"use strict";
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var FudgeCore;
(function (FudgeCore) {
    class PerformanceMonitor {
        static {
            window.addEventListener("load", () => PerformanceMonitor.display = document.body.appendChild(new PerformanceDisplay()));
        }
        static { this.measurements = {}; }
        static { this.framesToAverage = 60; }
        static measure(_name) {
            return (_value, _context) => {
                const name = _name ?? _context.name.toString();
                if (_context.kind === "method" || _context.kind === "getter") {
                    return function (..._args) {
                        PerformanceMonitor.startMeasure(name);
                        const result = _value.call(this, ..._args);
                        PerformanceMonitor.endMeasure(name);
                        return result;
                    };
                }
                if (_context.kind === "field") {
                    return function (_initialValue) {
                        if (typeof _initialValue != "function")
                            return _initialValue;
                        const replacement = function (..._args) {
                            PerformanceMonitor.startMeasure(name);
                            const result = _initialValue.call(this, ..._args);
                            PerformanceMonitor.endMeasure(name);
                            return result;
                        };
                        return replacement;
                    };
                }
                return null;
            };
        }
        static startMeasure(_label) {
            if (!this.measurements[_label]) {
                this.measurements[_label] = {
                    frameTimeMin: Number.MAX_VALUE,
                    frameTimeMax: -Number.MAX_VALUE,
                    frameTimeAvg: 0,
                    callsPerFrame: 0,
                    time: 0,
                    calls: 0
                };
            }
            this.measurements[_label].start = performance.now();
        }
        static endMeasure(_label) {
            const measurement = this.measurements[_label];
            if (!measurement?.start)
                return 0;
            const duration = performance.now() - measurement.start;
            measurement.time += duration;
            measurement.calls++;
            return duration;
        }
        static startFrame() {
            PerformanceMonitor.startMeasure("Frame");
            for (const label in this.measurements) {
                this.measurements[label].time = 0;
                this.measurements[label].calls = 0;
            }
        }
        static endFrame() {
            PerformanceMonitor.endMeasure("Frame");
            for (const label in this.measurements) {
                const measurement = this.measurements[label];
                if (measurement.calls > 0) {
                    const frameTotal = measurement.time;
                    measurement.frameTimeMin = Math.min(measurement.frameTimeMin, frameTotal);
                    measurement.frameTimeMax = Math.max(measurement.frameTimeMax, frameTotal);
                    measurement.frameTimeAvg = ((this.framesToAverage - 1) * measurement.frameTimeAvg + frameTotal) / this.framesToAverage;
                    measurement.callsPerFrame = measurement.calls;
                }
            }
        }
    }
    FudgeCore.PerformanceMonitor = PerformanceMonitor;
    class PerformanceDisplay extends HTMLPreElement {
        constructor() {
            super();
            this.update = () => {
                let longestString = Object.keys(PerformanceMonitor.measurements).reduce((_a, _b) => _a.length > _b.length ? _a : _b).length;
                let text = `${"Performance Monitor".padEnd(longestString)} |  time  |  calls\n`;
                for (let key in PerformanceMonitor.measurements) {
                    let measurement = PerformanceMonitor.measurements[key];
                    let avg = measurement.frameTimeAvg.toFixed(2).padStart(4);
                    let calls = measurement.callsPerFrame.toString().padStart(3);
                    text += `${key.padEnd(longestString)} | ${avg}ms | ${calls}cpf\n`;
                }
                this.textContent = text;
            };
            this.style.cssText = `
      font-family: Consolas, "Courier New", monospace;
      font-weight: bold;
      color: yellow;
      text-shadow: -1px -1px 0 black, 1px -1px 0 black, -1px 1px 0 black, 1px 1px 0 black;
      padding: 0.2rem;
      margin: 0;
      background: rgba(0, 0, 0, 0.7);
      width: min-content;
      position: absolute;
      left: 0;
      top: 0;
      z-index: 1000;
      pointer-events: none;`;
            FudgeCore.Loop.addEventListener("loopFrame" /* EVENT.LOOP_FRAME */, this.update);
        }
    }
    FudgeCore.PerformanceDisplay = PerformanceDisplay;
    customElements.define("ui-performance", PerformanceDisplay, { extends: "pre" });
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for the different DebugTargets, mainly for technical purpose of inheritance
     */
    class DebugTarget {
        /**
         * Merge the given message and arguments into a single string, separated by ', '
         */
        static mergeArguments(_message, ..._args) {
            let out = _message.toString(); //JSON.stringify(_message);
            for (let arg of _args)
                if (arg instanceof Number)
                    out += ", " + arg.toPrecision(2).toString(); //JSON.stringify(arg, null, 2);
                else
                    out += ", " + arg.toString(); //JSON.stringify(arg, null, 2);
            return out;
        }
    }
    FudgeCore.DebugTarget = DebugTarget;
})(FudgeCore || (FudgeCore = {}));
// <reference path="DebugAlert.ts"/>
var FudgeCore;
// <reference path="DebugAlert.ts"/>
(function (FudgeCore) {
    /**
     * The filters corresponding to debug activities, more to come
     */
    let DEBUG_FILTER;
    (function (DEBUG_FILTER) {
        DEBUG_FILTER[DEBUG_FILTER["NONE"] = 0] = "NONE";
        DEBUG_FILTER[DEBUG_FILTER["INFO"] = 1] = "INFO";
        DEBUG_FILTER[DEBUG_FILTER["LOG"] = 2] = "LOG";
        DEBUG_FILTER[DEBUG_FILTER["WARN"] = 4] = "WARN";
        DEBUG_FILTER[DEBUG_FILTER["ERROR"] = 8] = "ERROR";
        DEBUG_FILTER[DEBUG_FILTER["FUDGE"] = 16] = "FUDGE";
        DEBUG_FILTER[DEBUG_FILTER["CLEAR"] = 256] = "CLEAR";
        DEBUG_FILTER[DEBUG_FILTER["GROUP"] = 257] = "GROUP";
        DEBUG_FILTER[DEBUG_FILTER["GROUPCOLLAPSED"] = 258] = "GROUPCOLLAPSED";
        DEBUG_FILTER[DEBUG_FILTER["GROUPEND"] = 260] = "GROUPEND";
        DEBUG_FILTER[DEBUG_FILTER["SOURCE"] = 512] = "SOURCE";
        DEBUG_FILTER[DEBUG_FILTER["MESSAGES"] = 31] = "MESSAGES";
        DEBUG_FILTER[DEBUG_FILTER["FORMAT"] = 263] = "FORMAT";
        DEBUG_FILTER[DEBUG_FILTER["ALL"] = 287] = "ALL";
    })(DEBUG_FILTER = FudgeCore.DEBUG_FILTER || (FudgeCore.DEBUG_FILTER = {}));
    FudgeCore.DEBUG_SYMBOL = {
        [DEBUG_FILTER.INFO]: "‚úì",
        [DEBUG_FILTER.LOG]: "‚úé",
        [DEBUG_FILTER.WARN]: "‚ö†",
        [DEBUG_FILTER.ERROR]: "‚ùå",
        [DEBUG_FILTER.FUDGE]: "üé≤",
        [DEBUG_FILTER.SOURCE]: "üîó"
    };
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the standard-console
     */
    class DebugConsole extends FudgeCore.DebugTarget {
        static { this.delegates = {
            [FudgeCore.DEBUG_FILTER.INFO]: console.info,
            [FudgeCore.DEBUG_FILTER.LOG]: console.log,
            [FudgeCore.DEBUG_FILTER.WARN]: console.warn,
            [FudgeCore.DEBUG_FILTER.ERROR]: console.error,
            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugConsole.fudge,
            [FudgeCore.DEBUG_FILTER.CLEAR]: console.clear,
            [FudgeCore.DEBUG_FILTER.GROUP]: console.group,
            [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: console.groupCollapsed,
            [FudgeCore.DEBUG_FILTER.GROUPEND]: console.groupEnd,
            [FudgeCore.DEBUG_FILTER.SOURCE]: DebugConsole.source
        }; }
        /**
         * Should be used to display uncritical state information of FUDGE, only visible in browser's verbose mode
         */
        static fudge(_message, ..._args) {
            console.debug(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE], _message, ..._args);
        }
        /**
         * Displays an extra line with information about the source of the debug message
         */
        static source(_message, ..._args) {
            console.log(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE], _message, ..._args);
        }
    }
    FudgeCore.DebugConsole = DebugConsole;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
(function (FudgeCore) {
    /**
     * The Debug-Class offers functions known from the console-object and additions,
     * routing the information to various {@link DebugTarget}s that can be easily defined by the developers and registerd by users
     * Override functions in subclasses of {@link DebugTarget} and register them as their delegates
     */
    class Debug {
        /**
         * For each set filter, this associative array keeps references to the registered delegate functions of the chosen {@link DebugTarget}s
         */
        static { this.delegates = Debug.setupConsole(); }
        /**
         * De- / Activate a filter for the given DebugTarget.
         */
        static setFilter(_target, _filter) {
            for (let filter in Debug.delegates)
                Debug.delegates[filter].delete(_target);
            for (let filter in FudgeCore.DEBUG_FILTER) {
                let parsed = parseInt(filter);
                if (isNaN(parsed))
                    break;
                if ([FudgeCore.DEBUG_FILTER.MESSAGES, FudgeCore.DEBUG_FILTER.FORMAT, FudgeCore.DEBUG_FILTER.ALL].indexOf(parsed) != -1)
                    // dont delegate combos... 
                    continue;
                if (_filter & parsed)
                    Debug.delegates[parsed].set(_target, _target.delegates[parsed]);
            }
        }
        /**
         * Get the filter(s) for the given DebugTarget.
         */
        static getFilter(_target) {
            let result = 0;
            for (let filter in _target.delegates)
                result |= parseInt(filter);
            return result;
        }
        /**
         * Add a filter to the given DebugTarget.
         */
        static addFilter(_target, _filter) {
            let current = Debug.getFilter(_target);
            Debug.setFilter(_target, current | _filter);
        }
        /**
         * Remove a filter from the given DebugTarget.
         */
        static removeFilter(_target, _filter) {
            let current = Debug.getFilter(_target);
            Debug.setFilter(_target, current ^ _filter);
        }
        /**
         * Info(...) displays additional information with low priority
         */
        static info(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.INFO, _message, _args);
        }
        /**
         * Displays information with medium priority
         */
        static log(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.LOG, _message, _args);
        }
        /**
         * Displays information about non-conformities in usage, which is emphasized e.g. by color
         */
        static warn(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.WARN, _message, _args);
        }
        /**
         * Displays critical information about failures, which is emphasized e.g. by color
         */
        static error(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.ERROR, _message, _args);
        }
        /**
         * Displays messages from FUDGE
         */
        static fudge(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.FUDGE, _message, _args);
        }
        /**
         * Clears the output and removes previous messages if possible
         */
        static clear() {
            Debug.delegate(FudgeCore.DEBUG_FILTER.CLEAR, null, null);
        }
        /**
         * Opens a new group for messages
         */
        static group(_name) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUP, _name, null);
        }
        /**
         * Opens a new group for messages that is collapsed at first
         */
        static groupCollapsed(_name) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, _name, null);
        }
        /**
         * Closes the youngest group
         */
        static groupEnd() {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPEND, null, null);
        }
        /**
         * Log a branch of the node hierarchy
         */
        static branch(_branch) {
            if (_branch.nChildren > 0)
                Debug.group(_branch.name);
            else
                Debug.fudge(_branch.name);
            for (let child of _branch.getChildren())
                Debug.branch(child);
            if (_branch.nChildren > 0)
                Debug.groupEnd();
        }
        /**
         * Displays messages about the source of the debug call
         */
        static source(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.SOURCE, _message, _args);
        }
        /**
         * Lookup all delegates registered to the filter and call them using the given arguments
         */
        static delegate(_filter, _message, _args) {
            if (_filter == FudgeCore.DEBUG_FILTER.LOG || _filter == FudgeCore.DEBUG_FILTER.WARN || _filter == FudgeCore.DEBUG_FILTER.ERROR) {
                if (Debug.delegates[FudgeCore.DEBUG_FILTER.SOURCE])
                    for (let delegate of Debug.delegates[FudgeCore.DEBUG_FILTER.SOURCE].values())
                        if (delegate) {
                            let trace = new Error("Test").stack.split("\n");
                            delegate(trace[3]);
                        }
            }
            let delegates = Debug.delegates[_filter];
            for (let delegate of delegates.values())
                if (delegate)
                    if (_args && _args.length > 0)
                        delegate(_message, ..._args);
                    else
                        delegate(_message);
        }
        /**
         * setup routing to standard console
         */
        static setupConsole() {
            let result = {};
            let filters = [
                FudgeCore.DEBUG_FILTER.INFO, FudgeCore.DEBUG_FILTER.LOG, FudgeCore.DEBUG_FILTER.WARN, FudgeCore.DEBUG_FILTER.ERROR, FudgeCore.DEBUG_FILTER.FUDGE,
                FudgeCore.DEBUG_FILTER.CLEAR, FudgeCore.DEBUG_FILTER.GROUP, FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, FudgeCore.DEBUG_FILTER.GROUPEND,
                FudgeCore.DEBUG_FILTER.SOURCE
            ];
            for (let filter of filters)
                result[filter] = new Map([[FudgeCore.DebugConsole, FudgeCore.DebugConsole.delegates[filter]]]);
            result[FudgeCore.DEBUG_FILTER.SOURCE].delete(FudgeCore.DebugConsole);
            return result;
        }
    }
    FudgeCore.Debug = Debug;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Extends EventTarget to work with {@link EventListenerUnified} and {@link EventUnified} */
    class EventTargetUnified extends EventTarget {
        /**
         * See {@link EventTarget.addEventListener} for reference. Works with {@link EventListenerUnified} and {@link EventUnified}
         */
        addEventListener(_type, _handler, _options) {
            super.addEventListener(_type, _handler, _options);
        }
        /**
         * See {@link EventTarget.removeEventListener} for reference. Works with {@link EventListenerUnified} and {@link EventUnified}
         */
        removeEventListener(_type, _handler, _options) {
            super.removeEventListener(_type, _handler, _options);
        }
        /**
         * See {@link EventTarget.dispatchEvent} for reference. Works with with {@link EventUnified}
         */
        dispatchEvent(_event) {
            return super.dispatchEvent(_event);
        }
    }
    FudgeCore.EventTargetUnified = EventTargetUnified;
    /**
     * Base class for EventTarget singletons, which are fixed entities in the structure of FUDGE, such as the core loop
     */
    class EventTargetStatic extends EventTargetUnified {
        static { this.targetStatic = new EventTargetStatic(); }
        constructor() {
            super();
        }
        /**
         * Add an event listener to {@link targetStatic}.
         */
        static addEventListener(_type, _handler, _options) {
            EventTargetStatic.targetStatic.addEventListener(_type, _handler);
        }
        /**
         * Remove an event listener from {@link targetStatic}.
         */
        static removeEventListener(_type, _handler, _options) {
            EventTargetStatic.targetStatic.removeEventListener(_type, _handler);
        }
        /**
         * Dispatch an event on {@link targetStatic}.
         */
        static dispatchEvent(_event) {
            EventTargetStatic.targetStatic.dispatchEvent(_event);
            return true;
        }
    }
    FudgeCore.EventTargetStatic = EventTargetStatic;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // export interface MutatorForComponent extends Mutator { readonly forUserComponent: null; }
    /**
     * Collect applicable attributes of the instance and copies of their values in a Mutator-object
     */
    function getMutatorOfArbitrary(_object) {
        let mutator = {};
        let attributes = Reflect.ownKeys(Reflect.getPrototypeOf(_object));
        for (let attribute of attributes) {
            let value = Reflect.get(_object, attribute);
            if (value instanceof Function)
                continue;
            // if (value instanceof Object && !(value instanceof Mutable))
            //   continue;
            mutator[attribute.toString()] = value;
        }
        return mutator;
    }
    FudgeCore.getMutatorOfArbitrary = getMutatorOfArbitrary;
    // @ts-ignore - as of now we need to polyfill the symbol to make decorator metadata work, see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#decorator-metadata
    Symbol.metadata ??= Symbol("Symbol.metadata");
    function type(_constructor) {
        return (_value, _context) => {
            let meta = _context.metadata;
            if (!Object.hasOwn(meta, "attributeTypes"))
                meta.attributeTypes = { ...meta.attributeTypes };
            meta.attributeTypes[_context.name] = _constructor;
        };
    }
    FudgeCore.type = type;
    function enumerate(_value, _context) {
        // _context.addInitializer(function (this: unknown) { // this is run per instance... ideally we would want to run this once per class
        //   const prototype: unknown = Object.getPrototypeOf(this);
        //   const descriptor: PropertyDescriptor = Object.getOwnPropertyDescriptor(prototype, _context.name);
        //   if (descriptor && descriptor.enumerable == false)
        //     Object.defineProperty(prototype, _context.name, { enumerable: true });
        // });
        let metadata = _context.metadata;
        if (_context.kind == "getter" || _context.kind == "accessor") {
            if (typeof _context.name != "string")
                return;
            if (!Object.hasOwn(metadata, "enumerableKeys"))
                metadata.enumerateKeys = [];
            metadata.enumerateKeys.push(_context.name.toString());
            return;
        }
        if (_context.kind == "class") {
            if (metadata.enumerateKeys)
                for (const key of metadata.enumerateKeys)
                    Object.defineProperty(_value.prototype, key, { enumerable: true });
            return;
        }
    }
    FudgeCore.enumerate = enumerate;
    /**
     * Base class for all types that are mutable using {@link Mutator}-objects, thus providing and using interfaces created at runtime.
     *
     * Mutables provide a {@link Mutator} built by collecting all their applicable enumerable properties. By default, this includes only primitive types and nested mutable objects.
     * Using the {@link type}-decorator can also include non-mutable objects, which will be displayed via their {@link toString} method in the editor.
     *
     * Subclasses can either reduce the standard {@link Mutator} built by this base class by deleting properties or implement an individual getMutator method.
     * The provided properties of the {@link Mutator} must match public properties or getters/setters of the object.
     * Otherwise, they will be ignored unless handled by an override of the mutate method in the subclass, and will throw errors in an automatically generated user interface for the object.
     */
    class Mutable extends FudgeCore.EventTargetUnified {
        /**
         * Decorator allows to attach {@link Mutable} functionality to existing classes.
         */
        // public static decorate(_constructor: Function): void {
        //   Object.defineProperty(_constructor.prototype, "useRenderData", {
        //     value: function getMutator(this: MutableForUserInterface): Mutator {
        //       return getMutatorOfArbitrary(this);
        //     }
        //   });
        // }
        static getMutatorFromPath(_mutator, _path) {
            let key = _path[0];
            let mutator = {};
            if (_mutator[key] == undefined) // if the path deviates from mutator structure, return the mutator
                return _mutator;
            mutator[key] = _mutator[key];
            if (_path.length > 1)
                mutator[key] = Mutable.getMutatorFromPath(mutator[key], _path.slice(1, _path.length));
            return mutator;
        }
        /**
         * Retrieves the type of this mutable subclass as the name of the runtime class
         * @returns The type of the mutable
         */
        get type() {
            return this.constructor.name;
        }
        /**
         * Collect applicable attributes of the instance and copies of their values in a Mutator-object.
         * By default, a mutator cannot be extended, since extensions are not available in the object the mutator belongs to.
         * A mutator may be reduced by the descendants of {@link Mutable} to contain only the properties needed.
         */
        getMutator(_extendable = false) {
            let mutator = {};
            // collect primitive and mutable attributes
            for (let attribute in this) {
                let value = this[attribute];
                if (value instanceof Function)
                    continue;
                if (value instanceof Object && !(value instanceof Mutable) && !(value instanceof FudgeCore.MutableArray) && !(value.hasOwnProperty("idResource")) && this.getMetaAttributeTypes()[attribute] == undefined)
                    continue;
                mutator[attribute] = value;
            }
            if (!_extendable)
                // mutator can be reduced but not extended!
                Object.preventExtensions(mutator);
            // delete unwanted attributes
            this.reduceMutator(mutator);
            // replace references to mutable objects with references to mutators
            for (let attribute in mutator) {
                let value = mutator[attribute];
                if (value instanceof Mutable)
                    mutator[attribute] = value.getMutator();
                if (value instanceof FudgeCore.MutableArray)
                    mutator[attribute] = value.map((_value) => _value.getMutator());
            }
            return mutator;
        }
        /**
         * Collect the attributes of the instance and their values applicable for animation.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForAnimation(_extendable = false) {
            return this.getMutator(_extendable);
        }
        /**
         * Collect the attributes of the instance and their values applicable for the user interface.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForUserInterface(_extendable = false) {
            return this.getMutator(_extendable); // TODO: both of these (this and getMutatorForAnimation) don't really work as they don't recursively call getMutatorForUserInterface on sub-mutable objects, maybe instead implement a reduceMutatorForUserInterface???
        }
        /**
         * Collect the attributes of the instance and their values applicable for indiviualization by the component.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        // public getMutatorForComponent(): MutatorForComponent {
        //     return <MutatorForComponent>this.getMutator();
        // }
        /**
         * Returns an associative array with the same attributes as the given mutator, but with the corresponding types as string-values.
         * Does not recurse into objects! This will return the decorated {@link Metadata meta-type} instead of the runtime-type of the object, if available.
         */
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            let metaTypes = this.getMetaAttributeTypes();
            for (let attribute in _mutator) {
                let metaType = metaTypes[attribute]; // constructor or enum
                let type;
                if (typeof metaType == "function")
                    type = metaType.name;
                else if (typeof metaType == "object")
                    type = metaType;
                let value = _mutator[attribute];
                if (value != undefined && type == undefined)
                    if (typeof value == "object")
                        type = this[attribute].constructor.name;
                    else if (typeof value == "function")
                        type = value.name;
                    else
                        type = value.constructor.name;
                types[attribute] = type;
            }
            return types;
        }
        /**
         * Retrieves the specified {@link Metadata.attributeTypes | attribute types} from the {@link Metadata | metadata} of this instance's class.
         */
        getMetaAttributeTypes() {
            return this.getMetadata().attributeTypes ??= {};
        }
        /**
         * Retrieves the {@link Metadata | metadata} of this instance's class.
         */
        getMetadata() {
            return this.constructor[Symbol.metadata] ??= {};
        }
        /**
         * Updates the values of the given mutator according to the current state of the instance
         * @param _mutator
         */
        updateMutator(_mutator) {
            for (let attribute in _mutator) {
                let value = Reflect.get(this, attribute);
                if (value instanceof Mutable)
                    value.updateMutator(_mutator[attribute]);
                else
                    _mutator[attribute] = value;
            }
        }
        /**
         * Updates the attribute values of the instance according to the state of the mutator.
         * The mutation may be restricted to a subset of the mutator and the event dispatching suppressed.
         * Uses mutateBase, but can be overwritten in subclasses
         */
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            await this.mutateBase(_mutator, _selection);
            if (_dispatchMutate)
                this.dispatchEvent(new CustomEvent("mutate" /* EVENT.MUTATE */, { bubbles: true, detail: { mutator: _mutator } }));
        }
        /**
         * Base method for mutation, always available to subclasses. Do not overwrite in subclasses!
         */
        async mutateBase(_mutator, _selection) {
            let mutator = _mutator;
            if (_selection) { // TODO: this doesn't work as it does not recurse into objects
                mutator = {};
                for (let attribute of _selection) // reduce the mutator to the selection
                    if (typeof (_mutator[attribute]) !== "undefined")
                        mutator[attribute] = _mutator[attribute];
            }
            for (let attribute in mutator) {
                if (!Reflect.has(this, attribute))
                    continue;
                let mutant = Reflect.get(this, attribute);
                let value = mutator[attribute];
                if (mutant instanceof FudgeCore.MutableArray || mutant instanceof Mutable)
                    await mutant.mutate(value, null, false);
                else
                    Reflect.set(this, attribute, value);
            }
        }
    }
    FudgeCore.Mutable = Mutable;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Abstract class serving as a base for interface-like pure abstract classes that work with the "instanceof"-operator.
     *
     * **Usage**:
     * * Create a pure abstract class that extends {@link Implementable} that will serve as your interface. Specify the required attributes and methods within it as abstract.
     * * Use your abstract class via the `implements` keyword exactly how you would use a regular `interface`.
     * * Decorate the class that implements your abstract class using the static `YOUR_ABSTRACT_CLASS`.{@link register} method.
     * * Now you can use the `instanceof`-operator with your abstract class.
     *
     * **Example**:
     * ```typescript
     * import ∆í = FudgeCore;
     *
     * abstract class MyInterface extends ∆í.Implementable {
     *   public abstract myAttribute: string;
     *   public abstract myMethod(): void;
     * }
     *
     * @MyInterface.register
     * class MyClass implements MyInterface {
     *   public myAttribute: string;
     *   public myMethod(): void {}
     * }
     *
     * let myInstance: MyInterface = new MyClass();
     * console.log(myInstance instanceof MyInterface); // true
     * console.log(MyClass.prototype instanceof MyInterface); // true
     * ```
     */
    class Implementable {
        static register(_class, _context) {
            let meta = _context.metadata;
            if (!Object.hasOwn(meta, "implements"))
                meta.implements = new Set(meta.implements);
            let implement = this;
            while (implement != Implementable) {
                meta.implements.add(implement);
                implement = Object.getPrototypeOf(implement);
            }
        }
        static [Symbol.hasInstance](_instance) {
            let meta = _instance.constructor[Symbol.metadata];
            return meta?.implements?.has(this);
        }
    }
    FudgeCore.Implementable = Implementable;
    function serialize(_constructor, _context) {
        // decorate class
        if (_context) {
            let meta = _context.metadata;
            const prototype = _constructor.prototype;
            // make getters enumerable
            if (meta.enumerateKeys)
                for (const key of meta.enumerateKeys)
                    Object.defineProperty(prototype, key, { enumerable: true });
            // override serialize and deserialize methods
            const originalSerialize = prototype.serialize;
            const originalDeserialize = prototype.deserialize;
            const serializables = meta.serializables;
            prototype.serialize = function () {
                const serialization = originalSerialize?.call(this) ?? {};
                for (const key in serializables) {
                    let value = Reflect.get(this, key);
                    if (value == null)
                        continue;
                    switch (serializables[key]) {
                        case "primitive":
                            serialization[key] = value;
                            break;
                        case "serializable":
                            serialization[key] = value.serialize();
                            break;
                        case "resource":
                            serialization[key] = value.idResource;
                            break;
                        case "node":
                            serialization[key] = FudgeCore.Node.PATH_FROM_TO(this, value);
                            break;
                    }
                }
                return serialization;
            };
            prototype.deserialize = async function (_serialization) {
                if (originalDeserialize)
                    await originalDeserialize.call(this, _serialization);
                for (const key in serializables) {
                    let value = _serialization[key];
                    if (value == null)
                        continue;
                    switch (serializables[key]) {
                        case "primitive":
                            Reflect.set(this, key, value);
                            break;
                        case "serializable":
                            await Reflect.get(this, key).deserialize(value);
                            break;
                        case "resource":
                            Reflect.set(this, key, FudgeCore.Project.resources[value] ?? await FudgeCore.Project.getResource(value)); // await is costly so first try to get resource directly
                            break;
                        case "node":
                            let instance = this;
                            const hndNodeDeserialized = () => {
                                const hndGraphDeserialized = (_event) => {
                                    Reflect.set(this, key, FudgeCore.Node.FIND(instance, value));
                                    instance.node.removeEventListener("graphDeserialized" /* EVENT.GRAPH_DESERIALIZED */, hndGraphDeserialized, true);
                                    instance.node.removeEventListener("graphInstantiated" /* EVENT.GRAPH_INSTANTIATED */, hndGraphDeserialized, true);
                                    instance.removeEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
                                };
                                instance.node.addEventListener("graphDeserialized" /* EVENT.GRAPH_DESERIALIZED */, hndGraphDeserialized, true);
                                instance.node.addEventListener("graphInstantiated" /* EVENT.GRAPH_INSTANTIATED */, hndGraphDeserialized, true);
                            };
                            instance.addEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
                    }
                }
                return this;
            };
            return;
        }
        // decorate property
        return (_value, _context) => {
            if (typeof _context.name != "string")
                return;
            let meta = _context.metadata;
            // add attribute type to metadata
            if (!Object.hasOwn(meta, "attributeTypes"))
                meta.attributeTypes = { ...meta.attributeTypes };
            meta.attributeTypes[_context.name] = _constructor;
            // determine serialization type and add to metadata
            let type;
            if (_constructor == String || _constructor == Number || _constructor == Boolean || typeof _constructor == "object") // primitive or enum
                type = "primitive";
            else if (_constructor == FudgeCore.Node)
                type = "node";
            else if (_constructor.prototype instanceof FudgeCore.SerializableResource)
                type = "resource";
            else if (_constructor.prototype.serialize && _constructor.prototype.deserialize)
                type = "serializable";
            if (!type)
                return;
            if (!Object.hasOwn(meta, "serializables"))
                meta.serializables = { ...meta.serializables };
            meta.serializables[_context.name] = type;
            if (_context.kind != "getter")
                return;
            // mark getter to be made enumerable
            if (!Object.hasOwn(meta, "enumerableKeys"))
                meta.enumerateKeys = [];
            meta.enumerateKeys.push(_context.name.toString());
        };
    }
    FudgeCore.serialize = serialize;
    /**
     * Handles the external serialization and deserialization of {@link Serializable} objects. The internal process is handled by the objects themselves.
     * A {@link Serialization} object can be created from a {@link Serializable} object and a JSON-String may be created from that.
     * Vice versa, a JSON-String can be parsed to a {@link Serialization} which can be deserialized to a {@link Serializable} object.
     * ```text
     *  [Serializable] ‚Üí (serialize) ‚Üí [Serialization] ‚Üí (stringify) ‚Üí [String] ‚Üí (save or send)
     *                                        ‚Üì                            ‚Üì                  ‚Üì
     *                [Serializable] ‚Üê (deserialize) ‚Üê [Serialization] ‚Üê (parse) ‚Üê (load) ‚Üê [Medium]
     * ```
     * While the internal serialize/deserialize method1s of the objects care of the selection of information needed to recreate the object and its structure,
     * the {@link Serializer} keeps track of the namespaces and classes in order to recreate {@link Serializable} objects. The general structure of a {@link Serialization} is as follows
     * ```text
     * {
     *      namespaceName.className: {
     *          propertyName: propertyValue,
     *          ...,
     *          propertyNameOfReference: SerializationOfTheReferencedObject,
     *          ...,
     *          constructorNameOfSuperclass: SerializationOfSuperClass
     *      }
     * }
     * ```
     * Since the instance of the superclass is created automatically when an object is created,
     * the SerializationOfSuperClass omits the the namespaceName.className key and consists only of its value.
     * The constructorNameOfSuperclass is given instead as a property name in the serialization of the subclass.
     */
    class Serializer {
        /** In order for the Serializer to create class instances, it needs access to the appropriate namespaces */
        static { this.namespaces = { "∆í": FudgeCore }; }
        /**
         * Registers a namespace to the {@link Serializer}, to enable automatic instantiation of classes defined within
         */
        static registerNamespace(_namespace) {
            for (let name in Serializer.namespaces)
                if (Serializer.namespaces[name] == _namespace)
                    return name;
            let name = Serializer.findNamespaceIn(_namespace, window);
            if (!name)
                for (let parentName in Serializer.namespaces) {
                    name = Serializer.findNamespaceIn(_namespace, Serializer.namespaces[parentName]);
                    if (name) {
                        name = parentName + "." + name;
                        break;
                    }
                }
            if (!name)
                throw new Error("Namespace not found. Maybe parent namespace hasn't been registered before?");
            Serializer.namespaces[name] = _namespace;
            return name;
        }
        /**
         * Returns a javascript object representing the serializable FUDGE-object given,
         * including attached components, children, superclass-objects all information needed for reconstruction
         * @param _object An object to serialize, implementing the {@link Serializable} interface
         */
        static serialize(_object) {
            // TODO: save the namespace with the constructors name
            let path = this.getFullPath(_object);
            if (!path)
                throw new Error(`Namespace of serializable object of type ${_object.constructor.name} not found. Maybe the namespace hasn't been registered or the class not exported?`);
            return { [path]: _object.serialize() };
        }
        /**
         * Returns a FUDGE-object reconstructed from the information in the {@link Serialization} given,
         * including attached components, children, superclass-objects
         */
        static async deserialize(_serialization) {
            let reconstruct;
            let path;
            try {
                // loop constructed solely to access type-property. Only one expected!
                for (path in _serialization) {
                    reconstruct = Serializer.reconstruct(path);
                    reconstruct = await reconstruct.deserialize(_serialization[path]);
                    return reconstruct;
                }
            }
            catch (_error) {
                let message = `Deserialization of ${path}, ${reconstruct ? Reflect.get(reconstruct, "idResource") : ""} failed: ` + _error;
                throw new Error(message);
            }
            return null;
        }
        /**
         * Returns an Array of javascript object representing the serializable FUDGE-objects given in the array,
         * including attached components, children, superclass-objects all information needed for reconstruction
         */
        static serializeArray(_type, _objects) {
            let serializations = [];
            let path = this.getFullPath(new _type());
            if (!path)
                throw new Error(`Namespace of serializable object of type ${_type.name} not found. Maybe the namespace hasn't been registered or the class not exported?`);
            for (let object of _objects)
                serializations.push(object.serialize());
            let serialization = {};
            serialization[path] = serializations;
            return serialization;
        }
        /**
         * Returns an Array of FUDGE-objects reconstructed from the information in the array of {@link Serialization}s given,
         * including attached components, children, superclass-objects
         */
        static async deserializeArray(_serialization) {
            let serializables = [];
            let construct;
            let serializations = [];
            try {
                // loop constructed solely to access type-property. Only one expected!
                for (let path in _serialization) {
                    construct = Serializer.getConstructor(path);
                    serializations = _serialization[path];
                    break;
                }
            }
            catch (_error) {
                throw new Error("Deserialization failed: " + _error);
            }
            for (let serialization of serializations) {
                let serializable = new construct();
                await serializable.deserialize(serialization);
                serializables.push(serializable);
            }
            return serializables;
        }
        //TODO: implement prettifier to make JSON-Stringification of serializations more readable, e.g. placing x, y and z in one line
        /**
         * Prettify a JSON-String, to make it more readable.
         * not implemented yet
         */
        static prettify(_json) { return _json; }
        /**
         * Returns a formatted, human readable JSON-String, representing the given {@link Serialization} that may have been created by {@link Serializer}.serialize
         * @param _serialization
         */
        static stringify(_serialization) {
            // adjustments to serialization can be made here before stringification, if desired
            let json = JSON.stringify(_serialization, null, 2);
            let pretty = Serializer.prettify(json);
            return pretty;
        }
        /**
         * Returns a {@link Serialization} created from the given JSON-String. Result may be passed to {@link Serializer.deserialize}
         * @param _json
         */
        static parse(_json) {
            return JSON.parse(_json);
        }
        /**
         * Creates an object of the class defined with the full path including the namespaceName(s) and the className seperated by dots(.)
         * @param _path
         */
        static reconstruct(_path) {
            let constructor = Serializer.getConstructor(_path);
            let reconstruction = new constructor();
            return reconstruction;
        }
        // public static getConstructor<T extends Serializable>(_type: string, _namespace: Object = FudgeCore): new () => T {
        /**
         * Returns the constructor from the given path to a class
         */
        static getConstructor(_path) {
            let typeName = _path.substring(_path.lastIndexOf(".") + 1);
            let namespace = Serializer.getNamespace(_path);
            if (!namespace)
                throw new Error(`Constructor of serializable object of type ${_path} not found. Maybe the namespace hasn't been registered?`);
            return namespace[typeName];
        }
        /**
         * Returns the full path to the class of the object, if found in the registered namespaces
         * @param _object
         */
        static getFullPath(_object) {
            let typeName = _object.constructor.name;
            // Debug.log("Searching namespace of: " + typeName);
            for (let namespaceName in Serializer.namespaces) {
                let found = Serializer.namespaces[namespaceName][typeName];
                if (found && _object instanceof found)
                    return namespaceName + "." + typeName;
            }
            return null;
        }
        /**
         * Returns the namespace-object defined within the full path, if registered
         * @param _path
         */
        static getNamespace(_path) {
            let namespaceName = _path.substr(0, _path.lastIndexOf("."));
            return Serializer.namespaces[namespaceName] || FudgeCore;
        }
        /**
         * Finds the namespace-object in properties of the parent-object (e.g. window), if present
         * @param _namespace
         * @param _parent
         */
        static findNamespaceIn(_namespace, _parent) {
            for (let prop in _parent)
                if (_parent[prop] == _namespace)
                    return prop;
            return null;
        }
    }
    FudgeCore.Serializer = Serializer;
    /**
     * Creates a new (abstract) class implementing {@link SerializableResourceExternal} from any class that implements {@link SerializableResource} by mixing in the functionality to load the resource from an external source.
     * @internal
     * @authors Jonas Plotzky, HFU, 2024
     */
    function mixinSerializableResourceExternal(_base) {
        class SerializableResourceExternalMixin extends _base {
            constructor() {
                super(...arguments);
                this.status = FudgeCore.RESOURCE_STATUS.PENDING;
            }
            /**
             * Returns a {@link Serialization} of this resource. Only the data needed to load it from the external source is serialized ("url", "name", "idResource").
             */
            serialize() {
                const serialization = {
                    idResource: this.idResource,
                    name: this.name,
                    type: this.type,
                    url: this.url.toString()
                };
                return serialization;
            }
            async deserialize(_serialization) {
                FudgeCore.Project.register(this, _serialization.idResource);
                this.url = _serialization.url;
                this.name = _serialization.name;
                return this.load();
            }
        }
        ;
        if (_base.prototype instanceof FudgeCore.Mutable) {
            /**
             * Mixin the {@link Mutable} functionality into the class
             * @authors Jonas Plotzky, HFU, 2024
             */
            function mixinMutableSerializableResourceExternal(_base) {
                class MutableSerializableResourceExternal extends _base {
                    async mutate(_mutator, _selection = null, _dispatchMutate = true) {
                        await super.mutate(_mutator, _selection, false);
                        if (_mutator.url != undefined || _mutator.name != undefined)
                            await this.load();
                    }
                    reduceMutator(_mutator) {
                        delete _mutator.status;
                    }
                }
                return MutableSerializableResourceExternal;
            }
            return mixinMutableSerializableResourceExternal(SerializableResourceExternalMixin);
        }
        return SerializableResourceExternalMixin;
    }
    FudgeCore.mixinSerializableResourceExternal = mixinSerializableResourceExternal;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Manages uniform data to be transmitted during rendering. All data is collected in one contiguous buffer and sent to the GPU in a single operation.
     * @internal
     * @authors Jonas Plotzky, HFU, 2025
     */
    class RenderBufferManager {
        constructor(_blockBinding, _blockSize, _maxObjects) {
            this.mapObjectToOffset = new WeakMap(); // Maps the objects to their respective byte offset in the gpu buffer
            this.count = 0;
            this.blockSize = _blockSize;
            this.blockBinding = _blockBinding;
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            const alignment = crc3.getParameter(WebGL2RenderingContext.UNIFORM_BUFFER_OFFSET_ALIGNMENT);
            this.spaceBuffer = Math.ceil(this.blockSize / alignment) * alignment; // round to multiple of alignment
            this.spaceData = this.spaceBuffer / Float32Array.BYTES_PER_ELEMENT;
            this.data = new Float32Array(this.spaceData * _maxObjects);
            this.buffer = FudgeCore.RenderWebGL.assert(crc3.createBuffer());
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, this.buffer);
            crc3.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, this.data.byteLength, WebGL2RenderingContext.DYNAMIC_DRAW);
        }
        static get instance() {
            Object.defineProperty(this, "instance", {
                //@ts-ignore
                value: new this()
            });
            return this.instance;
        }
        /** @internal Reroutes the decorated static method to the instance method of the **same name** of this manager‚Äôs singleton instance */
        static decorate(_method, _context) {
            const method = Reflect.get(this.instance, _context.name);
            return method.bind(this.instance);
        }
        resetRenderData() {
            this.count = 0;
        }
        updateRenderbuffer() {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, this.buffer);
            crc3.bufferSubData(WebGL2RenderingContext.UNIFORM_BUFFER, 0, this.data, 0, this.count * this.spaceData);
        }
        useRenderData(_object) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindBufferRange(WebGL2RenderingContext.UNIFORM_BUFFER, this.blockBinding, this.buffer, this.mapObjectToOffset.get(_object), this.blockSize);
        }
        store(_object) {
            const offsetData = this.count * this.spaceData;
            this.mapObjectToOffset.set(_object, this.count * this.spaceBuffer); // offset in bytes
            this.count++;
            if (offsetData + this.spaceData > this.data.length)
                this.grow();
            return offsetData;
        }
        grow() {
            const data = new Float32Array(this.data.length * 1.5);
            data.set(this.data);
            this.data = data;
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, this.buffer);
            crc3.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, this.data.byteLength, WebGL2RenderingContext.DYNAMIC_DRAW);
        }
    }
    FudgeCore.RenderBufferManager = RenderBufferManager;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Manages {@link Coat} data to be transmitted during rendering.
     * @internal
     * @authors Jonas Plotzky, HFU, 2025
     */
    class RenderManagerCoat extends FudgeCore.RenderBufferManager {
        constructor() {
            const maxMaterials = 128;
            const blockSize = (4 + 1 + 1 + 1 + 1 + 1) * 4; // vct4 color, float diffuse, float specular, float intensity, float metallic, float alphaClip
            super(FudgeCore.UNIFORM_BLOCK.MATERIAL.BINDING, blockSize, maxMaterials);
        }
        static decorate(_method, _context) {
            return super.decorate(_method, _context);
        }
        updateRenderData(_coat) {
            const offset = this.store(_coat);
            const data = this.data;
            if (_coat instanceof FudgeCore.CoatColored)
                data.set(_coat.color.get(), offset);
            if (_coat instanceof FudgeCore.CoatRemissive || _coat instanceof FudgeCore.CoatRemissiveTextured) {
                data[offset + 4] = _coat.diffuse;
                data[offset + 5] = _coat.specular;
                data[offset + 6] = _coat.intensity;
                data[offset + 7] = _coat.metallic;
            }
            data[offset + 8] = _coat.alphaClip;
        }
        useRenderData(_coat) {
            super.useRenderData(_coat);
            if (_coat instanceof FudgeCore.CoatTextured)
                _coat.texture.useRenderData(FudgeCore.TEXTURE_LOCATION.COLOR.UNIT);
            if (_coat instanceof FudgeCore.CoatRemissiveTexturedNormals)
                _coat.normalMap.useRenderData(FudgeCore.TEXTURE_LOCATION.NORMAL.UNIT);
            if (_coat instanceof FudgeCore.CoatToon)
                _coat.texToon.useRenderData(FudgeCore.TEXTURE_LOCATION.TOON.UNIT);
        }
    }
    FudgeCore.RenderManagerCoat = RenderManagerCoat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Manages {@link Node} data (data that is unique for each node, i.e. {@link Component} data) to be transmitted during rendering.
     * @internal
     * @authors Jonas Plotzky, HFU, 2025
     */
    class RenderManagerNode extends FudgeCore.RenderBufferManager {
        constructor() {
            const maxNodes = 256;
            const blockSize = (16 + 12 + 4 + 1 + 1 + 1 + 1 + 1 + 1) * 4; // mat4 mtxWorld, mat3 mtxPivot, vec4 color, float blendMode, float duration, float size, float time, bool faceCameraActive, bool faceCameraRestrict, 
            super(FudgeCore.UNIFORM_BLOCK.NODE.BINDING, blockSize, maxNodes);
        }
        static decorate(_method, _context) {
            return super.decorate(_method, _context);
        }
        updateRenderData(_node, _cmpMesh, _cmpMaterial, _cmpFaceCamera, _cmpParticleSystem) {
            const offset = this.store(_node);
            const data = this.data;
            // mtx world
            data.set(_cmpMesh.mtxWorld.getData(), offset);
            // mtx pivot
            let dataPivot = _cmpMaterial.mtxPivot.get();
            data[offset + 16] = dataPivot[0];
            data[offset + 17] = dataPivot[1];
            data[offset + 18] = dataPivot[2];
            // data[offsetPivot + 19] = padding
            data[offset + 20] = dataPivot[3];
            data[offset + 21] = dataPivot[4];
            data[offset + 22] = dataPivot[5];
            // data[offsetPivot + 23] = padding
            data[offset + 24] = dataPivot[6];
            data[offset + 25] = dataPivot[7];
            data[offset + 26] = dataPivot[8];
            // data[offsetPivot + 27] = padding
            // color
            let color = _cmpMaterial.clrPrimary;
            data[offset + 28] = color.r;
            data[offset + 29] = color.g;
            data[offset + 30] = color.b;
            data[offset + 31] = color.a;
            if (_cmpParticleSystem) {
                data[offset + 32] = _cmpParticleSystem.blendMode;
                data[offset + 33] = _cmpParticleSystem.duration;
                data[offset + 34] = _cmpParticleSystem.size;
                data[offset + 35] = _cmpParticleSystem.time;
                data[offset + 36] = _cmpFaceCamera?.isActive ? 1 : 0;
                data[offset + 37] = _cmpFaceCamera?.restrict ? 1 : 0;
            }
        }
        useRenderData(_node, _mtxWorldOverride) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            let offset = this.mapObjectToOffset.get(_node);
            crc3.bindBufferRange(WebGL2RenderingContext.UNIFORM_BUFFER, this.blockBinding, this.buffer, offset, this.blockSize);
            if (_mtxWorldOverride) // this is relatively slow, but since prepare has no camera information, we may need to override the world matrix here
                crc3.bufferSubData(WebGL2RenderingContext.UNIFORM_BUFFER, offset, _mtxWorldOverride.get());
        }
    }
    FudgeCore.RenderManagerNode = RenderManagerNode;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Gives WebGL Buffer the data from the {@link Shader}
     * @internal
     */
    class RenderInjectorShader {
        /**
         * Injects the functionality of this class into the constructor of the given {@link Shader}-subclass
         */
        static decorate(_constructor, _context) {
            Object.defineProperty(_constructor, _constructor.useProgram.name, {
                value: RenderInjectorShader.useProgram
            });
            Object.defineProperty(_constructor, _constructor.createProgram.name, {
                value: RenderInjectorShader.createProgram
            });
            Object.defineProperty(_constructor, _constructor.deleteProgram.name, {
                value: RenderInjectorShader.deleteProgram
            });
        }
        /**
         * Set this program to use as the active program in WebGL
         */
        static useProgram() {
            if (!this.program)
                this.createProgram();
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.useProgram(this.program);
        }
        /**
         * Deletes this program from WebGL, clearing the used memory on the GPU.
         */
        static deleteProgram() {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.program) {
                crc3.deleteProgram(this.program);
                delete this.uniforms;
                delete this.program;
            }
        }
        static createProgram() {
            FudgeCore.Debug.fudge("Create shader program", this.name);
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            let program = crc3.createProgram();
            try {
                let shdVertex = compileShader(this.getVertexShaderSource(), WebGL2RenderingContext.VERTEX_SHADER);
                let shdFragment = compileShader(this.getFragmentShaderSource(), WebGL2RenderingContext.FRAGMENT_SHADER);
                crc3.attachShader(program, FudgeCore.RenderWebGL.assert(shdVertex));
                crc3.attachShader(program, FudgeCore.RenderWebGL.assert(shdFragment));
                crc3.linkProgram(program);
                let error = FudgeCore.RenderWebGL.assert(crc3.getProgramInfoLog(program));
                if (error !== "") {
                    throw new Error("Error linking Shader: " + error);
                }
                this.program = program;
                this.uniforms = detectUniforms();
                bindUniformBlock(program, FudgeCore.UNIFORM_BLOCK.LIGHTS.NAME, FudgeCore.UNIFORM_BLOCK.LIGHTS.BINDING);
                bindUniformBlock(program, FudgeCore.UNIFORM_BLOCK.CAMERA.NAME, FudgeCore.UNIFORM_BLOCK.CAMERA.BINDING);
                bindUniformBlock(program, FudgeCore.UNIFORM_BLOCK.MATERIAL.NAME, FudgeCore.UNIFORM_BLOCK.MATERIAL.BINDING);
                bindUniformBlock(program, FudgeCore.UNIFORM_BLOCK.NODE.NAME, FudgeCore.UNIFORM_BLOCK.NODE.BINDING);
                bindUniformBlock(program, FudgeCore.UNIFORM_BLOCK.SKIN.NAME, FudgeCore.UNIFORM_BLOCK.SKIN.BINDING);
                bindUniformBlock(program, FudgeCore.UNIFORM_BLOCK.FOG.NAME, FudgeCore.UNIFORM_BLOCK.FOG.BINDING);
                crc3.useProgram(this.program);
                let uniform = this.uniforms[FudgeCore.TEXTURE_LOCATION.COLOR.UNIFORM];
                if (uniform)
                    crc3.uniform1i(uniform, FudgeCore.TEXTURE_LOCATION.COLOR.INDEX);
                uniform = this.uniforms[FudgeCore.TEXTURE_LOCATION.NORMAL.UNIFORM];
                if (uniform)
                    crc3.uniform1i(uniform, FudgeCore.TEXTURE_LOCATION.NORMAL.INDEX);
                uniform = this.uniforms[FudgeCore.TEXTURE_LOCATION.TOON.UNIFORM];
                if (uniform)
                    crc3.uniform1i(uniform, FudgeCore.TEXTURE_LOCATION.TOON.INDEX);
                uniform = this.uniforms[FudgeCore.TEXTURE_LOCATION.PARTICLE.UNIFORM];
                if (uniform)
                    crc3.uniform1i(uniform, FudgeCore.TEXTURE_LOCATION.PARTICLE.INDEX);
            }
            catch (_error) {
                FudgeCore.Debug.error(_error);
                debugger;
            }
            function compileShader(_shaderCode, _shaderType) {
                let webGLShader = crc3.createShader(_shaderType);
                crc3.shaderSource(webGLShader, _shaderCode);
                crc3.compileShader(webGLShader);
                let error = FudgeCore.RenderWebGL.assert(crc3.getShaderInfoLog(webGLShader));
                if (error !== "") {
                    FudgeCore.Debug.log(_shaderCode);
                    throw new Error("Error compiling shader: " + error);
                }
                // Check for any compilation errors.
                if (!crc3.getShaderParameter(webGLShader, WebGL2RenderingContext.COMPILE_STATUS)) {
                    alert(crc3.getShaderInfoLog(webGLShader));
                    return null;
                }
                return webGLShader;
            }
            function detectUniforms() {
                let detectedUniforms = {};
                let uniformCount = crc3.getProgramParameter(program, WebGL2RenderingContext.ACTIVE_UNIFORMS);
                for (let i = 0; i < uniformCount; i++) {
                    let info = FudgeCore.RenderWebGL.assert(crc3.getActiveUniform(program, i));
                    if (!info) {
                        break;
                    }
                    let location = crc3.getUniformLocation(program, info.name);
                    if (location)
                        detectedUniforms[info.name] = FudgeCore.RenderWebGL.assert(location);
                }
                return detectedUniforms;
            }
            function bindUniformBlock(_program, _uniformBlockName, _uniformBlockBinding) {
                let blockIndex = crc3.getUniformBlockIndex(_program, _uniformBlockName);
                if (blockIndex == WebGL2RenderingContext.INVALID_INDEX)
                    return;
                let referencedByVertexShader = crc3.getActiveUniformBlockParameter(_program, blockIndex, WebGL2RenderingContext.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER);
                let referencedByFragmentShader = crc3.getActiveUniformBlockParameter(_program, blockIndex, WebGL2RenderingContext.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER);
                if (!referencedByVertexShader && !referencedByFragmentShader)
                    return;
                crc3.uniformBlockBinding(_program, blockIndex, _uniformBlockBinding);
            }
        }
    }
    FudgeCore.RenderInjectorShader = RenderInjectorShader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Buffers the data from the {@link Mesh} into a WebGL Buffer
     * @internal
     */
    class RenderInjectorMesh {
        /**
         * Injects the functionality of this class into the constructor of the given {@link Mesh}-subclass
         */
        static decorate(_constructor, _context) {
            Object.defineProperty(_constructor.prototype, _constructor.prototype.useRenderBuffers.name, {
                value: RenderInjectorMesh.useRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, _constructor.prototype.getRenderBuffers.name, {
                value: RenderInjectorMesh.getRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, _constructor.prototype.deleteRenderBuffers.name, {
                value: RenderInjectorMesh.deleteRenderBuffers
            });
        }
        static getRenderBuffers() {
            let buffers = this.renderMesh.buffers;
            if (buffers)
                return buffers;
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            const vao = FudgeCore.RenderWebGL.assert(crc3.createVertexArray());
            crc3.bindVertexArray(vao);
            buffers = {
                indices: createBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.renderMesh.indices),
                positions: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.positions),
                normals: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.normals),
                textureUVs: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.textureUVs),
                colors: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.colors),
                tangents: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.tangents),
                nIndices: this.renderMesh.indices.length,
                vao: vao
            };
            if (this.renderMesh.bones)
                buffers.bones = createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.bones);
            if (this.renderMesh.weights)
                buffers.weights = createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.weights);
            setAttributeBuffer(buffers.positions, FudgeCore.SHADER_ATTRIBUTE.POSITION, 3, WebGL2RenderingContext.FLOAT);
            setAttributeBuffer(buffers.normals, FudgeCore.SHADER_ATTRIBUTE.NORMAL, 3, WebGL2RenderingContext.FLOAT);
            setAttributeBuffer(buffers.textureUVs, FudgeCore.SHADER_ATTRIBUTE.TEXCOORDS, 2, WebGL2RenderingContext.FLOAT);
            setAttributeBuffer(buffers.colors, FudgeCore.SHADER_ATTRIBUTE.COLOR, 4, WebGL2RenderingContext.FLOAT);
            setAttributeBuffer(buffers.tangents, FudgeCore.SHADER_ATTRIBUTE.TANGENT, 4, WebGL2RenderingContext.FLOAT);
            if (buffers.bones)
                setAttributeBuffer(buffers.bones, FudgeCore.SHADER_ATTRIBUTE.BONES, 4, WebGL2RenderingContext.UNSIGNED_BYTE);
            if (buffers.weights)
                setAttributeBuffer(buffers.weights, FudgeCore.SHADER_ATTRIBUTE.WEIGHTS, 4, WebGL2RenderingContext.FLOAT);
            return this.renderMesh.buffers = buffers;
            function createBuffer(_type, _array) {
                let buffer = FudgeCore.RenderWebGL.assert(crc3.createBuffer());
                crc3.bindBuffer(_type, buffer);
                crc3.bufferData(_type, _array, WebGL2RenderingContext.STATIC_DRAW);
                return buffer;
            }
            function setAttributeBuffer(_buffer, _location, _size, _type) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, _buffer);
                crc3.enableVertexAttribArray(_location);
                if (_type == WebGL2RenderingContext.FLOAT)
                    crc3.vertexAttribPointer(_location, _size, _type, false, 0, 0);
                if (_type == WebGL2RenderingContext.UNSIGNED_BYTE)
                    crc3.vertexAttribIPointer(_location, _size, _type, 0, 0);
            }
        }
        static useRenderBuffers() {
            const buffers = this.getRenderBuffers();
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindVertexArray(buffers.vao);
            return buffers;
        }
        static deleteRenderBuffers(_renderBuffers) {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (_renderBuffers) {
                crc3.deleteVertexArray(_renderBuffers.vao);
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null);
                crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, null);
                Object.values(_renderBuffers)
                    .filter(_value => _value instanceof WebGLBuffer)
                    .forEach(_buffer => crc3.deleteBuffer(_buffer));
            }
        }
    }
    FudgeCore.RenderInjectorMesh = RenderInjectorMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let ParticleData;
    (function (ParticleData) {
        let FUNCTION;
        (function (FUNCTION) {
            // VALUE = "value",
            FUNCTION["ADDITION"] = "addition";
            FUNCTION["SUBTRACTION"] = "subtraction";
            FUNCTION["MULTIPLICATION"] = "multiplication";
            FUNCTION["DIVISION"] = "division";
            FUNCTION["MODULO"] = "modulo";
            FUNCTION["POWER"] = "power";
            FUNCTION["POLYNOMIAL3"] = "polynomial3";
            FUNCTION["SQUARE_ROOT"] = "squareRoot";
            FUNCTION["RANDOM"] = "random";
            FUNCTION["RANDOM_RANGE"] = "randomRange";
        })(FUNCTION = ParticleData.FUNCTION || (ParticleData.FUNCTION = {}));
        ParticleData.FUNCTION_MINIMUM_PARAMETERS = {
            // [ParticleData.FUNCTION.VALUE]: 1,
            [ParticleData.FUNCTION.ADDITION]: 2,
            [ParticleData.FUNCTION.SUBTRACTION]: 2,
            [ParticleData.FUNCTION.MULTIPLICATION]: 2,
            [ParticleData.FUNCTION.DIVISION]: 2,
            [ParticleData.FUNCTION.MODULO]: 2,
            [ParticleData.FUNCTION.POWER]: 2,
            [ParticleData.FUNCTION.POLYNOMIAL3]: 5,
            [ParticleData.FUNCTION.SQUARE_ROOT]: 1,
            [ParticleData.FUNCTION.RANDOM]: 0,
            [ParticleData.FUNCTION.RANDOM_RANGE]: 2
        };
        ParticleData.PREDEFINED_VARIABLES = {
            systemDuration: "u_fParticleSystemDuration",
            systemSize: "u_fParticleSystemSize",
            systemTime: "u_fParticleSystemTime",
            particleId: "fParticleId"
        };
    })(ParticleData = FudgeCore.ParticleData || (FudgeCore.ParticleData = {}));
    /**
     * Compiles particle system shaders ({@link ShaderParticleSystem}) from shader universal derivates for WebGL
     * @authors Jonas Plotzky, HFU, 2022
     * @internal
     */
    class RenderInjectorShaderParticleSystem {
        static { this.FUNCTIONS = {
            // [ParticleData.FUNCTION.VALUE]: (_parameters: string[]) => {
            //   return `(${_parameters[0]})`;
            // },
            [ParticleData.FUNCTION.ADDITION]: (_parameters) => {
                return `(${_parameters.reduce((_accumulator, _value) => `${_accumulator} + ${_value}`)})`;
            },
            [ParticleData.FUNCTION.SUBTRACTION]: (_parameters) => {
                return `(${_parameters.reduce((_accumulator, _value) => `${_accumulator} - ${_value}`)})`;
            },
            [ParticleData.FUNCTION.MULTIPLICATION]: (_parameters) => {
                return `(${_parameters.reduce((_accumulator, _value) => `${_accumulator} * ${_value}`)})`;
            },
            [ParticleData.FUNCTION.DIVISION]: (_parameters) => {
                return `(${_parameters[0]} / ${_parameters[1]})`;
            },
            [ParticleData.FUNCTION.MODULO]: (_parameters) => {
                return `(${_parameters.reduce((_accumulator, _value) => `mod(${_accumulator}, ${_value})`)})`;
            },
            [ParticleData.FUNCTION.POWER]: (_parameters) => {
                return `pow(${_parameters[0]}, ${_parameters[1]})`;
            },
            [ParticleData.FUNCTION.POLYNOMIAL3]: (_parameters) => {
                let x = _parameters[0];
                let a = _parameters[1];
                let b = _parameters[2];
                let c = _parameters[3];
                let d = _parameters[4];
                return `(${a} * pow(${x}, 3.0) + ${b} * pow(${x}, 2.0) + ${c} * ${x} + ${d})`;
            },
            [ParticleData.FUNCTION.SQUARE_ROOT]: (_parameters) => {
                let x = _parameters[0];
                return `sqrt(${x})`;
            },
            [ParticleData.FUNCTION.RANDOM]: (_parameters) => {
                return `fetchRandomNumber(${(RenderInjectorShaderParticleSystem.randomNumberIndexOffset++).toFixed(0)}, iParticleSystemRandomNumbersSize, iParticleSystemRandomNumbersLength)`;
            },
            [ParticleData.FUNCTION.RANDOM_RANGE]: (_parameters) => {
                return `(${RenderInjectorShaderParticleSystem.FUNCTIONS["random"]()} * (${_parameters[1]} - ${_parameters[0]}) + ${_parameters[0]})`;
            }
        }; }
        static { this.randomNumberIndexOffset = 0; }
        static decorate(_constructor, _context) {
            FudgeCore.RenderInjectorShader.decorate(_constructor.prototype, _context);
            Object.defineProperty(_constructor.prototype, _constructor.prototype.getVertexShaderSource.name, {
                value: RenderInjectorShaderParticleSystem.getVertexShaderSource
            });
            Object.defineProperty(_constructor.prototype, _constructor.prototype.getFragmentShaderSource.name, {
                value: RenderInjectorShaderParticleSystem.getFragmentShaderSource
            });
        }
        /**
         * Generates the source code for the vertex shader of the {@link ShaderParticleSystem} from the set {@link ShaderParticleSystem.data} and the original {@link ShaderParticleSystem.vertexShaderSource}.
         */
        static getVertexShaderSource() {
            let data = this.data;
            let mtxLocal = data?.mtxLocal;
            let mtxWorld = data?.mtxWorld;
            RenderInjectorShaderParticleSystem.randomNumberIndexOffset = 0;
            let source = this.vertexShaderSource
                .replace("#version 300 es", `#version 300 es\n#define ${this.define[0]}${data.color ? "\n#define PARTICLE_COLOR" : ""}`)
                .replace("/*$variables*/", RenderInjectorShaderParticleSystem.generateVariables(data?.variables, data?.variableNames))
                .replace("/*$mtxLocal*/", RenderInjectorShaderParticleSystem.generateTransformations(mtxLocal, "Local"))
                .replace("/*$mtxLocal*/", mtxLocal && mtxLocal.length > 0 ? "* mtxLocal" : "")
                .replace("/*$mtxWorld*/", RenderInjectorShaderParticleSystem.generateTransformations(mtxWorld, "World"))
                .replace("/*$mtxWorld*/", mtxWorld && mtxWorld.length > 0 ? "mtxWorld *" : "")
                .replaceAll("/*$color*/", RenderInjectorShaderParticleSystem.generateColor(data?.color));
            return source;
        }
        /**
         * Generates the source code for the fragment shader of the {@link ShaderParticleSystem} from the set {@link ShaderParticleSystem.data} and the original {@link ShaderParticleSystem.fragmentShaderSource}.
         */
        static getFragmentShaderSource() {
            return this.fragmentShaderSource.replace("#version 300 es", `#version 300 es\n#define ${this.define[0]}${this.data.color ? "\n#define PARTICLE_COLOR" : ""}`);
        }
        //#region code generation
        static generateVariables(_variables, _variableNames) {
            if (!_variables)
                return "";
            return _variables
                .map((_variable, _index) => ({ name: "fParticleSystemVariable_" + _variableNames[_index], value: RenderInjectorShaderParticleSystem.generateExpression(_variable) }))
                .map(_variable => `float ${_variable.name} = ${_variable.value};`)
                .reduce((_accumulator, _code) => `${_accumulator}\n${_code}`, "");
        }
        static generateTransformations(_transformations, _localOrWorld) {
            if (!_transformations || _transformations.length == 0)
                return "";
            let transformations = _transformations
                .map(_data => {
                let isScale = _data.transformation === "scale";
                let [x, y, z] = [_data.parameters[0], _data.parameters[1], _data.parameters[2]]
                    .map((_value) => _value ? RenderInjectorShaderParticleSystem.generateExpression(_value) : (isScale ? "1.0" : "0.0"));
                return [_data.transformation, x, y, z];
            });
            let code = "";
            code += transformations
                .map(([_transformation, _x, _y, _z], _index) => {
                let rotateId = _index + _localOrWorld;
                if (_transformation == "rotate") {
                    let toRadians = (_value) => `${_value} * ${FudgeCore.Calc.deg2rad}`;
                    return `float fXRadians${rotateId} = ${toRadians(_x)};
              float fYRadians${rotateId} = ${toRadians(_y)};
              float fZRadians${rotateId} = ${toRadians(_z)};
              float fSinX${rotateId} = sin(fXRadians${rotateId});
              float fCosX${rotateId} = cos(fXRadians${rotateId}); 
              float fSinY${rotateId} = sin(fYRadians${rotateId});
              float fCosY${rotateId} = cos(fYRadians${rotateId});
              float fSinZ${rotateId} = sin(fZRadians${rotateId});
              float fCosZ${rotateId} = cos(fZRadians${rotateId});\n`;
                }
                else
                    return "";
            })
                .filter((_transformation) => _transformation != "")
                .reduce((_accumulator, _code) => `${_accumulator}\n${_code}`, "");
            code += "\n";
            code += `mat4 mtx${_localOrWorld} = `;
            code += transformations
                .map(([_transformation, _x, _y, _z], _index) => {
                let rotateId = _index + _localOrWorld;
                switch (_transformation) {
                    case "translate":
                        return `mat4(
              1.0, 0.0, 0.0, 0.0,
              0.0, 1.0, 0.0, 0.0,
              0.0, 0.0, 1.0, 0.0,
              ${_x}, ${_y}, ${_z}, 1.0)`;
                    case "rotate":
                        return `mat4(
              fCosZ${rotateId} * fCosY${rotateId}, fSinZ${rotateId} * fCosY${rotateId}, -fSinY${rotateId}, 0.0,
              fCosZ${rotateId} * fSinY${rotateId} * fSinX${rotateId} - fSinZ${rotateId} * fCosX${rotateId}, fSinZ${rotateId} * fSinY${rotateId} * fSinX${rotateId} + fCosZ${rotateId} * fCosX${rotateId}, fCosY${rotateId} * fSinX${rotateId}, 0.0,
              fCosZ${rotateId} * fSinY${rotateId} * fCosX${rotateId} + fSinZ${rotateId} * fSinX${rotateId}, fSinZ${rotateId} * fSinY${rotateId} * fCosX${rotateId} - fCosZ${rotateId} * fSinX${rotateId}, fCosY${rotateId} * fCosX${rotateId}, 0.0,
              0.0, 0.0, 0.0, 1.0
              )`;
                    case "scale":
                        return `mat4(
              ${_x}, 0.0, 0.0, 0.0,
              0.0, ${_y}, 0.0, 0.0,
              0.0, 0.0, ${_z}, 0.0,
              0.0, 0.0, 0.0, 1.0
              )`;
                    default:
                        throw `Error in ${FudgeCore.ParticleSystem.name}: "${_transformation}" is not a transformation`;
                }
            })
                .reduce((_accumulator, _code) => `${_accumulator} * \n${_code}`);
            code += ";\n";
            return code;
        }
        static generateColor(_color) {
            if (!_color)
                return "";
            let rgba = [_color[0], _color[1], _color[2], _color[3]]
                .map((_value) => _value ? RenderInjectorShaderParticleSystem.generateExpression(_value) : "1.0")
                .join(", ");
            return `vec4(${rgba});`;
        }
        static generateExpression(_expression) {
            if (ParticleData.isFunction(_expression)) {
                let parameters = [];
                for (let param of _expression.parameters) {
                    parameters.push(RenderInjectorShaderParticleSystem.generateExpression(param));
                }
                return RenderInjectorShaderParticleSystem.generateFunction(_expression.function, parameters);
            }
            if (ParticleData.isVariable(_expression)) {
                return ParticleData.PREDEFINED_VARIABLES[_expression.value] || "fParticleSystemVariable_" + _expression.value;
            }
            if (ParticleData.isConstant(_expression)) {
                let value = _expression.value.toString();
                return `${value}${value.includes(".") ? "" : ".0"}`;
            }
            if (ParticleData.isCode(_expression)) {
                let code = _expression.code
                    .replaceAll(/\b[a-zA-z]+\w*(?!\()\b/g, (_match) => ParticleData.PREDEFINED_VARIABLES[_match] || "fParticleSystemVariable_" + _match)
                    .replaceAll(/(?<!\.)\b\d+\b(?!\.)/g, (_match) => _match + ".0");
                code = RenderInjectorShaderParticleSystem.replaceFunctions(code);
                return code;
            }
            throw `Error in ${FudgeCore.ParticleSystem.name}: invalid node structure in particle system serialization`;
        }
        static generateFunction(_function, _parameters) {
            if (_parameters.length < ParticleData.FUNCTION_MINIMUM_PARAMETERS[_function])
                throw `Error in ${FudgeCore.ParticleSystem.name}: "${_function}" needs at least ${ParticleData.FUNCTION_MINIMUM_PARAMETERS[_function]} parameters`;
            if (Object.values(ParticleData.FUNCTION).includes(_function))
                return RenderInjectorShaderParticleSystem.FUNCTIONS[_function](_parameters);
            else
                throw `Error in ${FudgeCore.ParticleSystem.name}: "${_function}" is not an operation`;
        }
        static replaceFunctions(_code) {
            let functionRegex = /\b[a-zA-z_]+\w*\(/g;
            let match;
            while ((match = functionRegex.exec(_code)) != null) {
                let functionGenerator = RenderInjectorShaderParticleSystem.FUNCTIONS[match[0].slice(0, -1)];
                if (!functionGenerator)
                    continue;
                let commaIndices = [];
                let openBrackets = 1;
                let argumentsLastIndex = functionRegex.lastIndex;
                while (openBrackets > 0) {
                    switch (_code[argumentsLastIndex]) {
                        case "(":
                            openBrackets++;
                            break;
                        case ")":
                            openBrackets--;
                            break;
                        case ",":
                            if (openBrackets == 1)
                                commaIndices.push(argumentsLastIndex);
                            break;
                    }
                    argumentsLastIndex++;
                }
                let args = [functionRegex.lastIndex - 1, ...commaIndices, argumentsLastIndex - 1].reduce((_accumulator, _position, _index, _positions) => {
                    return _index == _positions.length - 1 ?
                        _accumulator :
                        _accumulator.concat(_code.slice(_position + 1, _positions[_index + 1]).trim());
                }, []);
                functionRegex.lastIndex = match.index;
                _code = `${_code.slice(0, match.index)}(${functionGenerator(args)})${_code.slice(argumentsLastIndex)}`;
            }
            return _code;
        }
    }
    FudgeCore.RenderInjectorShaderParticleSystem = RenderInjectorShaderParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Buffers the random number data for the particle system ({@link ComponentParticleSystem}) into a WebGL Texture
     * @authors Jonas Plotzky, HFU, 2022
     * @internal
     */
    class RenderInjectorComponentParticleSystem {
        /**
         * Replaces the decorated method with the static method of the same name of class. Used in {@link ComponentParticleSystem}
         */
        static decorate(_method, _context) {
            return Reflect.get(this, _context.name);
        }
        static useRenderData() {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.renderData) {
                crc3.activeTexture(FudgeCore.TEXTURE_LOCATION.PARTICLE.UNIT); // ATTENTION!: changing this id requires changing of corresponding id in particle render method, use ctrl + shift + f search!
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.renderData);
                return;
            }
            const texture = FudgeCore.Render.assert(crc3.createTexture());
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
            let textureSize = Math.ceil(Math.sqrt(this.size));
            textureSize = Math.min(textureSize, crc3.getParameter(crc3.MAX_TEXTURE_SIZE));
            // TODO: use internal random number generator, additionally maybe use a seed to make it possible to recreate the same random numbers
            let randomNumbers = [];
            for (let i = 0; i < textureSize * textureSize; i++)
                randomNumbers.push(Math.random());
            try {
                crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.R32F, textureSize, textureSize, 0, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT, Float32Array.from(randomNumbers));
            }
            catch (_error) {
                FudgeCore.Debug.error(_error);
            }
            crc3.texParameteri(crc3.TEXTURE_2D, crc3.TEXTURE_MIN_FILTER, crc3.NEAREST);
            crc3.texParameteri(crc3.TEXTURE_2D, crc3.TEXTURE_MAG_FILTER, crc3.NEAREST);
            this.renderData = texture;
            this.useRenderData();
        }
        static deleteRenderData() {
            if (!this.renderData)
                return;
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
            crc3.deleteTexture(this.renderData);
            delete this.renderData;
        }
    }
    FudgeCore.RenderInjectorComponentParticleSystem = RenderInjectorComponentParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Keeps a depot of objects that have been marked for reuse, sorted by type.
     * Using {@link Recycler} reduces load on the carbage collector and thus supports smooth performance.
     * @author Jirka Dell'Oro-Friedl, HFU, 2021
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Recycler
     */
    class Recycler {
        static { this.depot = {}; }
        /**
         * Fetches an object of the requested type from the depot, calls its recycle-method and returns it.
         * If the depot for that type is empty it returns a new object of the requested type.
         * @param _t The class identifier of the desired object
         */
        static get(_t) {
            let key = _t.name;
            let instances = Recycler.depot[key];
            if (instances && instances.length > 0) {
                let instance = instances.pop();
                instance.recycle?.();
                return instance;
            }
            else
                return new _t();
        }
        /**
         * Fetches an object of the requested type from the depot and returns it. ‚ö†Ô∏è**DOES NOT** call its recycle-method.
         * Faster than {@link Recycler.get}, but should be used with caution.
         */
        static reuse(_t) {
            return Recycler.depot[_t.name]?.pop() ?? new _t();
        }
        /**
         * Stores the object in the depot for later recycling. Users are responsible for throwing in objects that are about to loose scope and are not referenced by any other
         * @param _instance
         */
        static store(_instance) {
            // let key: string = _instance.constructor.name;
            // //Debug.log(key);
            // let instances: RecycableArray<Object> = RecyclerNew.depot[key] || new RecycableArray<Object>();
            // instances.push(_instance);
            // RecyclerNew.depot[key] = instances;
            // Debug.log(`ObjectManager.depot[${key}]: ${ObjectManager.depot[key].length}`);
            //Debug.log(this.depot);
            (Recycler.depot[_instance.constructor.name] ??= new FudgeCore.RecycableArray()).push(_instance);
        }
        /**
         * Stores the provided objects using the {@link Recycler.store} method
         */
        static storeMultiple(..._instances) {
            for (const instance of _instances)
                Recycler.store(instance);
        }
        /**
         * Emptys the depot of a given type, leaving the objects for the garbage collector. May result in a short stall when many objects were in
         * @param _t
         */
        static dump(_t) {
            Recycler.depot[_t.name] = new FudgeCore.RecycableArray();
        }
        /**
         * Emptys all depots, leaving all objects to the garbage collector. May result in a short stall when many objects were in
         */
        static dumpAll() {
            Recycler.depot = {};
        }
    }
    FudgeCore.Recycler = Recycler;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a twodimensional vector comprised of the components x and y
     * ```text
     *            +y
     *             |__ +x
     * ```
     * @authors Lukas Scheuerle, Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Vector2 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0) {
            super();
            this.set(_x, _y);
        }
        //#region Static
        /**
         * A shorthand for writing `new Vector2(0, 0)`.
         * @returns A new vector with the values (0, 0)
         */
        static ZERO() {
            const vector = FudgeCore.Recycler.reuse(Vector2);
            vector.set(0, 0);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(_scale, _scale)`.
         * @param _scale the scale of the vector. Default: 1
         */
        static ONE(_scale = 1) {
            const vector = FudgeCore.Recycler.reuse(Vector2);
            vector.set(_scale, _scale);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(x, 0)`.
         * @param _scale The number to write in the x coordinate. Default: 1
         * @returns A new vector with the values (_scale, 0)
         */
        static X(_scale = 1) {
            const vector = FudgeCore.Recycler.reuse(Vector2);
            vector.set(_scale, 0);
            return vector;
        }
        /**
         * A shorthand for writing `new Vector2(0, y)`.
         * @param _scale The number to write in the y coordinate. Default: 1
         * @returns A new vector with the values (0, _scale)
         */
        static Y(_scale = 1) {
            const vector = FudgeCore.Recycler.reuse(Vector2);
            vector.set(0, _scale);
            return vector;
        }
        /**
         * Creates and returns a vector through transformation of the given vector by the given matrix
         */
        static TRANSFORMATION(_vector, _mtxTransform, _includeTranslation = true) {
            const vector = FudgeCore.Recycler.reuse(Vector2);
            let m = _mtxTransform.get();
            vector.set(m[0] * _vector.x + m[3] * _vector.y, m[1] * _vector.x + m[4] * _vector.y);
            if (_includeTranslation)
                vector.add(_mtxTransform.translation);
            return vector;
        }
        /**
         * Creates and returns a vector which is a copy of the given vector scaled to the given length.
         */
        static NORMALIZATION(_vector, _length = 1) {
            let magnitudeSquared = _vector.magnitudeSquared;
            if (magnitudeSquared == 0)
                throw (new RangeError("Impossible normalization"));
            let vector = _vector.clone;
            vector.scale(_length / Math.sqrt(magnitudeSquared));
            return vector;
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor
         */
        static SCALE(_vector, _scale) {
            const vector = FudgeCore.Recycler.reuse(Vector2);
            vector.set(_vector.x * _scale, _vector.y * _scale);
            return vector;
        }
        /**
         * Returns the resulting vector attained by addition of all given vectors.
         */
        static SUM(..._vectors) {
            const result = FudgeCore.Recycler.get(Vector2);
            for (let vector of _vectors)
                result.set(result.x + vector.x, result.y + vector.y);
            return result;
        }
        /**
         * Returns the result of the subtraction of two vectors.
         */
        static DIFFERENCE(_minuend, _subtrahend) {
            const vector = FudgeCore.Recycler.reuse(Vector2);
            vector.set(_minuend.x - _subtrahend.x, _minuend.y - _subtrahend.y);
            return vector;
        }
        /**
         * Calculates the cross product of two Vectors. Due to them being only 2 Dimensional, the result is a single number,
         * which implicitly is on the Z axis. It is also the signed magnitude of the result.
         */
        static CROSS(_a, _b) {
            return _a.x * _b.y - _a.y * _b.x;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         */
        static DOT(_a, _b) {
            return _a.x * _b.x + _a.y * _b.y;
        }
        /**
         * Calculates the orthogonal vector to the given vector. Rotates counterclockwise by default.
         * ```text
         * ‚Üë => ‚Üê => ‚Üì => ‚Üí => ‚Üë
         * ```
         * @param _vector Vector to get the orthogonal equivalent of
         * @param _clockwise Should the rotation be clockwise instead of the default counterclockwise? default: false
         * @returns A Vector that is orthogonal to and has the same magnitude as the given Vector.
         */
        static ORTHOGONAL(_vector, _clockwise = false) {
            let result = FudgeCore.Recycler.reuse(Vector2);
            if (_clockwise)
                result.set(_vector.y, -_vector.x);
            else
                result.set(-_vector.y, _vector.x);
            return result;
        }
        /**
         * Creates a cartesian vector from polar coordinates
         */
        static GEO(_angle = 0, _magnitude = 1) {
            let vector = FudgeCore.Recycler.reuse(Vector2);
            let geo = FudgeCore.Recycler.reuse(FudgeCore.Geo2);
            geo.set(_angle, _magnitude);
            vector.geo = geo;
            FudgeCore.Recycler.store(geo);
            return vector;
        }
        //#endregion
        //#region Accessors
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.hypot(this.x, this.y);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector2.DOT(this, this);
        }
        /**
         * Returns a polar representation of this vector
         */
        get geo() {
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo2);
            geo.magnitude = this.magnitude;
            if (geo.magnitude === 0)
                return geo;
            geo.angle = 180 * Math.atan2(this.y / geo.magnitude, this.x / geo.magnitude) / Math.PI;
            return geo;
        }
        /**
         * Adjust the cartesian values of this vector to represent the given as polar coordinates
         */
        set geo(_geo) {
            this.set(_geo.magnitude, 0);
            this.transform(FudgeCore.Matrix3x3.ROTATION(_geo.angle));
        }
        /**
         * Creates and returns a clone of this vector.
         */
        get clone() {
            return FudgeCore.Recycler.reuse(Vector2).copy(this);
        }
        //#endregion
        /**
         * Copies the components of the given vector into this vector.
         */
        copy(_original) {
            return this.set(_original.x, _original.y);
        }
        recycle() {
            this.set(0, 0);
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            return true;
        }
        /**
         * Adds the given vector to the executing vector, changing the executor.
         * @param _addend The vector to add.
         */
        add(_addend) {
            this.x += _addend.x;
            this.y += _addend.y;
            return this;
        }
        /**
         * Subtracts the given vector from the executing vector, changing the executor.
         * @param _subtrahend The vector to subtract.
         */
        subtract(_subtrahend) {
            this.x -= _subtrahend.x;
            this.y -= _subtrahend.y;
            return this;
        }
        /**
         * Scales the Vector by the given _scalar.
         */
        scale(_scalar) {
            this.x *= _scalar;
            this.y *= _scalar;
            return this;
        }
        /**
         * Normalizes this to the given length, 1 by default
         */
        normalize(_length = 1) {
            return this.copy(Vector2.NORMALIZATION(this, _length));
        }
        /**
         * Sets the components of this vector.
         */
        set(_x = 0, _y = 0) {
            this.x = _x;
            this.y = _y;
            return this;
        }
        /**
         * Returns an array of the components of this vector.
         */
        get() {
            return new Float32Array([this.x, this.y]);
        }
        /**
         * Transforms this vector by the given matrix, including or exluding the translation.
         * Including is the default, excluding will only rotate and scale this vector.
         */
        transform(_mtxTransform, _includeTranslation = true) {
            let transformed = Vector2.TRANSFORMATION(this, _mtxTransform, _includeTranslation);
            this.copy(transformed);
            FudgeCore.Recycler.store(transformed);
            return this;
        }
        /**
         * For each dimension, moves the component to the minimum of this and the given vector
         */
        min(_compare) {
            this.x = Math.min(this.x, _compare.x);
            this.y = Math.min(this.y, _compare.y);
            return this;
        }
        /**
         * For each dimension, moves the component to the maximum of this and the given vector
         */
        max(_compare) {
            this.x = Math.max(this.x, _compare.x);
            this.y = Math.max(this.y, _compare.y);
            return this;
        }
        /**
         * Adds a z-component of the given magnitude (default=0) to the vector and returns a new Vector3
         */
        toVector3(_z = 0) {
            return new FudgeCore.Vector3(this.x, this.y, _z);
        }
        /**
         * Returns a formatted string representation of this vector
         */
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)})`;
            return result;
        }
        /**
         * Uses the standard array.map functionality to perform the given function on all components of this vector
         * and return a new vector with the results
         */
        map(_function) {
            let copy = FudgeCore.Recycler.get(Vector2);
            copy.set(...[this.x, this.y].map(_function));
            return copy;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator();
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.x}, ${this.y}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.x, this.y] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        getMutator() {
            let mutator = {
                x: this.x, y: this.y
            };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector2 = Vector2;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../Recycle/Recycler.ts"/>
///<reference path="Vector2.ts"/>
var FudgeCore;
///<reference path="../Recycle/Recycler.ts"/>
///<reference path="Vector2.ts"/>
(function (FudgeCore) {
    /**
     * Defines the origin of a rectangle
     */
    let ORIGIN2D;
    (function (ORIGIN2D) {
        ORIGIN2D[ORIGIN2D["TOPLEFT"] = 0] = "TOPLEFT";
        ORIGIN2D[ORIGIN2D["TOPCENTER"] = 1] = "TOPCENTER";
        ORIGIN2D[ORIGIN2D["TOPRIGHT"] = 2] = "TOPRIGHT";
        ORIGIN2D[ORIGIN2D["CENTERLEFT"] = 16] = "CENTERLEFT";
        ORIGIN2D[ORIGIN2D["CENTER"] = 17] = "CENTER";
        ORIGIN2D[ORIGIN2D["CENTERRIGHT"] = 18] = "CENTERRIGHT";
        ORIGIN2D[ORIGIN2D["BOTTOMLEFT"] = 32] = "BOTTOMLEFT";
        ORIGIN2D[ORIGIN2D["BOTTOMCENTER"] = 33] = "BOTTOMCENTER";
        ORIGIN2D[ORIGIN2D["BOTTOMRIGHT"] = 34] = "BOTTOMRIGHT";
    })(ORIGIN2D = FudgeCore.ORIGIN2D || (FudgeCore.ORIGIN2D = {}));
    /**
     * Defines a rectangle with position and size and add comfortable methods to it
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Rectangle extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            super();
            this.position = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.size = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.setPositionAndSize(_x, _y, _width, _height, _origin);
        }
        /**
         * Returns a new rectangle created with the given parameters
         */
        static GET(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            let rect = FudgeCore.Recycler.get(Rectangle);
            rect.setPositionAndSize(_x, _y, _width, _height);
            return rect;
        }
        get x() {
            return this.position.x;
        }
        get y() {
            return this.position.y;
        }
        get width() {
            return this.size.x;
        }
        get height() {
            return this.size.y;
        }
        /**
         * Return the leftmost expansion, respecting also negative values of width
         */
        get left() {
            if (this.size.x > 0)
                return this.position.x;
            return (this.position.x + this.size.x);
        }
        /**
         * Return the topmost expansion, respecting also negative values of height
         */
        get top() {
            if (this.size.y > 0)
                return this.position.y;
            return (this.position.y + this.size.y);
        }
        /**
         * Return the rightmost expansion, respecting also negative values of width
         */
        get right() {
            if (this.size.x > 0)
                return (this.position.x + this.size.x);
            return this.position.x;
        }
        /**
         * Return the lowest expansion, respecting also negative values of height
         */
        get bottom() {
            if (this.size.y > 0)
                return (this.position.y + this.size.y);
            return this.position.y;
        }
        set x(_x) {
            this.position.x = _x;
        }
        set y(_y) {
            this.position.y = _y;
        }
        set width(_width) {
            this.size.x = _width;
        }
        set height(_height) {
            this.size.y = _height;
        }
        set left(_value) {
            this.size.x = this.right - _value;
            this.position.x = _value;
        }
        set top(_value) {
            this.size.y = this.bottom - _value;
            this.position.y = _value;
        }
        set right(_value) {
            this.size.x = this.position.x + _value;
        }
        set bottom(_value) {
            this.size.y = this.position.y + _value;
        }
        get clone() {
            return Rectangle.GET(this.x, this.y, this.width, this.height);
        }
        recycle() {
            this.setPositionAndSize();
        }
        /**
         * Set this rectangle to the values given by the rectangle provided
         */
        copy(_rect) {
            this.setPositionAndSize(_rect.x, _rect.y, _rect.width, _rect.height);
        }
        /**
         * Sets the position and size of the rectangle according to the given parameters
         */
        setPositionAndSize(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            this.size.set(_width, _height);
            switch (_origin & 0x03) {
                case 0x00:
                    this.position.x = _x;
                    break;
                case 0x01:
                    this.position.x = _x - _width / 2;
                    break;
                case 0x02:
                    this.position.x = _x - _width;
                    break;
            }
            switch (_origin & 0x30) {
                case 0x00:
                    this.position.y = _y;
                    break;
                case 0x10:
                    this.position.y = _y - _height / 2;
                    break;
                case 0x20:
                    this.position.y = _y - _height;
                    break;
            }
        }
        /**
         * Transforms the given point from this rectangles space to the target rectangles space
         */
        pointToRect(_point, _target) {
            let result = _point.clone;
            result.subtract(this.position);
            result.x *= _target.width / this.width;
            result.y *= _target.height / this.height;
            result.add(_target.position);
            return result;
        }
        /**
         * Returns true if the given point is inside of this rectangle or on the border
         * @param _point
         */
        isInside(_point) {
            return (_point.x >= this.left && _point.x <= this.right && _point.y >= this.top && _point.y <= this.bottom);
        }
        /**
         * Returns true if this rectangle collides with the rectangle given
         * @param _rect
         */
        collides(_rect) {
            if (this.left > _rect.right)
                return false;
            if (this.right < _rect.left)
                return false;
            if (this.top > _rect.bottom)
                return false;
            if (this.bottom < _rect.top)
                return false;
            return true;
        }
        /**
         * Returns the rectangle created by the intersection of this and the given rectangle or null, if they don't collide
         */
        getIntersection(_rect) {
            if (!this.collides(_rect))
                return null;
            let intersection = new Rectangle();
            intersection.x = Math.max(this.left, _rect.left);
            intersection.y = Math.max(this.top, _rect.top);
            intersection.width = Math.min(this.right, _rect.right) - intersection.x;
            intersection.height = Math.min(this.bottom, _rect.bottom) - intersection.y;
            return intersection;
        }
        /**
     * Returns the rectangle created by the intersection of this and the given rectangle or null, if they don't collide
     */
        covers(_rect) {
            if (this.left > _rect.left)
                return false;
            if (this.right < _rect.right)
                return false;
            if (this.top > _rect.top)
                return false;
            if (this.bottom < _rect.bottom)
                return false;
            return true;
        }
        /**
         * Creates a string representation of this rectangle
         */
        toString() {
            let result = `∆í.Rectangle(position:${this.position.toString()}, size:${this.size.toString()}`;
            result += `, left:${this.left.toPrecision(5)}, top:${this.top.toPrecision(5)}, right:${this.right.toPrecision(5)}, bottom:${this.bottom.toPrecision(5)}`;
            return result;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Rectangle = Rectangle;
})(FudgeCore || (FudgeCore = {}));
///<reference path="RenderBufferManager.ts"/>
///<reference path="RenderManagerCoat.ts"/>
///<reference path="RenderManagerNode.ts"/>
///<reference path="RenderInjectorShader.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
///<reference path="RenderInjectorShaderParticleSystem.ts"/>
///<reference path="RenderInjectorComponentParticleSystem.ts"/>
///<reference path="../Math/Rectangle.ts"/>
var FudgeCore;
///<reference path="RenderBufferManager.ts"/>
///<reference path="RenderManagerCoat.ts"/>
///<reference path="RenderManagerNode.ts"/>
///<reference path="RenderInjectorShader.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
///<reference path="RenderInjectorShaderParticleSystem.ts"/>
///<reference path="RenderInjectorComponentParticleSystem.ts"/>
///<reference path="../Math/Rectangle.ts"/>
(function (FudgeCore) {
    // export declare let fudgeConfig: General;
    let BLEND;
    (function (BLEND) {
        BLEND[BLEND["OPAQUE"] = 0] = "OPAQUE";
        BLEND[BLEND["TRANSPARENT"] = 1] = "TRANSPARENT";
        BLEND[BLEND["ADDITIVE"] = 2] = "ADDITIVE";
        BLEND[BLEND["SUBTRACTIVE"] = 3] = "SUBTRACTIVE";
        BLEND[BLEND["MODULATE"] = 4] = "MODULATE";
    })(BLEND = FudgeCore.BLEND || (FudgeCore.BLEND = {}));
    let DEPTH_FUNCTION;
    (function (DEPTH_FUNCTION) {
        DEPTH_FUNCTION[DEPTH_FUNCTION["NEVER"] = 0] = "NEVER";
        DEPTH_FUNCTION[DEPTH_FUNCTION["LESS"] = 1] = "LESS";
        DEPTH_FUNCTION[DEPTH_FUNCTION["EQUAL"] = 2] = "EQUAL";
        DEPTH_FUNCTION[DEPTH_FUNCTION["LESS_EQUAL"] = 3] = "LESS_EQUAL";
        DEPTH_FUNCTION[DEPTH_FUNCTION["GREATER"] = 4] = "GREATER";
        DEPTH_FUNCTION[DEPTH_FUNCTION["NOT_EQUAL"] = 5] = "NOT_EQUAL";
        DEPTH_FUNCTION[DEPTH_FUNCTION["GREATER_EQUAL"] = 6] = "GREATER_EQUAL";
        DEPTH_FUNCTION[DEPTH_FUNCTION["ALWAYS"] = 7] = "ALWAYS";
    })(DEPTH_FUNCTION = FudgeCore.DEPTH_FUNCTION || (FudgeCore.DEPTH_FUNCTION = {}));
    let SHADER_ATTRIBUTE;
    (function (SHADER_ATTRIBUTE) {
        SHADER_ATTRIBUTE[SHADER_ATTRIBUTE["POSITION"] = 0] = "POSITION";
        SHADER_ATTRIBUTE[SHADER_ATTRIBUTE["NORMAL"] = 1] = "NORMAL";
        SHADER_ATTRIBUTE[SHADER_ATTRIBUTE["TEXCOORDS"] = 2] = "TEXCOORDS";
        SHADER_ATTRIBUTE[SHADER_ATTRIBUTE["COLOR"] = 3] = "COLOR";
        SHADER_ATTRIBUTE[SHADER_ATTRIBUTE["TANGENT"] = 4] = "TANGENT";
        SHADER_ATTRIBUTE[SHADER_ATTRIBUTE["BONES"] = 5] = "BONES";
        SHADER_ATTRIBUTE[SHADER_ATTRIBUTE["WEIGHTS"] = 6] = "WEIGHTS";
    })(SHADER_ATTRIBUTE = FudgeCore.SHADER_ATTRIBUTE || (FudgeCore.SHADER_ATTRIBUTE = {}));
    // we want type inference here so we can use vs code to search for references
    FudgeCore.UNIFORM_BLOCK = {
        LIGHTS: {
            NAME: "Lights",
            BINDING: 0
        },
        CAMERA: {
            NAME: "Camera",
            BINDING: 1
        },
        MATERIAL: {
            NAME: "Material",
            BINDING: 2
        },
        NODE: {
            NAME: "Node",
            BINDING: 3
        },
        SKIN: {
            NAME: "Skin",
            BINDING: 4
        },
        FOG: {
            NAME: "Fog",
            BINDING: 5
        }
    };
    FudgeCore.TEXTURE_LOCATION = {
        COLOR: {
            UNIFORM: "u_texColor",
            UNIT: WebGL2RenderingContext.TEXTURE0,
            INDEX: 0 // could compute these by UNIT - WebGL2RenderingContext.TEXTURE0 
        },
        NORMAL: {
            UNIFORM: "u_texNormal",
            UNIT: WebGL2RenderingContext.TEXTURE1,
            INDEX: 1
        },
        PARTICLE: {
            UNIFORM: "u_particleSystemRandomNumbers",
            UNIT: WebGL2RenderingContext.TEXTURE2,
            INDEX: 2
        },
        TEXT: {
            UNIFORM: "u_texText", // TODO: add text uniform to shader...
            UNIT: WebGL2RenderingContext.TEXTURE3,
            INDEX: 3
        },
        TOON: {
            UNIFORM: "u_texToon",
            UNIT: WebGL2RenderingContext.TEXTURE4,
            INDEX: 4
        }
    };
    /**
     * Base class for RenderManager, handling the connection to the rendering system, in this case WebGL.
     * Methods and attributes of this class should not be called directly, only through {@link Render}
     */
    let RenderWebGL = (() => {
        let _classSuper = FudgeCore.EventTargetStatic;
        let _staticExtraInitializers = [];
        let _static_drawAmbientOcclusion_decorators;
        let _static_drawBloom_decorators;
        return class RenderWebGL extends _classSuper {
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _static_drawAmbientOcclusion_decorators = [FudgeCore.PerformanceMonitor.measure()];
                _static_drawBloom_decorators = [FudgeCore.PerformanceMonitor.measure()];
                __esDecorate(this, null, _static_drawAmbientOcclusion_decorators, { kind: "method", name: "drawAmbientOcclusion", static: true, private: false, access: { has: obj => "drawAmbientOcclusion" in obj, get: obj => obj.drawAmbientOcclusion }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(this, null, _static_drawBloom_decorators, { kind: "method", name: "drawBloom", static: true, private: false, access: { has: obj => "drawBloom" in obj, get: obj => obj.drawBloom }, metadata: _metadata }, null, _staticExtraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.crc3 = (__runInitializers(this, _staticExtraInitializers), RenderWebGL.initialize()); }
            static { this.rectRender = RenderWebGL.getCanvasRect(); }
            /**
             * Initializes offscreen-canvas, renderingcontext and hardware viewport. Call once before creating any resources like meshes or shaders
             */
            static initialize(_antialias, _alpha) {
                let fudgeConfig = Reflect.get(globalThis, "fudgeConfig") || {};
                const antialias = (_antialias != undefined) ? _antialias : fudgeConfig.antialias || false;
                if (antialias)
                    FudgeCore.Debug.error("The default antialiasing is not compatible with the current post-processing effects and will therefore be disabled.");
                let contextAttributes = {
                    alpha: (_alpha != undefined) ? _alpha : fudgeConfig.alpha || false,
                    antialias: false,
                    premultipliedAlpha: false,
                    stencil: true
                };
                FudgeCore.Debug.fudge("Initialize RenderWebGL", contextAttributes);
                let canvas = document.createElement("canvas");
                let crc3;
                crc3 = RenderWebGL.assert(canvas.getContext("webgl2", contextAttributes), "WebGL-context couldn't be created");
                RenderWebGL.crc3 = crc3;
                // Enable backface- and zBuffer-culling.
                crc3.enable(WebGL2RenderingContext.CULL_FACE);
                crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
                crc3.enable(WebGL2RenderingContext.BLEND);
                RenderWebGL.setBlendMode(BLEND.TRANSPARENT);
                RenderWebGL.rectRender = RenderWebGL.getCanvasRect();
                RenderWebGL.initializeAttachments();
                RenderWebGL.adjustAttachments();
                RenderWebGL.initializeCamera();
                RenderWebGL.initializeLights();
                RenderWebGL.initializeFog();
                return crc3;
            }
            /**
            * Checks the first parameter and throws an exception with the WebGL-errorcode if the value is null
            * @param _value  value to check against null
            * @param _message  optional, additional message for the exception
            */
            static assert(_value, _message = "") {
                if (_value === null)
                    throw new Error(`Assertion failed. ${_message}, WebGL-Error: ${RenderWebGL.crc3 ? RenderWebGL.crc3.getError() : ""}`);
                return _value;
            }
            /**
             * Return a reference to the offscreen-canvas
             */
            static getCanvas() {
                return RenderWebGL.crc3.canvas; // TODO: enable OffscreenCanvas
            }
            /**
             * Return a reference to the rendering context
             */
            static getRenderingContext() {
                return RenderWebGL.crc3;
            }
            /**
             * Return a rectangle describing the size of the offscreen-canvas. x,y are 0 at all times.
             */
            static getCanvasRect() {
                let canvas = RenderWebGL.crc3.canvas;
                return FudgeCore.Rectangle.GET(0, 0, canvas.width, canvas.height);
            }
            /**
             * Set the size of the offscreen-canvas.
             */
            static setCanvasSize(_width, _height) {
                RenderWebGL.crc3.canvas.width = _width;
                RenderWebGL.crc3.canvas.height = _height;
            }
            /**
             * Set the area on the offscreen-canvas to render the camera image to.
             * @param _rect
             */
            static setRenderRectangle(_rect) {
                RenderWebGL.rectRender.setPositionAndSize(_rect.x, _rect.y, _rect.width, _rect.height);
                RenderWebGL.crc3.viewport(_rect.x, _rect.y, _rect.width, _rect.height);
            }
            /**
             * Clear the offscreen renderbuffer with the given {@link Color}
             */
            static clear(_color, _colors = true, _depth = true, _stencil = true) {
                RenderWebGL.crc3.clearColor(_color?.r ?? 0, _color?.g ?? 0, _color?.b ?? 0, _color?.a ?? 1);
                let mask = 0;
                if (_colors)
                    mask |= WebGL2RenderingContext.COLOR_BUFFER_BIT;
                if (_depth)
                    mask |= WebGL2RenderingContext.DEPTH_BUFFER_BIT;
                if (_stencil)
                    mask |= WebGL2RenderingContext.STENCIL_BUFFER_BIT;
                RenderWebGL.crc3.clear(mask);
            }
            /**
             * Set the final framebuffer to render to. If null, the canvas default framebuffer is used.
             * Used by XR to render to the XRWebGLLayer framebuffer.
             */
            static setFramebufferTarget(_buffer) {
                RenderWebGL.fboTarget = _buffer;
            }
            /**
             * Reset the framebuffer to the main color buffer.
             */
            static resetFramebuffer() {
                RenderWebGL.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboMain);
            }
            /**
             * Retrieve the area on the offscreen-canvas the camera image gets rendered to.
             */
            static getRenderRectangle() {
                return RenderWebGL.rectRender;
            }
            /**
             * Enable / Disable WebGLs depth test.
             */
            static setDepthTest(_test) {
                if (_test)
                    RenderWebGL.crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
                else
                    RenderWebGL.crc3.disable(WebGL2RenderingContext.DEPTH_TEST);
            }
            /**
             * Set the comparison operation used to test fragment depths against current depth buffer values.
             */
            static setDepthFunction(_function = DEPTH_FUNCTION.LESS) {
                RenderWebGL.crc3.depthFunc(_function + WebGL2RenderingContext.NEVER);
            }
            /**
             * Enable / Disable WebGLs scissor test.
             */
            static setScissorTest(_test, _x, _y, _width, _height) {
                if (_test)
                    RenderWebGL.crc3.enable(WebGL2RenderingContext.SCISSOR_TEST);
                else
                    RenderWebGL.crc3.disable(WebGL2RenderingContext.SCISSOR_TEST);
                RenderWebGL.crc3.scissor(_x, _y, _width, _height);
            }
            /**
             * Set which color components to enable or to disable when rendering to a color buffer.
             */
            static setColorWriteMask(_r, _g, _b, _a) {
                RenderWebGL.crc3.colorMask(_r, _g, _b, _a);
            }
            /**
             * Set WebGLs viewport.
             */
            static setViewport(_x, _y, _width, _height) {
                RenderWebGL.crc3.viewport(_x, _y, _width, _height);
            }
            /**
             * Set the blend mode to render with
             */
            static setBlendMode(_mode) {
                switch (_mode) {
                    case BLEND.OPAQUE:
                        RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
                        RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ZERO);
                        break;
                    case BLEND.TRANSPARENT:
                        RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
                        // RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                        RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                        break;
                    case BLEND.ADDITIVE:
                        RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
                        // RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE);
                        RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE);
                        break;
                    case BLEND.SUBTRACTIVE:
                        RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_REVERSE_SUBTRACT);
                        // RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE);
                        RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE);
                        break;
                    case BLEND.MODULATE: // color gets multiplied, tried to copy unitys "Particle Shader: Blending Option: Rendering Mode: Modulate"
                        RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
                        RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.DST_COLOR, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                    default:
                        break;
                }
            }
            /**
             * Read the (world) position from the pixel at the given point on the render-rectangle (origin top left).
             * ‚ö†Ô∏è CAUTION: Currently only works when ambient occlusion is active due to writing to the position texture being disabled otherwise.
             */
            static pointRenderToWorld(_render) {
                const crc3 = RenderWebGL.getRenderingContext();
                const data = new Float32Array(4);
                crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboMain);
                crc3.readBuffer(WebGL2RenderingContext.COLOR_ATTACHMENT1);
                crc3.readPixels(_render.x, RenderWebGL.rectRender.height - _render.y, 1, 1, crc3.RGBA, crc3.FLOAT, data);
                crc3.readBuffer(WebGL2RenderingContext.COLOR_ATTACHMENT0);
                let position = FudgeCore.Recycler.get(FudgeCore.Vector3);
                position.set(data[0], data[1], data[2]);
                return position;
            }
            /**
             * Initializes different framebuffers aswell as texture attachments to use as render targets
             */
            static initializeAttachments() {
                const crc3 = RenderWebGL.crc3;
                crc3.getExtension("EXT_color_buffer_float"); // TODO: disable ssao if not supported
                RenderWebGL.fboMain = RenderWebGL.assert(crc3.createFramebuffer());
                RenderWebGL.fboPost = RenderWebGL.assert(crc3.createFramebuffer());
                RenderWebGL.fboTarget = null;
                RenderWebGL.fboPick = RenderWebGL.assert(crc3.createFramebuffer());
                RenderWebGL.texColor = createTexture(WebGL2RenderingContext.NEAREST, WebGL2RenderingContext.CLAMP_TO_EDGE);
                RenderWebGL.texPosition = createTexture(WebGL2RenderingContext.NEAREST, WebGL2RenderingContext.CLAMP_TO_EDGE);
                RenderWebGL.texNormal = createTexture(WebGL2RenderingContext.LINEAR, WebGL2RenderingContext.CLAMP_TO_EDGE);
                RenderWebGL.texDepthStencil = createTexture(WebGL2RenderingContext.NEAREST, WebGL2RenderingContext.CLAMP_TO_EDGE);
                RenderWebGL.texNoise = createTexture(WebGL2RenderingContext.NEAREST, WebGL2RenderingContext.CLAMP_TO_EDGE);
                RenderWebGL.texPick = createTexture(WebGL2RenderingContext.NEAREST, WebGL2RenderingContext.CLAMP_TO_EDGE);
                RenderWebGL.texDepthPick = createTexture(WebGL2RenderingContext.NEAREST, WebGL2RenderingContext.CLAMP_TO_EDGE);
                RenderWebGL.texDepthStencilOutline = createTexture(WebGL2RenderingContext.NEAREST, WebGL2RenderingContext.CLAMP_TO_EDGE);
                RenderWebGL.texBloomSamples = new Array(6);
                for (let i = 0; i < RenderWebGL.texBloomSamples.length; i++)
                    RenderWebGL.texBloomSamples[i] = createTexture(WebGL2RenderingContext.LINEAR, WebGL2RenderingContext.CLAMP_TO_EDGE);
                crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboMain);
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texColor, 0);
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT1, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texPosition, 0);
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT2, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texNormal, 0);
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.DEPTH_STENCIL_ATTACHMENT, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texDepthStencil, 0);
                crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboPick);
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texPick, 0);
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.DEPTH_ATTACHMENT, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texDepthPick, 0);
                crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, null);
                function createTexture(_filter, _wrap) {
                    const texture = RenderWebGL.assert(crc3.createTexture());
                    crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
                    crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, _filter);
                    crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, _filter);
                    crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, _wrap);
                    crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, _wrap);
                    crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
                    return texture;
                }
            }
            /**
             * Adjusts the size of the different texture attachments (render targets) to the canvas size
             * ‚ö†Ô∏è CAUTION: Expensive operation, use only when canvas size changed
             */
            static adjustAttachments() {
                const crc3 = RenderWebGL.getRenderingContext();
                const width = crc3.canvas.width || 1;
                const height = crc3.canvas.height || 1;
                crc3.activeTexture(crc3.TEXTURE0);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texColor);
                crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, width, height, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, null);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texPosition);
                // In view space 16F would be precise enough... but we want to use world space for calculations
                crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA32F, width, height, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, null);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texNormal);
                crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA16F, width, height, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, null);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texDepthStencil);
                crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.DEPTH24_STENCIL8, width, height, 0, WebGL2RenderingContext.DEPTH_STENCIL, WebGL2RenderingContext.UNSIGNED_INT_24_8, null);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texDepthStencilOutline);
                crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.DEPTH24_STENCIL8, width, height, 0, WebGL2RenderingContext.DEPTH_STENCIL, WebGL2RenderingContext.UNSIGNED_INT_24_8, null);
                for (let i = 0, divisor = 1; i < RenderWebGL.texBloomSamples.length; i++, divisor *= 2) {
                    let width = Math.max(Math.round(crc3.canvas.width / divisor), 1);
                    let height = Math.max(Math.round(crc3.canvas.height / divisor), 1);
                    crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texBloomSamples[i]);
                    crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, width, height, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, null);
                }
                const nValues = width * height * 4;
                const noiseData = new Uint8Array(nValues);
                for (let i = 0; i < nValues; i += 4) {
                    noiseData[i] = Math.floor(Math.random() * 256);
                    noiseData[i + 1] = Math.floor(Math.random() * 256);
                    noiseData[i + 2] = Math.floor(Math.random() * 256);
                    noiseData[i + 3] = Math.floor(Math.random() * 256);
                }
                crc3.bindTexture(crc3.TEXTURE_2D, RenderWebGL.texNoise);
                crc3.texImage2D(crc3.TEXTURE_2D, 0, crc3.RGBA, width, height, 0, crc3.RGBA, crc3.UNSIGNED_BYTE, noiseData);
                crc3.bindTexture(crc3.TEXTURE_2D, null);
            }
            /**
             * Buffer the camera data into the camera ubo
             */
            static bufferCamera(_cmpCamera) {
                const crc3 = RenderWebGL.getRenderingContext();
                const mtxView = _cmpCamera.mtxCameraInverse;
                const mtxProjection = _cmpCamera.mtxProjection;
                const mtxViewProjection = _cmpCamera.mtxWorldToView;
                const vctPosition = _cmpCamera.mtxWorld.translation;
                const data = new Float32Array(16 + 16 + 16 + 3);
                data.set(mtxView.get(), 0);
                data.set(mtxProjection.get(), 16);
                data.set(mtxViewProjection.get(), 32);
                data.set(vctPosition.get(), 48);
                crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, RenderWebGL.uboCamera);
                crc3.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, data, WebGL2RenderingContext.DYNAMIC_DRAW);
            }
            static useNodeUniforms(_shader, _mtxWorld, _mtxPivot, _color, _id) {
                const crc3 = RenderWebGL.crc3;
                let uniform = _shader.uniforms["u_mtxMeshToWorld"];
                if (uniform && _mtxWorld)
                    crc3.uniformMatrix4fv(uniform, false, _mtxWorld.getData());
                uniform = _shader.uniforms["u_mtxPivot"];
                if (uniform && _mtxPivot)
                    crc3.uniformMatrix3fv(_shader.uniforms["u_mtxPivot"], false, _mtxPivot.getData());
                uniform = _shader.uniforms["u_vctColorPrimary"];
                if (uniform && _color)
                    crc3.uniform4fv(uniform, _color.get());
                uniform = _shader.uniforms["u_id"];
                if (uniform)
                    RenderWebGL.crc3.uniform1i(uniform, _id);
            }
            //#region Picking
            /**
             * Used with a {@link Picker}-camera, this method renders one pixel with picking information
             * for each pickable object in the line of sight and returns that as an unsorted array of {@link Pick}s.
             * The function to render the objects into the pick buffer must be provided by the caller.
             * @param _pick The function which renders objects into the pick buffer. Returns a {@link Pick} for each rendered object.
             * **MUST** use {@link ShaderPick} or {@link ShaderPickTextured} to render objects.
             */
            static pickFrom(_from, _cmpCamera, _pick) {
                const size = Math.ceil(Math.sqrt(_from.length));
                const crc3 = RenderWebGL.getRenderingContext();
                // adjust pick buffer size
                crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboPick);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texPick);
                crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA32I, size, size, 0, WebGL2RenderingContext.RGBA_INTEGER, WebGL2RenderingContext.INT, null); // could use RBGA32F in the future e.g. WebGPU
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texDepthPick);
                crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.DEPTH_COMPONENT24, size, size, 0, WebGL2RenderingContext.DEPTH_COMPONENT, WebGL2RenderingContext.UNSIGNED_INT, null);
                crc3.clear(WebGL2RenderingContext.DEPTH_BUFFER_BIT);
                RenderWebGL.bufferCamera(_cmpCamera);
                // buffer size into pick shaders
                FudgeCore.ShaderPick.useProgram();
                crc3.uniform2fv(FudgeCore.ShaderPick.uniforms["u_vctSize"], [size, size]);
                FudgeCore.ShaderPickTextured.useProgram();
                crc3.uniform2fv(FudgeCore.ShaderPickTextured.uniforms["u_vctSize"], [size, size]);
                // render picks into pick buffer
                RenderWebGL.setBlendMode(BLEND.OPAQUE);
                let picks = _pick(_from, _cmpCamera);
                RenderWebGL.setBlendMode(BLEND.TRANSPARENT);
                // get/filter picks
                // evaluate texture by reading pixels and extract, convert and store the information about each mesh hit
                let data = new Int32Array(size * size * 4);
                FudgeCore.Render.crc3.readPixels(0, 0, size, size, WebGL2RenderingContext.RGBA_INTEGER, WebGL2RenderingContext.INT, data);
                let picked = [];
                let mtxViewToWorld = FudgeCore.Matrix4x4.INVERSE(_cmpCamera.mtxWorldToView);
                for (let i = 0; i < picks.length; i++) {
                    let zBuffer = data[4 * i + 0] + data[4 * i + 1] / 256;
                    if (zBuffer == 0) // discard misses 
                        continue;
                    let pick = picks[i];
                    pick.zBuffer = convertInt32toFloat32(data, 4 * i + 0) * 2 - 1;
                    pick.color = convertInt32toColor(data, 4 * i + 1);
                    pick.textureUV = FudgeCore.Recycler.reuse(FudgeCore.Vector2);
                    pick.textureUV.set(convertInt32toFloat32(data, 4 * i + 2), convertInt32toFloat32(data, 4 * i + 3));
                    pick.mtxViewToWorld = mtxViewToWorld;
                    picked.push(pick);
                }
                RenderWebGL.resetFramebuffer();
                return picked;
                function convertInt32toFloat32(_int32Array, _index) {
                    let buffer = new ArrayBuffer(4);
                    let view = new DataView(buffer);
                    view.setInt32(0, _int32Array[_index]);
                    return view.getFloat32(0);
                }
                function convertInt32toColor(_int32Array, _index) {
                    let buffer = new ArrayBuffer(4);
                    let view = new DataView(buffer);
                    view.setInt32(0, _int32Array[_index]);
                    let color = FudgeCore.Color.CSS(`rgb(${view.getUint8(0)}, ${view.getUint8(1)}, ${view.getUint8(2)})`, view.getUint8(3) / 255);
                    return color;
                }
            }
            /**
             * The render function for picking nodes.
             * A cameraprojection with extremely narrow focus is used, so each pixel of the buffer would hold the same information from the node,
             * but the fragment shader renders only 1 pixel for each node into the render buffer, 1st node to 1st pixel, 2nd node to second pixel etc.
             */
            static pick(_nodes, _cmpCamera) {
                let picks = [];
                for (const node of _nodes) {
                    let cmpMesh = node.getComponent(FudgeCore.ComponentMesh);
                    let cmpMaterial = node.getComponent(FudgeCore.ComponentMaterial);
                    if (!(cmpMesh && cmpMesh.isActive && cmpMaterial && cmpMaterial.isActive))
                        continue;
                    let coat = cmpMaterial.material.coat;
                    let shader = coat instanceof FudgeCore.CoatTextured ? FudgeCore.ShaderPickTextured : FudgeCore.ShaderPick;
                    shader.useProgram();
                    coat.useRenderData();
                    let mtxMeshToWorld = RenderWebGL.faceCamera(node, cmpMesh.mtxWorld, _cmpCamera.mtxWorld);
                    RenderWebGL.useNodeUniforms(shader, mtxMeshToWorld, cmpMaterial.mtxPivot, cmpMaterial.clrPrimary, picks.length);
                    const renderBuffers = cmpMesh.mesh.useRenderBuffers();
                    RenderWebGL.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
                    picks.push(new FudgeCore.Pick(node));
                }
                return picks;
            }
            //#endregion
            static initializeCamera() {
                RenderWebGL.uboCamera = RenderWebGL.assert(RenderWebGL.crc3.createBuffer());
                RenderWebGL.crc3.bindBufferBase(WebGL2RenderingContext.UNIFORM_BUFFER, FudgeCore.UNIFORM_BLOCK.CAMERA.BINDING, RenderWebGL.uboCamera);
            }
            static initializeFog() {
                RenderWebGL.uboFog = RenderWebGL.assert(RenderWebGL.crc3.createBuffer());
                RenderWebGL.crc3.bindBufferBase(WebGL2RenderingContext.UNIFORM_BUFFER, FudgeCore.UNIFORM_BLOCK.FOG.BINDING, RenderWebGL.uboFog);
            }
            /**
             * Buffer the fog parameters into the fog ubo
             */
            static bufferFog(_cmpFog) {
                const crc3 = RenderWebGL.getRenderingContext();
                const data = new Float32Array(8);
                data[0] = _cmpFog?.isActive ? 1 : 0;
                if (_cmpFog) {
                    data[1] = _cmpFog.near;
                    data[2] = _cmpFog.far;
                    data.set(_cmpFog.color.get(), 4);
                }
                // buffer data to bound buffer
                crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, RenderWebGL.uboFog);
                crc3.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, data, WebGL2RenderingContext.DYNAMIC_DRAW);
            }
            static initializeLights() {
                const MAX_LIGHTS_DIRECTIONAL = 15; // must match the define in the shader
                const MAX_LIGHTS_POINT = 100;
                const MAX_LIGHTS_SPOT = 100;
                const BYTES_PER_LIGHT = Float32Array.BYTES_PER_ELEMENT * (4 + 16 + 16); // vctColor + mtxShape + mtxShapeInverse as float32s in shader
                RenderWebGL.uboLightsOffsets = {};
                RenderWebGL.uboLightsOffsets["u_nLightsDirectional"] = Uint32Array.BYTES_PER_ELEMENT * 0;
                RenderWebGL.uboLightsOffsets["u_nLightsPoint"] = Uint32Array.BYTES_PER_ELEMENT * 1;
                RenderWebGL.uboLightsOffsets["u_nLightsSpot"] = Uint32Array.BYTES_PER_ELEMENT * 2;
                RenderWebGL.uboLightsOffsets["u_ambient"] = Uint32Array.BYTES_PER_ELEMENT * 4;
                RenderWebGL.uboLightsOffsets["u_directional"] = RenderWebGL.uboLightsOffsets["u_ambient"] + BYTES_PER_LIGHT * 1;
                RenderWebGL.uboLightsOffsets["u_point"] = RenderWebGL.uboLightsOffsets["u_directional"] + BYTES_PER_LIGHT * MAX_LIGHTS_DIRECTIONAL;
                RenderWebGL.uboLightsOffsets["u_spot"] = RenderWebGL.uboLightsOffsets["u_point"] + BYTES_PER_LIGHT * MAX_LIGHTS_POINT;
                const crc3 = RenderWebGL.getRenderingContext();
                RenderWebGL.uboLights = RenderWebGL.assert(crc3.createBuffer());
                const blockSize = RenderWebGL.uboLightsOffsets["u_spot"] + BYTES_PER_LIGHT * MAX_LIGHTS_SPOT;
                crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, RenderWebGL.uboLights);
                crc3.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, blockSize, crc3.DYNAMIC_DRAW);
                crc3.bindBufferBase(WebGL2RenderingContext.UNIFORM_BUFFER, FudgeCore.UNIFORM_BLOCK.LIGHTS.BINDING, RenderWebGL.uboLights);
            }
            /**
             * Buffer the data from the lights in the scenegraph into the lights ubo
             */
            static bufferLights(_lights) {
                if (!RenderWebGL.uboLights)
                    return;
                RenderWebGL.crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, RenderWebGL.uboLights);
                // fill the buffer with the ambient light color
                let cmpLights = _lights.get(FudgeCore.LightAmbient);
                if (cmpLights) {
                    let clrSum = new FudgeCore.Color(0, 0, 0, 0);
                    for (let cmpLight of cmpLights) {
                        let clrLight = FudgeCore.Color.PRODUCT(cmpLight.light.color, cmpLight.light.intensity);
                        clrSum.add(clrLight);
                        FudgeCore.Recycler.store(clrLight);
                    }
                    RenderWebGL.crc3.bufferSubData(RenderWebGL.crc3.UNIFORM_BUFFER, RenderWebGL.uboLightsOffsets["u_ambient"], // byte offset of the struct Light "u_ambient" inside the ubo
                    new Float32Array(clrSum.get()));
                }
                // fill the buffer with the light data for each light type
                // we are currently doing a maximum of 4 crc3.bufferSubData() calls, but we could do this in one call
                bufferLightsOfType(FudgeCore.LightDirectional, "u_nLightsDirectional", "u_directional");
                bufferLightsOfType(FudgeCore.LightPoint, "u_nLightsPoint", "u_point");
                bufferLightsOfType(FudgeCore.LightSpot, "u_nLightsSpot", "u_spot");
                function bufferLightsOfType(_type, _uniName, _uniStruct) {
                    const cmpLights = _lights.get(_type);
                    RenderWebGL.crc3.bufferSubData(RenderWebGL.crc3.UNIFORM_BUFFER, RenderWebGL.uboLightsOffsets[_uniName], // byte offset of the uint "u_nLightsDirectional" inside the ubo
                    new Uint8Array([cmpLights?.length ?? 0]));
                    if (!cmpLights)
                        return;
                    const lightDataSize = 4 + 16 + 16; // vctColor + mtxShape + mtxShapeInverse, as float32s
                    const lightsData = new Float32Array(cmpLights.length * lightDataSize);
                    let iLight = 0;
                    for (let cmpLight of cmpLights) {
                        const lightDataOffset = iLight * lightDataSize;
                        // set vctColor
                        let clrLight = FudgeCore.Color.PRODUCT(cmpLight.light.color, cmpLight.light.intensity);
                        lightsData.set(clrLight.get(), lightDataOffset + 0);
                        FudgeCore.Recycler.store(clrLight);
                        // set mtxShape
                        let mtxTotal = FudgeCore.Matrix4x4.PRODUCT(cmpLight.node.mtxWorld, cmpLight.mtxPivot);
                        if (_type == FudgeCore.LightDirectional) {
                            let zero = FudgeCore.Vector3.ZERO();
                            mtxTotal.translation = zero;
                            FudgeCore.Recycler.store(zero);
                        }
                        lightsData.set(mtxTotal.get(), lightDataOffset + 4); // offset + vctColor
                        // set mtxShapeInverse
                        if (_type != FudgeCore.LightDirectional) {
                            let mtxInverse = FudgeCore.Matrix4x4.INVERSE(mtxTotal);
                            lightsData.set(mtxInverse.get(), lightDataOffset + 4 + 16); // offset + vctColor + mtxShape
                            FudgeCore.Recycler.store(mtxInverse);
                        }
                        FudgeCore.Recycler.store(mtxTotal);
                        iLight++;
                    }
                    RenderWebGL.crc3.bufferSubData(RenderWebGL.crc3.UNIFORM_BUFFER, RenderWebGL.uboLightsOffsets[_uniStruct], // byte offset of the struct Light array inside the ubo
                    lightsData);
                }
            }
            /**
             * Draws the given nodes using the given camera and the post process components attached to the same node as the camera
             * The opaque nodes are drawn first, then ssao is applied, then bloom is applied, then nodes alpha (sortForAlpha) are drawn.
             */
            static drawNodes(_nodesOpaque, _nodesAlpha, _cmpCamera) {
                const crc3 = RenderWebGL.getRenderingContext();
                const cmpFog = _cmpCamera.node?.getComponent(FudgeCore.ComponentFog);
                const cmpAmbientOcclusion = _cmpCamera.node?.getComponent(FudgeCore.ComponentAmbientOcclusion);
                const cmpBloom = _cmpCamera.node?.getComponent(FudgeCore.ComponentBloom);
                const cmpOutline = _cmpCamera.node?.getComponent(FudgeCore.ComponentOutline);
                RenderWebGL.bufferFog(cmpFog);
                RenderWebGL.bufferCamera(_cmpCamera);
                // opaque pass 
                // TODO: think about disabling blending for all opaque objects, this might improve performance 
                // as otherwise the 3 color attachments (color, position and normals) all need to be blended
                crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboMain);
                crc3.drawBuffers(cmpAmbientOcclusion?.isActive ? // only use position and normal textures if ambient occlusion is active
                    [WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.COLOR_ATTACHMENT1, WebGL2RenderingContext.COLOR_ATTACHMENT2] :
                    [WebGL2RenderingContext.COLOR_ATTACHMENT0]);
                crc3.disable(WebGL2RenderingContext.BLEND);
                for (let node of _nodesOpaque)
                    RenderWebGL.drawNode(node, _cmpCamera);
                crc3.enable(WebGL2RenderingContext.BLEND);
                // ambient occlusion pass
                if (cmpAmbientOcclusion?.isActive)
                    RenderWebGL.drawAmbientOcclusion(_cmpCamera, cmpAmbientOcclusion);
                // transparent pass TODO: think about disabling depth write for all transparent objects -> this might make depth mask option in component particle system obsolete
                crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboMain);
                crc3.drawBuffers([WebGL2RenderingContext.COLOR_ATTACHMENT0]);
                // crc3.depthMask(false);
                for (let node of _nodesAlpha)
                    RenderWebGL.drawNode(node, _cmpCamera);
                // crc3.depthMask(true);
                // bloom pass
                if (cmpBloom?.isActive)
                    RenderWebGL.drawBloom(cmpBloom);
                if (cmpOutline?.isActive)
                    RenderWebGL.drawOutline(cmpOutline.selection, _cmpCamera, cmpOutline);
                // copy framebuffer to canvas
                crc3.bindFramebuffer(WebGL2RenderingContext.READ_FRAMEBUFFER, RenderWebGL.fboMain);
                crc3.bindFramebuffer(WebGL2RenderingContext.DRAW_FRAMEBUFFER, RenderWebGL.fboTarget);
                crc3.blitFramebuffer(0, 0, crc3.canvas.width, crc3.canvas.height, 0, 0, crc3.canvas.width, crc3.canvas.height, WebGL2RenderingContext.COLOR_BUFFER_BIT | WebGL2RenderingContext.DEPTH_BUFFER_BIT, WebGL2RenderingContext.NEAREST);
            }
            /**
             * Draws the occlusion over the color-buffer, using the given ambient-occlusion-component
             */
            static drawAmbientOcclusion(_cmpCamera, _cmpAmbientOcclusion) {
                const crc3 = RenderWebGL.getRenderingContext();
                FudgeCore.ShaderAmbientOcclusion.useProgram();
                RenderWebGL.bindTexture(FudgeCore.ShaderAmbientOcclusion, RenderWebGL.texPosition, WebGL2RenderingContext.TEXTURE0, "u_texPosition");
                RenderWebGL.bindTexture(FudgeCore.ShaderAmbientOcclusion, RenderWebGL.texNormal, WebGL2RenderingContext.TEXTURE1, "u_texNormal");
                RenderWebGL.bindTexture(FudgeCore.ShaderAmbientOcclusion, RenderWebGL.texNoise, WebGL2RenderingContext.TEXTURE2, "u_texNoise");
                crc3.uniform1f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_fNear"], _cmpCamera.getNear());
                crc3.uniform1f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_fFar"], _cmpCamera.getFar());
                crc3.uniform1f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_fBias"], _cmpAmbientOcclusion.bias);
                crc3.uniform1f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_fSampleRadius"], _cmpAmbientOcclusion.sampleRadius);
                crc3.uniform1f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_fAttenuationConstant"], _cmpAmbientOcclusion.attenuationConstant);
                crc3.uniform1f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_fAttenuationLinear"], _cmpAmbientOcclusion.attenuationLinear);
                crc3.uniform1f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_fAttenuationQuadratic"], _cmpAmbientOcclusion.attenuationQuadratic);
                crc3.uniform2f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_vctResolution"], RenderWebGL.getCanvas().width, RenderWebGL.getCanvas().height);
                crc3.uniform3fv(FudgeCore.ShaderAmbientOcclusion.uniforms["u_vctCamera"], _cmpCamera.mtxWorld.translation.get());
                crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboPost);
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texColor, 0);
                RenderWebGL.setBlendMode(BLEND.SUBTRACTIVE);
                crc3.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, 3);
                RenderWebGL.setBlendMode(BLEND.TRANSPARENT);
            }
            /**
             * Draws the bloom-effect over the color-buffer, using the given bloom-component
             */
            static drawBloom(_cmpBloom) {
                const crc3 = RenderWebGL.getRenderingContext();
                FudgeCore.ShaderBloom.useProgram();
                // extract bright colors, could move this to main render pass so that individual objects can be exempt from bloom
                crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboPost);
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texBloomSamples[0], 0);
                RenderWebGL.clear();
                RenderWebGL.bindTexture(FudgeCore.ShaderBloom, RenderWebGL.texColor, WebGL2RenderingContext.TEXTURE0, "u_texSource");
                crc3.uniform1f(FudgeCore.ShaderBloom.uniforms["u_fThreshold"], _cmpBloom.threshold);
                crc3.uniform1i(FudgeCore.ShaderBloom.uniforms["u_iMode"], 0);
                crc3.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, 3);
                // downsample
                const iterations = RenderWebGL.texBloomSamples.length;
                for (let i = 1, divisor = 2; i < iterations; i++, divisor *= 2) {
                    let width = Math.max(Math.round(crc3.canvas.width / divisor), 1);
                    let height = Math.max(Math.round(crc3.canvas.height / divisor), 1);
                    crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texBloomSamples[i], 0);
                    crc3.viewport(0, 0, width, height);
                    RenderWebGL.clear();
                    RenderWebGL.bindTexture(FudgeCore.ShaderBloom, RenderWebGL.texBloomSamples[i - 1], WebGL2RenderingContext.TEXTURE0, "u_texSource");
                    crc3.uniform1i(FudgeCore.ShaderBloom.uniforms["u_iMode"], 1);
                    crc3.uniform2f(FudgeCore.ShaderBloom.uniforms["u_vctTexel"], 0.5 / width, 0.5 / height); // half texel size
                    // crc3.uniform2f(ShaderBloom.uniforms["u_vctResolution"], width, height);
                    crc3.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, 3);
                }
                RenderWebGL.setBlendMode(BLEND.ADDITIVE);
                // upsample
                for (let i = iterations - 1, divisor = 2 ** (iterations - 2); i > 0; i--, divisor /= 2) {
                    let width = Math.max(Math.round(crc3.canvas.width / divisor), 1);
                    let height = Math.max(Math.round(crc3.canvas.height / divisor), 1);
                    crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texBloomSamples[i - 1], 0);
                    crc3.viewport(0, 0, Math.round(width), Math.round(height));
                    RenderWebGL.bindTexture(FudgeCore.ShaderBloom, RenderWebGL.texBloomSamples[i], WebGL2RenderingContext.TEXTURE0, "u_texSource");
                    crc3.uniform1i(FudgeCore.ShaderBloom.uniforms["u_iMode"], 2);
                    crc3.uniform2f(FudgeCore.ShaderBloom.uniforms["u_vctTexel"], 0.5 / width, 0.5 / height); // half texel size
                    // crc3.uniform2f(ShaderBloom.uniforms["u_vctResolution"], width, height);
                    crc3.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, 3);
                }
                crc3.viewport(0, 0, crc3.canvas.width, crc3.canvas.height);
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texColor, 0);
                RenderWebGL.bindTexture(FudgeCore.ShaderBloom, RenderWebGL.texBloomSamples[0], WebGL2RenderingContext.TEXTURE0, "u_texSource");
                crc3.uniform1i(FudgeCore.ShaderBloom.uniforms["u_iMode"], 3);
                crc3.uniform1f(FudgeCore.ShaderBloom.uniforms["u_fIntensity"], _cmpBloom.intensity);
                crc3.uniform1f(FudgeCore.ShaderBloom.uniforms["u_fHighlightDesaturation"], _cmpBloom.highlightDesaturation);
                crc3.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, 3);
                RenderWebGL.setBlendMode(BLEND.TRANSPARENT);
            }
            static drawOutline(_nodes, _cmpCamera, _cmpOutline) {
                const crc3 = RenderWebGL.getRenderingContext();
                crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboPost);
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, null, 0);
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.DEPTH_STENCIL_ATTACHMENT, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texDepthStencilOutline, 0);
                RenderWebGL.clear();
                crc3.disable(WebGL2RenderingContext.BLEND);
                for (let selected of _nodes)
                    for (const node of selected) {
                        if (node.getComponent(FudgeCore.ComponentMesh)?.isActive && node.getComponent(FudgeCore.ComponentMaterial)?.isActive)
                            RenderWebGL.drawNode(node, _cmpCamera);
                    }
                crc3.enable(WebGL2RenderingContext.BLEND);
                FudgeCore.ShaderOutline.useProgram();
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texColor, 0);
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.DEPTH_STENCIL_ATTACHMENT, WebGL2RenderingContext.TEXTURE_2D, null, 0);
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT2, WebGL2RenderingContext.TEXTURE_2D, null, 0);
                crc3.drawBuffers([WebGL2RenderingContext.COLOR_ATTACHMENT0]);
                RenderWebGL.bindTexture(FudgeCore.ShaderOutline, RenderWebGL.texDepthStencilOutline, WebGL2RenderingContext.TEXTURE0, "u_texDepthOutline");
                RenderWebGL.bindTexture(FudgeCore.ShaderOutline, RenderWebGL.texDepthStencil, WebGL2RenderingContext.TEXTURE1, "u_texDepthScene");
                crc3.uniform4fv(FudgeCore.ShaderOutline.uniforms["u_vctColor"], _cmpOutline.color.get());
                crc3.uniform4fv(FudgeCore.ShaderOutline.uniforms["u_vctColorOccluded"], _cmpOutline.colorOccluded.get());
                crc3.uniform2f(FudgeCore.ShaderOutline.uniforms["u_vctTexel"], 1 / Math.round(crc3.canvas.width), 1 / Math.round(crc3.canvas.height)); // half texel size
                crc3.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, 3);
            }
            /**
             * Draw a mesh buffer using the given infos and the complete projection matrix
            */
            // @PerformanceMonitor.measure("Render.drawNode")
            static drawNode(_node, _cmpCamera) {
                // PerformanceMonitor.startMeasure("Render.drawNode get components");
                let cmpMesh = _node.getComponent(FudgeCore.ComponentMesh);
                let cmpMaterial = _node.getComponent(FudgeCore.ComponentMaterial);
                let cmpText = _node.getComponent(FudgeCore.ComponentText);
                let cmpFaceCamera = _node.getComponent(FudgeCore.ComponentFaceCamera);
                let cmpParticleSystem = _node.getComponent(FudgeCore.ComponentParticleSystem);
                let drawParticles = cmpParticleSystem?.isActive;
                let shader = cmpMaterial.material.getShader();
                if (drawParticles)
                    shader = cmpParticleSystem.particleSystem.getShaderFrom(shader);
                // PerformanceMonitor.endMeasure("Render.drawNode get components");
                // PerformanceMonitor.startMeasure("Render.drawNode useProgram");
                shader.useProgram();
                // PerformanceMonitor.endMeasure("Render.drawNode useProgram");
                // PerformanceMonitor.startMeasure("Render.drawNode useRenderData");
                cmpMaterial.material.coat.useRenderData();
                // PerformanceMonitor.endMeasure("Render.drawNode useRenderData");
                if (cmpMesh.skeleton?.isActive)
                    cmpMesh.skeleton.useRenderBuffer();
                // PerformanceMonitor.startMeasure("Render.drawNode other");
                let mtxWorldOverride;
                if (cmpText?.isActive)
                    mtxWorldOverride = cmpText.useRenderData(cmpMesh.mtxWorld, _cmpCamera);
                if (cmpFaceCamera?.isActive && !drawParticles)
                    mtxWorldOverride = RenderWebGL.faceCamera(_node, mtxWorldOverride ?? cmpMesh.mtxWorld, _cmpCamera.mtxWorld);
                // RenderWebGL.useRenderDataNode(_node, mtxWorldOverride);
                _node.useRenderData(mtxWorldOverride);
                // PerformanceMonitor.endMeasure("Render.drawNode other");
                // PerformanceMonitor.startMeasure("Render.drawNode getRenderBuffers");
                const renderBuffers = cmpMesh.mesh.useRenderBuffers(); // TODO: find out why this gets slower the more different meshes are drawn???
                // PerformanceMonitor.endMeasure("Render.drawNode getRenderBuffers");
                // PerformanceMonitor.startMeasure("Render.drawNode drawElements");
                if (drawParticles)
                    RenderWebGL.drawParticles(cmpParticleSystem, renderBuffers.nIndices);
                else
                    RenderWebGL.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
                // PerformanceMonitor.endMeasure("Render.drawNode drawElements");
            }
            static drawParticles(_cmpParticleSystem, _nIndices) {
                const crc3 = RenderWebGL.getRenderingContext();
                _cmpParticleSystem.useRenderData();
                crc3.depthMask(_cmpParticleSystem.depthMask);
                RenderWebGL.setBlendMode(_cmpParticleSystem.blendMode);
                crc3.drawElementsInstanced(WebGL2RenderingContext.TRIANGLES, _nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0, _cmpParticleSystem.size);
                crc3.depthMask(true);
                RenderWebGL.setBlendMode(BLEND.TRANSPARENT);
            }
            static faceCamera(_node, _mtxMeshToWorld, _mtxCamera) {
                let cmpFaceCamera = _node.getComponent(FudgeCore.ComponentFaceCamera);
                if (cmpFaceCamera?.isActive)
                    return _mtxMeshToWorld.clone.lookAt(_mtxCamera.translation, cmpFaceCamera.upLocal ? null : cmpFaceCamera.up, cmpFaceCamera.restrict);
                return _mtxMeshToWorld;
            }
            static bindTexture(_shader, _texture, _unit, _uniform) {
                const crc3 = RenderWebGL.getRenderingContext();
                crc3.activeTexture(_unit);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, _texture);
                crc3.uniform1i(_shader.uniforms[_uniform], _unit - WebGL2RenderingContext.TEXTURE0);
            }
        };
    })();
    FudgeCore.RenderWebGL = RenderWebGL;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Gives WebGL Buffer the data from the {@link Texture}
     * @internal
     */
    class RenderInjectorTexture {
        static decorate(_constructor, _context) {
            Object.defineProperty(_constructor.prototype, _constructor.prototype.useRenderData.name, {
                value: RenderInjectorTexture.useRenderData
            });
            Object.defineProperty(_constructor.prototype, _constructor.prototype.deleteRenderData.name, {
                value: RenderInjectorTexture.deleteRenderData
            });
        }
        static useRenderData(_textureUnit = WebGL2RenderingContext.TEXTURE0) {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (!this.renderData)
                this.renderData = FudgeCore.RenderWebGL.assert(crc3.createTexture()); // TODO: check if all WebGL-Creations are asserted
            crc3.activeTexture(_textureUnit);
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.renderData);
            if (this.textureDirty) {
                try {
                    // Always premultiply alpha while loading textures
                    crc3.pixelStorei(crc3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
                    crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, this.texImageSource);
                    crc3.pixelStorei(crc3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                    this.mipmapDirty = true;
                    this.textureDirty = false;
                }
                catch (_error) {
                    FudgeCore.Debug.error(_error);
                }
            }
            if (this.mipmapDirty) {
                switch (this.mipmap) {
                    case FudgeCore.MIPMAP.CRISP:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
                        break;
                    case FudgeCore.MIPMAP.MEDIUM:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST_MIPMAP_LINEAR);
                        crc3.generateMipmap(WebGL2RenderingContext.TEXTURE_2D);
                        break;
                    case FudgeCore.MIPMAP.BLURRY:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.LINEAR);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR_MIPMAP_LINEAR);
                        crc3.generateMipmap(WebGL2RenderingContext.TEXTURE_2D);
                        break;
                    case FudgeCore.MIPMAP.SMOOTH:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.LINEAR);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR);
                }
                this.mipmapDirty = false;
            }
            if (this.wrapDirty) {
                switch (this.wrap) {
                    case FudgeCore.WRAP.REPEAT:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.REPEAT);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.REPEAT);
                        break;
                    case FudgeCore.WRAP.CLAMP:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
                        break;
                    case FudgeCore.WRAP.MIRROR:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.MIRRORED_REPEAT);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.MIRRORED_REPEAT);
                        break;
                }
                this.wrapDirty = false;
            }
        }
        static deleteRenderData() {
            if (!this.renderData)
                return;
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
            crc3.deleteTexture(this.renderData);
            this.renderData = null;
            this.textureDirty = true;
            this.mipmapDirty = true;
            this.wrapDirty = true;
        }
    }
    FudgeCore.RenderInjectorTexture = RenderInjectorTexture;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Represents a node in the scenetree.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Graph
     */
    let Node = (() => {
        var _a, _b, _c, _d;
        let _classSuper = FudgeCore.EventTargetUnified;
        let _staticExtraInitializers = [];
        let _static_resetRenderData_decorators;
        let _static_updateRenderbuffer_decorators;
        let _static_updateRenderData_decorators;
        let _static_useRenderData_decorators;
        return class Node extends _classSuper {
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(this, null, _static_resetRenderData_decorators, { kind: "method", name: "resetRenderData", static: true, private: false, access: { has: obj => "resetRenderData" in obj, get: obj => obj.resetRenderData }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(this, null, _static_updateRenderbuffer_decorators, { kind: "method", name: "updateRenderbuffer", static: true, private: false, access: { has: obj => "updateRenderbuffer" in obj, get: obj => obj.updateRenderbuffer }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(this, null, _static_updateRenderData_decorators, { kind: "method", name: "updateRenderData", static: true, private: false, access: { has: obj => "updateRenderData" in obj, get: obj => obj.updateRenderData }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(this, null, _static_useRenderData_decorators, { kind: "method", name: "useRenderData", static: true, private: false, access: { has: obj => "useRenderData" in obj, get: obj => obj.useRenderData }, metadata: _metadata }, null, _staticExtraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(this, _staticExtraInitializers);
            }
            #mtxWorldInverseUpdated;
            #mtxWorldInverse;
            /**
             * Creates a new node with a name and initializes all attributes
             */
            constructor(_name) {
                super();
                this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
                this.timestampUpdate = 0;
                /** The number of nodes of the whole branch including this node and all successors */
                this.nNodesInBranch = 0;
                /** The radius of the bounding sphere in world dimensions enclosing the geometry of this node and all successors in the branch */
                this.radius = 0;
                this.parent = null; // The parent of this node.
                this.children = []; // array of child nodes appended to this node.
                this.components = {};
                // private tags: string[] = []; // Names of tags that are attached to this node. (TODO: As of yet no functionality)
                // private layers: string[] = []; // Names of the layers this node is on. (TODO: As of yet no functionality)
                this.listeners = {};
                this.captures = {};
                this.active = true;
                /**
                 * Simply calls {@link addChild}. This reference is here solely because appendChild is the equivalent method in DOM.
                 * See and preferably use {@link addChild}
                 */
                // eslint-disable-next-line @typescript-eslint/member-ordering
                this.appendChild = this.addChild;
                this.name = _name;
            }
            /**
             * Return the mutator-like path string to get from one node to another or null if no path is found e.g.:
             * ```typescript
             * "node/parent/children/1/components/ComponentSkeleton/0"
             * ```
             */
            static PATH_FROM_TO(_from, _to) {
                const from = _from instanceof FudgeCore.Component ? _from.node : _from;
                const to = _to instanceof FudgeCore.Component ? _to.node : _to;
                if (!from || !to)
                    return null;
                // find paths to lowest common ancestor
                let pathFrom = from.getPath();
                let pathTo = to.getPath();
                let ancestor = null;
                while (pathFrom.length && pathTo.length && pathFrom[0] == pathTo[0]) {
                    ancestor = pathFrom.shift();
                    pathTo.shift();
                }
                pathTo.unshift(ancestor);
                if (!ancestor)
                    return null;
                // create relative path
                let pathToAncestor = pathFrom.map(_node => "parent"); // TODO: use "keyof Node" as type
                let pathFromAncestor = pathTo
                    .flatMap((_node, _index, _array) => ["children", _node.findChild(_array[_index + 1]).toString()])
                    .slice(0, -2);
                if (_from instanceof FudgeCore.Component)
                    pathToAncestor.unshift("node");
                if (_to instanceof FudgeCore.Component)
                    pathFromAncestor.push("components", _to.type, to.components[_to.type].indexOf(_to).toString());
                return pathToAncestor.concat(pathFromAncestor).join("/"); // TODO: or maybe validate this string with node and component objects?
            }
            /**
             * Return the {@link Node} or {@link Component} found at the given path starting from the given node or undefined if not found
             */
            static FIND(_from, _path) {
                if (_path == "")
                    return _from;
                let path = _path.split("/");
                let to = _from;
                while (path.length && to)
                    to = Reflect.get(to, path.shift());
                return to;
            }
            /** @internal reroute to {@link RenderManagerNode.resetRenderData} */
            static resetRenderData() { }
            ;
            /** @internal reroute to {@link RenderManagerNode.updateRenderbuffer} */
            static updateRenderbuffer() { }
            ;
            /** @internal reroute to {@link RenderManagerNode.updateRenderData} */
            static updateRenderData(_node, _cmpMesh, _cmpMaterial, _cmpFaceCamera, _cmpParticleSystem) { }
            ;
            /** @internal reroute to {@link RenderManagerNode.useRenderData} */
            static useRenderData(_node, _mtxWorldOverride) { }
            ;
            get isActive() {
                return this.active;
            }
            /**
             * Shortcut to retrieve this nodes {@link ComponentTransform}
             */
            get cmpTransform() {
                return this.getComponents(FudgeCore.ComponentTransform)?.[0];
            }
            /**
             * Shortcut to retrieve the local {@link Matrix4x4} attached to this nodes {@link ComponentTransform}
             * Fails if no {@link ComponentTransform} is attached
             */
            get mtxLocal() {
                return this.cmpTransform?.mtxLocal;
            }
            get mtxWorldInverse() {
                if (this.#mtxWorldInverseUpdated != this.timestampUpdate)
                    this.#mtxWorldInverse = FudgeCore.Matrix4x4.INVERSE(this.mtxWorld);
                this.#mtxWorldInverseUpdated = this.timestampUpdate;
                return this.#mtxWorldInverse;
            }
            /**
             * Returns the number of children attached to this
             */
            get nChildren() {
                return this.children.length;
            }
            /**
             * Generator yielding the node and all decendants in the graph below for iteration
             * Inactive nodes and their descendants can be filtered
             */
            *getIterator(_active = false) {
                if (!_active || this.isActive) {
                    yield this;
                    for (let child of this.children)
                        yield* child.getIterator(_active);
                }
            }
            /**
             * Returns an iterator over this node and all its descendants in the graph below
             */
            [(_static_resetRenderData_decorators = [(_a = FudgeCore.RenderManagerNode).decorate.bind(_a)], _static_updateRenderbuffer_decorators = [(_b = FudgeCore.RenderManagerNode).decorate.bind(_b)], _static_updateRenderData_decorators = [(_c = FudgeCore.RenderManagerNode).decorate.bind(_c)], _static_useRenderData_decorators = [(_d = FudgeCore.RenderManagerNode).decorate.bind(_d)], Symbol.iterator)]() {
                return this.getIterator();
            }
            /** @internal reroute to {@link RenderManagerNode.updateRenderData} */
            updateRenderData(_cmpMesh, _cmpMaterial, _cmpFaceCamera, _cmpParticleSystem) { Node.updateRenderData(this, _cmpMesh, _cmpMaterial, _cmpFaceCamera, _cmpParticleSystem); }
            ;
            /** @internal reroute to {@link RenderManagerNode.useRenderData} */
            useRenderData(_mtxWorldOverride) { Node.useRenderData(this, _mtxWorldOverride); }
            ;
            /**
             * De- / Activate this node. Inactive nodes will not be processed by the renderer.
             */
            activate(_on) {
                this.active = _on;
                this.dispatchEvent(new Event(_on ? "nodeActivate" /* EVENT.NODE_ACTIVATE */ : "nodeDeactivate" /* EVENT.NODE_DEACTIVATE */, { bubbles: true }));
                this.broadcastEvent(new Event(_on ? "nodeActivate" /* EVENT.NODE_ACTIVATE */ : "nodeDeactivate" /* EVENT.NODE_DEACTIVATE */));
            }
            // #region Scenetree
            /**
             * Returns a reference to this nodes parent node
             */
            getParent() {
                return this.parent;
            }
            /**
             * Traces back the ancestors of this node and returns the first
             */
            getAncestor() {
                let ancestor = this;
                while (ancestor.getParent())
                    ancestor = ancestor.getParent();
                return ancestor;
            }
            /**
             * Traces the hierarchy upwards to the first ancestor and returns the path through the graph to this node
             */
            getPath() {
                let ancestor = this;
                let path = [this];
                while (ancestor.getParent())
                    path.unshift(ancestor = ancestor.getParent());
                return path;
            }
            /**
             * Returns child at the given index in the list of children
             */
            getChild(_index) {
                return this.children[_index];
            }
            /**
             * Returns a clone of the list of children
             */
            getChildren() {
                return this.children.slice(0);
            }
            /**
             * Returns an array of references to childnodes with the supplied name.
             */
            getChildrenByName(_name) {
                let found = [];
                found = this.children.filter((_node) => _node.name == _name);
                return found;
            }
            addChild(_child, _index) {
                if (this.children.includes(_child) && _index == undefined)
                    // _node is already a child of this
                    return;
                let inAudioGraph = false;
                let graphListened = FudgeCore.AudioManager.default.getGraphListeningTo();
                let ancestor = this;
                while (ancestor) {
                    ancestor.timestampUpdate = 0;
                    inAudioGraph = inAudioGraph || (ancestor == graphListened);
                    if (ancestor == _child)
                        throw (new Error("Cyclic reference prohibited in node hierarchy, ancestors must not be added as children"));
                    else
                        ancestor = ancestor.parent;
                }
                let previousParent = _child.parent;
                if (previousParent == this && _index > previousParent.findChild(_child))
                    _index--;
                if (previousParent)
                    previousParent.removeChild(_child);
                this.children.splice(_index ?? this.children.length, 0, _child);
                _child.parent = this;
                _child.dispatchEvent(new Event("childAppend" /* EVENT.CHILD_APPEND */, { bubbles: true }));
                if (inAudioGraph)
                    _child.broadcastEvent(new Event("childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */));
            }
            /**
             * Removes the reference to the give node from the list of children
             */
            removeChild(_child) {
                let found = this.findChild(_child);
                if (found < 0)
                    return;
                _child.dispatchEvent(new Event("childRemove" /* EVENT.CHILD_REMOVE */, { bubbles: true }));
                _child.broadcastEvent(new Event("nodeDeactivate" /* EVENT.NODE_DEACTIVATE */));
                if (this.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo()))
                    _child.broadcastEvent(new Event("childRemoveFromAudioGraph" /* EVENT_AUDIO.CHILD_REMOVE */));
                this.children.splice(found, 1);
                _child.parent = null;
            }
            /**
             * Removes all references in the list of children
             */
            removeAllChildren() {
                while (this.children.length)
                    this.removeChild(this.children[0]);
            }
            /**
             * Returns the position of the node in the list of children or -1 if not found
             */
            findChild(_search) {
                return this.children.indexOf(_search);
            }
            /**
             * Replaces a child node with another, preserving the position in the list of children
             */
            replaceChild(_replace, _with) {
                let found = this.findChild(_replace);
                if (found < 0)
                    return false;
                _with.getParent()?.removeChild(_with);
                this.removeChild(_replace);
                this.addChild(_with, found);
                return true;
            }
            /**
             * Returns true if the given timestamp matches the last update timestamp this node underwent, else false
             */
            isUpdated(_timestampUpdate) {
                return (this.timestampUpdate == _timestampUpdate);
            }
            /**
             * Returns true if this node is a descendant of the given node, directly or indirectly, else false
             */
            isDescendantOf(_ancestor) {
                let node = this;
                while (node && node != _ancestor)
                    node = node.parent;
                return (node != null);
            }
            /**
             * Applies a Mutator from {@link Animation} to all its components and transfers it to its children.
             */
            applyAnimation(_mutator) {
                if ("components" in _mutator) {
                    for (const componentType in _mutator.components) {
                        let componentsOfType = this.components[componentType]; // TODO: add errors if node doesn't contain property
                        let mutatorsForType = _mutator.components[componentType];
                        if (componentsOfType != undefined && mutatorsForType != undefined) {
                            for (const i in mutatorsForType) {
                                FudgeCore.PerformanceMonitor.startMeasure("applyAnimation mutate components");
                                componentsOfType[i].mutate(mutatorsForType[i], null, false);
                                FudgeCore.PerformanceMonitor.endMeasure("applyAnimation mutate components");
                            }
                        }
                    }
                }
                if ("children" in _mutator) {
                    for (const childName in _mutator.children) {
                        for (const childNode of this.getChildrenByName(childName)) {
                            childNode.applyAnimation(_mutator.children[childName]);
                        }
                    }
                }
            }
            // #endregion
            // #region Components
            /**
             * Returns a list of all components attached to this node, independent of type.
             */
            getAllComponents() {
                let all = [];
                for (let type in this.components) {
                    all = all.concat(this.components[type]);
                }
                return all;
            }
            /**
             * Returns a clone of the list of components of the given class attached to this node.
             */
            getComponents(_class) {
                return (this.components[_class.name] || []).slice(0);
            }
            /**
             * Returns the first compontent found of the given class attached this node or null, if list is empty or doesn't exist
             */
            getComponent(_class) {
                return this.components[_class.name]?.[0];
            }
            /**
             * Attach the given component to this node. Identical to {@link addComponent}
             */
            attach(_component) {
                this.addComponent(_component);
            }
            /**
             * Attach the given component to this node
             */
            addComponent(_component) {
                if (_component.node == this)
                    return;
                let cmpList = this.components[_component.type];
                if (cmpList === undefined)
                    this.components[_component.type] = [_component];
                else if (cmpList.length && _component.isSingleton)
                    throw new Error(`Component ${_component.type} is marked singleton and can't be attached, no more than one allowed`);
                else
                    cmpList.push(_component);
                _component.attachToNode(this);
                _component.dispatchEvent(new Event("componentAdd" /* EVENT.COMPONENT_ADD */));
                this.dispatchEventToTargetOnly(new CustomEvent("componentAdd" /* EVENT.COMPONENT_ADD */, { detail: _component })); // TODO: see if this is be feasable
            }
            /**
             * Detach the given component from this node. Identical to {@link removeComponent}
             */
            detach(_component) {
                this.removeComponent(_component);
            }
            /**
             * Removes all components of the given class attached to this node.
             */
            removeComponents(_class) {
                this.getComponents(_class).forEach(_component => this.removeComponent(_component));
            }
            /**
             * Removes the given component from the node, if it was attached, and sets its parent to null.
             */
            removeComponent(_component) {
                try {
                    let componentsOfType = this.components[_component.type];
                    let foundAt = componentsOfType.indexOf(_component);
                    if (foundAt < 0)
                        return;
                    _component.dispatchEvent(new Event("componentRemove" /* EVENT.COMPONENT_REMOVE */));
                    this.dispatchEventToTargetOnly(new CustomEvent("componentRemove" /* EVENT.COMPONENT_REMOVE */, { detail: _component })); // TODO: see if this would be feasable
                    componentsOfType.splice(foundAt, 1);
                    _component.attachToNode(null);
                }
                catch (_error) {
                    throw new Error(`Unable to remove component '${_component}'in node named '${this.name}'`);
                }
            }
            // #endregion
            // #region Serialization
            serialize() {
                let serialization = {
                    name: this.name,
                    active: this.active
                };
                let components = {};
                for (let type in this.components) {
                    if (this.components[type].length == 0)
                        continue;
                    components[type] = [];
                    for (let component of this.components[type]) {
                        // components[type].push(component.serialize());
                        components[type].push(FudgeCore.Serializer.serialize(component));
                    }
                }
                serialization["components"] = components;
                let children = [];
                for (let child of this.children) {
                    children.push(FudgeCore.Serializer.serialize(child));
                }
                serialization["children"] = children;
                this.dispatchEvent(new Event("nodeSerialized" /* EVENT.NODE_SERIALIZED */));
                return serialization;
            }
            async deserialize(_serialization) {
                this.name = _serialization.name;
                // this.parent = is set when the nodes are added
                // deserialize components first so scripts can react to children being appended
                for (let type in _serialization.components) {
                    for (let serializedComponent of _serialization.components[type]) {
                        let deserializedComponent = await FudgeCore.Serializer.deserialize(serializedComponent);
                        this.addComponent(deserializedComponent);
                    }
                }
                if (_serialization.children)
                    for (let serializedChild of _serialization.children) {
                        let deserializedChild = await FudgeCore.Serializer.deserialize(serializedChild);
                        this.appendChild(deserializedChild);
                    }
                this.dispatchEvent(new Event("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */));
                for (let component of this.getAllComponents())
                    component.dispatchEvent(new Event("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */));
                // TODO: consider if this is a good idea
                // const hndGraphDeserialized: EventListenerUnified = () => {
                //   for (let component of this.getAllComponents())
                //     component.dispatchEvent(new Event(EVENT.GRAPH_DESERIALIZED, { bubbles: false }));
                //   this.removeEventListener(EVENT.GRAPH_DESERIALIZED, hndGraphDeserialized, true);
                //   this.removeEventListener(EVENT.GRAPH_INSTANTIATED, hndGraphDeserialized, true);
                // };
                // this.addEventListener(EVENT.GRAPH_DESERIALIZED, hndGraphDeserialized, true);
                // this.addEventListener(EVENT.GRAPH_INSTANTIATED, hndGraphDeserialized, true);
                this.activate(_serialization.active);
                return this;
            }
            // #endregion
            toString() {
                return this.name;
            }
            /**
             * Creates a string as representation of this node and its descendants
             */
            toHierarchyString(_node = null, _level = 0) {
                // TODO: refactor for better readability
                if (!_node)
                    _node = this;
                let prefix = "+".repeat(_level);
                let output = prefix + " " + _node.name + " | ";
                for (let type in _node.components)
                    output += _node.components[type].length + " " + type.split("Component").pop() + ", ";
                output = output.slice(0, -2) + "</br>";
                for (let child of _node.children) {
                    output += this.toHierarchyString(child, _level + 1);
                }
                return output;
            }
            // #region Events
            /**
             * Adds an event listener to the node. The given handler will be called when a matching event is passed to the node.
             * Deviating from the standard EventTarget, here the _handler must be a function and _capture is the only option.
             */
            addEventListener(_type, _handler, _capture = false) {
                let listListeners = _capture ? this.captures : this.listeners;
                if (!listListeners[_type])
                    listListeners[_type] = [];
                listListeners[_type].push(_handler);
            }
            /**
             * Removes an event listener from the node. The signature must match the one used with addEventListener
             */
            removeEventListener(_type, _handler, _capture = false) {
                let listenersForType = _capture ? this.captures[_type] : this.listeners[_type];
                if (listenersForType)
                    for (let i = listenersForType.length - 1; i >= 0; i--)
                        if (listenersForType[i] == _handler)
                            listenersForType.splice(i, 1);
            }
            /**
             * Dispatches a synthetic event to target. This implementation always returns true (standard: return true only if either event's cancelable attribute value is false or its preventDefault() method was not invoked)
             * The event travels into the hierarchy to this node dispatching the event, invoking matching handlers of the nodes ancestors listening to the capture phase,
             * than the matching handler of the target node in the target phase, and back out of the hierarchy in the bubbling phase, invoking appropriate handlers of the anvestors
             */
            dispatchEvent(_event) {
                let ancestors = [];
                let upcoming = this;
                // overwrite event target
                Object.defineProperty(_event, "target", { writable: true, value: this });
                // TODO: consider using Reflect instead of Object throughout. See also Render and Mutable...
                while (upcoming.parent)
                    ancestors.push(upcoming = upcoming.parent);
                Object.defineProperty(_event, "path", { writable: true, value: new Array(this, ...ancestors) });
                // capture phase
                Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
                for (let i = ancestors.length - 1; i >= 0; i--) {
                    let ancestor = ancestors[i];
                    Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                    this.callListeners(ancestor.captures[_event.type], _event);
                }
                // target phase
                Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.AT_TARGET });
                Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
                this.callListeners(this.captures[_event.type], _event);
                this.callListeners(this.listeners[_event.type], _event);
                if (!_event.bubbles)
                    return true;
                // bubble phase
                Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.BUBBLING_PHASE });
                for (let i = 0; i < ancestors.length; i++) {
                    let ancestor = ancestors[i];
                    Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                    this.callListeners(ancestor.listeners[_event.type], _event);
                }
                return true; //TODO: return a meaningful value, see documentation of dispatch event
            }
            /**
             * Dispatches a synthetic event to target without travelling through the graph hierarchy neither during capture nor bubbling phase
             */
            dispatchEventToTargetOnly(_event) {
                Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.AT_TARGET });
                Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
                this.callListeners(this.listeners[_event.type], _event); // TODO: examine if this should go to the captures instead of the listeners
                return true;
            }
            /**
             * Broadcasts a synthetic event to this node and from there to all nodes deeper in the hierarchy,
             * invoking matching handlers of the nodes listening to the capture phase. Watch performance when there are many nodes involved
             */
            broadcastEvent(_event) {
                // overwrite event target and phase
                Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
                Object.defineProperty(_event, "target", { writable: true, value: this });
                this.broadcastEventRecursive(_event);
            }
            broadcastEventRecursive(_event) {
                // capture phase only
                Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
                let captures = this.captures[_event.type];
                if (captures) {
                    captures = [...captures]; // create a copy to avoid problems with handlers that detach themselves
                    for (let handler of captures)
                        // @ts-ignore
                        handler(_event);
                    // appears to be slower, astonishingly...
                    // captures.forEach(function (handler: Function): void {
                    //     handler(_event);
                    // });
                }
                // same for children
                for (let child of this.children) {
                    child.broadcastEventRecursive(_event);
                }
            }
            callListeners(_listeners, _event) {
                if (_listeners?.length > 0)
                    for (let handler of _listeners)
                        // @ts-ignore
                        handler(_event);
            }
        };
    })();
    FudgeCore.Node = Node;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Superclass for all {@link Component}s that can be attached to {@link Node}s.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020 | Jascha Karag√∂l, HFU, 2019
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Component
     */
    class Component extends FudgeCore.Mutable {
        /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
        static { this.baseClass = Component; }
        /** list of all the subclasses derived from this class, if they registered properly*/
        static { this.subclasses = []; }
        #node;
        constructor() {
            super();
            this.singleton = true;
            this.active = true;
            this.#node = null;
            this.addEventListener("mutate" /* EVENT.MUTATE */, (_event) => {
                if (this.#node) {
                    // TODO: find the number of the component in the array if not singleton
                    _event.detail.component = this;
                    //@ts-ignore
                    _event.detail.componentIndex = this.node.getComponents(this.constructor).indexOf(this);
                    this.#node.dispatchEvent(_event);
                }
            });
        }
        static registerSubclass(_subclass) { return Component.subclasses.push(_subclass) - 1; }
        get isActive() {
            return this.active;
        }
        /**
         * Is true, when only one instance of the component class can be attached to a node
         */
        get isSingleton() {
            return this.singleton;
        }
        /**
         * Retrieves the node, this component is currently attached to
         */
        get node() {
            return this.#node;
        }
        /**
         * De- / Activate this component. Inactive components will not be processed by the renderer.
         */
        activate(_on) {
            this.active = _on;
            this.dispatchEvent(new Event(_on ? "componentActivate" /* EVENT.COMPONENT_ACTIVATE */ : "componentDeactivate" /* EVENT.COMPONENT_DEACTIVATE */));
        }
        /**
         * Tries to attach the component to the given node, removing it from the node it was attached to if applicable
         */
        attachToNode(_container) {
            if (this.#node == _container)
                return;
            let previousContainer = this.#node;
            try {
                if (previousContainer)
                    previousContainer.removeComponent(this);
                this.#node = _container;
                if (this.#node)
                    this.#node.addComponent(this);
            }
            catch (_error) {
                this.#node = previousContainer;
            }
        }
        //#region Transfer
        serialize() {
            let serialization = {
                active: this.active
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.activate(_serialization.active);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            await super.mutate(_mutator, _selection, _dispatchMutate);
            if (typeof (_mutator.active) !== "undefined")
                this.activate(_mutator.active);
        }
        reduceMutator(_mutator) {
            delete _mutator.singleton;
            delete _mutator.mtxWorld;
        }
    }
    FudgeCore.Component = Component;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Wraps a regular Javascript Array and offers very limited functionality geared solely towards avoiding garbage colletion.
     * @author Jirka Dell'Oro-Friedl, HFU, 2021
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Recycler
     */
    class RecycableArray {
        #length = 0;
        #array = new Array();
        // #type: new () => T;
        // //tslint:disable-next-line:no-any
        // constructor(_type: new (...args: any[]) => T) {
        //   this.#type = _type;
        // }
        get length() {
            return this.#length;
        }
        /**
         * Sets the virtual length of the array to zero but keeps the entries beyond.
         */
        reset() {
            this.#length = 0;
        }
        /**
         * Recycle this array
         */
        recycle() {
            this.reset();
        }
        /**
         * Appends a new entry to the end of the array, and returns the new length of the array.
         */
        push(_entry) {
            this.#array[this.#length] = _entry;
            this.#length++;
            return this.#length;
        }
        /**
         * Removes the last entry from the array and returns it.
         */
        pop() {
            if (this.#length == 0)
                return undefined;
            this.#length--;
            return this.#array[this.#length];
        }
        /**
         * Recycles the object following the last in the array and increases the array length
         * It must be assured, that none of the objects in the array is still in any use of any kind!
         */
        // public recycle(): T {
        //   if (this.#length < this.#array.length) {
        //     this.#length++;
        //     return this.#array[this.#length++];
        //   }
        //   this.#array.push(Recycler.get(this.#type));
        //   return this.#array[this.#length++];
        // }
        *[Symbol.iterator]() {
            for (let i = 0; i < this.#length; i++)
                yield this.#array[i];
        }
        /**
         * Returns a copy of the array sorted according to the given compare function
         */
        getSorted(_sort) {
            let sorted = this.#array.slice(0, this.#length);
            sorted.sort(_sort);
            return sorted;
        }
    }
    FudgeCore.RecycableArray = RecycableArray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Special type of {@link Event} for physics.
     */
    class EventPhysics extends Event {
        /** Creates a new event customized for physics. Holding informations about impulses. Collision point and the body that is colliding */
        constructor(_type, _hitRigidbody, _normalImpulse, _tangentImpulse, _binormalImpulse, _collisionPoint = null, _collisionNormal = null) {
            super(_type);
            this.cmpRigidbody = _hitRigidbody;
            this.normalImpulse = _normalImpulse;
            this.tangentImpulse = _tangentImpulse;
            this.binomalImpulse = _binormalImpulse;
            this.collisionPoint = _collisionPoint;
            this.collisionNormal = _collisionNormal;
        }
    }
    FudgeCore.EventPhysics = EventPhysics;
    /**
    * Groups to place a node in, not every group should collide with every group. Use a Mask in to exclude collisions
    */
    let COLLISION_GROUP;
    (function (COLLISION_GROUP) {
        COLLISION_GROUP[COLLISION_GROUP["DEFAULT"] = 1] = "DEFAULT";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_1"] = 2] = "GROUP_1";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_2"] = 4] = "GROUP_2";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_3"] = 8] = "GROUP_3";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_4"] = 16] = "GROUP_4";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_5"] = 32] = "GROUP_5";
    })(COLLISION_GROUP = FudgeCore.COLLISION_GROUP || (FudgeCore.COLLISION_GROUP = {}));
    /**
    * Defines the type of the rigidbody which determines the way it interacts with the physical and the visual world
    */
    let BODY_TYPE;
    (function (BODY_TYPE) {
        /** The body ignores the hierarchy of the render graph, is completely controlled  by physics and takes its node with it  */
        BODY_TYPE[BODY_TYPE["DYNAMIC"] = 0] = "DYNAMIC";
        /** The body ignores the hierarchy of the render graph, is completely immoveble and keeps its node from moving  */
        BODY_TYPE[BODY_TYPE["STATIC"] = 1] = "STATIC";
        /** The body is controlled by its node and moves with it, while it impacts the physical world e.g. by collisions */
        BODY_TYPE[BODY_TYPE["KINEMATIC"] = 2] = "KINEMATIC"; // = OIMO.RigidBodyType.KINEMATIC
    })(BODY_TYPE = FudgeCore.BODY_TYPE || (FudgeCore.BODY_TYPE = {}));
    /**
    * Different types of collider shapes, with different options in scaling BOX = Vector3(length, height, depth),
    * SPHERE = Vector3(diameter, x, x), CAPSULE = Vector3(diameter, height, x), CYLINDER = Vector3(diameter, height, x),
    * CONE = Vector(diameter, height, x), PYRAMID = Vector3(length, height, depth); x == unused.
    * CONVEX = ComponentMesh needs to be available in the RB Property convexMesh, the points of that component are used to create a collider that matches,
    * the closest possible representation of that form, in form of a hull. Convex is experimental and can produce unexpected behaviour when vertices
    * are too close to one another and the given vertices do not form a in itself closed shape and having a genus of 0 (no holes). Vertices in the ComponentMesh can be scaled differently
    * for texturing/normal or other reasons, so the collider might be off compared to the visual shape, this can be corrected by changing the pivot scale of the ComponentRigidbody.
    */
    let COLLIDER_TYPE;
    (function (COLLIDER_TYPE) {
        COLLIDER_TYPE[COLLIDER_TYPE["CUBE"] = 0] = "CUBE";
        COLLIDER_TYPE[COLLIDER_TYPE["SPHERE"] = 1] = "SPHERE";
        COLLIDER_TYPE[COLLIDER_TYPE["CAPSULE"] = 2] = "CAPSULE";
        COLLIDER_TYPE[COLLIDER_TYPE["CYLINDER"] = 3] = "CYLINDER";
        COLLIDER_TYPE[COLLIDER_TYPE["CONE"] = 4] = "CONE";
        COLLIDER_TYPE[COLLIDER_TYPE["PYRAMID"] = 5] = "PYRAMID";
        COLLIDER_TYPE[COLLIDER_TYPE["CONVEX"] = 6] = "CONVEX";
    })(COLLIDER_TYPE = FudgeCore.COLLIDER_TYPE || (FudgeCore.COLLIDER_TYPE = {}));
    /** Displaying different types of debug information about different physic features. Default = JOINTS_AND_COLLIDER. */
    let PHYSICS_DEBUGMODE;
    (function (PHYSICS_DEBUGMODE) {
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["NONE"] = 0] = "NONE";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["COLLIDERS"] = 1] = "COLLIDERS";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["JOINTS_AND_COLLIDER"] = 2] = "JOINTS_AND_COLLIDER";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["BOUNDING_BOXES"] = 3] = "BOUNDING_BOXES";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["CONTACTS"] = 4] = "CONTACTS";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["PHYSIC_OBJECTS_ONLY"] = 5] = "PHYSIC_OBJECTS_ONLY";
    })(PHYSICS_DEBUGMODE = FudgeCore.PHYSICS_DEBUGMODE || (FudgeCore.PHYSICS_DEBUGMODE = {}));
    /** Info about Raycasts shot from the physics system. */
    class RayHitInfo {
        constructor() {
            this.hitPoint = FudgeCore.Vector3.ZERO();
            this.hitNormal = FudgeCore.Vector3.ZERO();
            this.rayEnd = FudgeCore.Vector3.ZERO();
            this.rayOrigin = FudgeCore.Vector3.ZERO();
            this.recycle();
        }
        recycle() {
            this.hit = false;
            this.hitDistance = 0;
            this.hitPoint.recycle();
            this.rigidbodyComponent = null;
            this.hitNormal.recycle();
            this.rayOrigin.recycle();
            this.rayEnd.recycle();
        }
    }
    FudgeCore.RayHitInfo = RayHitInfo;
    /** General settings for the physic simulation and the debug of it. */
    class PhysicsSettings {
        constructor(_defaultCollisionGroup, _defaultCollisionMask) {
            if (typeof OIMO == "undefined")
                return;
            this.defaultCollisionGroup = _defaultCollisionGroup;
            this.defaultCollisionMask = _defaultCollisionMask;
        }
        /** Change if rigidbodies are able to sleep (don't be considered in physical calculations) when their movement is below a threshold. Deactivation is decreasing performance for minor advantage in precision. */
        get disableSleeping() {
            return OIMO.Setting.disableSleeping;
        }
        set disableSleeping(_value) {
            OIMO.Setting.disableSleeping = _value;
        }
        /** Sleeping Threshold for Movement Veloctiy. */
        get sleepingVelocityThreshold() {
            return OIMO.Setting.sleepingVelocityThreshold;
        }
        set sleepingVelocityThreshold(_value) {
            OIMO.Setting.sleepingVelocityThreshold = _value;
        }
        /** Sleeping Threshold for Rotation Velocity. */
        get sleepingAngularVelocityThreshold() {
            return OIMO.Setting.sleepingAngularVelocityThreshold;
        }
        set sleepingAngularVelocityThreshold(_value) {
            OIMO.Setting.sleepingAngularVelocityThreshold = _value;
        }
        /** Threshold how long the Rigidbody must be below/above the threshold to count as sleeping. */
        get sleepingTimeThreshold() {
            return OIMO.Setting.sleepingTimeThreshold;
        }
        set sleepingTimeThreshold(_value) {
            OIMO.Setting.sleepingTimeThreshold = _value;
        }
        /** Error threshold. Default is 0.05. The higher the more likely collisions get detected before actual impact at high speeds but it's visually less accurate. */
        get defaultCollisionMargin() {
            return OIMO.Setting.defaultGJKMargin;
        }
        set defaultCollisionMargin(_thickness) {
            OIMO.Setting.defaultGJKMargin = _thickness;
        }
        /** The default applied friction between two rigidbodies with the default value. How much velocity is slowed down when moving accross this surface. */
        get defaultFriction() {
            return OIMO.Setting.defaultFriction;
        }
        set defaultFriction(_value) {
            OIMO.Setting.defaultFriction = _value;
        }
        /** Bounciness of rigidbodies. How much of the impact is restituted. */
        get defaultRestitution() {
            return OIMO.Setting.defaultRestitution;
        }
        set defaultRestitution(_value) {
            OIMO.Setting.defaultRestitution = _value;
        }
        /** Groups the default rigidbody will collide with. Set it like: (PHYSICS_GROUP.DEFAULT | PHYSICS_GROUP.GROUP_1 | PHYSICS_GROUP.GROUP_2 | PHYSICS_GROUP.GROUP_3)
         * to collide with multiple groups. Default is collision with everything but triggers.
        */
        get defaultCollisionMask() {
            return OIMO.Setting.defaultCollisionMask;
        }
        set defaultCollisionMask(_value) {
            OIMO.Setting.defaultCollisionMask = _value;
        }
        /** The group that this rigidbody belongs to. Default is the DEFAULT Group which means its just a normal Rigidbody not a trigger nor anything special. */
        get defaultCollisionGroup() {
            return OIMO.Setting.defaultCollisionGroup;
        }
        set defaultCollisionGroup(_value) {
            OIMO.Setting.defaultCollisionGroup = _value;
        }
        /** Change the type of joint solver algorithm. Default Iterative == 0, is faster but less stable. Direct == 1, slow but more stable, recommended for complex joint work. Change this setting only at the start of your game. */
        get defaultConstraintSolverType() {
            return OIMO.Setting.defaultJointConstraintSolverType;
        }
        set defaultConstraintSolverType(_value) {
            OIMO.Setting.defaultJointConstraintSolverType = _value;
        }
        /** The correction algorithm used to correct physics calculations. Change this only at the beginning of your game. Each has different approaches, so if you have problems test another
         *  Default 0 = Baumgarte (fast but less correct induces some energy errors), 1 = Split-Impulse (fast and no engery errors, but more inaccurate for joints), 2 = Non-linear Gauss Seidel (slowest but most accurate)*/
        get defaultCorrectionAlgorithm() {
            return OIMO.Setting.defaultJointPositionCorrectionAlgorithm;
        }
        set defaultCorrectionAlgorithm(_value) {
            OIMO.Setting.defaultJointPositionCorrectionAlgorithm = _value;
        }
        /** The precision of the simulation in form of number of iterations the simulations runs through until it accepts the result.
         *  10 Default - Higher means more precision but results in a performance decrease. This helps especially with joints,
         * but also the general stability of the simulation due to simulation steps being rechecked multiple times before being set.
         */
        get solverIterations() {
            return FudgeCore.Physics.activeInstance.getOimoWorld().getNumPositionIterations();
        }
        set solverIterations(_value) {
            FudgeCore.Physics.activeInstance.getOimoWorld().setNumPositionIterations(_value);
            FudgeCore.Physics.activeInstance.getOimoWorld().setNumVelocityIterations(_value);
        }
    }
    FudgeCore.PhysicsSettings = PhysicsSettings;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * Acts as the physical representation of a connection between two {@link Node}'s.
       * The type of conncetion is defined by the subclasses like prismatic joint, cylinder joint etc.
       * A Rigidbody on the {@link Node} that this component is added to is needed. Setting the connectedRigidbody and
       * initializing the connection creates a physical connection between them. This differs from a connection through hierarchy
       * in the node structure of fudge. Joints can have different DOF's (Degrees Of Freedom), 1 Axis that can either twist or swing is a degree of freedom.
       * A joint typically consists of a motor that limits movement/rotation or is activly trying to move to a limit. And a spring which defines the rigidity.
       * @author Marko Fehrenbach, HFU 2020
       */
    class Joint extends FudgeCore.Component {
        /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
        static { this.baseClass = Joint; }
        /** list of all the subclasses derived from this class, if they registered properly*/
        static { this.subclasses = []; }
        #idBodyAnchor;
        #idBodyTied;
        #bodyAnchor;
        #bodyTied;
        #connected;
        #anchor;
        #internalCollision;
        #breakForce;
        #breakTorque;
        #nameChildToConnect;
        /** Create a joint connection between the two given RigidbodyComponents. */
        constructor(_bodyAnchor = null, _bodyTied = null) {
            super();
            // public static readonly iSubclass: number = Component.registerSubclass(ComponentJoint);
            this.singleton = false; //Multiple joints can be attached to one Node
            this.#idBodyAnchor = 0;
            this.#idBodyTied = 0;
            this.#connected = false;
            this.#internalCollision = false;
            this.#breakForce = 0;
            this.#breakTorque = 0;
            this.hndEvent = (_event) => {
                switch (_event.type) {
                    case "componentAdd" /* EVENT.COMPONENT_ADD */:
                        this.node.addEventListener("disconnectJoint" /* EVENT.DISCONNECT_JOINT */, () => { this.disconnect(); this.dirtyStatus(); }, true);
                        this.dirtyStatus();
                        break;
                    case "componentRemove" /* EVENT.COMPONENT_REMOVE */:
                        this.node.removeEventListener("disconnectJoint" /* EVENT.DISCONNECT_JOINT */, () => { this.disconnect(); this.dirtyStatus(); }, true);
                        this.removeJoint();
                        break;
                }
            };
            this.#getMutator = () => {
                let mutator = {
                    nameChildToConnect: this.#nameChildToConnect,
                    internalCollision: this.#internalCollision,
                    breakForce: this.#breakForce,
                    breakTorque: this.#breakTorque
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.mutateBase(_mutator, ["internalCollision", "breakForce", "breakTorque"]);
            };
            this.bodyAnchor = _bodyAnchor;
            this.bodyTied = _bodyTied;
            /*
              Tell the physics that there is a new joint and on the physics start the actual joint is first created. Values can be set but the
              actual constraint ain't existent until the game starts
            */
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.hndEvent);
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.hndEvent);
        }
        static registerSubclass(_subclass) { return Joint.subclasses.push(_subclass) - 1; }
        /** Get/Set the first ComponentRigidbody of this connection. It should always be the one that this component is attached too in the sceneTree. */
        get bodyAnchor() {
            return this.#bodyAnchor;
        }
        set bodyAnchor(_cmpRB) {
            this.#idBodyAnchor = _cmpRB != null ? _cmpRB.id : -1;
            this.#bodyAnchor = _cmpRB;
            this.disconnect();
            this.dirtyStatus();
        }
        /** Get/Set the second ComponentRigidbody of this connection. */
        get bodyTied() {
            return this.#bodyTied;
        }
        set bodyTied(_cmpRB) {
            this.#idBodyTied = _cmpRB != null ? _cmpRB.id : -1;
            this.#bodyTied = _cmpRB;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The exact position where the two {@link Node}s are connected. When changed after initialization the joint needs to be reconnected.
         */
        get anchor() {
            return new FudgeCore.Vector3(this.#anchor.x, this.#anchor.y, this.#anchor.z);
        }
        set anchor(_value) {
            this.#anchor = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The amount of force needed to break the JOINT, while rotating, in Newton. 0 equals unbreakable (default)
        */
        get breakTorque() {
            return this.#breakTorque;
        }
        set breakTorque(_value) {
            this.#breakTorque = _value;
            if (this.joint != null)
                this.joint.setBreakTorque(this.#breakTorque);
        }
        /**
         * The amount of force needed to break the JOINT, in Newton. 0 equals unbreakable (default)
         */
        get breakForce() {
            return this.#breakForce;
        }
        set breakForce(_value) {
            this.#breakForce = _value;
            if (this.joint != null)
                this.joint.setBreakForce(this.#breakForce);
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
          * On a welding joint the connected bodies should not be colliding with each other,
          * for best results
         */
        get internalCollision() {
            return this.#internalCollision;
        }
        set internalCollision(_value) {
            this.#internalCollision = _value;
            if (this.joint != null)
                this.joint.setAllowCollision(this.#internalCollision);
        }
        /**
         * Connect a child node with the given name to the joint.
         */
        connectChild(_name) {
            this.#nameChildToConnect = _name;
            if (!this.node)
                return;
            let children = this.node.getChildrenByName(_name);
            if (children.length == 1)
                this.connectNode(children.pop());
            else
                FudgeCore.Debug.warn(`${this.constructor.name} at ${this.node.name} fails to connect child with non existent or ambigous name ${_name}`);
        }
        /**
         * Connect the given node to the joint. Tieing its rigidbody to the nodes rigidbody this component is attached to.
         */
        connectNode(_node) {
            if (!_node || !this.node)
                return;
            FudgeCore.Debug.fudge(`${this.constructor.name} connected ${this.node.name} and ${_node.name}`);
            let connectBody = _node.getComponent(FudgeCore.ComponentRigidbody);
            let thisBody = this.node.getComponent(FudgeCore.ComponentRigidbody);
            if (!connectBody || !thisBody) {
                FudgeCore.Debug.warn(`${this.constructor.name} at ${this.node.name} fails due to missing rigidbodies on ${this.node.name} or ${_node.name}`);
                return;
            }
            this.bodyAnchor = thisBody;
            this.bodyTied = connectBody;
        }
        /** Check if connection is dirty, so when either rb is changed disconnect and reconnect. Internally used no user interaction needed. */
        isConnected() {
            return this.#connected;
        }
        /**
         * Initializing and connecting the two rigidbodies with the configured joint properties
         * is automatically called by the physics system. No user interaction needed.
         */
        connect() {
            if (this.#connected == false) {
                if (this.#idBodyAnchor == -1 || this.#idBodyTied == -1) {
                    if (this.#nameChildToConnect)
                        this.connectChild(this.#nameChildToConnect);
                    return;
                }
                this.constructJoint();
                this.#connected = true;
                this.addJoint();
            }
        }
        /**
         * Disconnecting the two rigidbodies and removing them from the physics system,
         * is automatically called by the physics system. No user interaction needed.
         */
        disconnect() {
            if (this.#connected == true) {
                this.removeJoint();
                this.#connected = false;
            }
        }
        /**
         * Returns the original Joint used by the physics engine. Used internally no user interaction needed.
         * Only to be used when functionality that is not added within FUDGE is needed.
        */
        getOimoJoint() {
            return this.joint;
        }
        serialize() {
            let serialization = this.#getMutator();
            serialization.anchor = this.anchor.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.anchor = await new FudgeCore.Vector3().deserialize(_serialization.anchor);
            this.#mutate(_serialization);
            await super.deserialize(_serialization[super.constructor.name]);
            this.connectChild(_serialization.nameChildToConnect);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            Object.assign(mutator, this.#getMutator());
            mutator.anchor = this.anchor.getMutator();
            return mutator;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            types.nameChildToConnect = "String";
            return types;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (typeof (_mutator.anchor) !== "undefined")
                this.anchor = new FudgeCore.Vector3(...(Object.values(_mutator.anchor)));
            delete _mutator.anchor;
            if (typeof (_mutator.nameChildToConnect) !== "undefined")
                this.connectChild(_mutator.nameChildToConnect);
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        reduceMutator(_mutator) {
            delete _mutator.springDamper;
            delete _mutator.joint;
            delete _mutator.motor;
            super.reduceMutator(_mutator);
        }
        /** Tell the FudgePhysics system that this joint needs to be handled in the next frame. */
        dirtyStatus() {
            FudgeCore.Physics.changeJointStatus(this);
        }
        addJoint() {
            FudgeCore.Physics.addJoint(this);
        }
        removeJoint() {
            FudgeCore.Physics.removeJoint(this);
        }
        constructJoint(..._configParams) {
            let posBodyAnchor = this.bodyAnchor.node.mtxWorld.translation; //Setting the anchor position locally from the first rigidbody
            let worldAnchor = new OIMO.Vec3(posBodyAnchor.x + this.#anchor.x, posBodyAnchor.y + this.#anchor.y, posBodyAnchor.z + this.#anchor.z);
            // @ts-ignore    // unfortunately, method init is not a member of the base class OIMO.JointConfig
            this.config.init(this.#bodyAnchor.getOimoRigidbody(), this.#bodyTied.getOimoRigidbody(), worldAnchor, ..._configParams);
        }
        configureJoint() {
            this.joint.setBreakForce(this.breakForce);
            this.joint.setBreakTorque(this.breakTorque);
            this.joint.setAllowCollision(this.#internalCollision);
        }
        deleteFromMutator(_mutator, _delete) {
            for (let key in _delete)
                delete _mutator[key];
        }
        #getMutator;
        #mutate;
    }
    FudgeCore.Joint = Joint;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * Base class for joints operating with exactly one axis
       * @author Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class JointAxial extends FudgeCore.Joint {
        //Internal Variables
        #maxMotor = 10;
        #minMotor = -10;
        #motorSpeed = 0;
        #axis;
        #springFrequency = 0;
        #springDamping = 0;
        /** Creating a cylindrical joint between two ComponentRigidbodies moving on one axis and rotating around another bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.axis = _axis;
            this.anchor = _localAnchor;
            this.minMotor = -10;
            this.maxMotor = 10;
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axis() {
            return new FudgeCore.Vector3(this.#axis.x, this.#axis.y, this.#axis.z);
        }
        set axis(_value) {
            this.#axis = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        get maxMotor() {
            return this.#maxMotor;
        }
        set maxMotor(_value) {
            this.#maxMotor = _value;
            try {
                this.joint.getLimitMotor().upperLimit = _value;
            }
            catch (_e) { /* */ }
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        get minMotor() {
            return this.#minMotor;
        }
        set minMotor(_value) {
            this.#minMotor = _value;
            try {
                this.joint.getLimitMotor().lowerLimit = _value;
            }
            catch (_e) { /* */ }
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDamping() {
            return this.#springDamping;
        }
        set springDamping(_value) {
            this.#springDamping = _value;
            try {
                this.joint.getSpringDamper().dampingRatio = _value;
            }
            catch (_e) { /* */ }
        }
        /**
          * The target speed of the motor in m/s.
         */
        get motorSpeed() {
            return this.#motorSpeed;
        }
        set motorSpeed(_value) {
            this.#motorSpeed = _value;
            try {
                this.joint.getLimitMotor().motorSpeed = _value;
            }
            catch (_e) { /* */ }
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequency() {
            return this.#springFrequency;
        }
        set springFrequency(_value) {
            this.#springFrequency = _value;
            try {
                this.joint.getSpringDamper().frequency = _value;
            }
            catch (_e) { /* */ }
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.axis = this.axis.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.axis = await new FudgeCore.Vector3().deserialize(_serialization.axis);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (typeof (_mutator.axis) !== "undefined")
                this.axis = new FudgeCore.Vector3(...(Object.values(_mutator.axis)));
            delete _mutator.axis;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.axis = this.axis.getMutator();
            Object.assign(mutator, this.#getMutator());
            return mutator;
        }
        //#endregion
        constructJoint() {
            this.springDamper = new OIMO.SpringDamper().setSpring(this.#springFrequency, this.#springDamping);
            super.constructJoint(this.#axis);
        }
        #getMutator = () => {
            let mutator = {
                springDamping: this.#springDamping,
                springFrequency: this.#springFrequency,
                maxMotor: this.#maxMotor,
                minMotor: this.#minMotor,
                motorSpeed: this.#motorSpeed
            };
            return mutator;
        };
        #mutate = (_mutator) => {
            this.mutateBase(_mutator, ["springDamping", "springFrequency", "maxMotor", "minMotor", "motorSpeed"]);
        };
    }
    FudgeCore.JointAxial = JointAxial;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let MODE;
    (function (MODE) {
        MODE[MODE["EDITOR"] = 0] = "EDITOR";
        MODE[MODE["RUNTIME"] = 1] = "RUNTIME";
    })(MODE = FudgeCore.MODE || (FudgeCore.MODE = {}));
    let RESOURCE_STATUS;
    (function (RESOURCE_STATUS) {
        RESOURCE_STATUS[RESOURCE_STATUS["PENDING"] = 0] = "PENDING";
        RESOURCE_STATUS[RESOURCE_STATUS["READY"] = 1] = "READY";
        RESOURCE_STATUS[RESOURCE_STATUS["ERROR"] = 2] = "ERROR";
    })(RESOURCE_STATUS = FudgeCore.RESOURCE_STATUS || (FudgeCore.RESOURCE_STATUS = {}));
    /** A serializable resource implementing an id and a name so it can be managed by the {@link Project} */
    class SerializableResource extends FudgeCore.Implementable {
    } // allow check with instanceof 
    FudgeCore.SerializableResource = SerializableResource;
    /**
     * Static class handling the resources used with the current FUDGE-instance.
     * Keeps a list of the resources and generates ids to retrieve them.
     * Resources are objects referenced multiple times but supposed to be stored only once
     */
    class Project extends FudgeCore.EventTargetStatic {
        static { this.resources = {}; }
        static { this.serialization = {}; }
        static { this.scriptNamespaces = {}; }
        static { this.baseURL = new URL(location.toString()); }
        static { this.mode = MODE.RUNTIME; }
        static { this.graphInstancesToResync = {}; }
        /**
         * Registers the resource and generates an id for it by default.
         * If the resource already has an id, thus having been registered, its deleted from the list and registered anew.
         * It's possible to pass an id, but should not be done except by the Serializer.
         */
        static register(_resource, _idResource) {
            if (_resource.idResource && _resource.idResource == _idResource)
                return;
            if (_resource.idResource) // deregister the old id
                this.deregister(_resource);
            if (_idResource) {
                _resource.idResource = _idResource;
                this.deregister(_resource); // deregister the new id
            }
            if (!_resource.idResource)
                _resource.idResource = Project.generateId(_resource);
            Project.resources[_resource.idResource] = _resource;
            if (_resource instanceof FudgeCore.Graph)
                _resource.addEventListener("graphMutated" /* EVENT.GRAPH_MUTATED */, (_event) => this.dispatchEvent(new CustomEvent("graphMutated" /* EVENT.GRAPH_MUTATED */, { detail: _resource })));
        }
        /**
         * Removes the resource from the list of resources.
         */
        static deregister(_resource) {
            delete (Project.resources[_resource.idResource]);
            delete (Project.serialization[_resource.idResource]);
        }
        /**
         * Clears the list of resources and their serialization, thus removing all resources.
         */
        static clear() {
            Project.resources = {};
            Project.serialization = {};
            Project.clearScriptNamespaces();
            // Project.scriptNamespaces = {};
        }
        // <T extends Component>(_class: new () => T): T[] {
        //   return <T[]>(this.components[_class.name] || []).slice(0);
        // }
        /**
         * Returns an array of all resources of the requested type.
         */
        static getResourcesByType(_type) {
            let found = [];
            for (let resourceId in Project.resources) {
                let resource = Project.resources[resourceId];
                if (resource instanceof _type)
                    found.push(resource);
            }
            return found;
        }
        /**
         * Returns an array of all resources with the requested name.
         */
        static getResourcesByName(_name) {
            let found = [];
            for (let resourceId in Project.resources) {
                let resource = Project.resources[resourceId];
                if (resource.name == _name)
                    found.push(resource);
            }
            return found;
        }
        /**
         * Generate a user readable and unique id using the type of the resource, the date and random numbers
         * @param _resource
         */
        static generateId(_resource) {
            // TODO: build id and integrate info from resource, not just date
            let idResource;
            do
                idResource = _resource.constructor.name + "|" + new Date().toISOString() + "|" + Math.random().toPrecision(5).substr(2, 5);
            while (Project.resources[idResource]);
            return idResource;
        }
        /**
         * Tests, if an object is a {@link SerializableResource}
         * @param _object The object to examine
         */
        static isResource(_object) {
            return (Reflect.has(_object, "idResource"));
        }
        /**
         * Retrieves the resource stored with the given id
         */
        static async getResource(_idResource) {
            let resource = Project.resources[_idResource];
            if (!resource) {
                let serialization = Project.serialization[_idResource];
                if (!serialization) {
                    FudgeCore.Debug.error("Resource not found", _idResource);
                    return null;
                }
                resource = await Project.deserializeResource(serialization);
            }
            return resource;
        }
        static async cloneResource(_resource) {
            if (!_resource)
                return null;
            let serialization = FudgeCore.Serializer.serialize(_resource);
            let type = Reflect.ownKeys(serialization)[0];
            delete (serialization[type].idResource);
            let clone = await Project.deserializeResource(serialization);
            Project.register(clone);
            clone.name += "_clone";
            return clone;
        }
        /**
         * Creates and registers a resource from a {@link Node}, copying the complete graph starting with it
         * @param _node A node to create the resource from
         * @param _replaceWithInstance if true (default), the node used as origin is replaced by a {@link GraphInstance} of the {@link Graph} created
         */
        static async registerAsGraph(_node, _replaceWithInstance = true) {
            let serialization = _node.serialize();
            let graph = new FudgeCore.Graph(_node.name);
            await graph.deserialize(serialization);
            Project.register(graph);
            if (_replaceWithInstance && _node.getParent()) {
                let instance = await Project.createGraphInstance(graph);
                _node.getParent().replaceChild(_node, instance);
            }
            return graph;
        }
        /**
         * Creates and returns a {@link GraphInstance} of the given {@link Graph}
         * and connects it to the graph for synchronisation of mutation.
         */
        static async createGraphInstance(_graph) {
            let instance = new FudgeCore.GraphInstance(_graph); // TODO: cleanup since creation moved here
            await instance.connectToGraph();
            return instance;
        }
        /**
         * Register the given {@link GraphInstance} to be resynced
         */
        static registerGraphInstanceForResync(_instance) {
            let instances = Project.graphInstancesToResync[_instance.idSource] || [];
            instances.push(_instance);
            Project.graphInstancesToResync[_instance.idSource] = instances;
        }
        /**
         * Resync all {@link GraphInstance} registered to the given {@link Graph}
         */
        static async resyncGraphInstances(_graph) {
            let instances = Project.graphInstancesToResync[_graph.idResource];
            if (!instances)
                return;
            for (let instance of instances)
                await instance.connectToGraph();
            delete (Project.graphInstancesToResync[_graph.idResource]);
        }
        /**
         * Register the given namespace to the list of script-namespaces.
         */
        static registerScriptNamespace(_namespace) {
            let name = FudgeCore.Serializer.registerNamespace(_namespace);
            if (!Project.scriptNamespaces[name])
                Project.scriptNamespaces[name] = _namespace;
        }
        /**
         * Clear the list of script-namespaces.
         */
        static clearScriptNamespaces() {
            for (let name in Project.scriptNamespaces) {
                Reflect.set(window, name, undefined);
                Project.scriptNamespaces[name] = undefined;
                delete Project.scriptNamespaces[name];
            }
        }
        /**
         * Collects all {@link ComponentScript}s registered in {@link Project.scriptNamespaces} and returns them.
         */
        static getComponentScripts() {
            let compoments = {};
            for (let namespace in Project.scriptNamespaces) {
                compoments[namespace] = [];
                for (let name in Project.scriptNamespaces[namespace]) {
                    let script = Reflect.get(Project.scriptNamespaces[namespace], name);
                    // Using Object.create doesn't call the constructor, but instanceof can be used. More elegant than the loop above, though maybe not as performant. 
                    try {
                        let o = Object.create(script);
                        if (o.prototype instanceof FudgeCore.ComponentScript)
                            compoments[namespace].push(script);
                    }
                    catch (_e) { /* */ }
                }
            }
            return compoments;
        }
        /**
         * Loads a script from the given URL and integrates it into a {@link HTMLScriptElement} in the {@link document.head}
         */
        static async loadScript(_url) {
            let script = document.createElement("script");
            script.type = "text/javascript";
            // script.type = "module";
            script.async = false;
            // script.addEventListener("load", handleLoadedScript)
            let head = document.head;
            head.appendChild(script);
            FudgeCore.Debug.log("Loading: ", _url);
            return new Promise((_resolve, _reject) => {
                script.addEventListener("load", () => _resolve());
                script.addEventListener("error", () => {
                    FudgeCore.Debug.error("Loading script", _url);
                    _reject();
                });
                script.src = _url.toString();
            });
        }
        /**
         * Load {@link Resources} from the given url
         */
        static async loadResources(_url) {
            const response = await fetch(_url);
            const resourceFileContent = await response.text();
            let serialization = FudgeCore.Serializer.parse(resourceFileContent);
            let reconstruction = await Project.deserialize(serialization);
            Project.dispatchEvent(new CustomEvent("resourcesLoaded" /* EVENT.RESOURCES_LOADED */, { detail: { url: _url, resources: reconstruction } }));
            return reconstruction;
        }
        /**
         * Load all resources from the {@link document.head}
         */
        static async loadResourcesFromHTML() {
            const head = document.head;
            let links = head.querySelectorAll("link[type=resources]");
            for (let link of links) {
                let url = link.getAttribute("src");
                await Project.loadResources(url);
            }
        }
        /**
         * Serialize all resources
         */
        static serialize() {
            let serialization = {};
            for (let idResource in Project.resources) {
                let resource = Project.resources[idResource];
                if (idResource != resource.idResource)
                    FudgeCore.Debug.error("Resource-id mismatch", resource);
                serialization[idResource] = FudgeCore.Serializer.serialize(resource);
            }
            return serialization;
        }
        /**
         * Create resources from a serialization, deleting all resources previously registered
         * @param _serialization
         */
        static async deserialize(_serialization) {
            Project.serialization = _serialization;
            Project.resources = {};
            for (let idResource in _serialization) {
                let serialization = _serialization[idResource];
                let resource = await Project.deserializeResource(serialization);
                if (resource)
                    Project.resources[idResource] = resource;
            }
            return Project.resources;
        }
        static async deserializeResource(_serialization) {
            return FudgeCore.Serializer.deserialize(_serialization);
        }
    }
    FudgeCore.Project = Project;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * - CRISP: no mipmapping, mag filter nearest, min filter nearest
     * - MEDIUM: mipmapping, mag filter nearest, min filter nearest_mipmap_linear
     * - BLURRY: mipmapping, mag filter linear, min filter linear_mipmap_linear
     * - SMOOTH: no mipmapping, mag filter linear, min filter linear
     */
    let MIPMAP;
    (function (MIPMAP) {
        MIPMAP[MIPMAP["CRISP"] = 0] = "CRISP";
        MIPMAP[MIPMAP["MEDIUM"] = 1] = "MEDIUM";
        MIPMAP[MIPMAP["BLURRY"] = 2] = "BLURRY";
        MIPMAP[MIPMAP["SMOOTH"] = 3] = "SMOOTH";
    })(MIPMAP = FudgeCore.MIPMAP || (FudgeCore.MIPMAP = {}));
    let WRAP;
    (function (WRAP) {
        WRAP[WRAP["REPEAT"] = 0] = "REPEAT";
        WRAP[WRAP["CLAMP"] = 1] = "CLAMP";
        WRAP[WRAP["MIRROR"] = 2] = "MIRROR";
    })(WRAP = FudgeCore.WRAP || (FudgeCore.WRAP = {}));
    /**
     * Baseclass for different kinds of textures.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let Texture = (() => {
        var _a, _b;
        let _classDecorators = [(_a = FudgeCore.RenderInjectorTexture).decorate.bind(_a), (_b = FudgeCore.SerializableResource).register.bind(_b)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Mutable;
        var Texture = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                Texture = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(_classThis, _classExtraInitializers);
            }
            #mipmap;
            #wrap;
            constructor(_name = "Texture") {
                super();
                this.idResource = undefined;
                this.textureDirty = true;
                this.mipmapDirty = true;
                this.wrapDirty = true;
                this.#mipmap = MIPMAP.CRISP;
                this.#wrap = WRAP.REPEAT;
                this.name = _name;
            }
            set mipmap(_mipmap) {
                this.#mipmap = _mipmap;
                this.mipmapDirty = true;
            }
            get mipmap() {
                return this.#mipmap;
            }
            set wrap(_wrap) {
                this.#wrap = _wrap;
                this.wrapDirty = true;
            }
            get wrap() {
                return this.#wrap;
            }
            /**
             * Generates and binds the texture in WebGL from the {@link texImageSource}.
             * Injected by {@link RenderInjectorTexture}. Used by the render system.
             * @internal
             */
            useRenderData(_textureUnit = 0) { }
            /**
             * Deletes the texture in WebGL freeing the allocated gpu memory.
             * Injected by {@link RenderInjectorTexture}.
             * @internal
             */
            deleteRenderData() { }
            /**
             * Refreshes the image data in the render engine.
             */
            refresh() {
                this.textureDirty = true;
            }
            //#region Transfer
            serialize() {
                let serialization = {
                    idResource: this.idResource,
                    name: this.name,
                    mipmap: MIPMAP[this.#mipmap],
                    wrap: WRAP[this.#wrap]
                };
                return serialization;
            }
            async deserialize(_serialization) {
                FudgeCore.Project.register(this, _serialization.idResource);
                this.name = _serialization.name;
                this.#mipmap = MIPMAP[_serialization.mipmap];
                this.#wrap = WRAP[_serialization.wrap];
                return this;
            }
            getMutator(_extendable) {
                let mutator = super.getMutator(true);
                mutator.mipmap = this.#mipmap;
                mutator.wrap = this.#wrap;
                return mutator;
            }
            getMutatorAttributeTypes(_mutator) {
                let types = super.getMutatorAttributeTypes(_mutator);
                if (types.mipmap)
                    types.mipmap = MIPMAP;
                if (types.wrap)
                    types.wrap = WRAP;
                return types;
            }
            reduceMutator(_mutator) {
                delete _mutator.idResource;
                delete _mutator.renderData;
                delete _mutator.textureDirty;
                delete _mutator.mipmapDirty;
                delete _mutator.mipmapGenerated;
                delete _mutator.wrapDirty;
            }
        };
        return Texture = _classThis;
    })();
    FudgeCore.Texture = Texture;
    /**
     * Texture created from an existing image
     */
    class TextureImage extends Texture {
        constructor(_url) {
            super();
            this.image = null;
            if (_url) {
                this.load(_url);
                this.name = _url.toString().split("/").pop();
            }
            FudgeCore.Project.register(this);
        }
        get texImageSource() {
            return this.image;
        }
        /**
         * Asynchronously loads the image from the given url
         */
        async load(_url) {
            this.url = _url;
            this.image = new Image();
            // const response: Response = await window.fetch(this.url);
            // const blob: Blob = await response.blob();
            // let objectURL: string = URL.createObjectURL(blob);
            // this.image.src = objectURL;
            return new Promise((_resolve, _reject) => {
                this.image.addEventListener("load", () => {
                    this.renderData = null; // refresh render data on next draw call
                    _resolve();
                });
                this.image.addEventListener("error", () => _reject());
                this.image.src = new URL(this.url.toString(), FudgeCore.Project.baseURL).toString();
            });
        }
        //#region Transfer
        serialize() {
            return {
                url: this.url,
                type: this.type, // serialize for editor views
                [super.constructor.name]: super.serialize()
            };
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            await this.load(_serialization.url);
            // this.type is an accessor of Mutable doesn't need to be deserialized
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (_mutator.url && _mutator.url != this.url.toString())
                await this.load(_mutator.url);
            // except url from mutator for further processing
            delete (_mutator.url);
            await super.mutate(_mutator, _selection, _dispatchMutate);
            // TODO: examine necessity to reconstruct, if mutator is kept by caller
            // _mutator.url = this.url; 
        }
    }
    FudgeCore.TextureImage = TextureImage;
    /**
     * Texture created from a canvas
     */
    class TextureBase64 extends Texture {
        constructor(_name, _base64, _mipmap = MIPMAP.CRISP, _wrap = WRAP.REPEAT, _width, _height) {
            super(_name);
            this.image = new Image();
            this.image.src = _base64;
            this.mipmap = _mipmap;
            this.wrap = _wrap;
            if (_width)
                this.image.width = _width;
            if (_height)
                this.image.height = _height;
        }
        get texImageSource() {
            return this.image;
        }
    }
    FudgeCore.TextureBase64 = TextureBase64;
    /**
     * Texture created from a canvas
     */
    class TextureCanvas extends Texture {
        constructor(_name, _crc2) {
            super(_name);
            this.crc2 = _crc2;
        }
        get texImageSource() {
            return this.crc2.canvas;
        }
    }
    FudgeCore.TextureCanvas = TextureCanvas;
    /**
     * Texture created from a text. Texture upates when the text or font changes. The texture is resized to fit the text.
     * @authors Jonas Plotzky, HFU, 2024
     */
    class TextureText extends Texture {
        #text;
        #font;
        constructor(_name, _text = "Text", _font = "20px monospace") {
            super(_name);
            this.crc2 = document.createElement("canvas").getContext("2d");
            this.text = _text;
            this.font = _font;
        }
        set text(_text) {
            this.#text = _text;
            this.textureDirty = true;
        }
        get text() {
            return this.#text;
        }
        set font(_font) {
            this.#font = _font;
            document.fonts.load(this.#font)
                .catch((_error) => FudgeCore.Debug.error(`${TextureText.name}: ${_error}`))
                .finally(() => this.textureDirty = true);
        }
        get font() {
            return this.#font;
        }
        get texImageSource() {
            return this.canvas;
        }
        get width() {
            return this.canvas.width;
        }
        get height() {
            return this.canvas.height;
        }
        get hasTransparency() {
            return true;
        }
        get canvas() {
            return this.crc2.canvas;
        }
        useRenderData(_textureUnit) {
            if (this.textureDirty) {
                this.crc2.font = this.font;
                let metrics = this.crc2.measureText(this.text);
                let width = metrics.width;
                let height = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
                this.canvas.width = width + this.crc2.measureText("  ").width;
                this.canvas.height = height * 1.1; // padding, otherwise on some glyphs might get cut off
                if (this.canvas.width == 0)
                    return;
                this.crc2.font = this.font; // TODO: wait for font to be loaded using document.fonts
                this.crc2.textAlign = "center";
                this.crc2.textBaseline = "middle";
                this.crc2.fillStyle = "white";
                this.crc2.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.crc2.fillText(this.#text, this.canvas.width / 2, this.canvas.height / 2);
            }
            super.useRenderData(_textureUnit);
        }
        serialize() {
            return {
                [super.constructor.name]: super.serialize(),
                text: this.text,
                font: this.font
            };
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            this.text = _serialization.text;
            this.font = _serialization.font;
            return this;
        }
        getMutator(_extendable) {
            let mutator = super.getMutator(true);
            mutator.text = this.text;
            mutator.font = this.font;
            return mutator;
        }
    }
    FudgeCore.TextureText = TextureText;
    /**
     * Texture created from a FUDGE-Sketch
     */
    class TextureSketch extends TextureCanvas {
        get texImageSource() {
            return null;
        }
    }
    FudgeCore.TextureSketch = TextureSketch;
    /**
     * Texture created from an HTML-page
     */
    class TextureHTML extends TextureCanvas {
        get texImageSource() {
            return null;
        }
    }
    FudgeCore.TextureHTML = TextureHTML;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Abstract base class for all meshes.
     * Meshes provide indexed vertices, the order of indices to create trigons and normals, and texture coordinates
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019/22
     */
    let Mesh = (() => {
        var _a, _b;
        let _classDecorators = [(_a = FudgeCore.RenderInjectorMesh).decorate.bind(_a), (_b = FudgeCore.SerializableResource).register.bind(_b)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Mutable;
        var Mesh = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                Mesh = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
            static { this.baseClass = Mesh; }
            /** list of all the subclasses derived from this class, if they registered properly*/
            static { this.subclasses = []; }
            #renderMesh;
            constructor(_name = "Mesh") {
                super();
                // TODO: rename vertices to verticesSmooth or just cloud, and cloud to vertices
                this.idResource = undefined;
                this.name = "Mesh";
                // base structure for meshes in FUDGE
                this.vertices = new FudgeCore.Vertices();
                this.faces = [];
                this.name = _name;
                this.clear();
                FudgeCore.Project.register(this);
            }
            static registerSubclass(_subClass) { return Mesh.subclasses.push(_subClass) - 1; }
            get renderMesh() {
                if (this.#renderMesh == null)
                    this.#renderMesh = new FudgeCore.RenderMesh(this);
                return this.#renderMesh;
            }
            get boundingBox() {
                if (this.∆íbox == null)
                    this.∆íbox = this.createBoundingBox();
                return this.∆íbox;
            }
            get radius() {
                if (this.∆íradius == null)
                    this.∆íradius = this.createRadius();
                return this.∆íradius;
            }
            /**
             * Injected by {@link RenderInjectorMesh}.
             * Used by the render system.
             * @internal
             */ // TODO: rename this
            useRenderBuffers() { return null; /* injected by RenderInjector*/ }
            /**
             * Injected by {@link RenderInjectorMesh}.
             * Used by the render system.
             * @internal
             */
            getRenderBuffers() { return null; /* injected by RenderInjector*/ }
            /**
             * Injected by {@link RenderInjectorMesh}.
             * Used by the render system.
             * @internal
             */
            deleteRenderBuffers(_renderBuffers) { }
            /**
             * Clears the bounds of this mesh aswell as the buffers of the associated {@link RenderMesh}.
             */
            clear() {
                this.∆íbox = undefined;
                this.∆íradius = undefined;
                this.deleteRenderBuffers(this.renderMesh.buffers);
                this.renderMesh.clear();
            }
            //#region Transfer
            // Serialize/Deserialize for all meshes that calculate without parameters
            serialize() {
                let serialization = {
                    idResource: this.idResource,
                    name: this.name,
                    type: this.type // store for editor view
                }; // no data needed ...
                return serialization;
            }
            async deserialize(_serialization) {
                FudgeCore.Project.register(this, _serialization.idResource);
                this.name = _serialization.name;
                // type is an accessor and must not be deserialized
                return this;
            }
            reduceMutator(_mutator) {
                // TODO: so much to delete... rather just gather what to mutate
                delete _mutator.∆íbox;
                delete _mutator.∆íradius;
                delete _mutator.renderBuffers;
            }
            //#endregion
            createRadius() {
                //TODO: radius and bounding box could be created on construction of vertex-array
                let radius = 0;
                for (let i = 0; i < this.vertices.length; i++) {
                    radius = Math.max(radius, this.vertices.position(i).magnitudeSquared);
                }
                return Math.sqrt(radius);
            }
            createBoundingBox() {
                let box = FudgeCore.Recycler.get(FudgeCore.Box);
                box.set();
                for (let i = 0; i < this.vertices.length; i++) {
                    let point = this.vertices.position(i);
                    box.expand(point);
                }
                return box;
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return Mesh = _classThis;
    })();
    FudgeCore.Mesh = Mesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for materials. Combines a {@link Shader} with a compatible {@link Coat}
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let Material = (() => {
        var _a;
        let _classDecorators = [FudgeCore.enumerate, (_a = FudgeCore.SerializableResource).register.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Mutable;
        let _instanceExtraInitializers = [];
        let _get_coat_decorators;
        var Material = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _get_coat_decorators = [FudgeCore.type(FudgeCore.Coat), FudgeCore.enumerate];
                __esDecorate(this, null, _get_coat_decorators, { kind: "getter", name: "coat", static: false, private: false, access: { has: obj => "coat" in obj, get: obj => obj.coat }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                Material = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(_classThis, _classExtraInitializers);
            }
            #coat;
            constructor(_name, _shader, _coat) {
                super();
                /** The name to call the Material by. */
                this.name = __runInitializers(this, _instanceExtraInitializers);
                this.idResource = undefined;
                this.name = _name;
                this.shaderType = _shader;
                if (_shader) {
                    if (_coat)
                        this.coat = _coat;
                    else
                        this.coat = this.createCoatMatchingShader();
                }
                FudgeCore.Project.register(this);
            }
            /**
             * Returns the currently referenced {@link Coat} instance
             */
            get coat() {
                return this.#coat;
            }
            /**
             * Makes this material reference the given {@link Coat} if it is compatible with the referenced {@link Shader}
             */
            set coat(_coat) {
                if (this.shaderType)
                    if (_coat.constructor != this.shaderType.getCoat())
                        if (_coat instanceof this.shaderType.getCoat())
                            FudgeCore.Debug.fudge("Coat is extension of Coat required by shader");
                        else
                            throw (new Error("Shader and coat don't match"));
                this.#coat = _coat;
            }
            /**
             * Creates a new {@link Coat} instance that is valid for the {@link Shader} referenced by this material
             */
            createCoatMatchingShader() {
                let coat = new (this.shaderType.getCoat())();
                return coat;
            }
            /**
             * Changes the materials reference to the given {@link Shader}, creates and references a new {@link Coat} instance
             * and mutates the new coat to preserve matching properties.
             * @param _shaderType
             */
            setShader(_shaderType) {
                this.shaderType = _shaderType;
                let coat = this.createCoatMatchingShader();
                coat.mutate(this.#coat?.getMutator());
                this.coat = coat;
            }
            /**
             * Returns the {@link Shader} referenced by this material
             */
            getShader() {
                return this.shaderType;
            }
            //#region Transfer
            // TODO: this type of serialization was implemented for implicit Material create. Check if obsolete when only one material class exists and/or materials are stored separately
            serialize() {
                let serialization = {
                    name: this.name,
                    idResource: this.idResource,
                    shader: this.shaderType.name,
                    coat: FudgeCore.Serializer.serialize(this.#coat),
                };
                return serialization;
            }
            async deserialize(_serialization) {
                this.name = _serialization.name;
                FudgeCore.Project.register(this, _serialization.idResource);
                this.shaderType = FudgeCore[_serialization.shader];
                let coat = await FudgeCore.Serializer.deserialize(_serialization.coat);
                this.coat = coat;
                return this;
            }
            reduceMutator(_mutator) {
                // delete _mutator.idResource;
            }
        };
        return Material = _classThis;
    })();
    FudgeCore.Material = Material;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The namesapce for handling the particle data
     */
    let ParticleData;
    (function (ParticleData) {
        /**
         * Returns true if the given data is a {@link Expression}
         */
        function isExpression(_data) {
            return isFunction(_data) || isVariable(_data) || isConstant(_data) || isCode(_data);
        }
        ParticleData.isExpression = isExpression;
        /**
         * Returns true if the given data is a {@link Function}
         */
        function isFunction(_data) {
            return typeof _data == "object" && "function" in _data;
        }
        ParticleData.isFunction = isFunction;
        /**
         * Returns true if the given data is a {@link Variable}
         */
        function isVariable(_data) {
            return typeof _data == "object" && "value" in _data && typeof _data.value == "string";
        }
        ParticleData.isVariable = isVariable;
        /**
         * Returns true if the given data is a {@link Constant}
         */
        function isConstant(_data) {
            return typeof _data == "object" && "value" in _data && typeof _data.value == "number";
        }
        ParticleData.isConstant = isConstant;
        /**
         * Returns true if the given data is a {@link Code}
         */
        function isCode(_data) {
            return typeof _data == "object" && "code" in _data;
        }
        ParticleData.isCode = isCode;
        /**
         * Returns true if the given data is a {@link Transformation}
         */
        function isTransformation(_data) {
            return typeof _data == "object" && "transformation" in _data;
        }
        ParticleData.isTransformation = isTransformation;
    })(ParticleData = FudgeCore.ParticleData || (FudgeCore.ParticleData = {}));
    /**
     * Holds information on how to mutate the particles of a particle system.
     * A full particle system is composed by attaching a {@link ComponentParticleSystem}, {@link ComponentMesh} and {@link ComponentMaterial} to the same {@link Node}.
     * Additionally a {@link ComponentFaceCamera} can be attached to make the particles face the camera.
     * @authors Jonas Plotzky, HFU, 2022
     */
    let ParticleSystem = (() => {
        var _a;
        let _classDecorators = [(_a = FudgeCore.SerializableResource).register.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Mutable;
        var ParticleSystem = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                ParticleSystem = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(_classThis, _classExtraInitializers);
            }
            #data;
            /** Map of shader universal derivates to corresponding computed {@link ShaderParticleSystem}.
             * This way each particle system resource can be used in conjunction with multiple shader universal derivates */
            #shaderToShaderParticleSystem;
            constructor(_name = ParticleSystem.name, _data = {}) {
                super();
                this.idResource = undefined;
                /** Map of shader universal derivates to corresponding computed {@link ShaderParticleSystem}.
                 * This way each particle system resource can be used in conjunction with multiple shader universal derivates */
                this.#shaderToShaderParticleSystem = new Map();
                this.name = _name;
                this.data = _data;
                FudgeCore.Project.register(this);
            }
            get data() {
                return this.#data;
            }
            set data(_data) {
                this.#data = _data;
                this.#shaderToShaderParticleSystem.forEach(_shader => _shader.deleteProgram());
                this.#shaderToShaderParticleSystem.clear();
            }
            /**
             * Returns a corresponding {@link ShaderParticleSystem} for the given shader universal derivate.
             * Used by the render system to render the particle system.
             * @returns the corresponding {@link ShaderParticleSystem}
             * @internal
             */
            getShaderFrom(_source) {
                if (!this.#shaderToShaderParticleSystem.has(_source)) {
                    let particleShader = new FudgeCore.ShaderParticleSystem();
                    particleShader.data = this.data;
                    particleShader.define = [...particleShader.define, ..._source.define];
                    particleShader.vertexShaderSource = _source.getVertexShaderSource();
                    particleShader.fragmentShaderSource = _source.getFragmentShaderSource();
                    this.#shaderToShaderParticleSystem.set(_source, particleShader);
                }
                return this.#shaderToShaderParticleSystem.get(_source);
            }
            //#region Transfer
            serialize() {
                let serialization = {
                    idResource: this.idResource,
                    name: this.name,
                    data: this.data
                };
                return serialization;
            }
            async deserialize(_serialization) {
                FudgeCore.Project.register(this, _serialization.idResource);
                this.name = _serialization.name;
                this.data = _serialization.data;
                return this;
            }
            reduceMutator(_mutator) {
                delete _mutator.cachedMutators;
                delete _mutator.shaderMap;
            }
        };
        return ParticleSystem = _classThis;
    })();
    FudgeCore.ParticleSystem = ParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Buffers the bone data from the {@link ComponentSkeleton} into a WebGL Buffer
     * @internal
     */
    class RenderInjectorComponentSkeleton {
        static decorate(_constructor, _context) {
            Object.defineProperty(_constructor.prototype, _constructor.prototype.useRenderBuffer.name, {
                value: RenderInjectorComponentSkeleton.useRenderBuffer
            });
            Object.defineProperty(_constructor.prototype, _constructor.prototype.updateRenderBuffer.name, {
                value: RenderInjectorComponentSkeleton.updateRenderBuffer
            });
            Object.defineProperty(_constructor.prototype, _constructor.prototype.deleteRenderBuffer.name, {
                value: RenderInjectorComponentSkeleton.deleteRenderBuffer
            });
        }
        static useRenderBuffer() {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.renderBuffer)
                crc3.bindBufferBase(WebGL2RenderingContext.UNIFORM_BUFFER, FudgeCore.UNIFORM_BLOCK.SKIN.BINDING, this.renderBuffer);
        }
        static updateRenderBuffer() {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (!this.renderBuffer) {
                const bonesByteSize = 256 * 16 * 4; // CAUTION: this is dependent on the shader source code where 256 is the maximum number of bones
                this.renderBuffer = FudgeCore.RenderWebGL.assert(crc3.createBuffer());
                crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, this.renderBuffer);
                crc3.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, bonesByteSize, WebGL2RenderingContext.DYNAMIC_DRAW);
            }
            const data = new Float32Array(this.mtxBones.length * 16);
            for (let i = 0; i < this.mtxBones.length; i++)
                data.set(this.mtxBones[i].get(), i * 16);
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, this.renderBuffer);
            crc3.bufferSubData(WebGL2RenderingContext.UNIFORM_BUFFER, 0, data);
        }
        static deleteRenderBuffer() {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.renderBuffer)
                crc3.deleteBuffer(this.renderBuffer);
        }
    }
    FudgeCore.RenderInjectorComponentSkeleton = RenderInjectorComponentSkeleton;
})(FudgeCore || (FudgeCore = {}));
///<reference path="./../Render/RenderInjectorComponentSkeleton.ts"/>
var FudgeCore;
///<reference path="./../Render/RenderInjectorComponentSkeleton.ts"/>
(function (FudgeCore) {
    /**
     * Holds an array of bones ({@link Node}s within a {@link Graph}). Referenced from a {@link ComponentMesh} it can be associated with a {@link Mesh} and enable skinning for the mesh.
     * @authors Matthias Roming, HFU, 2022-2023 | Jonas Plotzky, HFU, 2023
     */
    let ComponentSkeleton = (() => {
        var _a;
        let _classDecorators = [(_a = FudgeCore.RenderInjectorComponentSkeleton).decorate.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Component;
        var ComponentSkeleton = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                ComponentSkeleton = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(_classThis, _classExtraInitializers);
            }
            constructor(_bones = [], _mtxBoneInverses = []) {
                super();
                this.singleton = false;
                /** Contains the bone transformations applicable to the vertices of a {@link Mesh} */
                this.mtxBones = [];
                this.bones = _bones;
                this.mtxBindInverses = _mtxBoneInverses;
                for (let i = 0; i < this.bones.length; i++)
                    if (this.mtxBindInverses[i] == null)
                        this.mtxBindInverses[i] = this.bones[i].mtxWorldInverse.clone;
            }
            /**
             * Injected by {@link RenderInjectorComponentSkeleton}.
             * Used by the render system.
             * @internal
             */
            useRenderBuffer() { }
            ;
            /**
             * Injected by {@link RenderInjectorComponentSkeleton}.
             * Used by the render system.
             * @internal
             */
            updateRenderBuffer() { }
            /**
             * Injected by {@link RenderInjectorComponentSkeleton}.
             * Used by the render system.
             * @internal
             */
            deleteRenderBuffer() { }
            /**
             * Adds a node as a bone with its bind inverse matrix
             */
            addBone(_bone, _mtxBindInverse = _bone.mtxWorldInverse.clone) {
                this.bones.push(_bone);
                this.mtxBindInverses.push(_mtxBindInverse);
            }
            indexOf(_name) {
                if (typeof (_name) == "string")
                    return this.bones.findIndex((_bone) => _bone.name == _name);
                else
                    return this.bones.indexOf(_name);
            }
            /**
             * Updates the bone matrices to be used by the shader
             */
            update() {
                for (const mtxBone of this.mtxBones)
                    FudgeCore.Recycler.store(mtxBone);
                this.mtxBones.length = 0;
                for (let i = 0; i < this.bones.length; i++) {
                    FudgeCore.PerformanceMonitor.startMeasure("ComponentSkeleton.update mtxWorld * mtxBindInverses");
                    let mtxBone = FudgeCore.Matrix4x4.PRODUCT(this.bones[i].mtxWorld, this.mtxBindInverses[i]);
                    FudgeCore.PerformanceMonitor.endMeasure("ComponentSkeleton.update mtxWorld * mtxBindInverses");
                    this.mtxBones.push(mtxBone);
                }
            }
            /**
             * Resets the pose of this skeleton to the default pose
             */
            resetPose() {
                for (let i = 0; i < this.bones.length; i++)
                    this.bones[i].mtxLocal.copy(FudgeCore.Matrix4x4.INVERSE(this.mtxBindInverses[i]));
            }
            serialize() {
                const serialization = {};
                serialization[super.constructor.name] = super.serialize();
                serialization.bones = this.bones.map(_bone => FudgeCore.Node.PATH_FROM_TO(this, _bone));
                serialization.mtxBindInverses = FudgeCore.Serializer.serializeArray(FudgeCore.Matrix4x4, this.mtxBindInverses);
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization[super.constructor.name]);
                const hndNodeDeserialized = () => {
                    this.bones = _serialization.bones.map((_path) => {
                        let bone = FudgeCore.Node.FIND(this, _path);
                        if (!bone)
                            throw new Error(`${FudgeCore.Node.name} "${this.node.name}" ${ComponentSkeleton.name}: Could not find bone ${_path}`);
                        return bone;
                    });
                    this.removeEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
                };
                this.addEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
                this.mtxBindInverses = await FudgeCore.Serializer.deserializeArray(_serialization.mtxBindInverses);
                return this;
            }
        };
        return ComponentSkeleton = _classThis;
    })();
    FudgeCore.ComponentSkeleton = ComponentSkeleton;
})(FudgeCore || (FudgeCore = {}));
/// <reference path="Debug/Performance.ts"/>
/// <reference path="Debug/DebugTarget.ts"/>
/// <reference path="Debug/Debug.ts"/>
// / <reference path="Time/Time.ts"/>
/// <reference path="Event/Event.ts"/>
/// <reference path="Serialization/Mutable.ts"/>
/// <reference path="Serialization/Serializer.ts"/> 
/// <reference path="Render/RenderWebGL.ts"/>
/// <reference path="Render/RenderInjectorTexture.ts"/>
/// <reference path="Graph/Node.ts"/>
/// <reference path="Component/Component.ts"/>
/// <reference path="Recycle/RecycableArray.ts"/>
/// <reference path="Physics/HelpersPhysics.ts"/>
/// <reference path="Physics/Joint.ts"/>
/// <reference path="Physics/JointAxial.ts"/>
/// <reference path="Serialization/Project.ts"/>
/// <reference path="Texture/Texture.ts"/>
/// <reference path="Mesh/Mesh.ts"/>
/// <reference path="Material/Material.ts"/>
/// <reference path="ParticleSystem/ParticleSystem.ts"/>
/// <reference path="Component/ComponentSkeleton.ts"/>
//global functions
function ifNumber(_check, _default) {
    return typeof _check == "undefined" ? _default : _check;
}
var FudgeCore;
(function (FudgeCore) {
    /**
     * Internally used to differentiate between the various generated structures and events.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_STRUCTURE_TYPE;
    (function (ANIMATION_STRUCTURE_TYPE) {
        /**Default: forward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["NORMAL"] = 0] = "NORMAL";
        /**backward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["REVERSE"] = 1] = "REVERSE";
        /**forward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTERED"] = 2] = "RASTERED";
        /**backward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTEREDREVERSE"] = 3] = "RASTEREDREVERSE";
    })(ANIMATION_STRUCTURE_TYPE || (ANIMATION_STRUCTURE_TYPE = {}));
    /**
     * Holds different playmodes the animation uses to play back its animation.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_PLAYMODE;
    (function (ANIMATION_PLAYMODE) {
        /**Plays animation in a loop: it restarts once it hit the end.*/
        ANIMATION_PLAYMODE["LOOP"] = "loop";
        /**Plays animation once and stops at the last key/frame*/
        ANIMATION_PLAYMODE["PLAY_ONCE"] = "playOnce";
        /**Plays animation once and stops on the first key/frame */
        ANIMATION_PLAYMODE["PLAY_ONCE_RESET"] = "playOnceReset";
        /**Plays animation like LOOP, but backwards.*/
        ANIMATION_PLAYMODE["REVERSE_LOOP"] = "reverseLoop";
        /**Causes the animation not to play at all. Useful for jumping to various positions in the animation without proceeding in the animation.*/
        ANIMATION_PLAYMODE["STOP"] = "stop";
        //TODO: add an INHERIT and a PINGPONG mode
    })(ANIMATION_PLAYMODE = FudgeCore.ANIMATION_PLAYMODE || (FudgeCore.ANIMATION_PLAYMODE = {}));
    let ANIMATION_QUANTIZATION;
    (function (ANIMATION_QUANTIZATION) {
        //TODO: add an in-depth description of what happens to the animation (and events) depending on the quantization. Use Graphs to explain.
        /**Calculates the state of the animation at the exact position of time. Ignores FPS value of animation.*/
        ANIMATION_QUANTIZATION["CONTINOUS"] = "continous";
        /**Limits the calculation of the state of the animation to the FPS value of the animation. Skips frames if needed.*/
        ANIMATION_QUANTIZATION["DISCRETE"] = "discrete";
        /** Advances the time each frame according to the FPS value of the animation, ignoring the actual duration of the frames. Doesn't skip any frames.*/
        ANIMATION_QUANTIZATION["FRAMES"] = "frames";
    })(ANIMATION_QUANTIZATION = FudgeCore.ANIMATION_QUANTIZATION || (FudgeCore.ANIMATION_QUANTIZATION = {}));
    /**
     * Describes and controls and animation by yielding mutators
     * according to the stored {@link AnimationStructure} and {@link AnimationSequence}s
     * Applied to a {@link Node} directly via script or {@link ComponentAnimation}.
     * @author Lukas Scheuerle, HFU, 21019 | Jirka Dell'Oro-Friedl, HFU, 2021-2023
     */
    let Animation = (() => {
        var _a;
        let _classDecorators = [(_a = FudgeCore.SerializableResource).register.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Mutable;
        var Animation = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                Animation = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            // /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
            // public static readonly baseClass: typeof Animation = Animation;
            // /** list of all the subclasses derived from this class, if they registered properly*/
            static { this.subclasses = []; }
            static { this.iSubclass = Animation.registerSubclass(Animation); }
            #animationStructuresProcessed;
            constructor(_name = Animation.name, _animStructure = {}, _fps = 60) {
                super();
                this.idResource = undefined;
                this.totalTime = 0; // Why isn't this called duration or length?
                this.labels = {}; // a label marks a specific time to conveniently jump to using a text identifier
                this.events = {};
                this.framesPerSecond = 60; // TODO: change this and its accessors to #framesPerSecond?
                // processed eventlist and animation strucutres for playback.
                this.eventsProcessed = new Map();
                this.#animationStructuresProcessed = new Map();
                this.name = _name;
                this.animationStructure = _animStructure;
                this.#animationStructuresProcessed.set(ANIMATION_STRUCTURE_TYPE.NORMAL, _animStructure);
                this.framesPerSecond = _fps;
                this.calculateTotalTime();
                FudgeCore.Project.register(this);
            }
            /**
             * Override the given base mutator with the given override mutator using linear interpolation between the values with the given weight.
             * Set the intersect flag to only include properties in the result that exist in both of the given mutators.
             */
            static blendOverride(_base, _override, _weight, _intersect = false) {
                return Animation.blendRecursive(_base, _override, 1 - _weight, _weight, _intersect);
            }
            /**
             * Add the given additive mutator to the given base mutator. The values of the additive mutator will be multiplied by the given weight.
             */
            static blendAdditive(_base, _add, _weight) {
                return Animation.blendRecursive(_base, _add, 1, _weight);
            }
            /**
             * Blend the two given mutators together, using the given weights to determine the influence of each.
             * The resulting mutator will contain all properties of the base mutator, with the properties of the blend mutator blended in.
             * Blend mutator properties that don't exist in the base mutator will be added to the result mutator.
             * Set the intersect flag to only include properties in the result that exist in both of the given mutators.
             */
            static blendRecursive(_base, _blend, _weightBase, _weightBlend, _intersect = false) {
                let mutator = _intersect ? {} : { ..._base };
                for (const key in _blend) {
                    if (_intersect && _base[key] == undefined)
                        continue;
                    if (typeof _blend[key] == "number") {
                        mutator[key] = (_base[key] ?? 0) * _weightBase + _blend[key] * _weightBlend;
                        continue;
                    }
                    if (typeof _base[key] == "object") {
                        let base = _base[key];
                        let blend = _blend[key];
                        if (base.x != undefined && base.y != undefined && base.z != undefined && base.w != undefined && FudgeCore.Quaternion.DOT(base, blend) < 0)
                            FudgeCore.Quaternion.negate(base); // TODO: eliminate this side effect
                        mutator[key] = this.blendRecursive(base, blend, _weightBase, _weightBlend, _intersect);
                        continue;
                    }
                    if (typeof _blend[key] === "object") {
                        mutator[key] = this.blendRecursive({}, _blend[key], _weightBase, _weightBlend, _intersect);
                        continue;
                    }
                }
                return mutator;
            }
            static registerSubclass(_subClass) { return Animation.subclasses.push(_subClass) - 1; }
            get getLabels() {
                //TODO: this actually needs testing
                let en = new Enumerator(this.labels);
                return en;
            }
            get fps() {
                return this.framesPerSecond;
            }
            set fps(_fps) {
                this.framesPerSecond = _fps;
                this.eventsProcessed.clear();
                this.clearCache();
            }
            /**
             * Clear this animations cache.
             */
            clearCache() {
                this.#animationStructuresProcessed.clear();
            }
            /**
             * Generates and returns a {@link Mutator} with the information to apply to the {@link Node} to animate
             * in the state the animation is in at the given time, direction and quantization
             */
            getState(_time, _direction, _quantization) {
                let m = {};
                let animationStructure;
                if (_quantization == ANIMATION_QUANTIZATION.CONTINOUS)
                    animationStructure = _direction < 0 ? ANIMATION_STRUCTURE_TYPE.REVERSE : ANIMATION_STRUCTURE_TYPE.NORMAL;
                else
                    animationStructure = _direction < 0 ? ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE : ANIMATION_STRUCTURE_TYPE.RASTERED;
                m = this.traverseStructureForMutator(this.getProcessedAnimationStructure(animationStructure), _time);
                return m;
            }
            /**
             * Returns a list of the names of the events the {@link ComponentAnimation} needs to fire between _min and _max input values.
             * @param _direction The direction the animation is supposed to run in. >0 == forward, 0 == stop, <0 == backwards
             * @returns a list of strings with the names of the custom events to fire.
             */
            getEventsToFire(_min, _max, _quantization, _direction) {
                let eventList = [];
                let minSection = Math.floor(_min / this.totalTime);
                let maxSection = Math.floor(_max / this.totalTime);
                _min = _min % this.totalTime;
                _max = _max % this.totalTime;
                while (minSection <= maxSection) {
                    let eventTriggers = this.getCorrectEventList(_direction, _quantization);
                    if (minSection == maxSection) {
                        eventList = eventList.concat(this.checkEventsBetween(eventTriggers, _min, _max));
                    }
                    else {
                        eventList = eventList.concat(this.checkEventsBetween(eventTriggers, _min, this.totalTime));
                        _min = 0;
                    }
                    minSection++;
                }
                return eventList;
            }
            /**
             * Adds an Event to the List of events.
             * @param _name The name of the event (needs to be unique per Animation).
             * @param _time The timestamp of the event (in milliseconds).
             */
            setEvent(_name, _time) {
                this.events[_name] = _time;
                this.eventsProcessed.clear();
            }
            /**
             * Removes the event with the given name from the list of events.
             * @param _name name of the event to remove.
             */
            removeEvent(_name) {
                delete this.events[_name];
                this.eventsProcessed.clear();
            }
            /**
             * (Re-)Calculate the total time of the Animation. Calculation-heavy, use only if actually needed.
             */
            calculateTotalTime() {
                this.totalTime = 0;
                this.traverseStructureForTime(this.animationStructure);
                // if (this.totalTime == 0) // animations with one keyframe need a total time != 0 to work
                //   this.totalTime = 1;
            }
            /**
             * Returns the time to use for animation sampling when applying a playmode
             */
            getModalTime(_time, _playmode, _timeStop = _time) {
                switch (_playmode) {
                    case ANIMATION_PLAYMODE.STOP:
                        // return this.localTime.getOffset();
                        return _timeStop;
                    case ANIMATION_PLAYMODE.PLAY_ONCE:
                        if (_time >= this.totalTime)
                            return this.totalTime - 0.01; //TODO: this might cause some issues
                    case ANIMATION_PLAYMODE.PLAY_ONCE_RESET:
                        if (_time >= this.totalTime)
                            // TODO: return _timeStop instead?
                            return this.totalTime + 0.01; //TODO: this might cause some issues
                }
                return _time;
            }
            /**
             * Calculates and returns the direction the animation should currently be playing in.
             * @param _time the time at which to calculate the direction
             * @returns 1 if forward, 0 if stop, -1 if backwards
             */
            calculateDirection(_time, _playmode) {
                switch (_playmode) {
                    case ANIMATION_PLAYMODE.STOP:
                        return 0;
                    // case ANIMATION_PLAYMODE.PINGPONG:
                    //   if (Math.floor(_time / this.animation.totalTime) % 2 == 0)
                    //     return 1;
                    //   else
                    //     return -1;
                    case ANIMATION_PLAYMODE.REVERSE_LOOP:
                        return -1;
                    case ANIMATION_PLAYMODE.PLAY_ONCE:
                    case ANIMATION_PLAYMODE.PLAY_ONCE_RESET:
                        if (_time >= this.totalTime) {
                            return 0;
                        }
                    default:
                        return 1;
                }
            }
            //#region transfer
            serialize() {
                let s = {
                    idResource: this.idResource,
                    name: this.name,
                    labels: {},
                    events: {},
                    framesPerSecond: this.framesPerSecond
                    // sps: this.stepsPerSecond
                };
                for (let name in this.labels) {
                    s.labels[name] = this.labels[name];
                }
                for (let name in this.events) {
                    s.events[name] = this.events[name];
                }
                s.animationStructure = this.traverseStructureForSerialization(this.animationStructure);
                return s;
            }
            async deserialize(_serialization) {
                FudgeCore.Project.register(this, _serialization.idResource);
                this.name = _serialization.name;
                this.framesPerSecond = _serialization.framesPerSecond;
                // this.stepsPerSecond = _serialization.sps;
                this.labels = {};
                for (let name in _serialization.labels) {
                    this.labels[name] = _serialization.labels[name];
                }
                this.events = {};
                for (let name in _serialization.events) {
                    this.events[name] = _serialization.events[name];
                }
                this.eventsProcessed = new Map();
                this.animationStructure = await this.traverseStructureForDeserialization(_serialization.animationStructure);
                this.#animationStructuresProcessed = new Map();
                this.calculateTotalTime();
                return this;
            }
            // public getMutator(): Mutator {
            //   return this.serialize();
            // }
            reduceMutator(_mutator) {
                delete _mutator.totalTime;
            }
            /**
             * Traverses an AnimationStructure and returns the Serialization of said Structure.
             * @param _structure The Animation Structure at the current level to transform into the Serialization.
             * @returns the filled Serialization.
             */
            traverseStructureForSerialization(_structure) {
                let serialization = {};
                for (const property in _structure) {
                    let structureOrSequence = _structure[property];
                    if (structureOrSequence instanceof FudgeCore.AnimationSequence)
                        serialization[property] = structureOrSequence.serialize();
                    else
                        serialization[property] = this.traverseStructureForSerialization(structureOrSequence);
                }
                return serialization;
            }
            /**
             * Traverses a Serialization to create a new AnimationStructure.
             * @param _serialization The serialization to transfer into an AnimationStructure
             * @returns the newly created AnimationStructure.
             */
            async traverseStructureForDeserialization(_serialization) {
                let structure = {};
                for (let n in _serialization) {
                    if (_serialization[n].animationSequence) {
                        let animSeq = new FudgeCore.AnimationSequence();
                        structure[n] = (await animSeq.deserialize(_serialization[n]));
                    }
                    else {
                        structure[n] = await this.traverseStructureForDeserialization(_serialization[n]);
                    }
                }
                return structure;
            }
            //#endregion
            /**
             * Finds and returns the list of events to be used with these settings.
             */
            getCorrectEventList(_direction, _quantization) {
                if (_quantization != ANIMATION_QUANTIZATION.FRAMES) {
                    if (_direction >= 0) {
                        return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.NORMAL);
                    }
                    else {
                        return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE);
                    }
                }
                else {
                    if (_direction >= 0) {
                        return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTERED);
                    }
                    else {
                        return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE);
                    }
                }
            }
            /**
             * Traverses an {@link AnimationStructure} and returns a {@link Mutator} describing the state at the given time
             */
            traverseStructureForMutator(_structure, _time) {
                let newMutator = {};
                for (let n in _structure) {
                    if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                        newMutator[n] = _structure[n].evaluate(_time);
                    }
                    else {
                        newMutator[n] = this.traverseStructureForMutator(_structure[n], _time);
                    }
                }
                return newMutator;
            }
            /**
             * Traverses the current AnimationStrcuture to find the totalTime of this animation.
             * @param _structure The structure to traverse
             */
            traverseStructureForTime(_structure) {
                for (let n in _structure) {
                    if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                        let sequence = _structure[n];
                        if (sequence.length > 0) {
                            let sequenceTime = sequence.getKey(sequence.length - 1).time;
                            this.totalTime = Math.max(sequenceTime, this.totalTime);
                        }
                    }
                    else {
                        this.traverseStructureForTime(_structure[n]);
                    }
                }
            }
            /**
             * Ensures the existance of the requested {@link AnimationStrcuture} and returns it.
             * @param _type the type of the structure to get
             * @returns the requested [[@link AnimationStructure]]
             */
            getProcessedAnimationStructure(_type) {
                if (!this.#animationStructuresProcessed.has(_type)) {
                    this.calculateTotalTime();
                    let ae = {};
                    switch (_type) {
                        case ANIMATION_STRUCTURE_TYPE.NORMAL:
                            ae = this.animationStructure;
                            break;
                        case ANIMATION_STRUCTURE_TYPE.REVERSE:
                            ae = this.traverseStructureForNewStructure(this.animationStructure, this.calculateReverseSequence.bind(this));
                            break;
                        case ANIMATION_STRUCTURE_TYPE.RASTERED:
                            ae = this.traverseStructureForNewStructure(this.animationStructure, this.calculateRasteredSequence.bind(this));
                            break;
                        case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                            ae = this.traverseStructureForNewStructure(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.REVERSE), this.calculateRasteredSequence.bind(this));
                            break;
                        default:
                            return {};
                    }
                    this.#animationStructuresProcessed.set(_type, ae);
                }
                return this.#animationStructuresProcessed.get(_type);
            }
            /**
             * Ensures the existance of the requested {@link AnimationEventTrigger} and returns it.
             * @param _type The type of AnimationEventTrigger to get
             * @returns the requested {@link AnimationEventTrigger}
             */
            getProcessedEventTrigger(_type) {
                if (!this.eventsProcessed.has(_type)) {
                    this.calculateTotalTime();
                    let ev = {};
                    switch (_type) {
                        case ANIMATION_STRUCTURE_TYPE.NORMAL:
                            ev = this.events;
                            break;
                        case ANIMATION_STRUCTURE_TYPE.REVERSE:
                            ev = this.calculateReverseEventTriggers(this.events);
                            break;
                        case ANIMATION_STRUCTURE_TYPE.RASTERED:
                            ev = this.calculateRasteredEventTriggers(this.events);
                            break;
                        case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                            ev = this.calculateRasteredEventTriggers(this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE));
                            break;
                        default:
                            return {};
                    }
                    this.eventsProcessed.set(_type, ev);
                }
                return this.eventsProcessed.get(_type);
            }
            /**
             * Traverses an existing structure to apply a recalculation function to the AnimationStructure to store in a new Structure.
             * @param _oldStructure The old structure to traverse
             * @param _functionToUse The function to use to recalculated the structure.
             * @returns A new Animation Structure with the recalulated Animation Sequences.
             */
            traverseStructureForNewStructure(_oldStructure, _functionToUse) {
                let newStructure = {};
                for (let n in _oldStructure) {
                    if (_oldStructure[n] instanceof FudgeCore.AnimationSequence) {
                        newStructure[n] = _functionToUse(_oldStructure[n]);
                    }
                    else {
                        newStructure[n] = this.traverseStructureForNewStructure(_oldStructure[n], _functionToUse);
                    }
                }
                return newStructure;
            }
            /**
             * Creates a reversed Animation Sequence out of a given Sequence.
             * @param _sequence The sequence to calculate the new sequence out of
             * @returns The reversed Sequence
             */
            calculateReverseSequence(_sequence) {
                let seq = new FudgeCore.AnimationSequence();
                for (let i = 0; i < _sequence.length; i++) {
                    let oldKey = _sequence.getKey(i);
                    let key = new FudgeCore.AnimationKey(this.totalTime - oldKey.time, oldKey.value, oldKey.interpolation, oldKey.slopeOut, oldKey.slopeIn);
                    seq.addKey(key);
                }
                return seq;
            }
            /**
             * Creates a rastered {@link AnimationSequence} out of a given sequence.
             * @param _sequence The sequence to calculate the new sequence out of
             * @returns the rastered sequence.
             */
            calculateRasteredSequence(_sequence) {
                let seq = new FudgeCore.AnimationSequence();
                let frameTime = 1000 / this.framesPerSecond;
                for (let i = 0; i < this.totalTime; i += frameTime) {
                    let key = new FudgeCore.AnimationKey(i, _sequence.evaluate(i), FudgeCore.ANIMATION_INTERPOLATION.CONSTANT, 0, 0);
                    seq.addKey(key);
                }
                return seq;
            }
            /**
             * Creates a new reversed {@link AnimationEventTrigger} object based on the given one.
             * @param _events the event object to calculate the new one out of
             * @returns the reversed event object
             */
            calculateReverseEventTriggers(_events) {
                let ae = {};
                for (let name in _events) {
                    ae[name] = this.totalTime - _events[name];
                }
                return ae;
            }
            /**
             * Creates a rastered {@link AnimationEventTrigger} object based on the given one.
             * @param _events the event object to calculate the new one out of
             * @returns the rastered event object
             */
            calculateRasteredEventTriggers(_events) {
                let ae = {};
                let frameTime = 1000 / this.framesPerSecond;
                for (let name in _events) {
                    ae[name] = _events[name] - (_events[name] % frameTime);
                }
                return ae;
            }
            /**
             * Checks which events lay between two given times and returns the names of the ones that do.
             * @param _eventTriggers The event object to check the events inside of
             * @param _min the minimum of the range to check between (inclusive)
             * @param _max the maximum of the range to check between (exclusive)
             * @returns an array of the names of the events in the given range.
             */
            checkEventsBetween(_eventTriggers, _min, _max) {
                let eventsToTrigger = [];
                for (let name in _eventTriggers) {
                    if (_min <= _eventTriggers[name] && _eventTriggers[name] < _max) {
                        eventsToTrigger.push(name);
                    }
                }
                return eventsToTrigger;
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return Animation = _classThis;
    })();
    FudgeCore.Animation = Animation;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Calculates the values between {@link AnimationKey}s.
     * Represented internally by a cubic function (`f(x) = ax¬≥ + bx¬≤ + cx + d`).
     * Only needs to be recalculated when the keys change, so at runtime it should only be calculated once.
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationFunction {
        constructor(_keyIn, _keyOut = null) {
            this.a = 0;
            this.b = 0;
            this.c = 0;
            this.d = 0;
            this.keyIn = _keyIn;
            this.keyOut = _keyOut;
            this.calculate();
        }
        set setKeyIn(_keyIn) {
            this.keyIn = _keyIn;
            this.calculate();
        }
        set setKeyOut(_keyOut) {
            this.keyOut = _keyOut;
            this.calculate();
        }
        /**
         * Returns the parameter values of this cubic function. `f(x) = ax¬≥ + bx¬≤ + cx + d`
         * Used by editor.
         */
        getParameters() {
            return { a: this.a, b: this.b, c: this.c, d: this.d };
        }
        /**
         * Calculates the value of the function at the given time.
         * @param _time the point in time at which to evaluate the function in milliseconds. Will be corrected for offset internally.
         * @returns the value at the given time
         */
        evaluate(_time) {
            _time -= this.keyIn.time;
            let time2 = _time * _time;
            let time3 = time2 * _time;
            return this.a * time3 + this.b * time2 + this.c * _time + this.d;
        }
        /**
         * (Re-)Calculates the parameters of the cubic function.
         * See https://math.stackexchange.com/questions/3173469/calculate-cubic-equation-from-two-points-and-two-slopes-variably
         * and https://jirkadelloro.github.io/FUDGE/Documentation/Logs/190410_Notizen_LS
         */
        calculate() {
            if (!this.keyIn) {
                this.d = this.c = this.b = this.a = 0;
                return;
            }
            if (!this.keyOut || this.keyIn.interpolation == FudgeCore.ANIMATION_INTERPOLATION.CONSTANT) {
                this.d = this.keyIn.value;
                this.c = this.b = this.a = 0;
                return;
            }
            let x1 = this.keyOut.time - this.keyIn.time;
            this.d = this.keyIn.value;
            if (this.keyIn.interpolation == FudgeCore.ANIMATION_INTERPOLATION.LINEAR) {
                this.c = (this.keyOut.value - this.keyIn.value) / x1;
                return;
            }
            this.c = this.keyIn.slopeOut;
            this.a = (-x1 * (this.keyIn.slopeOut + this.keyOut.slopeIn) - 2 * this.keyIn.value + 2 * this.keyOut.value) / -Math.pow(x1, 3);
            this.b = (this.keyOut.slopeIn - this.keyIn.slopeOut - 3 * this.a * Math.pow(x1, 2)) / (2 * x1);
        }
    }
    FudgeCore.AnimationFunction = AnimationFunction;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * An {@link Animation} loaded from a glTF-File.
     * @authors Jonas Plotzky
     */
    class AnimationGLTF extends FudgeCore.mixinSerializableResourceExternal(FudgeCore.Animation) {
        async load(_url = this.url, _name = this.name) {
            this.url = _url;
            this.name = _name;
            return FudgeCore.GLTFLoader.loadResource(this);
        }
        serialize() {
            const serialization = super.serialize();
            serialization.events = { ...this.events };
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.events = { ..._serialization.events };
            return this;
        }
    }
    FudgeCore.AnimationGLTF = AnimationGLTF;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let ANIMATION_INTERPOLATION;
    (function (ANIMATION_INTERPOLATION) {
        ANIMATION_INTERPOLATION[ANIMATION_INTERPOLATION["CONSTANT"] = 0] = "CONSTANT";
        ANIMATION_INTERPOLATION[ANIMATION_INTERPOLATION["LINEAR"] = 1] = "LINEAR";
        ANIMATION_INTERPOLATION[ANIMATION_INTERPOLATION["CUBIC"] = 2] = "CUBIC";
    })(ANIMATION_INTERPOLATION = FudgeCore.ANIMATION_INTERPOLATION || (FudgeCore.ANIMATION_INTERPOLATION = {}));
    // type AnimationInterpolation = "constant" | "linear" | "cubic";
    /**
     * Holds information about continous points in time their accompanying values as well as their slopes.
     * Also holds a reference to the {@link AnimationFunction}s that come in and out of the sides.
     * The {@link AnimationFunction}s are handled by the {@link AnimationSequence}s.
     * If the property constant is true, the value does not change and wil not be interpolated between this and the next key in a sequence
     * @author Lukas Scheuerle, HFU, 2019
     */
    class AnimationKey extends FudgeCore.Mutable {
        #time;
        #value;
        #interpolation;
        #slopeIn = 0;
        #slopeOut = 0;
        constructor(_time = 0, _value = 0, _interpolation = ANIMATION_INTERPOLATION.CUBIC, _slopeIn = 0, _slopeOut = 0) {
            super();
            this.#time = _time;
            this.#value = _value;
            this.#interpolation = _interpolation;
            this.#slopeIn = _slopeIn;
            this.#slopeOut = _slopeOut;
            this.functionOut = new FudgeCore.AnimationFunction(this, null);
        }
        /**
         * Static comparation function to use in an array sort function to sort the keys by their time.
         * @param _a the animation key to check
         * @param _b the animation key to check against
         * @returns >0 if a>b, 0 if a=b, <0 if a<b
         */
        static compare(_a, _b) {
            return _a.time - _b.time;
        }
        get time() {
            return this.#time;
        }
        set time(_time) {
            this.#time = _time;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get value() {
            return this.#value;
        }
        set value(_value) {
            this.#value = _value;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get interpolation() {
            return this.#interpolation;
        }
        set interpolation(_interpolation) {
            this.#interpolation = _interpolation;
            this.functionIn.calculate();
            this.functionOut.calculate();
        }
        get slopeIn() {
            return this.#slopeIn;
        }
        set slopeIn(_slope) {
            this.#slopeIn = _slope;
            this.functionIn.calculate();
        }
        get slopeOut() {
            return this.#slopeOut;
        }
        set slopeOut(_slope) {
            this.#slopeOut = _slope;
            this.functionOut.calculate();
        }
        //#region transfer
        serialize() {
            let serialization = {};
            serialization.time = this.#time;
            serialization.value = this.#value;
            serialization.interpolation = this.#interpolation;
            serialization.slopeIn = this.#slopeIn;
            serialization.slopeOut = this.#slopeOut;
            return serialization;
        }
        async deserialize(_serialization) {
            this.#time = _serialization.time;
            this.#value = _serialization.value;
            this.#interpolation = _serialization.interpolation;
            this.#slopeIn = _serialization.slopeIn;
            this.#slopeOut = _serialization.slopeOut;
            // if (_serialization.interpolation == undefined)
            //   if (_serialization.constant) // TODO: remove this when constant is removed
            //     this.#interpolation = "constant";
            //   else
            //     this.#interpolation = "cubic";
            return this;
        }
        getMutator() {
            return this.serialize();
        }
        reduceMutator(_mutator) {
            //
        }
    }
    FudgeCore.AnimationKey = AnimationKey;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Blending modes used in {@link AnimationNodeBlend}. */
    let ANIMATION_BLENDING;
    (function (ANIMATION_BLENDING) {
        /** Adds this animation to the previous animations. */
        ANIMATION_BLENDING["ADDITIVE"] = "Additive";
        /** Overrides the previous animations using linear interpolation. */
        ANIMATION_BLENDING["OVERRIDE"] = "Override";
    })(ANIMATION_BLENDING = FudgeCore.ANIMATION_BLENDING || (FudgeCore.ANIMATION_BLENDING = {}));
    /**
     * Base class for all animation nodes. Animation nodes form an animation graph enabling hierachical animation blending and animation transitions.
     * Can be attached to a {@link Node} via {@link ComponentAnimationGraph}.
     * @author Jonas Plotzky, HFU, 2024-2025
     */
    class AnimationNode {
        constructor(_options) {
            this.speed = _options?.speed ?? 1;
            this.weight = _options?.weight ?? 1;
            this.blending = _options?.blending ?? ANIMATION_BLENDING.OVERRIDE;
        }
    }
    FudgeCore.AnimationNode = AnimationNode;
    /**
     * Evaluates a single {@link Animation} providing a {@link mutator} and {@link events}.
     * Used as an input for other {@link AnimationNode}s.
     * @author Jonas Plotzky, HFU, 2024-2025
     */
    class AnimationNodeAnimation extends AnimationNode {
        constructor(_animation, _options) {
            super(_options);
            if (!_animation)
                return;
            if (!(_animation instanceof FudgeCore.Animation)) {
                this.mutator = _animation;
                return;
            }
            this.animation = _animation;
            this.offset = _options?.offset ?? 0;
            this.playmode = _options?.playmode;
            this.time = 0;
        }
        /** Resets this node to its {@link offset} time. */
        reset() {
            this.time = this.offset;
        }
        update(_deltaTime) {
            if (!this.animation)
                return;
            _deltaTime *= this.speed;
            let updatedTime = this.time + _deltaTime;
            if (this.animation.totalTime == 0)
                return;
            updatedTime = this.animation.getModalTime(updatedTime, this.playmode);
            let direction = this.animation.calculateDirection(updatedTime, this.playmode);
            this.events = this.animation.getEventsToFire(this.time, updatedTime, FudgeCore.ANIMATION_QUANTIZATION.CONTINOUS, direction);
            this.mutator = this.animation.getState(updatedTime % this.animation.totalTime, direction, FudgeCore.ANIMATION_QUANTIZATION.CONTINOUS);
            this.time = updatedTime;
            return;
        }
    }
    FudgeCore.AnimationNodeAnimation = AnimationNodeAnimation;
    /**
     * Blends multiple input {@link AnimationNode}s providing a blended {@link mutator} and the {@link events} from all nodes.
     * Each child node must specify its own blend {@link weight} and {@link blending}. Processes nodes sequentially, each node blends with the accumulated result.
     * When combined with {@link AnimationNodeTransition}s as children, transitions from/into an empty state will blend from/into the accumulated result of this node.
     * @author Jonas Plotzky, HFU, 2024-2025
     *
     * **Example walk-run-blend:**
     * ```typescript
     * import ∆í = FudgeCore;
     * // initialization
     * const walk: ∆í.Animation = new ∆í.Animation();
     * const run: ∆í.Animation = new ∆í.Animation();
     * const nodeWalk: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(walk);
     * const nodeRun: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(run, { speed: run.totalTime / walk.totalTime }) // slow down the playback speed of run to synchronize the motion with walk.
     * const nodeMove: ∆í.AnimationNodeBlend = new ∆í.AnimationNodeBlend([nodeWalk, nodeRun]);
     * const cmpAnimationGraph: ∆í.ComponentAnimationGraph = new ∆í.ComponentAnimationGraph(); // get the animation component
     * cmpAnimationGraph.root = nodeMove;
     *
     * // during the game
     * nodeRun.weight = 0.5; // adjust the weight: 0 is walking, 1 is running.
     * nodeMove.speed = 1 + nodeRun.weight * nodeRun.speed; // adjust the playback speed of the blend to account for the slowed down run animation.
     * ```
     * **Example transition-empty-state:**
     * ```typescript
     * import ∆í = FudgeCore;
     * // initialization
     * const idle: ∆í.Animation = new ∆í.Animation();
     * const walk: ∆í.Animation = new ∆í.Animation();
     * const draw: ∆í.Animation = new ∆í.Animation();
     * const sheathe: ∆í.Animation = new ∆í.Animation();
     *
     * const nodeEmpty: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation();
     * const nodeIdle: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(idle);
     * const nodeWalk: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(walk);
     * const nodeDraw: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(draw, { playmode: ∆í.ANIMATION_PLAYMODE.PLAY_ONCE });
     * const nodeSheathe: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(sheathe, { playmode: ∆í.ANIMATION_PLAYMODE.PLAY_ONCE });
     *
     * const nodeWholeBody: ∆í.AnimationNodeTransition = new ∆í.AnimationNodeTransition(nodeIdle);
     * const nodeUpperBody: ∆í.AnimationNodeTransition = new ∆í.AnimationNodeTransition(nodeEmpty);
     * const nodeRoot: ∆í.AnimationNodeBlend = new ∆í.AnimationNodeBlend([nodeWholeBody, nodeUpperBody]);
     * const cmpAnimationGraph: ∆í.ComponentAnimationGraph = new ∆í.ComponentAnimationGraph(); // get the animation component
     * cmpAnimationGraph.root = nodeRoot;
     *
     * // during the game
     * nodeWholeBody.transit(nodeWalk, 300); // transit whole body into walk.
     * // in parallel to the whole body, the upper body can transit from empty to draw/sheath and back to empty.
     * nodeUpperBody.transit(nodeDraw, 300); // transit upper body from empty into draw.
     * nodeUpperBody.transit(nodeSheathe, 300); // transit upper body from draw into sheathe.
     * nodeUpperBody.transit(nodeEmpty, 300); // transit upper body from sheathe into empty.
     * ```
     */
    class AnimationNodeBlend extends AnimationNode {
        constructor(_nodes, _options) {
            super(_options);
            this.nodes = _nodes;
        }
        reset() {
            for (const node of this.nodes)
                node.reset();
        }
        update(_deltaTime) {
            if (this.nodes.length == 0) {
                this.mutator = null;
                this.events = [];
                return;
            }
            _deltaTime *= this.speed;
            this.nodes[0].update(_deltaTime, {}); // TODO: add base pose snapshot to blend from
            let mutator = this.nodes[0].mutator ?? {};
            let events = this.nodes[0].events ?? [];
            for (let i = 1; i < this.nodes.length; i++) {
                const node = this.nodes[i];
                node.update(_deltaTime, mutator);
                if (!node.mutator)
                    continue;
                switch (node.blending) {
                    case ANIMATION_BLENDING.ADDITIVE:
                        mutator = FudgeCore.Animation.blendAdditive(mutator, node.mutator, node.weight);
                        break;
                    case ANIMATION_BLENDING.OVERRIDE:
                        mutator = FudgeCore.Animation.blendOverride(mutator, node.mutator, node.weight);
                        break;
                }
                events = events.concat(node.events);
            }
            this.mutator = mutator;
            this.events = events;
        }
    }
    FudgeCore.AnimationNodeBlend = AnimationNodeBlend;
    /**
     * Allows to transition from one {@link AnimationNode} to another over a specified time.
     * If nested inside an {@link AnimationNodeBlend}, transit from/into an empty state to blend from/into the accumulated result of the container blend node.
     * @author Jonas Plotzky, HFU, 2024-2025
     *
     * **Example:**
     * ```typescript
     * import ∆í = FudgeCore;
     * // initialization
     * const idle: ∆í.Animation = new ∆í.Animation();
     * const walk: ∆í.Animation = new ∆í.Animation();
     * const nodeIdle: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(idle);
     * const nodeWalk: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(walk);
     * const nodeTransition: ∆í.AnimationNodeTransition = new ∆í.AnimationNodeTransition(nodeIdle);
     * const cmpAnimationGraph: ∆í.ComponentAnimationGraph = new ∆í.ComponentAnimationGraph(); // get the animation component
     * cmpAnimationGraph.root = nodeTransition;
     *
     * // during the game
     * nodeTransition.transit(nodeWalk, 300); // transit to the walk animation in 300ms.
     * nodeTransition.transit(nodeIdle, 300); // transit back to the idle animation.
     * ```
     */
    class AnimationNodeTransition extends AnimationNode {
        constructor(_animation, _options) {
            super(_options);
            this.from = _animation;
        }
        reset() {
            this.from.reset();
            this.to?.reset();
        }
        /** Transit to the given {@link AnimationNode} over the specified duration. The given node will be {@link reset}. */
        transit(_to, _duration) {
            _to.reset();
            if (this.to)
                this.from = new AnimationNodeAnimation(this.mutator);
            this.to = _to;
            this.duration = _duration;
            this.time = 0;
        }
        update(_deltaTime, _pose) {
            _deltaTime *= this.speed;
            this.time += _deltaTime;
            this.from.update(_deltaTime);
            if (!this.to) {
                this.mutator = this.from.mutator;
                this.events = this.from.events;
                return;
            }
            this.to.update(_deltaTime);
            let progress = Math.min(this.time / this.duration, 1);
            let from = this.from.mutator ?? _pose;
            let to = this.to.mutator ?? _pose;
            if (from == to) {
                this.mutator = null;
                return;
            }
            this.mutator = FudgeCore.Animation.blendOverride(from, to, progress, from == _pose || to == _pose);
            this.events = this.to.events;
            if (progress >= 1) {
                this.from = this.to;
                this.to = null;
                this.duration = null;
                this.time = null;
            }
        }
    }
    FudgeCore.AnimationNodeTransition = AnimationNodeTransition;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A sequence of {@link AnimationKey}s that is mapped to an attribute of a {@link Node} or its {@link Component}s inside the {@link Animation}.
     * Provides functions to modify said keys
     * @authors Lukas Scheuerle, HFU, 2019 | Jonas Plotzky, HFU, 2022
     */
    class AnimationSequence extends FudgeCore.Mutable {
        constructor(_keys = []) {
            super();
            this.keys = _keys;
            this.regenerateFunctions();
        }
        get length() {
            return this.keys.length;
        }
        /**
         * Evaluates the sequence at the given point in time.
         * @param _time the point in time at which to evaluate the sequence in milliseconds.
         * @returns the value of the sequence at the given time. undefined if there are no keys.
         */
        evaluate(_time) {
            if (this.keys.length == 0)
                return undefined; //TODO: shouldn't return 0 but something indicating no change, like null. probably needs to be changed in Node as well to ignore non-numeric values in the applyAnimation function
            if (this.keys.length == 1 || this.keys[0].time >= _time)
                return this.keys[0].value;
            for (let i = 0; i < this.keys.length - 1; i++) {
                if (this.keys[i].time <= _time && _time < this.keys[i + 1].time) {
                    return this.keys[i].functionOut.evaluate(_time);
                }
                // if (this.keys[i].time == _time)
                //   return this.keys[i].value;
            }
            return this.keys[this.keys.length - 1].value;
        }
        /**
         * Adds a new key to the sequence.
         * @param _key the key to add
         */
        addKey(_key) {
            this.keys.push(_key);
            this.keys.sort(FudgeCore.AnimationKey.compare);
            this.regenerateFunctions();
        }
        /**
         * Modifys a given key in the sequence.
         * @param _key the key to add
         */
        modifyKey(_key, _time, _value) {
            if (_time != null)
                _key.time = _time;
            if (_value != null)
                _key.value = _value;
            this.keys.sort(FudgeCore.AnimationKey.compare);
            this.regenerateFunctions();
        }
        /**
         * Removes a given key from the sequence.
         * @param _key the key to remove
         */
        removeKey(_key) {
            for (let i = 0; i < this.keys.length; i++) {
                if (this.keys[i] == _key) {
                    this.keys.splice(i, 1);
                    this.regenerateFunctions();
                    return;
                }
            }
        }
        /**
         * Find a key in the sequence exactly matching the given time.
         */
        findKey(_time) {
            for (let key of this.keys)
                if (key.time == _time)
                    return key;
            return null;
        }
        /**
         * Removes the Animation Key at the given index from the keys.
         * @param _index the zero-based index at which to remove the key
         * @returns the removed AnimationKey if successful, null otherwise.
         */
        removeKeyAtIndex(_index) {
            if (_index < 0 || _index >= this.keys.length) {
                return null;
            }
            let ak = this.keys[_index];
            this.keys.splice(_index, 1);
            this.regenerateFunctions();
            return ak;
        }
        /**
         * Gets a key from the sequence at the desired index.
         * @param _index the zero-based index at which to get the key
         * @returns the AnimationKey at the index if it exists, null otherwise.
         */
        getKey(_index) {
            if (_index < 0 || _index >= this.keys.length)
                return null;
            return this.keys[_index];
        }
        /**
         * Returns this sequence's keys. This is not a copy, but the actual array used internally. Handle with care!
         * Used by Editor.
         */
        getKeys() {
            return this.keys;
        }
        //#region transfer
        serialize() {
            let s = {
                keys: [],
                animationSequence: true
            };
            for (let i = 0; i < this.keys.length; i++) {
                s.keys[i] = this.keys[i].serialize();
            }
            return s;
        }
        async deserialize(_serialization) {
            for (let i = 0; i < _serialization.keys.length; i++) {
                // this.keys.push(<AnimationKey>Serializer.deserialize(_serialization.keys[i]));
                let k = new FudgeCore.AnimationKey();
                await k.deserialize(_serialization.keys[i]);
                this.keys[i] = k;
            }
            this.regenerateFunctions();
            return this;
        }
        reduceMutator(_mutator) { }
        //#endregion
        /**
         * Utility function that (re-)generates all functions in the sequence.
         */
        regenerateFunctions() {
            for (let i = 0; i < this.keys.length; i++) {
                let f = new FudgeCore.AnimationFunction(this.keys[i]);
                this.keys[i].functionOut = f;
                if (i == this.keys.length - 1) {
                    //TODO: check if this is even useful. Maybe update the runcondition to length - 1 instead. Might be redundant if functionIn is removed, see TODO in AnimationKey.
                    f.setKeyOut = this.keys[0];
                    this.keys[0].functionIn = f;
                    break;
                }
                f.setKeyOut = this.keys[i + 1];
                this.keys[i + 1].functionIn = f;
            }
        }
    }
    FudgeCore.AnimationSequence = AnimationSequence;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let AnimationSprite = (() => {
        let _classDecorators = [FudgeCore.enumerate];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Animation;
        let _instanceExtraInitializers = [];
        let _get_texture_decorators;
        var AnimationSprite = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _get_texture_decorators = [FudgeCore.enumerate, FudgeCore.type(FudgeCore.Texture)];
                __esDecorate(this, null, _get_texture_decorators, { kind: "getter", name: "texture", static: false, private: false, access: { has: obj => "texture" in obj, get: obj => obj.texture }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                AnimationSprite = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Animation.registerSubclass(AnimationSprite); }
            #texture;
            // TODO: fps should be a parameter too
            constructor(_name = "AnimationSprite") {
                super(_name, {}, 1);
                this.frames = (__runInitializers(this, _instanceExtraInitializers), 25);
                this.wrapAfter = 5;
                this.start = new FudgeCore.Vector2(0, 0);
                this.size = new FudgeCore.Vector2(80, 80);
                this.next = new FudgeCore.Vector2(80, 0);
                this.wrap = new FudgeCore.Vector2(0, 80);
                this.#texture = FudgeCore.TextureDefault.color;
                this.framesPerSecond = this.frames;
                this.create(this.texture, this.frames, this.wrapAfter, this.start, this.size, this.next, this.wrap, this.framesPerSecond);
            }
            get texture() {
                return this.#texture;
            }
            /**
             * Sets the texture to be used as the spritesheet
             */
            set texture(_texture) {
                this.#texture = _texture;
                this.create(this.texture, this.frames, this.wrapAfter, this.start, this.size, this.next, this.wrap, this.framesPerSecond);
            }
            /**
             * Creates this animation sprite from the given arguments
             */
            create(_texture, _frames, _wrapAfter, _start, _size, _next, _wrap, _framesPerSecond) {
                this.#texture = _texture;
                this.frames = _frames;
                this.wrapAfter = _wrapAfter;
                this.start = _start;
                this.size = _size;
                this.next = _next;
                this.wrap = _wrap;
                this.framesPerSecond = _framesPerSecond;
                let scale = this.getScale();
                let positions = this.getPositions();
                let xTranslation = new FudgeCore.AnimationSequence();
                let yTranslation = new FudgeCore.AnimationSequence();
                let xScale = new FudgeCore.AnimationSequence();
                let yScale = new FudgeCore.AnimationSequence();
                xScale.addKey(new FudgeCore.AnimationKey(0, scale.x));
                yScale.addKey(new FudgeCore.AnimationKey(0, scale.y));
                for (let frame = 0; frame <= this.frames; frame++) {
                    let time = 1000 * frame / this.framesPerSecond;
                    let position = positions[Math.min(frame, this.frames - 1)]; //repeat the last key to give the last frame some time
                    xTranslation.addKey(new FudgeCore.AnimationKey(time, position.x / this.#texture.texImageSource.width)); //, 0, 0, true))
                    yTranslation.addKey(new FudgeCore.AnimationKey(time, position.y / this.#texture.texImageSource.height)); //, 0, 0, true))
                }
                this.animationStructure = {
                    "components": {
                        "ComponentMaterial": [{
                                "mtxPivot": {
                                    "translation": {
                                        x: xTranslation,
                                        y: yTranslation
                                    },
                                    "scaling": {
                                        x: xScale,
                                        y: yScale
                                    }
                                }
                            }]
                    }
                };
                this.calculateTotalTime();
            }
            /**
             * Returns the scale of the spritesheet
             */
            getScale() {
                return new FudgeCore.Vector2(this.size.x / this.#texture.texImageSource.width, this.size.y / this.#texture.texImageSource.height);
            }
            /**
             * Returns the positions of the spritesheet
             */
            getPositions() {
                let iNext = 0;
                let iWrap = 0;
                let positions = [];
                for (let frame = 0; frame < this.frames; frame++) {
                    positions.push(new FudgeCore.Vector2(this.start.x + iNext * this.next.x + iWrap * this.wrap.x, this.start.y + iNext * this.next.y + iWrap * this.wrap.y));
                    iNext++;
                    if (iNext >= this.wrapAfter) {
                        iNext = 0;
                        iWrap++;
                    }
                }
                return positions;
            }
            //#region transfer
            async mutate(_mutator, _selection, _dispatchMutate) {
                super.mutate(_mutator, _selection, _dispatchMutate);
                this.create(this.texture, this.frames, this.wrapAfter, this.start, this.size, this.next, this.wrap, this.framesPerSecond);
            }
            serialize() {
                let serialization = {};
                serialization.idResource = this.idResource;
                serialization.idTexture = this.#texture.idResource;
                serialization.frames = this.frames;
                serialization.wrapAfter = this.wrapAfter;
                for (let name of ["start", "size", "next", "wrap"])
                    serialization[name] = Reflect.get(this, name).serialize();
                let animationsStructure = this.animationStructure;
                this.animationStructure = {}; // no need to serialize structure
                // let serialization: Serialization = super.serialize();
                serialization[super.constructor.name] = super.serialize();
                this.animationStructure = animationsStructure; // restore existent structure
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization[super.constructor.name]);
                if (_serialization.idTexture)
                    this.#texture = await FudgeCore.Project.getResource(_serialization.idTexture);
                for (let name of ["start", "size", "next", "wrap"])
                    Reflect.get(this, name).deserialize(_serialization[name]);
                this.create(this.texture, _serialization.frames, _serialization.wrapAfter, this.start, this.size, this.next, this.wrap, this.framesPerSecond);
                return this;
            }
            //#endregion
            /**
             * Converts the {@link AnimationSprite} into an {@link Animation}
             */
            convertToAnimation() {
                let animation = new FudgeCore.Animation(this.name, this.animationStructure, this.framesPerSecond);
                return animation;
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return AnimationSprite = _classThis;
    })();
    FudgeCore.AnimationSprite = AnimationSprite;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Extension of AudioBuffer with a load method that creates a buffer in the {@link AudioManager}.default to be used with {@link ComponentAudio}
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    let Audio = (() => {
        var _a;
        let _classDecorators = [(_a = FudgeCore.SerializableResource).register.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Mutable;
        var Audio = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                Audio = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(_classThis, _classExtraInitializers);
            }
            constructor(_url) {
                super();
                this.name = "Audio";
                this.idResource = undefined;
                this.buffer = undefined;
                this.path = undefined;
                this.url = undefined;
                this.ready = false;
                if (_url) {
                    this.load(_url);
                    this.name = _url.toString().split("/").pop();
                }
                FudgeCore.Project.register(this);
            }
            get isReady() {
                return this.ready;
            }
            /**
             * Asynchronously loads the audio (mp3) from the given url
             */
            async load(_url) {
                FudgeCore.Debug.fudge("AudioLoad", _url);
                this.url = _url;
                this.ready = false;
                this.path = new URL(this.url.toString(), FudgeCore.Project.baseURL);
                const response = await window.fetch(this.path.toString());
                const arrayBuffer = await response.arrayBuffer();
                let buffer = await FudgeCore.AudioManager.default.decodeAudioData(arrayBuffer);
                this.buffer = buffer;
                this.ready = true;
                this.dispatchEvent(new Event("ready" /* EVENT_AUDIO.READY */));
            }
            //#region Transfer
            serialize() {
                return {
                    url: this.url,
                    idResource: this.idResource,
                    name: this.name,
                    type: this.type
                };
            }
            async deserialize(_serialization) {
                FudgeCore.Project.register(this, _serialization.idResource);
                await this.load(_serialization.url);
                this.name = _serialization.name;
                return this;
            }
            async mutate(_mutator, _selection, _dispatchMutate) {
                let url = _mutator.url; // save url for reconstruction after exclusion
                if (_mutator.url != this.url.toString())
                    this.load(_mutator.url);
                // except url from mutator for further processing
                delete (_mutator.url);
                super.mutate(_mutator, _selection, _dispatchMutate);
                // reconstruct, for mutator may be kept by caller
                Reflect.set(_mutator, "url", url);
            }
            reduceMutator(_mutator) {
                // delete _mutator.idResource; 
                delete _mutator.ready;
            }
        };
        return Audio = _classThis;
    })();
    FudgeCore.Audio = Audio;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../Event/EventAudio.ts"/>
var FudgeCore;
///<reference path="../Event/EventAudio.ts"/>
(function (FudgeCore) {
    /**
     * Extends the standard AudioContext for integration with FUDGE-graphs.
     * Creates a default object at startup to be addressed as AudioManager default.
     * Other objects of this class may be create for special purposes.
     */
    class AudioManager extends AudioContext {
        /** The default context that may be used throughout the project without the need to create others */
        static { this.default = new AudioManager({ latencyHint: "interactive", sampleRate: 44100 }); }
        static { this.eventUpdate = new Event("updateAudioGraph" /* EVENT_AUDIO.UPDATE */); }
        constructor(_contextOptions) {
            super(_contextOptions);
            this.graph = null;
            this.cmpListener = null;
            /**
             * Determines FUDGE-graph to listen to. Each {@link ComponentAudio} in the graph will connect to this contexts master gain, all others disconnect.
             */
            this.listenTo = (_graph) => {
                if (this.graph)
                    this.graph.broadcastEvent(new Event("childRemoveFromAudioGraph" /* EVENT_AUDIO.CHILD_REMOVE */));
                if (!_graph)
                    return;
                this.graph = _graph;
                this.graph.broadcastEvent(new Event("childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */));
            };
            /**
             * Retrieve the FUDGE-graph currently listening to
             */
            this.getGraphListeningTo = () => {
                return this.graph;
            };
            /**
             * Set the {@link ComponentAudioListener} that serves the spatial location and orientation for this contexts listener
             */
            this.listenWith = (_cmpListener) => {
                this.cmpListener = _cmpListener;
            };
            /**
             * Updates the spatial settings of the AudioNodes effected in the current FUDGE-graph
             */
            this.update = () => {
                if (this.state != "running")
                    return;
                // this.graph.broadcastEvent(new Event(EVENT_AUDIO.UPDATE));
                this.graph.broadcastEvent(AudioManager.eventUpdate);
                if (this.cmpListener)
                    this.cmpListener.update(this.listener);
            };
            this.gain = this.createGain();
            this.gain.connect(this.destination);
        }
        /**
         * Set the master volume
         */
        set volume(_value) {
            this.gain.gain.value = _value;
        }
        /**
         * Get the master volume
         */
        get volume() {
            return this.gain.gain.value;
        }
    }
    FudgeCore.AudioManager = AudioManager;
})(FudgeCore || (FudgeCore = {}));
// namespace FudgeCore {
//     /**
//      * Enumerator for all possible Oscillator Types
//      */
//     type OSCILLATOR_TYPE = "sine" | "square" | "sawtooth" | "triangle" | "custom";
//     /**
//      * Interface to create Custom Oscillator Types.
//      * Start-/Endpoint of a custum curve e.g. sine curve.
//      * Both parameters need to be inbetween -1 and 1.
//      * @param startpoint startpoint of a curve 
//      * @param endpoint Endpoint of a curve 
//      */
//     interface OscillatorWave {
//         startpoint: number;
//         endpoint: number;
//     }
//     /**
//      * Add an {@link AudioFilter} to an {@link Audio]]
//      * @authors Thomas Dorner, HFU, 2019
//      */
//     export class AudioOscillator {
//         public audioOscillator: OscillatorNode; 
//         private frequency: number;
//         private oscillatorType: OSCILLATOR_TYPE;
//         private oscillatorWave: PeriodicWave;
//         private localGain: GainNode;
//         private localGainValue: number;
//         constructor(_audioSettings: AudioSettings, _oscillatorType?: OSCILLATOR_TYPE) {
//             this.audioOscillator = _audioSettings.getAudioContext().createOscillator();
//             this.localGain = _audioSettings.getAudioContext().createGain();
//             this.oscillatorType = _oscillatorType;
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//                 else {
//                     console.log("Create a Custom Periodic Wave first to use Custom Type");
//                 }
//             }
//         }
//         public setOscillatorType(_oscillatorType: OSCILLATOR_TYPE): void {
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//             }
//         }
//         public getOscillatorType(): OSCILLATOR_TYPE {
//             return this.oscillatorType;
//         }
//         public createPeriodicWave(_audioSettings: AudioSettings, _real: OscillatorWave, _imag: OscillatorWave): void {
//             let waveReal: Float32Array = new Float32Array(2);
//             waveReal[0] = _real.startpoint;
//             waveReal[1] = _real.endpoint;
//             let waveImag: Float32Array = new Float32Array(2);
//             waveImag[0] = _imag.startpoint;
//             waveImag[1] = _imag.endpoint;
//             this.oscillatorWave = _audioSettings.getAudioContext().createPeriodicWave(waveReal, waveImag);
//         }
//         public setLocalGain(_localGain: GainNode): void {
//             this.localGain = _localGain;
//         }
//         public getLocalGain(): GainNode {
//             return this.localGain;
//         }
//         public setLocalGainValue(_localGainValue: number): void {
//             this.localGainValue = _localGainValue;
//             this.localGain.gain.value = this.localGainValue;
//         }
//         public getLocalGainValue(): number {
//             return this.localGainValue;
//         }
//         public setFrequency(_audioSettings: AudioSettings, _frequency: number): void {
//             this.frequency = _frequency;
//             this.audioOscillator.frequency.setValueAtTime(this.frequency, _audioSettings.getAudioContext().currentTime);
//         }
//         public getFrequency(): number {
//             return this.frequency;
//         }
//         public createSnare(_audioSettings: AudioSettings): void {
//             this.setOscillatorType("triangle");
//             this.setFrequency(_audioSettings, 100);
//             this.setLocalGainValue(0);
//             this.localGain.gain.setValueAtTime(0, _audioSettings.getAudioContext().currentTime);
//             this.localGain.gain.exponentialRampToValueAtTime(0.01, _audioSettings.getAudioContext().currentTime + .1);
//             this.audioOscillator.connect(this.localGain);
//         }
//     }
// }
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attached to a {@link Node} with an attached {@link ComponentCamera} this causes the rendered image to receive an ambient occlusion effect.
     * @authors Roland Heer, HFU, 2023 | Jonas Plotzky, HFU, 2023
     */
    class ComponentAmbientOcclusion extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentAmbientOcclusion); }
        constructor(_sampleRadius = 16, _bias = 0.07, _attenuationConstant = 2.5, _attenuationLinear = 1, _attenuationQuadratic = 1) {
            super();
            this.sampleRadius = _sampleRadius;
            this.bias = _bias;
            this.attenuationConstant = _attenuationConstant;
            this.attenuationLinear = _attenuationLinear;
            this.attenuationQuadratic = _attenuationQuadratic;
        }
        //#region Transfer
        serialize() {
            let serialization = {
                sampleRadius: this.sampleRadius,
                bias: this.bias,
                attenuationConstant: this.attenuationConstant,
                attenuationLinear: this.attenuationLinear,
                attenuationQuadratic: this.attenuationQuadratic
            };
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.sampleRadius = _serialization.sampleRadius;
            this.bias = _serialization.bias;
            this.attenuationConstant = _serialization.attenuationConstant;
            this.attenuationLinear = _serialization.attenuationLinear;
            this.attenuationQuadratic = _serialization.attenuationQuadratic;
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
    }
    FudgeCore.ComponentAmbientOcclusion = ComponentAmbientOcclusion;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
var FudgeCore;
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
(function (FudgeCore) {
    /**
     * Holds a reference to an {@link Animation} and controls it. Controls quantization and playmode as well as speed.
     * @authors Lukas Scheuerle, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2021 | Jonas Plotzky, HFU, 2022
     */
    let ComponentAnimation = (() => {
        let _classSuper = FudgeCore.Component;
        let _animation_decorators;
        let _animation_initializers = [];
        let _animation_extraInitializers = [];
        return class ComponentAnimation extends _classSuper {
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _animation_decorators = [FudgeCore.type(FudgeCore.Animation)];
                __esDecorate(null, null, _animation_decorators, { kind: "field", name: "animation", static: false, private: false, access: { has: obj => "animation" in obj, get: obj => obj.animation, set: (obj, value) => { obj.animation = value; } }, metadata: _metadata }, _animation_initializers, _animation_extraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentAnimation); }
            #scale;
            #timeLocal;
            #previous;
            constructor(_animation, _playmode = FudgeCore.ANIMATION_PLAYMODE.LOOP, _quantization = FudgeCore.ANIMATION_QUANTIZATION.CONTINOUS) {
                super();
                this.animation = __runInitializers(this, _animation_initializers, void 0);
                this.playmode = __runInitializers(this, _animation_extraInitializers);
                this.scaleWithGameTime = true;
                this.animateInEditor = false;
                this.#scale = 1;
                this.#previous = 0;
                //#region updateAnimation
                /**
                 * Updates the Animation.
                 * Uses the built-in time unless a different time is specified.
                 * May also be called from updateAnimation().
                 */
                this.updateAnimationLoop = (_e, _time) => {
                    FudgeCore.PerformanceMonitor.startMeasure("updateAnimationLoop");
                    if (this.animation.totalTime == 0)
                        return null;
                    let time = _time || _time === 0 ? _time : this.#timeLocal.get();
                    if (this.quantization == FudgeCore.ANIMATION_QUANTIZATION.FRAMES) {
                        time = this.#previous + (1000 / this.animation.fps);
                    }
                    let direction = this.animation.calculateDirection(time, this.playmode);
                    time = this.animation.getModalTime(time, this.playmode, this.#timeLocal.getOffset());
                    this.executeEvents(this.animation.getEventsToFire(this.#previous, time, this.quantization, direction));
                    if (this.#previous != time) {
                        this.#previous = time;
                        time = time % this.animation.totalTime;
                        let mutator = this.animation.getState(time, direction, this.quantization);
                        if (this.node) {
                            this.node.applyAnimation(mutator);
                        }
                        FudgeCore.PerformanceMonitor.endMeasure("updateAnimationLoop");
                        return mutator;
                    }
                    return null;
                };
                /**
                 * Updates the scale of the animation if the user changes it or if the global game timer changed its scale.
                 */
                this.updateScale = () => {
                    let newScale = this.#scale;
                    if (this.scaleWithGameTime)
                        newScale *= FudgeCore.Time.game.getScale();
                    this.#timeLocal.setScale(newScale);
                };
                this.playmode = _playmode;
                this.quantization = _quantization;
                this.animation = _animation;
                this.#timeLocal = new FudgeCore.Time();
                //TODO: update animation total time when loading a different animation?
                this.animation?.calculateTotalTime();
                this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, () => this.activate(false));
                this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, () => {
                    this.node.addEventListener("childRemove" /* EVENT.CHILD_REMOVE */, () => this.activate(false));
                    this.activate(true);
                });
            }
            set scale(_scale) {
                this.#scale = _scale;
                this.updateScale();
            }
            get scale() {
                return this.#scale;
            }
            /**
             * - get: return the current sample time of the animation
             * - set: jump to a certain sample time in the animation
             */
            get time() {
                return this.#timeLocal.get() % this.animation.totalTime;
            }
            set time(_time) {
                this.jumpTo(_time);
            }
            activate(_on) {
                super.activate(_on);
                if (!this.node)
                    return;
                this.activateListeners(_on);
            }
            /**
             * Jumps to a certain time in the animation to play from there.
             */
            jumpTo(_time) {
                this.#timeLocal.set(_time);
                this.#previous = _time;
                _time = _time % this.animation.totalTime;
                let mutator = this.animation.getState(_time, this.animation.calculateDirection(_time, this.playmode), this.quantization);
                this.node.applyAnimation(mutator);
            }
            /**
             * Jumps to a certain label in the animation if defined
             */
            jumpToLabel(_label) {
                let time = this.animation.labels[_label];
                if (time)
                    this.jumpTo(time);
            }
            /**
             * Forces an update of the animation from outside. Used in the ViewAnimation. Shouldn't be used during the game.
             * @param _time the (unscaled) time to update the animation with.
             * @returns the Mutator for Animation.
             */
            updateAnimation(_time) {
                this.#previous = undefined;
                return this.updateAnimationLoop(null, _time);
            }
            //#region transfer
            serialize() {
                let serialization = {};
                serialization[super.constructor.name] = super.serialize();
                serialization.idAnimation = this.animation.idResource;
                serialization.playmode = this.playmode;
                serialization.quantization = this.quantization;
                serialization.scale = this.scale;
                serialization.scaleWithGameTime = this.scaleWithGameTime;
                serialization.animateInEditor = this.animateInEditor;
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization[super.constructor.name]);
                this.animation = await FudgeCore.Project.getResource(_serialization.idAnimation);
                this.playmode = _serialization.playmode;
                this.quantization = _serialization.quantization;
                this.scale = _serialization.scale;
                this.scaleWithGameTime = _serialization.scaleWithGameTime;
                this.animateInEditor = _serialization.animateInEditor;
                return this;
            }
            async mutate(_mutator, _selection = null, _dispatchMutate = true) {
                await super.mutate(_mutator, _selection, _dispatchMutate);
                if (typeof (_mutator.animateInEditor) !== "undefined") {
                    this.updateAnimation(0);
                    this.activateListeners(this.active);
                }
            }
            getMutatorAttributeTypes(_mutator) {
                let types = super.getMutatorAttributeTypes(_mutator);
                if (types.playmode)
                    types.playmode = FudgeCore.ANIMATION_PLAYMODE;
                if (types.quantization)
                    types.quantization = FudgeCore.ANIMATION_QUANTIZATION;
                return types;
            }
            //#endregion
            activateListeners(_on) {
                if (_on && (FudgeCore.Project.mode != FudgeCore.MODE.EDITOR || FudgeCore.Project.mode == FudgeCore.MODE.EDITOR && this.animateInEditor)) {
                    FudgeCore.Time.game.addEventListener("timeScaled" /* EVENT.TIME_SCALED */, this.updateScale);
                    this.node.addEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.updateAnimationLoop);
                }
                else {
                    FudgeCore.Time.game.removeEventListener("timeScaled" /* EVENT.TIME_SCALED */, this.updateScale);
                    this.node.removeEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.updateAnimationLoop);
                }
            }
            /**
             * Fires all custom events the Animation should have fired between the last frame and the current frame.
             * @param _events a list of names of custom events to fire
             */
            executeEvents(_events) {
                for (let i = 0; i < _events.length; i++) {
                    this.dispatchEvent(new Event(_events[i]));
                }
            }
        };
    })();
    FudgeCore.ComponentAnimation = ComponentAnimation;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches an {@link AnimationNode animation graph} to a {@link Node} and animates it.
     * @author Jonas Plotzky, HFU, 2024-2025
     */
    class ComponentAnimationGraph extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentAnimationGraph); }
        constructor(_root) {
            super();
            this.update = () => {
                FudgeCore.PerformanceMonitor.startMeasure("ComponentAnimationGraph.update");
                if (!this.root || !this.node || !this.active)
                    return;
                FudgeCore.PerformanceMonitor.startMeasure("ComponentAnimationGraph.update compute");
                this.root.update(FudgeCore.Loop.timeFrameGame);
                this.root.events?.forEach(_event => this.dispatchEvent(new Event(_event)));
                FudgeCore.PerformanceMonitor.endMeasure("ComponentAnimationGraph.update compute");
                FudgeCore.PerformanceMonitor.startMeasure("ComponentAnimationGraph.update apply");
                this.node.applyAnimation(this.root.mutator);
                FudgeCore.PerformanceMonitor.endMeasure("ComponentAnimationGraph.update apply");
                FudgeCore.PerformanceMonitor.endMeasure("ComponentAnimationGraph.update");
            };
            this.root = _root;
            if (FudgeCore.Project.mode == FudgeCore.MODE.EDITOR)
                return;
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, () => this.node.addEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.update));
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, () => this.node.removeEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.update));
        }
    }
    FudgeCore.ComponentAnimationGraph = ComponentAnimationGraph;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let AUDIO_PANNER;
    (function (AUDIO_PANNER) {
        AUDIO_PANNER["CONE_INNER_ANGLE"] = "coneInnerAngle";
        AUDIO_PANNER["CONE_OUTER_ANGLE"] = "coneOuterAngle";
        AUDIO_PANNER["CONE_OUTER_GAIN"] = "coneOuterGain";
        AUDIO_PANNER["DISTANCE_MODEL"] = "distanceModel";
        AUDIO_PANNER["MAX_DISTANCE"] = "maxDistance";
        AUDIO_PANNER["PANNING_MODEL"] = "panningModel";
        AUDIO_PANNER["REF_DISTANCE"] = "refDistance";
        AUDIO_PANNER["ROLLOFF_FACTOR"] = "rolloffFactor";
    })(AUDIO_PANNER = FudgeCore.AUDIO_PANNER || (FudgeCore.AUDIO_PANNER = {}));
    let AUDIO_NODE_TYPE;
    (function (AUDIO_NODE_TYPE) {
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["SOURCE"] = 0] = "SOURCE";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["PANNER"] = 1] = "PANNER";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["GAIN"] = 2] = "GAIN";
    })(AUDIO_NODE_TYPE = FudgeCore.AUDIO_NODE_TYPE || (FudgeCore.AUDIO_NODE_TYPE = {}));
    /**
     * Builds a minimal audio graph (by default in {@link AudioManager}.default) and synchronizes it with the containing {@link Node}
     * ```text
     * ‚îå AudioManager(.default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     * ‚îÇ ‚îå ComponentAudio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
     * ‚îÇ ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
     * ‚îÇ ‚îÇ    ‚îÇsource‚îÇ ‚Üí ‚îÇpanner‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚îÇ
     * ‚îÇ ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
     * ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
     * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ComponentAudio = (() => {
        let _classSuper = FudgeCore.Component;
        let _audio_decorators;
        let _audio_initializers = [];
        let _audio_extraInitializers = [];
        return class ComponentAudio extends _classSuper {
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _audio_decorators = [FudgeCore.type(FudgeCore.Audio)];
                __esDecorate(null, null, _audio_decorators, { kind: "field", name: "audio", static: false, private: false, access: { has: obj => "audio" in obj, get: obj => obj.audio, set: (obj, value) => { obj.audio = value; } }, metadata: _metadata }, _audio_initializers, _audio_extraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudio); }
            constructor(_audio = null, _loop = false, _start = false, _audioManager = FudgeCore.AudioManager.default) {
                super();
                /** places and directs the panner relative to the world transform of the {@link Node}  */
                this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
                this.singleton = false;
                this.audio = __runInitializers(this, _audio_initializers, void 0);
                this.gain = __runInitializers(this, _audio_extraInitializers);
                this.playing = false;
                this.listened = false;
                //#endregion
                this.hndAudioReady = (_event) => {
                    FudgeCore.Debug.fudge("Audio start", Reflect.get(_event.target, "url"));
                    if (this.playing)
                        this.play(true);
                };
                this.hndAudioEnded = (_event) => {
                    // Debug.fudge("Audio ended", Reflect.get(_event.target, "url"));
                    this.playing = false;
                };
                /**
                 * Automatically connects/disconnects AudioNodes when adding/removing this component to/from a node.
                 * Therefore unused AudioNodes may be garbage collected when an unused component is collected
                 */
                this.handleAttach = (_event) => {
                    // Debug.log(_event);
                    if (_event.type == "componentAdd" /* EVENT.COMPONENT_ADD */) {
                        this.node.addEventListener("childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */, this.handleGraph, true);
                        this.node.addEventListener("childRemoveFromAudioGraph" /* EVENT_AUDIO.CHILD_REMOVE */, this.handleGraph, true);
                        this.node.addEventListener("updateAudioGraph" /* EVENT_AUDIO.UPDATE */, this.update, true);
                        this.listened = this.node.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo());
                    }
                    else {
                        this.node.removeEventListener("childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */, this.handleGraph, true);
                        this.node.removeEventListener("childRemoveFromAudioGraph" /* EVENT_AUDIO.CHILD_REMOVE */, this.handleGraph, true);
                        this.node.removeEventListener("updateAudioGraph" /* EVENT_AUDIO.UPDATE */, this.update, true);
                        this.listened = false;
                    }
                    this.updateConnection();
                };
                /**
                 * Automatically connects/disconnects AudioNodes when appending/removing the FUDGE-graph the component is in.
                 */
                this.handleGraph = (_event) => {
                    // Debug.log(_event);
                    this.listened = (_event.type == "childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */);
                    this.updateConnection();
                };
                /**
                 * Updates the panner node, its position and direction, using the worldmatrix of the container and the pivot of this component.
                 */
                this.update = (_event) => {
                    let mtxResult = this.mtxPivot;
                    if (this.node)
                        mtxResult = FudgeCore.Matrix4x4.PRODUCT(this.node.mtxWorld, this.mtxPivot);
                    // Debug.log(mtxResult.toString());
                    let position = mtxResult.translation;
                    let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
                    this.panner.positionX.value = position.x;
                    this.panner.positionY.value = position.y;
                    this.panner.positionZ.value = position.z;
                    this.panner.orientationX.value = forward.x;
                    this.panner.orientationY.value = forward.y;
                    this.panner.orientationZ.value = forward.z;
                    FudgeCore.Recycler.store(forward);
                    // TODO: examine why the following produces erroneous results, see test "Spatial Audio"
                    if (this.node)
                        FudgeCore.Recycler.store(mtxResult);
                };
                this.install(_audioManager);
                this.createSource(_audio, _loop);
                this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.handleAttach);
                this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.handleAttach);
                if (_start)
                    this.play(_start);
            }
            set volume(_value) {
                this.gain.gain.value = _value;
            }
            get volume() {
                return this.gain.gain.value;
            }
            set loop(_on) {
                this.source.loop = _on;
            }
            get loop() {
                return this.source.loop;
            }
            set playbackRate(_value) {
                this.source.playbackRate.value = _value;
            }
            get playbackRate() {
                return this.source.playbackRate.value;
            }
            get isPlaying() {
                return this.playing;
            }
            get isAttached() {
                return this.node != null;
            }
            get isListened() {
                return this.listened;
            }
            /**
             * Sets the given {@link Audio} as the audio source
             */
            setAudio(_audio) {
                this.createSource(_audio, this.source.loop);
            }
            /**
             * Returns the {@link Audio} currently used as audio source
             */
            getAudio() {
                return this.audio;
            }
            /**
             * Set the property of the panner to the given value. Use to manipulate range and rolloff etc.
             */
            setPanner(_property, _value) {
                Reflect.set(this.panner, _property, _value);
            }
            // TODO: may be used for serialization of AudioNodes
            /**
             * Returns the mutator for the specified AudioNode of the standard graph
             */
            getMutatorOfNode(_type) {
                let node = this.getAudioNode(_type);
                let mutator = FudgeCore.getMutatorOfArbitrary(node);
                return mutator;
            }
            /**
             * Returns the specified AudioNode of the standard graph for further manipulation
             */
            getAudioNode(_type) {
                switch (_type) {
                    case AUDIO_NODE_TYPE.SOURCE: return this.source;
                    case AUDIO_NODE_TYPE.PANNER: return this.panner;
                    case AUDIO_NODE_TYPE.GAIN: return this.gain;
                }
            }
            /**
             * Start or stop playing the audio
             */
            play(_on) {
                if (_on) {
                    if (this.audio.isReady) {
                        this.createSource(this.audio, this.source.loop, this.playbackRate);
                        this.source.start(0, 0);
                    }
                    else {
                        this.audio.addEventListener("ready" /* EVENT_AUDIO.READY */, this.hndAudioReady);
                    }
                    this.source.addEventListener("ended" /* EVENT_AUDIO.ENDED */, this.hndAudioEnded);
                }
                else
                    try {
                        this.source.stop();
                    }
                    catch (_error) { /* catch exception when source hasn't been started... */ }
                this.playing = _on;
            }
            /**
             * Inserts AudioNodes between the panner and the local gain of this {@link ComponentAudio}
             * _input and _output may be the same AudioNode, if there is only one to insert,
             * or may have multiple AudioNode between them to create an effect-graph.\
             * Note that {@link ComponentAudio} does not keep track of inserted AudioNodes!
             * ```text
             * ‚îå AudioManager(.default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
             * ‚îÇ ‚îå ComponentAudio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
             * ‚îÇ ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
             * ‚îÇ ‚îÇ    ‚îÇsource‚îÇ ‚Üí ‚îÇpanner‚îÇ ‚Üí ‚îÇ_input‚îÇ ‚Üí ...  ‚Üí ‚îÇ_output‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚îÇ
             * ‚îÇ ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
             * ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
             * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             * ```
             */
            insertAudioNodes(_input, _output) {
                this.panner.disconnect(0);
                if (!_input && !_output) {
                    this.panner.connect(this.gain);
                    return;
                }
                this.panner.connect(_input);
                _output.connect(this.gain);
            }
            /**
             * Activate override. Connects or disconnects AudioNodes
             */
            activate(_on) {
                super.activate(_on);
                this.updateConnection();
            }
            /**
             * Connects this components gain-node to the gain node of the AudioManager this component runs on.
             * Only call this method if the component is not attached to a {@link Node} but needs to be heard.
             */
            connect(_on) {
                if (_on)
                    this.gain.connect(this.audioManager.gain);
                else
                    this.gain.disconnect(this.audioManager.gain);
            }
            drawGizmos() {
                let mtxShape = FudgeCore.Matrix4x4.PRODUCT(this.node.mtxWorld, this.mtxPivot);
                mtxShape.scaling = new FudgeCore.Vector3(0.5, 0.5, 0.5);
                let color = FudgeCore.Color.CSS("cornflowerblue");
                FudgeCore.Gizmos.drawIcon(FudgeCore.TextureDefault.iconAudio, mtxShape, color);
                FudgeCore.Recycler.storeMultiple(mtxShape, color);
            }
            ;
            //#region Transfer
            serialize() {
                let serialization = super.serialize();
                serialization.idResource = this.audio?.idResource;
                serialization.playing = this.playing;
                serialization.loop = this.loop;
                serialization.volume = this.volume;
                // console.log(this.getMutatorOfNode(AUDIO_NODE_TYPE.PANNER));
                // TODO: serialize panner parameters
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization);
                let audio = await FudgeCore.Project.getResource(_serialization.idResource);
                this.createSource(audio, _serialization.loop);
                this.volume = _serialization.volume;
                this.play(_serialization.playing);
                return this;
            }
            getMutator() {
                let mutator = super.getMutator(true);
                let audio = mutator.audio;
                delete mutator.audio; // just to rearrange in interfaces...
                mutator.loop = this.loop;
                mutator.volume = this.volume;
                mutator.audio = audio; //... so audio comes last
                return mutator;
            }
            // public async mutate(_mutator: Mutator): Promise<void> {
            //   await super.mutate(_mutator);
            //   // this.volume = _mutator.volume;
            //   // this.loop = _mutator.loop;
            // }
            reduceMutator(_mutator) {
                super.reduceMutator(_mutator);
                delete _mutator.listened;
            }
            install(_audioManager = FudgeCore.AudioManager.default) {
                let active = this.isActive;
                this.activate(false);
                this.audioManager = _audioManager;
                this.panner = _audioManager.createPanner();
                this.gain = _audioManager.createGain();
                this.panner.connect(this.gain);
                this.gain.connect(_audioManager.gain);
                this.activate(active);
            }
            createSource(_audio, _loop, _playbackRate = 1.0) {
                if (this.source) {
                    this.source.disconnect();
                    this.source.buffer = null;
                }
                this.source = this.audioManager.createBufferSource();
                this.source.connect(this.panner);
                if (_audio) {
                    this.audio = _audio;
                    this.source.buffer = _audio.buffer;
                }
                this.source.loop = _loop;
                this.playbackRate = _playbackRate;
            }
            updateConnection() {
                try {
                    this.connect(this.isActive && this.isAttached && this.listened);
                }
                catch (_error) {
                    // nop
                }
            }
        };
    })();
    FudgeCore.ComponentAudio = ComponentAudio;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Serves to set the spatial location and orientation of AudioListeners relative to the
     * world transform of the {@link Node} it is attached to.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentAudioListener extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
        }
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudioListener); }
        /**
         * Updates the position and orientation of the given AudioListener
         */
        update(_listener) {
            let mtxResult = this.mtxPivot;
            if (this.node)
                mtxResult = FudgeCore.Matrix4x4.PRODUCT(this.node.mtxWorld, this.mtxPivot);
            // Debug.log(mtxResult.toString());
            let position = mtxResult.translation;
            let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
            let up = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Y(), mtxResult, false);
            if (_listener.positionX != undefined) {
                _listener.positionX.value = position.x;
                _listener.positionY.value = position.y;
                _listener.positionZ.value = position.z;
                _listener.forwardX.value = forward.x;
                _listener.forwardY.value = forward.y;
                _listener.forwardZ.value = forward.z;
                _listener.upX.value = up.x;
                _listener.upY.value = up.y;
                _listener.upZ.value = up.z;
            }
            else {
                // Firefox still uses deprecated methods. TODO: delete as soon as possible!
                _listener.setPosition(position.x, position.y, position.z);
                _listener.setOrientation(forward.x, forward.y, forward.z, up.x, up.y, up.z);
            }
            FudgeCore.Recycler.store(forward);
            FudgeCore.Recycler.store(up);
            if (this.node)
                FudgeCore.Recycler.store(mtxResult);
            // Debug.log(mtxResult.translation.toString(), forward.toString(), up.toString());
        }
    }
    FudgeCore.ComponentAudioListener = ComponentAudioListener;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attached to a {@link Node} with an attached {@link ComponentCamera} this causes the rendered image to receive a bloom-effect.
     * @authors Roland Heer, HFU, 2023
     */
    class ComponentBloom extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentBloom); }
        #threshold;
        #intensity;
        #highlightDesaturation;
        constructor(_threshold = 0.95, _intensity = 1.0, _desaturateHighlights = 0.5) {
            super();
            this.#threshold = _threshold;
            this.#intensity = _intensity;
            this.#highlightDesaturation = _desaturateHighlights;
        }
        get threshold() {
            return this.#threshold;
        }
        set threshold(_value) {
            this.#threshold = FudgeCore.Calc.clamp(_value, 0, 1);
        }
        get intensity() {
            return this.#intensity;
        }
        set intensity(_value) {
            this.#intensity = Math.max(0, _value);
        }
        get highlightDesaturation() {
            return this.#highlightDesaturation;
        }
        set highlightDesaturation(_value) {
            this.#highlightDesaturation = FudgeCore.Calc.clamp(_value, 0, 1);
        }
        //#region Transfer
        serialize() {
            let serialization = {
                threshold: this.#threshold,
                intensity: this.#intensity,
                desaturateHighlights: this.#highlightDesaturation,
            };
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.#threshold = _serialization.threshold;
            this.#intensity = _serialization.intensity;
            this.#highlightDesaturation = _serialization.desaturateHighlights;
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.threshold = this.threshold;
            mutator.intensity = this.intensity;
            mutator.highlightDesaturation = this.highlightDesaturation;
            return mutator;
        }
    }
    FudgeCore.ComponentBloom = ComponentBloom;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="Component.ts"/>
var FudgeCore;
// / <reference path="Component.ts"/>
(function (FudgeCore) {
    let FIELD_OF_VIEW;
    (function (FIELD_OF_VIEW) {
        FIELD_OF_VIEW["HORIZONTAL"] = "horizontal";
        FIELD_OF_VIEW["VERTICAL"] = "vertical";
        FIELD_OF_VIEW["DIAGONAL"] = "diagonal";
    })(FIELD_OF_VIEW = FudgeCore.FIELD_OF_VIEW || (FudgeCore.FIELD_OF_VIEW = {}));
    /**
     * Defines identifiers for the various projections a camera can provide.
     * TODO: change back to number enum if strings not needed
     */
    let PROJECTION;
    (function (PROJECTION) {
        PROJECTION["CENTRAL"] = "central";
        PROJECTION["ORTHOGRAPHIC"] = "orthographic";
        PROJECTION["DIMETRIC"] = "dimetric";
        PROJECTION["STEREO"] = "stereo";
    })(PROJECTION = FudgeCore.PROJECTION || (FudgeCore.PROJECTION = {}));
    /**
     * The camera component holds the projection-matrix and other data needed to render a scene from the perspective of the node it is attached to.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentCamera extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
            this.clrBackground = new FudgeCore.Color(0, 0, 0, 1); // The color of the background the camera will render.
            //private orthographic: boolean = false; // Determines whether the image will be rendered with perspective or orthographic projection.
            this.projection = PROJECTION.CENTRAL;
            this.fieldOfView = 45; // The camera's sensorangle.
            this.aspectRatio = 1.0;
            this.direction = FIELD_OF_VIEW.DIAGONAL;
            this.near = 1;
            this.far = 2000;
            this.backgroundEnabled = true; // Determines whether or not the background of this camera will be rendered.
            //#endregion
        }
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentCamera); }
        // TODO: examine, if background should be an attribute of Camera or Viewport
        #mtxWorldToView;
        #mtxCameraInverse;
        #mtxProjection;
        /**
         * Returns {@link mtxProjection} * {@link mtxCameraInverse}
         * yielding the worldspace to viewspace matrix
         */
        get mtxWorldToView() {
            if (this.#mtxWorldToView)
                return this.#mtxWorldToView;
            //TODO: optimize, no need to recalculate if neither mtxWorld nor mtxProjection have changed
            this.#mtxWorldToView = FudgeCore.Matrix4x4.PRODUCT(this.#mtxProjection, this.mtxCameraInverse);
            return this.#mtxWorldToView;
        }
        /**
         * Returns the inversion of this cameras worldtransformation
         */
        get mtxCameraInverse() {
            if (this.#mtxCameraInverse)
                return this.#mtxCameraInverse;
            //TODO: optimize, no need to recalculate if mtxWorld hasn't changed
            this.#mtxCameraInverse = FudgeCore.Matrix4x4.INVERSE(this.mtxWorld);
            return this.#mtxCameraInverse;
        }
        /**
         * Returns the projectionmatrix of this camera
         */
        get mtxProjection() {
            return this.#mtxProjection;
        }
        /**
         * Resets this cameras {@link mtxWorldToView} and {@link mtxCameraInverse} matrices
         */
        resetWorldToView() {
            if (this.#mtxWorldToView)
                FudgeCore.Recycler.store(this.#mtxWorldToView);
            if (this.#mtxCameraInverse)
                FudgeCore.Recycler.store(this.#mtxCameraInverse);
            this.#mtxWorldToView = null;
            this.#mtxCameraInverse = null;
        }
        /**
         * Returns the cameras {@link PROJECTION} mode
         */
        getProjection() {
            return this.projection;
        }
        /**
         * Returns true if the background of the camera should be rendered, false if not
         */
        getBackgroundEnabled() {
            return this.backgroundEnabled;
        }
        /**
         * Returns the cameras aspect ratio
         */
        getAspect() {
            return this.aspectRatio;
        }
        /**
         * Returns the cameras field of view in degrees
         */
        getFieldOfView() {
            return this.fieldOfView;
        }
        /**
         * Returns the cameras direction i.e. the plane on which the fieldOfView-Angle is given
         */
        getDirection() {
            return this.direction;
        }
        /**
         * Returns the cameras near value i.e. the minimum distance to render objects at
         */
        getNear() {
            return this.near;
        }
        /**
         * Returns the cameras far value i.e. the maximum distance to render objects at
         */
        getFar() {
            return this.far;
        }
        /**
         * Set the camera to perspective projection. The world origin is in the center of the canvaselement.
         * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
         * @param _fieldOfView The field of view in Degrees. (Default = 45)
         * @param _direction The plane on which the fieldOfView-Angle is given
         */
        projectCentral(_aspect = this.aspectRatio, _fieldOfView = this.fieldOfView, _direction = this.direction, _near = this.near, _far = this.far) {
            this.aspectRatio = _aspect;
            this.fieldOfView = _fieldOfView;
            this.direction = _direction;
            this.projection = PROJECTION.CENTRAL;
            this.near = _near;
            this.far = _far;
            this.#mtxProjection = FudgeCore.Matrix4x4.PROJECTION_CENTRAL(_aspect, this.fieldOfView, _near, _far, this.direction); // TODO: remove magic numbers
        }
        /**
         * Set the camera to orthographic projection. Default values are derived the canvas client dimensions
         * @param _left The positionvalue of the projectionspace's left border.
         * @param _right The positionvalue of the projectionspace's right border.
         * @param _bottom The positionvalue of the projectionspace's bottom border.
         * @param _top The positionvalue of the projectionspace's top border.
         */
        projectOrthographic(_left = -FudgeCore.Render.getCanvas().clientWidth / 2, _right = FudgeCore.Render.getCanvas().clientWidth / 2, _bottom = FudgeCore.Render.getCanvas().clientHeight / 2, _top = -FudgeCore.Render.getCanvas().clientHeight / 2) {
            this.projection = PROJECTION.ORTHOGRAPHIC;
            this.#mtxProjection = FudgeCore.Matrix4x4.PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, 400, -400); // TODO: examine magic numbers!
        }
        /**
         * Return the calculated dimension of a projection surface in the hypothetical distance of 1 to the camera
         */
        getProjectionRectangle() {
            let tanFov = Math.tan(Math.PI * this.fieldOfView / 360); // Half of the angle, to calculate dimension from the center -> right angle
            let tanHorizontal = 0;
            let tanVertical = 0;
            if (this.direction == FIELD_OF_VIEW.DIAGONAL) {
                let aspect = Math.sqrt(this.aspectRatio);
                tanHorizontal = tanFov * aspect;
                tanVertical = tanFov / aspect;
            }
            else if (this.direction == FIELD_OF_VIEW.VERTICAL) {
                tanVertical = tanFov;
                tanHorizontal = tanVertical * this.aspectRatio;
            }
            else { //FOV_DIRECTION.HORIZONTAL
                tanHorizontal = tanFov;
                tanVertical = tanHorizontal / this.aspectRatio;
            }
            return FudgeCore.Rectangle.GET(0, 0, tanHorizontal * 2, tanVertical * 2);
        }
        /**
         * Transforms the given point from world space to clip space
         */
        pointWorldToClip(_pointInWorldSpace) {
            let result;
            let m = this.mtxWorldToView.get();
            let w = m[3] * _pointInWorldSpace.x + m[7] * _pointInWorldSpace.y + m[11] * _pointInWorldSpace.z + m[15];
            result = FudgeCore.Vector3.TRANSFORMATION(_pointInWorldSpace, this.mtxWorldToView);
            result.scale(1 / w);
            return result;
        }
        /**
         * Transforms the given point from clip space to world space
         */
        pointClipToWorld(_pointInClipSpace) {
            let mtxViewToWorld = FudgeCore.Matrix4x4.INVERSE(this.mtxWorldToView);
            let m = mtxViewToWorld.get();
            let rayWorld = FudgeCore.Vector3.TRANSFORMATION(_pointInClipSpace, mtxViewToWorld, true);
            let w = m[3] * _pointInClipSpace.x + m[7] * _pointInClipSpace.y + m[11] * _pointInClipSpace.z + m[15];
            rayWorld.scale(1 / w);
            return rayWorld;
        }
        /**
         * Returns a scaling factor that, given a position in world space,
         * scales an object at that position so that one unit equals one (logical) pixel on the screen
         * when seen through this camera.
         * e.g., after setting the scaling, 1 unit in the world equals one (logical) pixel on the screen.
         */
        getWorldToPixelScale(_posWorld) {
            let distance = this.mtxWorld.translation.getDistance(_posWorld);
            let scale;
            let rect = FudgeCore.Render.getRenderRectangle();
            switch (this.getDirection()) {
                case FIELD_OF_VIEW.VERTICAL:
                    scale = 1 / rect.height * window.devicePixelRatio;
                    break;
                case FIELD_OF_VIEW.HORIZONTAL:
                    scale = 1 / rect.width * window.devicePixelRatio;
                    break;
                case FIELD_OF_VIEW.DIAGONAL:
                    scale = 1 / Math.sqrt((rect.width * rect.height) * window.devicePixelRatio);
                    break;
            }
            return scale * distance;
        }
        //#region Transfer
        serialize() {
            let serialization = {
                backgroundColor: this.clrBackground,
                backgroundEnabled: this.backgroundEnabled,
                projection: this.projection,
                fieldOfView: this.fieldOfView,
                direction: this.direction,
                near: this.near,
                far: this.far,
                aspect: this.aspectRatio,
                pivot: this.mtxPivot.serialize(),
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            await this.clrBackground.deserialize(_serialization.backgroundColor);
            this.backgroundEnabled = _serialization.backgroundEnabled;
            this.projection = _serialization.projection;
            this.fieldOfView = _serialization.fieldOfView;
            this.aspectRatio = _serialization.aspect;
            this.direction = _serialization.direction;
            this.near = _serialization.near ?? this.near;
            this.far = _serialization.far ?? this.far;
            await this.mtxPivot.deserialize(_serialization.pivot);
            await super.deserialize(_serialization[super.constructor.name]);
            switch (this.projection) {
                case PROJECTION.ORTHOGRAPHIC:
                    this.projectOrthographic(); // TODO: serialize and deserialize parameters
                    break;
                case PROJECTION.CENTRAL:
                    this.projectCentral();
                    break;
            }
            return this;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.direction)
                types.direction = FIELD_OF_VIEW;
            if (types.projection)
                types.projection = PROJECTION;
            return types;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            await super.mutate(_mutator, _selection, _dispatchMutate);
            switch (this.projection) {
                case PROJECTION.CENTRAL:
                    this.projectCentral(this.aspectRatio, this.fieldOfView, this.direction, this.near, this.far);
                    break;
            }
        }
        drawGizmos() {
            let mtxWorld = this.mtxWorld.clone;
            mtxWorld.scaling = new FudgeCore.Vector3(0.5, 0.5, 0.5);
            let color = FudgeCore.Color.CSS("lightgrey");
            FudgeCore.Gizmos.drawIcon(FudgeCore.TextureDefault.iconCamera, mtxWorld, color);
            FudgeCore.Recycler.storeMultiple(mtxWorld, color);
        }
        drawGizmosSelected() {
            FudgeCore.Gizmos.drawWireFrustum(this.getAspect(), this.getFieldOfView(), this.getNear(), this.getFar(), this.getDirection(), this.mtxWorld, FudgeCore.Color.CSS("lightgrey"));
        }
        ;
        reduceMutator(_mutator) {
            delete _mutator.transform;
            super.reduceMutator(_mutator);
        }
    }
    FudgeCore.ComponentCamera = ComponentCamera;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Makes the node face the camera when rendering, respecting restrictions for rotation around specific axis
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Component
     */
    class ComponentFaceCamera extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentFaceCamera); }
        constructor() {
            super();
            this.upLocal = true;
            this.up = FudgeCore.Vector3.Y(1);
            this.restrict = false;
            this.singleton = true;
        }
    }
    FudgeCore.ComponentFaceCamera = ComponentFaceCamera;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attached to a {@link Node} with an attached {@link ComponentCamera} this causes the rendered image to receive a fog-effect.
     * @authors Roland Heer, HFU, 2023
     */
    class ComponentFog extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentFog); }
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1), _near = 1, _far = 50) {
            super();
            this.color = _color;
            this.near = _near;
            this.far = _far;
        }
        //#region Transfer
        serialize() {
            let serialization = {
                color: this.color.serialize(),
                near: this.near,
                far: this.far
            };
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await this.color.deserialize(_serialization.color);
            this.near = _serialization.near ?? this.near;
            this.far = _serialization.far ?? this.far;
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
    }
    FudgeCore.ComponentFog = ComponentFog;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Filters synchronization between a graph instance and the graph it is connected to. If active, no synchronization occurs.
     * Maybe more finegrained in the future...
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Component
     */
    class ComponentGraphFilter extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentGraphFilter); }
        constructor() {
            super();
            this.singleton = true;
        }
        serialize() {
            return this.getMutator();
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
    }
    FudgeCore.ComponentGraphFilter = ComponentGraphFilter;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for different kinds of lights.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Light extends FudgeCore.Mutable {
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1), _intensity = 1) {
            super();
            this.color = _color;
            this.intensity = _intensity;
        }
        /**
         * Returns the {@link TypeOfLight} of this light.
         */
        getType() {
            return this.constructor;
        }
        serialize() {
            let serialization = {
                color: this.color.serialize(),
                intensity: this.intensity
            };
            return serialization;
        }
        async deserialize(_serialization) {
            await this.color.deserialize(_serialization.color);
            if (_serialization.intensity != undefined)
                this.intensity = _serialization.intensity;
            return this;
        }
        reduceMutator() { }
    }
    FudgeCore.Light = Light;
    /**
     * Ambient light, coming from all directions, illuminating everything with its color independent of position and orientation (like a foggy day or in the shades)
     * Attached to a node by {@link ComponentLight}, the pivot matrix is ignored.
     * ```text
     * ~ ~ ~
     *  ~ ~ ~
     * ```
     */
    class LightAmbient extends Light {
    }
    FudgeCore.LightAmbient = LightAmbient;
    /**
     * Directional light, illuminating everything from a specified direction with its color (like standing in bright sunlight)
     * Attached to a node by {@link ComponentLight}, the pivot matrix specifies the direction of the light only.
     * ```text
     * --->
     * --->
     * --->
     * ```
     */
    class LightDirectional extends Light {
    }
    FudgeCore.LightDirectional = LightDirectional;
    /**
     * Omnidirectional light emitting from its position, illuminating objects depending on their position and distance with its color (like a colored light bulb)
     * Attached to a node by {@link ComponentLight}, the pivot matrix specifies the position of the light, it's shape and rotation.
     * So with uneven scaling, other shapes than a perfect sphere, such as an oval or a disc, are possible, which creates a visible effect of the rotation too.
     * The intensity of the light drops linearly from 1 in the center to 0 at the perimeter of the shape.
     * ```text
     *         .\|/.
     *        -- o --
     *         ¬¥/|\`
     * ```
     */
    class LightPoint extends Light {
    }
    FudgeCore.LightPoint = LightPoint;
    /**
     * Spot light emitting within a specified angle from its position, illuminating objects depending on their position and distance with its color
     * Attached to a node by {@link ComponentLight}, the pivot matrix specifies the position of the light, the direction and the size and angles of the cone.
     * The intensity of the light drops linearly from 1 in the center to 0 at the outer limits of the cone.
     * ```text
     *          o
     *         /|\
     *        / | \
     * ```
     */
    class LightSpot extends Light {
    }
    FudgeCore.LightSpot = LightSpot;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../Light/Light.ts"/>
var FudgeCore;
///<reference path="../Light/Light.ts"/>
(function (FudgeCore) {
    /**
     * Defines identifiers for the various types of light this component can provide.
     */
    // export let LIGHT_TYPE: { [type: string]: string } = {
    let LIGHT_TYPE;
    (function (LIGHT_TYPE) {
        LIGHT_TYPE["AMBIENT"] = "LightAmbient";
        LIGHT_TYPE["DIRECTIONAL"] = "LightDirectional";
        LIGHT_TYPE["POINT"] = "LightPoint";
        LIGHT_TYPE["SPOT"] = "LightSpot";
    })(LIGHT_TYPE = FudgeCore.LIGHT_TYPE || (FudgeCore.LIGHT_TYPE = {}));
    /**
      * Attaches a {@link Light} to the node
      * The pivot matrix has different effects depending on the type of the {@link Light}. See there for details.
      * @authors Jirka Dell'Oro-Friedl, HFU, 2019
      */
    class ComponentLight extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentLight); }
        //TODO: since there is almost no functionality left in Light, eliminate it and put all in the component as with the camera...
        constructor(_light = new FudgeCore.LightAmbient()) {
            super();
            // private static constructors: { [type: string]: General } = { [LIGHT_TYPE.AMBIENT]: LightAmbient, [LIGHT_TYPE.DIRECTIONAL]: LightDirectional, [LIGHT_TYPE.POINT]: LightPoint, [LIGHT_TYPE.SPOT]: LightSpot };
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            this.light = null;
            this.singleton = false;
            this.light = _light;
        }
        // TODO: use TypeOfLight as return type?
        /**
         * Set the type of {@link Light} used by this component.
         */
        setType(_class) {
            let mtrOld = {};
            if (this.light)
                mtrOld = this.light.getMutator();
            this.light = new _class();
            this.light.mutate(mtrOld);
        }
        serialize() {
            let serialization = {
                pivot: this.mtxPivot.serialize(),
                light: FudgeCore.Serializer.serialize(this.light)
            };
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            await this.mtxPivot.deserialize(_serialization.pivot);
            this.light = await FudgeCore.Serializer.deserialize(_serialization.light);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.type = this.light.getType().name;
            return mutator;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.type)
                types.type = LIGHT_TYPE;
            return types;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            let type = _mutator.type;
            if (typeof (type) !== "undefined" && type != this.light.constructor.name)
                this.setType(FudgeCore.Serializer.getConstructor(type));
            delete (_mutator.type); // exclude light type from further mutation
            super.mutate(_mutator, _selection, _dispatchMutate);
            _mutator.type = type; // reconstruct mutator
        }
        drawGizmos() {
            let mtxShape = FudgeCore.Matrix4x4.PRODUCT(this.node.mtxWorld, this.mtxPivot);
            mtxShape.scaling = new FudgeCore.Vector3(0.5, 0.5, 0.5);
            FudgeCore.Gizmos.drawIcon(FudgeCore.TextureDefault.iconLight, mtxShape, this.light.color);
            FudgeCore.Recycler.store(mtxShape);
        }
        ;
        drawGizmosSelected() {
            let mtxShape = FudgeCore.Matrix4x4.PRODUCT(this.node.mtxWorld, this.mtxPivot);
            let color = FudgeCore.Color.CSS("yellow");
            switch (this.light.getType()) {
                case FudgeCore.LightDirectional:
                    const radius = 0.5;
                    FudgeCore.Gizmos.drawWireCircle(mtxShape, color);
                    const lines = new Array(10).fill(null).map(() => FudgeCore.Recycler.get(FudgeCore.Vector3));
                    lines[0].set(0, 0, 0);
                    lines[1].set(0, 0, 1);
                    lines[2].set(0, radius, 0);
                    lines[3].set(0, radius, 1);
                    lines[6].set(0, -radius, 0);
                    lines[7].set(0, -radius, 1);
                    lines[4].set(radius, 0, 0);
                    lines[5].set(radius, 0, 1);
                    lines[8].set(-radius, 0, 0);
                    lines[9].set(-radius, 0, 1);
                    FudgeCore.Gizmos.drawLines(lines, mtxShape, color);
                    FudgeCore.Recycler.storeMultiple(...lines);
                    break;
                case FudgeCore.LightPoint:
                    mtxShape.scale(new FudgeCore.Vector3(2, 2, 2));
                    FudgeCore.Gizmos.drawWireSphere(mtxShape, color);
                    break;
                case FudgeCore.LightSpot:
                    FudgeCore.Gizmos.drawWireCone(mtxShape, color);
                    break;
            }
            FudgeCore.Recycler.storeMultiple(mtxShape, color);
        }
    }
    FudgeCore.ComponentLight = ComponentLight;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a {@link Material} to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019 - 2021
     */
    let ComponentMaterial = (() => {
        let _classSuper = FudgeCore.Component;
        let _material_decorators;
        let _material_initializers = [];
        let _material_extraInitializers = [];
        return class ComponentMaterial extends _classSuper {
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _material_decorators = [FudgeCore.type(FudgeCore.Material)];
                __esDecorate(null, null, _material_decorators, { kind: "field", name: "material", static: false, private: false, access: { has: obj => "material" in obj, get: obj => obj.material, set: (obj, value) => { obj.material = value; } }, metadata: _metadata }, _material_initializers, _material_extraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentMaterial); }
            // public mutatorCoat: MutatorForComponent;
            constructor(_material = null) {
                super();
                this.clrPrimary = FudgeCore.Color.CSS("white");
                this.clrSecondary = FudgeCore.Color.CSS("white");
                this.mtxPivot = FudgeCore.Matrix3x3.IDENTITY();
                this.material = __runInitializers(this, _material_initializers, void 0);
                /** Support sorting of objects with transparency when rendering, render objects in the back first. When this component is used as a part of a {@link ParticleSystem}, try enabling this when disabling {@link ComponentParticleSystem.depthMask} */
                this.sortForAlpha = (__runInitializers(this, _material_extraInitializers), false); // TODO: maybe make this a property of the material?
                this.material = _material;
                // this.mutatorCoat = _material.getCoat().getMutatorForComponent();
            }
            //#region Transfer
            serialize() {
                let serialization = {
                    sortForAlpha: this.sortForAlpha,
                    clrPrimary: this.clrPrimary.serialize(),
                    clrSecondary: this.clrSecondary.serialize(),
                    pivot: this.mtxPivot.serialize(),
                    [super.constructor.name]: super.serialize(),
                    idMaterial: this.material.idResource
                };
                return serialization;
            }
            async deserialize(_serialization) {
                this.material = await FudgeCore.Project.getResource(_serialization.idMaterial);
                await this.clrPrimary.deserialize(_serialization.clrPrimary);
                await this.clrSecondary.deserialize(_serialization.clrSecondary);
                this.sortForAlpha = _serialization.sortForAlpha;
                await this.mtxPivot.deserialize(_serialization.pivot);
                await super.deserialize(_serialization[super.constructor.name]);
                return this;
            }
        };
    })();
    FudgeCore.ComponentMaterial = ComponentMaterial;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a {@link Mesh} to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ComponentMesh = (() => {
        let _classDecorators = [FudgeCore.enumerate];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Component;
        let _instanceExtraInitializers = [];
        let _mesh_decorators;
        let _mesh_initializers = [];
        let _mesh_extraInitializers = [];
        let _get_mtxPivot_decorators;
        var ComponentMesh = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _mesh_decorators = [FudgeCore.type(FudgeCore.Mesh)];
                _get_mtxPivot_decorators = [FudgeCore.enumerate];
                __esDecorate(this, null, _get_mtxPivot_decorators, { kind: "getter", name: "mtxPivot", static: false, private: false, access: { has: obj => "mtxPivot" in obj, get: obj => obj.mtxPivot }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(null, null, _mesh_decorators, { kind: "field", name: "mesh", static: false, private: false, access: { has: obj => "mesh" in obj, get: obj => obj.mesh, set: (obj, value) => { obj.mesh = value; } }, metadata: _metadata }, _mesh_initializers, _mesh_extraInitializers);
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                ComponentMesh = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentMesh); }
            #mtxPivot;
            constructor(_mesh, _skeleton) {
                super();
                this.mtxWorld = (__runInitializers(this, _instanceExtraInitializers), FudgeCore.Matrix4x4.IDENTITY());
                this.mesh = __runInitializers(this, _mesh_initializers, void 0);
                this.skeleton = __runInitializers(this, _mesh_extraInitializers);
                this.#mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
                this.mesh = _mesh;
                this.skeleton = _skeleton;
            }
            get mtxPivot() {
                return this.#mtxPivot;
            }
            set mtxPivot(_mtx) {
                this.#mtxPivot = _mtx;
                this.#mtxPivot.modified = true;
            }
            get radius() {
                let scaling = this.mtxWorld.scaling;
                let scale = Math.max(Math.abs(scaling.x), Math.abs(scaling.y), Math.abs(scaling.z));
                return this.mesh.radius * scale;
            }
            // /**
            //  * Calculates the position of a vertex transformed by the skeleton
            //  * @param _index index of the vertex
            //  */
            // public getVertexPosition(_index: number): Vector3 {
            //   // extract the vertex data (vertices: 3D vectors, bone indices & weights: 4D vectors)
            //   const iVertex: number = _index * 3;
            //   const iBoneInfluence: number = _index * 4;
            //   const vertex: Vector3 = new Vector3(...Reflect.get(this.mesh, "renderMesh").vertices.slice(iVertex, iVertex + 3));
            //   if (!(this.mesh instanceof MeshSkin)) return vertex;
            //   const iBones: Uint8Array = this.mesh.iBones.slice(iBoneInfluence, iBoneInfluence + 4);
            //   const weights: Float32Array = this.mesh.weights.slice(iBoneInfluence, iBoneInfluence + 4);
            //   // get bone matrices
            //   const mtxBones: Array<Matrix4x4> = this.skeleton.mtxBones;
            //   // skin matrix S = sum_i=1^m{w_i * B_i}
            //   const skinMatrix: Matrix4x4 = new Matrix4x4();
            //   skinMatrix.set(Array
            //     .from(iBones)
            //     .map((iBone, iWeight) => mtxBones[iBone].get().map(value => value * weights[iWeight])) // apply weight on each matrix
            //     .reduce((mtxSum, mtxBone) => mtxSum.map((value, index) => value + mtxBone[index])) // sum up the matrices
            //   );
            //   // transform vertex
            //   vertex.transform(skinMatrix);
            //   return vertex;
            // }
            // TODO: remove or think if the transformed bounding box is of value or can be made to be
            // public get boundingBox(): Box {
            //   let box: Box = Recycler.get(Box);
            //   box.set(
            //     Vector3.TRANSFORMATION(this.mesh.boundingBox.min, this.mtxWorld, true),
            //     Vector3.TRANSFORMATION(this.mesh.boundingBox.max, this.mtxWorld, true)
            //   );
            //   return box;
            // }
            //#region Transfer
            serialize() {
                let serialization;
                /* at this point of time, serialization as resource and as inline object is possible. TODO: check if inline becomes obsolete */
                let idMesh = this.mesh.idResource;
                if (idMesh)
                    serialization = { idMesh: idMesh };
                else
                    serialization = { mesh: FudgeCore.Serializer.serialize(this.mesh) };
                if (this.skeleton)
                    serialization.skeleton = FudgeCore.Node.PATH_FROM_TO(this, this.skeleton);
                serialization.pivot = this.mtxPivot.serialize();
                serialization[super.constructor.name] = super.serialize();
                return serialization;
            }
            async deserialize(_serialization) {
                let mesh;
                if (_serialization.idMesh)
                    mesh = await FudgeCore.Project.getResource(_serialization.idMesh);
                else
                    mesh = await FudgeCore.Serializer.deserialize(_serialization.mesh);
                this.mesh = mesh;
                if (_serialization.skeleton) {
                    const hndNodeDeserialized = () => {
                        const hndGraphDeserialized = () => {
                            this.skeleton = FudgeCore.Node.FIND(this, _serialization.skeleton);
                            this.node.removeEventListener("graphDeserialized" /* EVENT.GRAPH_DESERIALIZED */, hndGraphDeserialized, true);
                            this.removeEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
                        };
                        this.node.addEventListener("graphDeserialized" /* EVENT.GRAPH_DESERIALIZED */, hndGraphDeserialized, true);
                    };
                    this.addEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
                }
                await this.mtxPivot.deserialize(_serialization.pivot);
                await super.deserialize(_serialization[super.constructor.name]);
                return this;
            }
            //#endregion
            drawGizmosSelected() {
                if (!this.mesh)
                    return;
                let color = FudgeCore.Color.CSS("salmon");
                FudgeCore.Gizmos.drawWireMesh(this.mesh, this.mtxWorld, color, 0.1);
                FudgeCore.Recycler.store(color);
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return ComponentMesh = _classThis;
    })();
    FudgeCore.ComponentMesh = ComponentMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attached to a {@link Node} with an attached {@link ComponentCamera} this causes all nodes in {@link selection} to be drawn with a 1px outline.
     * @authors Jonas Plotzky, HFU, 2025
     */
    class ComponentOutline extends FudgeCore.Component {
        constructor(_selection = [], _color = new FudgeCore.Color(0, 0, 0, 1), _colorOccluded = new FudgeCore.Color(0, 0, 0, 0)) {
            super();
            this.selection = _selection;
            this.color = _color;
            this.colorOccluded = _colorOccluded;
        }
    }
    FudgeCore.ComponentOutline = ComponentOutline;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let PARTICLE_SYSTEM_PLAYMODE;
    (function (PARTICLE_SYSTEM_PLAYMODE) {
        /**Plays particle system in a loop: it restarts once it hit the end.*/
        PARTICLE_SYSTEM_PLAYMODE[PARTICLE_SYSTEM_PLAYMODE["LOOP"] = 0] = "LOOP";
        /**Plays particle system once and stops at the last point in time.*/
        PARTICLE_SYSTEM_PLAYMODE[PARTICLE_SYSTEM_PLAYMODE["PLAY_ONCE"] = 1] = "PLAY_ONCE";
    })(PARTICLE_SYSTEM_PLAYMODE = FudgeCore.PARTICLE_SYSTEM_PLAYMODE || (FudgeCore.PARTICLE_SYSTEM_PLAYMODE = {}));
    /**
     * Attaches a {@link ParticleSystem} to the node.
     * Works in conjunction with {@link ComponentMesh} and {@link ComponentMaterial} to create a shader particle system.
     * Additionally a {@link ComponentFaceCamera} can be attached to make the particles face the camera.
     * @author Jonas Plotzky, HFU, 2022
     */
    let ComponentParticleSystem = (() => {
        var _a, _b;
        let _classDecorators = [FudgeCore.enumerate];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Component;
        let _instanceExtraInitializers = [];
        let _particleSystem_decorators;
        let _particleSystem_initializers = [];
        let _particleSystem_extraInitializers = [];
        let _get_size_decorators;
        let _useRenderData_decorators;
        let _deleteRenderData_decorators;
        var ComponentParticleSystem = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _particleSystem_decorators = [FudgeCore.type(FudgeCore.ParticleSystem)];
                _get_size_decorators = [FudgeCore.enumerate];
                _useRenderData_decorators = [(_a = FudgeCore.RenderInjectorComponentParticleSystem).decorate.bind(_a)];
                _deleteRenderData_decorators = [(_b = FudgeCore.RenderInjectorComponentParticleSystem).decorate.bind(_b)];
                __esDecorate(this, null, _get_size_decorators, { kind: "getter", name: "size", static: false, private: false, access: { has: obj => "size" in obj, get: obj => obj.size }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(this, null, _useRenderData_decorators, { kind: "method", name: "useRenderData", static: false, private: false, access: { has: obj => "useRenderData" in obj, get: obj => obj.useRenderData }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(this, null, _deleteRenderData_decorators, { kind: "method", name: "deleteRenderData", static: false, private: false, access: { has: obj => "deleteRenderData" in obj, get: obj => obj.deleteRenderData }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(null, null, _particleSystem_decorators, { kind: "field", name: "particleSystem", static: false, private: false, access: { has: obj => "particleSystem" in obj, get: obj => obj.particleSystem, set: (obj, value) => { obj.particleSystem = value; } }, metadata: _metadata }, _particleSystem_initializers, _particleSystem_extraInitializers);
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                ComponentParticleSystem = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentParticleSystem); }
            /** The number of particles */
            #size;
            #timeScale;
            #time;
            constructor(_particleSystem = null) {
                super();
                this.particleSystem = (__runInitializers(this, _instanceExtraInitializers), __runInitializers(this, _particleSystem_initializers, void 0));
                /** When disabled try enabling {@link ComponentMaterial.sortForAlpha} */
                this.depthMask = __runInitializers(this, _particleSystem_extraInitializers);
                this.#timeScale = 1;
                //#endregion
                this.hndEvent = (_event) => {
                    switch (_event.type) {
                        case "nodeDeserialized" /* EVENT.NODE_DESERIALIZED */:
                        case "componentAdd" /* EVENT.COMPONENT_ADD */:
                            FudgeCore.Time.game.addEventListener("timeScaled" /* EVENT.TIME_SCALED */, this.updateTimeScale);
                            this.node.addEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.update);
                            break;
                        case "componentRemove" /* EVENT.COMPONENT_REMOVE */:
                            FudgeCore.Time.game.removeEventListener("timeScaled" /* EVENT.TIME_SCALED */, this.updateTimeScale);
                            this.node.removeEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.update);
                    }
                };
                this.update = () => {
                    if (this.time > this.duration)
                        switch (this.playMode) {
                            default:
                            case PARTICLE_SYSTEM_PLAYMODE.LOOP:
                                this.time = 0;
                                break;
                            case PARTICLE_SYSTEM_PLAYMODE.PLAY_ONCE:
                                this.time = this.duration;
                                this.timeScale = 0;
                                break;
                        }
                };
                this.updateTimeScale = () => {
                    let timeScale = this.#timeScale * FudgeCore.Time.game.getScale();
                    this.#time.setScale(timeScale);
                };
                this.particleSystem = _particleSystem;
                this.depthMask = true;
                this.blendMode = FudgeCore.BLEND.ADDITIVE;
                this.playMode = PARTICLE_SYSTEM_PLAYMODE.LOOP;
                this.duration = 1000;
                this.size = 10;
                this.#time = new FudgeCore.Time();
                this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.hndEvent);
                this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.hndEvent);
                this.addEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, this.hndEvent);
            }
            /**
             * Get the number of particles
             */
            get size() {
                return this.#size;
            }
            /**
             * Set the number of particles. Caution: Setting this will reinitialize the random numbers array(texture) used in the shader.
             */
            set size(_size) {
                this.#size = _size;
                this.deleteRenderData();
            }
            get time() {
                return this.#time.get();
            }
            set time(_time) {
                this.#time.set(_time);
            }
            get timeScale() {
                return this.#timeScale;
            }
            set timeScale(_scale) {
                this.#timeScale = _scale;
                this.updateTimeScale();
            }
            /**
             * Generates and binds the random numbers texture in WebGL
             * Injected by {@link RenderInjectorComponentParticleSystem}. Used by the render system.
             * @internal
             */
            useRenderData() { }
            /**
             * Deletes the random numbers texture in WebGL freeing the allocated gpu memory.
             * Injected by {@link RenderInjectorComponentParticleSystem}.
             * @internal
             */
            deleteRenderData() { }
            //#region transfer
            serialize() {
                let serialization = {
                    [super.constructor.name]: super.serialize(),
                    idParticleSystem: this.particleSystem?.idResource,
                    depthMask: this.depthMask,
                    blendMode: this.blendMode,
                    playMode: this.playMode,
                    duration: this.duration,
                    size: this.size
                };
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization[super.constructor.name]);
                if (_serialization.idParticleSystem)
                    this.particleSystem = await FudgeCore.Project.getResource(_serialization.idParticleSystem);
                this.depthMask = _serialization.depthMask;
                this.blendMode = _serialization.blendMode;
                this.playMode = _serialization.playMode;
                this.duration = _serialization.duration;
                this.size = _serialization.size;
                return this;
            }
            getMutatorForAnimation() {
                let mutator = this.getMutator();
                delete mutator.particleSystem;
                delete mutator.size;
                return mutator;
            }
            getMutatorAttributeTypes(_mutator) {
                let types = super.getMutatorAttributeTypes(_mutator);
                if (types.blendMode)
                    types.blendMode = FudgeCore.BLEND;
                if (types.playMode)
                    types.playMode = PARTICLE_SYSTEM_PLAYMODE;
                return types;
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return ComponentParticleSystem = _classThis;
    })();
    FudgeCore.ComponentParticleSystem = ComponentParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let PICK;
    (function (PICK) {
        PICK["RADIUS"] = "radius";
        PICK["CAMERA"] = "camera";
        PICK["PHYSICS"] = "physics";
    })(PICK = FudgeCore.PICK || (FudgeCore.PICK = {}));
    /**
     * Attaches picking functionality to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class ComponentPick extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.pick = PICK.RADIUS;
        }
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentPick); }
        /**
         * Picks the node according to the given {@link Ray} and invokes events accordingly
         */
        pickAndDispatch(_ray, _event) {
            let cmpMesh = this.node.getComponent(FudgeCore.ComponentMesh);
            let position = cmpMesh ? cmpMesh.mtxWorld.translation : this.node.mtxWorld.translation;
            switch (this.pick) {
                case PICK.RADIUS:
                    // TODO: should only be node.radius. Adjustment needed, if mesh was transformed...
                    if (_ray.getDistance(position).magnitude < this.node.radius) {
                        this.node.dispatchEvent(_event);
                    }
                    break;
                case PICK.PHYSICS:
                    let hitInfo = FudgeCore.Physics.raycast(_ray.origin, _ray.direction, FudgeCore.Vector3.DIFFERENCE(position, _ray.origin).magnitudeSquared);
                    if (hitInfo.hit)
                        this.node.dispatchEvent(_event);
                    break;
                //TODO: PICK.CAMERA
            }
        }
        serialize() {
            return this.getMutator();
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.pick)
                types.pick = PICK;
            return types;
        }
        drawGizmosSelected(_cmpCamera) {
            if (this.pick != PICK.RADIUS)
                return;
            let translation = (this.node.getComponent(FudgeCore.ComponentMesh)?.mtxWorld ?? this.node.mtxWorld).translation;
            let color = FudgeCore.Color.CSS("white", 0.5);
            let scaling = FudgeCore.Recycler.get(FudgeCore.Vector3).set(this.node.radius * 2, this.node.radius * 2, this.node.radius * 2);
            let mtxWorld = FudgeCore.Matrix4x4.COMPOSITION(translation, undefined, scaling);
            FudgeCore.Gizmos.drawSphere(mtxWorld, color);
            FudgeCore.Recycler.storeMultiple(mtxWorld, scaling, color);
        }
    }
    FudgeCore.ComponentPick = ComponentPick;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for scripts the user writes
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Component
     */
    class ComponentScript extends FudgeCore.Component {
        // registering this doesn't make sense, only its subclasses. Or this component must refer to scripts to be attached to this component
        // TODO: rethink & refactor
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentScript); }
        constructor() {
            super();
            this.singleton = false;
        }
        serialize() {
            return this.getMutator(true);
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
    }
    FudgeCore.ComponentScript = ComponentScript;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a {@link TextureText} to the node.
     * Works in conjunction with {@link ComponentMesh} and {@link ComponentMaterial} to create a text node.
     * A 'textured' {@link Material} (e.g. {@link ShaderLitTextured}) must be used to display the text properly. Ideally a {@link MeshQuad} should be used to render the text onto.
     * Additionally a {@link ComponentFaceCamera} can be attached to make the text face the camera.
     * @authors Jonas Plotzky, HFU, 2024
     */
    class ComponentText extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentText); }
        constructor(_text, _font) {
            super();
            this.texture = new FudgeCore.TextureText(ComponentText.name, _text, _font);
            this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
            this.fixedSize = false;
        }
        serialize() {
            return this.getMutator();
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        useRenderData(_mtxMeshToWorld, _cmpCamera) {
            this.texture.useRenderData(FudgeCore.TEXTURE_LOCATION.COLOR.UNIT);
            this.mtxWorld.copy(_mtxMeshToWorld);
            let scaling = FudgeCore.Recycler.get(FudgeCore.Vector3);
            if (this.fixedSize) {
                let scale = _cmpCamera.getWorldToPixelScale(_mtxMeshToWorld.translation);
                this.mtxWorld.scaling = scaling.set(this.texture.width * scale, this.texture.height * scale, 1);
                ;
            }
            else {
                let pixelsToUnits = 1 / this.texture.height;
                scaling.set(this.texture.width * pixelsToUnits, this.texture.height * pixelsToUnits, 1);
                this.mtxWorld.scale(scaling);
            }
            FudgeCore.Recycler.store(scaling);
            return this.mtxWorld;
        }
        drawGizmosSelected() {
            let mesh = this.node.getComponent(FudgeCore.ComponentMesh)?.mesh;
            let cmpMaterial = this.node.getComponent(FudgeCore.ComponentMaterial);
            if (mesh == null || cmpMaterial == null)
                return;
            FudgeCore.Gizmos.drawWireMesh(mesh, this.mtxWorld, cmpMaterial.clrPrimary);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.texture.name;
        }
    }
    FudgeCore.ComponentText = ComponentText;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let BASE;
    (function (BASE) {
        BASE[BASE["SELF"] = 0] = "SELF";
        BASE[BASE["PARENT"] = 1] = "PARENT";
        BASE[BASE["WORLD"] = 2] = "WORLD";
        BASE[BASE["NODE"] = 3] = "NODE";
    })(BASE = FudgeCore.BASE || (FudgeCore.BASE = {}));
    /**
     * Attaches a transform-{@link Matrix4x4} to the node, moving, scaling and rotating it in space relative to its parent.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentTransform extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentTransform); }
        constructor(_mtxInit = FudgeCore.Matrix4x4.IDENTITY()) {
            super();
            this.mtxLocal = _mtxInit;
        }
        //#region Transformations respecting the hierarchy
        /**
         * recalculates this local matrix to yield the identical world matrix based on the given node.
         * Use rebase before appending the container of this component to another node while preserving its transformation in the world.
         */
        rebase(_node = null) {
            let mtxResult = this.mtxLocal;
            let container = this.node;
            if (container)
                mtxResult = container.mtxWorld;
            if (_node)
                mtxResult = FudgeCore.Matrix4x4.RELATIVE(mtxResult, null, _node.mtxWorldInverse);
            this.mtxLocal = mtxResult;
        }
        /**
         * Applies the given transformation relative to the selected base (SELF, PARENT, WORLD) or a particular other node (NODE)
         */
        transform(_mtxTransform, _base = BASE.SELF, _node = null) {
            switch (_base) {
                case BASE.SELF:
                    this.mtxLocal.multiply(_mtxTransform);
                    break;
                case BASE.PARENT:
                    this.mtxLocal.multiply(_mtxTransform, true);
                    break;
                case BASE.NODE:
                    if (!_node)
                        throw new Error("BASE.NODE requires a node given as base");
                case BASE.WORLD:
                    this.rebase(_node);
                    this.mtxLocal.multiply(_mtxTransform, true);
                    let node = this.node;
                    if (node) {
                        let mtxTemp;
                        if (_base == BASE.NODE) {
                            // fix mtxWorld of container for subsequent rebasing 
                            mtxTemp = FudgeCore.Matrix4x4.PRODUCT(_node.mtxWorld, node.mtxLocal);
                            node.mtxWorld.copy(mtxTemp);
                            FudgeCore.Recycler.store(mtxTemp);
                        }
                        let parent = node.getParent();
                        if (parent) {
                            // fix mtxLocal for current parent
                            this.rebase(node.getParent());
                            mtxTemp = FudgeCore.Matrix4x4.PRODUCT(node.getParent().mtxWorld, node.mtxLocal);
                            node.mtxWorld.copy(mtxTemp);
                            FudgeCore.Recycler.store(mtxTemp);
                        }
                    }
                    break;
            }
        }
        //#endregion
        //#region Transfer
        serialize() {
            let serialization = {
                local: this.mtxLocal.serialize(),
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            await this.mtxLocal.deserialize(_serialization.local);
            return this;
        }
        // public mutate(_mutator: Mutator): void {
        //     this.local.mutate(_mutator);
        // }
        // public getMutator(): Mutator { 
        //     return this.local.getMutator();
        // }
        // public getMutatorAttributeTypes(_mutator: Mutator): MutatorAttributeTypes {
        //     let types: MutatorAttributeTypes = this.local.getMutatorAttributeTypes(_mutator);
        //     return types;
        // }
        reduceMutator(_mutator) {
            delete _mutator.world;
            super.reduceMutator(_mutator);
        }
    }
    FudgeCore.ComponentTransform = ComponentTransform;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Describes a VR Controller and its capabilities.
     */
    class VRController {
        constructor() {
            this.cmpTransform = null;
            this.gamePad = null;
            this.thumbstickX = null;
            this.thumbstickY = null;
        }
    }
    FudgeCore.VRController = VRController;
    /**
     * VR Component Class, for Session Management, Controller Management and Reference Space Management.
     * @author Valentin Schmidberger, HFU, 2022
     */
    class ComponentVRDevice extends FudgeCore.ComponentCamera {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentVRDevice); }
        #mtxLocal;
        constructor() {
            super();
            this.rightCntrl = new VRController();
            this.leftCntrl = new VRController();
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.getMtxLocalFromCmpTransform);
        }
        /**
         * Returns the actual matrix of the vr - device.
         * Creators should use this for readonly purposes.
         */
        get mtxLocal() {
            return this.#mtxLocal;
        }
        /**
         * Sets a Vector3 as Position of the reference space.
         */
        set translation(_translation) {
            let translation = _translation.clone;
            translation.subtract(this.#mtxLocal.translation);
            translation.negate();
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(translation));
            this.#mtxLocal.translation = _translation;
            FudgeCore.Recycler.store(translation);
        }
        /**
         * Sets Vector3 Rotation of the reference space.
         */
        set rotation(_rotation) {
            let rotation = _rotation.clone;
            rotation.subtract(this.#mtxLocal.rotation);
            rotation.negate();
            let orientation = new FudgeCore.Quaternion();
            orientation.eulerAngles = rotation;
            // Rotation needs to be set in the Origin (0,0,0), otherwise the XR-Rig gets rotated around the origin. 
            // set xr - rig back to origin
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.DIFFERENCE(this.#mtxLocal.translation, FudgeCore.Vector3.ZERO())));
            // rotate xr rig in origin
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.ZERO(), orientation));
            // set xr - rig back to last position 
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.DIFFERENCE(FudgeCore.Vector3.ZERO(), this.#mtxLocal.translation)));
            this.#mtxLocal.rotation = _rotation;
            FudgeCore.Recycler.store(rotation);
        }
        /**
         * Adds a Vector3 in Position of the reference space.
         */
        translate(_by) {
            let translation = _by.clone;
            translation.transform(this.#mtxLocal.quaternion);
            translation.negate();
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(translation));
            this.#mtxLocal.translate(_by);
            FudgeCore.Recycler.store(translation);
        }
        /**
         * Adds a Vector3 in Rotation of the reference space.
         */
        rotate(_by) {
            let rotation = _by.clone.negate();
            let orientation = new FudgeCore.Quaternion();
            orientation.eulerAngles = rotation;
            // Rotation needs to be added in the Origin (0,0,0), otherwise the XR-Rig gets rotated around the origin. 
            // set xr - rig back to origin
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.DIFFERENCE(this.#mtxLocal.translation, FudgeCore.Vector3.ZERO())));
            // rotate xr rig in origin
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.ZERO(), orientation));
            // set xr - rig back to last position 
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.DIFFERENCE(FudgeCore.Vector3.ZERO(), this.#mtxLocal.translation)));
            this.#mtxLocal.rotate(_by);
            FudgeCore.Recycler.store(rotation);
        }
        getMtxLocalFromCmpTransform() {
            this.#mtxLocal = this.node.mtxLocal;
        }
    }
    FudgeCore.ComponentVRDevice = ComponentVRDevice;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Processes input signals of type number and generates an output signal of the same type using
     * proportional, integral or differential mapping, an amplification factor and a linear dampening/delay
     * ```text
     *         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     *         ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      pass through (Proportional)      ‚îÇ
     * Input ‚Üí ‚îÇ ‚Üí ‚îÇamplify‚îÇ ‚Üí ‚îÇdelay‚îÇ ‚Üí ‚öü sum up over time (Integral) ‚öû ‚Üí ‚îÇ ‚Üí Output
     *         ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      pass change  (Differential)      ‚îÇ
     *         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     */
    class Control extends EventTarget {
        constructor(_name, _factor = 1, _type = 0 /* CONTROL_TYPE.PROPORTIONAL */, _delay = 0) {
            super();
            this.rateDispatchOutput = 0;
            this.valuePrevious = 0;
            this.outputBase = 0;
            this.outputTarget = 0;
            this.outputPrevious = 0;
            this.outputTargetPrevious = 0;
            this.factor = 0;
            this.time = FudgeCore.Time.game;
            this.timeValueDelay = 0;
            this.timeOutputTargetSet = 0;
            this.idTimer = undefined;
            this.dispatchOutput = (_eventOrValue) => {
                if (!this.active)
                    return;
                let timer = this.time.getTimer(this.idTimer);
                let output;
                if (typeof (_eventOrValue) == "number")
                    output = _eventOrValue;
                else
                    output = this.calculateOutput();
                let outputChanged = (output != this.outputPrevious);
                if (timer) {
                    timer.active = outputChanged;
                    if (!outputChanged)
                        return;
                }
                this.outputPrevious = output;
                let event = new CustomEvent("output" /* EVENT_CONTROL.OUTPUT */, {
                    detail: {
                        output: output
                    }
                });
                this.dispatchEvent(event);
            };
            this.factor = _factor;
            this.type = _type;
            this.active = true;
            this.name = _name;
            this.setDelay(_delay);
        }
        /**
         * Set the time-object to be used when calculating the output in {@link CONTROL_TYPE.INTEGRAL}
         */
        setTimebase(_time) {
            this.time = _time;
            this.calculateOutput();
        }
        /**
         * Feed an input value into this control and fire the events {@link EVENT_CONTROL.INPUT} and {@link EVENT_CONTROL.OUTPUT}
         */
        setInput(_input) {
            if (!this.active)
                return;
            this.outputBase = this.calculateOutput();
            this.valuePrevious = this.getValueDelayed();
            this.outputTarget = this.factor * _input;
            this.timeOutputTargetSet = this.time.get();
            if (this.type == 2 /* CONTROL_TYPE.DIFFERENTIAL */) {
                this.valuePrevious = this.outputTarget - this.outputTargetPrevious;
                this.outputTargetPrevious = this.outputTarget;
                this.outputTarget = 0;
            }
            this.dispatchEvent(new Event("input" /* EVENT_CONTROL.INPUT */));
            if (this.type == 2 /* CONTROL_TYPE.DIFFERENTIAL */)
                this.dispatchOutput(this.valuePrevious);
            else
                this.dispatchOutput(null);
        }
        /**
         * TODO: describe!
         */
        pulse(_input) {
            this.setInput(_input);
            this.setInput(0);
        }
        /**
         * Set the time to take for the internal linear dampening until the final ouput value is reached
         */
        setDelay(_time) {
            this.timeValueDelay = Math.max(0, _time);
        }
        /**
         * Set the number of output-events to dispatch per second.
         * At the default of 0, the control output must be polled and will only actively dispatched once each time input occurs and the output changes.
         */
        setRateDispatchOutput(_rateDispatchOutput = 0) {
            this.rateDispatchOutput = _rateDispatchOutput;
            this.time.deleteTimer(this.idTimer);
            this.idTimer = undefined;
            if (this.rateDispatchOutput)
                this.idTimer = this.time.setTimer(1000 / this.rateDispatchOutput, 0, this.dispatchOutput);
        }
        /**
         * Set the factor to multiply the input value given with {@link setInput} with
         */
        setFactor(_factor) {
            this.factor = _factor;
        }
        /**
         * Get the value from the output of this control
         */
        getOutput() {
            return this.calculateOutput();
        }
        /**
         * Calculates the output of this control
         */
        calculateOutput() {
            let output = 0;
            let value = this.getValueDelayed();
            switch (this.type) {
                case 1 /* CONTROL_TYPE.INTEGRAL */:
                    let timeCurrent = this.time.get();
                    let timeElapsedSinceInput = timeCurrent - this.timeOutputTargetSet;
                    output = this.outputBase;
                    if (this.timeValueDelay > 0) {
                        if (timeElapsedSinceInput < this.timeValueDelay) {
                            output += 0.5 * (this.valuePrevious + value) * timeElapsedSinceInput;
                            break;
                        }
                        else {
                            output += 0.5 * (this.valuePrevious + value) * this.timeValueDelay;
                            timeElapsedSinceInput -= this.timeValueDelay;
                        }
                    }
                    output += value * timeElapsedSinceInput;
                    // value += 0.5 * (this.inputPrevious - input) * this.timeInputDelay + input * timeElapsedSinceInput;
                    break;
                case 2 /* CONTROL_TYPE.DIFFERENTIAL */:
                case 0 /* CONTROL_TYPE.PROPORTIONAL */:
                default:
                    output = value;
                    break;
            }
            return output;
        }
        /**
         * calculates the output considering the time of the delay
         */
        getValueDelayed() {
            if (this.timeValueDelay > 0) {
                let timeElapsedSinceInput = this.time.get() - this.timeOutputTargetSet;
                if (timeElapsedSinceInput < this.timeValueDelay)
                    return this.valuePrevious + (this.outputTarget - this.valuePrevious) * timeElapsedSinceInput / this.timeValueDelay;
            }
            return this.outputTarget;
        }
    }
    FudgeCore.Control = Control;
})(FudgeCore || (FudgeCore = {}));
///<reference path="Control.ts"/>
var FudgeCore;
///<reference path="Control.ts"/>
(function (FudgeCore) {
    /**
     * Handles multiple controls as inputs and creates an output from that.
     * As a subclass of {@link Control}, axis calculates the ouput summing up the inputs and processing the result using its own settings.
     * Dispatches {@link EVENT_CONTROL.OUTPUT} and {@link EVENT_CONTROL.INPUT} when one of the controls dispatches them.
     * ```text
     *           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                 ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ\                                ‚îÇ
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò \                               ‚îÇ
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  \‚îå‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ---‚îÇsum‚îÇ ‚Üí ‚îÇinternal control ‚îÇ ‚Üí ‚îÇ ‚Üí Output
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  /‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê /                               ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ/                                ‚îÇ
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
     *           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     */
    class Axis extends FudgeCore.Control {
        constructor() {
            super(...arguments);
            this.controls = new Map();
            this.sumPrevious = 0;
            this.hndOutputEvent = (_event) => {
                if (!this.active)
                    return;
                let control = _event.target;
                let event = new CustomEvent("output" /* EVENT_CONTROL.OUTPUT */, {
                    detail: {
                        control: control,
                        input: _event.detail.output,
                        output: this.getOutput()
                    }
                });
                this.dispatchEvent(event);
            };
            this.hndInputEvent = (_event) => {
                if (!this.active)
                    return;
                let event = new Event("input" /* EVENT_CONTROL.INPUT */, _event);
                this.dispatchEvent(event);
            };
        }
        /**
         * Add the control given to the list of controls feeding into this axis
         */
        addControl(_control) {
            this.controls.set(_control.name, _control);
            _control.addEventListener("input" /* EVENT_CONTROL.INPUT */, this.hndInputEvent);
            _control.addEventListener("output" /* EVENT_CONTROL.OUTPUT */, this.hndOutputEvent);
        }
        /**
         * Returns the control with the given name
         */
        getControl(_name) {
            return this.controls.get(_name);
        }
        /**
         * Removes the control with the given name
         */
        removeControl(_name) {
            let control = this.getControl(_name);
            if (control) {
                control.removeEventListener("input" /* EVENT_CONTROL.INPUT */, this.hndInputEvent);
                control.removeEventListener("output" /* EVENT_CONTROL.OUTPUT */, this.hndOutputEvent);
                this.controls.delete(_name);
            }
        }
        /**
         * Returns the value of this axis after summing up all inputs and processing the sum according to the axis' settings
         */
        getOutput() {
            let sumInput = 0;
            for (let control of this.controls) {
                if (control[1].active)
                    sumInput += control[1].getOutput();
            }
            if (sumInput != this.sumPrevious)
                super.setInput(sumInput);
            this.sumPrevious = sumInput;
            return super.getOutput();
        }
    }
    FudgeCore.Axis = Axis;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Collects the keys pressed on the keyboard and stores their status.
     */
    class Keyboard {
        static { this.keysPressed = Keyboard.initialize(); }
        // private static code_en: Object;
        /**
         * Returns true if one of the given keys is is currently being pressed.
         */
        static isPressedOne(_keys) {
            for (let code of _keys) {
                if (Keyboard.keysPressed[code])
                    return true;
            }
            return false;
        }
        /**
         * Returns true if all of the given keys are currently being pressed
         */
        static isPressedCombo(_keys) {
            for (let code of _keys) {
                if (!Keyboard.keysPressed[code])
                    return false;
            }
            return true;
        }
        /**
         * Returns the value given as _active if one or, when _combo is true, all of the given keys are pressed.
         * Returns the value given as _inactive if not.
         */
        static mapToValue(_active, _inactive, _keys, _combo = false) {
            if (!_combo && Keyboard.isPressedOne(_keys))
                return _active;
            if (Keyboard.isPressedCombo(_keys))
                return _active;
            return _inactive;
        }
        /**
         * Returns a balanced ternary value (either -1, 0 or 1)
         * according to the match of the keys currently being pressed and the lists of keys given
         */
        static mapToTrit(_positive, _negative) {
            return Keyboard.mapToValue(-1, 0, _negative) + Keyboard.mapToValue(1, 0, _positive);
        }
        // public static locale(_keyboard: Object): void {
        //   if (!Keyboard.code_en) {
        //     // save original keyboard codes to be able to switch back later
        //     Keyboard.code_en = {};
        //     Object.assign(Keyboard.code_en, KEYBOARD_CODE);
        //   }
        //   for (let key in _keyboard) {
        //     let value: string = Reflect.get(_keyboard, key);
        //     for (let original in KEYBOARD_CODE)
        //       if (Reflect.get(KEYBOARD_CODE, original) == value)
        //         // remove original key the yields the value
        //         Reflect.deleteProperty(KEYBOARD_CODE, original);
        //     // add new key to yield that value
        //     Reflect.set(KEYBOARD_CODE, key, value);
        //   }
        // }
        static initialize() {
            let store = {};
            document.addEventListener("keydown", Keyboard.hndKeyInteraction);
            document.addEventListener("keyup", Keyboard.hndKeyInteraction);
            return store;
        }
        static hndKeyInteraction(_event) {
            Keyboard.keysPressed[_event.code] = (_event.type == "keydown");
        }
    }
    FudgeCore.Keyboard = Keyboard;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the alert box
     */
    class DebugAlert extends FudgeCore.DebugTarget {
        static { this.delegates = {
            [FudgeCore.DEBUG_FILTER.INFO]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
            [FudgeCore.DEBUG_FILTER.LOG]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
            [FudgeCore.DEBUG_FILTER.WARN]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
            [FudgeCore.DEBUG_FILTER.ERROR]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE]),
            [FudgeCore.DEBUG_FILTER.SOURCE]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE])
        }; }
        /**
         * Returns a delegate-function expecting a message to log.
         */
        static createDelegate(_headline) {
            let delegate = function (_message, ..._args) {
                let args = _args.map(_arg => _arg.toString());
                let out = _headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, args);
                alert(out);
            };
            return delegate;
        }
    }
    FudgeCore.DebugAlert = DebugAlert;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to a HTMLDialogElement
     */
    class DebugDialog extends FudgeCore.DebugTarget {
    }
    FudgeCore.DebugDialog = DebugDialog;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Route to an HTMLTextArea, may be obsolete when using HTMLDialogElement
     */
    class DebugTextArea extends FudgeCore.DebugTarget {
        static { this.textArea = document.createElement("textarea"); }
        static { this.autoScroll = true; }
        static { this.delegates = {
            [FudgeCore.DEBUG_FILTER.INFO]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
            [FudgeCore.DEBUG_FILTER.LOG]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
            [FudgeCore.DEBUG_FILTER.WARN]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
            [FudgeCore.DEBUG_FILTER.ERROR]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE]),
            [FudgeCore.DEBUG_FILTER.CLEAR]: DebugTextArea.clear,
            [FudgeCore.DEBUG_FILTER.GROUP]: DebugTextArea.group,
            [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: DebugTextArea.group,
            [FudgeCore.DEBUG_FILTER.GROUPEND]: DebugTextArea.groupEnd,
            [FudgeCore.DEBUG_FILTER.SOURCE]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE])
        }; }
        static { this.groups = []; }
        /**
         * Clears the text area and the groups
         */
        static clear() {
            DebugTextArea.textArea.textContent = "";
            DebugTextArea.groups = [];
        }
        /**
         * Begins a new group with the given name
         */
        static group(_name) {
            DebugTextArea.print("‚ñº " + _name);
            DebugTextArea.groups.push(_name);
        }
        /**
         * Ends the last group
         */
        static groupEnd() {
            DebugTextArea.groups.pop();
        }
        /**
         * Returns a delegate-function expecting a message to log.
         */
        static createDelegate(_headline) {
            let delegate = function (_message, ..._args) {
                DebugTextArea.print(_headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, _args));
            };
            return delegate;
        }
        static getIndentation(_level) {
            let result = "";
            for (let i = 0; i < _level; i++)
                result += "| ";
            return result;
        }
        static print(_text) {
            DebugTextArea.textArea.textContent += DebugTextArea.getIndentation(DebugTextArea.groups.length) + _text + "\n";
            if (DebugTextArea.autoScroll)
                DebugTextArea.textArea.scrollTop = DebugTextArea.textArea.scrollHeight;
        }
    }
    FudgeCore.DebugTextArea = DebugTextArea;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The codes sent from a standard english keyboard layout
     */
    let KEYBOARD_CODE;
    (function (KEYBOARD_CODE) {
        KEYBOARD_CODE["A"] = "KeyA";
        KEYBOARD_CODE["B"] = "KeyB";
        KEYBOARD_CODE["C"] = "KeyC";
        KEYBOARD_CODE["D"] = "KeyD";
        KEYBOARD_CODE["E"] = "KeyE";
        KEYBOARD_CODE["F"] = "KeyF";
        KEYBOARD_CODE["G"] = "KeyG";
        KEYBOARD_CODE["H"] = "KeyH";
        KEYBOARD_CODE["I"] = "KeyI";
        KEYBOARD_CODE["J"] = "KeyJ";
        KEYBOARD_CODE["K"] = "KeyK";
        KEYBOARD_CODE["L"] = "KeyL";
        KEYBOARD_CODE["M"] = "KeyM";
        KEYBOARD_CODE["N"] = "KeyN";
        KEYBOARD_CODE["O"] = "KeyO";
        KEYBOARD_CODE["P"] = "KeyP";
        KEYBOARD_CODE["Q"] = "KeyQ";
        KEYBOARD_CODE["R"] = "KeyR";
        KEYBOARD_CODE["S"] = "KeyS";
        KEYBOARD_CODE["T"] = "KeyT";
        KEYBOARD_CODE["U"] = "KeyU";
        KEYBOARD_CODE["V"] = "KeyV";
        KEYBOARD_CODE["W"] = "KeyW";
        KEYBOARD_CODE["X"] = "KeyX";
        KEYBOARD_CODE["Y"] = "KeyY";
        KEYBOARD_CODE["Z"] = "KeyZ";
        KEYBOARD_CODE["ESC"] = "Escape";
        KEYBOARD_CODE["ZERO"] = "Digit0";
        KEYBOARD_CODE["ONE"] = "Digit1";
        KEYBOARD_CODE["TWO"] = "Digit2";
        KEYBOARD_CODE["THREE"] = "Digit3";
        KEYBOARD_CODE["FOUR"] = "Digit4";
        KEYBOARD_CODE["FIVE"] = "Digit5";
        KEYBOARD_CODE["SIX"] = "Digit6";
        KEYBOARD_CODE["SEVEN"] = "Digit7";
        KEYBOARD_CODE["EIGHT"] = "Digit8";
        KEYBOARD_CODE["NINE"] = "Digit9";
        KEYBOARD_CODE["MINUS"] = "Minus";
        KEYBOARD_CODE["EQUAL"] = "Equal";
        KEYBOARD_CODE["BACKSPACE"] = "Backspace";
        KEYBOARD_CODE["TABULATOR"] = "Tab";
        KEYBOARD_CODE["BRACKET_LEFT"] = "BracketLeft";
        KEYBOARD_CODE["BRACKET_RIGHT"] = "BracketRight";
        KEYBOARD_CODE["ENTER"] = "Enter";
        KEYBOARD_CODE["CTRL_LEFT"] = "ControlLeft";
        KEYBOARD_CODE["SEMICOLON"] = "Semicolon";
        KEYBOARD_CODE["QUOTE"] = "Quote";
        KEYBOARD_CODE["BACK_QUOTE"] = "Backquote";
        KEYBOARD_CODE["SHIFT_LEFT"] = "ShiftLeft";
        KEYBOARD_CODE["BACKSLASH"] = "Backslash";
        KEYBOARD_CODE["COMMA"] = "Comma";
        KEYBOARD_CODE["PERIOD"] = "Period";
        KEYBOARD_CODE["SLASH"] = "Slash";
        KEYBOARD_CODE["SHIFT_RIGHT"] = "ShiftRight";
        KEYBOARD_CODE["NUMPAD_MULTIPLY"] = "NumpadMultiply";
        KEYBOARD_CODE["ALT_LEFT"] = "AltLeft";
        KEYBOARD_CODE["SPACE"] = "Space";
        KEYBOARD_CODE["CAPS_LOCK"] = "CapsLock";
        KEYBOARD_CODE["F1"] = "F1";
        KEYBOARD_CODE["F2"] = "F2";
        KEYBOARD_CODE["F3"] = "F3";
        KEYBOARD_CODE["F4"] = "F4";
        KEYBOARD_CODE["F5"] = "F5";
        KEYBOARD_CODE["F6"] = "F6";
        KEYBOARD_CODE["F7"] = "F7";
        KEYBOARD_CODE["F8"] = "F8";
        KEYBOARD_CODE["F9"] = "F9";
        KEYBOARD_CODE["F10"] = "F10";
        KEYBOARD_CODE["PAUSE"] = "Pause";
        KEYBOARD_CODE["SCROLL_LOCK"] = "ScrollLock";
        KEYBOARD_CODE["NUMPAD7"] = "Numpad7";
        KEYBOARD_CODE["NUMPAD8"] = "Numpad8";
        KEYBOARD_CODE["NUMPAD9"] = "Numpad9";
        KEYBOARD_CODE["NUMPAD_SUBTRACT"] = "NumpadSubtract";
        KEYBOARD_CODE["NUMPAD4"] = "Numpad4";
        KEYBOARD_CODE["NUMPAD5"] = "Numpad5";
        KEYBOARD_CODE["NUMPAD6"] = "Numpad6";
        KEYBOARD_CODE["NUMPAD_ADD"] = "NumpadAdd";
        KEYBOARD_CODE["NUMPAD1"] = "Numpad1";
        KEYBOARD_CODE["NUMPAD2"] = "Numpad2";
        KEYBOARD_CODE["NUMPAD3"] = "Numpad3";
        KEYBOARD_CODE["NUMPAD0"] = "Numpad0";
        KEYBOARD_CODE["NUMPAD_DECIMAL"] = "NumpadDecimal";
        KEYBOARD_CODE["PRINT_SCREEN"] = "PrintScreen";
        KEYBOARD_CODE["INTL_BACK_SLASH"] = "IntlBackSlash";
        KEYBOARD_CODE["F11"] = "F11";
        KEYBOARD_CODE["F12"] = "F12";
        KEYBOARD_CODE["NUMPAD_EQUAL"] = "NumpadEqual";
        KEYBOARD_CODE["F13"] = "F13";
        KEYBOARD_CODE["F14"] = "F14";
        KEYBOARD_CODE["F15"] = "F15";
        KEYBOARD_CODE["F16"] = "F16";
        KEYBOARD_CODE["F17"] = "F17";
        KEYBOARD_CODE["F18"] = "F18";
        KEYBOARD_CODE["F19"] = "F19";
        KEYBOARD_CODE["F20"] = "F20";
        KEYBOARD_CODE["F21"] = "F21";
        KEYBOARD_CODE["F22"] = "F22";
        KEYBOARD_CODE["F23"] = "F23";
        KEYBOARD_CODE["F24"] = "F24";
        KEYBOARD_CODE["KANA_MODE"] = "KanaMode";
        KEYBOARD_CODE["LANG2"] = "Lang2";
        KEYBOARD_CODE["LANG1"] = "Lang1";
        KEYBOARD_CODE["INTL_RO"] = "IntlRo";
        KEYBOARD_CODE["CONVERT"] = "Convert";
        KEYBOARD_CODE["NON_CONVERT"] = "NonConvert";
        KEYBOARD_CODE["INTL_YEN"] = "IntlYen";
        KEYBOARD_CODE["NUMPAD_COMMA"] = "NumpadComma";
        KEYBOARD_CODE["UNDO"] = "Undo";
        KEYBOARD_CODE["PASTE"] = "Paste";
        KEYBOARD_CODE["MEDIA_TRACK_PREVIOUS"] = "MediaTrackPrevious";
        KEYBOARD_CODE["CUT"] = "Cut";
        KEYBOARD_CODE["COPY"] = "Copy";
        KEYBOARD_CODE["MEDIA_TRACK_NEXT"] = "MediaTrackNext";
        KEYBOARD_CODE["NUMPAD_ENTER"] = "NumpadEnter";
        KEYBOARD_CODE["CTRL_RIGHT"] = "ControlRight";
        KEYBOARD_CODE["AUDIO_VOLUME_MUTE"] = "AudioVolumeMute";
        KEYBOARD_CODE["LAUNCH_APP2"] = "LaunchApp2";
        KEYBOARD_CODE["MEDIA_PLAY_PAUSE"] = "MediaPlayPause";
        KEYBOARD_CODE["MEDIA_STOP"] = "MediaStop";
        KEYBOARD_CODE["EJECT"] = "Eject";
        KEYBOARD_CODE["AUDIO_VOLUME_DOWN"] = "AudioVolumeDown";
        KEYBOARD_CODE["VOLUME_DOWN"] = "VolumeDown";
        KEYBOARD_CODE["AUDIO_VOLUME_UP"] = "AudioVolumeUp";
        KEYBOARD_CODE["VOLUME_UP"] = "VolumeUp";
        KEYBOARD_CODE["BROWSER_HOME"] = "BrowserHome";
        KEYBOARD_CODE["NUMPAD_DIVIDE"] = "NumpadDivide";
        KEYBOARD_CODE["ALT_RIGHT"] = "AltRight";
        KEYBOARD_CODE["HELP"] = "Help";
        KEYBOARD_CODE["NUM_LOCK"] = "NumLock";
        KEYBOARD_CODE["HOME"] = "Home";
        KEYBOARD_CODE["ARROW_UP"] = "ArrowUp";
        KEYBOARD_CODE["ARROW_RIGHT"] = "ArrowRight";
        KEYBOARD_CODE["ARROW_DOWN"] = "ArrowDown";
        KEYBOARD_CODE["ARROW_LEFT"] = "ArrowLeft";
        KEYBOARD_CODE["END"] = "End";
        KEYBOARD_CODE["PAGE_UP"] = "PageUp";
        KEYBOARD_CODE["PAGE_DOWN"] = "PageDown";
        KEYBOARD_CODE["INSERT"] = "Insert";
        KEYBOARD_CODE["DELETE"] = "Delete";
        KEYBOARD_CODE["META_LEFT"] = "Meta_Left";
        KEYBOARD_CODE["OS_LEFT"] = "OSLeft";
        KEYBOARD_CODE["META_RIGHT"] = "MetaRight";
        KEYBOARD_CODE["OS_RIGHT"] = "OSRight";
        KEYBOARD_CODE["CONTEXT_MENU"] = "ContextMenu";
        KEYBOARD_CODE["POWER"] = "Power";
        KEYBOARD_CODE["BROWSER_SEARCH"] = "BrowserSearch";
        KEYBOARD_CODE["BROWSER_FAVORITES"] = "BrowserFavorites";
        KEYBOARD_CODE["BROWSER_REFRESH"] = "BrowserRefresh";
        KEYBOARD_CODE["BROWSER_STOP"] = "BrowserStop";
        KEYBOARD_CODE["BROWSER_FORWARD"] = "BrowserForward";
        KEYBOARD_CODE["BROWSER_BACK"] = "BrowserBack";
        KEYBOARD_CODE["LAUNCH_APP1"] = "LaunchApp1";
        KEYBOARD_CODE["LAUNCH_MAIL"] = "LaunchMail";
        KEYBOARD_CODE["LAUNCH_MEDIA_PLAYER"] = "LaunchMediaPlayer";
        //mac brings this buttton
        KEYBOARD_CODE["FN"] = "Fn";
        //Linux brings these
        KEYBOARD_CODE["AGAIN"] = "Again";
        KEYBOARD_CODE["PROPS"] = "Props";
        KEYBOARD_CODE["SELECT"] = "Select";
        KEYBOARD_CODE["OPEN"] = "Open";
        KEYBOARD_CODE["FIND"] = "Find";
        KEYBOARD_CODE["WAKE_UP"] = "WakeUp";
        KEYBOARD_CODE["NUMPAD_PARENT_LEFT"] = "NumpadParentLeft";
        KEYBOARD_CODE["NUMPAD_PARENT_RIGHT"] = "NumpadParentRight";
        //android
        KEYBOARD_CODE["SLEEP"] = "Sleep";
    })(KEYBOARD_CODE = FudgeCore.KEYBOARD_CODE || (FudgeCore.KEYBOARD_CODE = {}));
    let KEYBOARD_CODE_DE;
    (function (KEYBOARD_CODE_DE) {
        KEYBOARD_CODE_DE["Z"] = "KeyY";
        KEYBOARD_CODE_DE["Y"] = "KeyZ";
        KEYBOARD_CODE_DE["\u00D6"] = "Semicolon";
        KEYBOARD_CODE_DE["\u00C4"] = "Quote";
        KEYBOARD_CODE_DE["\u00DC"] = "BracketLeft";
        KEYBOARD_CODE_DE["HASH"] = "Backslash";
        KEYBOARD_CODE_DE["PLUS"] = "BracketRight";
        // eslint-disable-next-line 
        KEYBOARD_CODE_DE["\u00DF"] = "Minus";
        KEYBOARD_CODE_DE["ACUTE"] = "Equal";
        KEYBOARD_CODE_DE["LESS_THAN"] = "IntlBackSlash";
        KEYBOARD_CODE_DE["MINUS"] = "Slash";
    })(KEYBOARD_CODE_DE = FudgeCore.KEYBOARD_CODE_DE || (FudgeCore.KEYBOARD_CODE_DE = {}));
    /*
    Firefox can't make use of those buttons and Combinations:
    SINGELE_BUTTONS:
     Druck,
    COMBINATIONS:
     Shift + F10, Shift + Numpad5,
     CTRL + q, CTRL + F4,
     ALT + F1, ALT + F2, ALT + F3, ALT + F7, ALT + F8, ALT + F10
    Opera won't do good with these Buttons and combinations:
    SINGLE_BUTTONS:
     Float32Array, F11, ALT,
    COMBINATIONS:
     CTRL + q, CTRL + t, CTRL + h, CTRL + g, CTRL + n, CTRL + f
     ALT + F1, ALT + F2, ALT + F4, ALT + F5, ALT + F6, ALT + F7, ALT + F8, ALT + F10
     */
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * An event that represents a call from a {@link Timer}
     */
    class EventTimer {
        constructor(_timer, ..._arguments) {
            this.type = "\u0192lapse" /* EVENT_TIMER.CALL */;
            this.firstCall = true;
            this.lastCall = false;
            this.target = _timer;
            this.arguments = _arguments;
            this.firstCall = true;
        }
    }
    FudgeCore.EventTimer = EventTimer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Custom touch events
     */
    let EVENT_TOUCH;
    (function (EVENT_TOUCH) {
        /** custom event fired in addition to the standard touchmove, details offset to starting touch */
        EVENT_TOUCH["MOVE"] = "touchMove";
        /** custom event fired when the touches haven't moved outside of the tap radius */
        EVENT_TOUCH["TAP"] = "touchTap";
        /** custom event fired when the touches have moved outside of the notch radius, details offset and cardinal direction */
        EVENT_TOUCH["NOTCH"] = "touchNotch";
        /** custom event fired when the touches haven't moved outside of the tap radius for some time */
        EVENT_TOUCH["LONG"] = "touchLong";
        /** custom event fired when two taps were detected in short succession */
        EVENT_TOUCH["DOUBLE"] = "touchDouble";
        /** custom event fired when the distance between the only two touches changes beyond a tolerance */
        EVENT_TOUCH["PINCH"] = "touchPinch";
        /** custom event not implemented yet */
        EVENT_TOUCH["ROTATE"] = "touchRotate";
    })(EVENT_TOUCH = FudgeCore.EVENT_TOUCH || (FudgeCore.EVENT_TOUCH = {}));
    /**
     * Dispatches CustomTouchEvents to the EventTarget given with the constructor.
     * When using touch events, make sure to set `touch-action: none` in CSS
     * @author Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class TouchEventDispatcher {
        constructor(_target, _radiusTap = 5, _radiusNotch = 50, _timeDouble = 200, _timerLong = 1000) {
            this.posStart = FudgeCore.Vector2.ZERO();
            this.posNotch = FudgeCore.Vector2.ZERO();
            this.posPrev = FudgeCore.Vector2.ZERO();
            this.moved = false;
            this.time = new FudgeCore.Time();
            this.pinchDistance = 0;
            this.pinchTolerance = 1;
            this.hndEvent = (_event) => {
                _event.preventDefault();
                let touchFirst = _event.touches[0];
                let position = this.calcAveragePosition(_event.touches); //new Vector2(touchFirst?.clientX, touchFirst?.clientY);
                let offset;
                switch (_event.type) {
                    case "touchstart":
                        this.moved = false;
                        this.startGesture(position);
                        if (_event.touches.length == 2) {
                            // reset pinch
                            let pinch = new FudgeCore.Vector2(_event.touches[1].clientX - touchFirst.clientX, _event.touches[1].clientY - touchFirst.clientY);
                            this.pinchDistance = pinch.magnitude;
                        }
                        let dispatchLong = (_eventTimer) => {
                            this.moved = true;
                            this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.LONG, {
                                bubbles: true, detail: { position: position, touches: _event.touches }
                            }));
                        };
                        this.timerLong?.clear();
                        this.timerLong = new FudgeCore.Timer(this.time, this.timeLong, 1, dispatchLong);
                        break;
                    case "touchend":
                        this.timerLong?.clear();
                        if (_event.touches.length > 0) {
                            // still touches active
                            this.startGesture(position);
                            break;
                        }
                        let dispatchTap = (_eventTimer) => {
                            this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.TAP, {
                                bubbles: true, detail: { position: position, touches: _event.touches }
                            }));
                        };
                        // check if there was a tap before and timer is still running -> double tap
                        if (this.timerDouble?.active) {
                            this.timerDouble.clear();
                            // this.timer = undefined;
                            this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.DOUBLE, {
                                bubbles: true, detail: { position: position, touches: _event.touches }
                            }));
                        }
                        else if (!this.moved)
                            // check if there was movement, otherwise set timer to fire tap
                            this.timerDouble = new FudgeCore.Timer(this.time, this.timeDouble, 1, dispatchTap);
                        break;
                    case "touchmove":
                        this.detectPinch(_event, position);
                        offset = FudgeCore.Vector2.DIFFERENCE(this.posPrev, this.posStart);
                        this.moved ||= (offset.magnitude < this.radiusTap); // remember that touch moved over tap radius
                        let movement = FudgeCore.Vector2.DIFFERENCE(position, this.posPrev);
                        this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.MOVE, {
                            bubbles: true, detail: { position: position, touches: _event.touches, offset: offset, movement: movement }
                        }));
                        // fire notch when touches moved out of notch radius and reset notch
                        offset = FudgeCore.Vector2.DIFFERENCE(position, this.posNotch);
                        if (offset.magnitude > this.radiusNotch) {
                            let cardinal = Math.abs(offset.x) > Math.abs(offset.y) ?
                                FudgeCore.Vector2.X(offset.x < 0 ? -1 : 1) :
                                FudgeCore.Vector2.Y(offset.y < 0 ? -1 : 1);
                            this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.NOTCH, {
                                bubbles: true, detail: { position: position, touches: _event.touches, offset: offset, cardinal: cardinal, movement: movement }
                            }));
                            this.posNotch = position;
                        }
                        //TODO: pinch, rotate...
                        break;
                    default:
                        break;
                }
                this.posPrev.set(position.x, position.y);
            };
            this.detectPinch = (_event, _position) => {
                if (_event.touches.length != 2)
                    return;
                let t = _event.touches;
                let pinch = new FudgeCore.Vector2(t[1].clientX - t[0].clientX, t[1].clientY - t[0].clientY);
                let pinchDistance = pinch.magnitude;
                let pinchDelta = pinchDistance - this.pinchDistance;
                if (Math.abs(pinchDelta) > this.pinchTolerance)
                    this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.PINCH, {
                        bubbles: true, detail: { position: _position, touches: _event.touches, pinch: pinch, pinchDelta: pinchDelta }
                    }));
                this.pinchDistance = pinchDistance;
            };
            this.target = _target;
            this.radiusTap = _radiusTap;
            this.radiusNotch = _radiusNotch;
            this.timeDouble = _timeDouble;
            this.timeLong = _timerLong;
            this.activate(true);
        }
        /**
         * De-/Activates the dispatch of CustomTouchEvents
         */
        activate(_on) {
            if (_on) {
                this.target.addEventListener("touchstart", this.hndEvent);
                this.target.addEventListener("touchend", this.hndEvent);
                this.target.addEventListener("touchmove", this.hndEvent);
                return;
            }
            this.target.removeEventListener("touchstart", this.hndEvent);
            this.target.removeEventListener("touchend", this.hndEvent);
            this.target.removeEventListener("touchmove", this.hndEvent);
        }
        startGesture(_position) {
            this.posNotch.set(_position.x, _position.y);
            this.posStart.set(_position.x, _position.y);
        }
        calcAveragePosition(_touches) {
            let average = FudgeCore.Vector2.ZERO();
            for (let touch of _touches) {
                average.x += touch.clientX;
                average.y += touch.clientY;
            }
            average.scale(1 / _touches.length);
            return average;
        }
    }
    FudgeCore.TouchEventDispatcher = TouchEventDispatcher;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A node managed by {@link Project} that functions as a template for {@link GraphInstance}s
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Resource
     */
    let Graph = (() => {
        var _a;
        let _classDecorators = [(_a = FudgeCore.SerializableResource).register.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Node;
        var Graph = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                Graph = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(_classThis, _classExtraInitializers);
            }
            // #syncing: boolean = false;
            constructor(_name = "Graph") {
                super(_name);
                this.idResource = undefined;
                this.hndMutate = async (_event) => {
                    // TODO: if path contains a graph instance below this, don't dispatch!
                    // let path: Node[] = Reflect.get(_event, "path");
                    // for (let node of path)
                    //   if (node instanceof GraphInstance && node.idSource != this.idResource)
                    //     return;
                    // console.log("Graph mutates", this.name);
                    // this.#syncing = true;
                    _event.detail.path = Reflect.get(_event, "path"); // save path to target in detail
                    this.dispatchEvent(new CustomEvent("mutateGraph" /* EVENT.MUTATE_GRAPH */, { detail: _event.detail }));
                    this.dispatchEvent(new CustomEvent("graphMutated" /* EVENT.GRAPH_MUTATED */, { detail: _event.detail }));
                    // this.dispatchEvent(new Event(EVENT.MUTATE_INSTANCE));
                    // this.#syncing = false;
                };
                this.addEventListener("mutate" /* EVENT.MUTATE */, this.hndMutate);
            }
            get type() {
                return this.constructor.name;
            }
            serialize() {
                let serialization = super.serialize();
                serialization.idResource = this.idResource;
                serialization.type = this.type;
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization);
                FudgeCore.Project.register(this, _serialization.idResource);
                await FudgeCore.Project.resyncGraphInstances(this);
                this.broadcastEvent(new Event("graphDeserialized" /* EVENT.GRAPH_DESERIALIZED */));
                FudgeCore.Debug.log("Deserialized", this.name);
                return this;
            }
        };
        return Graph = _classThis;
    })();
    FudgeCore.Graph = Graph;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Graph} loaded from a glTF-File.
     * @authors Jonas Plotzky, HFU, 2024
     */
    class GraphGLTF extends FudgeCore.mixinSerializableResourceExternal(FudgeCore.Graph) {
        async load(_url = this.url, _name = this.name) {
            this.url = _url;
            this.name = _name;
            return FudgeCore.GLTFLoader.loadResource(this);
        }
        serialize() {
            const serializationExternal = super.serialize();
            const serializationNode = FudgeCore.Node.prototype.serialize.call(this); // this is wasteful as we only need the components deserialized
            delete serializationNode.components[FudgeCore.ComponentSkeleton.name];
            delete serializationNode.children;
            return { ...serializationNode, ...serializationExternal };
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            await FudgeCore.Graph.prototype.deserialize.call(this, _serialization);
            return this;
        }
    }
    FudgeCore.GraphGLTF = GraphGLTF;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // enum SYNC {
    //   READY, GRAPH_SYNCED, GRAPH_DONE, INSTANCE
    // }
    /**
     * An instance of a {@link Graph}.
     * This node keeps a reference to its resource an can thus optimize serialization
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Resource
     */
    class GraphInstance extends FudgeCore.Node {
        /** id of the resource that instance was created from */
        // TODO: examine, if this should be a direct reference to the Graph, instead of the id
        static { this.count = 0; }
        #idSource;
        // #sync: SYNC = SYNC.READY;
        #deserializeFromSource;
        /**
         * This constructor alone will not create a reconstruction, but only save the id.
         * To create an instance of the graph, call reset on this or set with a graph as parameter.
         * Prefer Project.createGraphInstance(_graph).
         */
        constructor(_graph) {
            super("GraphInstance");
            this.#idSource = undefined;
            // #sync: SYNC = SYNC.READY;
            this.#deserializeFromSource = true;
            /**
             * Source graph mutated, reflect mutation in this instance
             */
            this.hndMutationGraph = async (_event) => {
                if (this.isFiltered())
                    return;
                await this.reflectMutation(_event, _event.currentTarget, this, _event.detail.path);
                this.dispatchEvent(new Event("mutateGraphDone" /* EVENT.MUTATE_INSTANCE */, { bubbles: true }));
            };
            /**
             * This instance mutated, reflect mutation in source graph
             */
            this.hndMutationInstance = async (_event) => {
                if (this.isFiltered())
                    return;
                await this.reflectMutation(_event, this, this.get(), Reflect.get(_event, "path"));
                this.get().dispatchEvent(new CustomEvent("mutate" /* EVENT.MUTATE */, { detail: _event.detail }));
            };
            this.addEventListener("mutate" /* EVENT.MUTATE */, this.hndMutationInstance);
            if (!_graph)
                return;
            this.#idSource = _graph.idResource;
        }
        get idSource() {
            return this.#idSource;
        }
        /**
         * Recreate this node from the {@link Graph} referenced
         */
        async reset() {
            let resource = await FudgeCore.Project.getResource(this.#idSource);
            await this.set(resource);
        }
        //TODO: optimize using the referenced Graph, serialize/deserialize only the differences
        serialize() {
            let filter = this.getComponent(FudgeCore.ComponentGraphFilter);
            let serialization = {};
            if (filter && filter.isActive) { // if graph synchronisation is unfiltered, knowing the source is sufficient for serialization
                serialization = super.serialize();
                let graph = this.get();
                if (graph instanceof FudgeCore.GraphGLTF) { // like for the GraphGLTF: children and components loaded from gltf must never be serialized
                    delete serialization.components[FudgeCore.ComponentSkeleton.name];
                    delete serialization.children;
                    serialization.url = graph.url;
                }
            }
            else {
                serialization.deserializeFromSource = true;
            }
            serialization.idSource = this.#idSource;
            return serialization;
        }
        async deserialize(_serialization) {
            this.#idSource = _serialization.idSource ?? _serialization.idResource;
            if (!_serialization.deserializeFromSource) {
                let graph = await FudgeCore.Project.getResource(this.#idSource);
                if (graph instanceof FudgeCore.GraphGLTF)
                    await FudgeCore.GLTFLoader.loadResource(this, _serialization.url);
                await super.deserialize(_serialization); // instance is deserialized from individual data
                this.#deserializeFromSource = false;
            }
            let graph = this.get();
            if (graph)
                await this.connectToGraph(); // otherwise just connect
            else {
                FudgeCore.Debug.log("Register for resync", _serialization.name, this.name);
                FudgeCore.Project.registerGraphInstanceForResync(this);
            }
            return this;
        }
        /**
         * Connects this graph instance to the graph referenced.
         */
        async connectToGraph() {
            let graph = this.get();
            if (this.#deserializeFromSource)
                await this.set(graph);
        }
        /**
         * Set this node to be a recreation of the {@link Graph} given
         */
        async set(_graph) {
            this.#idSource = _graph.idResource;
            let currentGraph = this.get();
            if (currentGraph) {
                currentGraph.removeEventListener("mutateGraph" /* EVENT.MUTATE_GRAPH */, this.hndMutationGraph);
            }
            // TODO: examine, if the serialization should be stored in the Graph for optimization <- also useful for sync with instances
            let serialization = FudgeCore.Serializer.serialize(_graph);
            for (let path in serialization) {
                await this.deserialize(serialization[path]);
                break;
            }
            FudgeCore.Debug.fudge("GraphInstance set to " + this.name + " | " + "Instance count: " + GraphInstance.count++);
            _graph.addEventListener("mutateGraph" /* EVENT.MUTATE_GRAPH */, this.hndMutationGraph);
            this.broadcastEvent(new Event("graphInstantiated" /* EVENT.GRAPH_INSTANTIATED */));
        }
        /**
         * Retrieve the graph this instances refers to
         */
        get() {
            return FudgeCore.Project.resources[this.#idSource];
        }
        // reflect mutation from a source graph or instance to a destination instance or graph
        async reflectMutation(_event, _source, _destination, _path) {
            for (let node of _path) // iterate up the event path, which may contain regular Nodes or GraphInstances
                if (node instanceof GraphInstance) // until this GraphInstance is found (or no GraphInstance...)
                    if (node == this)
                        break;
                    else {
                        console.log("Sync aborted, target already synced");
                        return;
                    }
            // find the corresponding node in the destination hierarchy
            let index = _path.indexOf(_source);
            for (let i = index - 1; i >= 0; i--) {
                let childIndex = _path[i].getParent().findChild(_path[i]); // get the index of the childnode in the original path
                _destination = _destination.getChild(childIndex); // get the corresponding child in this path
                // TODO: respect index for non-singleton components...
            }
            // mutate the corresponding component in the destination
            let cmpMutate = _destination.getComponent(_event.detail.component.constructor);
            if (cmpMutate)
                await cmpMutate.mutate(_event.detail.mutator, null, false);
        }
        isFiltered() {
            let cmpFilter = this.getComponent(FudgeCore.ComponentGraphFilter);
            return (cmpFilter && cmpFilter.isActive);
        }
    }
    FudgeCore.GraphInstance = GraphInstance;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Holds data to feed into a {@link Shader} to describe the surface of {@link Mesh}.
     * {@link Material}s reference {@link Coat} and {@link Shader}.
     * The method useRenderData will be injected by {@link RenderInjector} at runtime, extending the functionality of this class to deal with the renderer.
     */
    let Coat = (() => {
        var _a, _b, _c, _d;
        let _classSuper = FudgeCore.Mutable;
        let _staticExtraInitializers = [];
        let _static_resetRenderData_decorators;
        let _static_updateRenderbuffer_decorators;
        let _static_updateRenderData_decorators;
        let _static_useRenderData_decorators;
        return class Coat extends _classSuper {
            constructor() {
                super(...arguments);
                // public name: string = "Coat";
                /**
                 * Clipping threshold for alpha values, every pixel with alpha < alphaClip will be discarded.
                 */
                this.alphaClip = 0.01;
                //#endregion
            }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _static_resetRenderData_decorators = [(_a = FudgeCore.RenderManagerCoat).decorate.bind(_a)];
                _static_updateRenderbuffer_decorators = [(_b = FudgeCore.RenderManagerCoat).decorate.bind(_b)];
                _static_updateRenderData_decorators = [(_c = FudgeCore.RenderManagerCoat).decorate.bind(_c)];
                _static_useRenderData_decorators = [(_d = FudgeCore.RenderManagerCoat).decorate.bind(_d)];
                __esDecorate(this, null, _static_resetRenderData_decorators, { kind: "method", name: "resetRenderData", static: true, private: false, access: { has: obj => "resetRenderData" in obj, get: obj => obj.resetRenderData }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(this, null, _static_updateRenderbuffer_decorators, { kind: "method", name: "updateRenderbuffer", static: true, private: false, access: { has: obj => "updateRenderbuffer" in obj, get: obj => obj.updateRenderbuffer }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(this, null, _static_updateRenderData_decorators, { kind: "method", name: "updateRenderData", static: true, private: false, access: { has: obj => "updateRenderData" in obj, get: obj => obj.updateRenderData }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(this, null, _static_useRenderData_decorators, { kind: "method", name: "useRenderData", static: true, private: false, access: { has: obj => "useRenderData" in obj, get: obj => obj.useRenderData }, metadata: _metadata }, null, _staticExtraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(this, _staticExtraInitializers);
            }
            /** @internal reroute to {@link RenderManagerCoat.resetRenderData} */
            static resetRenderData() { }
            ;
            /** @internal reroute to {@link RenderManagerCoat.updateRenderbuffer} */
            static updateRenderbuffer() { }
            ;
            /** @internal reroute to {@link RenderManagerCoat.updateRenderData} */
            static updateRenderData(_coat) { }
            ;
            /** @internal reroute to {@link RenderManagerCoat.useRenderData} */
            static useRenderData(_coat) { }
            ;
            /** @internal reroute to {@link RenderManagerCoat.updateRenderData} */
            updateRenderData() { Coat.updateRenderData(this); }
            ;
            /** @internal reroute to {@link RenderManagerCoat.useRenderData} */
            useRenderData() { Coat.useRenderData(this); }
            ;
            //#region Transfer
            serialize() {
                return {
                    alphaClip: this.alphaClip
                };
            }
            async deserialize(_serialization) {
                if (_serialization.alphaClip !== undefined)
                    this.alphaClip = _serialization.alphaClip;
                return this;
            }
            reduceMutator(_mutator) {
                delete _mutator.renderData;
            }
        };
    })();
    FudgeCore.Coat = Coat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The simplest {@link Coat} providing just a color
     */
    class CoatColored extends FudgeCore.Coat {
        constructor(_color = new FudgeCore.Color()) {
            super();
            this.color = _color;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.color = this.color.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            await this.color.deserialize(_serialization.color);
            return this;
        }
    }
    FudgeCore.CoatColored = CoatColored;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a color and parameters for the phong shading model.
     */
    class CoatRemissive extends FudgeCore.CoatColored {
        #metallic;
        constructor(_color = new FudgeCore.Color(), _diffuse = 1, _specular = 0.5, _intensity = 0.7, _metallic = 0.0) {
            super(_color);
            this.diffuse = _diffuse;
            this.specular = _specular;
            this.intensity = _intensity;
            this.metallic = _metallic;
        }
        get metallic() {
            return this.#metallic;
        }
        set metallic(_value) {
            this.#metallic = FudgeCore.Calc.clamp(_value, 0, 1);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.diffuse = this.diffuse;
            serialization.specular = this.specular;
            serialization.intensity = this.intensity;
            serialization.metallic = this.metallic;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.diffuse = _serialization.diffuse;
            this.specular = _serialization.specular;
            this.intensity = _serialization.intensity ?? this.intensity;
            this.metallic = _serialization.metallic ?? this.metallic;
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            delete mutator.diffuse;
            delete mutator.specular;
            delete mutator.intensity;
            mutator.diffuse = this.diffuse;
            mutator.specular = this.specular;
            mutator.intensity = this.intensity;
            mutator.metallic = this.metallic;
            return mutator;
        }
    }
    FudgeCore.CoatRemissive = CoatRemissive;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a texture and additional data for texturing
     */
    let CoatTextured = (() => {
        let _classSuper = FudgeCore.CoatColored;
        let _texture_decorators;
        let _texture_initializers = [];
        let _texture_extraInitializers = [];
        return class CoatTextured extends _classSuper {
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _texture_decorators = [FudgeCore.type(FudgeCore.Texture)];
                __esDecorate(null, null, _texture_decorators, { kind: "field", name: "texture", static: false, private: false, access: { has: obj => "texture" in obj, get: obj => obj.texture, set: (obj, value) => { obj.texture = value; } }, metadata: _metadata }, _texture_initializers, _texture_extraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            constructor(_color = new FudgeCore.Color(), _texture = FudgeCore.TextureDefault.color) {
                super(_color);
                this.texture = __runInitializers(this, _texture_initializers, void 0);
                __runInitializers(this, _texture_extraInitializers);
                this.texture = _texture;
            }
            //#region Transfer
            serialize() {
                let serialization = super.serialize();
                serialization.idTexture = this.texture.idResource;
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization);
                if (_serialization.idTexture)
                    this.texture = await FudgeCore.Project.getResource(_serialization.idTexture);
                return this;
            }
        };
    })();
    FudgeCore.CoatTextured = CoatTextured;
})(FudgeCore || (FudgeCore = {}));
///<reference path="CoatTextured.ts"/>
var FudgeCore;
///<reference path="CoatTextured.ts"/>
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a texture and additional data for texturing
     */
    class CoatRemissiveTextured extends FudgeCore.CoatTextured {
        #metallic;
        constructor(_color = new FudgeCore.Color(), _texture = FudgeCore.TextureDefault.color, _diffuse = 1, _specular = 0.5, _intensity = 0.7, _metallic = 0.0) {
            super(_color, _texture);
            this.diffuse = _diffuse;
            this.specular = _specular;
            this.intensity = _intensity;
            this.metallic = _metallic;
        }
        get metallic() {
            return this.#metallic;
        }
        set metallic(_value) {
            this.#metallic = FudgeCore.Calc.clamp(_value, 0, 1);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.diffuse = this.diffuse;
            serialization.specular = this.specular;
            serialization.intensity = this.intensity;
            serialization.metallic = this.metallic;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.diffuse = _serialization.diffuse;
            this.specular = _serialization.specular;
            this.intensity = _serialization.intensity ?? this.intensity;
            this.metallic = _serialization.metallic ?? this.metallic;
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            delete mutator.diffuse;
            delete mutator.specular;
            delete mutator.intensity;
            mutator.diffuse = this.diffuse;
            mutator.specular = this.specular;
            mutator.intensity = this.intensity;
            mutator.metallic = this.metallic;
            return mutator;
        }
    }
    FudgeCore.CoatRemissiveTextured = CoatRemissiveTextured;
})(FudgeCore || (FudgeCore = {}));
///<reference path="CoatTextured.ts"/>
var FudgeCore;
///<reference path="CoatTextured.ts"/>
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a texture and additional data for texturing
     */
    let CoatRemissiveTexturedNormals = (() => {
        let _classSuper = FudgeCore.CoatRemissiveTextured;
        let _normalMap_decorators;
        let _normalMap_initializers = [];
        let _normalMap_extraInitializers = [];
        return class CoatRemissiveTexturedNormals extends _classSuper {
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _normalMap_decorators = [FudgeCore.type(FudgeCore.Texture)];
                __esDecorate(null, null, _normalMap_decorators, { kind: "field", name: "normalMap", static: false, private: false, access: { has: obj => "normalMap" in obj, get: obj => obj.normalMap, set: (obj, value) => { obj.normalMap = value; } }, metadata: _metadata }, _normalMap_initializers, _normalMap_extraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            constructor(_color = new FudgeCore.Color(), _texture = FudgeCore.TextureDefault.color, _normalMap = FudgeCore.TextureDefault.normal, _diffuse, _specular = undefined, _intensity = undefined, _metallic = undefined) {
                super(_color, _texture, _diffuse, _specular, _intensity, _metallic);
                this.normalMap = __runInitializers(this, _normalMap_initializers, void 0);
                __runInitializers(this, _normalMap_extraInitializers);
                this.normalMap = _normalMap;
            }
            //#region Transfer
            serialize() {
                let serialization = super.serialize();
                serialization.idNormalMap = this.normalMap.idResource;
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization);
                if (_serialization.idNormalMap)
                    this.normalMap = await FudgeCore.Project.getResource(_serialization.idNormalMap);
                return this;
            }
        };
    })();
    FudgeCore.CoatRemissiveTexturedNormals = CoatRemissiveTexturedNormals;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a color and parameters for the toon shading model.
     */
    class CoatToon extends mixinCoatToon(FudgeCore.CoatRemissive) {
        constructor(_color = new FudgeCore.Color(), _texToon = FudgeCore.TextureDefault.toon, _diffuse, _specular = 1.2, _intensity, _metallic) {
            super(_color, _diffuse, _specular, _intensity, _metallic);
            this.texToon = _texToon;
        }
    }
    FudgeCore.CoatToon = CoatToon;
    /**
     * A {@link Coat} providing a texture, a color and parameters for the toon shading model.
     */
    class CoatToonTextured extends mixinCoatToon(FudgeCore.CoatRemissiveTextured) {
        constructor(_color = new FudgeCore.Color(), _texture = FudgeCore.TextureDefault.color, _texToon = FudgeCore.TextureDefault.toon, _diffuse, _specular = 1.2, _intensity, _metallic) {
            super(_color, _texture, _diffuse, _specular, _intensity, _metallic);
            this.texToon = _texToon;
        }
    }
    FudgeCore.CoatToonTextured = CoatToonTextured;
    function mixinCoatToon(_base) {
        let CoatToon = (() => {
            let _classSuper = _base;
            let _texToon_decorators;
            let _texToon_initializers = [];
            let _texToon_extraInitializers = [];
            return class CoatToon extends _classSuper {
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    _texToon_decorators = [FudgeCore.type(FudgeCore.Texture)];
                    __esDecorate(null, null, _texToon_decorators, { kind: "field", name: "texToon", static: false, private: false, access: { has: obj => "texToon" in obj, get: obj => obj.texToon, set: (obj, value) => { obj.texToon = value; } }, metadata: _metadata }, _texToon_initializers, _texToon_extraInitializers);
                    if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                }
                serialize() {
                    let serialization = super.serialize();
                    serialization.idTexToon = this.texToon.idResource;
                    return serialization;
                }
                async deserialize(_serialization) {
                    await super.deserialize(_serialization);
                    if (_serialization.idTexToon)
                        this.texToon = await FudgeCore.Project.getResource(_serialization.idTexToon);
                    return this;
                }
                constructor() {
                    super(...arguments);
                    this.texToon = __runInitializers(this, _texToon_initializers, void 0);
                    __runInitializers(this, _texToon_extraInitializers);
                }
            };
        })();
        return CoatToon;
    }
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines a color as values in the range of 0 to 1 for the four channels red, green, blue and alpha (for opacity)
     */
    class Color extends FudgeCore.Mutable {
        // crc2 only used for converting colors from strings predefined by CSS
        static { this.crc2 = (() => {
            const crc2 = document.createElement("canvas").getContext("2d", { willReadFrequently: true });
            crc2.globalCompositeOperation = "copy";
            return crc2;
        })(); }
        constructor(_r = 1, _g = 1, _b = 1, _a = 1) {
            super();
            this.setClamped(_r, _g, _b, _a);
        }
        /**
         * Returns a {@link Uint8ClampedArray} with the 8-bit color channels in the order RGBA.
         */
        static getBytesFromCSS(_keyword) {
            Color.crc2.fillStyle = _keyword;
            Color.crc2.fillRect(0, 0, 1, 1);
            return Color.crc2.getImageData(0, 0, 1, 1).data;
        }
        /**
         * Returns a new {@link Color} object created from the given css color keyword.
         * Passing an _alpha value will override the alpha value specified in the keyword.
         */
        static CSS(_keyword, _alpha) {
            return FudgeCore.Recycler.get(Color).setCSS(_keyword, _alpha);
        }
        static PRODUCT(_multiplicant, _multiplier) {
            return _multiplicant.clone.multiply(_multiplier);
        }
        /**
         * Creates and returns a clone of this color.
         */
        get clone() {
            return FudgeCore.Recycler.reuse(Color).copy(this);
        }
        /**
         * Copies the color channels of the given color into this color and returns it.
         */
        copy(_color) {
            this.r = _color.r;
            this.g = _color.g;
            this.b = _color.b;
            this.a = _color.a;
            return this;
        }
        recycle() {
            this.r = 1;
            this.g = 1;
            this.b = 1;
            this.a = 1;
        }
        /**
         * Sets this color from the given css color keyword. Optinally sets the alpha value to the given value.
         */
        setCSS(_keyword, _alpha) {
            const bytesRGBA = Color.getBytesFromCSS(_keyword);
            this.setBytes(bytesRGBA[0], bytesRGBA[1], bytesRGBA[2], bytesRGBA[3]);
            this.a = _alpha ?? this.a;
            return this;
        }
        setBytes(_r, _g, _b, _a) {
            if (_r instanceof Uint8ClampedArray)
                this.setBytes(_r[0], _r[1], _r[2], _r[3]);
            else
                this.setClamped(_r / 255, _g / 255, _b / 255, _a / 255);
            return this;
        }
        setClamped(_r, _g, _b, _a) {
            if (_r instanceof Float32Array)
                this.setClamped(_r[0], _r[1], _r[2], _r[3]);
            else
                this.set(FudgeCore.Calc.clamp(_r, 0, 1), FudgeCore.Calc.clamp(_g, 0, 1), FudgeCore.Calc.clamp(_b, 0, 1), FudgeCore.Calc.clamp(_a, 0, 1));
            return this;
        }
        /**
         * Sets the color channels of this color.
         */
        set(_r, _g, _b, _a) {
            this.r = _r;
            this.g = _g;
            this.b = _b;
            this.a = _a;
            return this;
        }
        /**
         * Returns an array of the color channels of this color.
         */
        get() {
            return new Float32Array([this.r, this.g, this.b, this.a]);
        }
        /**
         * Returns a {@link Uint8ClampedArray} of the color channels of this color.
         */
        getBytes() {
            return new Uint8ClampedArray([this.r * 255, this.g * 255, this.b * 255, this.a * 255]);
        }
        /**
         * Returns the css color keyword representing this color.
         */
        getCSS() {
            let bytes = this.getBytes();
            return `RGBA(${bytes[0]}, ${bytes[1]}, ${bytes[2]}, ${this.a})`;
        }
        /**
         * Returns the hex string representation of this color.
         */
        getHex() {
            let bytes = this.getBytes();
            let hex = "";
            for (let byte of bytes)
                hex += byte.toString(16).padStart(2, "0");
            return hex;
        }
        /**
         * Sets this color from the given hex string color.
         */
        setHex(_hex) {
            let bytes = this.getBytes();
            let channel = 0;
            for (let byte in bytes)
                bytes[byte] = parseInt(_hex.substr(channel++ * 2, 2), 16);
            return this.setBytes(bytes);
            ;
        }
        /**
         * Adds the given color to this.
         */
        add(_color) {
            this.r += _color.r;
            this.g += _color.g;
            this.b += _color.b;
            this.a += _color.a;
            return this;
        }
        multiply(_multiplier) {
            if (_multiplier instanceof Color) {
                this.r *= _multiplier.r;
                this.g *= _multiplier.g;
                this.b *= _multiplier.b;
                this.a *= _multiplier.a;
            }
            else {
                this.r *= _multiplier;
                this.g *= _multiplier;
                this.b *= _multiplier;
                this.a *= _multiplier;
            }
            return this;
        }
        /**
         * Returns true if the channels of this and the given color are to be considered identical within the given tolerance
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.r - _compare.r) > _tolerance)
                return false;
            if (Math.abs(this.g - _compare.g) > _tolerance)
                return false;
            if (Math.abs(this.b - _compare.b) > _tolerance)
                return false;
            if (Math.abs(this.a - _compare.a) > _tolerance)
                return false;
            return true;
        }
        /**
         * Returns a formatted string representation of this color
         */
        toString() {
            return `(r: ${this.r.toFixed(3)}, g: ${this.g.toFixed(3)}, b: ${this.b.toFixed(3)}, a: ${this.a.toFixed(3)})`;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator(true);
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.r}, ${this.g}, ${this.b}, ${this.a}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.r, this.g, this.b, this.a] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Color = Color;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Material} loaded from a glTF-File.
     * @authors Jonas Plotzky, HFU, 2024
     */
    class MaterialGLTF extends FudgeCore.mixinSerializableResourceExternal(FudgeCore.Material) {
        async load(_url = this.url, _name = this.name) {
            this.url = _url;
            this.name = _name;
            return FudgeCore.GLTFLoader.loadResource(this);
        }
    }
    FudgeCore.MaterialGLTF = MaterialGLTF;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Abstract class supporting various arithmetical helper functions
     */
    class Calc {
        /** factor multiplied with angle in degrees yields the angle in radian */
        static { this.deg2rad = Math.PI / 180; }
        /** factor multiplied with angle in radian yields the angle in degrees */
        static { this.rad2deg = 1 / Calc.deg2rad; }
        /**
         * Returns one of the values passed in, either _value if within _min and _max or the boundary being exceeded by _value
         */
        static clamp(_value, _min, _max, _isSmaller = (_value1, _value2) => { return _value1 < _value2; }) {
            if (_isSmaller(_value, _min))
                return _min;
            if (_isSmaller(_max, _value))
                return _max;
            return _value;
        }
        /**
         * Returns the linear interpolation between two values (_a, _b) for the given interpolation factor (_f). f is clamped between 0 and 1.
         */
        static lerp(_a, _b, _f) {
            return _a + (_b - _a) * Calc.clamp(_f, 0, 1);
        }
        /**
         * Rounds the given value to the nearest multiple of the given increment using the given rounding function.
         * Default rounding function is {@link Math.round}, use {@link Math.floor} or {@link Math.ceil} to round down or up.
         */
        static snap(_value, _increment, _round = Math.round) {
            return _round(_value / _increment) * _increment;
        }
    }
    FudgeCore.Calc = Calc;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Framing describes how to map a rectangle into a given frame
     * and how points in the frame correspond to points in the resulting rectangle and vice versa
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Framing
     */
    class Framing extends FudgeCore.Mutable {
        reduceMutator(_mutator) { }
    }
    FudgeCore.Framing = Framing;
    /**
     * The resulting rectangle has a fixed width and height and display should scale to fit the frame
     * Points are scaled in the same ratio
     */
    class FramingFixed extends Framing {
        constructor(_width = 300, _height = 150) {
            super();
            this.width = 300;
            this.height = 150;
            this.setSize(_width, _height);
        }
        /**
         * Sets this framing to the given width and height
         */
        setSize(_width, _height) {
            this.width = _width;
            this.height = _height;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.width * (_pointInFrame.x - _rectFrame.x) / _rectFrame.width, this.height * (_pointInFrame.y - _rectFrame.y) / _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x * _rect.width / this.width + _rect.x, _point.y * _rect.height / this.height + _rect.y);
            return result;
        }
        getRect(_rectFrame) {
            return FudgeCore.Rectangle.GET(0, 0, this.width, this.height);
        }
    }
    FudgeCore.FramingFixed = FramingFixed;
    /**
     * Width and height of the resulting rectangle are fractions of those of the frame, scaled by normed values normWidth and normHeight.
     * Display should scale to fit the frame and points are scaled in the same ratio
     */
    class FramingScaled extends Framing {
        constructor() {
            super(...arguments);
            this.normWidth = 1.0;
            this.normHeight = 1.0;
        }
        /**
         * Sets this framing to the given normed width and height
         */
        setScale(_normWidth, _normHeight) {
            this.normWidth = _normWidth;
            this.normHeight = _normHeight;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.normWidth * (_pointInFrame.x - _rectFrame.x), this.normHeight * (_pointInFrame.y - _rectFrame.y));
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x / this.normWidth + _rect.x, _point.y / this.normHeight + _rect.y);
            return result;
        }
        getRect(_rectFrame) {
            return FudgeCore.Rectangle.GET(0, 0, this.normWidth * _rectFrame.width, this.normHeight * _rectFrame.height);
        }
    }
    FudgeCore.FramingScaled = FramingScaled;
    /**
     * The resulting rectangle fits into a margin given as fractions of the size of the frame given by normAnchor
     * plus an absolute padding given by pixelBorder. Display should fit into this.
     */
    class FramingComplex extends Framing {
        constructor() {
            super(...arguments);
            this.margin = { left: 0, top: 0, right: 0, bottom: 0 };
            this.padding = { left: 0, top: 0, right: 0, bottom: 0 };
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(_pointInFrame.x - this.padding.left - this.margin.left * _rectFrame.width, _pointInFrame.y - this.padding.top - this.margin.top * _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x + this.padding.left + this.margin.left * _rect.width, _point.y + this.padding.top + this.margin.top * _rect.height);
            return result;
        }
        getRect(_rectFrame) {
            if (!_rectFrame)
                return null;
            let minX = _rectFrame.x + this.margin.left * _rectFrame.width + this.padding.left;
            let minY = _rectFrame.y + this.margin.top * _rectFrame.height + this.padding.top;
            let maxX = _rectFrame.x + (1 - this.margin.right) * _rectFrame.width - this.padding.right;
            let maxY = _rectFrame.y + (1 - this.margin.bottom) * _rectFrame.height - this.padding.bottom;
            return FudgeCore.Rectangle.GET(minX, minY, maxX - minX, maxY - minY);
        }
        getMutator() {
            return { margin: this.margin, padding: this.padding };
        }
    }
    FudgeCore.FramingComplex = FramingComplex;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Representation of a vector2 as polar coordinates
     * ```text
     *  ‚Üï- angle (Angle to the x-axis)
     *  -‚Üí Magnitude (Distance from the center)
     * ```
     */
    class Geo2 {
        constructor(_angle = 0, _magnitude = 1) {
            this.magnitude = 0;
            this.angle = 0;
            this.set(_angle, _magnitude);
        }
        /**
         * Set the properties of this instance at once
         */
        set(_angle = 0, _magnitude = 1) {
            this.magnitude = _magnitude;
            this.angle = _angle;
        }
        recycle() {
            this.set();
        }
        /**
         * Returns a pretty string representation
         */
        toString() {
            return `angle: ${this.angle.toPrecision(5)},  magnitude: ${this.magnitude.toPrecision(5)}`;
        }
    }
    FudgeCore.Geo2 = Geo2;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Representation of a vector3 as geographic coordinates as seen on a globe
     * ```text
     * ‚Üê|‚Üí Longitude (Angle to the z-axis)
     *  ‚Üï- Latitude (Angle to the equator)
     *  -‚Üí Magnitude (Distance from the center)
     * ```
     */
    class Geo3 {
        constructor(_longitude = 0, _latitude = 0, _magnitude = 1) {
            this.magnitude = 0;
            this.latitude = 0;
            this.longitude = 0;
            this.set(_longitude, _latitude, _magnitude);
        }
        /**
         * Set the properties of this instance at once
         */
        set(_longitude = 0, _latitude = 0, _magnitude = 1) {
            this.magnitude = _magnitude;
            this.latitude = _latitude;
            this.longitude = _longitude;
        }
        recycle() {
            this.set();
        }
        /**
         * Returns a pretty string representation
         */
        toString() {
            return `longitude: ${this.longitude.toPrecision(5)}, latitude: ${this.latitude.toPrecision(5)}, magnitude: ${this.magnitude.toPrecision(5)}`;
        }
    }
    FudgeCore.Geo3 = Geo3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // From http://baagoe.com/en/RandomMusings/javascript/
    // Johannes Baag√∏e <baagoe@baagoe.com>, 2010
    function Mash() {
        let n = 0xefc8249d;
        let mash = function (_data) {
            _data = _data.toString();
            for (let i = 0; i < _data.length; i++) {
                n += _data.charCodeAt(i);
                let h = 0.02519603282416938 * n;
                n = h >>> 0;
                h -= n;
                h *= n;
                n = h >>> 0;
                h -= n;
                n += h * 0x100000000; // 2^32
            }
            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
        };
        // mash.version = 'Mash 0.9';
        return mash;
    }
    FudgeCore.Mash = Mash;
    // From http://baagoe.com/en/RandomMusings/javascript/
    function LFIB4() {
        // George Marsaglia's LFIB4,
        //http://groups.google.com/group/sci.crypt/msg/eb4ddde782b17051
        let args = Array.prototype.slice.call(arguments);
        let k0 = 0, k1 = 58, k2 = 119, k3 = 178;
        let s = [];
        let mash = Mash();
        if (args.length === 0) {
            args = [+new Date()];
        }
        for (let j = 0; j < 256; j++) {
            s[j] = mash(" ");
            s[j] -= mash(" ") * 4.76837158203125e-7; // 2^-21
            if (s[j] < 0) {
                s[j] += 1;
            }
        }
        for (let i = 0; i < args.length; i++) {
            for (let j = 0; j < 256; j++) {
                s[j] -= mash(args[i]);
                s[j] -= mash(args[i]) * 4.76837158203125e-7; // 2^-21
                if (s[j] < 0) {
                    s[j] += 1;
                }
            }
        }
        mash = null;
        let random = function () {
            let x;
            k0 = (k0 + 1) & 255;
            k1 = (k1 + 1) & 255;
            k2 = (k2 + 1) & 255;
            k3 = (k3 + 1) & 255;
            x = s[k0] - s[k1];
            if (x < 0) {
                x += 1;
            }
            x -= s[k2];
            if (x < 0) {
                x += 1;
            }
            x -= s[k3];
            if (x < 0) {
                x += 1;
            }
            return s[k0] = x;
        };
        // random.uint32 = function () {
        //   return random() * 0x100000000 >>> 0; // 2^32
        // };
        // random.fract53 = random;
        // random.version = "LFIB4 0.9";
        // random.args = args;
        return random;
    }
    FudgeCore.LFIB4 = LFIB4;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Simple class for 3x3 matrix operations
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class Matrix3x3 extends FudgeCore.Mutable {
        constructor() {
            super();
            this.data = new Float32Array(9); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.recycle();
        }
        //TODO: figure out what this is used for
        /** TODO: describe! */
        static PROJECTION(_width, _height) {
            let mtxResult = new Matrix3x3;
            mtxResult.data.set([
                2 / _width, 0, 0,
                0, -2 / _height, 0,
                -1, 1, 1
            ]);
            return mtxResult;
        }
        /**
         * Retrieve a new identity matrix.
         */
        static IDENTITY() {
            const mtxResult = FudgeCore.Recycler.get(Matrix3x3);
            return mtxResult;
        }
        /**
         * Returns a matrix that translates coordinates along the x- and y-axis according to the given {@link Vector2}.
         */
        static TRANSLATION(_translate) {
            const mtxResult = FudgeCore.Recycler.reuse(Matrix3x3);
            mtxResult.set([
                1, 0, 0,
                0, 1, 0,
                _translate.x, _translate.y, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         */
        static ROTATION(_angleInDegrees) {
            const mtxResult = FudgeCore.Recycler.reuse(Matrix3x3);
            let angleInRadians = _angleInDegrees * FudgeCore.Calc.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.set([
                cos, sin, 0,
                -sin, cos, 0,
                0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that scales coordinates along the x- and y-axis according to the given {@link Vector2}
         */
        static SCALING(_scalar) {
            const mtxResult = FudgeCore.Recycler.reuse(Matrix3x3);
            mtxResult.set([
                _scalar.x, 0, 0,
                0, _scalar.y, 0,
                0, 0, 1
            ]);
            return mtxResult;
        }
        //#endregion
        /**
         * Computes and returns the product of two passed matrices.
         */
        static PRODUCT(_mtxLeft, _mtxRight) {
            let a00 = _mtxLeft.data[0 * 3 + 0];
            let a01 = _mtxLeft.data[0 * 3 + 1];
            let a02 = _mtxLeft.data[0 * 3 + 2];
            let a10 = _mtxLeft.data[1 * 3 + 0];
            let a11 = _mtxLeft.data[1 * 3 + 1];
            let a12 = _mtxLeft.data[1 * 3 + 2];
            let a20 = _mtxLeft.data[2 * 3 + 0];
            let a21 = _mtxLeft.data[2 * 3 + 1];
            let a22 = _mtxLeft.data[2 * 3 + 2];
            let b00 = _mtxRight.data[0 * 3 + 0];
            let b01 = _mtxRight.data[0 * 3 + 1];
            let b02 = _mtxRight.data[0 * 3 + 2];
            let b10 = _mtxRight.data[1 * 3 + 0];
            let b11 = _mtxRight.data[1 * 3 + 1];
            let b12 = _mtxRight.data[1 * 3 + 2];
            let b20 = _mtxRight.data[2 * 3 + 0];
            let b21 = _mtxRight.data[2 * 3 + 1];
            let b22 = _mtxRight.data[2 * 3 + 2];
            let mtxResult = FudgeCore.Recycler.reuse(Matrix3x3);
            mtxResult.set([
                b00 * a00 + b01 * a10 + b02 * a20,
                b00 * a01 + b01 * a11 + b02 * a21,
                b00 * a02 + b01 * a12 + b02 * a22,
                b10 * a00 + b11 * a10 + b12 * a20,
                b10 * a01 + b11 * a11 + b12 * a21,
                b10 * a02 + b11 * a12 + b12 * a22,
                b20 * a00 + b21 * a10 + b22 * a20,
                b20 * a01 + b21 * a11 + b22 * a21,
                b20 * a02 + b21 * a12 + b22 * a22
            ]);
            return mtxResult;
        }
        /**
         * Computes and returns the inverse of a passed matrix.
         * @param _mtx The matrix to compute the inverse of.
         */
        static INVERSE(_mtx) {
            let m = _mtx.data;
            let m00 = m[0 * 3 + 0];
            let m01 = m[0 * 3 + 1];
            let m02 = m[0 * 3 + 2];
            let m10 = m[1 * 3 + 0];
            let m11 = m[1 * 3 + 1];
            let m12 = m[1 * 3 + 2];
            let m20 = m[2 * 3 + 0];
            let m21 = m[2 * 3 + 1];
            let m22 = m[2 * 3 + 2];
            let d = 1 /
                (m00 * (m11 * m22 - m21 * m12) -
                    m01 * (m10 * m22 - m12 * m20) +
                    m02 * (m10 * m21 - m11 * m20));
            const mtxResult = FudgeCore.Recycler.reuse(Matrix3x3);
            mtxResult.set([
                d * (m11 * m22 - m21 * m12), // [0]
                d * (m02 * m21 - m01 * m22), // [1]
                d * (m01 * m12 - m02 * m11), // [2]
                d * (m12 * m20 - m10 * m22), // [3]
                d * (m00 * m22 - m02 * m20), // [4]
                d * (m10 * m02 - m00 * m12), // [5]
                d * (m10 * m21 - m20 * m11), // [6]
                d * (m20 * m01 - m00 * m21), // [7]
                d * (m00 * m11 - m10 * m01) // [8]
            ]);
            return mtxResult;
        }
        /**
         * - get: return a vector representation of the translation {@link Vector2}.
         * **Caution!** Use immediately, since the vector is going to be reused by Recycler. Create a clone to keep longer and manipulate.
         * - set: effect the matrix ignoring its rotation and scaling
         */
        get translation() {
            if (!this.vectors.translation)
                this.vectors.translation = new FudgeCore.Vector2(this.data[6], this.data[7]);
            return this.vectors.translation; // .clone;
        }
        set translation(_translation) {
            this.data.set(_translation.get(), 6);
            // no full cache reset required
            this.vectors.translation = _translation;
            this.mutator = null;
        }
        /**
         * - get: a copy of the calculated rotation {@link Vector2}
         * - set: effect the matrix
         */
        get rotation() {
            if (!this.vectors.rotation)
                this.vectors.rotation = this.getEulerAngle();
            return this.vectors.rotation;
        }
        set rotation(_rotation) {
            this.mutate({ "rotation": _rotation });
            this.resetCache();
        }
        /**
         * - get: return a vector representation of the scale {@link Vector3}.
         * **Caution!** Do not manipulate result, instead create a clone!
         * - set: effect the matrix
         */
        get scaling() {
            if (!this.vectors.scaling)
                this.vectors.scaling = new FudgeCore.Vector2(Math.hypot(this.data[0], this.data[1]) * (this.data[0] < 0 ? -1 : 1), Math.hypot(this.data[3], this.data[4]) * (this.data[4] < 0 ? -1 : 1));
            return this.vectors.scaling; // .clone;
        }
        set scaling(_scaling) {
            this.mutate({ "scaling": _scaling });
            this.resetCache();
        }
        /**
         * Creates and returns a clone of this matrix.
         */
        get clone() {
            return FudgeCore.Recycler.reuse(Matrix3x3).copy(this);
        }
        /**
         * Resets the matrix to the identity-matrix and clears cache. Used by the recycler to reset.
         */
        recycle() {
            this.set([
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ]);
        }
        /**
         * Resets the matrix to the identity-matrix and clears cache.
         */
        reset() {
            this.recycle();
        }
        //#region Translation
        /**
         * Adds a translation by the given {@link Vector2} to this matrix.
         */
        translate(_by) {
            const mtxResult = Matrix3x3.PRODUCT(this, Matrix3x3.TRANSLATION(_by));
            // TODO: possible optimization, translation may alter mutator instead of deleting it.
            this.set(mtxResult.data);
            FudgeCore.Recycler.store(mtxResult);
            return this;
        }
        /**
         * Adds a translation along the x-axis to this matrix.
         */
        translateX(_x) {
            this.data[6] += _x;
            this.mutator = null;
            this.vectors.translation = null;
            return this;
        }
        /**
         * Adds a translation along the y-axis to this matrix.
         */
        translateY(_y) {
            this.data[7] += _y;
            this.mutator = null;
            this.vectors.translation = null;
            return this;
        }
        //#endregion
        //#region Rotation
        /**
         * Adds a rotation around the z-Axis to this matrix
         */
        rotate(_angleInDegrees) {
            const mtxResult = Matrix3x3.PRODUCT(this, Matrix3x3.ROTATION(_angleInDegrees));
            this.set(mtxResult.data);
            FudgeCore.Recycler.store(mtxResult);
            return this;
        }
        //#endregion
        //#region Scaling
        /**
         * Adds a scaling by the given {@link Vector2} to this matrix.
         */
        scale(_by) {
            const mtxResult = Matrix3x3.PRODUCT(this, Matrix3x3.SCALING(_by));
            this.set(mtxResult.data);
            FudgeCore.Recycler.store(mtxResult);
            return this;
        }
        /**
         * Adds a scaling along the x-Axis to this matrix.
         */
        scaleX(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector2);
            vector.set(_by, 1);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
            return this;
        }
        /**
         * Adds a scaling along the y-Axis to this matrix.
         */
        scaleY(_by) {
            let vector = FudgeCore.Recycler.get(FudgeCore.Vector2);
            vector.set(1, _by);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
            return this;
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix with the given matrix
         */
        multiply(_mtxRight) {
            let mtxResult = Matrix3x3.PRODUCT(this, _mtxRight);
            this.set(mtxResult.data);
            FudgeCore.Recycler.store(mtxResult);
            this.mutator = null;
            return this;
        }
        //#endregion
        //#region Transfer
        /**
         * Calculates and returns the euler-angles representing the current rotation of this matrix
         */
        getEulerAngle() {
            let scaling = this.scaling;
            let s0 = this.data[0] / scaling.x;
            let s1 = this.data[1] / scaling.x;
            let s3 = this.data[3] / scaling.y;
            let s4 = this.data[4] / scaling.y;
            let xSkew = Math.atan2(-s3, s4);
            let ySkew = Math.atan2(s0, s1);
            let sy = Math.hypot(s0, s1); // probably 2. param should be this.data[4] / scaling.y
            let rotation;
            if (!(sy > 1e-6))
                rotation = ySkew;
            else
                rotation = xSkew;
            rotation *= FudgeCore.Calc.rad2deg;
            return rotation;
        }
        /**
         * Sets the elements of this matrix to the given array.
         */
        set(_array) {
            this.data.set(_array);
            this.resetCache();
            return this;
        }
        /**
         * Copies the elements of the given matrix into this matrix.
         */
        copy(_original) {
            this.data.set(_original.data);
            this.resetCache(); // TODO: for now reset the cache, as i have no idea how the caching works for matrix3x3.
            return this;
        }
        /**
         * Returns a formatted string representation of this matrix
         */
        toString() {
            return `∆í.Matrix3x3(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Returns an array of the elements of this matrix.
         */
        get() {
            return new Float32Array(this.data);
        }
        /**
         * Returns the original array of the elements of this matrix.
         */
        getData() {
            return this.data;
        }
        serialize() {
            // this.getMutator();
            let serialization = {
                translation: this.translation.serialize(),
                rotation: this.rotation,
                scaling: this.scaling.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            let mutator = {
                translation: await this.translation.deserialize(_serialization.translation),
                rotation: _serialization.rotation,
                scaling: await this.scaling.deserialize(_serialization.scaling)
            };
            this.mutate(mutator);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation,
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        async mutate(_mutator) {
            let oldTranslation = this.translation;
            let oldRotation = this.rotation;
            let oldScaling = this.scaling;
            let newTranslation = _mutator["translation"];
            let newRotation = _mutator["rotation"];
            let newScaling = _mutator["scaling"];
            let vectors = { translation: oldTranslation, rotation: oldRotation, scaling: oldScaling };
            if (newTranslation) {
                vectors.translation = new FudgeCore.Vector2(newTranslation.x != undefined ? newTranslation.x : oldTranslation.x, newTranslation.y != undefined ? newTranslation.y : oldTranslation.y);
            }
            vectors.rotation = (newRotation == undefined) ? oldRotation : newRotation;
            if (newScaling) {
                vectors.scaling = new FudgeCore.Vector2(newScaling.x != undefined ? newScaling.x : oldScaling.x, newScaling.y != undefined ? newScaling.y : oldScaling.y);
            }
            // TODO: possible performance optimization when only one or two components change, then use old matrix instead of IDENTITY and transform by differences/quotients
            let mtxResult = Matrix3x3.IDENTITY();
            if (vectors.translation)
                mtxResult.translate(vectors.translation);
            if (vectors.rotation) {
                mtxResult.rotate(vectors.rotation);
            }
            if (vectors.scaling)
                mtxResult.scale(vectors.scaling);
            this.set(mtxResult.data);
            this.vectors = vectors;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector2";
            if (_mutator.rotation != undefined)
                types.rotation = "number";
            if (_mutator.scaling)
                types.scaling = "Vector2";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.vectors = { translation: null, rotation: null, scaling: null };
            this.mutator = null;
        }
    }
    FudgeCore.Matrix3x3 = Matrix3x3;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores a 4x4 transformation matrix and provides operations for it.
     * ```text
     * [ 0, 1, 2, 3 ] ‚Üê row vector x
     * [ 4, 5, 6, 7 ] ‚Üê row vector y
     * [ 8, 9,10,11 ] ‚Üê row vector z
     * [12,13,14,15 ] ‚Üê translation
     *            ‚Üë  homogeneous column
     * ```
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019 | Jonas Plotzky, HFU, 2023
     */
    class Matrix4x4 extends FudgeCore.Mutable {
        #translation;
        #scaling;
        #rotation;
        #quaternion;
        #translationDirty;
        #scalingDirty;
        #rotationDirty;
        #quaternionDirty;
        constructor() {
            super();
            this.data = new Float32Array(16); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.#translation = FudgeCore.Vector3.ZERO();
            this.#scaling = FudgeCore.Vector3.ZERO();
            this.#rotation = FudgeCore.Vector3.ONE();
            this.#quaternion = FudgeCore.Quaternion.IDENTITY();
            this.recycle();
        }
        //#region STATICS
        /**
         * Retrieve a new identity matrix
         */
        static IDENTITY() {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            return mtxResult;
        }
        /**
         * Composes a new matrix according to the given translation, rotation and scaling.
         */
        static COMPOSITION(_translation, _rotation, _scaling) {
            let result = Matrix4x4.IDENTITY();
            result.mutate({ "translation": _translation, "rotation": _rotation, "scaling": _scaling });
            return result;
        }
        /**
         * Computes and returns the product of two passed matrices.
         */
        // @PerformanceMonitor.measure("Matrix4x4.PRODUCT")
        static PRODUCT(_mtxLeft, _mtxRight) {
            let a = _mtxLeft.data;
            let b = _mtxRight.data;
            const mtxResult = FudgeCore.Recycler.reuse(Matrix4x4);
            let a00 = a[0 * 4 + 0];
            let a01 = a[0 * 4 + 1];
            let a02 = a[0 * 4 + 2];
            let a03 = a[0 * 4 + 3];
            let a10 = a[1 * 4 + 0];
            let a11 = a[1 * 4 + 1];
            let a12 = a[1 * 4 + 2];
            let a13 = a[1 * 4 + 3];
            let a20 = a[2 * 4 + 0];
            let a21 = a[2 * 4 + 1];
            let a22 = a[2 * 4 + 2];
            let a23 = a[2 * 4 + 3];
            let a30 = a[3 * 4 + 0];
            let a31 = a[3 * 4 + 1];
            let a32 = a[3 * 4 + 2];
            let a33 = a[3 * 4 + 3];
            let b00 = b[0 * 4 + 0];
            let b01 = b[0 * 4 + 1];
            let b02 = b[0 * 4 + 2];
            let b03 = b[0 * 4 + 3];
            let b10 = b[1 * 4 + 0];
            let b11 = b[1 * 4 + 1];
            let b12 = b[1 * 4 + 2];
            let b13 = b[1 * 4 + 3];
            let b20 = b[2 * 4 + 0];
            let b21 = b[2 * 4 + 1];
            let b22 = b[2 * 4 + 2];
            let b23 = b[2 * 4 + 3];
            let b30 = b[3 * 4 + 0];
            let b31 = b[3 * 4 + 1];
            let b32 = b[3 * 4 + 2];
            let b33 = b[3 * 4 + 3];
            mtxResult.set([
                b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
                b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
                b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
                b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
                b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
                b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
                b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
                b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
                b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
                b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
                b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
                b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
                b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
                b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
                b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
                b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33
            ]);
            return mtxResult;
        }
        /**
         * Computes and returns the transpose of a passed matrix.
         */
        static TRANSPOSE(_mtx) {
            return _mtx.clone.transpose();
        }
        /**
         * Computes and returns the inverse of a passed matrix.
         * @param _mtx The matrix to compute the inverse of.
         */
        static INVERSE(_mtx) {
            return _mtx.clone.invert();
        }
        /**
         * Computes and returns a matrix with the given translation, its z-axis pointing directly at the given target,
         * and a minimal angle between its y-axis and the given up-{@link Vector3}, respetively calculating yaw and pitch.
         * The pitch may be restricted to the up-vector to only calculate yaw.
         */
        static LOOK_AT(_translation, _target, _up = FudgeCore.Vector3.Y(), _restrict = false) {
            let zAxis = FudgeCore.Vector3.DIFFERENCE(_target, _translation);
            zAxis.normalize();
            let vctCross = FudgeCore.Vector3.CROSS(_up, zAxis);
            if (vctCross.magnitudeSquared == 0) // experimental workaround: if z and up is parallel, there is no up to remain...
                vctCross.x = 0.001; // so tilt a little
            let xAxis = FudgeCore.Vector3.NORMALIZATION(vctCross);
            let yAxis = _restrict ? _up : FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(zAxis, xAxis));
            zAxis = _restrict ? FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(xAxis, _up)) : zAxis;
            const mtxResult = FudgeCore.Recycler.reuse(Matrix4x4);
            mtxResult.set([
                xAxis.x, xAxis.y, xAxis.z, 0,
                yAxis.x, yAxis.y, yAxis.z, 0,
                zAxis.x, zAxis.y, zAxis.z, 0,
                _translation.x,
                _translation.y,
                _translation.z,
                1
            ]);
            FudgeCore.Recycler.storeMultiple(zAxis, xAxis, vctCross); // don't store yAxis, it might be _up
            return mtxResult;
        }
        /**
         * Computes and returns a matrix with the given translation, its z-axis pointing directly in the given direction,
         * and a minimal angle between its y-axis and the given up-{@link Vector3}. Ideally up should be perpendicular to the given direction.
         */
        static LOOK_IN(_translation, _direction, _up = FudgeCore.Vector3.Y(), _restrict = false) {
            const mtxResult = Matrix4x4.COMPOSITION(_translation);
            mtxResult.lookIn(_direction, _up, _restrict);
            return mtxResult;
        }
        /**
         * Computes and returns a matrix with the given translation, its y-axis matching the given up-{@link Vector3}
         * and its z-axis facing towards the given target at a minimal angle, respetively calculating yaw only.
         */
        // public static SHOW_TO(_translation: Vector3, _target: Vector3, _up: Vector3 = Vector3.Y()): Matrix4x4 {
        //   const mtxResult: Matrix4x4 = Recycler.get(Matrix4x4);
        //   let zAxis: Vector3 = Vector3.DIFFERENCE(_target, _translation);
        //   zAxis.normalize();
        //   let xAxis: Vector3 = Vector3.NORMALIZATION(Vector3.CROSS(_up, zAxis));
        //   // let yAxis: Vector3 = Vector3.NORMALIZATION(Vector3.CROSS(zAxis, xAxis));
        //   zAxis = Vector3.NORMALIZATION(Vector3.CROSS(xAxis, _up));
        //   mtxResult.data.set(
        //     [
        //       xAxis.x, xAxis.y, xAxis.z, 0,
        //       _up.x, _up.y, _up.z, 0,
        //       zAxis.x, zAxis.y, zAxis.z, 0,
        //       _translation.x,
        //       _translation.y,
        //       _translation.z,
        //       1
        //     ]);
        //   return mtxResult;
        // }
        /**
         * Returns a matrix that translates coordinates along the x-, y- and z-axis according to the given {@link Vector3}.
         */
        static TRANSLATION(_translate) {
            const mtxResult = FudgeCore.Recycler.reuse(Matrix4x4);
            mtxResult.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                _translate.x, _translate.y, _translate.z, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the x-axis when multiplied by.
         */
        static ROTATION_X(_angleInDegrees) {
            const mtxResult = FudgeCore.Recycler.reuse(Matrix4x4);
            let angleInRadians = _angleInDegrees * FudgeCore.Calc.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.set([
                1, 0, 0, 0,
                0, cos, sin, 0,
                0, -sin, cos, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the y-axis when multiplied by.
         */
        static ROTATION_Y(_angleInDegrees) {
            const mtxResult = FudgeCore.Recycler.reuse(Matrix4x4);
            let angleInRadians = _angleInDegrees * FudgeCore.Calc.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.set([
                cos, 0, -sin, 0,
                0, 1, 0, 0,
                sin, 0, cos, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         */
        static ROTATION_Z(_angleInDegrees) {
            const mtxResult = FudgeCore.Recycler.reuse(Matrix4x4);
            let angleInRadians = _angleInDegrees * FudgeCore.Calc.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            mtxResult.set([
                cos, sin, 0, 0,
                -sin, cos, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a matrix that rotates coordinates when multiplied by, using the rotation euler angles or unit quaternion given.
         * Rotation occurs around the axis in the order Z-Y-X.
         */
        static ROTATION(_rotation) {
            const mtxResult = FudgeCore.Recycler.get(Matrix4x4);
            Matrix4x4.setRotation(mtxResult.data, _rotation);
            return mtxResult;
        }
        /**
         * Returns a matrix that scales coordinates along the x-, y- and z-axis according to the given {@link Vector3}
         */
        static SCALING(_scalar) {
            const mtxResult = FudgeCore.Recycler.reuse(Matrix4x4);
            mtxResult.set([
                _scalar.x, 0, 0, 0,
                0, _scalar.y, 0, 0,
                0, 0, _scalar.z, 0,
                0, 0, 0, 1
            ]);
            return mtxResult;
        }
        /**
         * Returns a representation of the given matrix relative to the given base.
         * If known, pass the inverse of the base to avoid unneccesary calculation
         */
        static RELATIVE(_mtx, _mtxBase, _mtxInverse) {
            if (_mtxInverse)
                return Matrix4x4.PRODUCT(_mtxInverse, _mtx);
            let mtxInverse = Matrix4x4.INVERSE(_mtxBase);
            let mtxResult = Matrix4x4.PRODUCT(mtxInverse, _mtx);
            FudgeCore.Recycler.store(mtxInverse);
            return mtxResult;
        }
        //#endregion
        //#region PROJECTIONS
        /**
         * Computes and returns a matrix that applies perspective to an object, if its transform is multiplied by it.
         * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
         * @param _fieldOfViewInDegrees The field of view in Degrees. (Default = 45)
         * @param _near The near clipspace border on the z-axis.
         * @param _far The far clipspace border on the z-axis.
         * @param _direction The plane on which the fieldOfView-Angle is given
         */
        static PROJECTION_CENTRAL(_aspect, _fieldOfViewInDegrees, _near, _far, _direction) {
            //TODO: camera looks down negative z-direction, should be positive
            let fieldOfViewInRadians = _fieldOfViewInDegrees * FudgeCore.Calc.deg2rad;
            let f = Math.tan(0.5 * (Math.PI - fieldOfViewInRadians));
            let rangeInv = 1.0 / (_near - _far);
            const mtxResult = FudgeCore.Recycler.reuse(Matrix4x4);
            mtxResult.set([
                f, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (_near + _far) * rangeInv, -1,
                0, 0, _near * _far * rangeInv * 2, 0
            ]);
            if (_direction == FudgeCore.FIELD_OF_VIEW.DIAGONAL) {
                _aspect = Math.sqrt(_aspect);
                mtxResult.data[0] = f / _aspect;
                mtxResult.data[5] = f * _aspect;
            }
            else if (_direction == FudgeCore.FIELD_OF_VIEW.VERTICAL)
                mtxResult.data[0] = f / _aspect;
            else //FOV_DIRECTION.HORIZONTAL
                mtxResult.data[5] = f * _aspect;
            // HACK: matrix should look in positive z-direction, preferably the matrix should be calculated like that right away
            mtxResult.rotateY(180);
            return mtxResult;
        }
        /**
         * Computes and returns a matrix that applies orthographic projection to an object, if its transform is multiplied by it.
         * @param _left The positionvalue of the projectionspace's left border.
         * @param _right The positionvalue of the projectionspace's right border.
         * @param _bottom The positionvalue of the projectionspace's bottom border.
         * @param _top The positionvalue of the projectionspace's top border.
         * @param _near The positionvalue of the projectionspace's near border.
         * @param _far The positionvalue of the projectionspace's far border
         */
        static PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, _near = -400, _far = 400) {
            const mtxResult = FudgeCore.Recycler.reuse(Matrix4x4);
            mtxResult.set([
                2 / (_right - _left), 0, 0, 0,
                0, -2 / (_top - _bottom), 0, 0,
                0, 0, 2 / (_far - _near), 0,
                (_left + _right) / (_left - _right),
                (_bottom + _top) / (_bottom - _top),
                (_near + _far) / (_near - _far),
                1
            ]);
            return mtxResult;
        }
        /**
         * Set the rotation part of the given matrixes data array to the given rotation.
         */
        static setRotation(_m, _rotation) {
            if (_rotation instanceof FudgeCore.Vector3) {
                const anglesRad = FudgeCore.Vector3.SCALE(_rotation, FudgeCore.Calc.deg2rad);
                const sinX = Math.sin(anglesRad.x);
                const cosX = Math.cos(anglesRad.x);
                const sinY = Math.sin(anglesRad.y);
                const cosY = Math.cos(anglesRad.y);
                const sinZ = Math.sin(anglesRad.z);
                const cosZ = Math.cos(anglesRad.z);
                FudgeCore.Recycler.store(anglesRad);
                _m[0] = cosZ * cosY; /**/
                _m[1] = sinZ * cosY; /**/
                _m[2] = -sinY;
                _m[4] = cosZ * sinY * sinX - sinZ * cosX;
                _m[5] = sinZ * sinY * sinX + cosZ * cosX;
                _m[6] = cosY * sinX;
                _m[8] = cosZ * sinY * cosX + sinZ * sinX;
                _m[9] = sinZ * sinY * cosX - cosZ * sinX;
                _m[10] = cosY * cosX;
            }
            else {
                // const rotationNormalized: Quaternion = Quaternion.NORMALIZATION(_rotation);
                const x = _rotation.x, y = _rotation.y, z = _rotation.z, w = _rotation.w;
                const xx = x * x, xy = x * y, xz = x * z, xw = x * w;
                const yy = y * y, yz = y * z, yw = y * w;
                const zz = z * z, zw = z * w;
                const ww = w * w;
                _m[0] = ww + xx - yy - zz;
                _m[1] = 2 * (xy + zw); /**/
                _m[2] = 2 * (xz - yw);
                _m[4] = 2 * (xy - zw); /**/
                _m[5] = ww - xx + yy - zz;
                _m[6] = 2 * (yz + xw);
                _m[8] = 2 * (xz + yw); /**/
                _m[9] = 2 * (yz - xw); /**/
                _m[10] = ww - xx - yy + zz;
                // _m[0] = 1 - 2 * (yy + zz); _m[1] = 2 * (xy + zw);/**/ _m[2] = 2 * (xz - yw);
                // _m[4] = 2 * (xy - zw);/**/ _m[5] = 1 - 2 * (xx + zz); _m[6] = 2 * (yz + xw);
                // _m[8] = 2 * (xz + yw);/**/ _m[9] = 2 * (yz - xw);/**/ _m[10] = 1 - 2 * (xx + yy);
                // Recycler.store(rotationNormalized);
            }
        }
        //#endregion
        //#region  Accessors
        /**
         * - get: return a vector representation of the translation {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: effect the matrix ignoring its rotation and scaling
         */
        get translation() {
            if (this.#translationDirty) {
                this.#translation.set(this.data[12], this.data[13], this.data[14]);
                this.#translationDirty = false;
            }
            return this.#translation;
        }
        set translation(_translation) {
            this.mutate({ "translation": _translation });
        }
        /**
         * - get: return a vector representation of the rotation {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: effect the matrix
         */
        get rotation() {
            if (this.#rotationDirty) {
                let scaling = this.scaling;
                let s0 = this.data[0] / scaling.x;
                let s1 = this.data[1] / scaling.x;
                let s2 = this.data[2] / scaling.x;
                let s6 = this.data[6] / scaling.y;
                let s10 = this.data[10] / scaling.z;
                let sy = Math.hypot(s0, s1); // probably 2. param should be this.data[4] / scaling.y
                let singular = sy < 1e-6; // If
                let x1, y1, z1;
                let x2, y2, z2;
                if (!singular) {
                    x1 = Math.atan2(s6, s10);
                    y1 = Math.atan2(-s2, sy);
                    z1 = Math.atan2(s1, s0);
                    x2 = Math.atan2(-s6, -s10);
                    y2 = Math.atan2(-s2, -sy);
                    z2 = Math.atan2(-s1, -s0);
                    if (Math.abs(x2) + Math.abs(y2) + Math.abs(z2) < Math.abs(x1) + Math.abs(y1) + Math.abs(z1)) {
                        x1 = x2;
                        y1 = y2;
                        z1 = z2;
                    }
                }
                else {
                    x1 = Math.atan2(-this.data[9] / scaling.z, this.data[5] / scaling.y);
                    y1 = Math.atan2(-this.data[2] / scaling.x, sy);
                    z1 = 0;
                }
                this.#rotation.set(x1, y1, z1);
                this.#rotation.scale(FudgeCore.Calc.rad2deg);
                this.#rotationDirty = false;
            }
            return this.#rotation;
        }
        set rotation(_rotation) {
            this.mutate({ "rotation": _rotation });
        }
        /**
         * - get: return a vector representation of the scaling {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: effect the matrix
         */
        get scaling() {
            if (this.#scalingDirty) {
                this.#scaling.set(Math.hypot(this.data[0], this.data[1], this.data[2]), //* (this.data[0] < 0 ? -1 : 1),
                Math.hypot(this.data[4], this.data[5], this.data[6]), //* (this.data[5] < 0 ? -1 : 1),
                Math.hypot(this.data[8], this.data[9], this.data[10]) // * (this.data[10] < 0 ? -1 : 1)
                );
                // if (this.determinant < 0) // ‚ö†Ô∏èEXPERMINETAL from three js: if determinant is negative, invert one scale
                //   this.#scaling.x = -this.#scaling.x;
                this.#scalingDirty = false;
            }
            return this.#scaling;
        }
        set scaling(_scaling) {
            this.mutate({ "scaling": _scaling });
        }
        /**
         * - get: return a unit quaternion representing the rotation of this matrix.
         * **Caution!** Use immediately and readonly, since the quaternion is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: effect the matrix
         */
        get quaternion() {
            if (this.#quaternionDirty) {
                this.#quaternion.eulerAngles = this.rotation;
                this.#quaternionDirty = false;
            }
            return this.#quaternion;
        }
        set quaternion(_quaternion) {
            this.mutate({ "rotation": _quaternion });
        }
        /**
         * Returns the determinant of this matrix. Computational heavy operation, not cached so use with care.
         */
        get determinant() {
            const m = this.data;
            const det00 = m[10] * m[15] - m[11] * m[14];
            const det01 = m[9] * m[15] - m[11] * m[13];
            const det02 = m[9] * m[14] - m[10] * m[13];
            const det03 = m[8] * m[15] - m[11] * m[12];
            const det04 = m[8] * m[14] - m[10] * m[12];
            const det05 = m[8] * m[13] - m[9] * m[12];
            const det = m[0] * (m[5] * det00 - m[6] * det01 + m[7] * det02) -
                m[1] * (m[4] * det00 - m[6] * det03 + m[7] * det04) +
                m[2] * (m[4] * det01 - m[5] * det03 + m[7] * det05) -
                m[3] * (m[4] * det02 - m[5] * det04 + m[6] * det05);
            return det;
        }
        /**
         * Returns the normalized cardinal x-axis.
         */
        get right() {
            let right = this.getX();
            right.normalize();
            return right;
        }
        /**
         * Returns the normalized cardinal y-axis.
         */
        get up() {
            let up = this.getY();
            up.normalize();
            return up;
        }
        /**
         * Returns the normalized cardinal z-axis.
         */
        get forward() {
            let forward = this.getZ();
            forward.normalize();
            return forward;
        }
        /**
         * Creates and returns a clone of this matrix.
         */
        get clone() {
            return FudgeCore.Recycler.reuse(Matrix4x4).copy(this);
        }
        //#endregion
        /**
         * Resets the matrix to the identity-matrix and clears cache. Used by the recycler to reset.
         */
        recycle() {
            this.set([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
        }
        /**
         * Resets the matrix to the identity-matrix and clears cache.
         */
        reset() {
            this.recycle();
        }
        /**
         * Transpose this matrix
         */
        transpose() {
            let m = this.data;
            this.set([
                m[0], m[4], m[8], m[12],
                m[1], m[5], m[9], m[13],
                m[2], m[6], m[10], m[14],
                m[3], m[7], m[11], m[15]
            ]);
            return this;
        }
        /**
         * Invert this matrix
         */
        invert() {
            let m = this.data;
            let m00 = m[0 * 4 + 0];
            let m01 = m[0 * 4 + 1];
            let m02 = m[0 * 4 + 2];
            let m03 = m[0 * 4 + 3];
            let m10 = m[1 * 4 + 0];
            let m11 = m[1 * 4 + 1];
            let m12 = m[1 * 4 + 2];
            let m13 = m[1 * 4 + 3];
            let m20 = m[2 * 4 + 0];
            let m21 = m[2 * 4 + 1];
            let m22 = m[2 * 4 + 2];
            let m23 = m[2 * 4 + 3];
            let m30 = m[3 * 4 + 0];
            let m31 = m[3 * 4 + 1];
            let m32 = m[3 * 4 + 2];
            let m33 = m[3 * 4 + 3];
            let tmp0 = m22 * m33;
            let tmp1 = m32 * m23;
            let tmp2 = m12 * m33;
            let tmp3 = m32 * m13;
            let tmp4 = m12 * m23;
            let tmp5 = m22 * m13;
            let tmp6 = m02 * m33;
            let tmp7 = m32 * m03;
            let tmp8 = m02 * m23;
            let tmp9 = m22 * m03;
            let tmp10 = m02 * m13;
            let tmp11 = m12 * m03;
            let tmp12 = m20 * m31;
            let tmp13 = m30 * m21;
            let tmp14 = m10 * m31;
            let tmp15 = m30 * m11;
            let tmp16 = m10 * m21;
            let tmp17 = m20 * m11;
            let tmp18 = m00 * m31;
            let tmp19 = m30 * m01;
            let tmp20 = m00 * m21;
            let tmp21 = m20 * m01;
            let tmp22 = m00 * m11;
            let tmp23 = m10 * m01;
            let t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
                (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
            let t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
                (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
            let t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
                (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
            let t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
                (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
            let d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
            this.set([
                d * t0, // [0]
                d * t1, // [1]
                d * t2, // [2]
                d * t3, // [3]
                d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30)), // [4]
                d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30)), // [5]
                d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30)), // [6]
                d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20)), // [7]
                d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33)), // [8]
                d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33)), // [9]
                d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33)), // [10]
                d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23)), // [11]
                d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22)), // [12]
                d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02)), // [13]
                d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12)), // [14]
                d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02)) // [15]
            ]);
            return this;
        }
        //#region Translation
        /**
         * Adds a translation by the given {@link Vector3} to this matrix.
         * If _local is true, the translation occurs according to the current rotation and scaling of this matrix,
         * otherwise, it occurs according to the parent.
         */
        translate(_by, _local = true) {
            if (_local) {
                let mtxTranslation = Matrix4x4.TRANSLATION(_by);
                let rotationDirty = this.#rotationDirty; // preserve dirty flags for rotation and scaling as they are not affected by translation
                let scalingDirty = this.#scalingDirty;
                this.multiply(mtxTranslation);
                this.#rotationDirty = rotationDirty;
                this.#scalingDirty = scalingDirty;
                FudgeCore.Recycler.store(mtxTranslation);
            }
            else {
                this.data[12] += _by.x;
                this.data[13] += _by.y;
                this.data[14] += _by.z;
                this.mutator = null;
                this.#translationDirty = true;
                this.modified = true;
            }
            // const matrix: Matrix4x4 = Matrix4x4.MULTIPLICATION(this, Matrix4x4.TRANSLATION(_by));
            // // TODO: possible optimization, translation may alter mutator instead of deleting it.
            // this.set(matrix);
            // Recycler.store(matrix);
            return this;
        }
        /**
         * Adds a translation along the x-axis to this matrix.
         */
        translateX(_x, _local = true) {
            let translation = FudgeCore.Vector3.X(_x);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
            return this;
        }
        /**
         * Adds a translation along the y-axis to this matrix.
         */
        translateY(_y, _local = true) {
            let translation = FudgeCore.Vector3.Y(_y);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
            return this;
        }
        /**
         * Adds a translation along the z-axis to this matrix.
         */
        translateZ(_z, _local = true) {
            let translation = FudgeCore.Vector3.Z(_z);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
            return this;
        }
        //#endregion
        //#region Rotation
        /**
         * Rotates this matrix by given {@link Vector3} in the order Z, Y, X. Right hand rotation is used, thumb points in axis direction, fingers curling indicate rotation
         * The rotation is appended to already applied transforms, thus multiplied from the right. Set _fromLeft to true to switch and put it in front.
         */
        rotate(_by, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION(_by);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
            return this;
        }
        /**
         * Adds a rotation around the x-axis to this matrix.
         */
        rotateX(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_X(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
            return this;
        }
        /**
         * Adds a rotation around the y-axis to this matrix.
         */
        rotateY(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_Y(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
            return this;
        }
        /**
         * Adds a rotation around the z-axis to this matrix.
         */
        rotateZ(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_Z(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
            return this;
        }
        /**
         * Adjusts the rotation of this matrix to point the z-axis directly at the given target and tilts it to accord with the given up-{@link Vector3},
         * respectively calculating yaw and pitch. If no up-{@link Vector3} is given, the previous up-{@link Vector3} is used.
         * The pitch may be restricted to the up-vector to only calculate yaw.
         */
        lookAt(_target, _up, _restrict = false) {
            _up = _up ? FudgeCore.Vector3.NORMALIZATION(_up) : this.up;
            const mtxResult = Matrix4x4.LOOK_AT(this.translation, _target, _up, _restrict);
            mtxResult.scale(this.scaling);
            this.set(mtxResult.data);
            FudgeCore.Recycler.store(mtxResult);
            return this;
        }
        /**
         * Adjusts the rotation of this matrix to align the z-axis with the given direction and tilts it to accord with the given up-{@link Vector3}.
         * Up should be perpendicular to the given direction. If no up-vector is provided, {@link up} is used.
         */
        lookIn(_direction, _up = this.up, _restrict = false) {
            let zAxis = FudgeCore.Vector3.NORMALIZATION(_direction);
            let xAxis = FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(_up, zAxis));
            let yAxis = _restrict ? _up : FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(zAxis, xAxis));
            zAxis = _restrict ? FudgeCore.Vector3.NORMALIZATION(FudgeCore.Vector3.CROSS(xAxis, _up)) : zAxis;
            xAxis.scale(this.scaling.x);
            yAxis.scale(this.scaling.y);
            zAxis.scale(this.scaling.z);
            this.set([
                xAxis.x, xAxis.y, xAxis.z, 0,
                yAxis.x, yAxis.y, yAxis.z, 0,
                zAxis.x, zAxis.y, zAxis.z, 0,
                this.translation.x, this.translation.y, this.translation.z, 1
            ]);
            FudgeCore.Recycler.storeMultiple(xAxis, zAxis);
            return this;
        }
        /**
         * Same as {@link Matrix4x4.lookAt}, but optimized and needs testing
         */
        // TODO: testing lookat that really just rotates the matrix rather than creating a new one
        // public lookAtRotate(_target: Vector3, _up?: Vector3, _preserveScaling: boolean = true): void {
        //   if (!_up)
        //     _up = this.getY();
        //   let scaling: Vector3 = this.scaling;
        //   let difference: Vector3 = Vector3.DIFFERENCE(_target, this.translation);
        //   difference.normalize();
        //   let cos: number = Vector3.DOT(Vector3.NORMALIZATION(this.getZ()), difference);
        //   let sin: number = Vector3.DOT(Vector3.NORMALIZATION(this.getX()), difference);
        //   // console.log(sin, cos);
        //   let mtxRotation: Matrix4x4 = Recycler.get(Matrix4x4);
        //   mtxRotation.data.set([
        //     cos, 0, -sin, 0,
        //     0, 1, 0, 0,
        //     sin, 0, cos, 0,
        //     0, 0, 0, 1
        //   ]);
        //   this.multiply(mtxRotation, false);
        //   cos = Vector3.DOT(Vector3.NORMALIZATION(this.getZ()), difference);
        //   sin = -Vector3.DOT(Vector3.NORMALIZATION(this.getY()), difference);
        //   // console.log(sin, cos);
        //   mtxRotation.data.set([
        //     1, 0, 0, 0,
        //     0, cos, sin, 0,
        //     0, -sin, cos, 0,
        //     0, 0, 0, 1
        //   ]);
        //   this.multiply(mtxRotation, false);
        //   this.scaling = scaling;
        //   Recycler.store(mtxRotation);
        // }
        //#endregion
        //#region Scaling
        /**
         * Adds a scaling by the given {@link Vector3} to this matrix.
         */
        scale(_by, _fromLeft = false) {
            const mtxScaling = Matrix4x4.SCALING(_by);
            this.multiply(mtxScaling, _fromLeft);
            FudgeCore.Recycler.store(mtxScaling);
            return this;
        }
        /**
         * Adds a scaling along the x-axis to this matrix.
         */
        scaleX(_by) {
            let vector = FudgeCore.Recycler.reuse(FudgeCore.Vector3);
            vector.set(_by, 1, 1);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
            return this;
        }
        /**
         * Adds a scaling along the y-axis to this matrix.
         */
        scaleY(_by) {
            let vector = FudgeCore.Recycler.reuse(FudgeCore.Vector3);
            vector.set(1, _by, 1);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
            return this;
        }
        /**
         * Adds a scaling along the z-axis to this matrix.
         */
        scaleZ(_by) {
            let vector = FudgeCore.Recycler.reuse(FudgeCore.Vector3);
            vector.set(1, 1, _by);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
            return this;
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix by the given matrix.
         */
        multiply(_matrix, _fromLeft = false) {
            const mtxResult = _fromLeft ? Matrix4x4.PRODUCT(_matrix, this) : Matrix4x4.PRODUCT(this, _matrix);
            this.set(mtxResult.data);
            FudgeCore.Recycler.store(mtxResult);
            return this;
        }
        //#endregion
        //#region Transfer
        // public getEulerAnglesNew(): Vector3 {
        //   let scaling: Vector3 = this.scaling;
        //   let thetaX: number, thetaY: number, thetaZ: number;
        //   let r02: number = this.data[2] / scaling.z;
        //   let r11: number = this.data[5] / scaling.y;
        //   if (r02 < 1) {
        //     if (r02 > -1) {
        //       thetaY = Math.asin(-r02);
        //       thetaZ = Math.atan2(this.data[1] / scaling.y, this.data[0] / scaling.x);
        //       thetaX = Math.atan2(this.data[9] / scaling.z, this.data[10] / scaling.z);
        //     }
        //     else {
        //       thetaY = Math.PI / 2;
        //       thetaZ = -Math.atan2(this.data[6] / scaling.y, r11);
        //       thetaX = 0;
        //     }
        //   }
        //   else {
        //     thetaY = -Math.PI / 2;
        //     thetaZ = Math.atan2(-this.data[6] / scaling.y, r11);
        //     thetaX = 0;
        //   }
        //   this.#eulerAngles.set(-thetaX, thetaY, thetaZ);
        //   this.#eulerAngles.scale(Mathematic.rad2deg);
        //   return this.#eulerAngles;
        // }
        /**
         * Sets the elements of this matrix to the given array.
         */
        set(_array) {
            this.data.set(_array);
            this.resetCache();
            return this;
        }
        /**
         * Copies the state of the given matrix into this matrix.
         */
        copy(_original) {
            this.data.set(_original.data);
            this.mutator = null;
            this.modified = true;
            this.#translationDirty = _original.#translationDirty;
            this.#rotationDirty = _original.#rotationDirty;
            this.#scalingDirty = _original.#scalingDirty;
            this.#quaternionDirty = _original.#quaternionDirty;
            if (!this.#translationDirty)
                this.#translation.copy(_original.#translation);
            if (!this.#rotationDirty)
                this.#rotation.copy(_original.#rotation);
            if (!this.#scalingDirty)
                this.#scaling.copy(_original.#scaling);
            if (!this.#quaternionDirty)
                this.#quaternion.copy(_original.#quaternion);
            return this;
        }
        /**
         * Returns a formatted string representation of this matrix
         */
        toString() {
            return `∆í.Matrix4x4(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Returns an array of the elements of this matrix.
         */
        get() {
            // TODO: optimization, it shouldn't always return a copy, since this bloats memory
            return new Float32Array(this.data);
        }
        /**
         * Returns the original array of the elements of this matrix.
         */
        getData() {
            return this.data;
        }
        /**
         * Return cardinal x-axis
         */
        getX() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[0], this.data[1], this.data[2]);
            return result;
        }
        /**
         * Return cardinal y-axis
         */
        getY() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[4], this.data[5], this.data[6]);
            return result;
        }
        /**
         * Return cardinal z-axis
         */
        getZ() {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(this.data[8], this.data[9], this.data[10]);
            return result;
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapXY() {
            let temp = [this.data[0], this.data[1], this.data[2]]; // store x-axis
            this.data.set([this.data[4], this.data[5], this.data[6]], 0); // overwrite x-axis with y-axis
            this.data.set(temp, 4); // overwrite Y with temp
            this.data.set([-this.data[8], -this.data[9], -this.data[10]], 8); // reverse z-axis
            this.resetCache();
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapXZ() {
            let temp = [this.data[0], this.data[1], this.data[2]]; // store x-axis
            this.data.set([this.data[8], this.data[9], this.data[10]], 0); // overwrite x-axis with z-axis
            this.data.set(temp, 8); // overwrite Z with temp
            this.data.set([-this.data[4], -this.data[5], -this.data[6]], 4); // reverse y-axis
            this.resetCache();
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapYZ() {
            let temp = [this.data[4], this.data[5], this.data[6]]; // store y-axis
            this.data.set([this.data[8], this.data[9], this.data[10]], 4); // overwrite y-axis with z-axis
            this.data.set(temp, 8); // overwrite Z with temp
            this.data.set([-this.data[0], -this.data[1], -this.data[2]], 0); // reverse x-axis
            this.resetCache();
        }
        /**
         * Returns the tranlation from this matrix to the target matrix
         */
        getTranslationTo(_mtxTarget) {
            let difference = FudgeCore.Recycler.get(FudgeCore.Vector3);
            difference.set(_mtxTarget.data[12] - this.data[12], _mtxTarget.data[13] - this.data[13], _mtxTarget.data[14] - this.data[14]);
            return difference;
        }
        serialize() {
            // this.getMutator();
            let serialization = {
                translation: this.translation.serialize(),
                rotation: this.rotation.serialize(),
                scaling: this.scaling.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            let mutator = {
                translation: await this.translation.deserialize(_serialization.translation),
                rotation: await this.rotation.deserialize(_serialization.rotation),
                scaling: await this.scaling.deserialize(_serialization.scaling)
            };
            this.mutate(mutator);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation.getMutator(),
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        async mutate(_mutator) {
            const m = this.data;
            if (_mutator.translation) {
                let translation = this.translation;
                translation.mutate(_mutator.translation);
                m[12] = translation.x;
                m[13] = translation.y;
                m[14] = translation.z;
                this.#translationDirty = false;
            }
            if (_mutator.rotation || _mutator.scaling) {
                // TODO: make full vector and quaternion mutators mandatory?
                let rotation = _mutator.rotation?.w != undefined ?
                    this.#quaternion : // using this.#quaternion assumes we get a full quaternion mutator with x, y, z and w set so we never need to recalculate the quaternion here. This might cause trouble if we ever want to mutate only a part of a quaternion...
                    isFullVectorMutator(_mutator.rotation) ? this.#rotation : this.rotation; // hack to avoid unnecessary recalculation of rotation and scaling. This recalculation is unnecessary when we get a full mutator i.e. with x, y and z set
                let scaling = isFullVectorMutator(_mutator.scaling) ? this.#scaling : this.scaling;
                const isQuaternion = rotation instanceof FudgeCore.Quaternion;
                if (_mutator.rotation) {
                    rotation.mutate(_mutator.rotation);
                    if (isQuaternion)
                        rotation.normalize();
                }
                if (_mutator.scaling)
                    scaling.mutate(_mutator.scaling);
                Matrix4x4.setRotation(m, rotation);
                this.#rotationDirty = isQuaternion;
                this.#quaternionDirty = !isQuaternion;
                const sx = scaling.x, sy = scaling.y, sz = scaling.z;
                m[0] *= sx;
                m[1] *= sx;
                m[2] *= sx;
                m[4] *= sy;
                m[5] *= sy;
                m[6] *= sy;
                m[8] *= sz;
                m[9] *= sz;
                m[10] *= sz;
                this.#scalingDirty = false;
            }
            this.mutator = null;
            this.modified = true;
            function isFullVectorMutator(_mutator) {
                return _mutator && _mutator.x != undefined && _mutator.y != undefined && _mutator.z != undefined;
            }
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector3";
            if (_mutator.rotation)
                types.rotation = "Vector3";
            if (_mutator.scaling)
                types.scaling = "Vector3";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.#translationDirty = true;
            this.#rotationDirty = true;
            this.#quaternionDirty = true;
            this.#scalingDirty = true;
            this.modified = true;
            this.mutator = null;
        }
    }
    FudgeCore.Matrix4x4 = Matrix4x4;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for Noise2, Noise3 and Noise4
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
     */
    class Noise {
        constructor(_random = Math.random) {
            this.perm = new Uint8Array(512);
            this.permMod12 = new Uint8Array(512);
            const p = new Uint8Array(256);
            for (let i = 0; i < 256; i++)
                p[i] = i;
            let n;
            let q;
            for (let i = 255; i > 0; i--) {
                n = Math.floor((i + 1) * _random());
                q = p[i];
                p[i] = p[n];
                p[n] = q;
            }
            for (let i = 0; i < 512; i++) {
                this.perm[i] = p[i & 255];
                this.permMod12[i] = this.perm[i] % 12;
            }
        }
    }
    FudgeCore.Noise = Noise;
})(FudgeCore || (FudgeCore = {}));
///<reference path="./Noise.ts"/>
var FudgeCore;
///<reference path="./Noise.ts"/>
(function (FudgeCore) {
    /**
     * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
     * done by Jirka Dell'Oro-Friedl, HFU, 2021
     *
     * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
     * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
     * Better rank ordering method by Stefan Gustavson in 2012.
     *
     * This code was placed in the public domain by its original author,
     * Stefan Gustavson. You may use it as you see fit, but
     * attribution is appreciated.
     */
    class Noise2 extends FudgeCore.Noise {
        static { this.offset = (3.0 - Math.sqrt(3.0)) / 6.0; }
        static { this.gradient = [[1, 1], [-1, 1], [1, -1], [-1, -1], [1, 0], [-1, 0], [1, 0], [-1, 0], [0, 1], [0, -1], [0, 1], [0, -1]]; }
        #sample;
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y) => {
                return this.#sample(_x, _y);
            };
            this.#sample = (_x, _y) => {
                // Skew the input space to determine which simplex cell we're in
                const s = (_x + _y) * 0.5 * (Math.sqrt(3.0) - 1.0); // Hairy factor for 2D
                const i = Math.floor(_x + s);
                const j = Math.floor(_y + s);
                const t = (i + j) * Noise2.offset;
                const X0 = i - t; // Unskew the cell origin back to (x,y) space
                const Y0 = j - t;
                const x0 = _x - X0; // The x,y distances from the cell origin
                const y0 = _y - Y0;
                // Determine which simplex we are in.
                const i1 = x0 > y0 ? 1 : 0;
                const j1 = x0 > y0 ? 0 : 1;
                // Offset:numbers for corners
                const x1 = x0 - i1 + Noise2.offset;
                const y1 = y0 - j1 + Noise2.offset;
                const x2 = x0 - 1.0 + 2.0 * Noise2.offset;
                const y2 = y0 - 1.0 + 2.0 * Noise2.offset;
                // Work out the hashed gradient indices of the three simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const g0 = Noise2.gradient[this.permMod12[ii + this.perm[jj]]];
                const g1 = Noise2.gradient[this.permMod12[ii + i1 + this.perm[jj + j1]]];
                const g2 = Noise2.gradient[this.permMod12[ii + 1 + this.perm[jj + 1]]];
                // Calculate the contribution from the three corners
                const t0 = 0.5 - x0 * x0 - y0 * y0;
                const n0 = t0 < 0 ? 0.0 : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0);
                const t1 = 0.5 - x1 * x1 - y1 * y1;
                const n1 = t1 < 0 ? 0.0 : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1);
                const t2 = 0.5 - x2 * x2 - y2 * y2;
                const n2 = t2 < 0 ? 0.0 : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2);
                // Add contributions from each corner to get the final noise value.
                // The result is scaled to return values in the interval [-1, 1]
                return 70.14805770653952 * (n0 + n1 + n2);
            };
        }
    }
    FudgeCore.Noise2 = Noise2;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
     * done by Jirka Dell'Oro-Friedl, HFU, 2021
     *
     * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
     * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
     * Better rank ordering method by Stefan Gustavson in 2012.
     *
     * This code was placed in the public domain by its original author,
     * Stefan Gustavson. You may use it as you see fit, but
     * attribution is appreciated.
     */
    // TODO: Test
    class Noise3 extends FudgeCore.Noise {
        static { this.offset = 1.0 / 6.0; }
        static { this.gradient = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, -1], [0, 1, -1], [0, -1, -1]
        ]; }
        #sample;
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y, _z) => {
                return this.#sample(_x, _y, _z);
            };
            this.#sample = (_x, _y, _z) => {
                // Skew the input space to determine which simplex cell we're in
                const s = (_x + _y + _z) / 3.0; // Very nice and simple skew factor for 3D
                const i = Math.floor(_x + s);
                const j = Math.floor(_y + s);
                const k = Math.floor(_z + s);
                const t = (i + j + k) * Noise3.offset;
                const X0 = i - t; // Unskew the cell origin back to (x,y,z) space
                const Y0 = j - t;
                const Z0 = k - t;
                const x0 = _x - X0; // The x,y,z distances from the cell origin
                const y0 = _y - Y0;
                const z0 = _z - Z0;
                // Deterine which simplex we are in
                let i1, j1, k1 // Offsets for second corner of simplex in (i,j,k) coords
                ;
                let i2, j2, k2 // Offsets for third corner of simplex in (i,j,k) coords
                ;
                if (x0 >= y0) {
                    if (y0 >= z0) {
                        i1 = i2 = j2 = 1;
                        j1 = k1 = k2 = 0;
                    }
                    else if (x0 >= z0) {
                        i1 = i2 = k2 = 1;
                        j1 = k1 = j2 = 0;
                    }
                    else {
                        k1 = i2 = k2 = 1;
                        i1 = j1 = j2 = 0;
                    }
                }
                else {
                    if (y0 < z0) {
                        k1 = j2 = k2 = 1;
                        i1 = j1 = i2 = 0;
                    }
                    else if (x0 < z0) {
                        j1 = j2 = k2 = 1;
                        i1 = k1 = i2 = 0;
                    }
                    else {
                        j1 = i2 = j2 = 1;
                        i1 = k1 = k2 = 0;
                    }
                }
                const x1 = x0 - i1 + Noise3.offset; // Offsets for second corner in (x,y,z) coords
                const y1 = y0 - j1 + Noise3.offset;
                const z1 = z0 - k1 + Noise3.offset;
                const x2 = x0 - i2 + 2.0 * Noise3.offset; // Offsets for third corner in (x,y,z) coords
                const y2 = y0 - j2 + 2.0 * Noise3.offset;
                const z2 = z0 - k2 + 2.0 * Noise3.offset;
                const x3 = x0 - 1.0 + 3.0 * Noise3.offset; // Offsets for last corner in (x,y,z) coords
                const y3 = y0 - 1.0 + 3.0 * Noise3.offset;
                const z3 = z0 - 1.0 + 3.0 * Noise3.offset;
                // Work :numberut the hashed gradient indices of the four simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                const g0 = Noise3.gradient[this.permMod12[ii + this.perm[jj + this.perm[kk]]]];
                const g1 = Noise3.gradient[this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]]];
                const g2 = Noise3.gradient[this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]]];
                const g3 = Noise3.gradient[this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]]];
                // Calcu:numberate the contribution from the four corners
                const t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0;
                const n0 = t0 < 0
                    ? 0.0
                    : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0 + g0[2] * z0);
                const t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1;
                const n1 = t1 < 0
                    ? 0.0
                    : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1 + g1[2] * z1);
                const t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2;
                const n2 = t2 < 0
                    ? 0.0
                    : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2 + g2[2] * z2);
                const t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3;
                const n3 = t3 < 0
                    ? 0.0
                    : Math.pow(t3, 4) * (g3[0] * x3 + g3[1] * y3 + g3[2] * z3);
                // Add contributions from each corner to get the final noise value.
                // The result is scaled to stay just inside [-1,1]
                return 94.68493150681972 * (n0 + n1 + n2 + n3);
            };
        }
    }
    FudgeCore.Noise3 = Noise3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // TODO: Test
    /**
     * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
     * done by Jirka Dell'Oro-Friedl, HFU, 2021
     *
     * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
     * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
     * Better rank ordering method by Stefan Gustavson in 2012.
     *
     * This code was placed in the public domain by its original author,
     * Stefan Gustavson. You may use it as you see fit, but
     * attribution is appreciated.
     */
    class Noise4 extends FudgeCore.Noise {
        static { this.offset = (5.0 - Math.sqrt(5.0)) / 20.0; }
        static { this.gradient = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]]; }
        #sample;
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y, _z, _w) => {
                return this.#sample(_x, _y, _z, _w);
            };
            this.#sample = (_x, _y, _z, _w) => {
                // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
                const s = (_x + _y + _z + _w) * (Math.sqrt(5.0) - 1.0) / 4.0; // Factor for 4D skewing
                const i = Math.floor(_x + s);
                const j = Math.floor(_y + s);
                const k = Math.floor(_z + s);
                const l = Math.floor(_w + s);
                const t = (i + j + k + l) * Noise4.offset; // Factor for 4D unskewing
                const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
                const Y0 = j - t;
                const Z0 = k - t;
                const W0 = l - t;
                const x0 = _x - X0; // The x,y,z,w distances from the cell origin
                const y0 = _y - Y0;
                const z0 = _z - Z0;
                const w0 = _w - W0;
                // To find out which of the 24 possible simplices we're in, we need to determine the
                // magnitude ordering of x0, y0, z0 and w0. Six pair-wise comparisons are performed between
                // each possible pair of the four coordinates, and the results are used to rank the numbers.
                let rankx = 0;
                let ranky = 0;
                let rankz = 0;
                let rankw = 0;
                if (x0 > y0)
                    rankx++;
                else
                    ranky++;
                if (x0 > z0)
                    rankx++;
                else
                    rankz++;
                if (x0 > w0)
                    rankx++;
                else
                    rankw++;
                if (y0 > z0)
                    ranky++;
                else
                    rankz++;
                if (y0 > w0)
                    ranky++;
                else
                    rankw++;
                if (z0 > w0)
                    rankz++;
                else
                    rankw++;
                // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
                // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
                // impossible. Only the 24 indices which have non-zero entries make any sense.
                // We use a thresholding to set the coordinates in turn from the largest magnitude.
                // Rank 3 denotes the largest coordinate.
                const i1 = rankx >= 3 ? 1 : 0;
                const j1 = ranky >= 3 ? 1 : 0;
                const k1 = rankz >= 3 ? 1 : 0;
                const l1 = rankw >= 3 ? 1 : 0;
                // Rank : 2 denotes the second largest coordinate.
                const i2 = rankx >= 2 ? 1 : 0;
                const j2 = ranky >= 2 ? 1 : 0;
                const k2 = rankz >= 2 ? 1 : 0;
                const l2 = rankw >= 2 ? 1 : 0;
                // Rank : 1 denotes the second smallest coordinate.
                const i3 = rankx >= 1 ? 1 : 0;
                const j3 = ranky >= 1 ? 1 : 0;
                const k3 = rankz >= 1 ? 1 : 0;
                const l3 = rankw >= 1 ? 1 : 0;
                // The fifth corner has all coordinate offsets = 1, so no need to compute that.
                const x1 = x0 - i1 + Noise4.offset; // Offsets for second corner in (x,y,z,w) coords
                const y1 = y0 - j1 + Noise4.offset;
                const z1 = z0 - k1 + Noise4.offset;
                const w1 = w0 - l1 + Noise4.offset;
                const x2 = x0 - i2 + 2.0 * Noise4.offset; // Offsets for third corner in (x,y,z,w) coords
                const y2 = y0 - j2 + 2.0 * Noise4.offset;
                const z2 = z0 - k2 + 2.0 * Noise4.offset;
                const w2 = w0 - l2 + 2.0 * Noise4.offset;
                const x3 = x0 - i3 + 3.0 * Noise4.offset; // Offsets for fourth corner in (x,y,z,w) coords
                const y3 = y0 - j3 + 3.0 * Noise4.offset;
                const z3 = z0 - k3 + 3.0 * Noise4.offset;
                const w3 = w0 - l3 + 3.0 * Noise4.offset;
                const x4 = x0 - 1.0 + 4.0 * Noise4.offset; // Offsets for last corner in (x,y,z,w) coords
                const y4 = y0 - 1.0 + 4.0 * Noise4.offset;
                const z4 = z0 - 1.0 + 4.0 * Noise4.offset;
                const w4 = w0 - 1.0 + 4.0 * Noise4.offset;
                // Work out the hashed gradient indices of the five simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                const ll = l & 255;
                const g0 = Noise4.gradient[this.perm[ii + this.perm[jj + this.perm[kk + this.perm[ll]]]] %
                    32];
                const g1 = Noise4.gradient[this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1 + this.perm[ll + l1]]]] % 32];
                const g2 = Noise4.gradient[this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2 + this.perm[ll + l2]]]] % 32];
                const g3 = Noise4.gradient[this.perm[ii + i3 + this.perm[jj + j3 + this.perm[kk + k3 + this.perm[ll + l3]]]] % 32];
                const g4 = Noise4.gradient[this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1 + this.perm[ll + 1]]]] % 32];
                // Calculate the contribution from the five corners
                const t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
                const n0 = t0 < 0
                    ? 0.0
                    : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0 + g0[2] * z0 + g0[3] * w0);
                const t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
                const n1 = t1 < 0
                    ? 0.0
                    : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1 + g1[2] * z1 + g1[3] * w1);
                const t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
                const n2 = t2 < 0
                    ? 0.0
                    : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2 + g2[2] * z2 + g2[3] * w2);
                const t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
                const n3 = t3 < 0
                    ? 0.0
                    : Math.pow(t3, 4) * (g3[0] * x3 + g3[1] * y3 + g3[2] * z3 + g3[3] * w3);
                const t4 = 0.5 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
                const n4 = t4 < 0
                    ? 0.0
                    : Math.pow(t4, 4) * (g4[0] * x4 + g4[1] * y4 + g4[2] * z4 + g4[3] * w4);
                // Sum up and scale the result to cover the range [-1,1]
                return 72.37855765153665 * (n0 + n1 + n2 + n3 + n4);
            };
        }
    }
    FudgeCore.Noise4 = Noise4;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
      * Storing and manipulating rotations in the form of quaternions.
      * Constructed out of the 4 components: (x, y, z, w). Mathematical notation: w + xi + yj + zk.
      * A Quaternion can be described with an axis and angle: (x, y, z) = sin(angle/2)*axis; w = cos(angle/2).
      * roll: x, pitch: y, yaw: z. Note that operations are adapted to work with vectors where y is up and z is forward.
      * @authors Matthias Roming, HFU, 2023 | Marko Fehrenbach, HFU, 2020 | Jonas Plotzky, HFU, 2023
      */
    class Quaternion extends FudgeCore.Mutable {
        #eulerAngles; // euler angle representation of this quaternion in degrees.
        #eulerAnglesDirty;
        constructor(_x = 0, _y = 0, _z = 0, _w = 1) {
            super();
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.#eulerAngles = FudgeCore.Vector3.ZERO(); // euler angle representation of this quaternion in degrees.
            this.set(_x, _y, _z, _w);
        }
        /**
         * Retrieve a new identity quaternion
         */
        static IDENTITY() {
            const result = FudgeCore.Recycler.get(Quaternion);
            return result;
        }
        /**
         * Returns a quaternion which is a copy of the given quaternion scaled to length 1.
         */
        static NORMALIZATION(_q) {
            return _q.clone.normalize();
        }
        static ROTATION(_vector, _angleOrUp) {
            const result = FudgeCore.Recycler.get(Quaternion);
            if (_angleOrUp == undefined) {
                result.eulerAngles = _vector;
            }
            else if (typeof _angleOrUp == "number") {
                let halfAngle = _angleOrUp * FudgeCore.Calc.deg2rad / 2;
                let sinHalfAngle = Math.sin(halfAngle);
                result.set(_vector.x * sinHalfAngle, _vector.y * sinHalfAngle, _vector.z * sinHalfAngle, Math.cos(halfAngle));
            }
            else {
                const right = FudgeCore.Vector3.CROSS(_angleOrUp, _vector);
                const matrix = FudgeCore.Recycler.reuse(FudgeCore.Matrix4x4);
                matrix.set([
                    right.x, right.y, right.z, 0,
                    _angleOrUp.x, _angleOrUp.y, _angleOrUp.z, 0,
                    _vector.x, _vector.y, _vector.z, 0,
                    0, 0, 0, 1
                ]);
                result.copy(matrix.quaternion);
                FudgeCore.Recycler.storeMultiple(right, matrix);
            }
            return result;
        }
        /**
         * Computes and returns the product of two passed quaternions.
         */
        static PRODUCT(_qLeft, _qRight) {
            return _qLeft.clone.multiply(_qRight);
        }
        /**
         * Computes and returns the inverse of a passed quaternion.
         */
        static INVERSE(_q) {
            return _q.clone.invert();
        }
        /**
         * Computes and returns the conjugate of a passed quaternion.
         */
        static CONJUGATION(_q) {
            return _q.clone.conjugate();
        }
        /**
         * Returns the dot product of two quaternions.
         */
        static DOT(_q1, _q2) {
            return _q1.x * _q2.x + _q1.y * _q2.y + _q1.z * _q2.z + _q1.w * _q2.w;
        }
        /**
         * Returns the normalized linear interpolation between two quaternions based on the given _factor. When _factor is 0 the result is _from, when _factor is 1 the result is _to.
         */
        static LERP(_from, _to, _factor) {
            let result = FudgeCore.Recycler.get(Quaternion);
            result.set((_from.x * (1 - _factor) + _to.x * _factor), (_from.y * (1 - _factor) + _to.y * _factor), (_from.z * (1 - _factor) + _to.z * _factor), (_from.w * (1 - _factor) + _to.w * _factor));
            result.normalize();
            return result;
        }
        /**
         * Returns the spherical linear interpolation between two quaternions based on the given _factor. When _factor is 0 the result is _from, when _factor is 1 the result is _to.
         */
        static SLERP(_from, _to, _factor) {
            // From: https://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            const result = FudgeCore.Recycler.reuse(Quaternion);
            let cosHalfTheta = _from.w * _to.w + _from.x * _to.x + _from.y * _to.y + _from.z * _to.z;
            if (Math.abs(cosHalfTheta) >= 1)
                return result.copy(_from);
            let halfTheta = Math.acos(cosHalfTheta);
            let sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
            if (Math.abs(sinHalfTheta) < 0.001) {
                result.set((_from.x * 0.5 + _to.x * 0.5), (_from.y * 0.5 + _to.y * 0.5), (_from.z * 0.5 + _to.z * 0.5), (_from.w * 0.5 + _to.w * 0.5));
                return result;
            }
            let ratioA = Math.sin((1 - _factor) * halfTheta) / sinHalfTheta;
            let ratioB = Math.sin(_factor * halfTheta) / sinHalfTheta;
            result.set((_from.x * ratioA + _to.x * ratioB), (_from.y * ratioA + _to.y * ratioB), (_from.z * ratioA + _to.z * ratioB), (_from.w * ratioA + _to.w * ratioB));
            return result;
        }
        /**
         * Negates the given quaternion.
         */
        static negate(_q) {
            _q.x = -_q.x;
            _q.y = -_q.y;
            _q.z = -_q.z;
            _q.w = -_q.w;
        }
        /**
         * Creates and returns a clone of this quaternion.
         */
        get clone() {
            let result = FudgeCore.Recycler.reuse(Quaternion);
            result.copy(this);
            return result;
        }
        /**
         * - get: return the euler angle representation of the rotation in degrees.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: set the euler angle representation of the rotation in degrees.
         */
        get eulerAngles() {
            if (this.#eulerAnglesDirty) {
                this.#eulerAnglesDirty = false;
                if (this.x == 0 && this.y == 0 && this.z == 0 && this.w == 1) {
                    this.#eulerAngles.set(0, 0, 0);
                    return this.#eulerAngles;
                }
                // roll (x-axis rotation)
                let sinrcosp = 2 * (this.w * this.x + this.y * this.z);
                let cosrcosp = 1 - 2 * (this.x * this.x + this.y * this.y);
                this.#eulerAngles.x = Math.atan2(sinrcosp, cosrcosp);
                // pitch (y-axis rotation)
                let sinp = 2 * (this.w * this.y - this.z * this.x);
                if (Math.abs(sinp) >= 1)
                    this.#eulerAngles.y = sinp < 0 ? -Math.abs(Math.PI / 2) : Math.abs(Math.PI / 2); // use 90 degrees if out of range
                else
                    this.#eulerAngles.y = Math.asin(sinp);
                // yaw (z-axis rotation)
                let sinycosp = 2 * (this.w * this.z + this.x * this.y);
                let cosycosp = 1 - 2 * (this.y * this.y + this.z * this.z);
                this.#eulerAngles.z = Math.atan2(sinycosp, cosycosp);
                this.#eulerAngles.scale(FudgeCore.Calc.rad2deg);
            }
            return this.#eulerAngles;
        }
        set eulerAngles(_eulerAngles) {
            const halfAnglesInRadians = FudgeCore.Vector3.SCALE(_eulerAngles, FudgeCore.Calc.deg2rad / 2);
            const cosX = Math.cos(halfAnglesInRadians.x);
            const cosY = Math.cos(halfAnglesInRadians.y);
            const cosZ = Math.cos(halfAnglesInRadians.z);
            const sinX = Math.sin(halfAnglesInRadians.x);
            const sinY = Math.sin(halfAnglesInRadians.y);
            const sinZ = Math.sin(halfAnglesInRadians.z);
            this.set(sinX * cosY * cosZ - cosX * sinY * sinZ, cosX * sinY * cosZ + sinX * cosY * sinZ, cosX * cosY * sinZ - sinX * sinY * cosZ, cosX * cosY * cosZ + sinX * sinY * sinZ);
            this.#eulerAngles.copy(_eulerAngles);
            this.#eulerAnglesDirty = false;
            FudgeCore.Recycler.store(halfAnglesInRadians);
        }
        /**
         * Normalizes this quaternion to a length of 1 (a unit quaternion) making it a valid rotation representation
         */
        normalize() {
            let length = Math.sqrt(this.x ** 2 + this.y ** 2 + this.z ** 2 + this.w ** 2);
            this.x /= length;
            this.y /= length;
            this.z /= length;
            this.w /= length;
            this.resetCache();
            return this;
        }
        /**
         * Negate this quaternion and returns it
         */
        negate() {
            this.x *= -1;
            this.y *= -1;
            this.z *= -1;
            this.w *= -1;
            this.resetCache();
            return this;
        }
        /**
         * Resets the quaternion to the identity-quaternion and clears cache. Used by the recycler to reset.
         */
        recycle() {
            this.set(0, 0, 0, 1);
        }
        /**
         * Invert this quaternion.
         */
        invert() {
            // quaternion is assumed to have unit length
            return this.conjugate();
        }
        /**
         * Conjugates this quaternion and returns it.
         */
        conjugate() {
            this.x *= -1;
            this.y *= -1;
            this.z *= -1;
            this.resetCache();
            return this;
        }
        /**
         * Rotates this quaternion around the given axis by the given angle.
         * The rotation is appended to already applied rotations, thus multiplied from the right. Set _fromLeft to true to switch and put it in front.
         */
        rotate(_axis, _angle, _fromLeft = false) {
            const rotation = Quaternion.ROTATION(_axis, _angle);
            this.multiply(rotation, _fromLeft);
            FudgeCore.Recycler.store(rotation);
            return this;
        }
        /**
         * Multiply this quaternion with the given quaternion
         */
        multiply(_other, _fromLeft = false) {
            const a = _fromLeft ? _other : this;
            const b = _fromLeft ? this : _other;
            // from: http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
            const ax = a.x;
            const ay = a.y;
            const az = a.z;
            const aw = a.w;
            const bx = b.x;
            const by = b.y;
            const bz = b.z;
            const bw = b.w;
            this.set(ax * bw + ay * bz - az * by + aw * bx, -ax * bz + ay * bw + az * bx + aw * by, ax * by - ay * bx + az * bw + aw * bz, -ax * bx - ay * by - az * bz + aw * bw);
            return this;
        }
        /**
         * Sets the components of this quaternion.
         */
        set(_x, _y, _z, _w) {
            this.x = _x;
            this.y = _y;
            this.z = _z;
            this.w = _w;
            this.resetCache();
            return this;
        }
        /**
         * Copies the state of the given quaternion into this quaternion.
         */
        copy(_original) {
            this.x = _original.x;
            this.y = _original.y;
            this.z = _original.z;
            this.w = _original.w;
            this.#eulerAnglesDirty = _original.#eulerAnglesDirty;
            if (!this.#eulerAnglesDirty)
                this.#eulerAngles.copy(_original.#eulerAngles);
            this.mutator = null;
            return this;
        }
        /**
         * Returns a formatted string representation of this quaternion
         */
        toString() {
            return `∆í.Quaternion(x: ${this.x}, y: ${this.y}, z: ${this.z}, w: ${this.w})`;
        }
        // currently quaternions are never serialized, so this is not needed. But maybe it will be in the future.
        serialize() {
            let serialization = this.getMutator();
            serialization.toJSON = () => { return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.x, this.y, this.z, this.w] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        getMutator() {
            if (!this.mutator)
                this.mutator = { x: this.x, y: this.y, z: this.z, w: this.w };
            return this.mutator;
        }
        async mutate(_mutator) {
            this.x = _mutator.x ?? this.x;
            this.y = _mutator.y ?? this.y;
            this.z = _mutator.z ?? this.z;
            this.w = _mutator.w ?? this.w;
            this.resetCache();
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.#eulerAnglesDirty = true;
            this.mutator = null;
        }
    }
    FudgeCore.Quaternion = Quaternion;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Class for creating random values, supporting Javascript's Math.random and a deterministig pseudo-random number generator (PRNG)
     * that can be fed with a seed and then returns a reproducable set of random numbers (if the precision of Javascript allows)
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Random {
        static { this.default = new Random(); }
        /**
         * Create an instance of {@link Random}.
         * If a seed is given, LFIB4 is used as generator, reproducing a series of numbers from that seed.
         * If a function producing values between 0 and 1 is given, it will be used as generator.
         */
        constructor(_seedOrFunction) {
            this.generate = Math.random;
            if (_seedOrFunction instanceof Function)
                this.generate = _seedOrFunction;
            else if (_seedOrFunction == undefined)
                this.generate = Math.random;
            else
                //@ts-ignore
                this.generate = new FudgeCore.LFIB4(_seedOrFunction);
        }
        /**
         * Returns a normed random number, thus in the range of [0, 1[
         */
        getNorm() {
            return this.generate();
        }
        /**
         * Returns a random number in the range of given [_min, _max[
         */
        getRange(_min, _max) {
            return _min + this.generate() * (_max - _min);
        }
        /**
         * Returns a random integer number in the range of given floored [_min, _max[
         */
        getRangeFloored(_min, _max) {
            return Math.floor(this.getRange(_min, _max));
        }
        /**
         * Returns true or false randomly
         */
        getBoolean() {
            return this.generate() < 0.5;
        }
        /**
         * Returns -1 or 1 randomly
         */
        getSign() {
            return this.getBoolean() ? 1 : -1;
        }
        /**
         * Returns a randomly selected index into the given array
         */
        getIndex(_array) {
            if (_array.length > 0)
                return this.getRangeFloored(0, _array.length);
            return -1;
        }
        /**
         * Returns a randomly selected element of the given array
         */
        getElement(_array) {
            if (_array.length > 0)
                return _array[this.getIndex(_array)];
            return null;
        }
        /**
         * Removes a randomly selected element from the given array and returns it
         */
        splice(_array) {
            return _array.splice(this.getIndex(_array), 1)[0];
        }
        /**
         * Returns a randomly selected key from the given Map-instance
         */
        getKey(_map) {
            let keys = Array.from(_map.keys());
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a randomly selected property name from the given object
         */
        getPropertyName(_object) {
            let keys = Object.getOwnPropertyNames(_object);
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a randomly selected symbol from the given object, if symbols are used as keys
         */
        getPropertySymbol(_object) {
            let keys = Object.getOwnPropertySymbols(_object);
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a random three-dimensional vector in the limits of the box defined by the vectors given as [_corner0, _corner1[
         */
        getVector3(_corner0, _corner1) {
            return new FudgeCore.Vector3(this.getRange(_corner0.x, _corner1.x), this.getRange(_corner0.y, _corner1.y), this.getRange(_corner0.z, _corner1.z));
        }
        /**
         * Returns a random two-dimensional vector in the limits of the rectangle defined by the vectors given as [_corner0, _corner1[
         */
        getVector2(_corner0, _corner1) {
            return new FudgeCore.Vector2(this.getRange(_corner0.x, _corner1.x), this.getRange(_corner0.y, _corner1.y));
        }
        /**
         * Returns a color with its r, g, b values set to random numbers in the range of [0, 1[.
         */
        getColor() {
            return new FudgeCore.Color(this.getNorm(), this.getNorm(), this.getNorm(), 1);
        }
    }
    FudgeCore.Random = Random;
    /**
     * Standard {@link Random}-instance using Math.random().
     */
    FudgeCore.random = new Random();
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a threedimensional vector comprised of the components x, y and z
     * ```text
     *            +y
     *             |__ +x
     *            /
     *          +z
     * ```
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019-2022 | Jonas Plotzky, HFU, 2023
     */
    class Vector3 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _z = 0) {
            super();
            this.set(_x, _y, _z);
        }
        //#region Static
        /**
         * Creates and returns a vector with the given length pointing in x-direction
         */
        static X(_scale = 1) {
            const vector = FudgeCore.Recycler.reuse(Vector3);
            vector.set(_scale, 0, 0);
            return vector;
        }
        /**
         * Creates and returns a vector with the given length pointing in y-direction
         */
        static Y(_scale = 1) {
            const vector = FudgeCore.Recycler.reuse(Vector3);
            vector.set(0, _scale, 0);
            return vector;
        }
        /**
         * Creates and returns a vector with the given length pointing in z-direction
         */
        static Z(_scale = 1) {
            const vector = FudgeCore.Recycler.reuse(Vector3);
            vector.set(0, 0, _scale);
            return vector;
        }
        /**
         * Creates and returns a vector with the value 0 on each axis
         */
        static ZERO() {
            const vector = FudgeCore.Recycler.reuse(Vector3);
            vector.set(0, 0, 0); // should be set to 0 by recycler already?
            return vector;
        }
        /**
         * Creates and returns a vector of the given size on each of the three axis
         */
        static ONE(_scale = 1) {
            const vector = FudgeCore.Recycler.reuse(Vector3);
            vector.set(_scale, _scale, _scale);
            return vector;
        }
        /**
         * Creates and returns a vector through transformation of the given vector by the given matrix or rotation quaternion.
         */
        static TRANSFORMATION(_vector, _transform, _includeTranslation = true) {
            const result = FudgeCore.Recycler.reuse(Vector3);
            if (_transform instanceof FudgeCore.Matrix4x4) {
                let m = _transform.get();
                result.set(m[0] * _vector.x + m[4] * _vector.y + m[8] * _vector.z, m[1] * _vector.x + m[5] * _vector.y + m[9] * _vector.z, m[2] * _vector.x + m[6] * _vector.y + m[10] * _vector.z);
                if (_includeTranslation)
                    result.add(_transform.translation);
            }
            else {
                // From: https://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/index.htm
                // result = q * quaternion(vector.x, vector.y, vector.z, 0) * conj(q)
                // q * quaternion(vector.x, vector.y, vector.z, 0) ...
                const qx = _transform.w * _vector.x + _transform.y * _vector.z - _transform.z * _vector.y;
                const qy = _transform.w * _vector.y + _transform.z * _vector.x - _transform.x * _vector.z;
                const qz = _transform.w * _vector.z + _transform.x * _vector.y - _transform.y * _vector.x;
                const qw = -_transform.x * _vector.x - _transform.y * _vector.y - _transform.z * _vector.z;
                // ... * conj(q)
                result.set(qx * _transform.w + qw * -_transform.x + qy * -_transform.z - qz * -_transform.y, qy * _transform.w + qw * -_transform.y + qz * -_transform.x - qx * -_transform.z, qz * _transform.w + qw * -_transform.z + qx * -_transform.y - qy * -_transform.x);
            }
            return result;
        }
        /**
         * Creates and returns a vector which is a copy of the given vector scaled to the given length
         */
        static NORMALIZATION(_vector, _length = 1) {
            let magnitudeSquared = _vector.magnitudeSquared;
            if (magnitudeSquared == 0)
                throw (new RangeError("Impossible normalization"));
            let vector = _vector.clone;
            vector.scale(_length / Math.sqrt(magnitudeSquared));
            return vector;
        }
        /**
         * Returns the resulting vector attained by addition of all given vectors.
         */
        static SUM(..._vectors) {
            let result = FudgeCore.Recycler.get(Vector3);
            for (let vector of _vectors)
                result.set(result.x + vector.x, result.y + vector.y, result.z + vector.z);
            return result;
        }
        /**
         * Returns the result of the subtraction of two vectors.
         */
        static DIFFERENCE(_minuend, _subtrahend) {
            let vector = FudgeCore.Recycler.reuse(Vector3);
            vector.set(_minuend.x - _subtrahend.x, _minuend.y - _subtrahend.y, _minuend.z - _subtrahend.z);
            return vector;
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor
         */
        static SCALE(_vector, _scaling) {
            let scaled = FudgeCore.Recycler.reuse(Vector3);
            scaled.set(_vector.x * _scaling, _vector.y * _scaling, _vector.z * _scaling);
            return scaled;
        }
        /**
         * Computes the crossproduct of 2 vectors.
         */
        static CROSS(_a, _b) {
            let vector = FudgeCore.Recycler.reuse(Vector3);
            vector.set(_a.y * _b.z - _a.z * _b.y, _a.z * _b.x - _a.x * _b.z, _a.x * _b.y - _a.y * _b.x);
            return vector;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         */
        static DOT(_a, _b) {
            return _a.x * _b.x + _a.y * _b.y + _a.z * _b.z;
            ;
        }
        /**
         * Calculates and returns the reflection of the incoming vector at the given normal vector. The length of normal should be 1.
         *     __________________
         *           /|\
         * incoming / | \ reflection
         *         /  |  \
         *          normal
         *
         */
        static REFLECTION(_incoming, _normal) {
            let dot = -Vector3.DOT(_incoming, _normal);
            let reflection = Vector3.SUM(_incoming, Vector3.SCALE(_normal, 2 * dot));
            return reflection;
        }
        /**
         * Divides the dividend by the divisor component by component and returns the result
         */
        static RATIO(_dividend, _divisor) {
            let vector = FudgeCore.Recycler.reuse(Vector3);
            vector.set(_dividend.x / _divisor.x, _dividend.y / _divisor.y, _dividend.z / _divisor.z);
            return vector;
        }
        /**
         * Creates a cartesian vector from geographic coordinates
         */
        static GEO(_longitude = 0, _latitude = 0, _magnitude = 1) {
            let vector = FudgeCore.Recycler.reuse(Vector3);
            let geo = FudgeCore.Recycler.reuse(FudgeCore.Geo3);
            geo.set(_longitude, _latitude, _magnitude);
            vector.geo = geo;
            FudgeCore.Recycler.store(geo);
            return vector;
        }
        /**
         * Return the angle in degrees between the two given vectors
         */
        static ANGLE(_from, _to) {
            let angle = Math.acos(FudgeCore.Calc.clamp(Vector3.DOT(_from, _to) / (_from.magnitude * _to.magnitude), -1, 1)); // clamp because of floating point errors when from == to
            return angle * FudgeCore.Calc.rad2deg;
        }
        /**
         * Return the projection of a onto b
         */
        static PROJECTION(_a, _b) {
            return _a.clone.project(_b);
        }
        /**
         * Returns the linear interpolation of two vectors. Clamps the factor between 0 and 1.
         */
        static LERP(_a, _b, _factor) {
            _factor = FudgeCore.Calc.clamp(_factor, 0, 1);
            let vector = FudgeCore.Recycler.reuse(Vector3);
            vector.set(_a.x + (_b.x - _a.x) * _factor, _a.y + (_b.y - _a.y) * _factor, _a.z + (_b.z - _a.z) * _factor);
            return vector;
        }
        /**
         * Smoothly interpolates between two vectors based on a critically damped spring model.
         * Allows to smooth toward a moving target with an ease-in/ease-out motion maintaining a continuous velocity.
         * Does not overshoot.
         * @param _current - The current value.
         * @param _target - The target value.
         * @param _velocity - The velocity at which the value is moving. This value is **modified** by the function and must be maintained in the outside context.
         * @param _smoothTime - The time it would take for the value to reach the target if it were moving at maximum velocity for the entire duration. When following a moving target the smooth time equals the lag time allowing to calculate the `lag distance = target velocity * smooth time`.
         * @param _timeFrame - The elapsed time since the last call to the function.
         * @param _maxSpeed - An optional maximum speed that limits the velocity of the value. Defaults to Infinity.
         * @source from Andrew Kirmse, Game Programming Gems 4, Chapter 1.10
         */
        static SMOOTHDAMP(_current, _target, _velocity, _smoothTime, _timeFrame, _maxSpeed = Infinity) {
            const omega = 2 / _smoothTime;
            const x = omega * _timeFrame;
            const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x); // approximation of e ^ -omega * timeFrame
            const change = Vector3.DIFFERENCE(_current, _target); // c = from - to  | to = from - c
            const maxChange = _maxSpeed * _smoothTime;
            const magnitudeSquared = change.magnitudeSquared;
            if (magnitudeSquared > maxChange * maxChange) {
                change.scale(maxChange / Math.sqrt(magnitudeSquared));
                _target = Vector3.DIFFERENCE(_current, change);
            }
            // TODO: maybe optimize this...
            const scaleChange = Vector3.SCALE(change, omega);
            const sumVelocityScaleChange = Vector3.SUM(_velocity, scaleChange);
            const temp = Vector3.SCALE(sumVelocityScaleChange, _timeFrame);
            const scaleTemp = Vector3.SCALE(temp, omega);
            const differenceVelocityScaleTemp = Vector3.DIFFERENCE(_velocity, scaleTemp);
            const scaleDifferenceVelocityScaleTemp = Vector3.SCALE(differenceVelocityScaleTemp, exp);
            _velocity.copy(scaleDifferenceVelocityScaleTemp);
            const sumChangeTemp = Vector3.SUM(change, temp);
            const scaleSumChangeTempExp = Vector3.SCALE(sumChangeTemp, exp);
            const result = Vector3.SUM(_target, scaleSumChangeTempExp);
            // without recycling...
            // const temp: Vector3 = Vector3.SCALE(Vector3.SUM(_velocity, Vector3.SCALE(change, omega)), _timeFrame);
            // _velocity.copy(Vector3.SCALE(Vector3.DIFFERENCE(_velocity, Vector3.SCALE(temp, omega)), exp));
            // const result: Vector3 = Vector3.SUM(_target, Vector3.SCALE(Vector3.SUM(change, temp), exp));
            FudgeCore.Recycler.storeMultiple(scaleChange, sumVelocityScaleChange, temp, scaleTemp, differenceVelocityScaleTemp, scaleDifferenceVelocityScaleTemp, sumChangeTemp, scaleSumChangeTempExp);
            return result;
        }
        //#endregion
        //#region Accessors
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.hypot(this.x, this.y, this.z);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector3.DOT(this, this);
        }
        /**
         * - get: returns a geographic representation of this vector
         * - set: adjust the cartesian values of this vector to represent the given as geographic coordinates
         */
        set geo(_geo) {
            this.set(0, 0, _geo.magnitude);
            this.transform(FudgeCore.Matrix4x4.ROTATION_X(-_geo.latitude));
            this.transform(FudgeCore.Matrix4x4.ROTATION_Y(_geo.longitude));
        }
        get geo() {
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo3);
            geo.magnitude = this.magnitude;
            if (geo.magnitude === 0)
                return geo;
            geo.longitude = 180 * Math.atan2(this.x / geo.magnitude, this.z / geo.magnitude) / Math.PI;
            geo.latitude = 180 * Math.asin(this.y / geo.magnitude) / Math.PI;
            return geo;
        }
        /**
         * Creates and returns a clone of this vector.
         */
        get clone() {
            return FudgeCore.Recycler.reuse(Vector3).copy(this);
        }
        //#endregion
        /**
         * Copies the components of the given vector into this vector.
         */
        copy(_original) {
            return this.set(_original.x, _original.y, _original.z);
        }
        recycle() {
            this.set(0, 0, 0);
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            if (Math.abs(this.z - _compare.z) > _tolerance)
                return false;
            return true;
        }
        /**
         * Returns true if the position described by this is within a cube with the opposite corners 1 and 2
         */
        isInsideCube(_corner1, _corner2) {
            let diagonal = Vector3.DIFFERENCE(_corner2, _corner1);
            let relative = Vector3.DIFFERENCE(this, _corner1);
            let ratio = Vector3.RATIO(relative, diagonal);
            if (ratio.x > 1 || ratio.x < 0)
                return false;
            if (ratio.y > 1 || ratio.y < 0)
                return false;
            if (ratio.z > 1 || ratio.z < 0)
                return false;
            return true;
        }
        /**
         * Returns true if the position described by this is within a sphere with the given center and radius
         */
        isInsideSphere(_center, _radius) {
            let difference = Vector3.DIFFERENCE(this, _center);
            return difference.magnitudeSquared < (_radius * _radius);
        }
        /**
         * Adds the given vector to this vector.
         */
        add(_addend) {
            this.x += _addend.x;
            this.y += _addend.y;
            this.z += _addend.z;
            return this;
        }
        /**
         * Subtracts the given vector from this vector.
         */
        subtract(_subtrahend) {
            this.x -= _subtrahend.x;
            this.y -= _subtrahend.y;
            this.z -= _subtrahend.z;
            return this;
        }
        /**
         * Scales this vector by the given scalar.
         */
        scale(_scalar) {
            this.x *= _scalar;
            this.y *= _scalar;
            this.z *= _scalar;
            return this;
        }
        /**
         * Normalizes this to the given length, 1 by default
         */
        normalize(_length = 1) {
            return this.copy(Vector3.NORMALIZATION(this, _length));
        }
        /**
         * Negates this vector by flipping the signs of its components
         */
        negate() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        }
        /**
         * Projects this vector onto the given vector
         */
        project(_on) {
            let scalar = Vector3.DOT(this, _on) / _on.magnitudeSquared;
            this.x = _on.x * scalar;
            this.y = _on.y * scalar;
            this.z = _on.z * scalar;
            return this;
        }
        /**
         * Sets the components of this vector and returns it.
         */
        set(_x = 0, _y = 0, _z = 0) {
            this.x = _x;
            this.y = _y;
            this.z = _z;
            return this;
        }
        /**
         * Returns an array of the components of this vector.
         */
        get() {
            return new Float32Array([this.x, this.y, this.z]);
        }
        /**
         * Transforms this vector by the given matrix or rotation quaternion.
         * Including or exluding the translation if a matrix is passed.
         * Including is the default, excluding will only rotate and scale this vector.
         */
        transform(_transform, _includeTranslation = true) {
            let transformed = Vector3.TRANSFORMATION(this, _transform, _includeTranslation);
            this.copy(transformed);
            FudgeCore.Recycler.store(transformed);
            return this;
        }
        /**
         * Drops the z-component and returns a Vector2 consisting of the x- and y-components
         */
        toVector2() {
            return new FudgeCore.Vector2(this.x, this.y);
        }
        /**
         * Reflects this vector at a given normal. See {@link Vector3.REFLECTION}
         */
        reflect(_normal) {
            const reflected = Vector3.REFLECTION(this, _normal);
            this.set(reflected.x, reflected.y, reflected.z);
            FudgeCore.Recycler.store(reflected);
            return this;
        }
        /**
         * Shuffles the components of this vector
         */
        shuffle() {
            let a = [this.x, this.y, this.z];
            this.set(FudgeCore.Random.default.splice(a), FudgeCore.Random.default.splice(a), a[0]);
            return this;
        }
        /**
         * Returns the distance bewtween this vector and the given vector
         */
        getDistance(_to) {
            let difference = Vector3.DIFFERENCE(this, _to);
            FudgeCore.Recycler.store(difference);
            return difference.magnitude;
        }
        /**
         * For each dimension, moves the component to the minimum of this and the given vector
         */
        min(_compare) {
            this.x = Math.min(this.x, _compare.x);
            this.y = Math.min(this.y, _compare.y);
            this.z = Math.min(this.z, _compare.z);
            return this;
        }
        /**
         * For each dimension, moves the component to the maximum of this and the given vector
         */
        max(_compare) {
            this.x = Math.max(this.x, _compare.x);
            this.y = Math.max(this.y, _compare.y);
            this.z = Math.max(this.z, _compare.z);
            return this;
        }
        /**
         * Uses the standard array.map functionality to perform the given function on all components of this vector
         * and return a new vector with the results
         */
        map(_function) {
            let copy = FudgeCore.Recycler.get(Vector3);
            copy.set(...[this.x, this.y, this.z].map(_function));
            return copy;
        }
        /**
         * Applies the given function to all components of this vector (modifying it) and returns it.
         */
        apply(_function) {
            this.x = _function(this.x, 0, "x");
            this.y = _function(this.y, 1, "y");
            this.z = _function(this.z, 2, "z");
            return this;
        }
        /**
         * Returns a formatted string representation of this vector
         */
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)}, ${this.z.toPrecision(5)})`;
            return result;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator();
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.x}, ${this.y}, ${this.z}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.x, this.y, this.z] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        async mutate(_mutator) {
            if (_mutator.x !== undefined)
                this.x = _mutator.x;
            if (_mutator.y !== undefined)
                this.y = _mutator.y;
            if (_mutator.z !== undefined)
                this.z = _mutator.z;
        }
        getMutator() {
            let mutator = { x: this.x, y: this.y, z: this.z };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector3 = Vector3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a fourdimensional vector comprised of the components x, y, z and w.
     * @authors Jonas Plotzky, HFU, 2023
     */
    class Vector4 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _z = 0, _w = 0) {
            super();
            this.set(_x, _y, _z, _w);
        }
        /**
         * The magnitude (length) of the vector.
         */
        get magnitude() {
            return Math.hypot(this.x, this.y, this.z, this.w);
        }
        /**
         * The squared magnitude (length) of the vector. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return this.dot(this);
        }
        /**
         * Creates and returns a clone of this vector.
         */
        get clone() {
            return FudgeCore.Recycler.reuse(Vector4).copy(this);
        }
        /**
         * Copies the components of the given vector into this vector.
         */
        copy(_original) {
            return this.set(_original.x, _original.y, _original.z, _original.w);
        }
        /**
         * Sets the components of this vector and returns it.
         */
        set(_x, _y, _z, _w) {
            this.x = _x;
            this.y = _y;
            this.z = _z;
            this.w = _w;
            return this;
        }
        /**
         * Returns an array of the components of this vector.
         */
        get() {
            return [this.x, this.y, this.z, this.w];
        }
        /**
         * Adds the given vector to this vector.
         */
        add(_addend) {
            this.x += _addend.x;
            this.y += _addend.y;
            this.z += _addend.z;
            this.w += _addend.w;
            return this;
        }
        /**
         * Subtracts the given vector from this vector.
         */
        subtract(_subtrahend) {
            this.x -= _subtrahend.x;
            this.y -= _subtrahend.y;
            this.z -= _subtrahend.z;
            this.w -= _subtrahend.w;
            return this;
        }
        /**
         * Scales this vector by the given scalar.
         */
        scale(_scalar) {
            this.x *= _scalar;
            this.y *= _scalar;
            this.z *= _scalar;
            this.w *= _scalar;
            return this;
        }
        /**
         * Normalizes this vector to the given length, 1 by default.
         */
        normalize(_length = 1) {
            let magnitudeSquared = this.magnitudeSquared;
            if (magnitudeSquared == 0)
                throw (new RangeError("Impossible normalization"));
            this.scale(_length / Math.sqrt(magnitudeSquared));
            return this;
        }
        /**
         * Calculates the dot product of this instance and another vector.
         */
        dot(_other) {
            return this.x * _other.x + this.y * _other.y + this.z * _other.z + this.w * _other.w;
        }
        recycle() {
            this.set(0, 0, 0, 0);
        }
        serialize() {
            return { toJSON: () => `[${this.x}, ${this.y}, ${this.z}, ${this.w}]` };
        }
        async deserialize(_serialization) {
            [this.x, this.y, this.z, this.w] = JSON.parse(_serialization);
            return this;
        }
        reduceMutator(_mutator) { }
        ;
    }
    FudgeCore.Vector4 = Vector4;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Describes a face of a {@link Mesh} by referencing three {@link Vertices} with their indizes
     * and calculates face normals.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Face {
        constructor(_vertices, _index0, _index1, _index2) {
            this.indices = [];
            this.angles = [];
            this.indices = [_index0, _index1, _index2];
            this.vertices = _vertices;
            this.calculateNormals();
        }
        /**
         * Returns the position of the vertex referenced by the given index
         */
        getPosition(_index) {
            return this.vertices.position(this.indices[_index]);
        }
        /**
         * must be coplanar
         */
        isInside(_point) {
            let diffs = [];
            for (let index of this.indices) {
                let diff = FudgeCore.Vector3.DIFFERENCE(this.vertices.position(index), _point);
                diffs.push(diff);
            }
            let n0 = FudgeCore.Vector3.CROSS(diffs[1], diffs[0]);
            let n1 = FudgeCore.Vector3.CROSS(diffs[2], diffs[1]);
            let n2 = FudgeCore.Vector3.CROSS(diffs[0], diffs[2]);
            let dot1 = FudgeCore.Vector3.DOT(n0, n1);
            let dot2 = FudgeCore.Vector3.DOT(n0, n2);
            return !(dot1 < 0 || dot2 < 0);
        }
        calculateNormals() {
            let trigon = this.indices.map((_index) => this.vertices.position(_index));
            let v1 = FudgeCore.Vector3.DIFFERENCE(trigon[1], trigon[0]);
            let v2 = FudgeCore.Vector3.DIFFERENCE(trigon[2], trigon[0]);
            this.normalUnscaled = FudgeCore.Vector3.CROSS(v1, v2);
            this.normal = FudgeCore.Vector3.NORMALIZATION(this.normalUnscaled);
            this.angles.push(FudgeCore.Vector3.ANGLE(v1, v2), FudgeCore.Vector3.ANGLE(FudgeCore.Vector3.DIFFERENCE(trigon[2], trigon[1]), FudgeCore.Vector3.DIFFERENCE(trigon[0], trigon[1])), FudgeCore.Vector3.ANGLE(FudgeCore.Vector3.DIFFERENCE(trigon[0], trigon[2]), FudgeCore.Vector3.DIFFERENCE(trigon[1], trigon[2])));
        }
    }
    FudgeCore.Face = Face;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple cube with edges of length 1, each face consisting of two trigons
     * ```text
     *       (12) 4____7  (11)
     *       (8) 0/__3/| (10)
     *       (15) ||5_||6 (14)
     *       (9) 1|/_2|/ (13)
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshCube extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshCube); }
        constructor(_name = "MeshCube") {
            super(_name);
            // no shared vertices, corners need three normals for Phong and Gouraud
            this.vertices = new FudgeCore.Vertices(
            // front vertices
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.5, 0.5), new FudgeCore.Vector2(0, 0)), // 0
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, -0.5, 0.5), new FudgeCore.Vector2(0, 1)), // 1
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, -0.5, 0.5), new FudgeCore.Vector2(1, 1)), // 2
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.5, 0.5), new FudgeCore.Vector2(1, 0)) //3
            );
            // generate vertices on sides
            for (let angle = 90; angle < 360; angle += 90) {
                let transform = FudgeCore.Matrix4x4.ROTATION(FudgeCore.Vector3.Y(angle));
                let side = this.vertices.slice(0, 4).map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, transform), _v.uv));
                this.vertices.push(...side);
            }
            // generate vertices for top and bottom
            for (let angle = 90; angle < 360; angle += 180) {
                let transform = FudgeCore.Matrix4x4.ROTATION(FudgeCore.Vector3.X(angle));
                let side = this.vertices.slice(0, 4).map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, transform), _v.uv));
                this.vertices.push(...side);
            }
            this.faces = [];
            for (let i = 0; i < 24; i += 4)
                // generate faces
                this.faces.push(...new FudgeCore.Quad(this.vertices, i + 0, i + 1, i + 2, i + 3).faces);
        }
    }
    FudgeCore.MeshCube = MeshCube;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a flat polygon. All trigons share vertex 0, so careful design is required to create concave polygons.
     * Vertex 0 is also associated with the face normal.
     * ```text
     *             0
     *           1‚ï±|‚ï≤  4 ...
     *            ‚ï≤|_‚ï≤‚ï±
     *            2   3
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshPolygon extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshPolygon); }
        static { this.shapeDefault = [
            new FudgeCore.Vector2(-1, -1),
            new FudgeCore.Vector2(1, -1),
            new FudgeCore.Vector2(0, 1)
        ]; }
        constructor(_name = "MeshPolygon", _shape = MeshPolygon.shapeDefault, _fitTexture = true) {
            super(_name);
            this.shape = new FudgeCore.MutableArray(FudgeCore.Vector2);
            this.create(_shape, _fitTexture);
        }
        get minVertices() {
            return 3;
        }
        /**
         * Create this mesh from the given vertices.
         */
        create(_shape = [], _fitTexture = true) {
            this.shape = FudgeCore.MutableArray.from(_shape.map(_vertex => _vertex.clone));
            this.clear();
            this.fitTexture = _fitTexture;
            if (_shape.length < this.minVertices) {
                FudgeCore.Debug.warn(`At least ${this.minVertices} vertices needed to construct MeshPolygon, default trigon used`);
                this.create(MeshPolygon.shapeDefault, true);
                return;
            }
            let shape = _shape;
            let min = FudgeCore.Vector2.ZERO();
            let max = FudgeCore.Vector2.ZERO();
            this.vertices = new FudgeCore.Vertices();
            for (let vertex of shape) {
                this.vertices.push(new FudgeCore.Vertex(vertex.toVector3()));
                min.x = Math.min(min.x, vertex.x);
                max.x = Math.max(max.x, vertex.x);
                min.y = Math.min(min.y, vertex.y);
                max.y = Math.max(max.y, vertex.y);
            }
            let size = new FudgeCore.Vector2(max.x - min.x, max.y - min.y);
            if (this.fitTexture) {
                for (let i = 0; i < shape.length; i++) {
                    let textureUV = FudgeCore.Vector2.DIFFERENCE(shape[i], min);
                    this.vertices[i].uv = new FudgeCore.Vector2(textureUV.x / size.x, 1 - textureUV.y / size.y);
                }
            }
            else {
                _shape.forEach((_vertex, _i) => this.vertices[_i].uv = new FudgeCore.Vector2(_vertex.x, -_vertex.y));
            }
            this.faces = [];
            for (let i = 2; i < this.vertices.length; i++)
                this.faces.push(new FudgeCore.Face(this.vertices, i - 1, i, 0));
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.shape = FudgeCore.Serializer.serializeArray(FudgeCore.Vector2, this.shape);
            serialization.fitTexture = this.fitTexture;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let vectors = await FudgeCore.Serializer.deserializeArray(_serialization.shape);
            this.create(vectors, _serialization.fitTexture);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            await super.mutate(_mutator, _selection, _dispatchMutate);
            this.create(this.shape, this.fitTexture);
            this.dispatchEvent(new Event("mutate" /* EVENT.MUTATE */));
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
        }
    }
    FudgeCore.MeshPolygon = MeshPolygon;
})(FudgeCore || (FudgeCore = {}));
///<reference path="MeshPolygon.ts"/>
var FudgeCore;
///<reference path="MeshPolygon.ts"/>
(function (FudgeCore) {
    /**
     * Generates an extrusion of a polygon by a series of transformations
     * ```text
     *                      ____
     * Polygon         ____‚ï±‚ï≤   ‚ï≤                             y
     * Transform 0  ‚Üí ‚ï± ‚ï≤__‚ï≤_‚ï≤___‚ï≤ ‚Üê Transform 2          z __‚îÇ
     * (base)         ‚ï≤_‚ï±__‚ï± ‚ï±   ‚ï±   (lid)                     ‚ï≤
     *     Transform 1  ‚Üí  ‚ï≤‚ï±___‚ï±                               x
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshExtrusion extends FudgeCore.MeshPolygon {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshExtrusion); }
        static { this.mtxDefaults = [
            FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Vector3.Z(0.5)),
            FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Vector3.Z(-0.5))
        ]; }
        constructor(_name = "MeshExtrusion", _vertices = FudgeCore.MeshPolygon.shapeDefault, _mtxTransforms = MeshExtrusion.mtxDefaults, _fitTexture = true) {
            super(_name, _vertices, _fitTexture);
            this.mtxTransforms = new FudgeCore.MutableArray(FudgeCore.Matrix4x4);
            this.extrude(_mtxTransforms);
            // console.log("Mutator", this.getMutator());
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.transforms = FudgeCore.Serializer.serializeArray(FudgeCore.Matrix4x4, this.mtxTransforms);
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let mtxTransforms;
            if (_serialization.transforms)
                mtxTransforms = await FudgeCore.Serializer.deserializeArray(_serialization.transforms);
            this.extrude(mtxTransforms);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            await super.mutate(_mutator, _selection, _dispatchMutate);
            this.extrude(this.mtxTransforms);
            this.dispatchEvent(new Event("mutate" /* EVENT.MUTATE */));
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
        }
        //#endregion
        extrude(_mtxTransforms = MeshExtrusion.mtxDefaults) {
            this.mtxTransforms = FudgeCore.MutableArray.from(_mtxTransforms);
            let nTransforms = _mtxTransforms.length;
            let nVerticesShape = this.vertices.length;
            // create new vertex cloud, current cloud holds MeshPolygon
            let vertices = new FudgeCore.Vertices();
            // create base by transformation of polygon with first transform
            let base = this.vertices.map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, _mtxTransforms[0], true), _v.uv));
            vertices.push(...base);
            // create lid by transformation of polygon with last transform
            let lid = this.vertices.map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, _mtxTransforms[nTransforms - 1], true), _v.uv));
            vertices.push(...lid);
            // recreate base faces to recalculate normals
            this.faces = this.faces.map((_face) => new FudgeCore.Face(vertices, _face.indices[0], _face.indices[1], _face.indices[2]));
            // create the lid faces using the indices of the base faces, but with an index offset and reverse order of indices
            this.faces.push(...this.faces.map(_face => new FudgeCore.Face(vertices, _face.indices[2] + nVerticesShape, _face.indices[1] + nVerticesShape, _face.indices[0] + nVerticesShape)));
            for (let t = 0; t < nTransforms; t++) {
                let mtxTransform = _mtxTransforms[t];
                let referToClose = vertices.length;
                let wrap = this.vertices.map((_v, _i) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, mtxTransform, true), new FudgeCore.Vector2(_i / nVerticesShape, t / nTransforms)));
                vertices.push(...wrap);
                vertices.push(new FudgeCore.Vertex(referToClose, new FudgeCore.Vector2(1, t / nTransforms)));
                // if (i > 0 && i < nTransforms - 1)
                //   vertices.push(...wrap.map((_vector: Vector3) => _vector.clone)); <- no slicing for flat shading yet...
            }
            // create indizes for wrapper
            for (let t = 0; t < nTransforms - 1; t++)
                for (let i = 0; i < nVerticesShape; i++) {
                    let index = +2 * nVerticesShape // base & lid are offsets 
                        + t * (nVerticesShape + 1) // offset for each transformation
                        + i;
                    let quad = new FudgeCore.Quad(vertices, index, index + nVerticesShape + 1, index + nVerticesShape + 2, index + 1, FudgeCore.QUADSPLIT.AT_0);
                    this.faces.push(...quad.faces);
                }
            this.vertices = vertices;
            return;
        }
    }
    FudgeCore.MeshExtrusion = MeshExtrusion;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A mesh loaded from an FBX-File.
     * @authors Matthias Roming, HFU, 2023 | Jonas Plotzky, HFU, 2023
     */
    class MeshFBX extends FudgeCore.mixinSerializableResourceExternal(FudgeCore.Mesh) {
        async load(_url = this.url, _iMesh = this.iMesh) {
            this.clear();
            this.url = _url;
            this.iMesh = _iMesh;
            const loader = await FudgeCore.FBXLoader.LOAD(this.url.toString());
            const geometryFBX = (loader.fbx.objects.geometries[_iMesh] ||
                loader.fbx.objects.geometries.find(_object => _object.name == this.name) ||
                loader.fbx.objects.models.find(_object => _object.name == this.name && _object.subtype == "Mesh").children[0]).load();
            if (geometryFBX)
                this.name = geometryFBX.name.length > 0 ? geometryFBX.name : geometryFBX.parents[0].name;
            let positions = [];
            let vertexBuffer = geometryFBX.Vertices;
            for (let iVertex = 0; iVertex < vertexBuffer.length; iVertex += 3) {
                positions.push(new FudgeCore.Vector3(vertexBuffer[iVertex + 0], vertexBuffer[iVertex + 1], vertexBuffer[iVertex + 2]));
            }
            let uvs = [];
            if (geometryFBX.LayerElementUV) {
                let uvBuffer = geometryFBX.LayerElementUV.UV;
                for (let iuv = 0; iuv < uvBuffer.length; iuv += 2) {
                    uvs.push(new FudgeCore.Vector2(uvBuffer[iuv], 1 - uvBuffer[iuv + 1]));
                }
            }
            let normals = [];
            if (geometryFBX.LayerElementNormal) {
                let normalBuffer = geometryFBX.LayerElementNormal.Normals;
                for (let iNormal = 0; iNormal < normalBuffer.length; iNormal += 3) {
                    normals.push(new FudgeCore.Vector3(normalBuffer[iNormal], normalBuffer[iNormal + 1], normalBuffer[iNormal + 2]));
                }
            }
            let mapVertexToIndex = new Map();
            let newVertexIndices = [];
            let iPolygon = 0;
            let isEndOfPolygon = false;
            let polygon = [];
            geometryFBX.PolygonVertexIndex.forEach((_iVertex, _iPolygonVertex) => {
                if (_iVertex < 0) {
                    _iVertex = _iVertex ^ -1;
                    isEndOfPolygon = true;
                }
                let position = positions[_iVertex];
                let uv = uvs[this.getDataIndex(geometryFBX.LayerElementUV, _iVertex, iPolygon, _iPolygonVertex)];
                let vertexKey = position.toString() + uv.toString();
                if (!mapVertexToIndex.has(vertexKey)) {
                    let normal = normals[this.getDataIndex(geometryFBX.LayerElementNormal, _iVertex, iPolygon, _iPolygonVertex)];
                    this.vertices.push(new FudgeCore.Vertex(position, uv, normal));
                    mapVertexToIndex.set(vertexKey, this.vertices.length - 1);
                    if (!newVertexIndices[_iVertex])
                        newVertexIndices[_iVertex] = [];
                    newVertexIndices[_iVertex].push(this.vertices.length - 1);
                }
                polygon.push(mapVertexToIndex.get(vertexKey));
                if (isEndOfPolygon) {
                    if (polygon.length == 3) {
                        this.faces.push(new FudgeCore.Face(this.vertices, polygon[0], polygon[1], polygon[2]));
                    }
                    else if (polygon.length == 4) {
                        let quad = new FudgeCore.Quad(this.vertices, polygon[0], polygon[1], polygon[2], polygon[3]);
                        this.faces.push(...quad.faces);
                    }
                    else {
                        for (let i = 2; i < polygon.length; i++)
                            this.faces.push(new FudgeCore.Face(this.vertices, polygon[0], polygon[i - 1], polygon[i - 0]));
                        // console.warn(`${MeshLoaderFBX.name}: Polygons with more than 4 vertices are not supported.`);
                    }
                    polygon = [];
                    isEndOfPolygon = false;
                    iPolygon++;
                }
            });
            if (geometryFBX.children?.[0].type == "Deformer") {
                const fbxDeformer = geometryFBX.children[0];
                const skeleton = await loader.getSkeleton(fbxDeformer.children[0].children[0]); // Deformer.SubDeformer.LimbNode
                this.createBones(fbxDeformer, skeleton, this.vertices, newVertexIndices);
            }
            return this;
        }
        serialize() {
            const serialization = super.serialize();
            serialization.iMesh = this.iMesh;
            return serialization;
        }
        async deserialize(_serialization) {
            this.iMesh = _serialization.iMesh;
            return super.deserialize(_serialization);
        }
        getDataIndex(_layerElement, _iVertex, _iPolygon, _iPolygonVertex) {
            let index = _layerElement.MappingInformationType == "ByVertex" ?
                _iVertex :
                _layerElement.MappingInformationType == "ByPolygon" ?
                    _iPolygon :
                    _iPolygonVertex;
            if (_layerElement.ReferenceInformationType === 'IndexToDirect') {
                let indices = _layerElement.UVIndex || _layerElement.NormalsIndex;
                index = indices[index];
            }
            return index;
        }
        createBones(_deformerFBX, _skeleton, _vertices, _newVertexIndices) {
            for (const fbxSubDeformer of _deformerFBX.children) {
                fbxSubDeformer.load();
                if (fbxSubDeformer.Indexes)
                    for (let iBoneInfluence = 0; iBoneInfluence < fbxSubDeformer.Indexes.length; iBoneInfluence++) {
                        const iVertex = fbxSubDeformer.Indexes[iBoneInfluence];
                        for (const iVertexNew of _newVertexIndices ? _newVertexIndices[iVertex] : [iVertex]) {
                            (_vertices[iVertexNew].bones || (_vertices[iVertexNew].bones = [])).push({
                                index: _skeleton.indexOf(fbxSubDeformer.children[0].name),
                                weight: fbxSubDeformer.Weights[iBoneInfluence] || 1
                            });
                        }
                    }
            }
        }
    }
    FudgeCore.MeshFBX = MeshFBX;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Allows to create custom meshes from given Data */
    class MeshFromData extends FudgeCore.Mesh {
        constructor(_vertices, _textureUVs, _indices, _faceNormals) {
            super();
            this.verticesToSet = _vertices;
            this.textureUVsToSet = _textureUVs;
            this.indicesToSet = _indices;
            this.faceNormalsToSet = _faceNormals;
        }
        createVertices() {
            return this.verticesToSet;
        }
        createTextureUVs() {
            return this.textureUVsToSet;
        }
        createIndices() {
            return this.indicesToSet;
        }
        createFlatNormals() {
            return this.faceNormalsToSet;
        }
    }
    FudgeCore.MeshFromData = MeshFromData;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Mesh} loaded from a glTF-File.
     * @authors Jonas Plotzky, HFU, 2024
     */
    class MeshGLTF extends FudgeCore.mixinSerializableResourceExternal(FudgeCore.Mesh) {
        async load(_url = this.url, _name = this.name, _iPrimitive = this.iPrimitive) {
            this.url = _url;
            this.name = _name;
            this.iPrimitive = _iPrimitive;
            return FudgeCore.GLTFLoader.loadResource(this);
        }
        serialize() {
            const serialization = super.serialize();
            serialization.iPrimitive = this.iPrimitive;
            return serialization;
        }
        deserialize(_serialization) {
            this.iPrimitive = _serialization.iPrimitive;
            return super.deserialize(_serialization);
        }
    }
    FudgeCore.MeshGLTF = MeshGLTF;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A mesh loaded from an OBJ-file.
     * Simple Wavefront OBJ import. Takes a wavefront obj string. To Load from a file url, use the
     * static LOAD Method. Currently only works with triangulated Meshes
     * (activate 'Geomentry ‚Üí Triangulate Faces' in Blenders obj exporter)
     * @todo Load Materials, Support Quads
     * @authors Simon Storl-Schulke 2021 | Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021-2022 | Matthias Roming, HFU, 2023 | Jonas Plotzky, HFU, 2023
     */
    class MeshOBJ extends FudgeCore.mixinSerializableResourceExternal(FudgeCore.Mesh) {
        async load(_url = this.url) {
            const url = new URL(_url.toString(), FudgeCore.Project.baseURL).toString();
            const data = await (await fetch(url)).text();
            this.name = url.split("/").pop();
            this.url = _url;
            const lines = data.split("\n");
            const indices = [];
            const positions = [];
            const uvs = [];
            const normals = [];
            const norms = [];
            const vertices = new FudgeCore.Vertices();
            const faces = [];
            const mapPositionUVNormalToIndex = {};
            const mapPositionNormalToIndex = {};
            // TODO: think about creating the needed buffers for rendermesh here already...
            for (let line of lines) {
                const parts = line.trim().split(" ");
                switch (parts.shift()) {
                    case "v": //Vertex - example: v 0.70 -0.45 -0.52         
                        positions.push(new FudgeCore.Vector3(...parts.map(_value => +_value)));
                        break;
                    case "vn": //Normal - example: vn 0.00 0.00 1.00
                        normals.push(new FudgeCore.Vector3(...parts.map(_value => +_value)));
                        break;
                    case "vt": //Texcoord - example: vt 0.545454 0.472382
                        uvs.push(new FudgeCore.Vector2(...parts.map((_value, _index) => +_value * (_index == 1 ? -1 : 1))));
                        break;
                    case "f": /*Face Indices - example: f 1/1/1 2/2/1 3/3/1 --> vertex1/texcoord1/normal1 vertex2/texcoord2/normal2 vertex3/texcoord3/normal3*/
                        for (let i = 0; i < 3; i++) {
                            let key = parts[i];
                            let index = mapPositionUVNormalToIndex[key];
                            if (index === undefined) {
                                index = vertices.length;
                                const vertexInfo = parts[i].split("/");
                                let position = positions[+vertexInfo[0] - 1]; // obj uses 1-based indices
                                let uv = uvs[+vertexInfo[1] - 1] ?? undefined;
                                let normal = normals[+vertexInfo[2] - 1] ?? undefined;
                                if (normal)
                                    norms.push(normal.x, normal.y, normal.z);
                                let keyPosNorm = `${vertexInfo[0]}/${vertexInfo[2]}`;
                                vertices.push(new FudgeCore.Vertex(mapPositionNormalToIndex[keyPosNorm] ?? position, uv, normal));
                                mapPositionUVNormalToIndex[key] = index;
                                if (mapPositionNormalToIndex[keyPosNorm] == undefined)
                                    mapPositionNormalToIndex[keyPosNorm] = index;
                            }
                            indices.push(index);
                        }
                        try {
                            faces.push(new FudgeCore.Face(vertices, indices[indices.length - 2], indices[indices.length - 1], indices[indices.length - 3]));
                        }
                        catch (_e) {
                            FudgeCore.Debug.fudge("Face excluded", _e.message);
                        }
                        break;
                }
            }
            this.clear();
            this.vertices = vertices;
            this.faces = faces;
            if (norms.length > 0) // TODO: rendermesh should be able to handle undefined normals correctly, i.e. calculate them only if they are not present in the vertices
                this.renderMesh.normals = new Float32Array(norms);
            // _mesh.renderMesh.indices = new Uint16Array(indices); // doens't seem to affect scene loading time...
            return this;
        }
    }
    FudgeCore.MeshOBJ = MeshOBJ;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple pyramid with edges at the base of length 1 and a height of 1. The sides consisting of one, the base of two trigons
     * ```text
     *               4
     *              /\`.
     *            3/__\_\ 2
     *           0/____\/1
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshPyramid extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshPyramid); }
        constructor(_name = "MeshPyramid") {
            super(_name);
            // this.create();
            this.vertices = new FudgeCore.Vertices(
            // ground vertices
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.0, 0.5), new FudgeCore.Vector2(0, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.0, 0.5), new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.0, -0.5), new FudgeCore.Vector2(1, 0)), new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.0, -0.5), new FudgeCore.Vector2(0, 0)), 
            // tip (vertex #4)
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.0, 1.0, 0.0), new FudgeCore.Vector2(0.5, 0.5)), 
            // floor again for downside texture
            new FudgeCore.Vertex(0, new FudgeCore.Vector2(0, 0)), new FudgeCore.Vertex(1, new FudgeCore.Vector2(1, 0)), new FudgeCore.Vertex(2, new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(3, new FudgeCore.Vector2(0, 1)));
            this.faces = [
                new FudgeCore.Face(this.vertices, 4, 0, 1),
                new FudgeCore.Face(this.vertices, 4, 1, 2),
                new FudgeCore.Face(this.vertices, 4, 2, 3),
                new FudgeCore.Face(this.vertices, 4, 3, 0),
                new FudgeCore.Face(this.vertices, 5 + 0, 5 + 2, 5 + 1),
                new FudgeCore.Face(this.vertices, 5 + 0, 5 + 3, 5 + 2)
            ];
        }
    }
    FudgeCore.MeshPyramid = MeshPyramid;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple quad with edges of length 1, the face consisting of two trigons
     * ```text
     *        0 __ 3
     *         |_\|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019-2022
     */
    class MeshQuad extends FudgeCore.MeshPolygon {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshQuad); }
        static { this.shape = [
            new FudgeCore.Vector2(-0.5, 0.5), new FudgeCore.Vector2(-0.5, -0.5), new FudgeCore.Vector2(0.5, -0.5), new FudgeCore.Vector2(0.5, 0.5)
        ]; }
        constructor(_name = "MeshQuad") {
            super(_name, MeshQuad.shape);
        }
        // // flat equals smooth
        // public get verticesFlat(): Float32Array { return this.vertices; }
        // public get indicesFlat(): Uint16Array { return this.indices; }
        // public get normalsFlat(): Float32Array { return this.normalsVertex; }
        //#region Transger
        serialize() {
            let serialization = this.getMutator();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(MeshQuad.shape, true); // this seems to be dispatched doubled while deserializing the resources
            return this;
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
            delete _mutator.fitTexture;
        }
    }
    FudgeCore.MeshQuad = MeshQuad;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Information about the vertical projection of a given position onto the terrain
     */
    class TerrainInfo {
    }
    FudgeCore.TerrainInfo = TerrainInfo;
    /**
     * A terrain spreads out in the x-z-plane, y is the height derived from the heightmap function.
     * The terrain is always 1 in size in all dimensions, fitting into the unit-cube.
     * Resolution determines the number of quads in x and z dimension, scale the factor applied to the x,z-coordinates passed to the heightmap function.
     * Standard function is the simplex noise implemented with FUDGE, but another function can be given.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022 | Simon Storl-Schulke, HFU, 2020 | Moritz Beaugrand, HFU, 2021
     */
    class MeshTerrain extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshTerrain); }
        constructor(_name = "MeshTerrain", _resolution = FudgeCore.Vector2.ONE(2), _scaleInput = FudgeCore.Vector2.ONE(), _functionOrSeed = 0) {
            super(_name);
            this.heightMapFunction = null;
            this.create(_resolution, _scaleInput, _functionOrSeed);
        }
        /**
         * Create this mesh from the given parameters
         */
        create(_resolution = FudgeCore.Vector2.ONE(2), _scaleInput = FudgeCore.Vector2.ONE(), _functionOrSeed = 0) {
            this.clear();
            this.seed = undefined;
            this.resolution = new FudgeCore.Vector2(Math.round(_resolution.x), Math.round(_resolution.y));
            this.scale = _scaleInput.clone;
            if (_functionOrSeed instanceof Function)
                this.heightMapFunction = _functionOrSeed;
            else if (typeof (_functionOrSeed) == "number") {
                this.seed = _functionOrSeed;
                let prng = new FudgeCore.Random(this.seed);
                this.heightMapFunction = new FudgeCore.Noise2(() => prng.getNorm()).sample; // TODO call PRNG
            }
            else
                this.heightMapFunction = new FudgeCore.Noise2().sample;
            this.vertices = new FudgeCore.Vertices();
            //Iterate over each cell to generate grid of vertices
            for (let z = 0; z <= this.resolution.y; z++) {
                for (let x = 0; x <= this.resolution.x; x++) {
                    let xNorm = x / this.resolution.x;
                    let zNorm = z / this.resolution.y;
                    this.vertices.push(new FudgeCore.Vertex(new FudgeCore.Vector3(xNorm - 0.5, this.heightMapFunction(xNorm * this.scale.x, zNorm * this.scale.y), zNorm - 0.5), new FudgeCore.Vector2(xNorm, zNorm)));
                }
            }
            let quads = [];
            let split = FudgeCore.QUADSPLIT.AT_0;
            for (let z = 0; z < this.resolution.y; z++) {
                for (let x = 0; x < this.resolution.x; x++) {
                    quads.push(new FudgeCore.Quad(this.vertices, (x + 0) + (z + 0) * (this.resolution.x + 1), (x + 0) + (z + 1) * (this.resolution.x + 1), (x + 1) + (z + 1) * (this.resolution.x + 1), (x + 1) + (z + 0) * (this.resolution.x + 1), split));
                    split = (split == FudgeCore.QUADSPLIT.AT_0) ? FudgeCore.QUADSPLIT.AT_1 : FudgeCore.QUADSPLIT.AT_0;
                }
                if (this.resolution.x % 2 == 0) // reverse last split change if x-resolution is even
                    split = (split == FudgeCore.QUADSPLIT.AT_0) ? FudgeCore.QUADSPLIT.AT_1 : FudgeCore.QUADSPLIT.AT_0;
            }
            this.faces = quads.flatMap((_quad) => _quad.faces);
        }
        /**
         * Returns information about the vertical projection of the given position onto the terrain.
         * Pass the overall world transformation of the terrain if the position is given in world coordinates.
         * If at hand, pass the inverse too to avoid unnecessary calculation.
         */
        getTerrainInfo(_position, _mtxWorld = FudgeCore.Matrix4x4.IDENTITY(), _mtxInverse) {
            if (!_mtxInverse)
                _mtxInverse = FudgeCore.Matrix4x4.INVERSE(_mtxWorld);
            let terrainInfo = new TerrainInfo;
            let posLocal = FudgeCore.Vector3.TRANSFORMATION(_position, _mtxInverse, true);
            let z = Math.floor((posLocal.z + 0.5) * this.resolution.y);
            let x = Math.floor((posLocal.x + 0.5) * this.resolution.x);
            if (z < 0 || z > this.resolution.y - 1 || x < 0 || x > this.resolution.x - 1)
                return null;
            let index = (z * this.resolution.x + x) * 2;
            let face = this.faces[index];
            let ray = new FudgeCore.Ray(FudgeCore.Vector3.Y(), posLocal);
            let point = ray.intersectFacePlane(face);
            if (!face.isInside(point)) {
                index++;
                face = this.faces[index];
                point = ray.intersectFacePlane(face);
            }
            terrainInfo.index = index;
            terrainInfo.positionFace = point;
            terrainInfo.position = FudgeCore.Vector3.TRANSFORMATION(point, _mtxWorld, true);
            terrainInfo.normal = FudgeCore.Vector3.TRANSFORMATION(face.normal, FudgeCore.Matrix4x4.TRANSPOSE(_mtxInverse), false);
            terrainInfo.distance = _position.y - terrainInfo.position.y;
            terrainInfo.grid = this.getGridFromFaceIndex(index);
            return terrainInfo;
        }
        /**
         * Returns the grid coordinates of the quad the given face belongs to.
         */
        getGridFromFaceIndex(_index) {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector2);
            let iQuad = Math.floor(_index / 2);
            result.set(iQuad % this.resolution.y, Math.floor(iQuad / this.resolution.x));
            return result;
        }
        /**
         * Returns the indices of the two faces forming the quad the given grid position belongs to.
         */
        getFaceIndicesFromGrid(_grid) {
            let iQuad = _grid.y * 2 * this.resolution.x + _grid.x * 2;
            return [iQuad, iQuad + 1];
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.seed = this.seed;
            serialization.scale = this.scale.serialize();
            serialization.resolution = this.resolution.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            await this.resolution.deserialize(_serialization.resolution);
            await this.scale.deserialize(_serialization.scale);
            this.seed = _serialization.seed;
            this.create(this.resolution, this.scale, this.seed);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            super.mutate(_mutator, _selection, _dispatchMutate);
            this.create(this.resolution, this.scale, this.seed);
        }
    }
    FudgeCore.MeshTerrain = MeshTerrain;
})(FudgeCore || (FudgeCore = {}));
///<reference path="MeshTerrain.ts"/>
var FudgeCore;
///<reference path="MeshTerrain.ts"/>
(function (FudgeCore) {
    /**
     * Generates a planar Grid and applies a Heightmap-Function to it.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021 | Moritz Beaugrand, HFU, 2020
     */
    let MeshRelief = (() => {
        let _classDecorators = [FudgeCore.enumerate];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.MeshTerrain;
        let _instanceExtraInitializers = [];
        let _get_texture_decorators;
        var MeshRelief = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _get_texture_decorators = [FudgeCore.enumerate, FudgeCore.type(FudgeCore.TextureImage)];
                __esDecorate(this, null, _get_texture_decorators, { kind: "getter", name: "texture", static: false, private: false, access: { has: obj => "texture" in obj, get: obj => obj.texture }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                MeshRelief = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshRelief); }
            #texture = __runInitializers(this, _instanceExtraInitializers);
            constructor(_name = "MeshRelief", _texture) {
                super(_name, FudgeCore.Vector2.ONE(2), undefined, (_x, _z) => 0);
                this.texture = _texture;
            }
            static createHeightMapFunction(_texture) {
                let array = MeshRelief.textureToClampedArray(_texture);
                let heightMapFunction = (_x, _z) => {
                    let pixel = Math.round(_z * _texture.image.width + _x);
                    return array[pixel * 4] / 255;
                };
                return heightMapFunction;
            }
            static textureToClampedArray(_texture) {
                let canvas = document.createElement("canvas");
                canvas.width = _texture.image.width;
                canvas.height = _texture.image.height;
                let crc = canvas.getContext("2d");
                crc.imageSmoothingEnabled = false;
                crc.drawImage(_texture.image, 0, 0);
                return crc.getImageData(0, 0, _texture.image.width, _texture.image.height).data;
            }
            /**
             * The texture to be used as the heightmap.
             * **Caution!** Setting this causes the mesh to be recreated which can be an expensive operation.
             */
            get texture() {
                return this.#texture;
            }
            set texture(_texture) {
                this.#texture = _texture;
                if (!_texture)
                    return;
                let resolution = _texture ? new FudgeCore.Vector2(_texture.image.width - 1, _texture.image.height - 1) : undefined;
                super.create(resolution, resolution, MeshRelief.createHeightMapFunction(_texture));
            }
            //#region Transfer
            serialize() {
                let serialization = super.serialize();
                delete serialization.seed;
                delete serialization.scale;
                delete serialization.resolution;
                if (this.#texture)
                    serialization.idTexture = this.texture.idResource;
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization);
                if (_serialization.idTexture)
                    this.texture = await FudgeCore.Project.getResource(_serialization.idTexture);
                return this;
            }
            reduceMutator(_mutator) {
                super.reduceMutator(_mutator);
                delete _mutator.seed;
                delete _mutator.scale;
                delete _mutator.resolution;
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return MeshRelief = _classThis;
    })();
    FudgeCore.MeshRelief = MeshRelief;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="MeshPolygon.ts"/>
var FudgeCore;
// /<reference path="MeshPolygon.ts"/>
(function (FudgeCore) {
    /**
     * Generates a rotation of a polygon around the y-axis
     * ```text
     *                     y
     *                  _  ‚Üë 0_1
     *                 ‚îÇ   ‚îÇ‚Üíx ‚îÇ2
     *                  ‚ï≤  ‚îÇ  ‚ï±3
     *                  ‚ï±  ‚îÇ  ‚ï≤
     *                 ‚ï±___‚îÇ___‚ï≤4
     *                      5
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshRotation extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshRotation); }
        static { this.verticesDefault = [
            new FudgeCore.Vector2(0.5, 0.5),
            new FudgeCore.Vector2(0.5, -0.5)
        ]; }
        constructor(_name = "MeshRotation", _shape = MeshRotation.verticesDefault, _longitudes = 3) {
            super(_name);
            this.shape = new FudgeCore.MutableArray(FudgeCore.Vector2);
            this.rotate(_shape, _longitudes);
            // console.log("Mutator", this.getMutator());
        }
        get minVertices() {
            return 2;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.shape = FudgeCore.Serializer.serializeArray(FudgeCore.Vector2, this.shape);
            serialization.longitudes = this.longitudes;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let shape = await FudgeCore.Serializer.deserializeArray(_serialization.shape);
            this.longitudes = _serialization.longitudes;
            this.rotate(shape, this.longitudes);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            await super.mutate(_mutator, _selection, _dispatchMutate);
            this.rotate(this.shape, this.longitudes);
            this.dispatchEvent(new Event("mutate" /* EVENT.MUTATE */));
        }
        //#endregion
        rotate(_shape, _longitudes) {
            this.clear();
            this.shape = FudgeCore.MutableArray.from(_shape.map(_vertex => _vertex.clone));
            this.longitudes = Math.round(_longitudes);
            let angle = 360 / this.longitudes;
            let mtxRotate = FudgeCore.Matrix4x4.ROTATION_Y(angle);
            // copy original polygon as Vector3 array
            let polygon = [];
            let distances = [0];
            let total = 0;
            for (let i = 0; i < this.shape.length; i++) {
                polygon.push(this.shape[i].toVector3());
                if (i > 0) {
                    let distance = FudgeCore.Vector2.DIFFERENCE(this.shape[i], this.shape[i - 1]).magnitude;
                    total += distance;
                    distances.push(total);
                }
            }
            distances.forEach((_entry, _index) => { distances[_index] = _entry / total; });
            let nVerticesPolygon = polygon.length;
            let cloud = new FudgeCore.Vertices();
            for (let longitude = 0; longitude <= this.longitudes; longitude++) {
                for (let i = 0; i < nVerticesPolygon; i++) {
                    let uv = new FudgeCore.Vector2(longitude / this.longitudes, distances[i]);
                    // TODO: last sector should only be references to the first meridian
                    if (longitude == this.longitudes)
                        cloud.push(new FudgeCore.Vertex(i, uv));
                    else {
                        if (longitude > 0 && this.shape[i].x == 0) // use a single vertex when it's on the rotation axis
                            cloud.push(new FudgeCore.Vertex(i, uv));
                        else
                            cloud.push(new FudgeCore.Vertex(polygon[i].clone, uv));
                    }
                }
                polygon.forEach((_vector) => _vector.transform(mtxRotate));
            }
            // copy indices to new index array
            let faces = [];
            for (let longitude = 0; longitude < this.longitudes; longitude++) {
                for (let latitude = 0; latitude < nVerticesPolygon - 1; latitude++) {
                    let start = longitude * nVerticesPolygon + latitude;
                    let quad = new FudgeCore.Quad(cloud, start + 1, start + 1 + nVerticesPolygon, start + nVerticesPolygon, start);
                    faces.push(...quad.faces);
                    // TODO: catch invalid faces right here...
                }
            }
            this.vertices = cloud;
            this.faces = faces;
        }
    }
    FudgeCore.MeshRotation = MeshRotation;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a UV Sphere with a given number of sectors and stacks (clamped at 128*128)
     * Implementation based on http://www.songho.ca/opengl/gl_sphere.html
     * @authors Simon Storl-Schulke, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshSphere extends FudgeCore.MeshRotation {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSphere); }
        constructor(_name = "MeshSphere", _longitudes = 8, _latitudes = 8) {
            super(_name);
            this.create(_longitudes, _latitudes); // TODO: when deserialized this causes this causes the mesh to be created twice
        }
        /**
         * Create this sphere with a given number of longitudes and latitudes
         */
        create(_longitudes = 3, _latitudes = 2) {
            this.clear();
            //Clamp resolution to prevent performance issues
            this.longitudes = Math.min(Math.round(_longitudes), 128);
            this.latitudes = Math.min(Math.round(_latitudes), 128);
            if (_longitudes < 3 || _latitudes < 2) {
                FudgeCore.Debug.warn("UV Sphere must have at least 3 longitudes and 2 latitudes to form a 3-dimensional shape.");
                this.longitudes = Math.max(3, _longitudes);
                this.latitudes = Math.max(2, _latitudes);
            }
            let shape = [];
            let step = Math.PI / this.latitudes;
            for (let i = 0; i <= this.latitudes; ++i) {
                let angle = Math.PI / 2 - i * step;
                let x = Math.cos(angle);
                let y = Math.sin(angle);
                shape.push(new FudgeCore.Vector2(x / 2, y / 2));
            }
            // place first and last vertex exactly on rotation axis
            shape[0].x = 0;
            shape[shape.length - 1].x = 0;
            super.rotate(shape, _longitudes);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            delete serialization.shape;
            serialization.latitudes = this.latitudes;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(_serialization.longitudes, _serialization.latitudes);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            super.mutate(_mutator, _selection, _dispatchMutate);
            this.create(this.longitudes, this.latitudes);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
        }
    }
    FudgeCore.MeshSphere = MeshSphere;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate two quads placed back to back, the one facing in negative Z-direction is textured reversed
     * ```text
     *        0 __ 3
     *         |__|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshSprite extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSprite); }
        constructor(_name = "MeshSprite") {
            super(_name);
            this.vertices = new FudgeCore.Vertices(new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.5, 0), new FudgeCore.Vector2(0, 0)), new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, -0.5, 0), new FudgeCore.Vector2(0, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, -0.5, 0), new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.5, 0), new FudgeCore.Vector2(1, 0)));
            this.faces = [
                new FudgeCore.Face(this.vertices, 1, 2, 0),
                new FudgeCore.Face(this.vertices, 2, 3, 0),
                new FudgeCore.Face(this.vertices, 0, 3, 1),
                new FudgeCore.Face(this.vertices, 3, 2, 1)
            ];
        }
        // flat is standard here // TODO: is this still needed?
        get verticesFlat() { return this.renderMesh.positions; }
        get indicesFlat() { return this.renderMesh.indices; }
    }
    FudgeCore.MeshSprite = MeshSprite;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a torus with a given ring radius, tube radius and the number of major- and minor segments
     * @authors Simon Storl-Schulke, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshTorus extends FudgeCore.MeshRotation {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshTorus); }
        constructor(_name = "MeshTorus", _radiusRing = 0.5 - 0.125, _radiusTube = 0.125, _longitudes = 8, _latitudes = 6) {
            super(_name, MeshTorus.getShape(_radiusRing, _radiusTube, Math.max(3, _latitudes)), _longitudes);
            this.latitudes = 12;
            this.radiusRing = 0.5 - 0.125;
            this.radiusTube = 0.125;
            this.radiusTube = _radiusTube;
            this.radiusRing = _radiusRing;
            this.longitudes = _longitudes;
            this.latitudes = Math.max(3, _latitudes);
        }
        static getShape(_radiusRing, _radiusTube, _latitudes) {
            let shape = [];
            let center = new FudgeCore.Vector2(_radiusRing, 0);
            for (let latitude = 0; latitude <= _latitudes; latitude++) {
                let angle = 2 * Math.PI * latitude / _latitudes;
                shape.push(FudgeCore.Vector2.SUM(center, new FudgeCore.Vector2(_radiusTube * -Math.cos(angle), _radiusTube * Math.sin(angle))));
            }
            return shape;
        }
        /**
         * Create this torus from the given parameters
         */
        create(_radiusRing = 0.5 - 0.125, _radiusTube = 0.125, _longitudes = 8, _latitudes = 6) {
            this.radiusTube = _radiusTube;
            this.latitudes = Math.max(3, _latitudes);
            this.radiusRing = _radiusRing;
            super.rotate(MeshTorus.getShape(_radiusRing, _radiusTube, _latitudes), _longitudes);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.latitudes = this.latitudes;
            serialization.radiusRing = this.radiusRing;
            serialization.radiusTube = this.radiusTube;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(_serialization.radiusRing, _serialization.radiusTube, _serialization.longitudes, _serialization.latitudes);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            super.mutate(_mutator, _selection, _dispatchMutate);
            this.create(this.radiusRing, this.radiusTube, this.longitudes, this.latitudes);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
        }
    }
    FudgeCore.MeshTorus = MeshTorus;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let QUADSPLIT;
    (function (QUADSPLIT) {
        QUADSPLIT[QUADSPLIT["PLANAR"] = 0] = "PLANAR";
        QUADSPLIT[QUADSPLIT["AT_0"] = 1] = "AT_0";
        QUADSPLIT[QUADSPLIT["AT_1"] = 2] = "AT_1";
    })(QUADSPLIT = FudgeCore.QUADSPLIT || (FudgeCore.QUADSPLIT = {}));
    /**
     * A surface created with four vertices which immediately creates none, one or two {@link Face}s depending on vertices at identical positions.
     * ```text
     * QUADSPLIT:  PLANAR                  AT_0                     AT_1
     *             0 _ 3                   0 _ 3                    0 _ 3
     *              |\|                     |\|                      |/|
     *             1 ‚Äæ 2                   1 ‚Äæ 2                    1 ‚Äæ 2
     *  shared last vertex 2      last vertices 2 + 3      last vertices 3 + 0
     *
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Quad {
        #split;
        constructor(_vertices, _index0, _index1, _index2, _index3, _split = QUADSPLIT.PLANAR) {
            this.faces = [];
            this.#split = _split;
            try {
                if (_split != QUADSPLIT.AT_1)
                    this.faces.push(new FudgeCore.Face(_vertices, _index0, _index1, _index2));
                else
                    this.faces.push(new FudgeCore.Face(_vertices, _index1, _index2, _index3));
            }
            catch (_e) {
                FudgeCore.Debug.fudge("Face excluded", _e.message);
            }
            try {
                if (_split == QUADSPLIT.PLANAR)
                    this.faces.push(new FudgeCore.Face(_vertices, _index3, _index0, _index2));
                else if (_split == QUADSPLIT.AT_0)
                    this.faces.push(new FudgeCore.Face(_vertices, _index0, _index2, _index3));
                else
                    this.faces.push(new FudgeCore.Face(_vertices, _index1, _index3, _index0));
            }
            catch (_e) {
                FudgeCore.Debug.fudge("Face excluded", _e.message);
            }
        }
        get split() {
            return this.#split;
        }
    }
    FudgeCore.Quad = Quad;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // TODO: the refer to  description is no longer correct as refer to also works for bone indices
    /**
     * Represents a vertex of a mesh with extended information such as the uv coordinates and the vertex normal.
     * It may refer to another vertex via an index into some array, in which case the position and the normal are stored there.
     * This way, vertex position and normal is a 1:1 association, vertex to texture coordinates a 1:n association.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Vertex {
        /**
         * Represents a vertex of a mesh with extended information such as the uv coordinates the vertex normal and its tangents.
         * It may refer to another vertex via an index into some array, in which case the position and the normal are stored there.
         * This way, vertex position and normal is a 1:1 association, vertex to texture coordinates a 1:n association.
       * @authors Jirka Dell'Oro-Friedl, HFU, 2022
         */
        constructor(_positionOrIndex, _uv = null, _normal = FudgeCore.Vector3.ZERO(), _tangent = null, _color = new FudgeCore.Color(1, 1, 1, 1), _bones = null) {
            if (_positionOrIndex instanceof FudgeCore.Vector3)
                this.position = _positionOrIndex;
            else
                this.referTo = _positionOrIndex;
            this.uv = _uv;
            this.normal = _normal;
            this.tangent = _tangent;
            this.color = _color;
            this.bones = _bones;
        }
    }
    FudgeCore.Vertex = Vertex;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Array with extended functionality to serve as a {@link Vertex}-cloud.
     * Accessors yield position or normal also for vertices referencing other vertices
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Vertices extends Array {
        // TODO: this class may become more powerful by hiding the array and add more service methods like calculating bounding box, radius etc.
        // see if a proxy of the array interfacing [] would do a good job -> tested: proxy is about 20 times slower!
        /**
         * Returns the subset of vertices that do not refer to other vertices
         */
        get originals() {
            return this.filter(_vertex => _vertex.referTo == undefined);
        }
        /**
         * returns the position associated with the vertex addressed, resolving references between vertices
         */
        position(_index) {
            let vertex = this[_index];
            return (vertex.referTo == undefined) ? vertex.position : this[vertex.referTo].position;
        }
        /**
         * returns the normal associated with the vertex addressed, resolving references between vertices
         */
        normal(_index) {
            let vertex = this[_index];
            return (vertex.referTo == undefined) ? vertex.normal : this[vertex.referTo].normal;
        }
        /**
         * returns the tangent associated with the vertex addressed
         */
        tangent(_index) {
            return this[_index].tangent; // tangents can not be shared as they are dependent on the uv-coordinates
        }
        /**
         * returns the uv-coordinates associated with the vertex addressed
         */
        uv(_index) {
            return this[_index].uv;
        }
        /**
         * returns the color associated with the vertex addressed
         */
        color(_index) {
            return this[_index].color;
        }
        /**
         * returns the bones associated with the vertex addressed, resolving references between vertices
         */
        bones(_index) {
            let vertex = this[_index];
            return (vertex.referTo == undefined) ? vertex.bones : this[vertex.referTo].bones;
        }
    }
    FudgeCore.Vertices = Vertices;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A WebGL shaderprogram for a particle system. Managed by a {@link ParticleSystem}. It uses {@link ParticleSystem.data} to generate and inject code into a shader universal derivate (GLSL) thus creating a shader particle system from a supplied {@link Shader}s vertex and fragment shader source code.
     * @author Jonas Plotzky, HFU, 2022
     * @internal
     */
    let ShaderParticleSystem = (() => {
        var _a;
        let _classDecorators = [(_a = FudgeCore.RenderInjectorShaderParticleSystem).decorate.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        var ShaderParticleSystem = class {
            static { _classThis = this; }
            constructor() {
                this.define = ["PARTICLE"];
            }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                ShaderParticleSystem = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(_classThis, _classExtraInitializers);
            }
            /**
             * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
             * @internal
             */
            getVertexShaderSource() { return ""; /* injected by decorator */ }
            /**
             * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
             * @internal
             */
            getFragmentShaderSource() { return ""; /* injected by decorator */ }
            /**
             * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
             * @internal
             */
            deleteProgram() { }
            /**
             * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
             * @internal
             */
            useProgram() { }
            /**
             * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
             * @internal
             */
            createProgram() { }
        };
        return ShaderParticleSystem = _classThis;
    })();
    FudgeCore.ShaderParticleSystem = ShaderParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Enables this node to access the waypoint grid established through {@link ComponentWaypoint}s and their {@link Connection}s,
     * find a path through them and even walk down the path.
     * @author Lukas Scheuerle, HFU, 2024
     */
    class ComponentWalker extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentWalker); }
        /** If true, move the node this component is attached to through forces instead of directly through the transform. Requires a [[ComponentRigidbody]] if true. */
        // public moveThroughPhysics: boolean = false;
        /** keeps the data needed for the current walk */
        #walkData;
        /** keeps the promise to resolve when the walker has reached the goal */
        #promiseResolverOnWalkFinished;
        /** status of whether it should rotate the walker to the walking direction */
        #rotateInWalkDirection;
        constructor() {
            super();
            /** The speed the walker should move with. Corresponds to units/s. */
            this.speed = 1;
            /** If true, move the node this component is attached to through forces instead of directly through the transform. Requires a [[ComponentRigidbody]] if true. */
            // public moveThroughPhysics: boolean = false;
            /** keeps the data needed for the current walk */
            this.#walkData = { path: [], totalProgress: -1 };
            /** status of whether it should rotate the walker to the walking direction */
            this.#rotateInWalkDirection = false;
            if (FudgeCore.Project.mode == FudgeCore.MODE.EDITOR)
                return;
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.#handleAttach.bind(this));
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.#handleDetach.bind(this));
        }
        serialize() {
            let serialization = {
                [super.constructor.name]: super.serialize(),
                speed: this.speed
                // moveThroughPhysics: this.moveThroughPhysics,
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.speed = _serialization.speed;
            // this.moveThroughPhysics = _serialization.moveThroughPhysics;
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async moveTo(_start, _end, _rotate = false) {
            if (!_start)
                return;
            let translate = FudgeCore.Vector3.DIFFERENCE(_start.mtxWorld.translation, this.node.mtxWorld.translation);
            this.node.mtxLocal.translate(translate);
            if (!_end || _start === _end) {
                this.#walkData = { path: [], totalProgress: -1 };
                return;
            }
            this.#rotateInWalkDirection = _rotate;
            return new Promise((_resolve, _reject) => {
                let path = this.getPath(_start, _end);
                if (!path || path.length === 0) {
                    _reject();
                    return;
                }
                this.#walkData = { path, totalProgress: 0 };
                this.#promiseResolverOnWalkFinished = _resolve;
                if (this.#rotateInWalkDirection && this.#walkData.path.length >= 1) {
                    this.rotateTowards(this.#walkData.path[0].waypoint);
                }
            });
        }
        /** Takes care of the moving algorithm by calculating the next step and moving along this step */
        moving() {
            // are we currently moving?
            if (this.#walkData.totalProgress < 0 || this.#walkData.path.length == 0)
                return;
            // do we have a current path we can follow
            let currentPath = this.#walkData.path[this.#walkData.totalProgress];
            if (!currentPath)
                return;
            // how big of a step are we taking this frame?
            let delta = this.speed * currentPath.previousConnection.speedModifier * FudgeCore.Loop.timeFrameGame / 1000;
            // how far away are we from the next waypoint?
            let step = FudgeCore.Vector3.DIFFERENCE(currentPath.waypoint.mtxWorld.translation, this.node.mtxWorld.translation);
            // let stepRotation: Matrix4x4 = Matrix4x4.CONSTRUCTION(step);
            // stepRotation.rotate(this.node.mtxWorld.rotation);
            // step = stepRotation.translation;
            let scale = FudgeCore.Vector3.DIFFERENCE(currentPath.waypoint.mtxWorld.scaling, this.node.mtxWorld.scaling);
            if (delta * delta < step.magnitudeSquared) { // won't reach next waypoint yet. Using squares because that's faster to compute than sqrt
                step.normalize(delta);
                this.node.mtxLocal.translate(step, false);
                if (scale.magnitudeSquared > 0) {
                    scale.normalize(delta);
                }
                this.node.mtxLocal.scaling = FudgeCore.Vector3.SUM(scale, this.node.mtxLocal.scaling);
                // this.node.mtxLocal.scale(Vector3.SUM(scale, this.node.mtxLocal.scaling));
                // TODO implement movement through physics
                return;
            }
            // reached next point
            this.dispatchEvent(new CustomEvent("waypointReached" /* EVENT.WAYPOINT_REACHED */, { bubbles: true, detail: currentPath.waypoint }));
            currentPath.waypoint.dispatchEvent(new CustomEvent("waypointReached" /* EVENT.WAYPOINT_REACHED */, { bubbles: true, detail: this }));
            let translate = FudgeCore.Vector3.DIFFERENCE(currentPath.waypoint.mtxWorld.translation, this.node.mtxWorld.translation);
            this.node.mtxLocal.translate(translate, false);
            this.node.mtxLocal.scaling = currentPath.waypoint.mtxWorld.scaling;
            this.#walkData.totalProgress++;
            // reached final point, finished walking
            if (this.#walkData.totalProgress >= this.#walkData.path.length) {
                if (this.#promiseResolverOnWalkFinished)
                    this.#promiseResolverOnWalkFinished();
                this.dispatchEvent(new CustomEvent("pathingConcluded" /* EVENT.PATHING_CONCLUDED */, { bubbles: true, detail: currentPath.waypoint }));
                return;
            }
            // should we rotate walker?
            if (this.#rotateInWalkDirection) {
                this.rotateTowards(this.#walkData.path[this.#walkData.totalProgress].waypoint);
            }
        }
        /** find the path between two given waypoints */
        getPath(_start, _end) {
            // TODO: use a more efficient algorithm like A* instead of Dijkstra
            // setup the graph of paths based on the start node
            let unvisitedNodes = [];
            let processedWaypoints = [_start];
            let waypointsToSearchThrough = [_start];
            do {
                let waypoint = waypointsToSearchThrough.pop();
                for (let connection of waypoint.connections) {
                    if (!processedWaypoints.includes(connection.end) && connection.start.isActive && connection.end.isActive) {
                        waypointsToSearchThrough.push(connection.end);
                        processedWaypoints.push(connection.end);
                    }
                }
                unvisitedNodes.push({ waypoint, distance: waypoint === _start ? 0 : Infinity, previous: null, previousConnection: null });
            } while (waypointsToSearchThrough.length > 0);
            // do the dijkstra
            while (unvisitedNodes.length > 0) {
                unvisitedNodes.sort((_a, _b) => _a.distance - _b.distance);
                let currentNode = unvisitedNodes.shift();
                if (currentNode.waypoint === _end)
                    return this.pathingNodeToPath(currentNode);
                for (let con of currentNode.waypoint.connections) {
                    if (!this.isConnectionUsable(con))
                        continue;
                    let endNode = unvisitedNodes.find(_n => _n.waypoint === con.end);
                    if (!endNode)
                        continue;
                    let newDistance = currentNode.distance + this.calculateConnectionCost(con);
                    if (newDistance >= endNode.distance)
                        continue;
                    endNode.distance = newDistance;
                    endNode.previous = currentNode;
                    endNode.previousConnection = con;
                }
            }
            return null;
        }
        /**
         * Checks whether a connection is usable by this specific walker.
         * **Always returns true, unless overwritten in a custom Walker subclass.**
         * Can be used to influence the pathfinding algorithm for custom waypoint / connection systems.
         * @param _connection A connection to check
         * @returns true if the connection is usable by this walker, false if not
         */
        isConnectionUsable(_connection) {
            return true;
        }
        /**
         * Calculates the new distance based on a connection.
         * **Always returns the plain connections cost unless overwritten in a custom walker subclass.**
         * Can be used to influence the pathfinding algorithm for custom waypoint / connection systems.
         * @param _connection A connection to check
         * @returns the amount of cost a connection encurs to the current walker or 0 if cost is negative.
         */
        calculateConnectionCost(_connection) {
            if (_connection.cost >= 0)
                return _connection.cost;
            return 0;
        }
        pathingNodeToPath(_node) {
            let path = [];
            if (!_node)
                return path;
            do {
                path.push(_node);
                _node = _node.previous;
            } while (_node?.previous);
            return path.reverse();
        }
        rotateTowards(_waypoint) {
            let mtxLook = FudgeCore.Matrix4x4.LOOK_AT(this.node.mtxWorld.translation, _waypoint.mtxWorld.translation);
            this.node.mtxLocal.rotation = mtxLook.rotation;
        }
        #handleAttach() {
            FudgeCore.Loop.addEventListener("loopFrame" /* EVENT.LOOP_FRAME */, this.moving.bind(this));
        }
        #handleDetach() {
            FudgeCore.Loop.removeEventListener("loopFrame" /* EVENT.LOOP_FRAME */, this.moving.bind(this));
        }
    }
    FudgeCore.ComponentWalker = ComponentWalker;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    var _a;
    /**
     * Sets a position that a {@link ComponentWalker} can use as a target point.
     * Implements {@link Waypoint}.
     * Registers itself to a static list of all available waypoints
     * @author Lukas Scheuerle, HFU, 2024
     */
    class ComponentWaypoint extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(this); }
        static #waypoints = [];
        #connections;
        constructor(_mtxInit = FudgeCore.Matrix4x4.IDENTITY(), _connections = []) {
            super();
            this.#connections = _connections;
            this.mtxLocal = _mtxInit;
            this.singleton = false;
            if (FudgeCore.Project.mode == FudgeCore.MODE.EDITOR)
                return;
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.#handleAttach.bind(this));
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.#handleDetach.bind(this));
        }
        /** All the waypoints that are currently loaded in the scene. **Do not edit, treat as readonly!** */
        static get waypoints() {
            return _a.#waypoints;
        }
        /**
         * A shorthand to create a connection between two {@link ComponentWaypoint}s
         * @param _start The {@link ComponentWaypoint} from which to start the connection.
         * @param _end The {@link ComponentWaypoint} to which the connection leads.
         * @param _cost The cost of the connection. The higher the value, the less likely it is to be taken. Cannot be negative.
         * @param _speedModifier How fast the connection can be walked on. Defaults to 1
         * @param _bothWays If true, creates a connection in both directions. Default: false
         */
        static addConnection(_start, _end, _cost, _speedModifier = 1, _bothWays = false) {
            _start.addConnection({ cost: _cost, end: _end, start: _start, speedModifier: _speedModifier });
            if (_bothWays)
                _end.addConnection({ cost: _cost, end: _start, start: _end, speedModifier: _speedModifier });
        }
        get isActive() {
            return this.active;
        }
        get connections() {
            return this.#connections;
        }
        /** The current world position of the Waypoint. Returns a new Matrix without connection to the Waypoint */
        get mtxWorld() {
            return FudgeCore.Matrix4x4.PRODUCT(this.mtxLocal, this.node.mtxWorld);
        }
        /** Adds a new {@link Connection} to this waypoint */
        addConnection(_connection) {
            this.#connections.push(_connection);
        }
        /** Removes a {@link Connection} from this waypoint */
        removeConnection(_connection) {
            let index = this.#connections.indexOf(_connection);
            if (index < 0)
                return;
            this.#connections.splice(index, 1);
        }
        serialize() {
            let serialization = {
                [super.constructor.name]: super.serialize(),
                matrix: this.mtxLocal.serialize(),
                connections: this.#connections.map(_con => {
                    let connection = { cost: _con.cost, end: _con.end, speedModifier: _con.speedModifier };
                    if (connection.end instanceof _a) {
                        connection.end = FudgeCore.Node.PATH_FROM_TO(this, connection.end);
                    }
                    return connection;
                })
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.mtxLocal.deserialize(_serialization.matrix);
            const hndNodeDeserialized = () => {
                this.#connections = _serialization.connections.map((_con) => {
                    let connection = { cost: _con.cost, end: this.serializedWaypointToWaypoint(_con.end), speedModifier: _con.speedModifier, start: this };
                    return connection;
                });
                this.removeEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
            };
            this.addEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        drawGizmos() {
            let scaleVector = FudgeCore.Vector3.SCALE(FudgeCore.Vector3.ONE(), 0.1);
            let mtx = this.mtxWorld;
            FudgeCore.Gizmos.drawSphere(FudgeCore.Matrix4x4.COMPOSITION(mtx.translation, FudgeCore.Vector3.ZERO(), scaleVector), FudgeCore.Color.CSS("orange"));
            // return;
            let lines = [];
            for (let connection of this.connections) {
                // if the start and end point are on the same point, don't draw line.
                let tmpMtx = connection.end.mtxWorld.clone;
                let directionVector = FudgeCore.Vector3.DIFFERENCE(mtx.translation, tmpMtx.translation);
                if (directionVector.magnitudeSquared === 0)
                    continue;
                // if one of the waypoints is inactive, don't draw gizmos
                if (!connection.end.isActive || !connection.start.isActive)
                    continue;
                // actual line
                lines.push(mtx.translation);
                lines.push(tmpMtx.translation);
                // arrow heads
                let directionMtx = FudgeCore.Matrix4x4.LOOK_IN(tmpMtx.translation, directionVector);
                directionMtx.scale(scaleVector);
                FudgeCore.Gizmos.drawWireCone(directionMtx, FudgeCore.Color.CSS("orange"));
            }
            FudgeCore.Gizmos.drawLines(lines, FudgeCore.Matrix4x4.IDENTITY(), FudgeCore.Color.CSS("orange"));
        }
        /** An internal function to help the deserializaztion process. */
        serializedWaypointToWaypoint(_point) {
            if (typeof _point !== "string")
                return _point;
            return FudgeCore.Node.FIND(this, _point);
        }
        #handleAttach() {
            _a.#waypoints.push(this);
        }
        #handleDetach() {
            let index = _a.#waypoints.indexOf(this);
            if (index >= 0) {
                _a.#waypoints.splice(index, 1);
            }
        }
    }
    _a = ComponentWaypoint;
    FudgeCore.ComponentWaypoint = ComponentWaypoint;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines automatic adjustment of the collider
     */
    let BODY_INIT;
    (function (BODY_INIT) {
        /** Collider uses the pivot of the mesh for initilialization */
        BODY_INIT[BODY_INIT["TO_MESH"] = 0] = "TO_MESH";
        /** Collider uses the transform of the node for initilialization */
        BODY_INIT[BODY_INIT["TO_NODE"] = 1] = "TO_NODE";
        /** Collider uses its own pivot for initilialization */
        BODY_INIT[BODY_INIT["TO_PIVOT"] = 2] = "TO_PIVOT";
    })(BODY_INIT = FudgeCore.BODY_INIT || (FudgeCore.BODY_INIT = {}));
    /**
     * Acts as the physical representation of the {@link Node} it's attached to.
     * It's the connection between the FUDGE rendered world and the Physics world.
     * For the physics to correctly get the transformations rotations need to be applied with from left = true.
     * Or rotations need to happen before scaling.
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class ComponentRigidbody extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentRigidbody); }
        static { this.mapBodyType = (typeof OIMO == "undefined") ?
            {
                [FudgeCore.BODY_TYPE.DYNAMIC]: FudgeCore.BODY_TYPE.DYNAMIC, [FudgeCore.BODY_TYPE.STATIC]: FudgeCore.BODY_TYPE.STATIC, [FudgeCore.BODY_TYPE.KINEMATIC]: FudgeCore.BODY_TYPE.KINEMATIC
            } : {
            [FudgeCore.BODY_TYPE.DYNAMIC]: OIMO.RigidBodyType.DYNAMIC, [FudgeCore.BODY_TYPE.STATIC]: OIMO.RigidBodyType.STATIC, [FudgeCore.BODY_TYPE.KINEMATIC]: OIMO.RigidBodyType.KINEMATIC
        }; }
        /** ID to reference this specific ComponentRigidbody */
        #id;
        //Private informations - Mostly OimoPhysics variables that should not be exposed to the FUDGE User and manipulated by them
        #collider;
        #colliderInfo;
        #collisionGroup;
        #typeCollider;
        #rigidbody;
        #rigidbodyInfo;
        #typeBody;
        #massData;
        #restitution;
        #friction;
        #dampingLinear;
        #dampingAngular;
        #effectRotation;
        #effectGravity;
        #isTrigger;
        #mtxPivotUnscaled;
        #mtxPivotInverse;
        #callbacks; //Callback Methods when within the oimoSystem a event is happening
        // #physics: Physics; //TODO: keep a pointer to the physics instance used by this component
        /** Creating a new rigidbody with a weight in kg, a physics type (default = dynamic), a collider type what physical form has the collider, to what group does it belong, is there a transform Matrix that should be used, and is the collider defined as a group of points that represent a convex mesh. */
        constructor(_mass = 1, _type = FudgeCore.BODY_TYPE.DYNAMIC, _colliderType = FudgeCore.COLLIDER_TYPE.CUBE, _group = FudgeCore.Physics.settings.defaultCollisionGroup, _mtxTransform = null, _convexMesh = null) {
            super();
            /** Transformation of the collider relative to the node's transform. Once set mostly remains constant.
             * If altered, {@link isInitialized} must be reset to false to recreate the collider in the next {@link Render.prepare}
             */
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            /**
             * Vertices that build a convex mesh (form that is in itself closed). Needs to set in the construction of the rb if none of the standard colliders is used.
             * Untested and not yet fully supported by serialization and mutation.
             */
            this.convexMesh = null;
            /** Collisions with rigidbodies happening to this body, can be used to build a custom onCollisionStay functionality. */
            this.collisions = new Array();
            /** Triggers that are currently triggering this body */
            this.triggerings = new Array();
            /**
             * Automatic adjustment of the pivot when {@link Render.prepare} is called according to {@link BODY_INIT}
             */
            this.initialization = BODY_INIT.TO_PIVOT;
            /** Marks if collider was initialized. Reset to false to initialize again e.g. after manipulation of mtxPivot */
            this.isInitialized = false;
            /** ID to reference this specific ComponentRigidbody */
            this.#id = 0;
            this.#collisionGroup = FudgeCore.COLLISION_GROUP.DEFAULT;
            this.#typeCollider = FudgeCore.COLLIDER_TYPE.CUBE;
            this.#rigidbodyInfo = new OIMO.RigidBodyConfig();
            this.#typeBody = FudgeCore.BODY_TYPE.DYNAMIC;
            this.#massData = new OIMO.MassData();
            this.#dampingLinear = 0.1;
            this.#dampingAngular = 0.1;
            this.#effectRotation = FudgeCore.Vector3.ONE();
            this.#effectGravity = 1;
            this.#isTrigger = false;
            this.#mtxPivotUnscaled = FudgeCore.Matrix4x4.IDENTITY();
            this.#mtxPivotInverse = FudgeCore.Matrix4x4.IDENTITY();
            //#endregion
            // Activate the functions of this component as response to events
            this.hndEvent = (_event) => {
                switch (_event.type) {
                    case "componentAdd" /* EVENT.COMPONENT_ADD */:
                        // this.addEventListener(EVENT.COMPONENT_ACTIVATE, this.addRigidbodyToWorld);
                        this.addEventListener("componentDeactivate" /* EVENT.COMPONENT_DEACTIVATE */, this.removeRigidbodyFromWorld);
                        // this.node.addEventListener(EVENT.NODE_ACTIVATE, this.addRigidbodyToWorld, true); // use capture to react to broadcast!
                        this.node.addEventListener("nodeDeactivate" /* EVENT.NODE_DEACTIVATE */, this.hndNodeDeactivate, true);
                        if (!this.node.cmpTransform)
                            FudgeCore.Debug.warn("ComponentRigidbody attached to node missing ComponentTransform", this.node);
                        break;
                    case "componentRemove" /* EVENT.COMPONENT_REMOVE */:
                        // this.removeEventListener(EVENT.COMPONENT_ADD, this.addRigidbodyToWorld);
                        this.removeEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.removeRigidbodyFromWorld);
                        // this.node.removeEventListener(EVENT.NODE_ACTIVATE, this.addRigidbodyToWorld, true); // use capture to react to broadcast!
                        this.node.removeEventListener("nodeDeactivate" /* EVENT.NODE_DEACTIVATE */, this.hndNodeDeactivate, true);
                        this.removeRigidbodyFromWorld();
                        break;
                    case "nodeDeserialized" /* EVENT.NODE_DESERIALIZED */:
                        if (!this.node.cmpTransform)
                            FudgeCore.Debug.error("ComponentRigidbody attached to node missing ComponentTransform", this.node);
                        break;
                }
            };
            /** Adding this ComponentRigidbody to the Physiscs.world giving the oimoPhysics system the information needed */
            this.addRigidbodyToWorld = () => {
                if (!this.#rigidbody._world)
                    FudgeCore.Physics.addRigidbody(this);
            };
            /** Capture only events that are broadcast to this node from an ancestor. Don't capture events that get send to descendants. */
            this.hndNodeDeactivate = (_event) => {
                let path = this.node.getPath();
                if (!path.includes(_event.target))
                    return;
                this.removeRigidbodyFromWorld();
            };
            /** Removing this ComponentRigidbody from the Physiscs.world taking the informations from the oimoPhysics system */
            this.removeRigidbodyFromWorld = () => {
                FudgeCore.Physics.removeRigidbody(this);
                this.isInitialized = false;
            };
            this.create(_mass, _type, _colliderType, _group, _mtxTransform, _convexMesh);
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.hndEvent);
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.hndEvent);
            // this.addEventListener(EVENT.NODE_DESERIALIZED, this.hndEvent);
        }
        //#region Accessors
        get id() {
            return this.#id;
        }
        /** Used for calculation of the geometrical relationship of node and collider by {@link Render}*/
        get mtxPivotInverse() {
            return this.#mtxPivotInverse;
        }
        /** Used for calculation of the geometrical relationship of node and collider by {@link Render}*/
        get mtxPivotUnscaled() {
            return this.#mtxPivotUnscaled;
        }
        /** Retrieve the body type. See {@link BODY_TYPE} */
        get typeBody() {
            return this.#typeBody;
        }
        /** Set the body type. See {@link BODY_TYPE} */
        set typeBody(_value) {
            this.#typeBody = _value;
            this.#rigidbody.setType(ComponentRigidbody.mapBodyType[this.#typeBody]);
            this.#rigidbody.setMassData(this.#massData); //have to reset mass after changing the type, since Oimo is handling mass internally wrong when switching types
        }
        /** The shape that represents the {@link Node} in the physical world. Default is a Cube. */
        get typeCollider() {
            return this.#typeCollider;
        }
        set typeCollider(_value) {
            if (_value != this.#typeCollider && this.#rigidbody != null) {
                this.#typeCollider = _value;
                this.initialize();
            }
        }
        /** The collision group this {@link Node} belongs to it's the default group normally which means it physically collides with every group besides trigger. */
        get collisionGroup() {
            return this.#collisionGroup;
        }
        set collisionGroup(_value) {
            this.#collisionGroup = _value;
            if (this.#rigidbody != null)
                this.#rigidbody.getShapeList().setCollisionGroup(this.#collisionGroup);
        }
        /** Marking the Body as a trigger therefore not influencing the collision system but only sending triggerEvents */
        get isTrigger() {
            return this.#isTrigger;
        }
        set isTrigger(_value) {
            this.#isTrigger = _value;
            if (this.getOimoRigidbody() != null) {
                this.getOimoRigidbody()._isTrigger = this.#isTrigger;
            }
        }
        /**
         * Returns the physical weight of the {@link Node}
         */
        get mass() {
            return this.#rigidbody.getMass();
        }
        /**
         * Setting the physical weight of the {@link Node} in kg
         */
        set mass(_value) {
            this.#massData.mass = _value;
            if (this.node != null)
                if (this.#rigidbody != null)
                    this.#rigidbody.setMassData(this.#massData);
        }
        /** Drag of linear movement. A Body does slow down even on a surface without friction. */
        get dampTranslation() {
            return this.#rigidbody.getLinearDamping();
        }
        set dampTranslation(_value) {
            this.#dampingLinear = _value;
            this.#rigidbody.setLinearDamping(_value);
        }
        /** Drag of rotation. */
        get dampRotation() {
            return this.#rigidbody.getAngularDamping();
        }
        set dampRotation(_value) {
            this.#dampingAngular = _value;
            this.#rigidbody.setAngularDamping(_value);
        }
        /** The factor this rigidbody reacts rotations that happen in the physical world. 0 to lock rotation this axis. */
        get effectRotation() {
            return this.#effectRotation;
        }
        set effectRotation(_effect) {
            this.#effectRotation = _effect;
            this.#rigidbody.setRotationFactor(new OIMO.Vec3(this.#effectRotation.x, this.#effectRotation.y, this.#effectRotation.z));
        }
        /** The factor this rigidbody reacts to world gravity. Default = 1 e.g. 1*9.81 m/s. */
        get effectGravity() {
            return this.#effectGravity;
        }
        set effectGravity(_effect) {
            this.#effectGravity = _effect;
            if (this.#rigidbody != null)
                this.#rigidbody.setGravityScale(this.#effectGravity);
        }
        /**
         * Get the friction of the rigidbody, which is the factor of sliding resistance of this rigidbody on surfaces
         */
        get friction() {
            return this.#friction;
        }
        /**
         * Set the friction of the rigidbody, which is the factor of  sliding resistance of this rigidbody on surfaces
         */
        set friction(_friction) {
            this.#friction = _friction;
            if (this.#rigidbody.getShapeList() != null)
                this.#rigidbody.getShapeList().setFriction(this.#friction);
        }
        /**
         * Get the restitution of the rigidbody, which is the factor of bounciness of this rigidbody on surfaces
         */
        get restitution() {
            return this.#restitution;
        }
        /**
         * Set the restitution of the rigidbody, which is the factor of bounciness of this rigidbody on surfaces
         */
        set restitution(_restitution) {
            this.#restitution = _restitution;
            if (this.#rigidbody.getShapeList() != null)
                this.#rigidbody.getShapeList().setRestitution(this.#restitution);
        }
        //#endregion
        //#region Transformation
        /**
         * Returns the rigidbody in the form the physics engine is using it, should not be used unless a functionality
         * is not provided through the FUDGE Integration.
         */
        getOimoRigidbody() {
            return this.#rigidbody;
        }
        /** Rotating the rigidbody therefore changing it's rotation over time directly in physics. This way physics is changing instead of transform.
         *  But you are able to incremental changing it instead of a direct rotation.  Although it's always prefered to use forces in physics.
         */
        rotateBody(_rotationChange) {
            this.#rigidbody.rotateXyz(new OIMO.Vec3(_rotationChange.x * FudgeCore.Calc.deg2rad, _rotationChange.y * FudgeCore.Calc.deg2rad, _rotationChange.z * FudgeCore.Calc.deg2rad));
        }
        /** Translating the rigidbody therefore changing it's place over time directly in physics. This way physics is changing instead of transform.
         *  But you are able to incrementally changing it instead of a direct position. Although it's always prefered to use forces in physics.
         */
        translateBody(_translationChange) {
            this.#rigidbody.translate(new OIMO.Vec3(_translationChange.x, _translationChange.y, _translationChange.z));
        }
        /**
         * Get the current POSITION of the {@link Node} in the physical space
         */
        getPosition() {
            let tmpPos = this.#rigidbody.getPosition();
            return new FudgeCore.Vector3(tmpPos.x, tmpPos.y, tmpPos.z);
        }
        /**
         * Sets the current POSITION of the {@link Node} in the physical space
         */
        setPosition(_value) {
            this.#rigidbody.setPosition(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /**
         * Get the current ROTATION of the {@link Node} in the physical space. Note this range from -pi to pi, so -90 to 90.
         */
        getRotation() {
            let orientation = this.#rigidbody.getOrientation();
            let tmpQuat = FudgeCore.Recycler.get(FudgeCore.Quaternion);
            tmpQuat.set(orientation.x, orientation.y, orientation.z, orientation.w);
            let eulerAngles = tmpQuat.eulerAngles.clone;
            FudgeCore.Recycler.store(tmpQuat);
            return eulerAngles;
        }
        /**
         * Sets the current ROTATION of the {@link Node} in the physical space, in degree.
         */
        setRotation(_value) {
            let quaternion = _value instanceof FudgeCore.Vector3 ? FudgeCore.Quaternion.ROTATION(_value) : _value;
            let quat = new OIMO.Quat(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
            if (_value instanceof FudgeCore.Vector3)
                FudgeCore.Recycler.store(quaternion);
            this.#rigidbody.setOrientation(quat);
        }
        /** Get the current SCALING in the physical space. */
        getScaling() {
            let scaling = this.node.mtxWorld.scaling.clone;
            scaling.x *= this.mtxPivot.scaling.x;
            scaling.y *= this.mtxPivot.scaling.y;
            scaling.z *= this.mtxPivot.scaling.z;
            return scaling;
        }
        /** Scaling requires the collider to be completely recreated anew */
        setScaling(_value) {
            // let scaling: Vector3 = _value.clone;   
            this.createCollider(new OIMO.Vec3(_value.x / 2, _value.y / 2, _value.z / 2), this.#typeCollider); //recreate the collider
            this.#collider = new OIMO.Shape(this.#colliderInfo);
            let oldCollider = this.#rigidbody.getShapeList();
            this.#rigidbody.addShape(this.#collider); //add new collider, before removing the old, so the rb is never active with 0 colliders
            this.#rigidbody.removeShape(oldCollider); //remove the old collider
            this.#collider.userData = this; //reset the extra information so that this collider knows to which FUDGE Component it's connected
            this.#collider.setCollisionGroup(this.collisionGroup);
            this.#collider.setCollisionMask(this.collisionMask);
            this.#collider.setRestitution(this.#restitution);
            this.#collider.setFriction(this.#friction);
            this.#collider.setContactCallback(this.#callbacks);
        }
        /**
         * Initializes the rigidbody according to its initialization setting to match the mesh, the node or its own pivot matrix
         */
        initialize() {
            if (!this.node) // delay initialization until this rigidbody is attached to a node
                return;
            switch (Number(this.initialization)) {
                case BODY_INIT.TO_NODE:
                    this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
                    break;
                case BODY_INIT.TO_MESH:
                    let cmpMesh = this.node.getComponent(FudgeCore.ComponentMesh);
                    if (cmpMesh)
                        this.mtxPivot = cmpMesh.mtxPivot.clone;
                    break;
                case BODY_INIT.TO_PIVOT:
                    break;
            }
            let mtxWorld = FudgeCore.Matrix4x4.PRODUCT(this.node.mtxWorld, this.mtxPivot);
            let position = mtxWorld.translation; //Adding the offsets from the pivot
            let rotation = mtxWorld.rotation;
            let scaling = mtxWorld.scaling;
            //scaling requires collider to be recreated
            this.setScaling(scaling);
            this.#rigidbody.setMassData(this.#massData);
            this.setPosition(position); //set the actual new rotation/position for this Rb again since it's now updated
            this.setRotation(rotation);
            let scalingInverse = this.node.mtxWorld.scaling.map(_i => 1 / _i);
            this.#mtxPivotUnscaled = FudgeCore.Matrix4x4.COMPOSITION(this.mtxPivot.translation, this.mtxPivot.rotation, scalingInverse);
            this.#mtxPivotInverse = FudgeCore.Matrix4x4.INVERSE(this.#mtxPivotUnscaled);
            this.addRigidbodyToWorld();
            this.isInitialized = true;
        }
        //#endregion
        //#region Velocity and Forces
        /**
        * Get the current VELOCITY of the {@link Node}
        */
        getVelocity() {
            let velocity = this.#rigidbody.getLinearVelocity();
            return new FudgeCore.Vector3(velocity.x, velocity.y, velocity.z);
        }
        /**
         * Sets the current VELOCITY of the {@link Node}
         */
        setVelocity(_value) {
            let velocity = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.#rigidbody.setLinearVelocity(velocity);
        }
        /**
         * Get the current ANGULAR - VELOCITY of the {@link Node}
         */
        getAngularVelocity() {
            let velocity = this.#rigidbody.getAngularVelocity();
            return new FudgeCore.Vector3(velocity.x, velocity.y, velocity.z);
        }
        /**
         * Sets the current ANGULAR - VELOCITY of the {@link Node}
         */
        setAngularVelocity(_value) {
            let velocity = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.#rigidbody.setAngularVelocity(velocity);
        }
        /**
        * Applies a continous FORCE at the center of the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS.
        * The force is measured in newton, 1kg needs about 10 Newton to fight against gravity.
        */
        applyForce(_force) {
            this.#rigidbody.applyForceToCenter(new OIMO.Vec3(_force.x, _force.y, _force.z));
        }
        /**
        * Applies a continous FORCE at a specific point in the world to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        */
        applyForceAtPoint(_force, _worldPoint) {
            this.#rigidbody.applyForce(new OIMO.Vec3(_force.x, _force.y, _force.z), new OIMO.Vec3(_worldPoint.x, _worldPoint.y, _worldPoint.z));
        }
        /**
        * Applies a continous ROTATIONAL FORCE (Torque) to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        */
        applyTorque(_rotationalForce) {
            this.#rigidbody.applyTorque(new OIMO.Vec3(_rotationalForce.x, _rotationalForce.y, _rotationalForce.z));
        }
        /**
        * Applies a instant FORCE at a point/rigidbodycenter to the RIGIDBODY in the three dimensions. Considering the rigidbod's MASS
        * Influencing the angular speed and the linear speed.
        */
        applyImpulseAtPoint(_impulse, _worldPoint = null) {
            _worldPoint = _worldPoint != null ? _worldPoint : this.getPosition();
            this.#rigidbody.applyImpulse(new OIMO.Vec3(_impulse.x, _impulse.y, _impulse.z), new OIMO.Vec3(_worldPoint.x, _worldPoint.y, _worldPoint.z));
        }
        /**
        * Applies a instant FORCE to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        * Only influencing it's speed not rotation.
        */
        applyLinearImpulse(_impulse) {
            this.#rigidbody.applyLinearImpulse(new OIMO.Vec3(_impulse.x, _impulse.y, _impulse.z));
        }
        /**
         * Applies a instant ROTATIONAL-FORCE to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
         * Only influencing it's rotation.
         */
        applyAngularImpulse(_rotationalImpulse) {
            this.#rigidbody.applyAngularImpulse(new OIMO.Vec3(_rotationalImpulse.x, _rotationalImpulse.y, _rotationalImpulse.z));
        }
        /**
         * Changing the VELOCITY of the RIGIDBODY. Only influencing the linear speed not angular
         */
        addVelocity(_value) {
            this.#rigidbody.addLinearVelocity(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /**
         * Changing the VELOCITY of the RIGIDBODY. Only influencing the angular speed not the linear
         */
        addAngularVelocity(_value) {
            this.#rigidbody.addAngularVelocity(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /**
         * De- / Activate the rigidbodies auto-sleeping function.
         * If activated the rigidbody will automatically sleep when needed, increasing performance.
         * If deactivated the rigidbody gets stopped from sleeping when movement is too minimal. Decreasing performance, for rarely more precise physics results
         */
        activateAutoSleep(_on) {
            this.#rigidbody.setAutoSleep(_on);
        }
        //#endregion
        //#region Collision
        // /**
        //  * Checking for Collision with other Colliders and dispatches a custom event with information about the collider.
        //  * Automatically called in the RenderManager, no interaction needed.
        //  */
        // public checkCollisionEvents(): void {
        //   if (!this.isInitialized) // check collisions only if initialization completed
        //     return;
        //   let contactLink: OIMO.ContactLink = this.#rigidbody.getContactLinkList(); // all physical contacts between colliding bodies on this rb
        //   while (contactLink != null) {
        //     let other: ComponentRigidbody = contactLink.getOther().userData; // get the other component rigidbody involved in the collision
        //     if (!other.isInitialized) {
        //       contactLink = contactLink.getNext();
        //       continue;
        //     }
        //     let contact: OIMO.Contact = contactLink.getContact();
        //     let wasTouching: boolean = this.collisions.includes(other);
        //     let isTouching: boolean = contact.isTouching();
        //     if (!wasTouching && isTouching) { // ENTER
        //       let manifold: OIMO.Manifold = contact.getManifold();
        //       let points: OIMO.ManifoldPoint[] = manifold.getPoints(); // All points in the collision where the two bodies are touching, used to calculate the full impact
        //       let normalImpulse: number = 0;
        //       let binormalImpulse: number = 0;
        //       let tangentImpulse: number = 0;
        //       for (let manifoldPoint of points) { // The impact of the collision involving all touching points
        //         normalImpulse += manifoldPoint.getNormalImpulse();
        //         binormalImpulse += manifoldPoint.getBinormalImpulse();
        //         tangentImpulse += manifoldPoint.getTangentImpulse();
        //       }
        //       let normal: OIMO.Vec3 = manifold.getNormal();
        //       let collisionNormal: Vector3 = new Vector3(normal.x, normal.y, normal.z);
        //       let collisionCenterPoint: Vector3 = this.collisionCenterPoint(points, manifold.getNumPoints());
        //       this.collisions.push(other);
        //       this.dispatchEvent(new EventPhysics(EVENT_PHYSICS.COLLISION_ENTER, other, normalImpulse, tangentImpulse, binormalImpulse, collisionCenterPoint, collisionNormal)); // Sending the given event
        //     } else if (wasTouching && !isTouching) { // EXIT
        //       this.collisions.splice(this.collisions.indexOf(other), 1);
        //       this.dispatchEvent(new EventPhysics(EVENT_PHYSICS.COLLISION_EXIT, other, 0, 0, 0));
        //     }
        //     contactLink = contactLink.getNext(); // Start the same routine with the next collision in the list
        //   }
        // }
        /**
         * Sends a ray through this specific body ignoring the rest of the world and checks if this body was hit by the ray,
         * returning info about the hit. Provides the same functionality and information a regular raycast does but the ray is only testing against this specific body.
         */
        raycastThisBody(_origin, _direction, _length, _debugDraw = false) {
            let hitInfo = new FudgeCore.RayHitInfo();
            let geometry = this.#rigidbody.getShapeList().getGeometry();
            let transform = this.#rigidbody.getTransform();
            let scaledDirection = _direction.clone;
            scaledDirection.scale(_length);
            let endpoint = FudgeCore.Vector3.SUM(scaledDirection, _origin.clone);
            let oimoRay = new OIMO.RayCastHit();
            let hit = geometry.rayCast(new OIMO.Vec3(_origin.x, _origin.y, _origin.z), new OIMO.Vec3(endpoint.x, endpoint.y, endpoint.z), transform, oimoRay); //the actual OimoPhysics Raycast
            if (hit) { //If hit return a bunch of informations about the hit
                hitInfo.hit = true;
                hitInfo.hitPoint = new FudgeCore.Vector3(oimoRay.position.x, oimoRay.position.y, oimoRay.position.z);
                hitInfo.hitNormal = new FudgeCore.Vector3(oimoRay.normal.x, oimoRay.normal.y, oimoRay.normal.z);
                let dx = _origin.x - hitInfo.hitPoint.x; //calculate hit distance
                let dy = _origin.y - hitInfo.hitPoint.y;
                let dz = _origin.z - hitInfo.hitPoint.z;
                hitInfo.hitDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                hitInfo.rigidbodyComponent = this;
                hitInfo.rayOrigin = _origin;
                hitInfo.rayEnd = endpoint;
            }
            else { //Only tell the origin, and the hit point is the end of the ray.
                hitInfo.rayOrigin = _origin;
                hitInfo.hitPoint = new FudgeCore.Vector3(endpoint.x, endpoint.y, endpoint.z);
            }
            if (_debugDraw) {
                FudgeCore.Physics.debugDraw.debugRay(hitInfo.rayOrigin, hitInfo.hitPoint, new FudgeCore.Color(0, 1, 0, 1));
            }
            return hitInfo;
        }
        //#endregion
        //#region Saving/Loading - Some properties might be missing, e.g. convexMesh (Float32Array)
        serialize() {
            let serialization = this.getMutator();
            delete serialization.mtxPivot;
            delete serialization.active;
            serialization.typeBody = FudgeCore.BODY_TYPE[this.#typeBody];
            serialization.typeCollider = FudgeCore.COLLIDER_TYPE[this.#typeCollider];
            serialization.initialization = BODY_INIT[this.initialization];
            serialization.id = this.#id;
            serialization.pivot = this.mtxPivot.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            super.deserialize(_serialization[super.constructor.name]);
            this.mtxPivot.deserialize(_serialization.pivot);
            this.#id = _serialization.id;
            this.mass = ifNumber(_serialization.mass, this.mass);
            this.dampTranslation = ifNumber(_serialization.dampTranslation, this.dampTranslation);
            this.dampRotation = ifNumber(_serialization.dampRotation, this.dampRotation);
            this.collisionGroup = ifNumber(_serialization.collisionGroup, this.collisionGroup);
            this.effectRotation = _serialization.effectRotation || this.effectRotation;
            this.effectGravity = ifNumber(_serialization.effectGravity, this.effectGravity);
            this.friction = ifNumber(_serialization.friction, this.friction);
            this.restitution = ifNumber(_serialization.restitution, this.restitution);
            this.isTrigger = _serialization.isTrigger || this.isTrigger;
            this.initialization = _serialization.initialization;
            this.initialization = BODY_INIT[_serialization.initialization];
            this.typeBody = FudgeCore.BODY_TYPE[_serialization.typeBody];
            this.typeCollider = FudgeCore.COLLIDER_TYPE[_serialization.typeCollider];
            // this.create(this.mass, this.#typeBody, this.#typeCollider, this.collisionGroup, null, this.convexMesh);
            return this;
        }
        /** Change properties by an associative array */
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (_mutator.typeBody != undefined)
                _mutator.typeBody = parseInt(_mutator.typeBody);
            if (_mutator.typeCollider != undefined)
                _mutator.typeCollider = parseInt(_mutator.typeCollider);
            if (_mutator.initialization != undefined)
                _mutator.initialization = parseInt(_mutator.initialization);
            await super.mutate(_mutator, _selection, _dispatchMutate);
            if (_mutator.initialization != undefined && this.isActive)
                this.initialize();
            // TODO: see if this alternative should be, at least partially, done with mutateSelection
            // let callIfExist: Function = (_key: string, _setter: Function) => {
            //   if (_mutator[_key])
            //     _setter(_mutator[_key]);
            // };
            // callIfExist("friction", (_value: number) => this.friction = _value);
            // callIfExist("restitution", (_value: number) => this.restitution = _value);
            // callIfExist("mass", (_value: number) => this.mass = _value);
            // callIfExist("dampTranslation", (_value: number) => this.dampTranslation = _value);
            // callIfExist("dampRotation", (_value: number) => this.dampRotation = _value);
            // callIfExist("effectGravity", (_value: number) => this.effectGravity = _value);
            // callIfExist("collisionGroup", (_value: COLLISION_GROUP) => this.collisionGroup = _value);
            // callIfExist("typeBody", (_value: string) => this.typeBody = parseInt(_value));
            // callIfExist("typeCollider", (_value: string) => this.typeCollider = parseInt(_value));
            // this.dispatchEvent(new Event(EVENT.MUTATE));
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.friction = this.friction;
            mutator.restitution = this.restitution;
            mutator.mass = this.mass;
            mutator.dampTranslation = this.dampTranslation;
            mutator.dampRotation = this.dampRotation;
            mutator.effectGravity = this.effectGravity;
            mutator.typeBody = this.#typeBody;
            mutator.typeCollider = this.#typeCollider;
            mutator.isTrigger = this.#isTrigger;
            // Object.preventExtensions(mutator);
            return mutator;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.typeBody)
                types.typeBody = FudgeCore.BODY_TYPE;
            if (types.typeCollider)
                types.typeCollider = FudgeCore.COLLIDER_TYPE;
            if (types.initialization)
                types.initialization = BODY_INIT;
            return types;
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.convexMesh; //Convex Mesh can't be shown in the editor because float32Array is not a viable mutator
            delete _mutator.collisionMask;
            delete _mutator.isInitialized;
        }
        //#region Creation
        create(_mass = 1, _type = FudgeCore.BODY_TYPE.DYNAMIC, _colliderType = FudgeCore.COLLIDER_TYPE.CUBE, _group = FudgeCore.Physics.settings.defaultCollisionGroup, _mtxTransform = null, _convexMesh = null) {
            //Setting up all incoming values to be internal values
            this.convexMesh = _convexMesh;
            this.#typeBody = _type;
            this.#collisionGroup = _group;
            this.#typeCollider = _colliderType;
            this.mass = _mass;
            this.#restitution = FudgeCore.Physics.settings.defaultRestitution;
            this.#friction = FudgeCore.Physics.settings.defaultFriction;
            this.collisionMask = FudgeCore.Physics.settings.defaultCollisionMask;
            //Create the actual rigidbody in the OimoPhysics Space
            this.createRigidbody(_mass, _type, this.#typeCollider, _mtxTransform, this.#collisionGroup);
            this.#id = FudgeCore.Physics.distributeBodyID();
            // Event Callbacks directly from OIMO Physics
            this.#callbacks = new OIMO.ContactCallback(); //fehm
            this.#callbacks.beginTriggerContact = this.triggerEnter;
            this.#callbacks.endTriggerContact = this.triggerExit;
            this.#callbacks.postSolve = this.collisionEnter; // use postSolve for collisionEnter to get the impulse
            this.#callbacks.endContact = this.collisionExit;
        }
        /** Creates the actual OimoPhysics Rigidbody out of informations the FUDGE Component has. */
        createRigidbody(_mass, _type, _colliderType, _mtxTransform, _collisionGroup = FudgeCore.COLLISION_GROUP.DEFAULT) {
            let oimoType; //Need the conversion from simple enum to number because if enum is defined as Oimo.RigidyBodyType you have to include Oimo to use FUDGE at all
            switch (_type) {
                case FudgeCore.BODY_TYPE.DYNAMIC:
                    oimoType = OIMO.RigidBodyType.DYNAMIC;
                    break;
                case FudgeCore.BODY_TYPE.STATIC:
                    oimoType = OIMO.RigidBodyType.STATIC;
                    break;
                case FudgeCore.BODY_TYPE.KINEMATIC:
                    oimoType = OIMO.RigidBodyType.KINEMATIC;
                    break;
                default:
                    oimoType = OIMO.RigidBodyType.DYNAMIC;
                    break;
            }
            // remove all previous shapes from world. Necessary?
            // while (this.#rigidbody && this.#rigidbody.getShapeList() != null)
            //   this.#rigidbody.removeShape(this.#rigidbody.getShapeList());
            let tmpTransform = _mtxTransform == null ? super.node != null ? super.node.mtxWorld : FudgeCore.Matrix4x4.IDENTITY() : _mtxTransform; //Get transform informations from the world, since physics does not care about hierarchy
            //Convert informations from FUDGE to OimoPhysics and creating a collider with it, while also adding a pivot to derivate from the transform informations if needed
            let scale = new OIMO.Vec3((tmpTransform.scaling.x * this.mtxPivot.scaling.x) / 2, (tmpTransform.scaling.y * this.mtxPivot.scaling.y) / 2, (tmpTransform.scaling.z * this.mtxPivot.scaling.z) / 2);
            let position = new OIMO.Vec3(tmpTransform.translation.x + this.mtxPivot.translation.x, tmpTransform.translation.y + this.mtxPivot.translation.y, tmpTransform.translation.z + this.mtxPivot.translation.z);
            let rotation = new OIMO.Vec3(tmpTransform.rotation.x + this.mtxPivot.rotation.x, tmpTransform.rotation.y + this.mtxPivot.rotation.y, tmpTransform.rotation.z + this.mtxPivot.rotation.z);
            this.createCollider(scale, _colliderType);
            //Setting informations about mass, position/rotation and physical reaction type
            this.#massData.mass = _mass; //_type != PHYSICS_TYPE.STATIC ? _mass : 0; //If a object is static it acts as if it has no mass
            this.#rigidbodyInfo.type = oimoType;
            this.#rigidbodyInfo.position = position;
            this.#rigidbodyInfo.rotation.fromEulerXyz(new OIMO.Vec3(rotation.x, rotation.y, rotation.z)); //Convert eulerAngles in degree to the internally used quaternions
            //Creating the actual rigidbody and it's collider
            this.#rigidbody = new OIMO.RigidBody(this.#rigidbodyInfo);
            this.#collider = new OIMO.Shape(this.#colliderInfo);
            //Filling the additional settings and informations the rigidbody needs. Who is colliding, how is the collision handled (damping, influence factors)
            this.#collider.userData = this;
            this.#collider.setCollisionGroup(_collisionGroup);
            this.#collider.setCollisionMask(this.collisionMask);
            this.#rigidbody.addShape(this.#collider);
            this.#rigidbody.setMassData(this.#massData);
            this.#rigidbody.getShapeList().setRestitution(this.#restitution);
            this.#rigidbody.getShapeList().setFriction(this.#friction);
            this.#rigidbody.getShapeList().setContactCallback(this.#callbacks);
            this.#rigidbody.setLinearDamping(this.#dampingLinear);
            this.#rigidbody.setAngularDamping(this.#dampingAngular);
            this.#rigidbody.setGravityScale(this.#effectGravity);
            this.#rigidbody.setRotationFactor(new OIMO.Vec3(this.#effectRotation.x, this.#effectRotation.y, this.#effectRotation.z));
        }
        /** Creates a collider a shape that represents the object in the physical world.  */
        createCollider(_scale, _colliderType) {
            let shapeConf = new OIMO.ShapeConfig(); //Collider with geometry and infos like friction/restitution and more
            let geometry;
            if (this.typeCollider != _colliderType) //If the collider type was changed set the internal one new, else don't so there is not infinite set calls
                this.typeCollider = _colliderType;
            switch (_colliderType) { //Create a different OimoPhysics geometry based on the given type. That is only the mathematical shape of the collider
                case FudgeCore.COLLIDER_TYPE.CUBE:
                    geometry = new OIMO.BoxGeometry(_scale);
                    break;
                case FudgeCore.COLLIDER_TYPE.SPHERE:
                    geometry = new OIMO.SphereGeometry(_scale.x);
                    break;
                case FudgeCore.COLLIDER_TYPE.CAPSULE:
                    geometry = new OIMO.CapsuleGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.CYLINDER:
                    geometry = new OIMO.CylinderGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.CONE:
                    geometry = new OIMO.ConeGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.PYRAMID:
                    geometry = this.createConvexGeometryCollider(this.createPyramidVertices(), _scale);
                    break;
                case FudgeCore.COLLIDER_TYPE.CONVEX:
                    geometry = this.createConvexGeometryCollider(this.convexMesh, _scale);
                    break;
            }
            shapeConf.geometry = geometry;
            this.#colliderInfo = shapeConf; //the configuration informations that are used to add an actual collider to the rigidbody in createRigidbody
        }
        /** Creating a shape that represents a in itself closed form, out of the given vertices. */
        createConvexGeometryCollider(_vertices, _scale) {
            let verticesAsVec3 = new Array(); //Convert FUDGE Vector3 to OimoVec3
            for (let i = 0; i < _vertices.length; i += 3) { //3 Values for one point
                verticesAsVec3.push(new OIMO.Vec3(_vertices[i] * _scale.x, _vertices[i + 1] * _scale.y, _vertices[i + 2] * _scale.z));
            }
            return new OIMO.ConvexHullGeometry(verticesAsVec3); //Tell OimoPhysics to create a hull that involves all points but close it of. A convex shape can not have a hole in it.
        }
        /** Internal implementation of vertices that construct a pyramid. The vertices of the implemented pyramid mesh can be used too. But they are halfed and double sided, so it's more performant to use this. */
        createPyramidVertices() {
            let vertices = new Float32Array([
                /*0*/ -1, 0, 1, /*1*/ 1, 0, 1, /*2*/ 1, 0, -1, /*3*/ -1, 0, -1,
                /*4*/ 0, 2, 0
            ]);
            return vertices;
        }
        //#region private EVENT functions
        //Calculating the center of a collision as a singular point - in case there is more than one point - by getting the geometrical center of all colliding points
        collisionCenterPoint(_colPoints, _numPoints) {
            let totalPoints = 0;
            let totalX = 0;
            let totalY = 0;
            let totalZ = 0;
            _colPoints.forEach((_value) => {
                if (totalPoints < _numPoints) {
                    totalPoints++;
                    totalX += _value.getPosition2().x;
                    totalY += _value.getPosition2().y;
                    totalZ += _value.getPosition2().z;
                }
            });
            return new FudgeCore.Vector3(totalX / _numPoints, totalY / _numPoints, totalZ / _numPoints);
            ;
        }
        //#endregion
        collisionEnter(_contact) {
            let bodyA = _contact.getShape1()?.userData;
            let bodyB = _contact.getShape2()?.userData;
            if (!bodyA || !bodyB || bodyA.collisions.includes(bodyB)) // already entered
                return;
            bodyA.collisions.push(bodyB);
            bodyB.collisions.push(bodyA);
            // TODO: maybe rather expose the manifold to the event or something
            let manifold = _contact.getManifold();
            let points = manifold.getPoints(); // All points in the collision where the two bodies are touching, used to calculate the full impact
            let normalImpulse = 0;
            let tangentImpulse = 0;
            let binormalImpulse = 0;
            for (let manifoldPoint of points) { // The impact of the collision involving all touching points
                normalImpulse += manifoldPoint.getNormalImpulse();
                tangentImpulse += manifoldPoint.getTangentImpulse();
                binormalImpulse += manifoldPoint.getBinormalImpulse();
            }
            let normal = manifold.getNormal();
            let collisionNormal = new FudgeCore.Vector3(normal.x, normal.y, normal.z);
            let collisionCenterPoint = bodyA.collisionCenterPoint(points, manifold.getNumPoints());
            bodyA.dispatchEvent(new FudgeCore.EventPhysics("ColliderEnteredCollision" /* EVENT_PHYSICS.COLLISION_ENTER */, bodyB, normalImpulse, tangentImpulse, binormalImpulse, collisionCenterPoint, collisionNormal));
            bodyB.dispatchEvent(new FudgeCore.EventPhysics("ColliderEnteredCollision" /* EVENT_PHYSICS.COLLISION_ENTER */, bodyA, normalImpulse, tangentImpulse, binormalImpulse, collisionCenterPoint, collisionNormal));
        }
        collisionExit(_contact) {
            let bodyA = _contact.getShape1()?.userData;
            let bodyB = _contact.getShape2()?.userData;
            if (!bodyA || !bodyB || !bodyA.collisions.includes(bodyB)) // already exited
                return;
            bodyA.collisions.splice(bodyA.collisions.indexOf(bodyB), 1);
            bodyB.collisions.splice(bodyB.collisions.indexOf(bodyA), 1);
            bodyA.dispatchEvent(new FudgeCore.EventPhysics("ColliderLeftCollision" /* EVENT_PHYSICS.COLLISION_EXIT */, bodyB, 0, 0, 0));
            bodyB.dispatchEvent(new FudgeCore.EventPhysics("ColliderLeftCollision" /* EVENT_PHYSICS.COLLISION_EXIT */, bodyA, 0, 0, 0));
        }
        /**
        * Trigger EnteringEvent Callback, automatically called by OIMO Physics within their calculations.
        * Since the event does not know which body is the trigger iniator, the event can be listened to
        * on either the trigger or the triggered. (This is only possible with the FUDGE OIMO Fork!)
        */
        triggerEnter(_contact) {
            let bodyA = _contact.getShape1()?.userData;
            let bodyB = _contact.getShape2()?.userData;
            if (!bodyA || !bodyB || bodyA.triggerings.includes(bodyB)) // already entered
                return;
            bodyA.triggerings.push(bodyB);
            bodyB.triggerings.push(bodyA);
            let manifold = _contact.getManifold();
            let points = manifold.getPoints();
            let normal = manifold.getNormal();
            let collisionNormal = new FudgeCore.Vector3(normal.x, normal.y, normal.z);
            let collisionCenterPoint = bodyA.collisionCenterPoint(points, manifold.getNumPoints());
            bodyA.dispatchEvent(new FudgeCore.EventPhysics("TriggerEnteredCollision" /* EVENT_PHYSICS.TRIGGER_ENTER */, bodyB, 0, 0, 0, collisionCenterPoint, collisionNormal));
            bodyB.dispatchEvent(new FudgeCore.EventPhysics("TriggerEnteredCollision" /* EVENT_PHYSICS.TRIGGER_ENTER */, bodyA, 0, 0, 0, collisionCenterPoint, collisionNormal));
        }
        /**
        * Trigger LeavingEvent Callback, automatically called by OIMO Physics within their calculations.
        * Since the event does not know which body is the trigger iniator, the event can be listened to
        * on either the trigger or the triggered. (This is only possible with the FUDGE OIMO Fork!)
        */
        triggerExit(_contact) {
            let bodyA = _contact.getShape1()?.userData;
            let bodyB = _contact.getShape2()?.userData;
            if (!bodyA || !bodyB || !bodyA.triggerings.includes(bodyB)) // already exited
                return;
            bodyA.triggerings.splice(bodyA.collisions.indexOf(bodyB), 1);
            bodyB.triggerings.splice(bodyB.collisions.indexOf(bodyA), 1);
            bodyA.dispatchEvent(new FudgeCore.EventPhysics("TriggerLeftCollision" /* EVENT_PHYSICS.TRIGGER_EXIT */, bodyB, 0, 0, 0));
            bodyB.dispatchEvent(new FudgeCore.EventPhysics("TriggerLeftCollision" /* EVENT_PHYSICS.TRIGGER_EXIT */, bodyA, 0, 0, 0));
        }
    }
    FudgeCore.ComponentRigidbody = ComponentRigidbody;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Internal class for holding data about physics debug vertices.*/
    class PhysicsDebugVertexBuffer {
        /** Setup the rendering context for this buffer and create the actual buffer for this context. */
        constructor(_renderingContext) {
            this.numVertices = 0;
            this.gl = _renderingContext;
            this.buffer = this.gl.createBuffer();
        }
        /** Fill the bound buffer with data. Used at buffer initialization */
        setData(_array) {
            if (this.attribs == null)
                throw "set attributes first";
            this.numVertices = _array.length / (this.stride / 4);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(_array), this.gl.DYNAMIC_DRAW);
            //not necessary an in webgl2 anymore to rebind the same last buffer (which is achieved by giving a null buffer), after buffer is changed. Removed it on all other occasions
            // this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null); 
        }
        /** Set Shader Attributes informations by getting their position in the shader, setting the offset, stride and size. For later use in the binding process */
        setAttribs(_attribs) {
            this.attribs = _attribs;
            this.offsets = [];
            this.stride = 0;
            let n = _attribs.length;
            for (let i = 0; i < n; i++) {
                this.offsets.push(this.stride);
                this.stride += _attribs[i].float32Count * Float32Array.BYTES_PER_ELEMENT; // 32bit float Bytes are a constant of 4
            }
        }
        /** Get the position of the attribute in the shader */
        loadAttribIndices(_program) {
            this.indices = _program.getAttribIndices(this.attribs);
        }
        /** Enable a attribute in a shader for this context, */
        bindAttribs() {
            if (this.indices == null)
                throw "indices are not loaded";
            let n = this.attribs.length;
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer); //making the buffer of this class the current buffer
            for (let i = 0; i < n; i++) {
                this.gl.enableVertexAttribArray(this.indices[i]); //enable the Attribute
                this.gl.vertexAttribPointer(this.indices[i], this.attribs[i].float32Count, this.gl.FLOAT, false, this.stride, this.offsets[i]); //creates a pointer and structure for this attribute
            }
        }
    }
    FudgeCore.PhysicsDebugVertexBuffer = PhysicsDebugVertexBuffer;
    /** Internal class for holding data about PhysicsDebugVertexBuffers */
    class PhysicsDebugIndexBuffer {
        /** Setup the rendering context for this buffer and create the actual buffer for this context. */
        constructor(_renderingContext) {
            this.gl = _renderingContext;
            this.buffer = this.gl.createBuffer();
        }
        /** Fill the bound buffer with data amount. Used at buffer initialization */
        setData(_array) {
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Int16Array(_array), this.gl.DYNAMIC_DRAW);
            this.count = _array.length;
        }
        /** The actual DrawCall for physicsDebugDraw Buffers. This is where the information from the debug is actually drawn. */
        draw(_mode = this.gl.TRIANGLES, _count = -1) {
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            this.gl.drawElements(_mode, _count >= 0 ? _count : this.count, this.gl.UNSIGNED_SHORT, 0);
        }
    }
    FudgeCore.PhysicsDebugIndexBuffer = PhysicsDebugIndexBuffer;
    /** Internal class for managing data about webGL Attributes */
    class PhysicsDebugVertexAttribute {
        constructor(_float32Count, _name) {
            this.name = _name;
            this.float32Count = _float32Count;
        }
    }
    FudgeCore.PhysicsDebugVertexAttribute = PhysicsDebugVertexAttribute;
    /** Internal class for Shaders used only by the physics debugDraw */
    class PhysicsDebugShader {
        /** Introduce the FUDGE Rendering Context to this class, creating a program and vertex/fragment shader in this context */
        constructor(_renderingContext) {
            this.gl = _renderingContext;
            this.program = this.gl.createProgram();
            this.vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
            this.fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        }
        /** Take glsl shaders as strings and compile them, attaching the compiled shaders to a program thats used by this rendering context. */
        compile(_vertexSource, _fragmentSource) {
            this.uniformLocationMap = new Map();
            this.compileShader(this.vertexShader, _vertexSource);
            this.compileShader(this.fragmentShader, _fragmentSource);
            this.gl.attachShader(this.program, this.vertexShader);
            this.gl.attachShader(this.program, this.fragmentShader);
            this.gl.linkProgram(this.program);
            if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) { //make sure the linking worked, so the program is valid, and shaders are working
                FudgeCore.Debug.log(this.gl.getProgramInfoLog(this.program));
            }
            this.gl.validateProgram(this.program);
            if (!this.gl.getProgramParameter(this.program, this.gl.VALIDATE_STATUS)) {
                console.error("ERROR validating program!", this.gl.getProgramInfoLog(this.program));
                return;
            }
        }
        /** Get index of a attribute in a shader in this program */
        getAttribIndex(_name) {
            return this.gl.getAttribLocation(this.program, _name);
        }
        /** Get the location of a uniform in a shader in this program */
        getUniformLocation(_name) {
            if (this.uniformLocationMap.has(_name))
                return this.uniformLocationMap.get(_name);
            let location = this.gl.getUniformLocation(this.program, _name);
            this.uniformLocationMap.set(_name, location);
            return location;
        }
        /** Get all indices for every attribute in the shaders of this program */
        getAttribIndices(_attribs) {
            let indices = [];
            _attribs.forEach(_value => {
                indices.push(this.getAttribIndex(_value.name));
            });
            return indices;
        }
        /** Tell the FUDGE Rendering Context to use this program to draw. */
        use() {
            this.gl.useProgram(this.program);
        }
        /** Compile a shader out of a string and validate it. */
        compileShader(_shader, _source) {
            this.gl.shaderSource(_shader, _source);
            this.gl.compileShader(_shader);
            if (!this.gl.getShaderParameter(_shader, this.gl.COMPILE_STATUS)) {
                FudgeCore.Debug.log(this.gl.getShaderInfoLog(_shader));
            }
        }
    }
    FudgeCore.PhysicsDebugShader = PhysicsDebugShader;
    /** Internal Class used to draw debugInformations about the physics simulation onto the renderContext. No user interaction needed.
     * @author Marko Fehrenbach, HFU 2020 //Based on OimoPhysics Haxe DebugDrawDemo
     */
    class PhysicsDebugDraw extends FudgeCore.RenderWebGL {
        /** Creating the debug for physics in FUDGE. Tell it to draw only wireframe objects, since FUDGE is handling rendering of the objects besides physics.
         * Override OimoPhysics Functions with own rendering. Initialize buffers and connect them with the context for later use. */
        constructor() {
            super();
            this.style = new OIMO.DebugDrawStyle();
            this.oimoDebugDraw = new OIMO.DebugDraw();
            this.oimoDebugDraw.wireframe = true; //Triangle Rendering is handled by FUDGE so, only the physics lines/points need to be rendered, although triangle is still implemented
            this.gl = FudgeCore.RenderWebGL.crc3;
            this.initializeOverride();
            this.shader = new PhysicsDebugShader(this.gl);
            this.shader.compile(this.vertexShaderSource(), this.fragmentShaderSource());
            this.initializeBuffers();
        }
        /** Receive the current DebugMode from the physics settings and set the OimoPhysics.DebugDraw booleans to show only certain informations.
         * Needed since some debug informations exclude others, and can't be drawn at the same time, by OimoPhysics. And for users it provides more readability
         * to debug only what they need and is commonly debugged.
         */
        setDebugMode(_mode = FudgeCore.PHYSICS_DEBUGMODE.NONE) {
            // tslint:disable-next-line
            let draw = { drawAabbs: false, drawBases: false, drawBvh: false, drawContactBases: false, drawContacts: false, drawJointLimits: false, drawJoints: false, drawPairs: false, drawShapes: false };
            switch (_mode) {
                case FudgeCore.PHYSICS_DEBUGMODE.COLLIDERS: //Colliders and Bases
                    draw.drawBases = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.JOINTS_AND_COLLIDER: //Colliders and joints
                    draw.drawJoints = draw.drawJointLimits = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.PHYSIC_OBJECTS_ONLY: //Physics Objects only, shows same as Collider / Joints but also hiding every other fudge object
                    draw.drawBases = draw.drawJointLimits = draw.drawJoints = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.CONTACTS: //Contacts
                    draw.drawBases = draw.drawContactBases = draw.drawContacts = draw.drawPairs = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.BOUNDING_BOXES: //Bounding Box / Broadphase Bvh / Bases
                    draw.drawAabbs = draw.drawBases = draw.drawBvh = true;
                    break;
            }
            Object.assign(this.oimoDebugDraw, draw);
        }
        /** Creating the empty render buffers. Defining the attributes used in shaders.
         * Needs to create empty buffers to already have them ready to draw later on, linking is only possible with existing buffers. */
        initializeBuffers() {
            let attribs = [
                new PhysicsDebugVertexAttribute(3, "aPosition"),
                new PhysicsDebugVertexAttribute(3, "aNormal"),
                new PhysicsDebugVertexAttribute(3, "aColor")
            ];
            this.pointVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.pointIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.pointVBO.setAttribs(attribs);
            this.pointVBO.loadAttribIndices(this.shader);
            this.lineVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.lineIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.lineVBO.setAttribs(attribs);
            this.lineVBO.loadAttribIndices(this.shader);
            this.triVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.triIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.triVBO.setAttribs(attribs);
            this.triVBO.loadAttribIndices(this.shader);
            this.clearBuffers();
        }
        /** Before OimoPhysics.world is filling the debug. Make sure the buffers are reset. Also receiving the debugMode from settings and updating the current projection for the vertexShader. */
        clearBuffers() {
            this.gl.lineWidth(2.0); //Does not affect anything because lineWidth is currently only supported by Microsoft Edge and FUDGE is optimized for Chrome
            this.pointData = []; //Resetting the data to be filled again
            this.lineData = [];
            this.triData = [];
            this.numPointData = 0; //Resetting the amount of data calls
            this.numLineData = 0;
            this.numTriData = 0;
        }
        /** After OimoPhysics.world filled the debug. Rendering calls. Setting this program to be used by the FUDGE rendering context. And draw each updated buffer and resetting them. */
        drawBuffers() {
            this.shader.use();
            this.gl.uniformMatrix4fv(this.shader.getUniformLocation("u_mtxWorldToView"), false, FudgeCore.Physics.mainCam.mtxWorldToView.get());
            this.gl.bindVertexArray(null);
            if (this.numPointData > 0) {
                this.pointIboData = []; //Buffer size matching to whats needed
                for (let i = 0; i < this.numPointData; i++) {
                    this.pointIboData.push(i);
                }
                this.pointIBO.setData(this.pointIboData); //Set Index buffer to correct size
                this.pointVBO.setData(this.pointData); //Set Vertex Buffer to current Data
                this.pointVBO.bindAttribs();
                this.pointIBO.draw(this.gl.POINTS, this.numPointData); //The actual draw call for each index in ibo
                this.numPointData = 0;
            }
            if (this.numLineData > 0) {
                this.lineIboData = [];
                for (let i = 0; i < this.numLineData; i++) {
                    this.lineIboData.push(i * 2);
                    this.lineIboData.push(i * 2 + 1);
                }
                this.lineIBO.setData(this.lineIboData);
                this.lineVBO.setData(this.lineData);
                this.lineVBO.bindAttribs();
                this.lineIBO.draw(this.gl.LINES, this.numLineData * 2);
                this.numLineData = 0;
            }
            if (this.numTriData > 0) {
                this.triIboData = [];
                for (let i = 0; i < this.numTriData; i++) {
                    this.triIboData.push(i * 3);
                    this.triIboData.push(i * 3 + 1);
                    this.triIboData.push(i * 3 + 2);
                }
                this.triIBO.setData(this.triIboData);
                this.triVBO.setData(this.triData);
                this.triVBO.bindAttribs();
                this.triIBO.draw(this.gl.TRIANGLES, this.numTriData * 3);
                this.numTriData = 0;
            }
        }
        /** Drawing the ray into the debugDraw Call. By using the overwritten line rendering functions and drawing a point (pointSize defined in the shader) at the end of the ray. */
        debugRay(_origin, _end, _color) {
            this.oimoDebugDraw.line(new OIMO.Vec3(_origin.x, _origin.y, _origin.z), new OIMO.Vec3(_end.x, _end.y, _end.z), new OIMO.Vec3(_color.r, _color.g, _color.b));
            this.oimoDebugDraw.point(new OIMO.Vec3(_end.x, _end.y, _end.z), new OIMO.Vec3(_color.r, _color.g, _color.b));
        }
        /** Overriding the existing functions from OimoPhysics.DebugDraw without actually inherit from the class, to avoid compiler problems.
         * Overriding them to receive debugInformations in the format the physic engine provides them but handling the rendering in the fudge context. */
        initializeOverride() {
            //Override point/line/triangle functions of OimoPhysics which are used to draw wireframes of objects, lines of raycasts or triangles when the objects are rendered by the physics not FUDGE (unused)
            OIMO.DebugDraw.prototype.point = function (_v, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw; //Get the custom physics debug class to have access to the data.
                if (FudgeCore.Physics.mainCam != null) { //only act when there is a camera that is rendering
                    let data = debugWrapper.pointData; //get the already written buffer informations
                    data.push(_v.x, _v.y, _v.z); //Coordinates of the point
                    data.push(0, 0, 0); //Point Normals - Empty since it's not a polygon
                    data.push(_color.x, _color.y, _color.z); //Color of the point
                    debugWrapper.numPointData++;
                }
            };
            OIMO.DebugDraw.prototype.line = function (_v1, _v2, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw;
                if (FudgeCore.Physics.mainCam != null) {
                    let data = debugWrapper.lineData;
                    data.push(_v1.x, _v1.y, _v1.z); //Point 1 Coordinates
                    data.push(0, 0, 0); //P1 Normals - Empty since it's not a polygon
                    data.push(_color.x, _color.y, _color.z); //P1 Color
                    data.push(_v2.x, _v2.y, _v2.z); //Point 2 Coordinates
                    data.push(0, 0, 0);
                    data.push(_color.x, _color.y, _color.z);
                    debugWrapper.numLineData++;
                }
            };
            OIMO.DebugDraw.prototype.triangle = function (_v1, _v2, _v3, _n1, _n2, _n3, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw;
                if (FudgeCore.Physics.mainCam != null) {
                    let data = debugWrapper.triData;
                    data.push(_v1.x, _v1.y, _v1.z);
                    data.push(_n1.x, _n1.y, _n1.z);
                    data.push(_color.x, _color.y, _color.z);
                    data.push(_v2.x, _v2.y, _v2.z);
                    data.push(_n2.x, _n2.y, _n2.z);
                    data.push(_color.x, _color.y, _color.z);
                    data.push(_v3.x, _v3.y, _v3.z);
                    data.push(_n3.x, _n3.y, _n3.z);
                    data.push(_color.x, _color.y, _color.z);
                    debugWrapper.numTriData++;
                }
            };
        }
        /** The source code (string) of the in physicsDebug used very simple vertexShader.
         *  Handling the projection (which includes, view/world[is always identity in this case]/projection in FUDGE). Increasing the size of single points drawn.
         *  And transfer position color to the fragmentShader. */
        vertexShaderSource() {
            return `
			precision mediump float;
			attribute vec3 aPosition;
			attribute vec3 aColor;
			attribute vec3 aNormal;
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec3 vColor;
			uniform mat4 u_mtxWorldToView;

			void main() {
				vPosition = aPosition;
				vColor = aColor;
				vNormal = aNormal;
				gl_Position = u_mtxWorldToView * vec4(aPosition,1.0);
				gl_PointSize = 6.0;
			}`;
        }
        /** The source code (string) of the in physicsDebug used super simple fragmentShader. Unlit - only colorizing the drawn pixels, normals/position are given to make it expandable */
        fragmentShaderSource() {
            return `
      precision mediump float;
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec3 vColor;

			void main() {
				gl_FragColor = vec4(vColor, 1.0);
			}`;
        }
    }
    FudgeCore.PhysicsDebugDraw = PhysicsDebugDraw;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A physical connection between two bodies with a defined axe of translation and rotation. Two Degrees of Freedom in the defined axis.
     * Two RigidBodies need to be defined to use it. A motor can be defined for rotation and translation, along with spring settings.
     *
     * ```text
     *          JointHolder - bodyAnchor
     *                    ‚îå‚îÄ‚îÄ‚îÄ‚îê
     *                    ‚îÇ   ‚îÇ
     *           <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> tied body, sliding on axis = 1st degree of freedom
     *                    ‚îÇ   ‚îÇ        rotating around axis = 2nd degree of freedom
     *                    ‚îî‚îÄ‚îÄ‚îÄ‚îò
     * ```
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class JointCylindrical extends FudgeCore.JointAxial {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointCylindrical); }
        #springDampingRotation;
        #springFrequencyRotation;
        #motorForce;
        #maxRotor;
        #minRotor;
        #rotorTorque;
        #rotorSpeed;
        #rotor;
        #rotorSpringDamper;
        /** Creating a cylindrical joint between two ComponentRigidbodies moving on one axis and rotating around another bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.config = new OIMO.CylindricalJointConfig();
            this.#springDampingRotation = 0;
            this.#springFrequencyRotation = 0;
            this.#motorForce = 0;
            this.#maxRotor = 360;
            this.#minRotor = 0;
            this.#rotorTorque = 0;
            this.#rotorSpeed = 0;
            this.#getMutator = () => {
                let mutator = {
                    motorForce: this.motorForce,
                    springDampingRotation: this.springDampingRotation,
                    springFrequencyRotation: this.springFrequencyRotation,
                    maxRotor: this.maxRotor,
                    minRotor: this.minRotor,
                    rotorTorque: this.rotorTorque,
                    rotorSpeed: this.rotorSpeed
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.mutateBase(_mutator, ["motorForce", "rotorTorque", "rotorSpeed", "maxRotor", "minRotor", "springDampingRotation", "springFrequencyRotation", "springFrequency"]);
            };
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        set springDamping(_value) {
            super.springDamping = _value;
            if (this.joint != null)
                this.joint.getTranslationalSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        set springFrequency(_value) {
            super.springFrequency = _value;
            if (this.joint != null)
                this.joint.getTranslationalSpringDamper().frequency = _value;
        }
        /**
        * The damping of the spring. 1 equals completly damped. Influencing TORQUE / ROTATION
        */
        get springDampingRotation() {
            return this.#springDampingRotation;
        }
        set springDampingRotation(_value) {
            this.#springDampingRotation = _value;
            if (this.joint != null)
                this.joint.getRotationalSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. Influencing TORQUE / ROTATION
        */
        get springFrequencyRotation() {
            return this.#springFrequencyRotation;
        }
        set springFrequencyRotation(_value) {
            this.#springFrequencyRotation = _value;
            if (this.joint != null)
                this.joint.getRotationalSpringDamper().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxRotor() {
            return this.#maxRotor;
        }
        set maxRotor(_value) {
            this.#maxRotor = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().upperLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotor() {
            return this.#minRotor;
        }
        set minRotor(_value) {
            this.#minRotor = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().lowerLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeed() {
            return this.#rotorSpeed;
        }
        set rotorSpeed(_value) {
            this.#rotorSpeed = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorque() {
            return this.#rotorTorque;
        }
        set rotorTorque(_value) {
            this.#rotorTorque = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().motorTorque = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        set maxMotor(_value) {
            super.maxMotor = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().upperLimit = _value;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        set minMotor(_value) {
            super.minMotor = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().lowerLimit = _value;
        }
        set motorSpeed(_value) {
            super.motorSpeed = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled.
         */
        get motorForce() {
            return this.#motorForce;
        }
        set motorForce(_value) {
            this.#motorForce = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().motorForce = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            return mutator;
        }
        //#endregion
        constructJoint() {
            this.#rotorSpringDamper = new OIMO.SpringDamper().setSpring(this.springFrequencyRotation, this.springDampingRotation);
            this.motor = new OIMO.TranslationalLimitMotor().setLimits(super.minMotor, super.maxMotor);
            this.motor.setMotor(super.motorSpeed, this.motorForce);
            this.#rotor = new OIMO.RotationalLimitMotor().setLimits(this.minRotor * FudgeCore.Calc.deg2rad, this.maxRotor * FudgeCore.Calc.deg2rad);
            this.#rotor.setMotor(this.rotorSpeed, this.rotorTorque);
            this.config = new OIMO.CylindricalJointConfig();
            super.constructJoint();
            this.config.translationalSpringDamper = this.springDamper;
            this.config.translationalLimitMotor = this.motor;
            this.config.rotationalLimitMotor = this.#rotor;
            this.config.rotationalSpringDamper = this.#rotorSpringDamper;
            this.joint = new OIMO.CylindricalJoint(this.config);
            this.configureJoint();
        }
        #getMutator;
        #mutate;
    }
    FudgeCore.JointCylindrical = JointCylindrical;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with a defined axe movement.
       * Used to create a sliding joint along one axis. Two RigidBodies need to be defined to use it.
       * A motor can be defined to move the connected along the defined axis. Great to construct standard springs or physical sliders.
       *
       * ```text
       *          JointHolder - bodyAnchor
       *                    ‚îå‚îÄ‚îÄ‚îÄ‚îê
       *                    ‚îÇ   ‚îÇ
       *           <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> tied body, sliding on one Axis, 1 Degree of Freedom
       *                    ‚îÇ   ‚îÇ
       *                    ‚îî‚îÄ‚îÄ‚îÄ‚îò
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointPrismatic extends FudgeCore.JointAxial {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointPrismatic); }
        //Internally used variables - Joint Properties that are used even when no actual joint is currently existent
        #motorForce;
        /** Creating a prismatic joint between two ComponentRigidbodies only moving on one axis bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.config = new OIMO.PrismaticJointConfig();
            //Internally used variables - Joint Properties that are used even when no actual joint is currently existent
            this.#motorForce = 0;
            this.maxMotor = 10;
            this.minMotor = -10;
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled. This is the force that the motor is using to hold the position, or reach it if a motorSpeed is defined.
         */
        get motorForce() {
            return this.#motorForce;
        }
        set motorForce(_value) {
            this.#motorForce = _value;
            if (this.joint != null)
                this.joint.getLimitMotor().motorForce = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                motorForce: this.motorForce,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.motorForce = _serialization.motorForce;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.motorForce = this.motorForce;
            return mutator;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (typeof (_mutator.motorForce) !== "undefined")
                this.motorForce = _mutator.motorForce;
            delete _mutator.motorForce;
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        //#endregion
        /** Actual creation of a joint in the OimoPhysics system */
        constructJoint() {
            this.motor = new OIMO.TranslationalLimitMotor().setLimits(this.minMotor, this.maxMotor); //Create motor settings, to hold positions, set constraint min/max
            this.motor.setMotor(this.motorSpeed, this.motorForce);
            this.config = new OIMO.PrismaticJointConfig(); //Create a specific config for this joint type that is calculating the local axis for both bodies
            super.constructJoint();
            this.config.springDamper = this.springDamper; //Telling the config to use the motor/spring of the FUDGE Component
            this.config.limitMotor = this.motor;
            this.joint = new OIMO.PrismaticJoint(this.config);
            this.configureJoint();
        }
    }
    FudgeCore.JointPrismatic = JointPrismatic;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
      * A physical connection between two bodies, designed to simulate behaviour within a real body. It has two axis, a swing and twist axis, and also the perpendicular axis,
      * similar to a Spherical joint, but more restrictive in it's angles and only two degrees of freedom. Two RigidBodies need to be defined to use it. Mostly used to create humanlike joints that behave like a
      * lifeless body.
      * ```text
      *
      *                      anchor - it can twist on one axis and swing on another
      *                            ‚îÇ
      *         z            ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îê
      *         ‚Üë            ‚îÇ   ‚îÇ ‚Üì ‚îÇ   ‚îÇ        e.g. z = TwistAxis, it can rotate in-itself around this axis
      *    -x ‚Üê‚îÄ‚îº‚îÄ‚Üí x        ‚îÇ   ‚îÇ x ‚îÇ   ‚îÇ        e.g. x = SwingAxis, it can rotate anchored around the base on this axis
      *         ‚Üì            ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
      *        -z            ‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îò         e.g. you can twist the leg in-itself to a certain degree,
      *                                                     but also rotate it forward/backward/left/right to a certain degree
      *                bodyAnchor          bodyTied
      *              (e.g. pelvis)         (e.g. upper-leg)
      *
      * ```
      * Twist equals a rotation around a point without moving on an axis.
      * Swing equals a rotation on a point with a moving local axis.
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
      */
    class JointRagdoll extends FudgeCore.Joint {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointRagdoll); }
        #springDampingTwist;
        #springFrequencyTwist;
        #springDampingSwing;
        #springFrequencySwing;
        #maxMotorTwist;
        #minMotorTwist;
        #motorTorqueTwist;
        #motorSpeedTwist;
        #motorTwist;
        #springDamperTwist;
        #springDamperSwing;
        #axisFirst;
        #axisSecond;
        #maxAngleFirst;
        #maxAngleSecond;
        constructor(_bodyAnchor = null, _bodyTied = null, _axisFirst = new FudgeCore.Vector3(1, 0, 0), _axisSecond = new FudgeCore.Vector3(0, 0, 1), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.config = new OIMO.RagdollJointConfig();
            this.#springDampingTwist = 0;
            this.#springFrequencyTwist = 0;
            this.#springDampingSwing = 0;
            this.#springFrequencySwing = 0;
            this.#maxMotorTwist = 360;
            this.#minMotorTwist = 0;
            this.#motorTorqueTwist = 0;
            this.#motorSpeedTwist = 0;
            this.#maxAngleFirst = 0;
            this.#maxAngleSecond = 0;
            this.#getMutator = () => {
                let mutator = {
                    maxAngleFirst: this.#maxAngleFirst,
                    maxAngleSecond: this.#maxAngleSecond,
                    springDampingTwist: this.springDampingTwist,
                    springFrequencyTwist: this.springFrequencyTwist,
                    springDampingSwing: this.springDampingSwing,
                    springFrequencySwing: this.springFrequencySwing,
                    maxMotorTwist: this.#maxMotorTwist,
                    minMotorTwist: this.#minMotorTwist,
                    motorSpeedTwist: this.motorSpeedTwist,
                    motorTorqueTwist: this.motorTorqueTwist
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                if (typeof (_mutator.maxAngleFirst) !== "undefined")
                    this.#maxAngleFirst = _mutator.maxAngleFirst;
                if (typeof (_mutator.maxAngleSecond) !== "undefined")
                    this.#maxAngleSecond = _mutator.maxAngleSecond;
                this.mutateBase(_mutator, [
                    "springDampingTwist", "springFrequencyTwist", "springDampingSwing", "springFrequencySwing", "maxMotorTwist", "minMotorTwist", "motorSpeedTwist", "motorTorqueTwist"
                ]);
            };
            this.axisFirst = _axisFirst;
            this.axisSecond = _axisSecond;
            this.anchor = _localAnchor;
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axisFirst() {
            return new FudgeCore.Vector3(this.#axisFirst.x, this.#axisFirst.y, this.#axisFirst.z);
        }
        set axisFirst(_value) {
            this.#axisFirst = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
        * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
        *  When changed after initialization the joint needs to be reconnected.
        */
        get axisSecond() {
            return new FudgeCore.Vector3(this.#axisSecond.x, this.#axisSecond.y, this.#axisSecond.z);
        }
        set axisSecond(_value) {
            this.#axisSecond = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The maximum angle of rotation along the first axis. Value needs to be positive. Changes do rebuild the joint
         */
        get maxAngleFirstAxis() {
            return this.#maxAngleFirst * FudgeCore.Calc.rad2deg;
        }
        set maxAngleFirstAxis(_value) {
            this.#maxAngleFirst = _value * FudgeCore.Calc.deg2rad;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The maximum angle of rotation along the second axis. Value needs to be positive. Changes do rebuild the joint
         */
        get maxAngleSecondAxis() {
            return this.#maxAngleSecond * FudgeCore.Calc.rad2deg;
        }
        set maxAngleSecondAxis(_value) {
            this.#maxAngleSecond = _value * FudgeCore.Calc.deg2rad;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingTwist() {
            return this.#springDampingTwist;
        }
        set springDampingTwist(_value) {
            this.#springDampingTwist = _value;
            if (this.joint != null)
                this.joint.getTwistSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencyTwist() {
            return this.#springFrequencyTwist;
        }
        set springFrequencyTwist(_value) {
            this.#springFrequencyTwist = _value;
            if (this.joint != null)
                this.joint.getTwistSpringDamper().frequency = _value;
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingSwing() {
            return this.#springDampingSwing;
        }
        set springDampingSwing(_value) {
            this.#springDampingSwing = _value;
            if (this.joint != null)
                this.joint.getSwingSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencySwing() {
            return this.#springFrequencySwing;
        }
        set springFrequencySwing(_value) {
            this.#springFrequencySwing = _value;
            if (this.joint != null)
                this.joint.getSwingSpringDamper().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxMotorTwist() {
            return this.#maxMotorTwist * FudgeCore.Calc.rad2deg;
        }
        set maxMotorTwist(_value) {
            _value *= FudgeCore.Calc.deg2rad;
            this.#maxMotorTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().upperLimit = _value;
        }
        /**
         * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minMotorTwist() {
            return this.#minMotorTwist * FudgeCore.Calc.rad2deg;
        }
        set minMotorTwist(_value) {
            _value *= FudgeCore.Calc.deg2rad;
            this.#minMotorTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().lowerLimit = _value;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get motorSpeedTwist() {
            return this.#motorSpeedTwist;
        }
        set motorSpeedTwist(_value) {
            this.#motorSpeedTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get motorTorqueTwist() {
            return this.#motorTorqueTwist;
        }
        set motorTorqueTwist(_value) {
            this.#motorTorqueTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.axisFirst = this.axisFirst.serialize();
            serialization.axisSecond = this.axisSecond.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await this.axisFirst.deserialize(_serialization.axisFirst);
            await this.axisSecond.deserialize(_serialization.axisSecond);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (typeof (_mutator.axisFirst) !== "undefined")
                this.axisFirst = new FudgeCore.Vector3(...(Object.values(_mutator.axisFirst)));
            if (typeof (_mutator.axisSecond) !== "undefined")
                this.axisSecond = new FudgeCore.Vector3(...(Object.values(_mutator.axisSecond)));
            delete _mutator.axisFirst;
            delete _mutator.axisSecond;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            mutator.axisFirst = this.axisFirst.getMutator();
            mutator.axisSecond = this.axisSecond.getMutator();
            return mutator;
        }
        //#endregion
        constructJoint() {
            this.#springDamperTwist = new OIMO.SpringDamper().setSpring(this.springFrequencyTwist, this.springDampingTwist);
            this.#springDamperSwing = new OIMO.SpringDamper().setSpring(this.springFrequencySwing, this.springDampingSwing);
            this.#motorTwist = new OIMO.RotationalLimitMotor().setLimits(this.minMotorTwist, this.maxMotorTwist);
            this.#motorTwist.setMotor(this.motorSpeedTwist, this.motorTorqueTwist);
            this.config = new OIMO.RagdollJointConfig();
            super.constructJoint(this.axisFirst, this.axisSecond);
            this.config.swingSpringDamper = this.#springDamperSwing;
            this.config.twistSpringDamper = this.#springDamperTwist;
            this.config.twistLimitMotor = this.#motorTwist;
            this.config.maxSwingAngle1 = this.#maxAngleFirst;
            this.config.maxSwingAngle2 = this.#maxAngleSecond;
            this.joint = new OIMO.RagdollJoint(this.config);
            super.configureJoint();
        }
        #getMutator;
        #mutate;
    }
    FudgeCore.JointRagdoll = JointRagdoll;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with a defined axe of rotation. Also known as HINGE joint.
       * Two RigidBodies need to be defined to use it. A motor can be defined to rotate the connected along the defined axis.
       *
       * ```text
       *                  rotation axis, 1st Degree of freedom
       *                    ‚Üë
       *               ‚îå‚îÄ‚îÄ‚îÄ‚îê‚îÇ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       *                    ‚îÇ
       *      bodyAnchor         bodyTied
       *   (e.g. Doorhinge)       (e.g. Door)
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointRevolute extends FudgeCore.JointAxial {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointRevolute); }
        #motorTorque;
        #rotor;
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.config = new OIMO.RevoluteJointConfig();
            this.#motorTorque = 0;
            this.maxMotor = 360;
            this.minMotor = 0;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        set maxMotor(_value) {
            super.maxMotor = _value;
            _value *= FudgeCore.Calc.deg2rad;
            if (this.joint)
                this.joint.getLimitMotor().upperLimit = _value;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        set minMotor(_value) {
            super.minMotor = _value;
            if (this.joint)
                this.joint.getLimitMotor().lowerLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled.
         */
        get motorTorque() {
            return this.#motorTorque;
        }
        set motorTorque(_value) {
            this.#motorTorque = _value;
            if (this.joint != null)
                this.joint.getLimitMotor().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                motorTorque: this.motorTorque,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.motorTorque = _serialization.motorTorque;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.motorTorque = this.motorTorque;
            return mutator;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (typeof (_mutator.motorTorque) !== "undefined")
                this.motorTorque = _mutator.motorTorque;
            delete _mutator.motorTorque;
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        //#endregion
        constructJoint() {
            this.#rotor = new OIMO.RotationalLimitMotor().setLimits(super.minMotor * FudgeCore.Calc.deg2rad, super.maxMotor * FudgeCore.Calc.deg2rad);
            this.#rotor.setMotor(this.motorSpeed, this.motorTorque);
            this.config = new OIMO.RevoluteJointConfig();
            super.constructJoint();
            this.config.springDamper = this.springDamper;
            this.config.limitMotor = this.#rotor;
            this.joint = new OIMO.RevoluteJoint(this.config);
            this.configureJoint();
        }
    }
    FudgeCore.JointRevolute = JointRevolute;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with three Degrees of Freedom, also known as ball and socket joint. Two bodies connected at their anchor but free to rotate.
       * Used for things like the connection of bones in the human shoulder (if simplified, else better use JointRagdoll). Two RigidBodies need to be defined to use it. Only spring settings can be defined.
       * 3 Degrees are swing horizontal, swing vertical and twist.
       *
       * ```text
       *              JointHolder
       *         z      bodyAnchor (e.g. Human-Shoulder)
       *      y  ‚Üë
       *        \|          ‚îÄ‚îÄ‚îÄ(‚óè‚îÄ‚îÄ‚îÄ
       *  -x <---|---> x           bodyTied
       *         |\                (e.g. Upper-Arm)
       *         ‚Üì -y
       *        -z
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointSpherical extends FudgeCore.Joint {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointSpherical); }
        #springDamping;
        #springFrequency;
        #springDamper;
        constructor(_bodyAnchor = null, _bodyTied = null, _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.config = new OIMO.SphericalJointConfig();
            this.#springDamping = 0;
            this.#springFrequency = 0;
            this.anchor = new FudgeCore.Vector3(_localAnchor.x, _localAnchor.y, _localAnchor.z);
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDamping() {
            return this.#springDamping;
        }
        set springDamping(_value) {
            this.#springDamping = _value;
            if (this.joint != null)
                this.joint.getSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequency() {
            return this.#springFrequency;
        }
        set springFrequency(_value) {
            this.#springFrequency = _value;
            if (this.joint != null)
                this.joint.getSpringDamper().frequency = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                springDamping: this.springDamping,
                springFrequency: this.springFrequency,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.springDamping = _serialization.springDamping;
            this.springFrequency = _serialization.springFrequency;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.springDamping = this.springDamping;
            mutator.springFrequency = this.springFrequency;
            return mutator;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            this.mutateBase(_mutator, ["springDamping", "springFrequency"]);
            delete _mutator.springDamping;
            delete _mutator.springFrequency;
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        //#endregion
        constructJoint() {
            this.#springDamper = new OIMO.SpringDamper().setSpring(this.springFrequency, this.springDamping);
            this.config = new OIMO.SphericalJointConfig();
            super.constructJoint();
            this.config.springDamper = this.#springDamper;
            this.joint = new OIMO.SphericalJoint(this.config);
            super.configureJoint();
        }
    }
    FudgeCore.JointSpherical = JointSpherical;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with two defined axis (normally e.g. (0,0,1) and rotation(1,0,0)), they share the same anchor and have free rotation, but transfer the twist.
       * In reality used in cars to transfer the more stable stationary force on the velocity axis to the bumping, damped moving wheel. Two RigidBodies need to be defined to use it.
       * The two motors can be defined for the two rotation axis, along with springs.
       * ```text
       *
       *                      anchor - twist is transfered between bodies
       *         z                   |
       *         ‚Üë            -----  |  ------------
       *         |           |     | ‚Üì |            |
       *  -x <---|---> x     |     | x |            |           e.g. wheel can still turn up/down,
       *         |           |     |   |            |           left right but transfering it's rotation on to the wheel-axis.
       *         ‚Üì            -----     ------------
       *        -z
       *                 attachedRB          connectedRB
       *                (e.g. wheel)       (e.g. wheel-axis)
       * ```
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointUniversal extends FudgeCore.Joint {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointUniversal); }
        #springDampingFirst;
        #springFrequencyFirst;
        #springDampingSecond;
        #springFrequencySecond;
        #maxRotorFirst;
        #minRotorFirst;
        #rotorTorqueFirst;
        #rotorSpeedFirst;
        #maxRotorSecond;
        #minRotorSecond;
        #rotorTorqueSecond;
        #rotorSpeedSecond;
        #motorFirst;
        #motorSecond;
        #axisSpringDamperFirst;
        #axisSpringDamperSecond;
        #axisFirst;
        #axisSecond;
        constructor(_bodyAnchor = null, _bodyTied = null, _axisFirst = new FudgeCore.Vector3(1, 0, 0), _axisSecond = new FudgeCore.Vector3(0, 0, 1), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.config = new OIMO.UniversalJointConfig();
            this.#springDampingFirst = 0;
            this.#springFrequencyFirst = 0;
            this.#springDampingSecond = 0;
            this.#springFrequencySecond = 0;
            this.#maxRotorFirst = 360;
            this.#minRotorFirst = 0;
            this.#rotorTorqueFirst = 0;
            this.#rotorSpeedFirst = 0;
            this.#maxRotorSecond = 360;
            this.#minRotorSecond = 0;
            this.#rotorTorqueSecond = 0;
            this.#rotorSpeedSecond = 0;
            this.#getMutator = () => {
                let mutator = {
                    springDampingFirst: this.#springDampingFirst,
                    springFrequencyFirst: this.#springFrequencyFirst,
                    springDampingSecond: this.#springDampingSecond,
                    springFrequencySecond: this.#springFrequencySecond,
                    maxRotorFirst: this.#maxRotorFirst,
                    minRotorFirst: this.#minRotorFirst,
                    rotorSpeedFirst: this.#rotorSpeedFirst,
                    rotorTorqueFirst: this.#rotorTorqueFirst,
                    maxRotorSecond: this.#maxRotorSecond,
                    minRotorSecond: this.#minRotorSecond,
                    rotorSpeedSecond: this.#rotorSpeedSecond,
                    rotorTorqueSecond: this.#rotorTorqueSecond
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.mutateBase(_mutator, [
                    "springDampingFirst", "springFrequencyFirst", "springDampingSecond", "springFrequencySecond",
                    "maxRotorFirst", "minRotorFirst", "rotorSpeedFirst", "rotorTorqueFirst",
                    "maxRotorSecond", "minRotorSecond", "rotorSpeedSecond", ".rotorTorqueSecond"
                ]);
            };
            this.axisFirst = _axisFirst;
            this.axisSecond = _axisSecond;
            this.anchor = _localAnchor;
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axisFirst() {
            return new FudgeCore.Vector3(this.#axisFirst.x, this.#axisFirst.y, this.#axisFirst.z);
        }
        set axisFirst(_value) {
            this.#axisFirst = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
        * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
        *  When changed after initialization the joint needs to be reconnected.
        */
        get axisSecond() {
            return new FudgeCore.Vector3(this.#axisSecond.x, this.#axisSecond.y, this.#axisSecond.z);
        }
        set axisSecond(_value) {
            this.#axisSecond = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingFirst() {
            return this.#springDampingFirst;
        }
        set springDampingFirst(_value) {
            this.#springDampingFirst = _value;
            if (this.joint != null)
                this.joint.getSpringDamper1().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencyFirst() {
            return this.#springFrequencyFirst;
        }
        set springFrequencyFirst(_value) {
            this.#springFrequencyFirst = _value;
            if (this.joint != null)
                this.joint.getSpringDamper1().frequency = _value;
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingSecond() {
            return this.#springDampingSecond;
        }
        set springDampingSecond(_value) {
            this.#springDampingSecond = _value;
            if (this.joint != null)
                this.joint.getSpringDamper2().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencySecond() {
            return this.#springFrequencySecond;
        }
        set springFrequencySecond(_value) {
            this.#springFrequencySecond = _value;
            if (this.joint != null)
                this.joint.getSpringDamper2().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxRotorFirst() {
            return this.#maxRotorFirst;
        }
        set maxRotorFirst(_value) {
            this.#maxRotorFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().upperLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotorFirst() {
            return this.#minRotorFirst;
        }
        set minRotorFirst(_value) {
            this.#minRotorFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().lowerLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeedFirst() {
            return this.#rotorSpeedFirst;
        }
        set rotorSpeedFirst(_value) {
            this.#rotorSpeedFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().motorSpeed = _value;
        }
        /**
         * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorqueFirst() {
            return this.#rotorTorqueFirst;
        }
        set rotorTorqueFirst(_value) {
            this.#rotorTorqueFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().motorTorque = _value;
        }
        /**
         * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxRotorSecond() {
            return this.#maxRotorSecond;
        }
        set maxRotorSecond(_value) {
            this.#maxRotorSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().upperLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotorSecond() {
            return this.#minRotorSecond;
        }
        set minRotorSecond(_value) {
            this.#minRotorSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().lowerLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeedSecond() {
            return this.#rotorSpeedSecond;
        }
        set rotorSpeedSecond(_value) {
            this.#rotorSpeedSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorqueSecond() {
            return this.#rotorTorqueSecond;
        }
        set rotorTorqueSecond(_value) {
            this.#rotorTorqueSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.firstAxis = this.axisFirst.serialize();
            serialization.secondAxis = this.axisSecond.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.axisFirst = await new FudgeCore.Vector3().deserialize(_serialization.axisFirst);
            this.axisSecond = await new FudgeCore.Vector3().deserialize(_serialization.axisSecond);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (typeof (_mutator.axisFirst) !== "undefined")
                this.axisFirst = new FudgeCore.Vector3(...(Object.values(_mutator.axisFirst)));
            if (typeof (_mutator.axisSecond) !== "undefined")
                this.axisSecond = new FudgeCore.Vector3(...(Object.values(_mutator.axisSecond)));
            delete _mutator.axisFirst;
            delete _mutator.axisSecond;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            mutator.axisFirst = this.axisFirst.getMutator();
            mutator.axisSecond = this.axisSecond.getMutator();
            return mutator;
        }
        //#endregion
        constructJoint() {
            this.#axisSpringDamperFirst = new OIMO.SpringDamper().setSpring(this.#springFrequencyFirst, this.#springDampingFirst);
            this.#axisSpringDamperSecond = new OIMO.SpringDamper().setSpring(this.#springFrequencySecond, this.#springDampingSecond);
            this.#motorFirst = new OIMO.RotationalLimitMotor().setLimits(this.#minRotorFirst * FudgeCore.Calc.deg2rad, this.#maxRotorFirst * FudgeCore.Calc.deg2rad);
            this.#motorFirst.setMotor(this.#rotorSpeedFirst, this.#rotorTorqueFirst);
            this.#motorSecond = new OIMO.RotationalLimitMotor().setLimits(this.#minRotorFirst * FudgeCore.Calc.deg2rad, this.#maxRotorFirst * FudgeCore.Calc.deg2rad);
            this.#motorSecond.setMotor(this.#rotorSpeedFirst, this.#rotorTorqueFirst);
            this.config = new OIMO.UniversalJointConfig();
            super.constructJoint(this.#axisFirst, this.#axisSecond);
            this.config.limitMotor1 = this.#motorFirst;
            this.config.limitMotor2 = this.#motorSecond;
            this.config.springDamper1 = this.#axisSpringDamperFirst;
            this.config.springDamper2 = this.#axisSpringDamperSecond;
            this.joint = new OIMO.UniversalJoint(this.config);
            super.configureJoint();
        }
        #getMutator;
        #mutate;
    }
    FudgeCore.JointUniversal = JointUniversal;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with no movement.
       * Best way to simulate convex objects like a chair seat connected to chair legs.
       * The actual anchor point does not matter that much, only in very specific edge cases.
       * Because welding means they simply do not disconnect. (unless you add Breakability)
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointWelding extends FudgeCore.Joint {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointWelding); }
        constructor(_bodyAnchor = null, _bodyTied = null, _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.config = new OIMO.GenericJointConfig();
            this.anchor = new FudgeCore.Vector3(_localAnchor.x, _localAnchor.y, _localAnchor.z);
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        //#endregion
        constructJoint() {
            this.config = new OIMO.GenericJointConfig();
            super.constructJoint(new OIMO.Mat3(), new OIMO.Mat3());
            this.joint = new OIMO.GenericJoint(this.config);
            this.joint.setAllowCollision(this.internalCollision);
        }
    }
    FudgeCore.JointWelding = JointWelding;
})(FudgeCore || (FudgeCore = {}));
/// <reference path="../../../Distribution/OimoPhysics.d.ts"/>
var FudgeCore;
/// <reference path="../../../Distribution/OimoPhysics.d.ts"/>
(function (FudgeCore) {
    /**
      * Manages the OIMO physics engine for FUDGE. Multiple instances may be created, one is active at a time.
      * All methods are static and use the currently active instance. At startup, a default instance is created and become the active instance
      * Attaching a {@link ComponentRigidbody} to a {@link Node} places a physics collider in the physics instance active at that time.
      * @author Marko Fehrenbach, HFU 2020
      */
    class Physics {
        /** The SETTINGS that apply to the physical world. Ranging from things like sleeping, collisionShapeThickness and others */
        static { this.settings = new FudgeCore.PhysicsSettings(FudgeCore.COLLISION_GROUP.DEFAULT, (FudgeCore.COLLISION_GROUP.DEFAULT | FudgeCore.COLLISION_GROUP.GROUP_1 | FudgeCore.COLLISION_GROUP.GROUP_2 | FudgeCore.COLLISION_GROUP.GROUP_3 | FudgeCore.COLLISION_GROUP.GROUP_4)); }
        static { this.∆íactive = new Physics(); }
        /** The rendering of physical debug informations. Used internally no interaction needed.*/
        #debugDraw;
        /** The camera/viewport the physics are debugged to. Used internally no interaction needed. */
        #mainCam;
        constructor() {
            this.bodyList = new Array();
            this.jointList = new Array();
            if (typeof OIMO == "undefined") { // Check if OIMO Namespace was loaded, else do not use any physics. Check is needed to ensure FUDGE can be used without Physics
                FudgeCore.Debug.error("OIMO physics engine not connected!");
                return null;
            }
            this.oimoWorld = new OIMO.World();
            this.#debugDraw = new FudgeCore.PhysicsDebugDraw(); //Create a FUDGE Physics debugging handling object
            this.oimoWorld.setDebugDraw(this.#debugDraw.oimoDebugDraw); //Tell OimoPhysics where to debug to and how it will be handled
        }
        /**
         * Define the currently active Physics instance
         */
        static set activeInstance(_physics) {
            Physics.∆íactive = _physics;
        }
        /** Get the currently active Physics instance */
        static get activeInstance() {
            return Physics.∆íactive;
        }
        static get debugDraw() {
            return Physics.∆íactive.#debugDraw;
        }
        static get mainCam() {
            return Physics.∆íactive.#mainCam;
        }
        /**
        * Cast a RAY into the physical world from a origin point in a certain direction. Receiving informations about the hit object and the
        * hit point. Do not specify a _group to raycast the whole world, else only bodies within the specific group can be hit.
        */
        static raycast(_origin, _direction, _length = 1, _debugDraw = false, _group = FudgeCore.COLLISION_GROUP.DEFAULT) {
            let hitInfo = new FudgeCore.RayHitInfo();
            let ray = new OIMO.RayCastClosest();
            let begin = new OIMO.Vec3(_origin.x, _origin.y, _origin.z);
            let end = this.getRayEndPoint(begin, new FudgeCore.Vector3(_direction.x, _direction.y, _direction.z), _length);
            ray.clear();
            if (_group == FudgeCore.COLLISION_GROUP.DEFAULT) { //Case 1: Raycasting the whole world, normal mode
                Physics.∆íactive.oimoWorld.rayCast(begin, end, ray);
            }
            else { //Case2: Raycasting on each body in a specific group
                let allHits = new Array();
                Physics.∆íactive.bodyList.forEach(function (_value) {
                    if (_value.collisionGroup == _group) {
                        hitInfo = _value.raycastThisBody(_origin, _direction, _length);
                        if (hitInfo.hit == true) { //Every hit is could potentially be the closest
                            allHits.push(hitInfo);
                        }
                    }
                });
                allHits.forEach(function (_value) {
                    if (_value.hitDistance < hitInfo.hitDistance || hitInfo.hit == false) {
                        hitInfo = _value;
                    }
                });
            }
            if (ray.hit) { //Fill in informations on the hit
                hitInfo.hit = true;
                hitInfo.hitPoint = new FudgeCore.Vector3(ray.position.x, ray.position.y, ray.position.z);
                hitInfo.hitNormal = new FudgeCore.Vector3(ray.normal.x, ray.normal.y, ray.normal.z);
                hitInfo.hitDistance = this.getRayDistance(_origin, hitInfo.hitPoint);
                hitInfo.rigidbodyComponent = ray.shape.userData;
                hitInfo.rayEnd = new FudgeCore.Vector3(end.x, end.y, end.z);
                hitInfo.rayOrigin = _origin;
            }
            else {
                hitInfo.rayOrigin = _origin;
                hitInfo.hitPoint = new FudgeCore.Vector3(end.x, end.y, end.z);
            }
            if (_debugDraw) { //Handle debugging
                Physics.∆íactive.#debugDraw.debugRay(hitInfo.rayOrigin, hitInfo.hitPoint, new FudgeCore.Color(0, 1, 0, 1));
            }
            return hitInfo;
        }
        /**
        * Simulates the physical world. _deltaTime is the amount of time between physical steps in seconds. Default is {@link Loop.timeFrameGame} / 1000 to run in sync with the {@link Loop}.
        * The maximum value is 1/30 of a second, to have more consistent frame calculations.
        */
        static simulate(_deltaTime = FudgeCore.Loop.timeFrameGame / 1000) {
            if (Physics.∆íactive.jointList.length > 0)
                Physics.connectJoints(); // Connect joints if anything has happened between the last call to any of the two paired rigidbodies
            if (_deltaTime == 0) // No time passed, no need to update the physics world
                return;
            _deltaTime = _deltaTime > 1 / 30 ? 1 / 30 : _deltaTime; // If instead of a fixed rate the game framerate is used, make sure irregular timings are fixed to 30fps
            Physics.∆íactive.oimoWorld.step(_deltaTime); // Update the simulation by the given deltaTime
        }
        /**
         * Draw information about the currently active instance using the {@link ComponentCamera} given
         */
        static draw(_cmpCamera, _mode) {
            Physics.∆íactive.#debugDraw.setDebugMode(_mode);
            Physics.∆íactive.#mainCam = _cmpCamera;
            Physics.∆íactive.oimoWorld.debugDraw(); //Filling the physics world debug informations into the debug rendering handler
            Physics.∆íactive.#debugDraw.drawBuffers();
            Physics.∆íactive.#debugDraw.clearBuffers(); //Updates info about the current projection, resetting the points/lines/triangles that need to be drawn from debug
        }
        /**
          * Adjusts the transforms of the {@link ComponentRigidbody}s in the given branch to match their nodes or meshes
          */
        static adjustTransforms(_branch, _toMesh = false) {
            FudgeCore.Render.prepare(_branch, { ignorePhysics: true });
            for (let node of FudgeCore.Render.nodesPhysics)
                node.getComponent(FudgeCore.ComponentRigidbody).initialize();
        }
        /**
        * Get the applied gravitational force of the active instance. Default earth gravity = 9.81 m/s
        */
        static getGravity() {
            let tmpVec = Physics.∆íactive.oimoWorld.getGravity();
            return new FudgeCore.Vector3(tmpVec.x, tmpVec.y, tmpVec.z);
        }
        /**
        * Set the applied gravitational force of the active instance. Default earth gravity = 9.81 m/s
        */
        static setGravity(_value) {
            let tmpVec = new OIMO.Vec3(_value.x, _value.y, _value.z);
            Physics.∆íactive.oimoWorld.setGravity(tmpVec);
        }
        /**
        * Add a new OIMO Rigidbody to the active instance, happens automatically when adding a FUDGE Rigidbody Component.
        */
        static addRigidbody(_cmpRB) {
            Physics.∆íactive.bodyList.push(_cmpRB);
            Physics.∆íactive.oimoWorld.addRigidBody(_cmpRB.getOimoRigidbody());
        }
        /**
        * Remove the OIMO Rigidbody to the active instance, happens automatically when removing a FUDGE Rigidbody Component
        */
        static removeRigidbody(_cmpRB) {
            // TODO: two lists are being managed, info might deviate. Cleanup!
            let oimoRigidBody = _cmpRB.getOimoRigidbody();
            if (oimoRigidBody._world)
                oimoRigidBody._world.removeRigidBody(oimoRigidBody);
            // what if the rigidbodys oimo-world does not belong to the active instance?
            let id = Physics.∆íactive.bodyList.indexOf(_cmpRB);
            if (id > -1)
                Physics.∆íactive.bodyList.splice(id, 1);
        }
        /**
        * Add a new OIMO Joint/Constraint to the active instance, happens automatically when adding a FUDGE Joint Component
        */
        static addJoint(_cmpJoint) {
            Physics.∆íactive.oimoWorld.addJoint(_cmpJoint.getOimoJoint());
        }
        /**
        * Called internally to inform the physics system that a joint has a change of core properties and needs to be recreated.
        */
        static changeJointStatus(_cmpJoint) {
            if (Physics.∆íactive.jointList.indexOf(_cmpJoint) < 0)
                Physics.∆íactive.jointList.push(_cmpJoint);
        }
        /**
          * Remove the OIMO Joint/Constraint to the active instance, happens automatically when removing a FUDGE Joint Component
          */
        static removeJoint(_cmpJoint) {
            try {
                Physics.∆íactive.oimoWorld.removeJoint(_cmpJoint.getOimoJoint());
            }
            catch (_error) {
                FudgeCore.Debug.fudge(_error);
            }
        }
        /** Returns all the ComponentRigidbodies that are known to the active instance. */
        static getBodyList() {
            return Physics.∆íactive.bodyList;
        }
        /** Giving a ComponentRigidbody a specific identification number so it can be referenced in the loading process. And removed rb's can receive a new id. */
        static distributeBodyID() {
            let freeId = 0;
            let free = false;
            Physics.∆íactive.bodyList.forEach((_value) => {
                if (_value.id != freeId) {
                    free = true;
                }
                else {
                    free = false;
                }
                if (!free) {
                    freeId++;
                }
            });
            return freeId;
        }
        /**
         * Connect all joints that are not connected yet. Used internally no user interaction needed. This functionality is called and needed to make sure joints connect/disconnect
         * if any of the two paired ComponentRigidbodies change.
         */
        static connectJoints() {
            let jointsToConnect = Physics.∆íactive.jointList;
            Physics.∆íactive.jointList = [];
            jointsToConnect.forEach((_joint) => {
                if (_joint.isConnected() == false)
                    if (_joint.isActive)
                        _joint.connect();
                    else
                        Physics.∆íactive.jointList.push(_joint);
            });
        }
        /** Remove all oimo joints and rigidbodies, so that they can be reused in another world  */
        static cleanup() {
            let oimoWorld = Physics.∆íactive.oimoWorld;
            if (oimoWorld != null) {
                //Resetting the world so a new world can be created, fix for re-opening a project in editor, making sure there are no old things calculated
                let jointsWorld = oimoWorld.getNumJoints();
                let bodiesWorld = oimoWorld.getNumRigidBodies();
                for (let body of Physics.∆íactive.bodyList)
                    body.isInitialized = false;
                Physics.∆íactive.jointList = new Array(); // TODO: see if it would be smarter, do use these arrays. Definitely more intuitive...
                for (let i = 0; i < jointsWorld; i++) {
                    let oimoJoint = Physics.∆íactive.oimoWorld.getJointList();
                    oimoWorld.removeJoint(oimoJoint);
                }
                for (let i = 0; i < bodiesWorld; i++) {
                    let oimoBody = oimoWorld.getRigidBodyList();
                    oimoWorld.removeRigidBody(oimoBody);
                }
            }
        }
        // /** Returns the ComponentRigidbody with the given id. Used internally to reconnect joints on loading in the editor. */
        // private static getBodyByID(_id: number): ComponentRigidbody {
        //   let body: ComponentRigidbody = null;
        //   Physics.#activePhysics.bodyList.forEach((value: ComponentRigidbody): void => {
        //     if (value.id == _id) {
        //       body = value;
        //     }
        //   });
        //   return body;
        // }
        /** Internal function to calculate the endpoint of mathematical ray. By adding the multiplied direction to the origin.
           * Used because OimoPhysics defines ray by start/end. But GameEngines commonly use origin/direction.
           */
        static getRayEndPoint(_start, _direction, _length) {
            let origin = FudgeCore.Recycler.get(FudgeCore.Vector3);
            origin.set(_start.x, _start.y, _start.z);
            let scaledDirection = _direction.clone;
            scaledDirection.scale(_length);
            let endpoint = FudgeCore.Vector3.SUM(scaledDirection, origin);
            FudgeCore.Recycler.store(scaledDirection);
            FudgeCore.Recycler.store(endpoint);
            FudgeCore.Recycler.store(origin);
            return new OIMO.Vec3(endpoint.x, endpoint.y, endpoint.z);
        }
        /** Internal function to get the distance in which a ray hit by subtracting points from each other and get the square root of the squared product of each component. */
        static getRayDistance(_origin, _hitPoint) {
            let dx = _origin.x - _hitPoint.x;
            let dy = _origin.y - _hitPoint.y;
            let dz = _origin.z - _hitPoint.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
        /** Returns the actual used world of the OIMO physics engine. No user interaction needed - Only for advanced users that need to access it directly */
        getOimoWorld() {
            return Physics.∆íactive.oimoWorld;
        }
    }
    FudgeCore.Physics = Physics;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines a threedimensional box by two corner-points, one with minimal values and one with maximum values
     */
    class Box {
        constructor(_min = FudgeCore.Vector3.ONE(Infinity), _max = FudgeCore.Vector3.ONE(-Infinity)) {
            this.set(_min, _max);
        }
        /**
         * Define the corners of this box, standard values are Infinity for min, and -Infinity for max,
         * creating an impossible inverted box that can not contain any points
         */
        set(_min = FudgeCore.Vector3.ONE(Infinity), _max = FudgeCore.Vector3.ONE(-Infinity)) {
            this.min = _min;
            this.max = _max;
        }
        /**
         * Expand the box if necessary to include the given point
         */
        expand(_include) {
            this.min.min(_include);
            this.max.max(_include);
        }
        recycle() {
            this.min.set(Infinity, Infinity, Infinity);
            this.max.set(-Infinity, -Infinity, -Infinity);
        }
    }
    FudgeCore.Box = Box;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores information provided by {@link Render}-picking e.g. using {@link Picker} and provides methods for further calculation of positions and normals etc.
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Pick {
        #mtxViewToWorld;
        #posWorld;
        #posMesh;
        constructor(_node) {
            this.node = _node;
        }
        /**
         * Accessor to calculate and store world position of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get posWorld() {
            if (this.#posWorld)
                return this.#posWorld;
            let pointInClipSpace = FudgeCore.Vector3.Z(this.zBuffer);
            let m = this.#mtxViewToWorld.get();
            let result = FudgeCore.Vector3.TRANSFORMATION(pointInClipSpace, this.#mtxViewToWorld, true);
            let w = m[3] * pointInClipSpace.x + m[7] * pointInClipSpace.y + m[11] * pointInClipSpace.z + m[15];
            result.scale(1 / w);
            this.#posWorld = result;
            return result;
        }
        /**
         * Accessor to calculate and store position in mesh-space of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get posMesh() {
            if (this.#posMesh)
                return this.#posMesh;
            let mtxWorldToMesh = FudgeCore.Matrix4x4.INVERSE(this.node.getComponent(FudgeCore.ComponentMesh).mtxWorld);
            let posMesh = FudgeCore.Vector3.TRANSFORMATION(this.posWorld, mtxWorldToMesh);
            this.#posMesh = posMesh;
            return posMesh;
        }
        /**
         * Accessor to calculate and store the face normal in world-space at the point of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get normal() {
            let cmpMesh = this.node.getComponent(FudgeCore.ComponentMesh);
            let result;
            for (let face of cmpMesh.mesh.faces) {
                if (face.isInside(this.posMesh)) {
                    result = face.normal.clone;
                    break;
                }
            }
            result.transform(cmpMesh.mtxWorld, false);
            result.normalize();
            return result;
        }
        /**
         * Called solely by the renderer to enable calculation of the world coordinates of this {@link Pick}
         */
        set mtxViewToWorld(_mtxViewToWorld) {
            this.#mtxViewToWorld = _mtxViewToWorld;
        }
    }
    FudgeCore.Pick = Pick;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Provides static methods for picking using {@link Render}
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Picker {
        static pickRay(_from, _ray, _min, _max) {
            if (_from.length == 0)
                return [];
            let cmpCameraPick = FudgeCore.Recycler.reuse(FudgeCore.ComponentCamera);
            cmpCameraPick.mtxWorld.translation = _ray.origin;
            cmpCameraPick.mtxWorld.lookAt(FudgeCore.Vector3.SUM(_ray.origin, _ray.direction));
            cmpCameraPick.projectCentral(1, 0.001, FudgeCore.FIELD_OF_VIEW.DIAGONAL, _min, _max);
            cmpCameraPick.resetWorldToView();
            let picks;
            if (_from[0] instanceof FudgeCore.Node)
                picks = FudgeCore.Render.pick(_from, cmpCameraPick);
            else
                picks = FudgeCore.Gizmos.pick(_from, cmpCameraPick);
            FudgeCore.Recycler.store(cmpCameraPick);
            return picks;
        }
        static pickCamera(_from, _cmpCamera, _posProjection) {
            let ray = new FudgeCore.Ray(new FudgeCore.Vector3(-_posProjection.x, _posProjection.y, 1));
            let length = ray.direction.magnitude;
            if (_cmpCamera.node) {
                let mtxCamera = FudgeCore.Matrix4x4.PRODUCT(_cmpCamera.node.mtxWorld, _cmpCamera.mtxPivot);
                ray.transform(mtxCamera);
                FudgeCore.Recycler.store(mtxCamera);
            }
            else
                ray.transform(_cmpCamera.mtxPivot);
            let picks = Picker.pickRay(_from, ray, length * _cmpCamera.getNear(), length * _cmpCamera.getFar());
            return picks;
        }
        /**
         * Takes the camera of the given viewport and a point the client surface to construct the picker-camera,
         * then renders the pick-texture and returns an unsorted {@link Pick}-array with information about the hits of the ray.
         */
        static pickViewport(_viewport, _posClient) {
            let posProjection = _viewport.pointClientToProjection(_posClient);
            let nodes = Array.from(_viewport.getBranch().getIterator(true));
            let picks = Picker.pickCamera(nodes, _viewport.camera, posProjection);
            if (_viewport.gizmosEnabled)
                picks = picks.concat(Picker.pickCamera(_viewport.getGizmos(nodes), _viewport.camera, posProjection)); // this is kind of wasteful because we do the same calculations twice
            return picks;
        }
    }
    FudgeCore.Picker = Picker;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defined by an origin and a direction of type {@link Pick}, rays are used to calculate picking and intersections
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Ray {
        constructor(_direction = FudgeCore.Vector3.Z(1), _origin = FudgeCore.Vector3.ZERO(), _length = 1) {
            this.origin = _origin;
            this.direction = _direction;
            this.length = _length;
        }
        /**
         * Returns the point of intersection of this ray with a plane defined by
         * the given point of origin and the planes normal. All values and calculations
         * must be relative to the same coordinate system, preferably the world
         */
        intersectPlane(_origin, _normal) {
            let difference = FudgeCore.Vector3.DIFFERENCE(_origin, this.origin);
            let factor = FudgeCore.Vector3.DOT(difference, _normal) / FudgeCore.Vector3.DOT(this.direction, _normal);
            let intersect = FudgeCore.Vector3.SUM(this.origin, FudgeCore.Vector3.SCALE(this.direction, factor));
            return intersect;
        }
        /**
         * Returns the point of intersection of this ray with a plane defined by the face.
         * All values and calculations must be relative to the same coordinate system, preferably the world
         */
        intersectFacePlane(_face) {
            return this.intersectPlane(_face.getPosition(0), _face.normal);
        }
        /**
         * Returns the shortest distance from the ray to the given target point.
         * All values and calculations must be relative to the same coordinate system, preferably the world.
         */
        getDistance(_target) {
            let originToTarget = FudgeCore.Vector3.DIFFERENCE(_target, this.origin);
            let raySection = FudgeCore.Vector3.NORMALIZATION(this.direction, 1);
            let projectedLength = FudgeCore.Vector3.DOT(originToTarget, raySection);
            raySection.scale(projectedLength);
            raySection.add(this.origin);
            let distance = FudgeCore.Vector3.DIFFERENCE(_target, raySection);
            return distance;
        }
        /**
         * Transform the ray by the given matrix
         */
        transform(_mtxTransform) {
            this.origin.transform(_mtxTransform);
            this.direction.transform(_mtxTransform, false);
        }
        /**
         * Returns a readable string representation of this ray
         */
        toString() {
            return `origin: ${this.origin.toString()}, direction: ${this.direction.toString()}, length: ${this.length.toPrecision(5)}`;
        }
    }
    FudgeCore.Ray = Ray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The gizmos drawing interface. {@link Component}s can use this to draw visual aids inside {@link Component.drawGizmos} and {@link Component.drawGizmosSelected}.
     */
    class Gizmos {
        /**
         * The default opacity of occluded gizmo parts. Use this to control the visibility of gizmos behind objects.
         * Set to 0 to make occluded gizmo parts disappear. Set to 1 to make occluded gizmo parts fully visible.
         */
        static { this.alphaOccluded = 0.3; } // currently gizmos can always be picked even if this is set to 0...
        static { this.arrayBuffer = FudgeCore.RenderWebGL.assert(FudgeCore.RenderWebGL.getRenderingContext().createBuffer()); }
        static { this.posIcons = new Set(); } // cache the positions of icons to avoid drawing them within each other
        static #camera;
        static #meshes = {};
        static #mapMeshToWireBuffers = new WeakMap();
        // TODO: think about drawing these on the fly instead of caching them. Then we could accept a position, radius etc. parameter and draw them independent from the mtxWorld
        static get wireCircle() {
            const radius = 0.5;
            const segments = 45;
            const circle = new Array(segments).fill(null).map(() => FudgeCore.Recycler.get(FudgeCore.Vector3));
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * 2 * Math.PI;
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                circle[i].set(x, y, 0);
            }
            const lines = [];
            for (let i = 0; i < segments; i++)
                lines.push(circle[i], circle[(i + 1) % segments]);
            Reflect.defineProperty(Gizmos, "wireCircle", { value: lines });
            return Gizmos.wireCircle;
        }
        static get wireSphere() {
            let lines = Gizmos.wireCircle.concat();
            let mtxRotation = FudgeCore.Matrix4x4.ROTATION_X(90);
            lines.push(...Gizmos.wireCircle.map((_point) => FudgeCore.Vector3.TRANSFORMATION(_point, mtxRotation)));
            mtxRotation.rotateY(90);
            lines.push(...Gizmos.wireCircle.map((_point) => FudgeCore.Vector3.TRANSFORMATION(_point, mtxRotation)));
            Reflect.defineProperty(Gizmos, "wireSphere", { value: lines });
            return Gizmos.wireSphere;
        }
        static get wireCone() {
            const radius = 0.5;
            const height = 1;
            const apex = FudgeCore.Vector3.ZERO();
            const quad = [
                new FudgeCore.Vector3(radius, 0, height),
                new FudgeCore.Vector3(-radius, 0, height),
                new FudgeCore.Vector3(0, radius, height),
                new FudgeCore.Vector3(0, -radius, height)
            ];
            let lines = Gizmos.wireCircle.map((_point) => FudgeCore.Vector3.TRANSFORMATION(_point, FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Vector3.Z(1))));
            lines.push(...[apex, quad[0], apex, quad[1], apex, quad[2], apex, quad[3]]);
            Reflect.defineProperty(Gizmos, "wireCone", { value: lines });
            return Gizmos.wireCone;
        }
        static get wireCube() {
            const halfSize = 0.5;
            const cube = [
                new FudgeCore.Vector3(halfSize, halfSize, halfSize), new FudgeCore.Vector3(-halfSize, halfSize, halfSize),
                new FudgeCore.Vector3(-halfSize, -halfSize, halfSize), new FudgeCore.Vector3(halfSize, -halfSize, halfSize),
                new FudgeCore.Vector3(halfSize, halfSize, -halfSize), new FudgeCore.Vector3(-halfSize, halfSize, -halfSize),
                new FudgeCore.Vector3(-halfSize, -halfSize, -halfSize), new FudgeCore.Vector3(halfSize, -halfSize, -halfSize)
            ];
            const lines = [
                cube[0], cube[1], cube[1], cube[2], cube[2], cube[3], cube[3], cube[0],
                cube[4], cube[5], cube[5], cube[6], cube[6], cube[7], cube[7], cube[4],
                cube[0], cube[4], cube[1], cube[5], cube[2], cube[6], cube[3], cube[7]
            ];
            Reflect.defineProperty(Gizmos, "wireCube", { value: lines });
            return Gizmos.wireCube;
        }
        /**
         * Are we currently rendering for picking?
         */
        static get #picking() {
            return this.pickId != null;
        }
        /**
         * Draws the given gizmos from the point of view of the given camera.
         */
        static draw(_gizmos, _cmpCamera, _selected) {
            for (const gizmo of _gizmos)
                if (gizmo.node)
                    Reflect.set(gizmo.node, "zCamera", _cmpCamera.pointWorldToClip(gizmo.node.mtxWorld.translation).z);
            _gizmos = _gizmos.sort((_a, _b) => (_b.node ? Reflect.get(_b.node, "zCamera") : 2) -
                (_a.node ? Reflect.get(_a.node, "zCamera") : 2));
            Gizmos.#camera = _cmpCamera;
            Gizmos.posIcons.clear();
            FudgeCore.RenderWebGL.bufferCamera(_cmpCamera);
            for (const gizmo of _gizmos) {
                gizmo.drawGizmos?.(_cmpCamera, Gizmos.#picking);
                if (_selected?.includes(gizmo.node))
                    gizmo.drawGizmosSelected?.(_cmpCamera);
            }
        }
        /**
         * Picks all gizmos in the line of sight and returns an unsorted array of {@link Pick}s each associated with the gizmo the pick ray hit.
         */
        static pick(_gizmos, _cmpCamera) {
            return FudgeCore.RenderWebGL.pickFrom(_gizmos, _cmpCamera, pick);
            function pick(_gizmos, _cmpCamera) {
                const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
                crc3.uniformMatrix3fv(FudgeCore.ShaderPickTextured.uniforms["u_mtxPivot"], false, FudgeCore.Matrix3x3.IDENTITY().get()); // only needed for textured pick shader, but gizmos have no pivot
                Gizmos.#camera = _cmpCamera;
                Gizmos.posIcons.clear();
                let picks = [];
                for (let gizmo of _gizmos) {
                    if (!gizmo.drawGizmos)
                        continue;
                    Gizmos.pickId = picks.length;
                    gizmo.drawGizmos(_cmpCamera, Gizmos.#picking);
                    let pick = new FudgeCore.Pick(gizmo.node);
                    pick.gizmo = gizmo;
                    picks.push(pick);
                }
                Gizmos.pickId = null;
                return picks;
            }
        }
        /**
         * Draws a camera frustum for the given parameters. The frustum is oriented along the z-axis, with the tip of the truncated pyramid at the origin.
         */
        static drawWireFrustum(_aspect, _fov, _near, _far, _direction, _mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            const f = Math.tan(FudgeCore.Calc.deg2rad * _fov / 2);
            let scaleX = f;
            let scaleY = f;
            switch (_direction) {
                case FudgeCore.FIELD_OF_VIEW.HORIZONTAL:
                    scaleY = f / _aspect;
                    break;
                case FudgeCore.FIELD_OF_VIEW.VERTICAL:
                    scaleX = f * _aspect;
                    break;
                case FudgeCore.FIELD_OF_VIEW.DIAGONAL:
                    const diagonalAspect = Math.sqrt(_aspect);
                    scaleX = f * diagonalAspect;
                    scaleY = f / diagonalAspect;
                    break;
            }
            const nearX = _near * scaleX;
            const nearY = _near * scaleY;
            const farX = _far * scaleX;
            const farY = _far * scaleY;
            const frustum = new Array(8).fill(null).map(() => FudgeCore.Recycler.get(FudgeCore.Vector3));
            frustum[0].set(-nearX, nearY, _near);
            frustum[1].set(nearX, nearY, _near);
            frustum[2].set(nearX, -nearY, _near);
            frustum[3].set(-nearX, -nearY, _near);
            frustum[4].set(-farX, farY, _far);
            frustum[5].set(farX, farY, _far);
            frustum[6].set(farX, -farY, _far);
            frustum[7].set(-farX, -farY, _far);
            Gizmos.drawLines([
                frustum[0], frustum[1], frustum[1], frustum[2], frustum[2], frustum[3], frustum[3], frustum[0], // near plane
                frustum[4], frustum[5], frustum[5], frustum[6], frustum[6], frustum[7], frustum[7], frustum[4], // far plane
                frustum[0], frustum[4], frustum[1], frustum[5], frustum[2], frustum[6], frustum[3], frustum[7] // sides
            ], _mtxWorld, _color, _alphaOccluded);
            FudgeCore.Recycler.storeMultiple(...frustum);
        }
        /**
         * Draws a wireframe cube. The cube has a side-length of 1 and is centered around the origin.
         */
        static drawWireCube(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawLines(Gizmos.wireCube, _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws a wireframe sphere. The sphere has a diameter of 1 and is centered around the origin.
         */
        static drawWireSphere(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            let mtxWorld = _mtxWorld.clone;
            Gizmos.drawLines(Gizmos.wireSphere, mtxWorld, _color, _alphaOccluded);
            mtxWorld.lookAt(Gizmos.#camera.mtxWorld.translation);
            Gizmos.drawWireCircle(mtxWorld, _color, _alphaOccluded);
            FudgeCore.Recycler.store(mtxWorld);
        }
        /**
         * Draws a cone with a height and diameter of 1. The cone is oriented along the z-axis with the tip at the origin.
         */
        static drawWireCone(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawLines(Gizmos.wireCone, _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws a circle with a diameter of 1. The circle lies in the x-y plane, with its center at the origin.
         */
        static drawWireCircle(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawLines(Gizmos.wireCircle, _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws lines between each pair of the given vertices.
         * Vertices are paired sequentially, so for example, lines will be drawn between vertices 0 and 1, 2 and 3, 4 and 5, etc.
         */
        static drawLines(_vertices, _mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            const shader = Gizmos.#picking ? FudgeCore.ShaderPick : FudgeCore.ShaderGizmo;
            shader.useProgram();
            const lineData = new Float32Array(_vertices.length * 3);
            for (let i = 0; i < _vertices.length; i++) {
                const point = _vertices[i];
                lineData.set(point.get(), i * 3);
            }
            crc3.bindVertexArray(null);
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, Gizmos.arrayBuffer);
            crc3.enableVertexAttribArray(FudgeCore.SHADER_ATTRIBUTE.POSITION);
            crc3.vertexAttribPointer(FudgeCore.SHADER_ATTRIBUTE.POSITION, 3, WebGL2RenderingContext.FLOAT, false, 0, 0);
            Gizmos.bufferMatrix(shader, _mtxWorld);
            crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, lineData, WebGL2RenderingContext.DYNAMIC_DRAW);
            Gizmos.drawGizmos(shader, Gizmos.drawArrays, _vertices.length, _color, _alphaOccluded);
        }
        /**
         * Draws a wireframe mesh.
         */
        static drawWireMesh(_mesh, _mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            const shader = Gizmos.#picking ? FudgeCore.ShaderPick : FudgeCore.ShaderGizmo;
            shader.useProgram();
            const wireBuffers = Gizmos.#mapMeshToWireBuffers.get(_mesh) ?? {};
            if (!Gizmos.#mapMeshToWireBuffers.has(_mesh)) {
                const indices = [];
                const renderBuffers = _mesh.getRenderBuffers();
                const renderMesh = _mesh.renderMesh;
                for (let i = 0; i < renderMesh.indices.length; i += 3) { // TODO: think about caching this in the mesh
                    const a = renderMesh.indices[i];
                    const b = renderMesh.indices[i + 1];
                    const c = renderMesh.indices[i + 2];
                    // Add the line segments for the triangle to the line indices
                    indices.push(a, b, b, c, c, a);
                }
                // set up vertex attribute object
                wireBuffers.vao = FudgeCore.RenderWebGL.assert(crc3.createVertexArray());
                wireBuffers.indices = FudgeCore.RenderWebGL.assert(FudgeCore.RenderWebGL.getRenderingContext().createBuffer());
                wireBuffers.positions = renderBuffers.positions;
                wireBuffers.nIndices = indices.length;
                crc3.bindVertexArray(wireBuffers.vao);
                crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, wireBuffers.indices);
                crc3.bufferData(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), WebGL2RenderingContext.STATIC_DRAW);
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, renderBuffers.positions);
                crc3.enableVertexAttribArray(FudgeCore.SHADER_ATTRIBUTE.POSITION);
                crc3.vertexAttribPointer(FudgeCore.SHADER_ATTRIBUTE.POSITION, 3, WebGL2RenderingContext.FLOAT, false, 0, 0);
            }
            Gizmos.bufferMatrix(shader, _mtxWorld);
            crc3.bindVertexArray(wireBuffers.vao);
            Gizmos.drawGizmos(shader, Gizmos.drawElementsLines, wireBuffers.nIndices, _color, _alphaOccluded);
        }
        /**
         * Draws an arrow at the given world position, facing in the given direction with the given length and width.
         * Size refers to the size of the arrow head: the height of the pyramid; the size of the cube; the diameter of the sphere.
         */
        static drawArrow(_position, _color, _direction, _up, _length, _width, _size, _head = FudgeCore.MeshPyramid, _alphaOccluded = Gizmos.alphaOccluded) {
            const scaling = FudgeCore.Recycler.reuse(FudgeCore.Vector3).set(_width, _width, _length - _size);
            const mtxWorld = FudgeCore.Matrix4x4.COMPOSITION(_position);
            mtxWorld.scaling = scaling;
            mtxWorld.lookIn(_direction, _up);
            mtxWorld.translateZ(0.5);
            Gizmos.drawCube(mtxWorld, _color, _alphaOccluded);
            mtxWorld.translateZ(0.5);
            if (_head == FudgeCore.MeshPyramid) {
                const widthHead = _size / 2;
                mtxWorld.scaling = scaling.set(widthHead, widthHead, _size);
                mtxWorld.rotateX(90); // rotate the pyramid so it points in the right direction
            }
            else {
                mtxWorld.scaling = scaling.set(_size, _size, _size);
                mtxWorld.translateZ(0.5); // translate cube/sphere so it sits on top of the arrow
            }
            Gizmos.drawMesh(Gizmos.getMesh(_head), mtxWorld, _color, _alphaOccluded);
            FudgeCore.Recycler.storeMultiple(mtxWorld, scaling);
        }
        /**
         * Draws a solid cube.
         */
        static drawCube(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawMesh(Gizmos.getMesh(FudgeCore.MeshCube), _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws a solid sphere.
         */
        static drawSphere(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawMesh(Gizmos.getMesh(FudgeCore.MeshSphere), _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws a solid quad.
         */
        static drawQuad(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawMesh(Gizmos.getMesh(FudgeCore.MeshQuad), _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws a solid double sided quad.
         */
        static drawSprite(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawMesh(Gizmos.getMesh(FudgeCore.MeshSprite), _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws a solid pyramid.
         */
        static drawPyramid(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawMesh(Gizmos.getMesh(FudgeCore.MeshPyramid), _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws a solid mesh.
         */
        static drawMesh(_mesh, _mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            const shader = Gizmos.#picking ? FudgeCore.ShaderPick : FudgeCore.ShaderGizmo;
            shader.useProgram();
            FudgeCore.RenderWebGL.useNodeUniforms(shader, _mtxWorld, null, null, Gizmos.pickId);
            const renderBuffers = _mesh.useRenderBuffers();
            Gizmos.drawGizmos(shader, Gizmos.drawElementsTrianlges, renderBuffers.nIndices, _color, _alphaOccluded);
        }
        /**
         * Draws an icon from a {@link Texture} on a {@link MeshQuad}. The icon is affected by the given transform and color.
         */
        static drawIcon(_texture, _mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            let position = _mtxWorld.translation.toString();
            if (Gizmos.posIcons.has(position))
                return;
            Gizmos.posIcons.add(position);
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            const shader = Gizmos.#picking ? FudgeCore.ShaderPickTextured : FudgeCore.ShaderGizmoTextured;
            shader.useProgram();
            let mtxWorld = _mtxWorld.clone;
            let color = _color.clone;
            let back = Gizmos.#camera.mtxWorld.forward.negate();
            let up = Gizmos.#camera.mtxWorld.up;
            mtxWorld.lookIn(back, up);
            let distance = FudgeCore.Vector3.DIFFERENCE(Gizmos.#camera.mtxWorld.translation, mtxWorld.translation).magnitude;
            let fadeFar = 4;
            let fadeNear = 1.5;
            if (distance > 0 && distance < fadeFar) {
                distance = (distance - fadeNear) / (fadeFar - fadeNear);
                color.a = FudgeCore.Calc.lerp(0, color.a, distance);
            }
            _texture.useRenderData(FudgeCore.TEXTURE_LOCATION.COLOR.UNIT);
            crc3.uniform1i(shader.uniforms[FudgeCore.TEXTURE_LOCATION.COLOR.UNIFORM], FudgeCore.TEXTURE_LOCATION.COLOR.INDEX);
            FudgeCore.RenderWebGL.useNodeUniforms(shader, mtxWorld, null, null, Gizmos.pickId);
            const renderBuffers = Gizmos.getMesh(FudgeCore.MeshQuad).useRenderBuffers();
            Gizmos.drawGizmos(shader, Gizmos.drawElementsTrianlges, renderBuffers.nIndices, color, _alphaOccluded);
            FudgeCore.Recycler.storeMultiple(mtxWorld, color, back, up);
        }
        static bufferColor(_shader, _color) {
            FudgeCore.RenderWebGL.getRenderingContext().uniform4fv(_shader.uniforms["u_vctColor"], _color.get());
        }
        static bufferMatrix(_shader, _mtxWorld) {
            FudgeCore.RenderWebGL.getRenderingContext().uniformMatrix4fv(_shader.uniforms["u_mtxMeshToWorld"], false, _mtxWorld.get());
        }
        static drawGizmos(_shader, _draw, _count, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (_alphaOccluded > 0) {
                let color = _color.clone;
                color.a *= _alphaOccluded;
                // draw occluded parts where the depth test failed (by inverting the depth test + no depth write)
                crc3.depthFunc(WebGL2RenderingContext.GEQUAL);
                crc3.depthMask(false);
                Gizmos.bufferColor(_shader, color);
                _draw(_count);
                crc3.depthFunc(WebGL2RenderingContext.LESS);
                crc3.depthMask(true);
                FudgeCore.Recycler.store(color);
            }
            Gizmos.bufferColor(_shader, _color);
            _draw(_count);
        }
        static drawElementsTrianlges(_count) {
            FudgeCore.RenderWebGL.getRenderingContext().drawElements(WebGL2RenderingContext.TRIANGLES, _count, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
        }
        static drawElementsLines(_count) {
            FudgeCore.RenderWebGL.getRenderingContext().drawElements(WebGL2RenderingContext.LINES, _count, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
        }
        static drawArrays(_count) {
            FudgeCore.RenderWebGL.getRenderingContext().drawArrays(WebGL2RenderingContext.LINES, 0, _count);
        }
        static getMesh(_constructor) {
            let key = _constructor.name;
            let mesh = Gizmos.#meshes[key];
            if (mesh)
                return mesh;
            mesh = new _constructor(key);
            FudgeCore.Project.deregister(mesh);
            Gizmos.#meshes[key] = mesh;
            return mesh;
        }
    }
    FudgeCore.Gizmos = Gizmos;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The main interface to the render engine, here WebGL (see superclass {@link RenderWebGL} and the RenderInjectors
     */
    let Render = (() => {
        let _classSuper = FudgeCore.RenderWebGL;
        let _staticExtraInitializers = [];
        let _static_prepare_decorators;
        let _static_draw_decorators;
        return class Render extends _classSuper {
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _static_prepare_decorators = [FudgeCore.PerformanceMonitor.measure("Render.prepare")];
                _static_draw_decorators = [FudgeCore.PerformanceMonitor.measure("Render.draw")];
                __esDecorate(this, null, _static_prepare_decorators, { kind: "method", name: "prepare", static: true, private: false, access: { has: obj => "prepare" in obj, get: obj => obj.prepare }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(this, null, _static_draw_decorators, { kind: "method", name: "draw", static: true, private: false, access: { has: obj => "draw" in obj, get: obj => obj.draw }, metadata: _metadata }, null, _staticExtraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.rectClip = (__runInitializers(this, _staticExtraInitializers), new FudgeCore.Rectangle(-1, 1, 2, -2)); }
            static { this.nodesPhysics = new FudgeCore.RecycableArray(); }
            static { this.componentsPick = new FudgeCore.RecycableArray(); }
            static { this.lights = new Map(); }
            static { this.nodesSimple = new FudgeCore.RecycableArray(); }
            static { this.nodesAlpha = new FudgeCore.RecycableArray(); }
            static { this.componentsSkeleton = new FudgeCore.RecycableArray(); }
            static { this.coats = new Set(); } // TODO: test if sets are an appropriate data structure here
            static { this.modificationsProcessed = new Set(); }
            /**
             * Recursively iterates over the branch starting with the node given, recalculates all world transforms,
             * collects all lights and feeds all shaders used in the graph with these lights. Sorts nodes for different
             * render passes.
             * @param _recalculate - set true to force recalculation of all world transforms in the given branch, even if their local transforms haven't changed
             */
            static prepare(_branch, _options = {}, _mtxWorld = FudgeCore.Matrix4x4.IDENTITY(), _recalculate = false) {
                Render.timestampUpdate = performance.now();
                Render.nodesSimple.reset();
                Render.nodesAlpha.reset();
                Render.nodesPhysics.reset();
                Render.componentsPick.reset();
                Render.componentsSkeleton.reset();
                Render.coats.clear();
                Render.modificationsProcessed.clear();
                Render.lights.forEach(_array => _array.reset());
                FudgeCore.Node.resetRenderData();
                FudgeCore.Coat.resetRenderData();
                _branch.dispatchEvent(new Event("renderPrepareStart" /* EVENT.RENDER_PREPARE_START */));
                this.prepareBranch(_branch, _options, _mtxWorld, _recalculate);
                for (const processed of Render.modificationsProcessed)
                    processed.modified = false;
                _branch.dispatchEvent(new Event("renderPrepareEnd" /* EVENT.RENDER_PREPARE_END */));
                for (const cmpSkeleton of Render.componentsSkeleton) {
                    cmpSkeleton.update();
                    cmpSkeleton.updateRenderBuffer();
                }
                for (const coat of Render.coats)
                    coat.updateRenderData();
                FudgeCore.Node.updateRenderbuffer();
                FudgeCore.Coat.updateRenderbuffer();
                Render.bufferLights(Render.lights);
            }
            static addLights(_cmpLights) {
                for (let cmpLight of _cmpLights) {
                    if (!cmpLight.isActive)
                        continue;
                    let type = cmpLight.light.getType();
                    let lightsOfType = Render.lights.get(type);
                    if (!lightsOfType) {
                        lightsOfType = new FudgeCore.RecycableArray();
                        Render.lights.set(type, lightsOfType);
                    }
                    lightsOfType.push(cmpLight);
                }
            }
            /**
             * Used with a {@link Picker}-camera, this method renders one pixel with picking information
             * for each node in the line of sight and return that as an unsorted {@link Pick}-array
             */
            static pick(_nodes, _cmpCamera) {
                return Render.pickFrom(_nodes, _cmpCamera, super.pick);
            }
            /**
             * Draws the scene from the point of view of the given camera
             */
            static draw(_cmpCamera) {
                for (let node of Render.nodesAlpha)
                    Reflect.set(node, "zCamera", _cmpCamera.pointWorldToClip(node.getComponent(FudgeCore.ComponentMesh).mtxWorld.translation).z);
                const sorted = Render.nodesAlpha.getSorted((_a, _b) => Reflect.get(_b, "zCamera") - Reflect.get(_a, "zCamera"));
                Render.drawNodes(Render.nodesSimple, sorted, _cmpCamera);
            }
            static prepareBranch(_branch, _options, _mtxWorld, _recalculate) {
                if (!_branch.isActive)
                    return; // don't add branch to render list if not active
                _branch.nNodesInBranch = 1;
                _branch.radius = 0;
                _branch.dispatchEventToTargetOnly(new Event("renderPrepare" /* EVENT.RENDER_PREPARE */));
                _branch.timestampUpdate = Render.timestampUpdate;
                let cmpTransform = _branch.getComponent(FudgeCore.ComponentTransform);
                if (cmpTransform && cmpTransform.isActive) {
                    if ((_recalculate ||= cmpTransform.mtxLocal.modified)) {
                        // PerformanceMonitor.startMeasure("Render.prepare mtxWorld * mtxLocal");
                        let mtxWorldBranch = FudgeCore.Matrix4x4.PRODUCT(_mtxWorld, _branch.cmpTransform.mtxLocal);
                        // PerformanceMonitor.endMeasure("Render.prepare mtxWorld * mtxLocal");
                        _branch.mtxWorld.copy(mtxWorldBranch);
                        FudgeCore.Recycler.store(mtxWorldBranch);
                        Render.modificationsProcessed.add(cmpTransform.mtxLocal);
                    }
                }
                else
                    _branch.mtxWorld.copy(_mtxWorld); // overwrite readonly mtxWorld of the current node
                let cmpRigidbody = _branch.getComponent(FudgeCore.ComponentRigidbody);
                if (cmpRigidbody && cmpRigidbody.isActive) { //TODO: support de-/activation throughout
                    Render.nodesPhysics.push(_branch); // add this node to physics list
                    if (!_options?.ignorePhysics)
                        this.transformByPhysics(_branch, cmpRigidbody);
                }
                let cmpPick = _branch.getComponent(FudgeCore.ComponentPick);
                if (cmpPick && cmpPick.isActive) {
                    Render.componentsPick.push(cmpPick); // add this component to pick list
                }
                let cmpLights = _branch.getComponents(FudgeCore.ComponentLight);
                Render.addLights(cmpLights);
                let cmpMesh = _branch.getComponent(FudgeCore.ComponentMesh);
                let cmpMaterial = _branch.getComponent(FudgeCore.ComponentMaterial);
                if (cmpMesh && cmpMesh.isActive && cmpMaterial && cmpMaterial.isActive) {
                    if (cmpMesh.mtxPivot.modified || _branch.mtxWorld.modified) {
                        // PerformanceMonitor.startMeasure("Render.prepare mtxWorld * mtxPivot");
                        let mtxWorldMesh = FudgeCore.Matrix4x4.PRODUCT(_branch.mtxWorld, cmpMesh.mtxPivot);
                        // PerformanceMonitor.endMeasure("Render.prepare mtxWorld * mtxPivot");
                        cmpMesh.mtxWorld.copy(mtxWorldMesh);
                        FudgeCore.Recycler.store(mtxWorldMesh); // TODO: examine, why recycling this causes meshes to be misplaced...
                        Render.modificationsProcessed.add(cmpMesh.mtxPivot);
                        Render.modificationsProcessed.add(_branch.mtxWorld);
                    }
                    let cmpFaceCamera = _branch.getComponent(FudgeCore.ComponentFaceCamera);
                    let cmpParticleSystem = _branch.getComponent(FudgeCore.ComponentParticleSystem);
                    _branch.updateRenderData(cmpMesh, cmpMaterial, cmpFaceCamera, cmpParticleSystem);
                    _branch.radius = cmpMesh.radius;
                    if (cmpMaterial.sortForAlpha || _branch.getComponent(FudgeCore.ComponentText)) // always sort text for alpha
                        Render.nodesAlpha.push(_branch); // add this node to render list
                    else
                        Render.nodesSimple.push(_branch); // add this node to render list
                    let material = cmpMaterial.material;
                    if (material)
                        Render.coats.add(material.coat);
                }
                let cmpSkeletons = _branch.getComponents(FudgeCore.ComponentSkeleton);
                for (let cmpSkeleton of cmpSkeletons)
                    if (cmpSkeleton && cmpSkeleton.isActive)
                        Render.componentsSkeleton.push(cmpSkeleton);
                for (let child of _branch.getChildren()) {
                    Render.prepareBranch(child, _options, _branch.mtxWorld, _recalculate);
                    _branch.nNodesInBranch += child.nNodesInBranch;
                    let cmpMeshChild = child.getComponent(FudgeCore.ComponentMesh);
                    let position = cmpMeshChild ? cmpMeshChild.mtxWorld.translation : child.mtxWorld.translation;
                    position = position.clone;
                    _branch.radius = Math.max(_branch.radius, position.getDistance(_branch.mtxWorld.translation) + child.radius);
                    FudgeCore.Recycler.store(position);
                }
            }
            static transformByPhysics(_node, _cmpRigidbody) {
                if (!_cmpRigidbody.isInitialized) // || Project.mode == MODE.EDITOR)
                    _cmpRigidbody.initialize();
                if (!FudgeCore.Physics.getBodyList().length)
                    return;
                if (!_node.mtxLocal) {
                    throw (new Error("ComponentRigidbody requires ComponentTransform at the same Node"));
                }
                // _cmpRigidbody.checkCollisionEvents();
                if (_cmpRigidbody.typeBody == FudgeCore.BODY_TYPE.KINEMATIC || FudgeCore.Project.mode == FudgeCore.MODE.EDITOR) { //Case of Kinematic Rigidbody
                    let mtxPivotWorld = FudgeCore.Matrix4x4.PRODUCT(_node.mtxWorld, _cmpRigidbody.mtxPivotUnscaled);
                    _cmpRigidbody.setPosition(mtxPivotWorld.translation);
                    _cmpRigidbody.setRotation(mtxPivotWorld.rotation);
                    FudgeCore.Recycler.store(mtxPivotWorld);
                    return;
                }
                let mtxWorld = FudgeCore.Matrix4x4.COMPOSITION(_cmpRigidbody.getPosition(), _cmpRigidbody.getRotation());
                mtxWorld.multiply(_cmpRigidbody.mtxPivotInverse);
                _node.mtxWorld.translation = mtxWorld.translation;
                _node.mtxWorld.rotation = mtxWorld.rotation;
                let parent = _node.getParent();
                let mtxLocal = parent ?
                    FudgeCore.Matrix4x4.RELATIVE(_node.mtxWorld, parent.mtxWorld, parent.mtxWorldInverse) :
                    _node.mtxWorld.clone;
                _node.mtxLocal.copy(mtxLocal);
                FudgeCore.Recycler.store(mtxWorld);
                FudgeCore.Recycler.store(mtxLocal);
            }
        };
    })();
    FudgeCore.Render = Render;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Inserted into a {@link Mesh}, an instance of this class calculates and represents the mesh data in the form needed by the render engine
     */
    class RenderMesh {
        /** indices to create faces from the vertices, rotation determines direction of face-normal */
        #indices;
        /** vertices of the actual point cloud, some points might be in the same location in order to refer to different texels */
        #positions;
        /** vertex normals for smooth shading, interpolated between vertices during rendering */
        #normals;
        /** texture coordinates associated with the vertices by the position in the array */
        #textureUVs;
        /* colors */
        #colors;
        /** vertex tangents for normal mapping, based on the vertex normals and the UV coordinates */
        #tangents;
        #bones;
        #weights;
        constructor(_mesh) {
            this.mesh = _mesh;
        }
        get positions() {
            return this.#positions || ( // return cache or ...
            // ... flatten all vertex positions from cloud into a typed array
            this.#positions = new Float32Array(this.mesh.vertices.flatMap((_vertex, _index) => {
                return [...this.mesh.vertices.position(_index).get()];
            })));
        }
        set positions(_vertices) {
            this.#positions = _vertices;
        }
        get indices() {
            return this.#indices || ( // return cache or ...
            // ... flatten all indices from the faces into a typed array
            this.#indices = new Uint16Array(this.mesh.faces.flatMap((_face) => _face.indices)));
        }
        set indices(_indices) {
            this.#indices = _indices;
        }
        get normals() {
            if (this.#normals == null) {
                // TODO: implement a check similiar to the one for tangents below, to see if normals are already present in the vertices
                // sum up all unscaled normals of faces connected to one vertex, weighted by the angle between the two neighbour vertices...
                this.mesh.vertices.forEach(_vertex => _vertex.normal.set(0, 0, 0));
                for (let face of this.mesh.faces)
                    face.indices.forEach((_iVertex, _iFaceVertex) => {
                        this.mesh.vertices.normal(_iVertex).add(FudgeCore.Vector3.SCALE(face.normalUnscaled, face.angles[_iFaceVertex]));
                    });
                // ... and normalize them
                this.mesh.vertices.forEach(_vertex => {
                    // some vertices might be unused and yield a zero-normal...
                    if (_vertex.normal.magnitudeSquared > 0)
                        _vertex.normal.normalize();
                });
                // this.∆ínormalsVertex = new Float32Array(normalsVertex.flatMap((_normal: Vector3) => [..._normal.get()]));
                this.#normals = new Float32Array(this.mesh.vertices.flatMap((_vertex, _index) => [...this.mesh.vertices.normal(_index).get()]));
            }
            return this.#normals;
        }
        set normals(_normals) {
            this.#normals = _normals;
        }
        get tangents() {
            if (this.#tangents == null) {
                if (this.mesh.vertices.some(_vertex => !_vertex.uv)) { // assume all vertices have texture coordinates or none
                    this.#tangents = new Float32Array(); // no texture coordinates, no tangents
                    return this.#tangents;
                }
                if (this.mesh.vertices.some(_vertex => !_vertex.tangent)) { // assume all vertices have tangents or none
                    const tangents = new Array(this.mesh.vertices.length);
                    const bitangents = new Array(this.mesh.vertices.length);
                    for (let i = 0; i < tangents.length; i++) {
                        tangents[i] = FudgeCore.Vector3.ZERO();
                        bitangents[i] = FudgeCore.Vector3.ZERO();
                    }
                    // this.mesh.vertices.forEach(_vertex => _vertex.tangent.set(0, 0, 0));
                    for (let face of this.mesh.faces) {
                        let i0 = face.indices[0];
                        let i1 = face.indices[1];
                        let i2 = face.indices[2];
                        //vertices surrounding one triangle
                        let v0 = this.mesh.vertices.position(i0);
                        let v1 = this.mesh.vertices.position(i1);
                        let v2 = this.mesh.vertices.position(i2);
                        //their UVs
                        let uv0 = this.mesh.vertices.uv(i0);
                        let uv1 = this.mesh.vertices.uv(i1);
                        let uv2 = this.mesh.vertices.uv(i2);
                        //We compute the edges of the triangle...
                        let deltaPos0 = FudgeCore.Vector3.DIFFERENCE(v1, v0);
                        let deltaPos1 = FudgeCore.Vector3.DIFFERENCE(v2, v0);
                        //...and the edges of the triangles in UV space...
                        let deltaUV0 = FudgeCore.Vector2.DIFFERENCE(uv1, uv0);
                        let deltaUV1 = FudgeCore.Vector2.DIFFERENCE(uv2, uv0);
                        //...and compute the tangent
                        let r = 1 / FudgeCore.Vector2.CROSS(deltaUV0, deltaUV1);
                        let faceTangent = FudgeCore.Vector3.SCALE(FudgeCore.Vector3.DIFFERENCE(FudgeCore.Vector3.SCALE(deltaPos0, deltaUV1.y), FudgeCore.Vector3.SCALE(deltaPos1, deltaUV0.y)), r);
                        let faceBitangent = FudgeCore.Vector3.SCALE(FudgeCore.Vector3.DIFFERENCE(FudgeCore.Vector3.SCALE(deltaPos1, -deltaUV0.x), FudgeCore.Vector3.SCALE(deltaPos0, -deltaUV1.x)), r); // for winding order counter clockwise
                        tangents[i0].add(FudgeCore.Vector3.SCALE(faceTangent, face.angles[0]));
                        tangents[i1].add(FudgeCore.Vector3.SCALE(faceTangent, face.angles[1]));
                        tangents[i2].add(FudgeCore.Vector3.SCALE(faceTangent, face.angles[2]));
                        bitangents[i0].add(FudgeCore.Vector3.SCALE(faceBitangent, face.angles[0]));
                        bitangents[i1].add(FudgeCore.Vector3.SCALE(faceBitangent, face.angles[1]));
                        bitangents[i2].add(FudgeCore.Vector3.SCALE(faceBitangent, face.angles[2]));
                    }
                    this.mesh.vertices.forEach((_vertex, _index) => {
                        let normal = this.mesh.vertices.normal(_index);
                        let tangent = tangents[_index];
                        let bitangent = bitangents[_index];
                        // reorthogonalize
                        tangent.add(FudgeCore.Vector3.SCALE(normal, -FudgeCore.Vector3.DOT(normal, tangent)));
                        if (tangent.magnitudeSquared > 0) // some vertices might be unused and yield a zero-tangent...
                            tangent.normalize();
                        let handedness = (FudgeCore.Vector3.DOT(FudgeCore.Vector3.CROSS(normal, tangent), bitangent) < 0) ? -1 : 1;
                        _vertex.tangent = new FudgeCore.Vector4(tangent.x, tangent.y, tangent.z, handedness);
                    });
                }
                this.#tangents = new Float32Array(this.mesh.vertices.flatMap(_vertex => _vertex.tangent.get()));
            }
            return this.#tangents;
        }
        set tangents(_tangents) {
            this.#tangents = _tangents;
        }
        get textureUVs() {
            return this.#textureUVs || ( // return cache or ...
            // ... flatten all uvs from the clous into a typed array
            this.#textureUVs = new Float32Array(this.mesh.vertices
                .filter(_vertex => _vertex.uv)
                .flatMap((_vertex) => [..._vertex.uv.get()])));
        }
        set textureUVs(_textureUVs) {
            this.#textureUVs = _textureUVs;
        }
        get colors() {
            return this.#colors || (this.#colors = new Float32Array(this.mesh.vertices
                .filter(_vertex => _vertex.color)
                .flatMap(_vertex => [..._vertex.color.get()])));
        }
        set colors(_colors) {
            this.#colors = _colors;
        }
        get bones() {
            return this.#bones || ( // return cache or ...
            this.#bones = this.mesh.vertices.some(_vertex => _vertex.bones) ?
                new Uint8Array(this.mesh.vertices.flatMap((_vertex, _index) => {
                    const bones = this.mesh.vertices.bones(_index);
                    return [bones?.[0]?.index || 0, bones?.[1]?.index || 0, bones?.[2]?.index || 0, bones?.[3]?.index || 0];
                })) :
                undefined);
        }
        set bones(_iBones) {
            this.#bones = _iBones;
        }
        get weights() {
            return this.#weights || ( // return cache or ...
            this.#weights = this.mesh.vertices.some(_vertex => _vertex.bones) ?
                new Float32Array(this.mesh.vertices.flatMap((_vertex, _index) => {
                    const bones = this.mesh.vertices.bones(_index);
                    return [bones?.[0]?.weight || 0, bones?.[1]?.weight || 0, bones?.[2]?.weight || 0, bones?.[3]?.weight || 0];
                })) :
                undefined);
        }
        set weights(_weights) {
            this.#weights = _weights;
        }
        /**
         * Clears this render mesh and all its buffers
         */
        clear() {
            this.#positions = null;
            this.#indices = null;
            this.#textureUVs = null;
            this.#normals = null;
            this.#colors = null;
            this.#tangents = null;
            this.#bones = null;
            this.#weights = null;
        }
    }
    FudgeCore.RenderMesh = RenderMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Controls the rendering of a branch, using the given {@link ComponentCamera},
     * and the propagation of the rendered image from the offscreen renderbuffer to the target canvas
     * through a series of {@link Framing} objects. The stages involved are in order of rendering
     * {@link Render}.viewport -> {@link Viewport}.source -> {@link Viewport}.destination -> DOM-Canvas -> Client(CSS)
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019-2022 | Jonas Plotzky, HFU, 2023
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Viewport
     */
    class Viewport extends FudgeCore.EventTargetUnified {
        constructor() {
            super(...arguments);
            this.name = "Viewport"; // The name to call this viewport by.
            this.camera = null; // The camera representing the view parameters to render the branch.
            // TODO: verify if client to canvas should be in Viewport or somewhere else (Window, Container?)
            // Multiple viewports using the same canvas shouldn't differ here...
            // different framing methods can be used, this is the default
            this.frameClientToCanvas = new FudgeCore.FramingScaled();
            this.frameCanvasToDestination = new FudgeCore.FramingComplex();
            this.frameDestinationToSource = new FudgeCore.FramingScaled();
            this.frameSourceToRender = new FudgeCore.FramingScaled();
            this.adjustingFrames = true; // TODO: maybe only adjust frames when anything changes instead of every drawn frame?
            this.adjustingCamera = true;
            this.physicsDebugMode = FudgeCore.PHYSICS_DEBUGMODE.NONE;
            this.gizmosEnabled = false;
            this.gizmosFilter = Object.fromEntries(FudgeCore.Component.subclasses // TODO: maybe make this lazy TODO: change to js object
                .filter((_class) => (_class.prototype).drawGizmos || (_class.prototype).drawGizmosSelected)
                .map((_class) => [_class.name, true]));
            this.componentsPick = new FudgeCore.RecycableArray();
            this.#branch = null; // The to render with all its descendants.
            this.#crc2 = null;
            this.#canvas = null;
        }
        #branch; // The to render with all its descendants.
        #crc2;
        #canvas;
        //#endregion
        // #region Events (passing from canvas to viewport and from there into branch)
        /**
         * Returns true if this viewport currently has focus and thus receives keyboard events
         */
        get hasFocus() {
            return (Viewport.focus == this);
        }
        /**
         * Retrieve the destination canvas
         */
        get canvas() {
            return this.#canvas;
        }
        /**
         * Retrieve the 2D-context attached to the destination canvas
         */
        get context() {
            return this.#crc2;
        }
        /**
         * Connects the viewport to the given canvas to render the given branch to using the given camera-component, and names the viewport as given.
         */
        initialize(_name, _branch, _camera, _canvas) {
            this.name = _name;
            this.camera = _camera;
            this.#canvas = _canvas;
            this.#crc2 = _canvas.getContext("2d");
            this.#canvas.tabIndex = 0; // can get focus and receive keyboard events
            this.rectSource = FudgeCore.Render.getCanvasRect();
            this.rectDestination = this.getClientRectangle();
            this.setBranch(_branch);
        }
        /**
         * Retrieve the size of the destination canvas as a rectangle, x and y are always 0
         */
        getCanvasRectangle() {
            return FudgeCore.Rectangle.GET(0, 0, this.#canvas.width, this.#canvas.height);
        }
        /**
         * Retrieve the client rectangle the canvas is displayed and fit in, x and y are always 0
         */
        getClientRectangle() {
            // FUDGE doesn't care about where the client rect is, only about the size matters.
            // return Rectangle.GET(this.canvas.offsetLeft, this.canvas.offsetTop, this.canvas.clientWidth, this.canvas.clientHeight);
            return FudgeCore.Rectangle.GET(0, 0, this.#canvas.clientWidth, this.#canvas.clientHeight);
        }
        /**
         * Set the branch to be drawn in the viewport.
         */
        setBranch(_branch) {
            if (_branch) {
                _branch.broadcastEvent(new Event("attachBranch" /* EVENT.ATTACH_BRANCH */));
            }
            this.#branch = _branch;
        }
        /**
         * Retrieve the branch this viewport renders
         */
        getBranch() {
            return this.#branch;
        }
        // #region Drawing
        /**
         * Draw this viewport displaying its branch. By default, the transforms in the branch are recalculated first.
         * Pass `false` if calculation was already done for this frame
         */
        // @PerformanceMonitor.measure("Viewport.draw")
        draw(_prepareBranch = true) {
            this.prepare(_prepareBranch);
            FudgeCore.Render.resetFramebuffer();
            FudgeCore.Render.clear(this.camera.clrBackground);
            if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.PHYSIC_OBJECTS_ONLY) {
                FudgeCore.Render.draw(this.camera);
                if (this.gizmosEnabled)
                    FudgeCore.Gizmos.draw(this.getGizmos(), this.camera, this.gizmosSelected);
            }
            if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.NONE) {
                FudgeCore.Physics.draw(this.camera, this.physicsDebugMode);
            }
            this.dispatchEvent(new Event("renderEnd" /* EVENT.RENDER_END */));
            this.#crc2.imageSmoothingEnabled = false;
            this.#crc2.drawImage(FudgeCore.Render.getCanvas(), this.rectSource.x, this.rectSource.y, this.rectSource.width, this.rectSource.height, this.rectDestination.x, this.rectDestination.y, this.rectDestination.width, this.rectDestination.height);
        }
        /**
        * Adjusts all frames and the camera to fit the current size of the canvas. Prepares the branch for rendering.
        */
        // @PerformanceMonitor.measure("Viewport.prepare")
        prepare(_prepareBranch = true) {
            if (!this.#branch)
                return;
            if (!this.camera.isActive)
                return;
            // PerformanceMonitor.startMeasure("Viewport.prepare cmpCamera.mtxWorld * cmpCamera.mtxPivot");
            if (this.camera.node) {
                const mtxWorldCamera = FudgeCore.Matrix4x4.PRODUCT(this.camera.node.mtxWorld, this.camera.mtxPivot);
                this.camera.mtxWorld.copy(mtxWorldCamera);
                FudgeCore.Recycler.store(mtxWorldCamera);
            }
            else {
                this.camera.mtxWorld.copy(this.camera.mtxPivot);
            }
            // PerformanceMonitor.endMeasure("Viewport.prepare cmpCamera.mtxWorld * cmpCamera.mtxPivot");
            if (this.adjustingFrames)
                this.adjustFrames();
            if (this.adjustingCamera)
                this.adjustCamera();
            if (_prepareBranch)
                this.prepareBranch();
        }
        /**
         * Prepares all nodes in the branch for rendering by updating their world transforms etc.
         */
        // @PerformanceMonitor.measure("Viewport.prepareBranch")
        prepareBranch() {
            let mtxRoot = FudgeCore.Matrix4x4.IDENTITY();
            if (this.#branch.getParent())
                mtxRoot = this.#branch.getParent().mtxWorld;
            this.dispatchEvent(new Event("renderPrepareStart" /* EVENT.RENDER_PREPARE_START */));
            FudgeCore.Render.prepare(this.#branch, {}, mtxRoot);
            this.dispatchEvent(new Event("renderPrepareEnd" /* EVENT.RENDER_PREPARE_END */));
            this.componentsPick = FudgeCore.Render.componentsPick;
        }
        /**
         * Performs a pick on all {@link ComponentPick}s in the branch of this viewport
         * using a ray from its camera through the client coordinates given in the event.
         * Dispatches the event to all nodes hit.
         * If {@link PICK.CAMERA} was chosen as the method to pick, a pick property gets added to the event,
         * which holds the detailed information, but is overwritten for each node.
         */
        dispatchPointerEvent(_event) {
            let posClient = new FudgeCore.Vector2(_event.clientX, _event.clientY);
            let ray = this.getRayFromClient(posClient);
            // let cameraPicks: RecycableArray<Node> = Recycler.get(RecycableArray); //TODO: think about optimization later
            let cameraPicks = [];
            let otherPicks = [];
            for (let cmpPick of this.componentsPick)
                if (cmpPick.pick == FudgeCore.PICK.CAMERA)
                    cameraPicks.push(cmpPick.node);
                else
                    otherPicks.push(cmpPick);
            if (cameraPicks.length) {
                let picks = FudgeCore.Picker.pickCamera(cameraPicks, this.camera, this.pointClientToProjection(posClient));
                for (let pick of picks) {
                    Reflect.set(_event, "pick", pick);
                    pick.node.dispatchEvent(_event);
                }
            }
            for (let cmpPick of otherPicks) {
                cmpPick.pickAndDispatch(ray, _event);
            }
        }
        /**
         * Adjust all frames involved in the rendering process from the display area in the client up to the renderer canvas
         */
        // @PerformanceMonitor.measure("Viewport.adjustFrames")
        adjustFrames() {
            // get the rectangle of the canvas area as displayed (consider css)
            let rectClient = this.getClientRectangle();
            // adjust the canvas size according to the given framing applied to client
            let rectCanvas = this.frameClientToCanvas.getRect(rectClient);
            this.#canvas.width = rectCanvas.width;
            this.#canvas.height = rectCanvas.height;
            let rectTemp;
            // adjust the destination area on the target-canvas to render to by applying the framing to canvas
            rectTemp = this.frameCanvasToDestination.getRect(rectCanvas);
            this.rectDestination.copy(rectTemp);
            FudgeCore.Recycler.store(rectTemp);
            // adjust the area on the source-canvas to render from by applying the framing to destination area
            rectTemp = this.frameDestinationToSource.getRect(this.rectDestination);
            this.rectSource.copy(rectTemp);
            FudgeCore.Recycler.store(rectTemp);
            // having an offset source does make sense only when multiple viewports display parts of the same rendering. For now: shift it to 0,0
            this.rectSource.x = this.rectSource.y = 0;
            // still, a partial image of the rendering may be retrieved by moving and resizing the render viewport. For now, it's always adjusted to the current viewport
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            FudgeCore.Render.setRenderRectangle(rectRender);
            let rectOffscreenCanvas = FudgeCore.Render.getCanvasRect(); // there are far to many rectangles involved here...
            // no more transformation after this for now, offscreen canvas and render-viewport have the same size
            FudgeCore.Render.setCanvasSize(rectRender.width, rectRender.height);
            if (rectRender.width != rectOffscreenCanvas.width || rectRender.height != rectOffscreenCanvas.height)
                FudgeCore.Render.adjustAttachments();
            FudgeCore.Recycler.store(rectClient);
            FudgeCore.Recycler.store(rectCanvas);
            FudgeCore.Recycler.store(rectRender);
            FudgeCore.Recycler.store(rectOffscreenCanvas);
        }
        /**
         * Adjust the camera parameters to fit the rendering into the render viewport
         */
        adjustCamera() {
            let rect = FudgeCore.Render.getRenderRectangle();
            // if (this.camera.getProjection() == PROJECTION.ORTHOGRAPHIC)
            //   this.camera.projectOrthographic(-rect.width / 20, rect.width / 20, rect.height / 20, -rect.height / 20);
            // else
            this.camera.projectCentral(rect.width / rect.height, this.camera.getFieldOfView(), this.camera.getDirection(), this.camera.getNear(), this.camera.getFar());
            this.camera.resetWorldToView();
        }
        // #endregion
        //#region Points
        /**
         * Returns a {@link Ray} in world coordinates from this camera through the point given in client space
         */
        getRayFromClient(_point) {
            let posProjection = this.pointClientToProjection(_point);
            let ray = new FudgeCore.Ray(new FudgeCore.Vector3(-posProjection.x, posProjection.y, 1));
            // ray.direction.scale(camera.distance);
            ray.transform(this.camera.mtxPivot);
            let cameraNode = this.camera.node;
            if (cameraNode)
                ray.transform(cameraNode.mtxWorld);
            return ray;
        }
        /**
         * Returns a point on the client rectangle matching the projection of the given point in world space
         */
        pointWorldToClient(_position) {
            let projection = this.camera.pointWorldToClip(_position);
            let posClient = this.pointClipToClient(projection.toVector2());
            return posClient;
        }
        /**
         * Returns a point on the source-rectangle matching the given point on the client rectangle
         */
        pointClientToSource(_client) {
            let result = this.frameClientToCanvas.getPoint(_client, this.getClientRectangle());
            result = this.frameCanvasToDestination.getPoint(result, this.getCanvasRectangle());
            result = this.frameDestinationToSource.getPoint(result, this.rectSource);
            //TODO: when Source, Render and RenderViewport deviate, continue transformation 
            return result;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the source rectangle
         */
        pointSourceToRender(_source) {
            let projectionRectangle = this.camera.getProjectionRectangle();
            let point = this.frameSourceToRender.getPoint(_source, projectionRectangle);
            // console.log(projectionRectangle.toString());
            return point;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the client rectangle
         */
        pointClientToRender(_client) {
            let point = this.pointClientToSource(_client);
            point = this.pointSourceToRender(point);
            //TODO: when Render and RenderViewport deviate, continue transformation 
            return point;
        }
        /**
         * Returns a point on a projection surface in the hypothetical distance of 1 to the camera
         * matching the given point on the client rectangle
         * TODO: examine, if this should be a camera-method. Current implementation is for central-projection
         */
        pointClientToProjection(_client) {
            let posRender = this.pointClientToRender(_client);
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            let rectProjection = this.camera.getProjectionRectangle();
            let posProjection = new FudgeCore.Vector2(rectProjection.width * posRender.x / rectRender.width, rectProjection.height * posRender.y / rectRender.height);
            posProjection.subtract(new FudgeCore.Vector2(rectProjection.width / 2, rectProjection.height / 2));
            posProjection.y *= -1;
            return posProjection;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToClient(_normed) {
            // let rectClient: Rectangle = this.getClientRectangle();
            // let result: Vector2 = Vector2.ONE(0.5);
            // result.x *= (_normed.x + 1) * rectClient.width;
            // result.y *= (1 - _normed.y) * rectClient.height;
            // result.add(rectClient.position);
            //TODO: check if rectDestination can safely (and more perfomant) be used instead getClientRectangle
            let pointClient = FudgeCore.Render.rectClip.pointToRect(_normed, this.rectDestination);
            return pointClient;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToCanvas(_normed) {
            let pointCanvas = FudgeCore.Render.rectClip.pointToRect(_normed, this.getCanvasRectangle());
            return pointCanvas;
        }
        /**
         * Returns a point in the browser page matching the given point of the viewport
         */
        pointClientToScreen(_client) {
            let screen = new FudgeCore.Vector2(this.#canvas.offsetLeft + _client.x, this.#canvas.offsetTop + _client.y);
            return screen;
        }
        // #endregion
        /**
         * Returns all the gizmos in the branch of this viewport that are active, filtered by {@link gizmosFilter}
         */
        getGizmos(_nodes = Array.from(this.#branch.getIterator(true))) {
            return _nodes
                .flatMap(_node => _node.getAllComponents())
                .filter(_component => _component.isActive && (_component.drawGizmos || _component.drawGizmosSelected) && this.gizmosFilter[_component.type]);
        }
    }
    FudgeCore.Viewport = Viewport;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Different xr session modes available. Could be expand with more modes in the future.
     * @authors Valentin Schmidberger, HFU, 2022 | Jonas Plotzky, HFU, 2023
     */
    let XR_SESSION_MODE;
    (function (XR_SESSION_MODE) {
        XR_SESSION_MODE["IMMERSIVE_VR"] = "immersive-vr";
        //IMMERSIVE_AR = "immersive-ar",
        //INLINE = "inline"
    })(XR_SESSION_MODE = FudgeCore.XR_SESSION_MODE || (FudgeCore.XR_SESSION_MODE = {}));
    /**
     * Different reference vr-spaces available, creator has to check if the space is supported with its device.
     * Could be expand with more available space types in the future.
     */
    let XR_REFERENCE_SPACE;
    (function (XR_REFERENCE_SPACE) {
        XR_REFERENCE_SPACE["VIEWER"] = "viewer";
        XR_REFERENCE_SPACE["LOCAL"] = "local";
        // LOCAL_FLOOR = "local-floor",
        // BOUNDED_FLOOR = "bounded-floor",
        // UNBOUNDED = "unbounded"
    })(XR_REFERENCE_SPACE = FudgeCore.XR_REFERENCE_SPACE || (FudgeCore.XR_REFERENCE_SPACE = {}));
    /**
     * XRViewport (webXR)-extension of Viewport, to displaying its branch on Head Mounted and AR (not implemted yet) Devices
     */
    class XRViewport extends FudgeCore.Viewport {
        static { this.xrViewportInstance = null; }
        // private poseMtx: Matrix4x4 = new Matrix4x4();
        constructor() {
            super();
            this.vrDevice = null;
            this.session = null;
            this.referenceSpace = null;
            this.useVRController = false;
            XRViewport.xrViewportInstance = this;
        }
        /**
         * To retrieve private static instance of xr viewport, readonly.
         */
        static get default() {
            return this.xrViewportInstance;
        }
        /**
          * Connects the viewport to the given canvas to render the given branch to using the given camera-component, and names the viewport as given.
          */
        initialize(_name, _branch, _cameraXR /* | ComponentCameraAR*/, _canvas) {
            super.initialize(_name, _branch, _cameraXR, _canvas);
        }
        /**
         * The VR Session is initialized here, also VR - Controller are initialized, if boolean is true.
         * Creator has to call FrameRequestXR after this Method to run the viewport in virtual reality.
         */
        async initializeVR(_vrSessionMode = XR_SESSION_MODE.IMMERSIVE_VR, _vrReferenceSpaceType = XR_REFERENCE_SPACE.LOCAL, _vrController = false) {
            let session = await navigator.xr.requestSession(_vrSessionMode);
            this.referenceSpace = await session.requestReferenceSpace(_vrReferenceSpaceType);
            await FudgeCore.Render.getRenderingContext().makeXRCompatible();
            let nativeScaleFactor = XRWebGLLayer.getNativeFramebufferScaleFactor(session);
            //TODO:  Field of view k√∂nnte an der Stelle noch ver√§ndert werden.
            let baseLayer = new XRWebGLLayer(session, FudgeCore.Render.getRenderingContext(), { framebufferScaleFactor: nativeScaleFactor });
            await session.updateRenderState({ baseLayer: baseLayer });
            FudgeCore.Render.setFramebufferTarget(baseLayer.framebuffer);
            FudgeCore.Render.setCanvasSize(baseLayer.framebufferWidth, baseLayer.framebufferHeight);
            FudgeCore.Render.setRenderRectangle(FudgeCore.Rectangle.GET(0, 0, baseLayer.framebufferWidth, baseLayer.framebufferHeight));
            FudgeCore.Render.adjustAttachments();
            this.adjustingFrames = false; // web xr handles this now
            this.vrDevice = this.camera;
            this.initializeReferenceSpace();
            this.useVRController = _vrController;
            if (_vrController) {
                this.vrDevice.rightCntrl.cmpTransform = new FudgeCore.ComponentTransform();
                this.vrDevice.leftCntrl.cmpTransform = new FudgeCore.ComponentTransform();
            }
            this.session = session;
            this.prepareBranch();
        }
        /**
         * The AR session could be initialized here. Up till now not implemented.
         */
        async initializeAR(_arSessionMode = null, _arReferenceSpaceType = null) {
            FudgeCore.Debug.error("NOT IMPLEMENTED YET! Check out initializeVR!");
        }
        /**
         * Draw the xr viewport displaying its branch. By default, the transforms in the branch are recalculated first.
         * Pass `false` if calculation was already done for this frame
         * Called from loop method {@link Loop} again with the xrFrame parameter handover, as soon as FRAME_REQUEST_XR is called from creator.
         */
        draw(_prepareBranch = true, _xrFrame = null) {
            if (!this.session) {
                super.draw(_prepareBranch);
                return;
            }
            let pose = _xrFrame?.getViewerPose(this.referenceSpace);
            if (!pose)
                return;
            this.vrDevice.mtxLocal.set(pose.transform.matrix);
            this.vrDevice.mtxLocal.rotateY(180); // rotate back because the XR Rig is looking in the direction of negative z
            super.prepare(_prepareBranch);
            FudgeCore.Render.resetFramebuffer();
            FudgeCore.Render.clear(this.camera.clrBackground);
            let glLayer = this.session.renderState.baseLayer;
            for (let view of pose.views) {
                let viewport = glLayer.getViewport(view);
                FudgeCore.Render.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);
                FudgeCore.Render.setScissorTest(true, viewport.x, viewport.y, viewport.width, viewport.height);
                if (this.useVRController)
                    this.setControllerConfigs(_xrFrame);
                this.camera.resetWorldToView(); // TODO: find a less expensive way to do this, maybe use two cameras
                this.camera.mtxProjection.set(view.projectionMatrix);
                this.camera.mtxCameraInverse.set(view.transform.inverse.matrix);
                if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.PHYSIC_OBJECTS_ONLY)
                    FudgeCore.Render.draw(this.camera);
                if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.NONE)
                    FudgeCore.Physics.draw(this.camera, this.physicsDebugMode);
            }
            // reset for other render operations e.g. picking
            FudgeCore.Render.setScissorTest(false);
            FudgeCore.Render.setRenderRectangle(FudgeCore.Render.getRenderRectangle());
        }
        /**
         * Move the reference space to set the initial position/orientation of the vr device in accordance to the node the vr device is attached to.
         */
        initializeReferenceSpace() {
            let mtxWorld = this.vrDevice.node?.getComponent(FudgeCore.ComponentVRDevice)?.mtxWorld;
            if (!mtxWorld)
                return;
            mtxWorld = mtxWorld.clone;
            mtxWorld.rotateY(180); // rotate because the XR Rig is looking in the direction of negative z
            let invMtxTransfom = FudgeCore.Matrix4x4.INVERSE(mtxWorld); // inverse because we are moving the reference space
            XRViewport.default.referenceSpace = XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(invMtxTransfom.translation, invMtxTransfom.quaternion));
        }
        //Sets controller matrices and thumbsticks movements.
        setControllerConfigs(_xrFrame) {
            if (_xrFrame) {
                if (XRViewport.default.session.inputSources.length > 0) {
                    XRViewport.default.session.inputSources.forEach(_controller => {
                        try {
                            switch (_controller.handedness) {
                                case ("right"):
                                    this.vrDevice.rightCntrl.cmpTransform.mtxLocal.set(_xrFrame.getPose(_controller.targetRaySpace, XRViewport.default.referenceSpace).transform.matrix);
                                    if (!this.vrDevice.rightCntrl.gamePad)
                                        this.vrDevice.rightCntrl.gamePad = _controller.gamepad;
                                    else {
                                        this.vrDevice.rightCntrl.thumbstickX = _controller.gamepad.axes[2];
                                        this.vrDevice.rightCntrl.thumbstickY = _controller.gamepad.axes[3];
                                    }
                                    break;
                                case ("left"):
                                    this.vrDevice.leftCntrl.cmpTransform.mtxLocal.set(_xrFrame.getPose(_controller.targetRaySpace, XRViewport.default.referenceSpace).transform.matrix);
                                    if (!this.vrDevice.leftCntrl.gamePad)
                                        this.vrDevice.leftCntrl.gamePad = _controller.gamepad;
                                    else {
                                        this.vrDevice.leftCntrl.thumbstickX = _controller.gamepad.axes[2];
                                        this.vrDevice.leftCntrl.thumbstickY = _controller.gamepad.axes[3];
                                    }
                                    break;
                            }
                        }
                        catch (e) {
                            FudgeCore.Debug.error("Input Sources Error: " + e);
                        }
                    });
                }
            }
        }
    }
    FudgeCore.XRViewport = XRViewport;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles file transfer from a FUDGE-Browserapp to the local filesystem without a local server.
     * Saves to the download-path given by the browser, loads from the player's choice.
     */
    class FileIoBrowserLocal extends FudgeCore.EventTargetStatic {
        // TODO: refactor to async function to be handled using promise, instead of using event target
        /**
         * Open file select dialog to load files from local filesystem into browser application.
         */
        static async load(_multiple = false) {
            FileIoBrowserLocal.selector = document.createElement("input");
            FileIoBrowserLocal.selector.type = "file";
            FileIoBrowserLocal.selector.multiple = _multiple;
            FileIoBrowserLocal.selector.hidden = true;
            FileIoBrowserLocal.selector.addEventListener("change", FileIoBrowserLocal.handleFileSelect);
            document.body.appendChild(FileIoBrowserLocal.selector);
            return new Promise(_resolve => {
                function hndLoaded(_event) {
                    FileIoBrowserLocal.removeEventListener("fileLoaded" /* EVENT.FILE_LOADED */, hndLoaded);
                    _resolve(_event.detail.mapFilenameToContent);
                }
                FileIoBrowserLocal.addEventListener("fileLoaded" /* EVENT.FILE_LOADED */, hndLoaded);
                FileIoBrowserLocal.selector.click();
            });
        }
        // TODO: refactor to async function to be handled using promise, instead of using event target
        /**
         * Open a file download dialog to save files to local filesystem.
         */
        static save(_toSave, _type = "text/plain") {
            for (let filename in _toSave) {
                let content = _toSave[filename];
                let blob = new Blob([content], { type: _type });
                let url = window.URL.createObjectURL(blob);
                //*/ using anchor element for download
                let downloader;
                downloader = document.createElement("a");
                downloader.setAttribute("href", url);
                downloader.setAttribute("download", filename);
                document.body.appendChild(downloader);
                downloader.click();
                document.body.removeChild(downloader);
                window.URL.revokeObjectURL(url);
            }
            return new Promise(_resolve => {
                _resolve(_toSave);
                // function hndSaved(_event: Event): void {
                //   FileIoBrowserLocal.removeEventListener(EVENT.FILE_SAVED, hndSaved);
                //   _resolve((<CustomEvent>_event).detail);
                // }
                // FileIoBrowserLocal.addEventListener(EVENT.FILE_SAVED, hndSaved);
                // let event: CustomEvent = new CustomEvent(EVENT.FILE_SAVED, { detail: { mapFilenameToContent: _toSave } });
                // FileIoBrowserLocal.targetStatic.dispatchEvent(event);
            });
        }
        /**
         * Load the the files referenced in {@link FileList} into the provided {@link MapFilenameToContent}
         */
        static async loadFiles(_fileList, _loaded) {
            for (let file of _fileList) {
                const content = await new Response(file).text();
                _loaded[file.name] = content;
            }
        }
        static async handleFileSelect(_event) {
            FudgeCore.Debug.fudge("-------------------------------- handleFileSelect");
            document.body.removeChild(FileIoBrowserLocal.selector);
            let fileList = _event.target.files;
            FudgeCore.Debug.fudge(fileList, fileList.length);
            if (fileList.length == 0)
                return;
            let loaded = {};
            await FileIoBrowserLocal.loadFiles(fileList, loaded);
            let event = new CustomEvent("fileLoaded" /* EVENT.FILE_LOADED */, { detail: { mapFilenameToContent: loaded } });
            FileIoBrowserLocal.targetStatic.dispatchEvent(event);
        }
    }
    FudgeCore.FileIoBrowserLocal = FileIoBrowserLocal;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Mutable array of {@link Mutable}s. The {@link Mutator}s of the entries are included as array in the {@link Mutator}
     * @author Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class MutableArray extends Array {
        #type;
        constructor(_type, ..._args) {
            super(..._args);
            this.#type = _type;
        }
        get type() {
            return this.#type;
        }
        /**
         * Rearrange the entries of the array according to the given sequence of indices
         */
        rearrange(_sequence) {
            let length = this.length;
            for (let index of _sequence) {
                let original = this[index];
                // TODO: optimize, copy only double entries
                //@ts-ignore
                let copy = new original.constructor();
                copy.mutate(original.getMutator());
                this.push(copy);
            }
            this.splice(0, length);
        }
        /**
         * Returns an associative array with this arrays elements corresponding types as string-values
         */
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            for (let entry in this)
                types[entry] = this[entry].constructor.name;
            return types;
        }
        /**
         * Returns an array with each elements mutator by invoking {@link Mutable.getMutator} on them
         */
        getMutator() {
            return this.map((_value) => _value.getMutator());
        }
        /**
         * See {@link Mutable.getMutatorForUserInterface}
         */
        getMutatorForUserInterface() {
            return this.getMutator();
        }
        /**
         * Mutate the elements of this array defined by the _mutator by invoking {@link Mutable.mutate} on it
         */
        async mutate(_mutator) {
            for (let entry in _mutator)
                await this[entry].mutate(_mutator[entry]);
        }
        /**
         * Updates the values of the given mutator according to the current state of the instance
         */
        updateMutator(_mutator) {
            for (let entry in this) {
                let mutatorValue = _mutator[entry];
                if (!mutatorValue)
                    continue;
                if (this[entry] instanceof FudgeCore.Mutable)
                    _mutator[entry] = this[entry].getMutator();
                else
                    _mutator[entry] = this[entry];
            }
        }
    }
    FudgeCore.MutableArray = MutableArray;
})(FudgeCore || (FudgeCore = {}));
var FBX;
(function (FBX) {
    /**
     * Reader to read data from an array buffer more conveniently.
     * It saves a current offset which is updated when data is read due to its bytelength.
     * despite getSequence it is mostly a copy of the reference: https://github.com/picode7/binary-reader
     * @author Matthias Roming, HFU, 2023
     */
    class BufferReader {
        constructor(_buffer) {
            this.view = new DataView(_buffer);
            this.offset = 0;
        }
        getChar(_offset = this.offset) {
            return String.fromCharCode(this.getUint8(_offset));
        }
        getBool(_offset = this.offset) {
            return this.getUint8(_offset) != 0;
        }
        getUint8(_offset = this.offset) {
            this.offset = _offset + 1;
            return this.view.getUint8(_offset);
        }
        getUint32(_offset = this.offset) {
            this.offset = _offset + 4;
            return this.view.getUint32(_offset, true);
        }
        getUint64(_offset = this.offset) {
            this.offset = _offset + 8;
            return this.view.getBigUint64(_offset, true);
        }
        getInt16(_offset = this.offset) {
            this.offset = _offset + 2;
            return this.view.getInt16(_offset, true);
        }
        getInt32(_offset = this.offset) {
            this.offset = _offset + 4;
            return this.view.getInt32(_offset, true);
        }
        getInt64(_offset = this.offset) {
            this.offset = _offset + 8;
            return this.view.getBigInt64(_offset, true);
        }
        getFloat32(_offset = this.offset) {
            this.offset = _offset + 4;
            return this.view.getFloat32(_offset, true);
        }
        getFloat64(_offset = this.offset) {
            this.offset = _offset + 8;
            return this.view.getFloat64(_offset, true);
        }
        getString(_length, _offset = this.offset) {
            return String.fromCharCode(...this.getSequence(this.getUint8, _length, _offset));
        }
        *getSequence(_getter, _length, _offset = this.offset) {
            this.offset = _offset;
            for (let i = 0; i < _length; i++) {
                yield _getter.call(this);
            }
        }
    }
    FBX.BufferReader = BufferReader;
})(FBX || (FBX = {}));
var FBX;
(function (FBX) {
    let MAPPING_INFORMATION_TYPE;
    (function (MAPPING_INFORMATION_TYPE) {
        MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["BY_VERTEX"] = 0] = "BY_VERTEX";
        MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["BY_POLYGON"] = 1] = "BY_POLYGON";
        MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["BY_POLYGON_VERTEX"] = 2] = "BY_POLYGON_VERTEX";
        MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["BY_EDGE"] = 3] = "BY_EDGE";
        MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["ALL_SAME"] = 4] = "ALL_SAME";
    })(MAPPING_INFORMATION_TYPE = FBX.MAPPING_INFORMATION_TYPE || (FBX.MAPPING_INFORMATION_TYPE = {}));
    let REFERENCE_INFORMATION_TYPE;
    (function (REFERENCE_INFORMATION_TYPE) {
        REFERENCE_INFORMATION_TYPE[REFERENCE_INFORMATION_TYPE["DIRECT"] = 0] = "DIRECT";
        REFERENCE_INFORMATION_TYPE[REFERENCE_INFORMATION_TYPE["INDEX_TO_DIRECT"] = 1] = "INDEX_TO_DIRECT";
    })(REFERENCE_INFORMATION_TYPE = FBX.REFERENCE_INFORMATION_TYPE || (FBX.REFERENCE_INFORMATION_TYPE = {}));
})(FBX || (FBX = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Asset loader for Filmbox files.
     * @author Matthias Roming, HFU, 2023
     */
    class FBXLoader {
        static #defaultMaterial;
        static #defaultSkinMaterial;
        #scenes;
        #nodes;
        #meshes;
        #materials;
        #skinMaterials = [];
        #textures;
        #skeletons;
        #animations;
        constructor(_buffer, _uri) {
            this.uri = _uri;
            this.nodes = FBX.parseNodesFromBinary(_buffer);
            FudgeCore.Debug.log(this.nodes);
            this.fbx = FBX.loadFromNodes(this.nodes);
            FudgeCore.Debug.log(this.fbx);
        }
        static get defaultMaterial() {
            return this.#defaultMaterial || (this.#defaultMaterial =
                new FudgeCore.Material("FBXDefaultMaterial", FudgeCore.ShaderGouraud, new FudgeCore.CoatRemissive(FudgeCore.Color.CSS("white"))));
        }
        static get defaultSkinMaterial() {
            return this.#defaultSkinMaterial || (this.#defaultSkinMaterial =
                new FudgeCore.Material("FBXDefaultSkinMaterial", FudgeCore.ShaderGouraudSkin, new FudgeCore.CoatRemissive(FudgeCore.Color.CSS("white"))));
        }
        static async LOAD(_uri) {
            if (!this.loaders)
                this.loaders = {};
            if (!this.loaders[_uri]) {
                const response = await fetch(_uri);
                const binary = await response.arrayBuffer();
                this.loaders[_uri] = new FBXLoader(binary, _uri);
            }
            return this.loaders[_uri];
        }
        async getScene(_index = 0) {
            if (!this.#scenes)
                this.#scenes = [];
            if (!this.#scenes[_index]) {
                const documentFBX = this.fbx.documents[_index].load();
                const scene = new FudgeCore.Graph(documentFBX.name);
                for (const childFBX of documentFBX.children) {
                    if (childFBX.type == "Model") {
                        scene.addChild(await this.getNode(this.fbx.objects.models.indexOf(childFBX)));
                    }
                }
                if (this.fbx.objects.animStacks && this.fbx.objects.animStacks.length > 0) {
                    const animation = await this.getAnimation(documentFBX.ActiveAnimStackName.length > 0 ?
                        this.fbx.objects.animStacks.findIndex(_animStack => _animStack.name == documentFBX.ActiveAnimStackName) : 0);
                    if (animation)
                        scene.addComponent(new FudgeCore.ComponentAnimation(animation));
                }
                for (const skeleton of this.#skeletons)
                    scene.addComponent(skeleton);
                FudgeCore.Project.register(scene);
                this.#scenes[_index] = scene;
            }
            return this.#scenes[_index];
        }
        async getNode(_index) {
            if (!this.#nodes)
                this.#nodes = [];
            if (!this.#nodes[_index]) {
                // create node with transform
                const modelFBX = this.fbx.objects.models[_index].load();
                const node = new FudgeCore.Node(modelFBX.name);
                await this.generateTransform(modelFBX, node);
                this.#nodes[_index] = node;
                // attach children and components
                if (modelFBX.children)
                    for (const childFBX of modelFBX.children) {
                        if (childFBX.type == "Model") {
                            node.addChild(await this.getNode(this.fbx.objects.models.indexOf(childFBX)));
                        }
                        else if (childFBX.type == "Geometry") {
                            const mesh = await this.getMesh(this.fbx.objects.geometries.indexOf(childFBX));
                            const cmpMesh = new FudgeCore.ComponentMesh(mesh);
                            node.addComponent(new FudgeCore.ComponentMaterial(FBXLoader.defaultMaterial));
                            if (mesh.renderMesh.bones) {
                                cmpMesh.skeleton = await this.getSkeleton(childFBX.children[0].children[0].children[0]);
                                // for (const subDeformerFBX of childFBX.children[0].children as FBX.SubDeformer[]) {
                                //   const bone: Node = cmpMesh.skeleton.bones[subDeformerFBX.children[0].name];
                                //   bone.mtxLocal.set(subDeformerFBX.TransformLink);
                                //   if (bone.getParent())
                                //     bone.mtxLocal.multiply(bone.getParent().mtxWorldInverse);
                                // }
                                node.getComponent(FudgeCore.ComponentMaterial).material = FBXLoader.defaultSkinMaterial;
                            }
                            node.addComponent(cmpMesh);
                        }
                        else if (childFBX.type == "Material") {
                            // TODO: additional skin materials get created here, check if the original material is still needed
                            const iMaterial = this.fbx.objects.materials.indexOf(childFBX);
                            const material = await this.getMaterial(iMaterial);
                            node.getComponent(FudgeCore.ComponentMaterial).material = node.getComponent(FudgeCore.ComponentMesh).mesh.renderMesh.bones ?
                                this.#skinMaterials[iMaterial] || (this.#skinMaterials[iMaterial] = new FudgeCore.Material(material.name, material.getShader() == FudgeCore.ShaderPhong ?
                                    FudgeCore.ShaderPhongSkin :
                                    FudgeCore.ShaderPhongTexturedSkin, material.coat)) :
                                material;
                        }
                    }
            }
            return this.#nodes[_index];
        }
        async getMesh(_index) {
            if (!this.#meshes)
                this.#meshes = [];
            if (!this.#meshes[_index])
                this.#meshes[_index] = await new FudgeCore.MeshFBX().load(this.uri, _index);
            return this.#meshes[_index];
        }
        async getMaterial(_index) {
            if (!this.#materials)
                this.#materials = [];
            if (!this.#materials[_index]) {
                const materialFBX = this.fbx.objects.materials[_index].load();
                if (!(materialFBX.DiffuseColor instanceof FudgeCore.Vector3))
                    materialFBX.DiffuseColor?.children[0].load();
                // FBX supports lambert and phong shading, either way fudge has no lambert shader so we always use phong.
                // In DiffuseColor the texture of the material color is stored, if it's defined we use a texture shader.
                // TODO: materialFBX also contains additional values like shininess and reflectivity (and others) which are not suppported.
                this.#materials[_index] = new FudgeCore.Material(materialFBX.name, materialFBX.DiffuseColor && !(materialFBX.DiffuseColor instanceof FudgeCore.Vector3) ?
                    FudgeCore.ShaderPhongTextured :
                    FudgeCore.ShaderPhong, materialFBX.DiffuseColor && !(materialFBX.DiffuseColor instanceof FudgeCore.Vector3) ?
                    new FudgeCore.CoatRemissiveTextured(new FudgeCore.Color(...materialFBX.Diffuse.get()), await this.getTexture(this.fbx.objects.textures.indexOf(materialFBX.DiffuseColor)), materialFBX.DiffuseFactor ?? 1, materialFBX.SpecularFactor ?? average(materialFBX.Specular?.get()) ?? 0) :
                    new FudgeCore.CoatRemissive(new FudgeCore.Color(...(materialFBX.DiffuseColor ?? materialFBX.Diffuse).get()), materialFBX.DiffuseFactor ?? 1, materialFBX.SpecularFactor ?? average(materialFBX.Specular?.get()) ?? 0));
            }
            return this.#materials[_index];
            function average(_array) {
                if (_array)
                    return _array.reduce((_a, _b) => _a + _b) / _array.length;
                else
                    return undefined;
            }
        }
        async getTexture(_index) {
            return new Promise((_resolve, _reject) => {
                if (!this.#textures)
                    this.#textures = [];
                if (this.#textures[_index])
                    return _resolve(this.#textures[_index]);
                const videoFBX = this.fbx.objects.textures[_index].children[0];
                const texture = new FudgeCore.TextureImage();
                texture.image = new Image();
                texture.image.onload = () => _resolve(texture);
                texture.image.onerror = _reject;
                texture.image.src = URL.createObjectURL(new Blob([videoFBX.Content], { type: "image/png" }));
                this.#textures[_index] = texture;
                // TODO: get and set mipmap information ???
            });
        }
        // Problem: mehrere Deformer verweisen auf das selbe Skelett aber nutzen dabei nicht immer alle Knochen
        // => Problem besteht auch im GLTFLoader
        /**
         * Retriefs the skeleton containing the given limb node.
         */
        async getSkeleton(_fbxLimbNode) {
            if (!this.#skeletons)
                this.#skeletons = [];
            return this.#skeletons.find(_skeleton => _fbxLimbNode.name in _skeleton.bones) || await (async () => {
                const skeleton = new FudgeCore.ComponentSkeleton(); // new Skeleton(`Skeleton${this.#skeletons.length}`);
                let rootNode = _fbxLimbNode;
                while (rootNode.parents && rootNode.parents.some(_parent => _parent.subtype == "LimbNode"))
                    rootNode = rootNode.parents.find(_parent => _parent.subtype == "LimbNode");
                const iRootNode = this.fbx.objects.models.findIndex(_model => _model.name == rootNode.name);
                for (const node of await this.getNode(iRootNode)) {
                    // TODO: maybe move this into the component, as this is probably needed in gltf import aswell
                    if (this.fbx.objects.models[this.#nodes.indexOf(node)].subtype == "LimbNode") {
                        const parent = node.getParent();
                        if (parent)
                            node.mtxWorld.copy(node.cmpTransform ?
                                FudgeCore.Matrix4x4.PRODUCT(parent.mtxWorld, node.mtxLocal) :
                                parent.mtxWorld);
                        node.mtxWorldInverse.copy(FudgeCore.Matrix4x4.INVERSE(node.mtxWorld));
                        skeleton.addBone(node);
                    }
                }
                this.#skeletons.push(skeleton);
                return skeleton;
            })();
        }
        async getAnimation(_index) {
            if (!this.#animations)
                this.#animations = [];
            if (!this.#animations[_index]) {
                const animStack = this.fbx.objects.animStacks[_index];
                const animNodesFBX = animStack.children[0].children;
                let fbxAnimNodeGrouped = new Map();
                for (const fbxAnimNode of animNodesFBX) {
                    const key = fbxAnimNode.parents.find(_parent => _parent.type == "Model");
                    if (key == undefined)
                        continue;
                    if (!fbxAnimNodeGrouped.has(key))
                        fbxAnimNodeGrouped.set(key, []);
                    fbxAnimNodeGrouped.get(key).push(fbxAnimNode);
                }
                const animationStructure = {};
                for (const [fbxModel, fbxAnimNodes] of fbxAnimNodeGrouped) {
                    let currentStructure = animationStructure;
                    let parent = fbxModel.parents.find(_parent => _parent.type == "Model");
                    let path = [];
                    path.push(fbxModel);
                    while (parent != undefined) {
                        path.push(parent);
                        parent = parent.parents.find(_parent => _parent.type == "Model");
                    }
                    for (const fbxPathModel of path.reverse()) {
                        if (currentStructure.children == undefined)
                            currentStructure.children = {};
                        if (currentStructure.children[fbxPathModel.name] == undefined)
                            currentStructure.children[fbxPathModel.name] = {};
                        currentStructure = currentStructure.children[fbxPathModel.name];
                        if (fbxPathModel == fbxModel) {
                            const mtxLocal = {};
                            for (const fbxAnimNode of fbxAnimNodes)
                                mtxLocal[{
                                    T: "translation",
                                    R: "rotation",
                                    S: "scale"
                                }[fbxAnimNode.name]] = this.getAnimationVector3(fbxAnimNode, fbxPathModel);
                            currentStructure.components = {
                                ComponentTransform: [
                                    { mtxLocal: mtxLocal }
                                ]
                            };
                        }
                    }
                }
                this.#animations[_index] = new FudgeCore.Animation(animStack.name, animationStructure);
            }
            return this.#animations[_index];
        }
        /**
         * fetched from three.js, adapted to FUDGE and optimized
         * https://github.com/mrdoob/three.js/blob/dev/examples/jsm/loaders/FBXLoader.js
         * line 3950
         */
        async generateTransform(_modelFBX, _node) {
            const parentIndex = this.fbx.objects.models.indexOf(_modelFBX.parents.find(_parent => _parent.type == "Model"));
            const parent = parentIndex >= 0 ? await this.getNode(parentIndex) : undefined;
            const mtxLocalRotation = _modelFBX.PreRotation || _modelFBX.LclRotation || _modelFBX.PostRotation ?
                FudgeCore.Matrix4x4.IDENTITY() :
                undefined;
            if (_modelFBX.PreRotation) {
                mtxLocalRotation.rotate(this.getOrdered(_modelFBX.PreRotation, _modelFBX));
            }
            if (_modelFBX.LclRotation) {
                mtxLocalRotation.rotate(this.getOrdered(this.getTransformVector(_modelFBX.LclRotation, FudgeCore.Vector3.ZERO), _modelFBX));
            }
            if (_modelFBX.PostRotation) {
                let mtxPostRotationInverse = FudgeCore.Matrix4x4.ROTATION(this.getOrdered(_modelFBX.PostRotation, _modelFBX));
                mtxPostRotationInverse = FudgeCore.Matrix4x4.INVERSE(mtxPostRotationInverse);
                mtxLocalRotation.multiply(mtxPostRotationInverse);
            }
            const mtxLocalScaling = _modelFBX.LclScaling ?
                FudgeCore.Matrix4x4.SCALING(this.getTransformVector(_modelFBX.LclScaling, FudgeCore.Vector3.ONE)) :
                undefined;
            const mtxParentWorldRotation = parent ? FudgeCore.Matrix4x4.ROTATION(parent.mtxWorld.rotation) : undefined;
            const mtxParentWorldScale = parent ? (() => {
                const mtxParentWorldScale = FudgeCore.Matrix4x4.INVERSE(mtxParentWorldRotation);
                mtxParentWorldScale.translate(FudgeCore.Vector3.SCALE(parent.mtxWorld.translation, -1));
                mtxParentWorldScale.multiply(parent.mtxWorld);
                return mtxParentWorldScale;
            })() : undefined;
            const mtxWorldRotationScale = parent || mtxLocalRotation || mtxLocalScaling ? FudgeCore.Matrix4x4.IDENTITY() : undefined;
            if (parent || mtxLocalRotation || mtxLocalScaling) {
                const inheritType = _modelFBX.InheritType || 0;
                if (inheritType == 0) {
                    if (parent)
                        mtxWorldRotationScale.multiply(mtxParentWorldRotation);
                    if (mtxLocalRotation)
                        mtxWorldRotationScale.multiply(mtxLocalRotation);
                    if (parent)
                        mtxWorldRotationScale.multiply(mtxParentWorldScale);
                    if (mtxLocalScaling)
                        mtxWorldRotationScale.multiply(mtxLocalScaling);
                }
                else if (inheritType == 1) {
                    if (parent) {
                        mtxWorldRotationScale.multiply(mtxParentWorldRotation);
                        mtxWorldRotationScale.multiply(mtxParentWorldScale);
                    }
                    if (mtxLocalRotation)
                        mtxWorldRotationScale.multiply(mtxLocalRotation);
                    if (mtxLocalScaling)
                        mtxWorldRotationScale.multiply(mtxLocalScaling);
                }
                else {
                    if (parent)
                        mtxWorldRotationScale.multiply(mtxParentWorldRotation);
                    if (mtxLocalRotation)
                        mtxWorldRotationScale.multiply(mtxLocalRotation);
                    if (parent) {
                        mtxWorldRotationScale.multiply(mtxParentWorldScale);
                        let mtxParentLocalScalingInverse = FudgeCore.Matrix4x4.SCALING(parent.mtxLocal.scaling);
                        mtxParentLocalScalingInverse = FudgeCore.Matrix4x4.INVERSE(mtxParentLocalScalingInverse);
                        mtxWorldRotationScale.multiply(mtxParentLocalScalingInverse);
                    }
                    if (mtxLocalScaling)
                        mtxWorldRotationScale.multiply(mtxLocalScaling);
                }
            }
            // Calculate the local transform matrix
            let translation;
            translation = FudgeCore.Vector3.ZERO();
            if (_modelFBX.LclTranslation)
                translation.add(this.getTransformVector(_modelFBX.LclTranslation, FudgeCore.Vector3.ZERO));
            if (_modelFBX.RotationOffset)
                translation.add(_modelFBX.RotationOffset);
            if (_modelFBX.RotationPivot)
                translation.add(_modelFBX.RotationPivot);
            const mtxTransform = FudgeCore.Matrix4x4.TRANSLATION(translation);
            if (mtxLocalRotation)
                mtxTransform.multiply(mtxLocalRotation);
            translation = FudgeCore.Vector3.ZERO();
            if (_modelFBX.RotationPivot)
                translation.subtract(_modelFBX.RotationPivot);
            if (_modelFBX.ScalingOffset)
                translation.add(_modelFBX.ScalingOffset);
            if (_modelFBX.ScalingPivot)
                translation.add(_modelFBX.ScalingPivot);
            mtxTransform.translate(translation);
            if (mtxLocalScaling)
                mtxTransform.multiply(mtxLocalScaling);
            if (_modelFBX.ScalingPivot)
                mtxTransform.translate(FudgeCore.Vector3.SCALE(_modelFBX.ScalingPivot, -1));
            const mtxWorldTranslation = parent ?
                FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Matrix4x4.PRODUCT(parent.mtxWorld, FudgeCore.Matrix4x4.TRANSLATION(mtxTransform.translation)).translation) :
                FudgeCore.Matrix4x4.TRANSLATION(mtxTransform.translation);
            mtxTransform.copy(mtxWorldTranslation);
            mtxTransform.multiply(mtxWorldRotationScale);
            _node.mtxWorld.copy(mtxTransform);
            if (parent)
                mtxTransform.multiply(FudgeCore.Matrix4x4.INVERSE(parent.mtxWorld), true);
            _node.addComponent(new FudgeCore.ComponentTransform(mtxTransform));
        }
        getTransformVector(_vector, _default) {
            return (_vector == undefined ?
                _default() :
                _vector instanceof FudgeCore.Vector3 ?
                    _vector :
                    new FudgeCore.Vector3(typeof (_vector = _vector.load()).dX == "number" ?
                        _vector.dX :
                        _vector.dX.load().Default, typeof _vector.dY == "number" ?
                        _vector.dY :
                        _vector.dY.load().Default, typeof _vector.dZ == "number" ?
                        _vector.dZ :
                        _vector.dZ.load().Default));
        }
        getAnimationVector3(_animNode, _target) {
            const vectorSequence = {};
            for (const valueName in _animNode)
                if (valueName == "dX" || valueName == "dY" || valueName == "dZ") {
                    const value = _animNode[valueName];
                    if (typeof value != "number") {
                        const sequence = new FudgeCore.AnimationSequence();
                        for (let i = 0; i < value.KeyTime.length; ++i) {
                            // According to the reference time is defined as a signed int64, unit being 1/46186158000 seconds
                            // ref: https://archive.blender.org/wiki/index.php/User:Mont29/Foundation/FBX_File_Structure/#Some_Specific_Property_Types
                            sequence.addKey(new FudgeCore.AnimationKey(Number((value.KeyTime[i] - value.KeyTime.reduce((_min, _v) => _v < _min ? _v : _min)) / BigInt("46186158")), value.KeyValueFloat[i]));
                        }
                        vectorSequence[valueName[1].toLowerCase()] = sequence;
                    }
                }
            if (_animNode.name == "R" && (_target.PreRotation || _target.PostRotation)) {
                let preRototation;
                if (_target.PreRotation)
                    preRototation = FudgeCore.Matrix4x4.ROTATION(_target.PreRotation);
                let postRotation;
                if (_target.PostRotation)
                    postRotation = FudgeCore.Matrix4x4.ROTATION(_target.PostRotation);
                [vectorSequence.x, vectorSequence.y, vectorSequence.z]
                    .flatMap(_seq => _seq?.getKeys())
                    .map(_key => _key?.time)
                    .sort((_timeA, _timeB) => _timeA - _timeB) // sort times
                    .filter((_time, _index, _times) => _time != _times[_index + 1]) // remove duplicates
                    .map(_time => {
                    return { x: findKey(vectorSequence.x), y: findKey(vectorSequence.y), z: findKey(vectorSequence.z) };
                    function findKey(_sequence) {
                        return _sequence?.getKeys().find(_key => _key.time == _time);
                    }
                })
                    .forEach(_frame => {
                    let vctEulerAngles = FudgeCore.Recycler.get(FudgeCore.Vector3);
                    vctEulerAngles.set(_frame.x?.value ?? 0, _frame.y?.value ?? 0, _frame.z?.value ?? 0);
                    const mtxRotation = FudgeCore.Matrix4x4.ROTATION(vctEulerAngles);
                    if (preRototation)
                        mtxRotation.multiply(preRototation, true);
                    if (postRotation)
                        mtxRotation.multiply(postRotation);
                    vctEulerAngles = mtxRotation.rotation;
                    if (_frame.x)
                        _frame.x.value = vctEulerAngles.x;
                    if (_frame.y)
                        _frame.y.value = vctEulerAngles.y;
                    if (_frame.z)
                        _frame.z.value = vctEulerAngles.z;
                });
            }
            return vectorSequence;
        }
        getOrdered(_rotation, _modelFBX) {
            if (!_modelFBX.EulerOrder)
                return _rotation;
            const data = _rotation.get();
            const result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(data[_modelFBX.EulerOrder.indexOf("Z")], data[_modelFBX.EulerOrder.indexOf("Y")], data[_modelFBX.EulerOrder.indexOf("X")]);
            return result;
        }
    }
    FudgeCore.FBXLoader = FBXLoader;
})(FudgeCore || (FudgeCore = {}));
var FBX;
(function (FBX) {
    /**
     * Interface to represent fbx-nodes containing its name, children and properties.
     * Children and properites are lazy.
     * @author Matthias Roming, HFU, 2023
     */
    class Node {
        #children;
        #properties;
        constructor(_name, _loadProperties, _loadChildren) {
            this.name = _name;
            this.loadProperties = _loadProperties;
            this.loadChildren = _loadChildren;
        }
        get properties() {
            return this.#properties || (this.#properties = this.loadProperties());
        }
        get children() {
            return this.#children || (this.#children = this.loadChildren());
        }
    }
    FBX.Node = Node;
    let ARRAY_ENCODING;
    (function (ARRAY_ENCODING) {
        ARRAY_ENCODING[ARRAY_ENCODING["UNCOMPRESSED"] = 0] = "UNCOMPRESSED";
        ARRAY_ENCODING[ARRAY_ENCODING["COMPRESSED"] = 1] = "COMPRESSED";
    })(ARRAY_ENCODING = FBX.ARRAY_ENCODING || (FBX.ARRAY_ENCODING = {}));
})(FBX || (FBX = {}));
var FBX;
(function (FBX) {
    /**
     * Loads an fbx file from its fbx-node array which may be retrieved by parseNodesFromBinary.
     * @author Matthias Roming, HFU, 2023
     */
    function loadFromNodes(_nodes) {
        const fbx = {
            documents: undefined,
            objects: {
                all: undefined,
                models: [],
                geometries: [],
                materials: [],
                poses: [],
                textures: [],
                animStacks: []
            },
            connections: undefined
        };
        for (const node of _nodes) {
            if (node.name == "Documents")
                fbx.documents = node.children
                    .filter(_documentNode => _documentNode.name == "Document")
                    .map(_documentNode => getDocument(_documentNode));
            else if (node.name == "Objects")
                fbx.objects.all = node.children.map(_objectNode => getObject(_objectNode, fbx));
            else if (node.name == "Connections")
                fbx.connections = node.children.map(_connectionNode => getConnection(_connectionNode));
            if (fbx.documents && fbx.objects.all && fbx.connections)
                break;
        }
        groupObjects(fbx);
        applyConnections(fbx.connections, fbx.documents, fbx.objects.all);
        return fbx;
    }
    FBX.loadFromNodes = loadFromNodes;
    function getDocument(_node) {
        const document = {
            uid: _node.properties[0],
            name: _node.properties[2],
            loaded: false,
            load: () => loadObjectProperties(_node, document)
        };
        return document;
    }
    function getObject(_node, _fbx) {
        const nameAndType = _node.properties[1].split("::");
        const object = {
            uid: _node.properties[0],
            name: nameAndType[0],
            type: nameAndType[1],
            subtype: _node.properties[2],
            loaded: false,
            load: () => loadObjectProperties(_node, object)
        };
        return object;
    }
    function groupObjects(_fbx) {
        for (const object of _fbx.objects.all) {
            if (object.type == "Model")
                _fbx.objects.models.push(object);
            else if (object.type == "Geometry")
                _fbx.objects.geometries.push(object);
            else if (object.type == "Material")
                _fbx.objects.materials.push(object);
            else if (object.type == "Pose")
                _fbx.objects.poses.push(object);
            else if (object.type == "Texture")
                _fbx.objects.textures.push(object);
            else if (object.type == "AnimStack")
                _fbx.objects.animStacks.push(object);
        }
    }
    function getConnection(_node) {
        if (!(_node.properties[0] == "OO" || _node.properties[0] == "OP")) {
            console.warn(`Connection type ${_node.properties[0]} is not supported`);
            return null;
        }
        return {
            childUID: _node.properties[1],
            parentUID: _node.properties[2],
            propertyName: _node.properties[0] == "OP" ? _node.properties[3] : null
        };
    }
    function applyConnections(_connections, _documents, _objects) {
        for (const connection of _connections) {
            let parent = _documents.find(_document => _document.load().RootNode == connection.parentUID);
            let child;
            for (const object of _objects) {
                if (parent == undefined && object.uid == connection.parentUID)
                    parent = object;
                if (child == undefined && object.uid == connection.childUID)
                    child = object;
                if (parent != undefined && child != undefined)
                    break;
            }
            if (child)
                (child.parents || (child.parents = [])).push(parent);
            if (connection.propertyName == null)
                (parent.children || (parent.children = [])).push(child);
            else
                parent[formatPropertyName(connection.propertyName)] = child;
        }
    }
    function loadObjectProperties(_node, _object) {
        if (_object.loaded)
            return _object;
        for (const child of _node.children) {
            if (child.name == "Properties70")
                for (const property70 of child.children) {
                    const name = formatPropertyName(property70.properties[0]);
                    if (!_object[name])
                        _object[name] = getProperty70Value(property70);
                }
            else {
                const name = formatPropertyName(child.name);
                if (!_object[name])
                    _object[name] = getPropertyValue(child);
            }
        }
        _object.loaded = true;
        return _object;
    }
    function getPropertyValue(_node) {
        return _node.children.length > 0
            ? _node.children.reduce((_subProperties, _subProperty) => {
                const name = formatPropertyName(_subProperty.name);
                if (_subProperties[name] == undefined)
                    _subProperties[name] = getPropertyValue(_subProperty);
                else {
                    if (!(_subProperties[name] instanceof Array))
                        _subProperties[name] = [_subProperties[name]];
                    _subProperties[name].push(getPropertyValue(_subProperty));
                }
                return _subProperties;
            }, {})
            : _node.properties[0];
    }
    function getProperty70Value(_node) {
        switch (_node.properties[1]) {
            case "bool":
                return _node.properties[4];
            case "int":
            case "enum":
            case "ULongLong":
            case "double":
            case "Number":
            case "FieldOfView":
                return _node.properties[4];
            case "Color":
            case "ColorRGB":
            case "Vector3D":
            case "Lcl Translation":
            case "Lcl Rotation":
            case "Lcl Scaling":
                return new FudgeCore.Vector3(..._node.properties.slice(4, 7));
            case "KString":
            default:
                return _node.properties[4];
        }
    }
    function formatPropertyName(_name) {
        return _name.replace(/[^a-zA-Z]/, "");
    }
})(FBX || (FBX = {}));
var FBX;
(function (FBX) {
    /**
     * Parses fbx-nodes array from a binary fbx-file.
     * despite the lazy node implementation it is mostly a copy of the reference: https://github.com/picode7/fbx-parser
     * @author Matthias Roming, HFU, 2023
     */
    function parseNodesFromBinary(_buffer) {
        if (_buffer.byteLength < binaryStartChars.length)
            throw "Not a binary FBX file";
        const data = new FBX.BufferReader(_buffer);
        const firstChars = new Uint8Array(data.getSequence(data.getUint8, binaryStartChars.length));
        const matchesFBXBinaryFirstChars = firstChars.every((_value, _index) => _value == binaryStartChars[_index]);
        if (!matchesFBXBinaryFirstChars)
            throw "Not a binary FBX file";
        const version = data.getUint32();
        const nodeAttributesAsUInt64 = version >= 7500; // Warum >= 7500?
        const nodes = [];
        while (true) {
            const node = readNode(data, nodeAttributesAsUInt64);
            if (node == null)
                break;
            nodes.push(node);
        }
        return nodes;
    }
    FBX.parseNodesFromBinary = parseNodesFromBinary;
    function readNode(_data, _attributesAsUint64) {
        const endOffset = _attributesAsUint64 ? Number(_data.getUint64()) : _data.getUint32();
        if (endOffset == 0)
            return null;
        const propertiesLength = _attributesAsUint64 ? Number(_data.getUint64()) : _data.getUint32();
        const propertiesByteLength = _attributesAsUint64 ? Number(_data.getUint64()) : _data.getUint32();
        const nameLength = _data.getUint8();
        const name = _data.getString(nameLength);
        const propertiesOffset = _data.offset;
        const childrenOffset = propertiesOffset + propertiesByteLength;
        const node = new FBX.Node(name, () => {
            _data.offset = propertiesOffset;
            const properties = [];
            for (let iProperty = 0; iProperty < propertiesLength; iProperty++) {
                properties.push(readProperty(_data));
            }
            return properties;
        }, () => {
            _data.offset = childrenOffset;
            const children = [];
            while (endOffset - _data.offset > nullCountAtNodeEnd) {
                const child = readNode(_data, _attributesAsUint64);
                if (child)
                    children.push(child);
            }
            return children;
        });
        _data.offset = endOffset;
        return node;
    }
    function readProperty(_data) {
        const typeCode = _data.getChar();
        const value = {
            C: _data.getBool,
            Y: _data.getInt16,
            I: _data.getInt32,
            L: _data.getInt64,
            F: _data.getFloat32,
            D: _data.getFloat64,
            S: () => _data.getString(_data.getUint32()).replace("\x00\x01", "::"),
            s: () => _data.getString(_data.getUint32()).replace("\x00\x01", "::"),
            R: () => new Uint8Array(readRaw(_data, _data.getUint8)),
            r: () => new Uint8Array(readArray(_data, _data.getUint8)),
            b: () => new Uint8Array(readArray(_data, _data.getUint8)),
            i: () => new Int32Array(readArray(_data, _data.getInt32)),
            l: () => new BigInt64Array(readArray(_data, _data.getInt64)),
            f: () => new Float32Array(readArray(_data, _data.getFloat32)),
            d: () => new Float32Array(readArray(_data, _data.getFloat64))
        }[typeCode]?.call(_data);
        if (value == null)
            FudgeCore.Debug.warn(`Unknown property type ${typeCode.charCodeAt(0)}`);
        return value;
    }
    function readArray(_data, _getter) {
        const length = _data.getUint32();
        const encoding = _data.getUint32();
        const byteLength = _data.getUint32();
        const endOffset = _data.offset + byteLength;
        const iterable = encoding == FBX.ARRAY_ENCODING.COMPRESSED ?
            (() => {
                const arrayData = new Uint8Array(_data.view.buffer, _data.offset, byteLength);
                const inflatedData = (Reflect.get(globalThis, "pako") ? pako.inflate : fflate.inflateSync)(arrayData);
                return new FBX.BufferReader(inflatedData.buffer).getSequence(_getter, length);
            })() :
            _data.getSequence(_getter, length);
        _data.offset = endOffset;
        return iterable;
    }
    function readRaw(_data, _getter) {
        // raw binary data needs to be interpreted in a special way see:
        // https://code.blender.org/2013/08/fbx-binary-file-format-specification/
        const length = _data.getUint32();
        return _data.getSequence(_getter, length);
        ;
    }
    const binaryStartChars = Uint8Array.from("Kaydara FBX Binary\x20\x20\x00\x1a\x00".split(""), _v => _v.charCodeAt(0));
    const nullCountAtNodeEnd = 13;
})(FBX || (FBX = {}));
var GLTF;
(function (GLTF) {
    /**
     * https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#accessor-data-types
     */
    let COMPONENT_TYPE;
    (function (COMPONENT_TYPE) {
        COMPONENT_TYPE[COMPONENT_TYPE["BYTE"] = 5120] = "BYTE";
        COMPONENT_TYPE[COMPONENT_TYPE["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
        COMPONENT_TYPE[COMPONENT_TYPE["SHORT"] = 5122] = "SHORT";
        COMPONENT_TYPE[COMPONENT_TYPE["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
        COMPONENT_TYPE[COMPONENT_TYPE["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
        COMPONENT_TYPE[COMPONENT_TYPE["FLOAT"] = 5126] = "FLOAT";
    })(COMPONENT_TYPE = GLTF.COMPONENT_TYPE || (GLTF.COMPONENT_TYPE = {}));
    let ACCESSOR_TYPE;
    (function (ACCESSOR_TYPE) {
        ACCESSOR_TYPE["SCALAR"] = "SCALAR";
        ACCESSOR_TYPE["VEC2"] = "VEC2";
        ACCESSOR_TYPE["VEC3"] = "VEC3";
        ACCESSOR_TYPE["VEC4"] = "VEC4";
        ACCESSOR_TYPE["MAT2"] = "MAT2";
        ACCESSOR_TYPE["MAT3"] = "MAT3";
        ACCESSOR_TYPE["MAT4"] = "MAT4";
    })(ACCESSOR_TYPE = GLTF.ACCESSOR_TYPE || (GLTF.ACCESSOR_TYPE = {}));
    let MESH_PRIMITIVE_MODE;
    (function (MESH_PRIMITIVE_MODE) {
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["POINTS"] = 0] = "POINTS";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["LINES"] = 1] = "LINES";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["LINE_LOOP"] = 2] = "LINE_LOOP";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["LINE_STRIP"] = 3] = "LINE_STRIP";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["TRIANGLES"] = 4] = "TRIANGLES";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    })(MESH_PRIMITIVE_MODE = GLTF.MESH_PRIMITIVE_MODE || (GLTF.MESH_PRIMITIVE_MODE = {}));
})(GLTF || (GLTF = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Asset loader for gl Transfer Format files.
     * @authors Matthias Roming, HFU, 2022 | Jonas Plotzky, HFU, 2023
     */
    class GLTFLoader {
        static #defaultMaterial;
        static #defaultSkinMaterial;
        #url;
        #gltf;
        #resources = {};
        #nodes = [];
        #cameras;
        #skeletons;
        #buffers;
        constructor(_gltf, _url, _bufferChunk) {
            this.#gltf = _gltf;
            this.#url = _url;
            if (_bufferChunk)
                this.#buffers = [_bufferChunk];
        }
        static get defaultMaterial() {
            if (!this.#defaultMaterial) {
                this.#defaultMaterial = new FudgeCore.Material("GLTFDefaultMaterial", FudgeCore.ShaderPhong, new FudgeCore.CoatRemissive(FudgeCore.Color.CSS("white"), 1, 0.5));
                FudgeCore.Project.deregister(this.#defaultMaterial);
            }
            return this.#defaultMaterial;
        }
        static get defaultSkinMaterial() {
            if (!this.#defaultSkinMaterial) {
                this.#defaultSkinMaterial = new FudgeCore.Material("GLTFDefaultSkinMaterial", FudgeCore.ShaderPhongSkin, new FudgeCore.CoatRemissive(FudgeCore.Color.CSS("white"), 1, 0.5));
                FudgeCore.Project.deregister(this.#defaultSkinMaterial);
            }
            return this.#defaultSkinMaterial;
        }
        /**
         * Handles the loading of an external resource from a glTF file. Used by the {@link SerializableResourceExternal}GLTF specializations to load themselves.
         * @internal
         */
        static async loadResource(_resource, _url) {
            const loader = await GLTFLoader.LOAD((_resource.url ?? _url).toString());
            if (!loader) {
                if (!(_resource instanceof FudgeCore.GraphInstance))
                    _resource.status = FudgeCore.RESOURCE_STATUS.ERROR;
                return _resource;
            }
            let loaded;
            if (_resource instanceof FudgeCore.GraphInstance)
                loaded = await loader.getGraph(_resource.get().name, _resource);
            else if (_resource instanceof FudgeCore.GraphGLTF)
                loaded = await loader.getGraph(_resource.name, _resource);
            else if (_resource instanceof FudgeCore.MeshGLTF)
                loaded = await loader.getMesh(_resource.name, _resource.iPrimitive, _resource);
            else if (_resource instanceof FudgeCore.MaterialGLTF)
                loaded = await loader.getMaterial(_resource.name, _resource);
            else if (_resource instanceof FudgeCore.AnimationGLTF)
                loaded = await loader.getAnimation(_resource.name, _resource);
            if (!loaded) {
                FudgeCore.Debug.error(`${_resource.constructor.name} | ${_resource instanceof FudgeCore.GraphInstance ? _resource.idSource : _resource.idResource}: Failed to load resource.`);
                if (!(_resource instanceof FudgeCore.GraphInstance))
                    _resource.status = FudgeCore.RESOURCE_STATUS.ERROR;
                return _resource;
            }
            if (!(loaded instanceof FudgeCore.GraphInstance)) {
                loaded.status = FudgeCore.RESOURCE_STATUS.READY;
            }
            // if (cached && !(_resource instanceof GraphInstance)) {
            //   if (!Project.resources[cached.idResource])
            //     cached.idResource = _resource.idResource; // change the id of the cached resource to the id of the resource that requested it
            //   if (cached.idResource != _resource.idResource) {
            //     // two different resources have requested the same cached resource
            //     Debug.error(`${_resource.idResource}: Failed to load resource. ${_resource.type} with name '${_resource.name}' from '${loader.name}' has already been loaded by '${cached.idResource}'. Please delete the duplicate '${_resource.idResource}' from the project.`);
            //     return _resource;
            //   }
            // }
            return loaded;
        }
        /**
         * Returns a {@link GLTFLoader} instance for the given url or null if the url can't be resolved.
         */
        static async LOAD(_url, _registerResources = false) {
            if (!this.loaders)
                GLTFLoader.loaders = {};
            if (!this.loaders[_url]) {
                let gltf;
                let buffer;
                try {
                    const response = await fetch(new URL(_url, FudgeCore.Project.baseURL));
                    const fileExtension = _url.split('.').pop()?.toLowerCase();
                    if (fileExtension == "gltf")
                        gltf = await response.json();
                    if (fileExtension == "glb") {
                        const arrayBuffer = await response.arrayBuffer();
                        const dataView = new DataView(arrayBuffer);
                        const magic = dataView.getUint32(0, true);
                        if (magic !== 0x46546C67)
                            throw new Error(`${GLTFLoader.name} | ${_url}: Invalid magic number in GLB file.`);
                        const version = dataView.getUint32(4, true);
                        if (version != 2)
                            throw new Error(`${GLTFLoader.name} | ${_url}: Unsupported version in GLB file.`);
                        const jsonLength = dataView.getUint32(12, true);
                        const jsonFormat = dataView.getUint32(16, true);
                        if (jsonFormat !== 0x4E4F534A)
                            throw new Error('Invalid format. The first chunk of the file is not in JSON format.');
                        const decoder = new TextDecoder();
                        const jsonChunk = decoder.decode(new Uint8Array(arrayBuffer, 20, jsonLength));
                        gltf = JSON.parse(jsonChunk);
                        if (arrayBuffer.byteLength >= 20 + jsonLength) {
                            const binaryLength = dataView.getUint32(20 + jsonLength, true);
                            const binaryFormat = dataView.getUint32(24 + jsonLength, true);
                            if (binaryFormat !== 0x004E4942)
                                throw new Error('Invalid format. The second chunk of the file is not in binary format.');
                            buffer = arrayBuffer.slice(28 + jsonLength, 28 + jsonLength + binaryLength);
                        }
                    }
                }
                catch (error) {
                    FudgeCore.Debug.error(`${GLTFLoader.name} | ${_url}: Failed to load file. ${error}`);
                    return null;
                }
                GLTFLoader.checkCompatibility(gltf, _url);
                GLTFLoader.preProcess(gltf, _url);
                GLTFLoader.loaders[_url] = new GLTFLoader(gltf, _url, buffer);
            }
            return GLTFLoader.loaders[_url];
        }
        static checkCompatibility(_gltf, _url) {
            if (_gltf.asset.version != "2.0")
                FudgeCore.Debug.warn(`${GLTFLoader.name} | ${_url}: This loader was developed for glTF 2.0. It may not work as intended with version ${_gltf.asset.version}.`);
            if (_gltf.asset.minVersion != undefined && _gltf.asset.minVersion != "2.0")
                throw new Error(`${GLTFLoader.name} | ${_url}: This loader was developed for glTF 2.0. It does not work with required min version ${_gltf.asset.minVersion}.`);
            if (_gltf.extensionsUsed?.length > 0)
                FudgeCore.Debug.warn(`${GLTFLoader.name} | ${_url}: This loader does not support glTF extensions. It may not work as intended with extensions ${_gltf.extensionsUsed.toString()}.`);
            if (_gltf.extensionsRequired?.length > 0)
                throw new Error(`${GLTFLoader.name} | ${_url}: This loader does not support glTF extensions. It does not work with required extensions ${_gltf.extensionsRequired.toString()}.`);
        }
        static preProcess(_gltf, _url) {
            // add a name to each scene
            if (_gltf.scenes) {
                _gltf.scene = _gltf.scene ?? 0;
                addNames("Scene", _gltf.scenes);
            }
            if (_gltf.nodes) {
                // mark all nodes that are animated
                _gltf.animations?.forEach(_animation => {
                    _animation.channels.forEach(_channel => {
                        const iNode = _channel.target.node;
                        if (iNode != undefined)
                            _gltf.nodes[iNode].isAnimated = true;
                    });
                });
                // mark parent of each node
                _gltf.nodes.forEach((_node, _iNode) => _node.children?.forEach(_iChild => _gltf.nodes[_iChild].parent = _iNode));
                _gltf.nodes.forEach((_node, _iNode) => {
                    // add names to nodes that don't have one
                    if (_node.name == undefined)
                        _node.name = `Node${_iNode}`;
                    if (_node.isAnimated) {
                        // add path to each animated node
                        let iParent = _node.parent;
                        let path = [];
                        path.push(_iNode);
                        while (iParent != undefined) {
                            path.push(iParent);
                            iParent = _gltf.nodes[iParent].parent;
                        }
                        _node.path = path.reverse();
                    }
                });
            }
            if (_gltf.materials)
                addNames("Material", _gltf.materials);
            if (_gltf.meshes)
                addNames("Mesh", _gltf.meshes);
            if (_gltf.animations)
                addNames("Animation", _gltf.animations);
            function addNames(_template, _target) {
                _target.forEach((_item, _index) => {
                    if (_item.name == undefined)
                        _item.name = `${_template}${_index}`;
                });
            }
        }
        /**
         * Returns the glTF file name.
         */
        get name() {
            return this.#url.split("\\").pop();
        }
        /**
         * Returns new instances of all resources of the given type.
         */
        async loadResources(_class) {
            let resources = [];
            switch (_class.name) {
                case FudgeCore.Graph.name:
                    for (let iScene = 0; iScene < this.#gltf.scenes?.length; iScene++)
                        resources.push(await this.getGraph(iScene, new FudgeCore.GraphGLTF()));
                    break;
                case FudgeCore.Mesh.name:
                    for (let iMesh = 0; iMesh < this.#gltf.meshes?.length; iMesh++)
                        for (let iPrimitive = 0; iPrimitive < this.#gltf.meshes[iMesh].primitives.length; iPrimitive++)
                            resources.push(await this.getMesh(iMesh, iPrimitive, new FudgeCore.MeshGLTF()));
                    break;
                case FudgeCore.Material.name:
                    for (let iMaterial = 0; iMaterial < this.#gltf.materials?.length; iMaterial++)
                        resources.push(await this.getMaterial(iMaterial, new FudgeCore.MaterialGLTF("Hi :)")));
                    break;
                case FudgeCore.Animation.name:
                    for (let iAnimation = 0; iAnimation < this.#gltf.animations?.length; iAnimation++)
                        resources.push(await this.getAnimation(iAnimation, new FudgeCore.AnimationGLTF()));
                    break;
            }
            for (const resource of resources) {
                if (!FudgeCore.Project.resources[resource.idResource])
                    FudgeCore.Project.register(resource);
                resource.status = FudgeCore.RESOURCE_STATUS.READY;
            }
            return resources;
        }
        async getGraph(_iScene = this.#gltf.scene, _graph) {
            _iScene = this.getIndex(_iScene, this.#gltf.scenes);
            if (_iScene == -1)
                return null;
            const id = `${FudgeCore.GraphGLTF.name}|${_iScene}`;
            if (!_graph && this.#resources[id])
                return this.#resources[id];
            this.#nodes = [];
            this.#cameras = [];
            this.#skeletons = [];
            const gltfScene = this.#gltf.scenes[_iScene];
            const graph = _graph ?? new FudgeCore.GraphGLTF();
            graph.name = gltfScene.name;
            if (graph instanceof FudgeCore.GraphGLTF)
                graph.url = this.#url;
            if (_graph) {
                _graph.removeAllChildren();
                _graph.removeComponents(FudgeCore.ComponentSkeleton);
            }
            for (const iNode of gltfScene.nodes)
                graph.addChild(await this.getNodeByIndex(iNode));
            // if (this.#gltf.animations?.length > 0 && !graph.getComponent(ComponentAnimation)) {
            //   let animation: Animation = await this.getAnimation(0);
            //   Project.register(animation);
            //   graph.addComponent(new ComponentAnimation(animation));
            // }
            // TODO: load only skeletons which belong to the scene???
            // if (this.gltf.skins?.length > 0)
            //   for (let iSkin: number = 0; iSkin < this.gltf.skins.length; iSkin++)
            //     scene.addComponent(await this.getSkeletonByIndex(iSkin));
            if (this.#skeletons)
                for (const skeleton of this.#skeletons)
                    graph.addComponent(skeleton);
            if (!_graph)
                this.#resources[id] = graph;
            return graph;
        }
        /**
         * Returns the first {@link Node} with the given name.
         */
        async getNode(_name) {
            const iNode = this.#gltf.nodes.findIndex(_node => _node.name == _name);
            if (iNode == -1)
                throw new Error(`${this}: Couldn't find name '${_name}' in glTF nodes.`);
            return await this.getNodeByIndex(iNode);
        }
        /**
         * Returns the {@link Node} for the given index.
         */
        async getNodeByIndex(_iNode) {
            if (!this.#nodes[_iNode]) {
                const gltfNode = this.#gltf.nodes[_iNode];
                const node = new FudgeCore.Node(gltfNode.name);
                this.#nodes[_iNode] = node;
                // check for children
                if (gltfNode.children)
                    for (const iNode of gltfNode.children)
                        node.addChild(await this.getNodeByIndex(iNode));
                // check for transformation
                if (gltfNode.matrix || gltfNode.rotation || gltfNode.scale || gltfNode.translation || gltfNode.isAnimated) {
                    node.addComponent(new FudgeCore.ComponentTransform());
                    if (gltfNode.matrix) {
                        node.mtxLocal.set(gltfNode.matrix);
                    }
                    else {
                        if (gltfNode.translation) {
                            const translation = FudgeCore.Recycler.get(FudgeCore.Vector3);
                            translation.set(gltfNode.translation[0], gltfNode.translation[1], gltfNode.translation[2]);
                            node.mtxLocal.translation = translation;
                            FudgeCore.Recycler.store(translation);
                        }
                        if (gltfNode.rotation) {
                            const rotation = FudgeCore.Recycler.get(FudgeCore.Quaternion);
                            rotation.set(gltfNode.rotation[0], gltfNode.rotation[1], gltfNode.rotation[2], gltfNode.rotation[3]);
                            node.mtxLocal.rotation = rotation;
                            FudgeCore.Recycler.store(rotation);
                        }
                        if (gltfNode.scale) {
                            const scale = FudgeCore.Recycler.get(FudgeCore.Vector3);
                            scale.set(gltfNode.scale[0], gltfNode.scale[1], gltfNode.scale[2]);
                            node.mtxLocal.scaling = scale;
                            FudgeCore.Recycler.store(scale);
                        }
                    }
                }
                // check for camera
                if (gltfNode.camera != undefined) {
                    node.addComponent(await this.getCameraByIndex(gltfNode.camera));
                }
                // check for mesh and material
                if (gltfNode.mesh != undefined) {
                    const gltfMesh = this.#gltf.meshes?.[gltfNode.mesh];
                    // TODO: review this
                    const subComponents = [];
                    for (let iPrimitive = 0; iPrimitive < gltfMesh.primitives.length; iPrimitive++) {
                        const cmpMesh = new FudgeCore.ComponentMesh(await this.getMesh(gltfNode.mesh, iPrimitive));
                        const isSkin = gltfNode.skin != undefined;
                        if (isSkin)
                            cmpMesh.skeleton = await this.getSkeletonByIndex(gltfNode.skin);
                        let cmpMaterial;
                        const iMaterial = gltfMesh.primitives?.[iPrimitive]?.material;
                        if (iMaterial == undefined) {
                            cmpMaterial = new FudgeCore.ComponentMaterial(isSkin ?
                                GLTFLoader.defaultSkinMaterial :
                                GLTFLoader.defaultMaterial);
                        }
                        else {
                            const isFlat = gltfMesh.primitives[iPrimitive].attributes.NORMAL == undefined;
                            cmpMaterial = new FudgeCore.ComponentMaterial(await this.getMaterial(iMaterial, null, isSkin, isFlat));
                            // TODO: maybe this should be a fudge material property
                            const gltfMaterial = this.#gltf.materials[iMaterial];
                            if (gltfMaterial)
                                cmpMaterial.sortForAlpha = gltfMaterial.alphaMode == "BLEND";
                        }
                        subComponents.push([cmpMesh, cmpMaterial]);
                    }
                    if (subComponents.length == 1) {
                        node.addComponent(subComponents[0][0]);
                        node.addComponent(subComponents[0][1]);
                    }
                    else {
                        subComponents.forEach(([_cmpMesh, _cmpMaterial], _i) => {
                            const nodePart = new FudgeCore.Node(`${node.name}_Primitive${_i}`);
                            nodePart.addComponent(_cmpMesh);
                            nodePart.addComponent(_cmpMaterial);
                            node.addChild(nodePart);
                        });
                    }
                }
            }
            return this.#nodes[_iNode];
        }
        /**
         * Returns the first {@link ComponentCamera} with the given camera name.
         */
        async getCamera(_name) {
            const iCamera = this.#gltf.cameras.findIndex(_camera => _camera.name == _name);
            if (iCamera == -1)
                throw new Error(`${this}: Couldn't find name '${_name}' in glTF cameras.`);
            return await this.getCameraByIndex(iCamera);
        }
        /**
         * Returns the {@link ComponentCamera} for the given camera index.
         */
        async getCameraByIndex(_iCamera) {
            if (!this.#cameras)
                this.#cameras = [];
            if (!this.#cameras[_iCamera]) {
                const gltfCamera = this.#gltf.cameras[_iCamera];
                const camera = new FudgeCore.ComponentCamera();
                if (gltfCamera.perspective)
                    camera.projectCentral(gltfCamera.perspective.aspectRatio, gltfCamera.perspective.yfov * FudgeCore.Calc.rad2deg, null, gltfCamera.perspective.znear, gltfCamera.perspective.zfar);
                else
                    camera.projectOrthographic(-gltfCamera.orthographic.xmag, gltfCamera.orthographic.xmag, -gltfCamera.orthographic.ymag, gltfCamera.orthographic.ymag);
                return camera;
            }
            return this.#cameras[_iCamera];
        }
        async getAnimation(_iAnimation, _animation) {
            _iAnimation = this.getIndex(_iAnimation, this.#gltf.animations);
            if (_iAnimation == -1)
                return null;
            const id = `${FudgeCore.Animation.name}|${_iAnimation}`;
            if (!_animation && this.#resources[id])
                return this.#resources[id];
            const gltfAnimation = this.#gltf.animations?.[_iAnimation];
            if (!gltfAnimation)
                throw new Error(`${this}: Couldn't find animation with index ${_iAnimation}.`);
            const animationStructure = {};
            for (const gltfChannel of gltfAnimation.channels) {
                const gltfNode = this.#gltf.nodes[gltfChannel.target.node];
                if (!gltfNode)
                    continue;
                let node = animationStructure;
                for (const iNode of gltfNode.path) {
                    const childName = this.#gltf.nodes[iNode].name;
                    // node.children[childName]
                    node = (node.children ??= {})[childName] ??= {};
                }
                // node.components.ComponentTransform[0].mtxLocal
                let mtxLocal = ((((node.components ??= {}).ComponentTransform ??= [])[0] ??= {}).mtxLocal ??= {});
                mtxLocal[toInternTransformation[gltfChannel.target.path]] =
                    await this.getAnimationSequenceVector(gltfAnimation.samplers[gltfChannel.sampler], gltfChannel.target.path);
            }
            const animation = _animation ?? new FudgeCore.AnimationGLTF();
            animation.animationStructure = animationStructure;
            animation.clearCache();
            animation.name = gltfAnimation.name;
            animation.calculateTotalTime();
            if (animation instanceof FudgeCore.AnimationGLTF)
                animation.url = this.#url;
            if (!_animation) {
                FudgeCore.Project.deregister(animation);
                this.#resources[id] = animation;
            }
            return animation;
        }
        async getMesh(_iMesh, _iPrimitive = 0, _mesh) {
            _iMesh = this.getIndex(_iMesh, this.#gltf.meshes);
            if (_iMesh == -1)
                return null;
            const id = `${FudgeCore.MeshGLTF.name}|${_iMesh}|${_iPrimitive}`;
            if (!_mesh && this.#resources[id])
                return this.#resources[id];
            const gltfMesh = this.#gltf.meshes[_iMesh];
            const gltfPrimitive = gltfMesh.primitives[_iPrimitive];
            if (gltfPrimitive.indices == undefined)
                FudgeCore.Debug.warn(`${this}: Mesh with index ${_iMesh} primitive ${_iPrimitive} has no indices. FUDGE does not support non-indexed meshes.`);
            if (gltfPrimitive.attributes.POSITION == undefined)
                FudgeCore.Debug.warn(`${this}: Mesh with index ${_iMesh} primitive ${_iPrimitive} has no position attribute. Primitive will be ignored.`);
            if (gltfPrimitive.mode != undefined && gltfPrimitive.mode != GLTF.MESH_PRIMITIVE_MODE.TRIANGLES)
                FudgeCore.Debug.warn(`${this}: Mesh with index ${_iMesh} primitive ${_iPrimitive} has topology type mode ${GLTF.MESH_PRIMITIVE_MODE[gltfPrimitive.mode]}. FUDGE only supports ${GLTF.MESH_PRIMITIVE_MODE[4]}.`);
            checkMaxSupport(this, "TEXCOORD", 2);
            checkMaxSupport(this, "COLOR", 1);
            checkMaxSupport(this, "JOINTS", 1);
            checkMaxSupport(this, "WEIGHTS", 1);
            let positions, indices;
            let normals, tangents;
            let colors, textureUVs;
            let bones, weights;
            if (gltfPrimitive.indices != undefined) {
                indices = await this.getVertexIndices(gltfPrimitive.indices);
                for (let i = 0; i < indices.length; i += 3) {
                    const temp = indices[i + 2];
                    indices[i + 2] = indices[i + 0];
                    indices[i + 0] = indices[i + 1];
                    indices[i + 1] = temp;
                }
            }
            else {
                FudgeCore.Debug.warn(`${this}: Mesh with index ${_iMesh} primitive ${_iPrimitive} has no indices. FUDGE does not support non-indexed meshes.`);
            }
            if (gltfPrimitive.attributes.POSITION != undefined)
                positions = await this.getFloat32Array(gltfPrimitive.attributes.POSITION);
            else
                FudgeCore.Debug.warn(`${this}: Mesh with index ${_iMesh} primitive ${_iPrimitive} has no position attribute. Primitive will be ignored.`);
            if (gltfPrimitive.attributes.NORMAL != undefined)
                normals = await this.getFloat32Array(gltfPrimitive.attributes.NORMAL);
            if (gltfPrimitive.attributes.TANGENT != undefined)
                tangents = await this.getFloat32Array(gltfPrimitive.attributes.TANGENT);
            if (gltfPrimitive.attributes.TEXCOORD_1 != undefined)
                textureUVs = await this.getFloat32Array(gltfPrimitive.attributes.TEXCOORD_1);
            else if (gltfPrimitive.attributes.TEXCOORD_0 != undefined)
                textureUVs = await this.getFloat32Array(gltfPrimitive.attributes.TEXCOORD_0);
            if (gltfPrimitive.attributes.COLOR_0 != undefined)
                colors = await this.getVertexColors(gltfPrimitive.attributes.COLOR_0);
            if (gltfPrimitive.attributes.JOINTS_0 != undefined && gltfPrimitive.attributes.WEIGHTS_0 != undefined) {
                bones = await this.getBoneIndices(gltfPrimitive.attributes.JOINTS_0);
                weights = await this.getFloat32Array(gltfPrimitive.attributes.WEIGHTS_0);
            }
            const mesh = _mesh ?? new FudgeCore.MeshGLTF();
            mesh.name = gltfMesh.name;
            if (mesh instanceof FudgeCore.MeshGLTF) {
                mesh.iPrimitive = _iPrimitive;
                mesh.url = this.#url;
            }
            if (_mesh) {
                _mesh.clear();
                _mesh.faces = [];
                _mesh.vertices = new FudgeCore.Vertices();
            }
            // Create mesh vertices and faces so that normals and tangents can be calculated if missing. If they are not missing this could be omitted.
            for (let iVector2 = 0, iVector3 = 0, iVector4 = 0; iVector3 < positions?.length; iVector2 += 2, iVector3 += 3, iVector4 += 4) {
                mesh.vertices.push(new FudgeCore.Vertex(new FudgeCore.Vector3(positions[iVector3 + 0], positions[iVector3 + 1], positions[iVector3 + 2]), textureUVs ?
                    new FudgeCore.Vector2(textureUVs[iVector2 + 0], textureUVs[iVector2 + 1]) :
                    undefined, normals ?
                    new FudgeCore.Vector3(normals[iVector3 + 0], normals[iVector3 + 1], normals[iVector3 + 2]) :
                    undefined, tangents ?
                    new FudgeCore.Vector4(tangents[iVector4 + 0], tangents[iVector4 + 1], tangents[iVector4 + 2], tangents[iVector4 + 3]) :
                    undefined, colors ?
                    new FudgeCore.Color(colors[iVector4 + 0], colors[iVector4 + 1], colors[iVector4 + 2], colors[iVector4 + 3]) :
                    undefined, bones && weights ?
                    [
                        { index: bones[iVector4 + 0], weight: weights[iVector4 + 0] },
                        { index: bones[iVector4 + 1], weight: weights[iVector4 + 1] },
                        { index: bones[iVector4 + 2], weight: weights[iVector4 + 2] },
                        { index: bones[iVector4 + 3], weight: weights[iVector4 + 3] }
                    ] :
                    undefined));
            }
            for (let iFaceVertexIndex = 0; iFaceVertexIndex < indices?.length; iFaceVertexIndex += 3) {
                try {
                    mesh.faces.push(new FudgeCore.Face(mesh.vertices, indices[iFaceVertexIndex + 0], indices[iFaceVertexIndex + 1], indices[iFaceVertexIndex + 2]));
                }
                catch (_e) {
                    FudgeCore.Debug.fudge("Face excluded", _e.message);
                }
            }
            mesh.renderMesh.positions = positions;
            mesh.renderMesh.indices = indices;
            mesh.renderMesh.normals = normals;
            mesh.renderMesh.tangents = tangents;
            mesh.renderMesh.textureUVs = textureUVs;
            mesh.renderMesh.colors = colors;
            mesh.renderMesh.bones = bones;
            mesh.renderMesh.weights = weights;
            if (!_mesh) {
                FudgeCore.Project.deregister(mesh);
                // mesh.idResource = id;
                this.#resources[id] = mesh;
            }
            return mesh;
            function checkMaxSupport(_loader, _check, _max) {
                if (Object.keys(gltfPrimitive.attributes).filter((_key) => _key.startsWith(_check)).length > _max)
                    FudgeCore.Debug.warn(`${_loader}: Mesh with index ${_iMesh} primitive ${_iPrimitive} has more than ${_max} sets of '${_check}' associated with it. FUGDE only supports up to ${_max} ${_check} sets per primitive.`);
            }
        }
        async getMaterial(_iMaterial, _material, _skin = false, _flat = false) {
            _iMaterial = this.getIndex(_iMaterial, this.#gltf.materials);
            if (_iMaterial == -1)
                return null;
            const id = `${FudgeCore.Material.name}|${_iMaterial}`;
            if (this.#resources[id] && !_material)
                return this.#resources[id];
            // TODO: in the future create an appropriate shader based on the glTF material properties
            const gltfMaterial = this.#gltf.materials[_iMaterial];
            if (!gltfMaterial)
                throw new Error(`${this}: Couldn't find material with index ${_iMaterial}.`);
            // TODO: add support for other glTF material properties: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-material
            // e.g. occlusion and emissive textures; doubleSided
            const gltfBaseColorFactor = gltfMaterial.pbrMetallicRoughness?.baseColorFactor ?? [1, 1, 1, 1];
            const gltfMetallicFactor = gltfMaterial.pbrMetallicRoughness?.metallicFactor ?? 1;
            const gltfRoughnessFactor = gltfMaterial.pbrMetallicRoughness?.roughnessFactor ?? 1;
            const gltfEmissiveFactor = gltfMaterial.emissiveFactor ?? [0, 0, 0];
            const gltfBaseColorTexture = gltfMaterial.pbrMetallicRoughness?.baseColorTexture;
            const gltfNormalTexture = gltfMaterial.normalTexture;
            // The diffuse contribution in the Phong shading model. Represents how much light is scattered in different directions due to the material's surface properties.
            const diffuse = 1;
            // The shininess of the material. Influences the sharpness or broadness of the specular highlight. Higher specular values result in a sharper and more concentrated specular highlight.
            const specular = 1.8 * (1 - gltfRoughnessFactor) + 0.6 * gltfMetallicFactor;
            // The strength/intensity of the specular reflection
            const intensity = 0.7 * (1 - gltfRoughnessFactor) + gltfMetallicFactor;
            // Influences how much the material's color affects the specular reflection. When metallic is higher, the specular reflection takes on the color of the material, creating a metallic appearance. Range from 0.0 to 1.0.
            const metallic = gltfMetallicFactor;
            const isLit = gltfEmissiveFactor[0] > 0 || gltfEmissiveFactor[1] > 0 || gltfEmissiveFactor[2] > 0;
            const color = new FudgeCore.Color(...gltfBaseColorFactor);
            if (isLit)
                color.add(new FudgeCore.Color(...gltfEmissiveFactor, 0));
            const coat = gltfBaseColorTexture ?
                isLit ? new FudgeCore.CoatTextured(color, await this.getTexture(gltfBaseColorTexture.index)) :
                    gltfNormalTexture ?
                        new FudgeCore.CoatRemissiveTexturedNormals(color, await this.getTexture(gltfBaseColorTexture.index), await this.getTexture(gltfNormalTexture.index), diffuse, specular, intensity, metallic) :
                        new FudgeCore.CoatRemissiveTextured(color, await this.getTexture(gltfBaseColorTexture.index), diffuse, specular, intensity, metallic) :
                isLit ? new FudgeCore.CoatColored(color) : new FudgeCore.CoatRemissive(color, diffuse, specular, intensity, metallic);
            if (gltfMaterial.alphaCutoff != undefined)
                coat.alphaClip = gltfMaterial.alphaCutoff;
            let shader;
            if (_flat) { // TODO: make flat a flag in the material so that we can have flat mesh with phong shading gradients
                shader = gltfBaseColorTexture ?
                    (_skin ? FudgeCore.ShaderFlatTexturedSkin : FudgeCore.ShaderFlatTextured) :
                    (_skin ? FudgeCore.ShaderFlatSkin : FudgeCore.ShaderFlat);
            }
            else if (isLit) {
                shader = gltfBaseColorTexture ?
                    (_skin ? FudgeCore.ShaderLitTexturedSkin : FudgeCore.ShaderLitTextured) :
                    (_skin ? FudgeCore.ShaderLitSkin : FudgeCore.ShaderLit);
            }
            else {
                shader = gltfBaseColorTexture ?
                    gltfNormalTexture ?
                        (_skin ? FudgeCore.ShaderPhongTexturedNormalsSkin : FudgeCore.ShaderPhongTexturedNormals) :
                        (_skin ? FudgeCore.ShaderPhongTexturedSkin : FudgeCore.ShaderPhongTextured) :
                    (_skin ? FudgeCore.ShaderPhongSkin : FudgeCore.ShaderPhong);
            }
            const material = _material ?? new FudgeCore.MaterialGLTF(gltfMaterial.name);
            material.name = gltfMaterial.name;
            material.coat = coat;
            Reflect.set(material, "shaderType", shader);
            // material.setShader(shader);
            if (material instanceof FudgeCore.MaterialGLTF)
                material.url = this.#url;
            if (!_material) {
                FudgeCore.Project.deregister(material);
                this.#resources[id] = material;
            }
            return material;
        }
        /**
         * Returns the {@link Texture} for the given texture index.
         */
        async getTexture(_iTexture) {
            const id = `${FudgeCore.Texture.name}|${_iTexture}`;
            if (this.#resources[id])
                return this.#resources[id];
            const gltfTexture = this.#gltf.textures[_iTexture];
            const gltfSampler = this.#gltf.samplers?.[gltfTexture.sampler];
            const gltfImage = this.#gltf.images?.[gltfTexture.source];
            if (gltfImage == undefined) {
                FudgeCore.Debug.warn(`${this}: Texture with index ${_iTexture} has no image.`);
                return FudgeCore.TextureDefault.color;
            }
            let url = new URL(gltfImage.uri, new URL(this.#url, FudgeCore.Project.baseURL)).toString();
            if (!gltfImage.uri && gltfImage.bufferView) {
                // TODO: this is duplicate code from getBufferData, maybe refactor getBufferData to handle bufferViewIndex input
                const gltfBufferView = this.#gltf.bufferViews[gltfImage.bufferView];
                const buffer = await this.getBuffer(gltfBufferView.buffer);
                const byteOffset = gltfBufferView.byteOffset || 0;
                const byteLength = gltfBufferView.byteLength || 0;
                url = URL.createObjectURL(new Blob([new Uint8Array(buffer, byteOffset, byteLength / Uint8Array.BYTES_PER_ELEMENT)], { type: gltfImage.mimeType }));
            }
            const texture = new FudgeCore.TextureImage();
            await texture.load(url);
            if (gltfSampler) {
                gltfSampler.magFilter = gltfSampler.magFilter ?? WebGL2RenderingContext.NEAREST; // default value
                gltfSampler.minFilter = gltfSampler.minFilter ?? WebGL2RenderingContext.NEAREST; // default value
                if (gltfSampler.magFilter == WebGL2RenderingContext.NEAREST && gltfSampler.minFilter == WebGL2RenderingContext.NEAREST)
                    texture.mipmap = FudgeCore.MIPMAP.CRISP;
                else if (gltfSampler.magFilter == WebGL2RenderingContext.NEAREST && gltfSampler.minFilter == WebGL2RenderingContext.NEAREST_MIPMAP_LINEAR)
                    texture.mipmap = FudgeCore.MIPMAP.MEDIUM;
                else if (gltfSampler.magFilter == WebGL2RenderingContext.LINEAR && gltfSampler.minFilter == WebGL2RenderingContext.LINEAR_MIPMAP_LINEAR)
                    texture.mipmap = FudgeCore.MIPMAP.BLURRY;
                else
                    FudgeCore.Debug.warn(`${this}: Texture with index ${_iTexture} has a magFilter and minFilter of '${getWebGLParameterName(gltfSampler.magFilter)}' and '${getWebGLParameterName(gltfSampler.minFilter)}' respectively. FUDGE only supports the following combinations: NEAREST and NEAREST | NEAREST and NEAREST_MIPMAP_LINEAR | LINEAR and LINEAR_MIPMAP_LINEAR.`);
                gltfSampler.wrapS = gltfSampler.wrapS ?? WebGL2RenderingContext.REPEAT; // default value
                gltfSampler.wrapT = gltfSampler.wrapT ?? WebGL2RenderingContext.REPEAT; // default value
                if (gltfSampler.wrapS == WebGL2RenderingContext.REPEAT && gltfSampler.wrapT == WebGL2RenderingContext.REPEAT)
                    texture.wrap = FudgeCore.WRAP.REPEAT;
                else if (gltfSampler.wrapS == WebGL2RenderingContext.CLAMP_TO_EDGE && gltfSampler.wrapT == WebGL2RenderingContext.CLAMP_TO_EDGE)
                    texture.wrap = FudgeCore.WRAP.CLAMP;
                else if (gltfSampler.wrapS == WebGL2RenderingContext.MIRRORED_REPEAT && gltfSampler.wrapT == WebGL2RenderingContext.MIRRORED_REPEAT)
                    texture.wrap = FudgeCore.WRAP.MIRROR;
                else
                    FudgeCore.Debug.warn(`${this}: Texture with index ${_iTexture} has a wrapS and wrapT of '${getWebGLParameterName(gltfSampler.wrapS)}' and '${getWebGLParameterName(gltfSampler.wrapT)}' respectively. FUDGE only supports the following combinations: REPEAT and REPEAT | CLAMP_TO_EDGE and CLAMP_TO_EDGE | MIRRORED_REPEAT and MIRRORED_REPEAT.`);
            }
            FudgeCore.Project.deregister(texture);
            this.#resources[id] = texture;
            return texture;
        }
        /**
        * Returns the first {@link ComponentSkeleton} with the given skeleton name.
        */
        async getSkeleton(_name) {
            const iSkeleton = this.#gltf.skins.findIndex(_skeleton => _skeleton.name == _name);
            if (iSkeleton == -1)
                throw new Error(`${this}: Couldn't find name '${_name}' in glTF skins.`);
            return await this.getSkeletonByIndex(iSkeleton);
        }
        /**
         * Returns the {@link ComponentSkeleton} for the given skeleton index.
         */
        async getSkeletonByIndex(_iSkeleton) {
            if (!this.#skeletons)
                this.#skeletons = [];
            if (!this.#skeletons[_iSkeleton]) {
                const gltfSkin = this.#gltf.skins[_iSkeleton];
                const bones = [];
                // convert float array to array of matrices and register bones
                let mtxData;
                if (gltfSkin.inverseBindMatrices != undefined)
                    mtxData = await this.getFloat32Array(gltfSkin.inverseBindMatrices);
                const mtxDataSpan = 16; // size of matrix
                const mtxBindInverses = [];
                // iterate over joints and get corresponding matrix from float array
                for (let iBone = 0; iBone < gltfSkin.joints.length; iBone++) {
                    let mtxBindInverse;
                    if (mtxData) {
                        mtxBindInverse = new FudgeCore.Matrix4x4();
                        mtxBindInverse.set(mtxData.subarray(iBone * mtxDataSpan, iBone * mtxDataSpan + mtxDataSpan));
                    }
                    bones.push(await this.getNodeByIndex(gltfSkin.joints[iBone]));
                    mtxBindInverses.push(mtxBindInverse);
                }
                this.#skeletons[_iSkeleton] = new FudgeCore.ComponentSkeleton(bones, mtxBindInverses);
            }
            return this.#skeletons[_iSkeleton];
        }
        toString() {
            return `${GLTFLoader.name} | ${this.#url}`;
        }
        getIndex(_nameOrIndex, _array) {
            let index = typeof _nameOrIndex == "number" ?
                _nameOrIndex :
                _array.findIndex(_object => _object.name == _nameOrIndex);
            if (index == -1) {
                let arrayName = Object.entries(this.#gltf).find(([_key, _value]) => _value == _array)?.[0];
                FudgeCore.Debug.error(`${this}: Couldn't find name '${_nameOrIndex}' in glTF ${arrayName}.`);
            }
            return index;
        }
        /**
         * Returns a {@link Uint8Array} for the given accessor index.
         * @internal
         */
        async getBoneIndices(_iAccessor) {
            const array = await this.getBufferData(_iAccessor);
            const componentType = this.#gltf.accessors[_iAccessor]?.componentType;
            if (componentType == GLTF.COMPONENT_TYPE.UNSIGNED_BYTE)
                return array;
            if (componentType == GLTF.COMPONENT_TYPE.UNSIGNED_SHORT) {
                FudgeCore.Debug.log(`${this}: Bone indices are stored as '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.UNSIGNED_SHORT]}'. FUDGE will convert them to '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.UNSIGNED_BYTE]}'. FUDGE only supports skeletons with up to 256 bones, so make sure your skeleton has no more than 256 bones.`);
                return Uint8Array.from(array);
            }
            throw new Error(`${this}: Invalid component type '${GLTF.COMPONENT_TYPE[componentType]}' for bone indices. Expected '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.UNSIGNED_BYTE]}' or '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.UNSIGNED_SHORT]}'.`);
        }
        /**
         * Returns a {@link Float32Array} for the given accessor index.
         * @internal
         */
        async getFloat32Array(_iAccessor) {
            const array = await this.getBufferData(_iAccessor);
            const gltfAccessor = this.#gltf.accessors[_iAccessor];
            if (gltfAccessor.componentType == GLTF.COMPONENT_TYPE.FLOAT)
                return array;
            if (gltfAccessor.normalized) {
                switch (gltfAccessor.componentType) {
                    case GLTF.COMPONENT_TYPE.BYTE:
                        return Float32Array.from(array, _value => Math.max(_value / 127, -1));
                    case GLTF.COMPONENT_TYPE.UNSIGNED_BYTE:
                        return Float32Array.from(array, _value => _value / 255);
                    case GLTF.COMPONENT_TYPE.SHORT:
                        return Float32Array.from(array, _value => Math.max(_value / 32767, -1));
                    case GLTF.COMPONENT_TYPE.UNSIGNED_SHORT:
                        return Float32Array.from(array, _value => _value / 65535);
                    default:
                        throw new Error(`${this}: Invalid component type '${GLTF.COMPONENT_TYPE[gltfAccessor.componentType]}' for normalized accessor.`);
                    // https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#_accessor_normalized
                }
            }
            FudgeCore.Debug.warn(`${this}: Expected component type '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.FLOAT]}' but was '${GLTF.COMPONENT_TYPE[gltfAccessor?.componentType]}'.`);
            return Float32Array.from(array);
        }
        /**
         * Returns a {@link Uint16Array} for the given accessor index. Only used to get the vertex indices.
         * @internal
         */
        async getVertexIndices(_iAccessor) {
            const array = await this.getBufferData(_iAccessor);
            const gltfAccessor = this.#gltf.accessors[_iAccessor];
            if (gltfAccessor.componentType == GLTF.COMPONENT_TYPE.UNSIGNED_SHORT)
                return array;
            if (gltfAccessor.count > 65535 && gltfAccessor.type == "SCALAR")
                throw new Error(`${this}: File includes a mesh with more than 65535 vertices. FUDGE does not support meshes with more than 65535 vertices.`);
            if (gltfAccessor.componentType == GLTF.COMPONENT_TYPE.UNSIGNED_BYTE || gltfAccessor.componentType == GLTF.COMPONENT_TYPE.UNSIGNED_INT)
                return Uint16Array.from(array);
            FudgeCore.Debug.warn(`${this}: Expected an unsigned integer component type but was '${GLTF.COMPONENT_TYPE[this.#gltf.accessors[_iAccessor]?.componentType]}'.`);
            return Uint16Array.from(array);
        }
        /**
         * Return a {@link Float32Array} for the given accessor index. The array contains the vertex colors in RGBA format.
         * @internal
         */
        async getVertexColors(_iAccessor) {
            const array = await this.getFloat32Array(_iAccessor);
            const gltfAccessor = this.#gltf.accessors[_iAccessor];
            if (gltfAccessor.type == GLTF.ACCESSOR_TYPE.VEC3) {
                const rgbaArray = new Float32Array(array.length * 4 / 3);
                for (let iVec3 = 0, iVec4 = 0; iVec3 < array.length; iVec3 += 3, iVec4 += 4) {
                    rgbaArray[iVec4] = array[iVec3];
                    rgbaArray[iVec4 + 1] = array[iVec3 + 1];
                    rgbaArray[iVec4 + 2] = array[iVec3 + 2];
                    rgbaArray[iVec4 + 3] = 1;
                }
                return rgbaArray;
            }
            return array;
        }
        async getBufferData(_iAccessor) {
            const gltfAccessor = this.#gltf.accessors[_iAccessor];
            if (!gltfAccessor)
                throw new Error(`${this}: Couldn't find accessor with index ${_iAccessor}.`);
            let array;
            const componentType = gltfAccessor.componentType;
            const accessorType = gltfAccessor.type;
            if (gltfAccessor.bufferView != undefined)
                array = await this.getBufferViewData(this.#gltf.bufferViews[gltfAccessor.bufferView], gltfAccessor.byteOffset, componentType, accessorType);
            if (gltfAccessor.sparse) {
                const gltfBufferViewIndices = this.#gltf.bufferViews[gltfAccessor.sparse.indices.bufferView];
                const gltfBufferViewValues = this.#gltf.bufferViews[gltfAccessor.sparse.values.bufferView];
                if (!gltfBufferViewIndices || !gltfBufferViewValues)
                    throw new Error(`${this}: Couldn't find buffer views for sparse indices or values of accessor with index ${_iAccessor}.`);
                const arrayIndices = await this.getBufferViewData(gltfBufferViewIndices, gltfAccessor.sparse.indices.byteOffset, gltfAccessor.sparse.indices.componentType, GLTF.ACCESSOR_TYPE.SCALAR);
                const arrayValues = await this.getBufferViewData(gltfBufferViewValues, gltfAccessor.sparse.values.byteOffset, componentType, accessorType);
                const accessorTypeLength = toAccessorTypeLength[gltfAccessor.type];
                if (gltfAccessor.bufferView == undefined)
                    array = new toArrayConstructor[gltfAccessor.componentType](gltfAccessor.count * accessorTypeLength);
                for (let i = 0; i < gltfAccessor.sparse.count; i++) {
                    array.set(arrayValues.slice(i * accessorTypeLength, (i + 1) * accessorTypeLength), arrayIndices[i] * accessorTypeLength);
                }
            }
            return array;
        }
        async getBufferViewData(_bufferView, _byteOffset, _componentType, _accessorType) {
            const buffer = await this.getBuffer(_bufferView.buffer);
            const byteOffset = (_bufferView.byteOffset ?? 0) + (_byteOffset ?? 0);
            const byteLength = _bufferView.byteLength ?? 0;
            const byteStride = _bufferView.byteStride;
            const arrayConstructor = toArrayConstructor[_componentType];
            //@ts-ignore because the TypedArrayConstructor type is not assignable to the TypedArray type
            const array = new arrayConstructor(buffer, byteOffset, byteLength / arrayConstructor.BYTES_PER_ELEMENT);
            if (byteStride != undefined) {
                // TODO: instead of creating new buffers maybe rather pass stride into the render mesh? and set it when data is passed to the gpu?
                const nComponentsPerElement = toAccessorTypeLength[_accessorType]; // amount of components per element of the accessor type, e.g. 3 for VEC3
                const nElements = byteLength / byteStride; // amount of elements, e.g. n*VEC3 
                const stride = byteStride / arrayConstructor.BYTES_PER_ELEMENT;
                const newArray = new arrayConstructor(nElements * nComponentsPerElement);
                for (let iNewElement = 0; iNewElement < nElements; iNewElement++) {
                    const iElement = iNewElement * stride;
                    // TODO: check if loop is faster than set + slice
                    for (let iComponent = 0; iComponent < nComponentsPerElement; iComponent++)
                        newArray[iNewElement * nComponentsPerElement + iComponent] = array[iElement + iComponent];
                    // newArray.set(array.slice(iElement, iElement + nComponentsPerElement), iNewElement * nComponentsPerElement);
                }
                return newArray;
            }
            return array;
        }
        async getBuffer(_iBuffer) {
            const gltfBuffer = this.#gltf.buffers[_iBuffer];
            if (!gltfBuffer)
                throw new Error(`${this}: Couldn't find buffer with index ${_iBuffer}.`);
            if (!this.#buffers)
                this.#buffers = [];
            if (!this.#buffers[_iBuffer]) {
                const response = await fetch(new URL(gltfBuffer.uri, new URL(this.#url, FudgeCore.Project.baseURL)));
                this.#buffers[_iBuffer] = await response.arrayBuffer();
            }
            return this.#buffers[_iBuffer];
        }
        async getAnimationSequenceVector(_sampler, _transformationType) {
            const input = await this.getFloat32Array(_sampler.input);
            const output = await this.getFloat32Array(_sampler.output);
            const millisPerSecond = 1000;
            const isRotation = _transformationType == "rotation";
            const vectorLength = isRotation ? 4 : 3; // rotation is stored as quaternion
            const interpolation = this.toInternInterpolation(_sampler.interpolation);
            const isCubic = interpolation == FudgeCore.ANIMATION_INTERPOLATION.CUBIC ? true : undefined;
            const vectorsPerInput = isCubic ? 3 : 1; // cubic interpolation uses 3 values per input: in-tangent, property value and out-tangent. https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#interpolation-cubic
            // used only for rotation interpolation
            let lastRotation;
            let nextRotation;
            const sequences = { x: [], y: [], z: [] };
            if (isRotation) {
                sequences.w = [];
                lastRotation = FudgeCore.Recycler.get(FudgeCore.Quaternion);
                nextRotation = FudgeCore.Recycler.get(FudgeCore.Quaternion);
            }
            for (let iInput = 0; iInput < input.length; iInput++) {
                const iOutput = iInput * vectorsPerInput * vectorLength + (isCubic ? vectorLength : 0);
                const iOutputSlopeIn = iOutput - vectorLength;
                const iOutputSlopeOut = iOutput + vectorLength;
                const time = millisPerSecond * input[iInput];
                if (isRotation) {
                    // Take the shortest path between two rotations, i.e. if the dot product is negative then the next quaternion needs to be negated.
                    // q and -q represent the same rotation but interpolation will take either the long way or the short way around the sphere depending on which we use.
                    nextRotation.set(output[iOutput + 0], output[iOutput + 1], output[iOutput + 2], output[iOutput + 3]);
                    if (FudgeCore.Quaternion.DOT(lastRotation, nextRotation) < 0)
                        nextRotation.negate();
                    output[iOutput + 0] = nextRotation.x;
                    output[iOutput + 1] = nextRotation.y;
                    output[iOutput + 2] = nextRotation.z;
                    output[iOutput + 3] = nextRotation.w;
                    lastRotation.set(nextRotation.x, nextRotation.y, nextRotation.z, nextRotation.w);
                }
                sequences.x.push(new FudgeCore.AnimationKey(time, output[iOutput + 0], interpolation, isCubic && output[iOutputSlopeIn + 0] / millisPerSecond, isCubic && output[iOutputSlopeOut + 0] / millisPerSecond));
                sequences.y.push(new FudgeCore.AnimationKey(time, output[iOutput + 1], interpolation, isCubic && output[iOutputSlopeIn + 1] / millisPerSecond, isCubic && output[iOutputSlopeOut + 1] / millisPerSecond));
                sequences.z.push(new FudgeCore.AnimationKey(time, output[iOutput + 2], interpolation, isCubic && output[iOutputSlopeIn + 2] / millisPerSecond, isCubic && output[iOutputSlopeOut + 2] / millisPerSecond));
                if (isRotation)
                    sequences.w.push(new FudgeCore.AnimationKey(time, output[iOutput + 3], interpolation, isCubic && output[iOutputSlopeIn + 3] / millisPerSecond, isCubic && output[iOutputSlopeOut + 3] / millisPerSecond));
            }
            if (isRotation) {
                FudgeCore.Recycler.store(lastRotation);
                FudgeCore.Recycler.store(nextRotation);
            }
            return Object.fromEntries(Object.entries(sequences).map(([_key, _value]) => [_key, new FudgeCore.AnimationSequence(_value)]));
        }
        toInternInterpolation(_interpolation) {
            switch (_interpolation) {
                case "LINEAR":
                    return FudgeCore.ANIMATION_INTERPOLATION.LINEAR;
                case "STEP":
                    return FudgeCore.ANIMATION_INTERPOLATION.CONSTANT;
                case "CUBICSPLINE":
                    return FudgeCore.ANIMATION_INTERPOLATION.CUBIC;
                default:
                    if (_interpolation != undefined)
                        FudgeCore.Debug.warn(`${this}: Unknown interpolation type ${_interpolation}.`);
                    return FudgeCore.ANIMATION_INTERPOLATION.LINEAR;
            }
        }
    }
    FudgeCore.GLTFLoader = GLTFLoader;
    function getWebGLParameterName(_value) {
        return Object.keys(WebGL2RenderingContext).find(_key => Reflect.get(WebGL2RenderingContext, _key) == _value);
    }
    const toInternTransformation = {
        "translation": "translation",
        "rotation": "rotation",
        "scale": "scaling",
        "weights": "weights"
    };
    // number of components defined by 'type'
    const toAccessorTypeLength = {
        "SCALAR": 1,
        "VEC2": 2,
        "VEC3": 3,
        "VEC4": 4,
        "MAT2": 4,
        "MAT3": 9,
        "MAT4": 16
    };
    const toArrayConstructor = {
        [GLTF.COMPONENT_TYPE.UNSIGNED_BYTE]: Uint8Array,
        [GLTF.COMPONENT_TYPE.BYTE]: Int8Array,
        [GLTF.COMPONENT_TYPE.UNSIGNED_SHORT]: Uint16Array,
        [GLTF.COMPONENT_TYPE.SHORT]: Int16Array,
        [GLTF.COMPONENT_TYPE.UNSIGNED_INT]: Uint32Array,
        [GLTF.COMPONENT_TYPE.FLOAT]: Float32Array
    };
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    FudgeCore.shaderSources = {};
    FudgeCore.shaderSources["ShaderAmbientOcclusion.frag"] = /*glsl*/ `#version 300 es
/**
 * Calculates ambient occlusion for a given fragment
 * @authors Roland Heer, HFU, 2023 | Jonas Plotzky, HFU, 2023
 * adaption of https://github.com/tsherif/webgl2examples/blob/da1153a15ebc09bb13498e5f732ef2036507740c/ssao.html
 * see here for an in depth explanation: 
*/
precision mediump float;
precision highp int;

const float sin45 = 0.707107; // 45 degrees in radians
const vec2 kernel[4] = vec2[4](vec2(0.0, 1.0), vec2(1.0, 0.0), vec2(0.0, -1.0), vec2(-1.0, 0.0));

uniform float u_fNear;
uniform float u_fFar;
uniform float u_fSampleRadius;
uniform float u_fBias;
uniform float u_fAttenuationConstant;
uniform float u_fAttenuationLinear;
uniform float u_fAttenuationQuadratic;
uniform vec2 u_vctResolution;
uniform vec3 u_vctCamera;
// uniform mat4 u_mtxViewProjectionInverse;

uniform sampler2D u_texPosition;
uniform sampler2D u_texNormal;
uniform sampler2D u_texNoise;
// uniform sampler2D u_texDepth;

in vec2 v_vctTexture;
out vec4 vctFrag;

layout(std140) uniform Fog {
  bool u_bFogActive;
  float u_fFogNear;
  float u_fFogFar;
  float pading;
  vec4 u_vctFogColor;
};

// This function could be used to calculate the position from the depth texture, but mobile devices seems to lack in precision to do this
// vec3 getPosition(vec2 _vctTexture) {
//   float fDepth = texture(u_texDepth, _vctTexture).r;
//   vec4 clipSpacePosition = vec4(_vctTexture * 2.0 - 1.0, fDepth * 2.0 - 1.0, 1.0);
//   vec4 worldSpacePosition = u_mtxViewProjectionInverse * clipSpacePosition;
//   return worldSpacePosition.xyz / worldSpacePosition.w;
// }

float getOcclusion(vec3 _vctPosition, vec3 _vctNormal, vec2 _vctTexture) {
  vec3 vctOccluder = texture(u_texPosition, _vctTexture).xyz;

  if (vctOccluder.x == 0.0 && vctOccluder.y == 0.0 && vctOccluder.z == 0.0) // no occluder at this position
    return 0.0;

  vec3 vctDistance = vctOccluder - _vctPosition;
  float fIntensity = max(dot(_vctNormal, normalize(vctDistance)) - u_fBias, 0.0);

  float fDistance = length(vctDistance);
  float fAttenuation = 1.0 / (u_fAttenuationConstant + u_fAttenuationLinear * fDistance + u_fAttenuationQuadratic * fDistance * fDistance);

  return fIntensity * fAttenuation;
}

float getFog(vec3 _vctPosition) {
  float fDistance = length(_vctPosition - u_vctCamera); // maybe use z-depth instead of euclidean depth
  float fFog = clamp((fDistance - u_fFogNear) / (u_fFogFar - u_fFogNear), 0.0, 1.0);
  fFog = -pow(fFog, 2.0) + (2.0 * fFog); // lets fog appear quicker and fall off slower results in a more gradual falloff
  return fFog * u_vctFogColor.a;
}

void main() {
  vec3 vctPosition = texture(u_texPosition, v_vctTexture).xyz;
  vec3 vctNormal = texture(u_texNormal, v_vctTexture).xyz;
  vec2 vctRandom = normalize(texture(u_texNoise, v_vctTexture).xy * 2.0 - 1.0);
  float fDepth = (length(vctPosition - u_vctCamera) - u_fNear) / (u_fFar - u_fNear); // linear euclidean depth in range [0,1], when changing to view space, don't subtract camera position
  float fKernelRadius = u_fSampleRadius * (1.0 - fDepth);

  float fOcclusion = 0.0;
  for (int i = 0; i < 4; ++i) {
    vec2 vctK1 = reflect(kernel[i], vctRandom);
    vec2 vctK2 = vec2(vctK1.x * sin45 - vctK1.y * sin45, vctK1.x * sin45 + vctK1.y * sin45);

    vctK1 /= u_vctResolution;
    vctK2 /= u_vctResolution;

    vctK1 *= fKernelRadius;
    vctK2 *= fKernelRadius;

    fOcclusion += getOcclusion(vctPosition, vctNormal, v_vctTexture + vctK1);
    fOcclusion += getOcclusion(vctPosition, vctNormal, v_vctTexture + vctK2 * 0.75);
    fOcclusion += getOcclusion(vctPosition, vctNormal, v_vctTexture + vctK1 * 0.5);
    fOcclusion += getOcclusion(vctPosition, vctNormal, v_vctTexture + vctK2 * 0.25);
  }

  fOcclusion = clamp(fOcclusion / 16.0, 0.0, 1.0);

  if (u_bFogActive && fOcclusion > 0.0) // correct occlusion by fog factor
    fOcclusion = mix(fOcclusion, 0.0, getFog(vctPosition));
  
  vctFrag.rgb = vec3(fOcclusion);
  vctFrag.a = 1.0;
}`;
    FudgeCore.shaderSources["ShaderBloom.frag"] = /*glsl*/ `#version 300 es
/**
 * Extracts colors, downsamples and upsamples a texture
 * Adaption of the "dual filtering kawase" method described in SIGGRAPH 2015 by Marius Bj√∏rge
 * https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_marius_2D00_notes.pdf
 * @authors Roland Heer, HFU, 2023 | Jirka Dell'Oro-Friedl, HFU, 2023 | Jonas Plotzky, HFU, 2023
 */
precision mediump float;
precision highp int;

uniform int u_iMode; // 0: extract, 1: downsample, 2: upsample, 3: apply
uniform float u_fThreshold;
uniform float u_fIntensity;
uniform float u_fHighlightDesaturation;
uniform vec2 u_vctTexel;

uniform sampler2D u_texSource;

in vec2 v_vctTexture;
out vec4 vctFrag;

// old gaussian blur
// flat in vec2[9] v_vctOffsets;
// const float gaussianKernel[9] = float[](0.045, 0.122, 0.045, 0.122, 0.332, 0.122, 0.045, 0.122, 0.045);
// vec4 downsample(vec2 _vctTexture) {
//   vec4 vctColor = vec4(0.0);
//   for (int i = 0; i < 9; i++) 
//     vctColor += texture(u_texSource, v_vctTexture + v_vctOffsets[i]) * gaussianKernel[i];
//   return vctColor;
// }
// vec4 upsample(vec2 _vctTexture) {
//   vec4 vctColor = vec4(0.0);
//   for (int i = 0; i < 9; i++) 
//     vctColor += texture(u_texSource, _vctTexture + v_vctOffsets[i]) * gaussianKernel[i];
//   return vctColor;
// }

// vec3 extract(vec2 _vctTexture) {
//   vec3 vctColor = texture(u_texSource, _vctTexture).rgb;
//   if(any(greaterThan(vctColor, vec3(u_fThreshold))))
//     return vctColor;
//   discard;
// }

// vec3 extract(vec2 _vctTexture) {
//   vec3 vctColor = texture(u_texSource, _vctTexture).rgb;
//   float luminance = dot(vctColor, vec3(0.299, 0.587, 0.114));
//   if(luminance > u_fThreshold)
//     return vctColor;
//   discard;
// }

// old extraction with average brightness
vec3 extract(vec2 _vctTexture) {
  vec3 vctColor = texture(u_texSource, _vctTexture).rgb;
  float fThreshold = u_fThreshold;
  if(fThreshold >= 1.0)
    fThreshold = 0.999999;

  vctColor = vctColor - fThreshold;
  vctColor = vctColor / (1.0 - fThreshold); // negative values might receive values above 1.0...
  
  float averageBrightness = (((vctColor.r + vctColor.g + vctColor.b) / 3.0) * 0.2) + 0.8; //the effect is reduced by first setting it to a 0.0-0.2 range and then adding 0.8
  vctColor = clamp(vctColor, 0.0, 1.0) * clamp(averageBrightness, 0.0, 1.0);
  return vctColor;
}

vec4 downsample(vec2 _vctTexture) {
  vec4 sum = texture(u_texSource, _vctTexture) * 4.0;
  sum += texture(u_texSource, _vctTexture - u_vctTexel.xy);
  sum += texture(u_texSource, _vctTexture + u_vctTexel.xy);
  sum += texture(u_texSource, _vctTexture + vec2(u_vctTexel.x, -u_vctTexel.y));
  sum += texture(u_texSource, _vctTexture - vec2(u_vctTexel.x, -u_vctTexel.y));

  return sum / 8.0;
}

vec4 upsample(vec2 _vctTexture) {
  vec4 sum = texture(u_texSource, _vctTexture + vec2(-u_vctTexel.x * 2.0, 0.0));
  sum += texture(u_texSource, _vctTexture + vec2(-u_vctTexel.x, u_vctTexel.y)) * 2.0;
  sum += texture(u_texSource, _vctTexture + vec2(0.0, u_vctTexel.y * 2.0));
  sum += texture(u_texSource, _vctTexture + vec2(u_vctTexel.x, u_vctTexel.y)) * 2.0;
  sum += texture(u_texSource, _vctTexture + vec2(u_vctTexel.x * 2.0, 0.0));
  sum += texture(u_texSource, _vctTexture + vec2(u_vctTexel.x, -u_vctTexel.y)) * 2.0;
  sum += texture(u_texSource, _vctTexture + vec2(0.0, -u_vctTexel.y * 2.0));
  sum += texture(u_texSource, _vctTexture + vec2(-u_vctTexel.x, -u_vctTexel.y)) * 2.0;
  return sum / 12.0;
}

vec3 apply(vec2 _vctTexture) {
  vec3 vctBloom = texture(u_texSource, _vctTexture).rgb;
  if (vctBloom.r >= 1.0 || vctBloom.g >= 1.0 || vctBloom.b >= 1.0) // maybe use threshold instead of 1.0?
    vctBloom = mix(vctBloom, vec3(1.0), u_fHighlightDesaturation);
  vctBloom = clamp(vctBloom * u_fIntensity, 0.0, 1.0);
  return vctBloom;
}

void main() {
  switch(u_iMode) {
    case 0:
      vctFrag.rgb = extract(v_vctTexture);
      vctFrag.a = 1.0;
      return;
    case 1:
      vctFrag = downsample(v_vctTexture);
      return;
    case 2:
      vctFrag = upsample(v_vctTexture);
      return;
    case 3:
      vctFrag.rgb = apply(v_vctTexture);
      vctFrag.a = 1.0;
      return;
    default:
      vctFrag = texture(u_texSource, v_vctTexture);
      return;
  }
}`;
    FudgeCore.shaderSources["ShaderGizmo.frag"] = /*glsl*/ `#version 300 es
/**
* ...
* @authors Jonas Plotzky, HFU, 2023
*/
precision mediump float;
precision highp int;

uniform vec4 u_vctColor;

out vec4 vctFrag;

// uniform sampler2D u_texDepthStencil;
#if defined(TEXTURE)

  uniform sampler2D u_texColor;
  in vec2 v_vctTexture;
  
#endif

// // 4x4 Bayer matrix for dithering
// const float mtxDither[16] = float[](
//   1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
//   13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
//   4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
//   16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
// );

void main() {
  vctFrag = u_vctColor;

  #if defined(TEXTURE)

      vctFrag *= texture(u_texColor, v_vctTexture);

  #endif

  // int x = int(gl_FragCoord.x) % 4;
  // int y = int(gl_FragCoord.y) % 4;
  // int index = y * 4 + x;
  // // Discard the fragment if its alpha is less than the corresponding value in the dithering matrix
  // if (vctFrag.a < mtxDither[index]) 
  //   discard;

  // // Discard the fragment if its alpha is 0
  // if (vctFrag.a == 0.0)
  //   discard;

  // // Create a checkerboard pattern for alpha values less than 0.5
  // else if (vctFrag.a < 0.5 && ((x + y) % 2 == 0))
  //   discard;

  // vctFrag.a = 1.0;

  if (vctFrag.a < 0.01)
    discard;
}`;
    FudgeCore.shaderSources["ShaderGizmo.vert"] = /*glsl*/ `#version 300 es
/**
* ...
* @authors Jonas Plotzky, HFU, 2023
*/
precision mediump float;
precision highp int;

uniform mat4 u_mtxMeshToWorld; // u_mtxModel

layout(std140) uniform Camera {
  mat4 u_mtxWorldToCamera; // u_mtxView
  mat4 u_mtxProjection; 
  mat4 u_mtxWorldToView; // u_mtxViewProjection
  vec3 u_vctCamera;
};

layout(location = 0) in vec3 a_vctPosition;

#if defined(TEXTURE)

  layout(location = 2) in vec2 a_vctTexture;
  out vec2 v_vctTexture;

#endif

void main() {
  gl_Position = u_mtxWorldToView * u_mtxMeshToWorld * vec4(a_vctPosition, 1.0);

  #if defined(TEXTURE)

    v_vctTexture = a_vctTexture;

  #endif
}`;
    FudgeCore.shaderSources["ShaderOutline.frag"] = /*glsl*/ `#version 300 es
/**
 * @authors Jonas Plotzky, HFU, 2025
 */
precision mediump float;
precision highp int;

uniform vec2 u_vctTexel;
uniform vec4 u_vctColor;
uniform vec4 u_vctColorOccluded;

uniform sampler2D u_texDepthOutline;
uniform sampler2D u_texDepthScene;

in vec2 v_vctTexture;
out vec4 vctFrag;

float getDepth(vec2 _vctTexture) {
  return texture(u_texDepthOutline, _vctTexture).r;
}

void main() {
  float fDepth = getDepth(v_vctTexture);

  if (fDepth != 1.0)
    discard;

  float fDepthTop = getDepth(v_vctTexture + vec2(0, u_vctTexel.y));
  float fDepthRight = getDepth(v_vctTexture + vec2(u_vctTexel.x, 0));
  float fDepthBottom = getDepth(v_vctTexture + vec2(0, -u_vctTexel.y));
  float fDepthLeft = getDepth(v_vctTexture + vec2(-u_vctTexel.x, 0));

  float fDepthMin = min(min(fDepthTop, fDepthRight), min(fDepthBottom, fDepthLeft));
  float fDepthDelta = abs(fDepth - fDepthMin);

  if (fDepthDelta == 0.0)
    discard;

  float fDepthScene = texture(u_texDepthScene, v_vctTexture).r;
  if (fDepthMin < fDepthScene)
    vctFrag = u_vctColor;
  else
    vctFrag = u_vctColorOccluded;
}`;
    FudgeCore.shaderSources["ShaderPhong.frag"] = /*glsl*/ `#version 300 es
/**
* Phong shading
* @authors Jirka Dell'Oro-Friedl, HFU, 2022 | Roland Heer, HFU, 2023 | Jonas Plotzky, HFU, 2023
*/

precision mediump float;
precision highp int;

uniform vec4 u_vctColor;
uniform float u_fDiffuse;
uniform float u_fSpecular;
uniform float u_fIntensity;
uniform float u_fMetallic;
uniform vec3 u_vctCamera;

uniform bool u_bFog;
uniform vec4 u_vctFogColor;
uniform float u_fFogNear;
uniform float u_fFogFar;

in vec4 v_vctColor;
in vec3 v_vctPosition;

layout(location = 0) out vec4 vctFrag;
layout(location = 1) out vec4 vctFragPosition;
layout(location = 2) out vec4 vctFragNormal;

#ifdef PHONG

  in vec3 v_vctNormal;

#endif

#ifdef FLAT

  flat in vec3 v_vctPositionFlat;

#endif

struct Light {
  vec4 vctColor;
  mat4 mtxShape;
  mat4 mtxShapeInverse;
};

const uint MAX_LIGHTS_DIRECTIONAL = 15u;
const uint MAX_LIGHTS_POINT = 100u;
const uint MAX_LIGHTS_SPOT = 100u;

layout(std140) uniform Lights {
  uint u_nLightsDirectional;
  uint u_nLightsPoint;
  uint u_nLightsSpot;
  uint padding; // Add padding to align to 16 bytes
  Light u_ambient;
  Light u_directional[MAX_LIGHTS_DIRECTIONAL];
  Light u_point[MAX_LIGHTS_POINT];
  Light u_spot[MAX_LIGHTS_SPOT];
};

// TEXTURE: input UVs and texture
#ifdef TEXTURE

  in vec2 v_vctTexture;
  uniform sampler2D u_texColor;

#endif

// NORMALMAP: input UVs and texture
#ifdef NORMALMAP

  in vec3 v_vctTangent;
  in vec3 v_vctBitangent;
  uniform sampler2D u_texNormal;

#endif

// Returns a vector for visualizing on model. Great for debugging
vec4 showVectorAsColor(vec3 _vector, bool _clamp) {
  if(_clamp) {
    _vector *= 0.5;
    _vector += 0.5;
  }
  return vec4(_vector.x, _vector.y, _vector.z, 1);
}

void illuminateDirected(vec3 _vctDirection, vec3 _vctView, vec3 _vctNormal, vec3 _vctColor, inout vec3 _vctDiffuse, inout vec3 _vctSpecular) {
  vec3 vctDirection = normalize(_vctDirection);
  float fIllumination = -dot(_vctNormal, vctDirection);
  if(fIllumination > 0.0) {
    _vctDiffuse += u_fDiffuse * fIllumination * _vctColor;

    if(u_fSpecular <= 0.0)
      return;
      
    //BLINN-Phong Shading
    vec3 halfwayDir = normalize(-vctDirection - _vctView);
    float factor = max(dot(-vctDirection, _vctNormal), 0.0); //Factor for smoothing out transition from surface facing the lightsource to surface facing away from the lightsource
    factor = 1.0 - (pow(factor - 1.0, 8.0));                 //The factor is altered in order to clearly see the specular highlight even at steep angles, while still preventing artifacts

    _vctSpecular += pow(max(dot(_vctNormal, halfwayDir), 0.0), exp2(u_fSpecular * 5.0)) * u_fSpecular * u_fIntensity * factor * _vctColor;
  }
}

float getFog(vec3 _vctPosition) {
  float fDistance = length(_vctPosition - u_vctCamera); // maybe use z-depth instead of euclidean depth
  float fFog = clamp((fDistance - u_fFogNear) / (u_fFogFar - u_fFogNear), 0.0, 1.0);
  fFog = -pow(fFog, 2.0) + (2.0 * fFog); // lets fog appear quicker and fall off slower results in a more gradual falloff
  return fFog;
}

void main() {
  #if defined(PHONG) && !defined(FLAT)

    #ifdef NORMALMAP

      mat3 mtxTBN = mat3(normalize(v_vctTangent), normalize(v_vctBitangent), normalize(v_vctNormal));
      vec3 vctNormal = texture(u_texNormal, v_vctTexture).xyz * 2.0 - 1.0;
      vctNormal = normalize(mtxTBN * vctNormal);

    #else

      vec3 vctNormal = normalize(v_vctNormal);

    #endif

    vec3 vctView = normalize(v_vctPosition - u_vctCamera);
    vec3 vctPosition = v_vctPosition;

  #endif

  #ifdef FLAT

    vec3 vctFdx = dFdx(v_vctPosition);
    vec3 vctFdy = dFdy(v_vctPosition);
    vec3 vctNormal = normalize(cross(vctFdx, vctFdy));
    vec3 vctView = normalize(v_vctPositionFlat - u_vctCamera);
    vec3 vctPosition = v_vctPositionFlat;

  #endif

  vec3 vctDiffuse = u_fDiffuse * u_ambient.vctColor.rgb;
  vec3 vctSpecular = vec3(0, 0, 0);

  // calculate directional light effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    vec3 vctDirection = vec3(u_directional[i].mtxShape * vec4(0.0, 0.0, 1.0, 1.0));
    illuminateDirected(vctDirection, vctView, vctNormal, u_directional[i].vctColor.rgb, vctDiffuse, vctSpecular);
  }

  // calculate point light effect
  for(uint i = 0u; i < u_nLightsPoint; i++) {
    vec3 vctPositionLight = vec3(u_point[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
    vec3 vctDirection = vctPosition - vctPositionLight;
    float fIntensity = 1.0 - length(mat3(u_point[i].mtxShapeInverse) * vctDirection);
    if(fIntensity < 0.0)
      continue;

    illuminateDirected(vctDirection, vctView, vctNormal, u_point[i].vctColor.rgb * fIntensity, vctDiffuse, vctSpecular);
  }

  // calculate spot light effect
  for(uint i = 0u; i < u_nLightsSpot; i++) {
    vec3 vctPositionLight = vec3(u_spot[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
    vec3 vctDirection = vctPosition - vctPositionLight;
    vec3 vctDirectionInverted = mat3(u_spot[i].mtxShapeInverse) * vctDirection;
    if(vctDirectionInverted.z <= 0.0)
      continue;

    float fIntensity = 1.0 - min(1.0, 2.0 * length(vctDirectionInverted.xy) / vctDirectionInverted.z);    //Coneshape that is brightest in the center. Possible TODO: "Variable Spotlightsoftness"
    fIntensity *= 1.0 - pow(vctDirectionInverted.z, 2.0);                                                 //Prevents harsh lighting artifacts at boundary of the given spotlight
    if(fIntensity < 0.0)
      continue;

    illuminateDirected(vctDirection, vctView, vctNormal, u_spot[i].vctColor.rgb * fIntensity, vctDiffuse, vctSpecular);
  }

  vctFrag.rgb = vctDiffuse + vctSpecular * u_fMetallic;
  vctFrag.a = 1.0;

  #ifdef TEXTURE

    vec4 vctColorTexture = texture(u_texColor, v_vctTexture);
    vctFrag *= vctColorTexture;

  #endif

  vctFrag *= u_vctColor * v_vctColor;
  vctFrag.rgb += vctSpecular * (1.0 - u_fMetallic);

  vctFragPosition = vec4(v_vctPosition, 1.0); // don't use flat here, because we want to interpolate the position
  vctFragNormal = vec4(vctNormal, 1.0);

  if (u_bFog) 
    vctFrag.rgb = mix(vctFrag.rgb, u_vctFogColor.rgb, getFog(vctPosition) * u_vctFogColor.a);

  vctFrag.rgb *= vctFrag.a;

  if(vctFrag.a < 0.01)
    discard;
}`;
    FudgeCore.shaderSources["ShaderPick.frag"] = /*glsl*/ `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
precision mediump float;
precision highp int;

uniform int u_id;
uniform vec2 u_vctSize;
uniform vec4 u_vctColor;
out ivec4 vctFrag;

#if defined(TEXTURE)

  uniform sampler2D u_texColor;
  in vec2 v_vctTexture;

#endif

void main() {
  int pixel = int(trunc(gl_FragCoord.x) + u_vctSize.x * trunc(gl_FragCoord.y));

  if (pixel != u_id)
    discard;
  
  vec4 vctColor = u_vctColor;
  
  #if defined(TEXTURE)

    vctColor *= texture(u_texColor, v_vctTexture);

  #endif

  uint icolor = uint(vctColor.r * 255.0) << 24 | uint(vctColor.g * 255.0) << 16 | uint(vctColor.b * 255.0) << 8 | uint(vctColor.a * 255.0);
  
  vctFrag = ivec4(floatBitsToInt(gl_FragCoord.z), icolor, 0, 0);

  #if defined(TEXTURE)

    vctFrag.b = floatBitsToInt(v_vctTexture.x);
    vctFrag.a = floatBitsToInt(v_vctTexture.y);

  #endif
}`;
    FudgeCore.shaderSources["ShaderPick.vert"] = /*glsl*/ `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
uniform mat4 u_mtxMeshToWorld; // u_mtxModel

layout(std140) uniform Camera {
  mat4 u_mtxWorldToCamera; // u_mtxView
  mat4 u_mtxProjection; 
  mat4 u_mtxWorldToView; // u_mtxViewProjection
  vec3 u_vctCamera;
};

layout(location = 0) in vec3 a_vctPosition;

#if defined(TEXTURE)

  layout(location = 2) in vec2 a_vctTexture;
  out vec2 v_vctTexture;

#endif

void main() {
  gl_Position = u_mtxWorldToView * u_mtxMeshToWorld * vec4(a_vctPosition, 1.0);

  #if defined(TEXTURE)

    v_vctTexture = a_vctTexture;

  #endif
}`;
    FudgeCore.shaderSources["ShaderScreen.vert"] = /*glsl*/ `#version 300 es
precision mediump float;
precision highp int;
/**
 * Creates a fullscreen triangle which cotains the screen quad and sets the texture coordinates accordingly.
 * @authors Roland Heer, HFU, 2023 | Jirka Dell'Oro-Friedl, HFU, 2023 | Jonas Plotzky, HFU, 2023
 *
 *  2  3 .
 *       .  .
 *       .     .  
 *       .        .
 *  1  1 ..........  .
 *       . screen .     .
 *       .  quad  .        .
 *  0 -1 ..........  .  .  .  .
 *    p -1        1           3
 *  t    0        1           2
 *  
 *  p == postion
 *  t == texture coordinate
 */

// uniform vec2 u_vctResolution;

out vec2 v_vctTexture;

// #ifdef SAMPLE

//   flat out vec2[9] v_vctOffsets;

// #endif

void main() {
  float x = float((gl_VertexID % 2) * 4); // 0, 4, 0
  float y = float((gl_VertexID / 2) * 4); // 0, 0, 4
  gl_Position = vec4(x - 1.0, y - 1.0, 0.0, 1.0); // (-1, -1), (3, -1), (-1, 3)
  v_vctTexture = vec2(x / 2.0, y / 2.0);  // (0, 0), (2, 0), (0, 2) -> interpolation will yield (0, 0), (1, 0), (0, 1) as the positions are double the size of the screen

  // #ifdef SAMPLE

  //   vec2 offset = vec2(1.0 / u_vctResolution.x, 1.0 / u_vctResolution.y);
  //   v_vctOffsets = vec2[](
  //     vec2(-offset.x, offset.y),  vec2(0.0, offset.y),  vec2(offset.x, offset.y),
  //     vec2(-offset.x, 0.0),       vec2(0.0, 0.0),       vec2(offset.x, 0.0),
  //     vec2(-offset.x, -offset.y), vec2(0.0, -offset.y),  vec2(offset.x, -offset.y)
  //   );

  // #endif
}`;
    FudgeCore.shaderSources["ShaderUniversal.frag"] = /*glsl*/ `#version 300 es
/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021 | Jonas Plotzky, HFU, 2023
*/
precision mediump float;
precision highp int;

layout(std140) uniform Node {
  uniform mat4 u_mtxMeshToWorld; // u_mtxModel
  uniform mat3 u_mtxPivot; // texture pivot matrix
  uniform vec4 u_vctColorPrimary; // component material color

  uniform int u_iBlendMode;
  uniform float u_fParticleSystemDuration;
  uniform float u_fParticleSystemSize;
  uniform float u_fParticleSystemTime;

  uniform bool u_bFaceCameraActive;
  uniform bool u_bFaceCameraRestrict;
};

layout(std140) uniform Camera {
  mat4 u_mtxWorldToCamera; // u_mtxView
  mat4 u_mtxProjection; 
  mat4 u_mtxWorldToView; // u_mtxViewProjection
  vec3 u_vctCamera;
};

layout(std140) uniform Material {
  uniform vec4 u_vctColor;

  uniform float u_fDiffuse;
  uniform float u_fSpecular;
  uniform float u_fIntensity;
  uniform float u_fMetallic;

  uniform float u_fAlphaClip;
};

layout(std140) uniform Fog {
  bool u_bFogActive;
  float u_fFogNear;
  float u_fFogFar;
  float fogPadding; // add padding to align to 16 bytes
  vec4 u_vctFogColor;
};

in vec3 v_vctPosition;
in vec4 v_vctColor;

layout(location = 0) out vec4 vctFrag;
layout(location = 1) out vec4 vctFragPosition; // TODO: make these optional?
layout(location = 2) out vec4 vctFragNormal;

#if defined(FLAT) || defined(GOURAUD) || defined(PHONG)

  in vec3 v_vctNormal;

#endif

#if defined(FLAT)

  flat in vec3 v_vctPositionFlat;

#endif

#if defined(GOURAUD)

  in vec3 v_vctDiffuse;
  in vec3 v_vctSpecular;

#endif

#if defined(TOON)

  uniform sampler2D u_texToon;

#endif

#if defined(PHONG) || defined(FLAT)

  struct Light {
    vec4 vctColor;
    mat4 mtxShape;
    mat4 mtxShapeInverse;
  };

  const uint MAX_LIGHTS_DIRECTIONAL = 15u;
  const uint MAX_LIGHTS_POINT = 100u;
  const uint MAX_LIGHTS_SPOT = 100u;

  layout(std140) uniform Lights {
    uint u_nLightsDirectional;
    uint u_nLightsPoint;
    uint u_nLightsSpot;
    uint ligthsPadding; // Add padding to align to 16 bytes
    Light u_ambient;
    Light u_directional[MAX_LIGHTS_DIRECTIONAL];
    Light u_point[MAX_LIGHTS_POINT];
    Light u_spot[MAX_LIGHTS_SPOT];
  };

  /**
   * _vctLight: direction from position to light
   * _vctView: direction from position to camera
   * _vctNormal: surface normal at position
   * _vctColor: color of the light
   */
  void illuminateDirected(vec3 _vctLightDirection, vec3 _vctViewDirection, vec3 _vctNormal, vec3 _vctColor, inout vec3 _vctDiffuse, inout vec3 _vctSpecular) {
    vec3 vctLightDirection = normalize(_vctLightDirection);

    float fDiffuse = dot(_vctNormal, vctLightDirection);

    if(fDiffuse > 0.0) {

      #if defined(TOON)
      
        fDiffuse = texture(u_texToon, vec2(fDiffuse, 0)).r;

      #endif

      _vctDiffuse += u_fDiffuse * fDiffuse * _vctColor;

      if(u_fSpecular <= 0.0 || u_fIntensity <= 0.0)
        return;
      
      //BLINN-Phong Shading
      vec3 halfwayDir = normalize(vctLightDirection + _vctViewDirection);
      float factor = fDiffuse;                  // Factor for smoothing out transition from surface facing the lightsource to surface facing away from the lightsource
      factor = 1.0 - (pow(factor - 1.0, 8.0));  // The factor is altered in order to clearly see the specular highlight even at steep angles, while still preventing artifacts

      float fSpecular = pow(max(dot(_vctNormal, halfwayDir), 0.0), exp2(u_fSpecular * 5.0)) * factor; // TODO: remove magic numbers?

      #if defined(TOON)
        
        fSpecular = texture(u_texToon, vec2(fSpecular, 0.0)).g * fDiffuse;

      #endif

      _vctSpecular += fSpecular * u_fIntensity * _vctColor;
    }
  }

#endif

#if defined(TEXTURE) || defined(MATCAP)

  uniform sampler2D u_texColor;
  in vec2 v_vctTexture;

#endif

#if defined(NORMALMAP)

  uniform sampler2D u_texNormal;
  in vec3 v_vctTangent;
  in vec3 v_vctBitangent;

#endif

float getFog(vec3 _vctPosition) {
  float fDistance = length(_vctPosition - u_vctCamera); // maybe use z-depth instead of euclidean depth
  float fFog = clamp((fDistance - u_fFogNear) / (u_fFogFar - u_fFogNear), 0.0, 1.0);
  fFog = -pow(fFog, 2.0) + (2.0 * fFog); // lets fog appear quicker and fall off slower results in a more gradual falloff
  return fFog * u_vctFogColor.a;
}

void main() {

  #if defined(FLAT)

    vec3 vctFdx = dFdx(v_vctPosition);
    vec3 vctFdy = dFdy(v_vctPosition);
    vec3 vctNormal = normalize(cross(vctFdx, vctFdy));
    vec3 vctViewDirection = normalize(u_vctCamera - v_vctPositionFlat);
    vec3 vctPosition = v_vctPositionFlat;

  #endif

  #if (defined(PHONG) || defined(GOURAUD)) && !defined(NORMALMAP)

    vec3 vctNormal = normalize(v_vctNormal);

  #endif

  #if defined(PHONG)

    vec3 vctViewDirection = normalize(u_vctCamera - v_vctPosition);
    vec3 vctPosition = v_vctPosition;

  #endif

  #if defined(NORMALMAP)

    mat3 mtxTBN = mat3(normalize(v_vctTangent), normalize(v_vctBitangent), normalize(v_vctNormal));
    vec3 vctNormal = texture(u_texNormal, v_vctTexture).xyz * 2.0 - 1.0;
    vctNormal = normalize(mtxTBN * vctNormal);

  #endif
  
  #if defined(FLAT) || defined(PHONG)

    vec3 vctDiffuse = u_fDiffuse * u_ambient.vctColor.rgb;
    vec3 vctSpecular = vec3(0, 0, 0);

    // directional lights
    for(uint i = 0u; i < u_nLightsDirectional; i++) {
      vec3 vctLightDirection = vec3(u_directional[i].mtxShape * vec4(0.0, 0.0, -1.0, 1.0));
      illuminateDirected(vctLightDirection, vctViewDirection, vctNormal, u_directional[i].vctColor.rgb, vctDiffuse, vctSpecular);
    }

    // point lights
    for(uint i = 0u; i < u_nLightsPoint; i++) {
      vec3 vctLightPosition = vec3(u_point[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
      vec3 vctLightDirection = vctLightPosition - vctPosition;
      float fIntensity = 1.0 - length(mat3(u_point[i].mtxShapeInverse) * vctLightDirection);
      if(fIntensity < 0.0)
        continue;

      illuminateDirected(vctLightDirection, vctViewDirection, vctNormal, u_point[i].vctColor.rgb * fIntensity, vctDiffuse, vctSpecular);
    }

    // spot lights
    for(uint i = 0u; i < u_nLightsSpot; i++) {
      vec3 vctLightPosition = vec3(u_spot[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
      vec3 vctLightDirection = vctLightPosition - vctPosition;
      vec3 vctLightDirectionInverted = mat3(u_spot[i].mtxShapeInverse) * -vctLightDirection;
      if(vctLightDirectionInverted.z <= 0.0)
        continue;

      float fIntensity = 1.0 - min(1.0, 2.0 * length(vctLightDirectionInverted.xy) / vctLightDirectionInverted.z);    // Coneshape that is brightest in the center. Possible TODO: "Variable Spotlightsoftness"
      fIntensity *= 1.0 - pow(vctLightDirectionInverted.z, 2.0);                                                      // Prevents harsh lighting artifacts at boundary of the given spotlight
      if(fIntensity < 0.0)
        continue;

      illuminateDirected(vctLightDirection, vctViewDirection, vctNormal, u_spot[i].vctColor.rgb * fIntensity, vctDiffuse, vctSpecular);
    }

  #endif

  vec4 vctColor = u_vctColor * u_vctColorPrimary * v_vctColor;

  #if defined(GOURAUD)

    vec3 vctDiffuse = v_vctDiffuse;
    vec3 vctSpecular = v_vctSpecular;

  #endif

  #if defined(FLAT) || defined(GOURAUD) || defined(PHONG)

    vctFrag.rgb = vctDiffuse + vctSpecular * u_fMetallic;
    vctFrag.a = 1.0;

  #else

    // MINIMAL: set the base color
    vctFrag = vctColor;

  #endif

  #if defined(TEXTURE) || defined(MATCAP)
    
    // TEXTURE: multiply with texel color
    vec4 vctColorTexture = texture(u_texColor, v_vctTexture); // has premultiplied alpha by webgl for correct filtering
    if (vctColorTexture.a > 0.0) // unpremultiply alpha
      vctColorTexture.rgb /= vctColorTexture.a; 
    vctFrag *= vctColorTexture;

  #endif

  #if defined(FLAT) || defined(GOURAUD) || defined(PHONG)

    vctFrag *= vctColor;
    vctFrag.rgb += vctSpecular * (1.0 - u_fMetallic);

    vctFragPosition = vec4(v_vctPosition, 1.0);
    vctFragNormal = vec4(vctNormal, 1.0);
  
  #endif

  #if !defined(PHONG) && !defined(FLAT) && !defined(GOURAUD) // MINIMAL

    vctFragPosition = vec4(0.0, 0.0, 0.0, 1.0); // (0, 0, 0) will treat occluders as non existing in ssao
    vctFragNormal = vec4(0.0, 0.0, 0.0, 1.0); // (0, 0, 0) normal will yield not occlusion in ssao
  
  #endif

  // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < u_fAlphaClip)
    discard;

  if (u_bFogActive) {
    float fFog = getFog(v_vctPosition);
    vctFrag.rgb = mix(vctFrag.rgb, u_vctFogColor.rgb, fFog);

    #if defined(PARTICLE)

      if (u_iBlendMode == 2 || u_iBlendMode == 3 || u_iBlendMode == 4)  // for blend additive, subtractive, modulate
        vctFrag.a = mix(vctFrag.a, 0.0, fFog);                          // fade out particle when in fog to make it disappear completely

    #endif
  }
}`;
    FudgeCore.shaderSources["ShaderUniversal.vert"] = /*glsl*/ `#version 300 es
/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021 | Jonas Plotzky, HFU, 2023
*/
precision mediump float;
precision highp int;

layout(std140) uniform Node {
  uniform mat4 u_mtxMeshToWorld; // u_mtxModel
  uniform mat3 u_mtxPivot; // texture pivot matrix
  uniform vec4 u_vctColorPrimary; // component material color

  uniform int u_iBlendMode;
  uniform float u_fParticleSystemDuration;
  uniform float u_fParticleSystemSize;
  uniform float u_fParticleSystemTime;

  uniform bool u_bFaceCameraActive;
  uniform bool u_bFaceCameraRestrict;
};

layout(std140) uniform Camera {
  mat4 u_mtxWorldToCamera; // u_mtxView
  mat4 u_mtxProjection; 
  mat4 u_mtxWorldToView; // u_mtxViewProjection
  vec3 u_vctCamera;
};

layout(std140) uniform Material {
  uniform vec4 u_vctColor;

  uniform float u_fDiffuse;
  uniform float u_fSpecular;
  uniform float u_fIntensity;
  uniform float u_fMetallic;

  uniform float u_fAlphaClip;
};

layout(location = 0) in vec3 a_vctPosition;
layout(location = 3) in vec4 a_vctColor; // TODO: think about making vertex color optional

out vec3 v_vctPosition;
out vec4 v_vctColor;

#if defined(FLAT) || defined(GOURAUD) || defined(PHONG)

  layout(location = 1) in vec3 a_vctNormal;
  out vec3 v_vctNormal;

#endif

#if defined(FLAT)

  flat out vec3 v_vctPositionFlat;

#endif

#if defined(GOURAUD)

  out vec3 v_vctDiffuse;
  out vec3 v_vctSpecular;

  struct Light {
    vec4 vctColor;
    mat4 mtxShape;
    mat4 mtxShapeInverse;
  };

  const uint MAX_LIGHTS_DIRECTIONAL = 15u;
  const uint MAX_LIGHTS_POINT = 100u;
  const uint MAX_LIGHTS_SPOT = 100u;

  layout(std140) uniform Lights {
    uint u_nLightsDirectional;
    uint u_nLightsPoint;
    uint u_nLightsSpot;
    uint ligthsPadding; // Add padding to align to 16 bytes
    Light u_ambient;
    Light u_directional[MAX_LIGHTS_DIRECTIONAL];
    Light u_point[MAX_LIGHTS_POINT];
    Light u_spot[MAX_LIGHTS_SPOT];
  };

  void illuminateDirected(vec3 _vctDirection, vec3 _vctView, vec3 _vctNormal, vec3 _vctColor, inout vec3 _vctDiffuse, inout vec3 _vctSpecular) {
    vec3 vctDirection = normalize(_vctDirection);
    float fIllumination = -dot(_vctNormal, vctDirection);
    if(fIllumination > 0.0) {
      _vctDiffuse += u_fDiffuse * fIllumination * _vctColor;

      if(u_fSpecular <= 0.0)
        return;

      //BLINN
      vec3 halfwayDir = normalize(-vctDirection - _vctView);
      float factor = max(dot(-vctDirection, _vctNormal), 0.0); //Factor for smoothing out transition from surface facing the lightsource to surface facing away from the lightsource
      factor = 1.0 - (pow(factor - 1.0, 8.0));                 //The factor is altered in order to clearly see the specular highlight even at steep angles, while still preventing artifacts

      _vctSpecular += pow(max(dot(_vctNormal, halfwayDir), 0.0), exp2(u_fSpecular * 5.0)) * u_fSpecular * u_fIntensity * factor * _vctColor;

      //PHONG (old)
      // vec3 vctReflection = normalize(reflect(-vctDirection, _vctNormal));
      // float fHitCamera = dot(vctReflection, _vctView);
      // _vctSpecular += pow(max(fHitCamera, 0.0), u_fSpecular * 10.0) * u_fSpecular * _vctColor; // 10.0 = magic number, looks good... 
    }
  }

#endif

#if defined(TEXTURE) || defined(NORMALMAP)

  layout(location = 2) in vec2 a_vctTexture;
  out vec2 v_vctTexture;

#endif

#if defined(NORMALMAP)

  layout(location = 4) in vec4 a_vctTangent;
  out vec3 v_vctTangent;
  out vec3 v_vctBitangent;

#endif

// MATCAP: offer buffers for UVs and pivot matrix
#if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals

  layout(location = 1) in vec3 a_vctNormal;
  out vec2 v_vctTexture;

#endif

#if defined(SKIN)

  // Bones https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl.js
  layout(location = 5) in uvec4 a_vctBones;
  layout(location = 6) in vec4 a_vctWeights;

  const uint MAX_BONES = 256u; // CAUTION: this number must be the same as in RenderInjectorSkeletonInstance where the corresponding buffers are created
  layout(std140) uniform Skin {
    mat4 u_mtxBones[MAX_BONES];
  };

#endif



#if defined(PARTICLE)

  uniform sampler2D u_particleSystemRandomNumbers;

  float fetchRandomNumber(int _iOffset, int _iParticleSystemRandomNumbersSize, int _iParticleSystemRandomNumbersLength) {
    _iOffset = gl_InstanceID + _iOffset % _iParticleSystemRandomNumbersLength;
    return texelFetch(u_particleSystemRandomNumbers, ivec2(_iOffset % _iParticleSystemRandomNumbersSize, _iOffset / _iParticleSystemRandomNumbersSize), 0).r;
  }

#endif

mat4 lookAtCamera(mat4 _mtxWorld, bool _bRestrict) {
  vec3 vctUp = vec3(0.0, 1.0, 0.0);

  vec3 vctPosition = _mtxWorld[3].xyz;

  // vec3 zAxis = normalize(u_vctCamera - vctPosition); // look at camera position
  vec3 zAxis = normalize(-vec3(u_mtxWorldToCamera[0].z, u_mtxWorldToCamera[1].z, u_mtxWorldToCamera[2].z)); // look in camera direction

  vec3 xAxis = normalize(cross(vctUp, zAxis));
  vec3 yAxis = _bRestrict ? vctUp : normalize(cross(zAxis, xAxis));
  zAxis = _bRestrict ? normalize(cross(xAxis, vctUp)) : zAxis;

  vec3 vctScale = vec3(length(_mtxWorld[0].xyz), length(_mtxWorld[1].xyz), length(_mtxWorld[2].xyz));

  mat4 billboardMatrix = mat4(
    vec4(xAxis * vctScale.x, 0.0),
    vec4(yAxis * vctScale.y, 0.0),
    vec4(zAxis * vctScale.z, 0.0),
    vec4(vctPosition, 1.0)
  );

  return billboardMatrix;
}

void main() {

  vec4 vctPosition = vec4(a_vctPosition, 1.0);
  mat4 mtxMeshToWorld = u_mtxMeshToWorld;

  // if (u_bBillboardActive) 
  //   mtxMeshToWorld = lookAtCamera(mtxMeshToWorld, u_bBillboardRestrict);

  #if defined(PARTICLE)
  
    float fParticleId = float(gl_InstanceID);
    int iParticleSystemRandomNumbersSize = textureSize(u_particleSystemRandomNumbers, 0).x; // the dimension of the quadratic texture
    int iParticleSystemRandomNumbersLength = iParticleSystemRandomNumbersSize * iParticleSystemRandomNumbersSize; // the total number of texels in the texture
    /*$variables*/
    /*$mtxLocal*/
    /*$mtxWorld*/
    mtxMeshToWorld = /*$mtxWorld*/ mtxMeshToWorld /*$mtxLocal*/;
    if(u_bFaceCameraActive) 
      mtxMeshToWorld = lookAtCamera(mtxMeshToWorld, u_bFaceCameraRestrict);

  #endif

  #if defined(SKIN)

    mtxMeshToWorld = a_vctWeights.x * u_mtxBones[a_vctBones.x] +
      a_vctWeights.y * u_mtxBones[a_vctBones.y] +
      a_vctWeights.z * u_mtxBones[a_vctBones.z] +
      a_vctWeights.w * u_mtxBones[a_vctBones.w];

  #endif

  mat4 mtxMeshToView = u_mtxWorldToView * mtxMeshToWorld;

  #if defined(FLAT) || defined(GOURAUD) || defined(PHONG) || defined(MATCAP) // only these work with particle and skinning

    mat4 mtxNormalMeshToWorld = transpose(inverse(mtxMeshToWorld));

  #endif

  gl_Position = mtxMeshToView * vctPosition; 
  vctPosition = mtxMeshToWorld * vctPosition;

  v_vctColor = a_vctColor;
  v_vctPosition = vctPosition.xyz;

  #if defined(PARTICLE_COLOR)

    v_vctColor *= /*$color*/;

  #endif

  #if defined(FLAT)

    v_vctPositionFlat = v_vctPosition;
    
  #endif

  #if defined(FLAT) || defined(GOURAUD) || defined(PHONG)

    v_vctNormal = mat3(mtxNormalMeshToWorld) * a_vctNormal; // unnormalized as it must be normalized in the fragment shader anyway

  #endif 

  #if defined(NORMALMAP)

    v_vctTangent = mat3(mtxNormalMeshToWorld) * a_vctTangent.xyz;
    v_vctBitangent = cross(v_vctNormal, v_vctTangent) * a_vctTangent.w;

  #endif

  #if defined(GOURAUD)
  
    vec3 vctView = normalize(vctPosition.xyz - u_vctCamera);
    vec3 vctNormal = normalize(v_vctNormal);
    v_vctDiffuse = u_fDiffuse * u_ambient.vctColor.rgb;
    v_vctSpecular = vec3(0, 0, 0);

    // calculate directional light effect
    for(uint i = 0u; i < u_nLightsDirectional; i ++) {
      vec3 vctDirection = vec3(u_directional[i].mtxShape * vec4(0.0, 0.0, 1.0, 1.0));
      illuminateDirected(vctDirection, vctView, vctNormal, u_directional[i].vctColor.rgb, v_vctDiffuse, v_vctSpecular);
    }

    // calculate point light effect
    for(uint i = 0u;i < u_nLightsPoint;i ++) {
      vec3 vctPositionLight = vec3(u_point[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
      vec3 vctDirection = vctPosition.xyz - vctPositionLight;
      float fIntensity = 1.0 - length(mat3(u_point[i].mtxShapeInverse) * vctDirection);
      if(fIntensity < 0.0) continue;

      illuminateDirected(vctDirection, vctView, vctNormal, u_point[i].vctColor.rgb * fIntensity, v_vctDiffuse, v_vctSpecular);
    }

    // calculate spot light effect
    for(uint i = 0u;i < u_nLightsSpot;i ++) {
      vec3 vctPositionLight = vec3(u_spot[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
      vec3 vctDirection = vctPosition.xyz - vctPositionLight;
      vec3 vctDirectionInverted = mat3(u_spot[i].mtxShapeInverse) * vctDirection;
      if(vctDirectionInverted.z <= 0.0) continue;

      float fIntensity = 1.0 - min(1.0, 2.0 * length(vctDirectionInverted.xy) / vctDirectionInverted.z);    //Coneshape that is brightest in the center. Possible TODO: "Variable Spotlightsoftness"
      fIntensity *= 1.0 - pow(vctDirectionInverted.z, 2.0);                                                 //Prevents harsh lighting artifacts at boundary of the given spotlight
      if(fIntensity < 0.0) continue;

      illuminateDirected(vctDirection, vctView, vctNormal, u_spot[i].vctColor.rgb * fIntensity, v_vctDiffuse, v_vctSpecular);
    }

  #endif

    // TEXTURE: transform UVs
  #if defined(TEXTURE) || defined(NORMALMAP)

    v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;

  #endif

  #if defined(MATCAP)

    vec4 vctVertexInCamera = normalize(u_mtxWorldToCamera * vctPosition);
    vctVertexInCamera.xy *= - 1.0;
    mat4 mtx_RotX = mat4(1, 0, 0, 0, 0, vctVertexInCamera.z, vctVertexInCamera.y, 0, 0, - vctVertexInCamera.y, vctVertexInCamera.z, 0, 0, 0, 0, 1);
    mat4 mtx_RotY = mat4(vctVertexInCamera.z, 0, - vctVertexInCamera.x, 0, 0, 1, 0, 0, vctVertexInCamera.x, 0, vctVertexInCamera.z, 0, 0, 0, 0, 1);

    vec3 vctNormal = mat3(mtxNormalMeshToWorld) * a_vctNormal;

    // adds correction for things being far and to the side, but distortion for things being close
    vctNormal = mat3(mtx_RotX * mtx_RotY) * vctNormal;

    vec3 vctReflection = normalize(mat3(u_mtxWorldToCamera) * normalize(vctNormal));
    vctReflection.y = - vctReflection.y;

    v_vctTexture = 0.5 * vctReflection.xy + 0.5;

  #endif
}`;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Coat/Coat.ts"/>
var FudgeCore;
// / <reference path="../Coat/Coat.ts"/>
(function (FudgeCore) {
    /**
     * Static superclass for the representation of WebGl shaderprograms.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    // TODO: define uniforms as layout and use those consistently in shaders
    let Shader = (() => {
        var _a;
        let _classDecorators = [(_a = FudgeCore.RenderInjectorShader).decorate.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        var Shader = class {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                Shader = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
            static { this.baseClass = Shader; }
            /** list of all the subclasses derived from this class, if they registered properly*/
            static { this.subclasses = []; }
            /** The type of coat that can be used with this shader to create a material */
            static getCoat() { return FudgeCore.CoatColored; }
            /** Returns the vertex shader source code for the render engine */
            static getVertexShaderSource() {
                return this.insertDefines(FudgeCore.shaderSources["ShaderUniversal.vert"], this.define);
            }
            /** Returns the fragment shader source code for the render engine */
            static getFragmentShaderSource() {
                return this.insertDefines(FudgeCore.shaderSources["ShaderUniversal.frag"], this.define);
            }
            /** @internal Injected by {@link RenderInjectorShader}. Used by the render system. */
            static deleteProgram() { }
            /** @internal Injected by {@link RenderInjectorShader}. Used by the render system. */
            static useProgram() { }
            /** @internal Injected by {@link RenderInjectorShader}. Used by the render system. */ // TODO: maybe don't flag this as internal, so shaders can be precompiled in future FUDGE apps. Or create an API to precompile shaders, load textures etc.
            static createProgram() { }
            static registerSubclass(_subclass) { return Shader.subclasses.push(_subclass) - 1; }
            // replace the mandatory header of the shader with itself plus the definitions given
            static insertDefines(_shader, _defines) {
                if (!_defines)
                    return _shader;
                let code = "#version 300 es\n";
                for (let define of _defines)
                    code += `#define ${define}\n`;
                return _shader.replace("#version 300 es", code);
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return Shader = _classThis;
    })();
    FudgeCore.Shader = Shader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderAmbientOcclusion extends FudgeCore.Shader {
        static { this.define = []; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderScreen.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderAmbientOcclusion.frag"], this.define);
        }
    }
    FudgeCore.ShaderAmbientOcclusion = ShaderAmbientOcclusion;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderBloom extends FudgeCore.Shader {
        static { this.define = []; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderScreen.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderBloom.frag"], this.define);
        }
    }
    FudgeCore.ShaderBloom = ShaderBloom;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderFlat extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlat); }
        static { this.define = [
            "FLAT"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
    }
    FudgeCore.ShaderFlat = ShaderFlat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderFlatSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlatSkin); }
        static { this.define = [
            "FLAT",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
    }
    FudgeCore.ShaderFlatSkin = ShaderFlatSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderFlatTextured extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlatTextured); }
        static { this.define = [
            "FLAT",
            "TEXTURE"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
    }
    FudgeCore.ShaderFlatTextured = ShaderFlatTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderFlatTexturedSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlatTexturedSkin); }
        static { this.define = [
            "FLAT",
            "TEXTURE",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
    }
    FudgeCore.ShaderFlatTexturedSkin = ShaderFlatTexturedSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGizmo extends FudgeCore.Shader {
        static { this.define = []; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderGizmo.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderGizmo.frag"], this.define);
        }
    }
    FudgeCore.ShaderGizmo = ShaderGizmo;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGizmoTextured extends FudgeCore.Shader {
        static { this.define = ["TEXTURE"]; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderGizmo.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderGizmo.frag"], this.define);
        }
    }
    FudgeCore.ShaderGizmoTextured = ShaderGizmoTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGouraud extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraud); }
        static { this.define = [
            "GOURAUD"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
    }
    FudgeCore.ShaderGouraud = ShaderGouraud;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGouraudSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraudSkin); }
        static { this.define = [
            "GOURAUD",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
    }
    FudgeCore.ShaderGouraudSkin = ShaderGouraudSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGouraudTextured extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraudTextured); }
        static { this.define = [
            "GOURAUD",
            "TEXTURE"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
    }
    FudgeCore.ShaderGouraudTextured = ShaderGouraudTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGouraudTexturedSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraudTexturedSkin); }
        static { this.define = [
            "GOURAUD",
            "TEXTURE",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
    }
    FudgeCore.ShaderGouraudTexturedSkin = ShaderGouraudTexturedSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderLit extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLit); }
        static { this.define = []; }
    }
    FudgeCore.ShaderLit = ShaderLit;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderLitSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLitSkin); }
        static { this.define = [
            "SKIN"
        ]; }
    }
    FudgeCore.ShaderLitSkin = ShaderLitSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderLitTextured extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLitTextured); }
        static { this.define = [
            "TEXTURE"
        ]; }
        static getCoat() { return FudgeCore.CoatTextured; }
    }
    FudgeCore.ShaderLitTextured = ShaderLitTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderLitTexturedSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLitTexturedSkin); }
        static { this.define = [
            "TEXTURE",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatTextured; }
    }
    FudgeCore.ShaderLitTexturedSkin = ShaderLitTexturedSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderMatCap extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderMatCap); }
        static { this.define = [
            "MATCAP"
        ]; }
        static getCoat() { return FudgeCore.CoatTextured; }
    }
    FudgeCore.ShaderMatCap = ShaderMatCap;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderOutline extends FudgeCore.Shader {
        static { this.define = []; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderScreen.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderOutline.frag"], this.define);
        }
    }
    FudgeCore.ShaderOutline = ShaderOutline;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhong extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhong); }
        static { this.define = [
            "PHONG"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
    }
    FudgeCore.ShaderPhong = ShaderPhong;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhongSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhongSkin); }
        static { this.define = [
            "PHONG",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
    }
    FudgeCore.ShaderPhongSkin = ShaderPhongSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhongTextured extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhongTextured); }
        static { this.define = [
            "PHONG",
            "TEXTURE"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
    }
    FudgeCore.ShaderPhongTextured = ShaderPhongTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhongTexturedNormals extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhongTexturedNormals); }
        static { this.define = [
            "PHONG",
            "TEXTURE",
            "NORMALMAP"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTexturedNormals; }
    }
    FudgeCore.ShaderPhongTexturedNormals = ShaderPhongTexturedNormals;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhongTexturedNormalsSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhongTexturedNormalsSkin); }
        static { this.define = [
            "PHONG",
            "TEXTURE",
            "NORMALMAP",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTexturedNormals; }
    }
    FudgeCore.ShaderPhongTexturedNormalsSkin = ShaderPhongTexturedNormalsSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhongTexturedSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhongTexturedSkin); }
        static { this.define = [
            "PHONG",
            "TEXTURE",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
    }
    FudgeCore.ShaderPhongTexturedSkin = ShaderPhongTexturedSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPick extends FudgeCore.Shader {
        static { this.define = []; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPick.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPick.frag"], this.define);
        }
    }
    FudgeCore.ShaderPick = ShaderPick;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPickTextured extends FudgeCore.Shader {
        static { this.define = ["TEXTURE"]; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPick.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPick.frag"], this.define);
        }
    }
    FudgeCore.ShaderPickTextured = ShaderPickTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderToon extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderToon); }
        static { this.define = [
            "PHONG",
            "TOON"
        ]; }
        static getCoat() { return FudgeCore.CoatToon; }
    }
    FudgeCore.ShaderToon = ShaderToon;
    class ShaderToonSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderToonSkin); }
        static { this.define = [
            "PHONG",
            "TOON",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatToon; }
    }
    FudgeCore.ShaderToonSkin = ShaderToonSkin;
    class ShaderToonTextured extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderToonTextured); }
        static { this.define = [
            "PHONG",
            "TOON",
            "TEXTURE"
        ]; }
        static getCoat() { return FudgeCore.CoatToonTextured; }
    }
    FudgeCore.ShaderToonTextured = ShaderToonTextured;
    class ShaderToonTexturedSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderToonTexturedSkin); }
        static { this.define = [
            "PHONG",
            "TOON",
            "TEXTURE",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatToonTextured; }
    }
    FudgeCore.ShaderToonTexturedSkin = ShaderToonTexturedSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class TextureDefault extends FudgeCore.TextureBase64 {
        static { this.color = new TextureDefault("TextureDefault", TextureDefault.getColor(), FudgeCore.MIPMAP.MEDIUM); }
        static { this.normal = new TextureDefault("TextureNormalDefault", TextureDefault.getNormal(), FudgeCore.MIPMAP.MEDIUM); }
        static { this.toon = new TextureDefault("TextureToonDefault", TextureDefault.getToon(), FudgeCore.MIPMAP.SMOOTH, FudgeCore.WRAP.CLAMP); }
        // TODO: maybe make these lazy
        static { this.iconLight = new TextureDefault("IconDefaultLight", TextureDefault.getIconLight(), FudgeCore.MIPMAP.BLURRY, FudgeCore.WRAP.CLAMP, 256, 256); }
        static { this.iconCamera = new TextureDefault("IconDefaultCamera", TextureDefault.getIconCamera(), FudgeCore.MIPMAP.BLURRY, FudgeCore.WRAP.CLAMP, 256, 256); }
        static { this.iconAudio = new TextureDefault("IconDefaultAudio", TextureDefault.getIconAudio(), FudgeCore.MIPMAP.BLURRY, FudgeCore.WRAP.CLAMP, 256, 256); }
        // public static iconParticles: TextureBase64 = new TextureDefault("IconDefaultParticle", TextureDefault.getIconParticles(), MIPMAP.BLURRY, 256, 256);
        static getColor() {
            return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGQCAYAAACAvzbMAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAADWLSURBVHhe7d0HnFTlvf/xH9uXZYGl9yrSRJpEUexYsJIba8Re498WNcZEb+41epOIsWs0Niyxm2g0duwaewO7oqJCAGnSt7H/8304B4dldpk5Z3b3zO7nzeu85pwzM8vMs7PPb35PO61qPBZjrVq18vfiKebFR/lFRPlFQ/lFE/fyy/FvAQBICwEEABAKAQQAEAp9IBHRhhoN5RcN5RdNSyg//YzCwkJr3bq1O169erXbMoEAEhF/wNFQftFQftE09/LLzc21Ll262E9+8hMbP368VVdX2+uvv27Tp093QSTq+yeARMQfcDSUXzSUXzTNtfxycnKspKTEBg0aZEceeaQdeuihtmLFCvvss89s3rx59vjjj9vDDz8cOROJHECqqqps9uzZtmzZMlu5cqVLldq1a2d9+/Z1+1HxAYyG8ouG8ouG8osmTPnl5+db9+7dbffdd7dTTz3V1cXvvvuuvfzyyy4DkVWrVtmNN95oS5YsccdhhQ4g5eXl9uyzz9qMGTNszZo1/tkfKQIq+u29995WWlrqn00fH8BoKL9oKL9oKL9o0ik/PbZNmza2xRZb2HHHHWeTJ0+2hQsX2pNPPmmLFy/2H7XOf/7zH7v11ltdPR5FqACyYMECu+eee1KKXmvXrrX99tvPRo8e7YJKuvgARkP5RROUnz67+iKUl5dnlZWVtnz58li8dj5/0TSn8lOT1b777msXXHCBde7c2V577TV78803k77Hb7/91u644w6rqKjwz4STdgBRtqHUJ4hoChCffPKJffXVV649rX379jZgwAC3BZQuTZo0ybbbbjuXXqWDD2A0lF80Qfl17NjRjjnmGOvUqZN988039sADD7gvUk39+vn8RdOcyq9r1642depU23rrre3RRx91X3JEdbSasIqLi23YsGHuXKYCSNopgXrvg+Ch/o/77rvPvVi9+J///Od29NFH29ChQ90LDGj4mNIlBZm4/8LQssycOdM1xb766qtJm2JF2UfPnj3t17/+tU2YMMF23XVXO/bYY11QQfM1f/58u+mmm1zfgfp44071sV6zPstB8FA9rC/8Tz31lOsXybS0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";
        }
        static getNormal() {
            return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAFDmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgeG1wOkNyZWF0ZURhdGU9IjIwMjMtMDUtMDZUMjI6Mjg6MDYrMDIwMCIKICAgeG1wOk1vZGlmeURhdGU9IjIwMjMtMDUtMDZUMjI6MzA6MjErMDI6MDAiCiAgIHhtcDpNZXRhZGF0YURhdGU9IjIwMjMtMDUtMDZUMjI6MzA6MjErMDI6MDAiCiAgIHBob3Rvc2hvcDpEYXRlQ3JlYXRlZD0iMjAyMy0wNS0wNlQyMjoyODowNiswMjAwIgogICBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIgogICBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiCiAgIGV4aWY6UGl4ZWxYRGltZW5zaW9uPSIxIgogICBleGlmOlBpeGVsWURpbWVuc2lvbj0iMSIKICAgZXhpZjpDb2xvclNwYWNlPSIxIgogICB0aWZmOkltYWdlV2lkdGg9IjEiCiAgIHRpZmY6SW1hZ2VMZW5ndGg9IjEiCiAgIHRpZmY6UmVzb2x1dGlvblVuaXQ9IjIiCiAgIHRpZmY6WFJlc29sdXRpb249IjcyLzEiCiAgIHRpZmY6WVJlc29sdXRpb249IjcyLzEiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJwcm9kdWNlZCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWZmaW5pdHkgUGhvdG8gMiAyLjAuNCIKICAgICAgc3RFdnQ6d2hlbj0iMjAyMy0wNS0wNlQyMjozMDoyMSswMjowMCIvPgogICAgPC9yZGY6U2VxPgogICA8L3htcE1NOkhpc3Rvcnk+CiAgPC9yZGY6RGVzY3JpcHRpb24+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+0IgVxAAAAYBpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHPK0RRFMc/M37mR6NYKBYvDauhQYmNxcivwmKMMtjMvPml5o3Xe2/SZKtsFSU2fi34C9gqa6WIlGxZExv0nOepkcy5nXs+93vvOd17LngjWVUzy4Og5SwjPBpSZqNzStUjFVTSRAu+mGrqk9MjEUra2w0eJ151OrVKn/vXahNJUwVPtfCgqhuW8JjwxLKlO7wp3KRmYgnhY+GAIRcUvnb0uMtPDqdd/nDYiISHwNsgrKR/cfwXqxlDE5aX49eyefXnPs5L6pK5mWmJbeKtmIQZJYTCOMMM0Uc3AzL30UkPXbKiRH7wO3+KJclVZdYpYLBImgwWAVHzUj0pMSV6UkaWgtP/v301U709bvW6EFQ82PZLO1RtwOe6bb/v2/bnAZTdw1mumL+0B/2voq8XNf8u+Fbh5LyoxbfgdA2a7/SYEfuWysS9qRQ8H0F9FBovoWbe7dnPPoe3EFmRr7qA7R3okPO+hS824WfQgxGCcgAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAxJREFUCJljaGj4DwADgwIAVbjWPwAAAABJRU5ErkJggg==";
        }
        static getToon() {
            return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAP8AAAABCAYAAAARkHijAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV/TSotUBO0g4pChOtlFRRxLFYtgobQVWnUwufQLmjQkKS6OgmvBwY/FqoOLs64OroIg+AHi7OCk6CIl/i8ptIjx4Lgf7+497t4BQqvGVDMQB1TNMjLJhJgvrIrBVwQRQBghDEnM1FPZxRw8x9c9fHy9i/Es73N/jgGlaDLAJxLHmW5YxBvEs5uWznmfOMIqkkJ8Tjxp0AWJH7kuu/zGueywwDMjRi4zTxwhFss9LPcwqxgq8QxxVFE1yhfyLiuctzirtQbr3JO/MFzUVrJcpzmGJJaQQhoiZDRQRQ0WYrRqpJjI0H7Cwz/q+NPkkslVBSPHAupQITl+8D/43a1Zmp5yk8IJoO/Ftj/GgeAu0G7a9vexbbdPAP8zcKV1/fUWMPdJerOrRY+AwW3g4rqryXvA5Q4w8qRLhuRIfppCqQS8n9E3FYDhW6B/ze2ts4/TByBHXS3fAAeHwESZstc93h3q7e3fM53+fgA4OXKPt/7K/gAAAAZiS0dEAP8AAAAAMyd88wAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+gHBAwdJ1j9WBsAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAVUlEQVQoz2NkYGD4zzAKhh5gZWBg4GBgYOBEo2FsKJ+Xk4FBipOBQZoDQktxMjCIsDEwSHFAMReE5sVmDhcWO1gYGBgYGMlINvj0MI7wZEis/6kbhgC04Qj/w7/HZgAAAABJRU5ErkJggg==";
        }
        static getIconLight() {
            return "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3Csvg viewBox='0 0 16 16' version='1.1' width='16' height='16' id='Light' xmlns='http://www.w3.org/2000/svg'%3E%3Cstyle%3E .s%7Bfill:%23fff;stroke:%23000;stroke-width:.1px;%7D %3C/style%3E%3Crect class='s' x='0.17039293' y='10.002448' width='3.9000568' height='0.90009934' id='NNE' transform='rotate(-67.5)' /%3E%3Crect x='8.8295078' y='10.002447' width='3.9000568' height='0.90009934' id='ENE' transform='rotate(-22.5)' class='s' /%3E%3Crect x='14.952469' y='3.8795717' width='3.9000139' height='0.90009987' id='ESE' transform='rotate(22.5)' class='s' /%3E%3Crect x='14.95247' y='-4.7795429' width='3.9000139' height='0.90009987' id='SSE' transform='rotate(67.5)' class='s' /%3E%3Crect x='-12.729565' y='10.002447' width='3.9000139' height='0.90009987' id='SSW' transform='rotate(-67.5)' class='s' /%3E%3Crect x='-4.0704498' y='10.002447' width='3.9000139' height='0.90009987' id='WSW' transform='rotate(-22.5)' class='s' /%3E%3Crect x='2.0524685' y='3.8795717' width='3.9000139' height='0.90009987' id='WNW' transform='rotate(22.5)' class='s' /%3E%3Crect x='2.0524685' y='-4.7795429' width='3.9000139' height='0.90009987' id='NNW' transform='rotate(67.5)' class='s' /%3E%3Cellipse id='CENTER' cx='8.000082' cy='8.0002575' rx='3.4500823' ry='3.4502573' class='s' /%3E%3C/svg%3E";
        }
        static getIconCamera() {
            return "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3Csvg id='Camera' viewBox='0 0 16 16' version='1.1' width='16' height='16' xmlns='http://www.w3.org/2000/svg'%3E%3Cstyle id='style1'%3E.s%7Bfill:%23fff;stroke:%23000;stroke-width:.1px;%7D %3C/style%3E%3Cpath class='s' d='M 13.857322,8.8755297 H 12.413424 L 12.413,6.787 h -1.425311 c 0.227026,-0.4494693 0.363243,-0.9453919 0.363243,-1.4885008 0,-1.7978775 -1.4075727,-3.2492893 -3.1511466,-3.2492893 -1.7435746,0 -3.1511479,1.4514118 -3.1511479,3.2492893 v 0.028093 C 4.5764194,5.0363118 4.0315524,4.8583968 3.4503606,4.8583968 1.7067863,4.8677567 0.29921298,6.3191723 0.29921298,8.107686 c 0,1.7885135 1.66538582,3.311789 3.42458512,3.249289 L 3.732,13.976 h 8.681 v -2.113368 h 1.444322 z' id='path1' /%3E%3Crect class='s' x='12.80391' y='8.3979683' width='2.8968766' height='3.8860376' rx='0' ry='0' id='rect1' /%3E%3C/svg%3E%0A";
        }
        static getIconAudio() {
            return "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3Csvg id='Audio' viewBox='0 0 16 16' version='1.1' width='16' height='16' xmlns='http://www.w3.org/2000/svg'%3E%3Cstyle%3E.s%7Bfill:%23fff;stroke:%23000;stroke-width:.1px;%7D %3C/style%3E%3Cpath class='s' d='M 9.1563588,1.0804006 3.6729341,4.642017 H 0.54364971 v 6.784031 H 3.7590612 l 5.3972976,3.493776 z' id='path1' /%3E%3Cpath class='s' d='m 13.347518,13.676645 -0.765157,-0.563566 c 4.227485,-5.5605241 0.210418,-9.881202 0.03825,-10.0596648 l 0.698204,-0.6481019 c 0.04782,0.046964 4.75353,5.0627076 0.03825,11.2713327 z' id='path2' /%3E%3Cpath class='s' d='m 11.321868,11.79809 -0.822541,-0.479032 c 2.142434,-3.5786474 0.114773,-6.35891 0.02869,-6.4716232 l 0.765156,-0.5635666 c 0.105208,0.1408915 2.505883,3.3814001 0.02869,7.5048298 z' id='path3' /%3E%3C/svg%3E%0A";
        }
    }
    FudgeCore.TextureDefault = TextureDefault;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
var FudgeCore;
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
(function (FudgeCore) {
    /**
     * Determines the mode a loop runs in
     */
    let LOOP_MODE;
    (function (LOOP_MODE) {
        /** Loop cycles controlled by window.requestAnimationFrame */
        LOOP_MODE["FRAME_REQUEST"] = "frameRequest";
        /** Loop cycles controlled by xrSession.requestAnimationFrame */
        LOOP_MODE["FRAME_REQUEST_XR"] = "frameRequestXR";
        /** Loop cycles with the given framerate in {@link Time.game} */
        LOOP_MODE["TIME_GAME"] = "timeGame";
        /** Loop cycles with the given framerate in realtime, independent of {@link Time.game} */
        LOOP_MODE["TIME_REAL"] = "timeReal";
    })(LOOP_MODE = FudgeCore.LOOP_MODE || (FudgeCore.LOOP_MODE = {}));
    /**
     * Core loop of a FUDGE application. Initializes automatically and must be started explicitly.
     * It then fires {@link EVENT.LOOP_FRAME} to all added listeners at each frame
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Loop extends FudgeCore.EventTargetStatic {
        static { this.∆íTimeStartGame = 0; }
        static { this.∆íTimeStartReal = 0; }
        static { this.∆íTimeFrameGame = 0; }
        static { this.∆íTimeFrameReal = 0; }
        static { this.∆íTimeFrameStartGame = 0; }
        static { this.∆íTimeFrameStartReal = 0; }
        static { this.∆íTimeLastFrameGameAvg = 0; }
        static { this.∆íTimeLastFrameRealAvg = 0; }
        static { this.∆íFrames = 0; }
        static { this.running = false; }
        static { this.mode = LOOP_MODE.FRAME_REQUEST; }
        static { this.idIntervall = 0; }
        static { this.idRequest = 0; }
        static { this.fpsDesired = 30; }
        static { this.framesToAverage = 30; }
        static { this.syncWithAnimationFrame = false; }
        /** The gametime the loop was started, overwritten at each start */
        static get timeStartGame() { return Loop.∆íTimeStartGame; }
        /** The realtime the loop was started, overwritten at each start */
        static get timeStartReal() { return Loop.∆íTimeStartReal; }
        /** The gametime elapsed since the last loop cycle */
        static get timeFrameGame() { return Loop.∆íTimeFrameGame; }
        /** The realtime elapsed since the last loop cycle */
        static get timeFrameReal() { return Loop.∆íTimeFrameReal; }
        /** The gametime the last loop cycle started*/
        static get timeFrameStartGame() { return Loop.∆íTimeFrameStartGame; }
        /** The realtime the last loop cycle started*/
        static get timeFrameStartReal() { return Loop.∆íTimeFrameStartReal; }
        /** The average number of frames per second in gametime */
        static get fpsGameAverage() { return 1000 / Loop.∆íTimeLastFrameGameAvg; }
        /** The average number of frames per second in realtime */
        static get fpsRealAverage() { return 1000 / Loop.∆íTimeLastFrameRealAvg; }
        /** The number of frames triggered so far */
        static get frames() { return Loop.∆íFrames; }
        /**
         * Starts the loop with the given mode and fps.
         * The default for _mode is FRAME_REQUEST, see {@link LOOP_MODE}, hooking the loop to the browser's animation frame.
         * Is only applicable in TIME-modes.
         * _syncWithAnimationFrame is experimental and only applicable in TIME-modes, deferring the loop-cycle until the next possible animation frame.
         */
        static start(_mode = LOOP_MODE.FRAME_REQUEST, _fps = 60, _syncWithAnimationFrame = false) {
            Loop.stop();
            Loop.∆íTimeStartGame = FudgeCore.Time.game.get();
            Loop.∆íTimeStartReal = performance.now();
            Loop.∆íTimeFrameStartGame = Loop.∆íTimeStartGame;
            Loop.∆íTimeFrameStartReal = Loop.∆íTimeStartReal;
            Loop.fpsDesired = (_mode == LOOP_MODE.FRAME_REQUEST) ? 60 : _fps;
            Loop.framesToAverage = Loop.fpsDesired;
            Loop.∆íTimeLastFrameGameAvg = Loop.∆íTimeLastFrameRealAvg = 1000 / Loop.fpsDesired;
            Loop.mode = _mode;
            Loop.syncWithAnimationFrame = _syncWithAnimationFrame;
            let log = `Loop starting in mode ${Loop.mode}`;
            if (Loop.mode != LOOP_MODE.FRAME_REQUEST)
                log += ` with attempted ${_fps} fps`;
            FudgeCore.Debug.fudge(log);
            switch (_mode) {
                case LOOP_MODE.FRAME_REQUEST:
                    Loop.loopFrame();
                    break;
                case LOOP_MODE.FRAME_REQUEST_XR:
                    Loop.loopFrameXR();
                    break;
                case LOOP_MODE.TIME_REAL:
                    Loop.idIntervall = window.setInterval(Loop.loopTime, 1000 / Loop.fpsDesired);
                    Loop.loopTime();
                    break;
                case LOOP_MODE.TIME_GAME:
                    Loop.idIntervall = FudgeCore.Time.game.setTimer(1000 / Loop.fpsDesired, 0, Loop.loopTime);
                    Loop.loopTime();
                    break;
                default:
                    break;
            }
            Loop.running = true;
        }
        /**
         * Stops the loop
         */
        static stop() {
            if (!Loop.running)
                return;
            switch (Loop.mode) {
                case LOOP_MODE.FRAME_REQUEST:
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                case LOOP_MODE.FRAME_REQUEST_XR:
                    FudgeCore.XRViewport.default.session.cancelAnimationFrame(Loop.idRequest);
                    FudgeCore.XRViewport.default.session = null;
                    break;
                case LOOP_MODE.TIME_REAL:
                    window.clearInterval(Loop.idIntervall);
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                case LOOP_MODE.TIME_GAME:
                    FudgeCore.Time.game.deleteTimer(Loop.idIntervall);
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                default:
                    break;
            }
            Loop.running = false;
            FudgeCore.Debug.fudge("Loop stopped!");
        }
        /**
         * Continue running the loop
         */
        static continue() {
            if (Loop.running)
                return;
            Loop.start(Loop.mode, Loop.fpsDesired, Loop.syncWithAnimationFrame);
        }
        static loop() {
            FudgeCore.PerformanceMonitor.startFrame();
            let time;
            time = performance.now();
            Loop.∆íTimeFrameReal = time - Loop.∆íTimeFrameStartReal;
            Loop.∆íTimeFrameStartReal = time;
            time = FudgeCore.Time.game.get();
            Loop.∆íTimeFrameGame = time - Loop.∆íTimeFrameStartGame;
            Loop.∆íTimeFrameStartGame = time;
            Loop.∆íTimeLastFrameGameAvg = ((Loop.framesToAverage - 1) * Loop.∆íTimeLastFrameGameAvg + Loop.∆íTimeFrameGame) / Loop.framesToAverage;
            Loop.∆íTimeLastFrameRealAvg = ((Loop.framesToAverage - 1) * Loop.∆íTimeLastFrameRealAvg + Loop.∆íTimeFrameReal) / Loop.framesToAverage;
            // TODO: consider LoopEvent which conveys information such as timeElapsed etc...
            Loop.∆íFrames++;
            let event = new Event("loopFrame" /* EVENT.LOOP_FRAME */);
            Loop.targetStatic.dispatchEvent(event);
            FudgeCore.PerformanceMonitor.endFrame();
        }
        static loopFrame() {
            Loop.loop();
            Loop.idRequest = window.requestAnimationFrame(Loop.loopFrame);
        }
        static loopFrameXR(_time = null, _xrFrame = null) {
            Loop.loop();
            FudgeCore.XRViewport.default.draw(true, _xrFrame);
            Loop.idRequest = FudgeCore.XRViewport.default.session.requestAnimationFrame(Loop.loopFrameXR);
        }
        static loopTime() {
            if (Loop.syncWithAnimationFrame)
                Loop.idRequest = window.requestAnimationFrame(Loop.loop);
            else
                Loop.loop();
        }
    }
    FudgeCore.Loop = Loop;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Instances of this class generate a timestamp that correlates with the time elapsed since the start of the program but allows for resetting and scaling.
     * Supports {@link Timer}s similar to window.setInterval but with respect to the scaled time.
     * All time values are given in milliseconds
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Time extends FudgeCore.EventTargetUnified {
        /** Standard game time starting automatically with the application */
        static { this.game = new Time(); }
        constructor() {
            super();
            this.timers = {};
            this.idTimerAddedLast = 0;
            this.start = performance.now();
            this.scale = 1.0;
            this.offset = 0.0;
            this.lastCallToElapsed = 0.0;
        }
        /**
         * Returns representions of the time given in milliseconds in various formats defined in {@link TimeUnits}
         */
        static getUnits(_milliseconds) {
            let units = {};
            units.asSeconds = _milliseconds / 1000;
            units.asMinutes = units.asSeconds / 60;
            units.asHours = units.asMinutes / 60;
            units.hours = Math.floor(units.asHours);
            units.minutes = Math.floor(units.asMinutes) % 60;
            units.seconds = Math.floor(units.asSeconds) % 60;
            units.fraction = _milliseconds % 1000;
            units.thousands = _milliseconds % 10;
            units.hundreds = _milliseconds % 100 - units.thousands;
            units.tenths = units.fraction - units.hundreds - units.thousands;
            return units;
        }
        //#region Get/Set time and scaling
        /**
         * Retrieves the current scaled timestamp of this instance in milliseconds
         */
        get() {
            return this.offset + this.scale * (performance.now() - this.start);
        }
        /**
         * Returns the remaining time to the given point of time
         */
        getRemainder(_to) {
            return _to - this.get();
        }
        /**
         * (Re-) Sets the timestamp of this instance
         * @param _time The timestamp to represent the current time (default 0.0)
         */
        set(_time = 0) {
            this.offset = _time;
            this.start = performance.now();
            this.getElapsedSincePreviousCall();
        }
        /**
         * Sets the scaling of this time, allowing for slowmotion (<1) or fastforward (>1)
         * @param _scale The desired scaling (default 1.0)
         */
        setScale(_scale = 1.0) {
            this.set(this.get());
            this.scale = _scale;
            //TODO: catch scale=0
            this.rescaleAllTimers();
            this.getElapsedSincePreviousCall();
            this.dispatchEvent(new Event("timeScaled" /* EVENT.TIME_SCALED */));
        }
        /**
         * Retrieves the current scaling of this time
         */
        getScale() {
            return this.scale;
        }
        /**
         * Retrieves the offset of this time
         */
        getOffset() {
            return this.offset;
        }
        /**
         * Retrieves the scaled time in milliseconds passed since the last call to this method
         * Automatically reset at every call to set(...) and setScale(...)
         */
        getElapsedSincePreviousCall() {
            let current = this.get();
            let elapsed = current - this.lastCallToElapsed;
            this.lastCallToElapsed = current;
            return elapsed;
        }
        //#endregion
        //#region Timers
        /**
         * Returns a Promise<void> to be resolved after the time given. To be used with async/await
         */
        delay(_lapse) {
            return new Promise(_resolve => this.setTimer(_lapse, 1, () => _resolve()));
        }
        // TODO: examine if web-workers would enhance performance here!
        /**
         * Stops and deletes all {@link Timer}s attached. Should be called before this Time-object leaves scope
         */
        clearAllTimers() {
            for (let id in this.timers) {
                this.deleteTimer(Number(id));
            }
        }
        /**
         * Deletes {@link Timer} found using the internal id of the connected interval-object
         * @param _id
         */
        deleteTimerByItsInternalId(_id) {
            for (let id in this.timers) {
                let timer = this.timers[id];
                if (timer.id == _id) {
                    timer.clear();
                    delete this.timers[id];
                    // TODO: check if an early out is OK here... should be!
                }
            }
        }
        /**
         * Installs a timer at this time object
         * @param _lapse The object-time to elapse between the calls to _callback
         * @param _count The number of calls desired, 0 = Infinite
         * @param _handler The function to call each the given lapse has elapsed
         * @param _arguments Additional parameters to pass to callback function
         */
        setTimer(_lapse, _count, _handler, ..._arguments) {
            // tslint:disable-next-line: no-unused-expression
            new FudgeCore.Timer(this, _lapse, _count, _handler, ..._arguments);
            //this.addTimer(timer);
            return this.idTimerAddedLast;
        }
        /**
         * This method is called internally by {@link Time} and {@link Timer} and must not be called otherwise
         */
        addTimer(_timer) {
            this.timers[++this.idTimerAddedLast] = _timer;
            return this.idTimerAddedLast;
        }
        /**
         * Deletes the timer with the id given by this time object
         */
        deleteTimer(_id) {
            let timer = this.timers[_id];
            if (!timer)
                return;
            timer.clear();
            delete this.timers[_id];
        }
        /**
         * Returns a reference to the timer with the given id or null if not found.
         */
        getTimer(_id) {
            return this.timers[_id];
        }
        /**
         * Returns a copy of the list of timers currently installed on this time object
         */
        getTimers() {
            let result = {};
            return Object.assign(result, this.timers);
        }
        /**
         * Returns true if there are {@link Timers} installed to this
         */
        hasTimers() {
            return (Object.keys(this.timers).length > 0);
        }
        /**
         * Recreates {@link Timer}s when scaling changes
         */
        rescaleAllTimers() {
            for (let id in this.timers) {
                let timer = this.timers[id];
                timer.clear();
                delete this.timers[id];
                if (!this.scale)
                    // Time has stopped, no need to replace cleared timers
                    continue;
                /* this.timers[id] =  */
                timer = timer.installCopy(); // the timer is automatically added to this time instance
                delete this.timers[this.idTimerAddedLast]; // remove the copy again ...
                this.timers[id] = timer; // ... and place it at the id of the original
            }
        }
    }
    FudgeCore.Time = Time;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Timer}-instance internally uses window.setInterval to call a given handler with a given frequency a given number of times,
     * passing an {@link EventTimer}-instance with additional information and given arguments.
     * The frequency scales with the {@link Time}-instance the {@link Timer}-instance is attached to.
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Timer {
        /**
         * Creates a {@link Timer} instance.
         * @param _time The {@link Time} instance, the timer attaches to
         * @param _elapse The time in milliseconds to elapse, to the next call of _handler, measured in _time
         * @param _count The desired number of calls to _handler, Timer deinstalls automatically after last call. Passing 0 invokes infinite calls
         * @param _handler The {@link TimerHandler} instance to call
         * @param _arguments Additional arguments to pass to _handler
         *
         * TODO: for proper handling and deletion, use Time.setTimer instead of instantiating timers yourself.
         */
        constructor(_time, _elapse, _count, _handler, ..._arguments) {
            this.time = _time;
            this.elapse = _elapse;
            this.event = new FudgeCore.EventTimer(this, ..._arguments);
            this.handler = _handler;
            this.count = _count;
            let scale = Math.abs(_time.getScale());
            if (!scale) {
                // Time is stopped, timer won't be active
                this.active = false;
                return;
            }
            this.timeoutReal = this.elapse / scale;
            let callback = () => {
                if (!this.active)
                    return;
                this.event.count = this.count;
                this.event.lastCall = (this.count == 1);
                _handler(this.event);
                this.event.firstCall = false;
                if (this.count > 0)
                    if (--this.count == 0)
                        _time.deleteTimerByItsInternalId(this.idWindow);
            };
            this.idWindow = window.setInterval(callback, this.timeoutReal, ..._arguments);
            this.active = true;
            _time.addTimer(this);
        }
        /**
         * Returns the window-id of the timer, which was returned by setInterval
         */
        get id() {
            return this.idWindow;
        }
        /**
         * Returns the time-intervall for calls to the handler
         */
        get lapse() {
            return this.elapse;
        }
        /**
         * Attaches a copy of this at its current state to the same {@link Time}-instance. Used internally when rescaling {@link Time}
         */
        installCopy() {
            return new Timer(this.time, this.elapse, this.count, this.handler, this.event.arguments);
        }
        /**
         * Clears the timer, removing it from the interval-timers handled by window
         */
        clear() {
            // if (this.type == TIMER_TYPE.TIMEOUT) {
            //     if (this.active)
            //         // save remaining time to timeout as new timeout for restart
            //         this.timeout = this.timeout * (1 - (performance.now() - this.startTimeReal) / this.timeoutReal);
            //     window.clearTimeout(this.id);
            // }
            // else
            // TODO: reusing timer starts interval anew. Should be remaining interval as timeout, then starting interval anew 
            window.clearInterval(this.idWindow);
            this.active = false;
        }
    }
    FudgeCore.Timer = Timer;
})(FudgeCore || (FudgeCore = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVkZ2VDb3JlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vU291cmNlL0NvcmUvRGVidWcvUGVyZm9ybWFuY2UudHMiLCIuLi9Tb3VyY2UvQ29yZS9EZWJ1Zy9EZWJ1Z1RhcmdldC50cyIsIi4uL1NvdXJjZS9Db3JlL0RlYnVnL0RlYnVnSW50ZXJmYWNlcy50cyIsIi4uL1NvdXJjZS9Db3JlL0RlYnVnL0RlYnVnQ29uc29sZS50cyIsIi4uL1NvdXJjZS9Db3JlL0RlYnVnL0RlYnVnLnRzIiwiLi4vU291cmNlL0NvcmUvRXZlbnQvRXZlbnQudHMiLCIuLi9Tb3VyY2UvQ29yZS9TZXJpYWxpemF0aW9uL011dGFibGUudHMiLCIuLi9Tb3VyY2UvQ29yZS9TZXJpYWxpemF0aW9uL1NlcmlhbGl6ZXIudHMiLCIuLi9Tb3VyY2UvQ29yZS9SZW5kZXIvUmVuZGVyQnVmZmVyTWFuYWdlci50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9SZW5kZXJNYW5hZ2VyQ29hdC50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9SZW5kZXJNYW5hZ2VyTm9kZS50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9SZW5kZXJJbmplY3RvclNoYWRlci50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9SZW5kZXJJbmplY3Rvck1lc2gudHMiLCIuLi9Tb3VyY2UvQ29yZS9SZW5kZXIvUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9SZW5kZXJJbmplY3RvckNvbXBvbmVudFBhcnRpY2xlU3lzdGVtLnRzIiwiLi4vU291cmNlL0NvcmUvUmVjeWNsZS9SZWN5Y2xlci50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvVmVjdG9yMi50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvUmVjdGFuZ2xlLnRzIiwiLi4vU291cmNlL0NvcmUvUmVuZGVyL1JlbmRlcldlYkdMLnRzIiwiLi4vU291cmNlL0NvcmUvUmVuZGVyL1JlbmRlckluamVjdG9yVGV4dHVyZS50cyIsIi4uL1NvdXJjZS9Db3JlL0dyYXBoL05vZGUudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50LnRzIiwiLi4vU291cmNlL0NvcmUvUmVjeWNsZS9SZWN5Y2FibGVBcnJheS50cyIsIi4uL1NvdXJjZS9Db3JlL1BoeXNpY3MvSGVscGVyc1BoeXNpY3MudHMiLCIuLi9Tb3VyY2UvQ29yZS9QaHlzaWNzL0pvaW50LnRzIiwiLi4vU291cmNlL0NvcmUvUGh5c2ljcy9Kb2ludEF4aWFsLnRzIiwiLi4vU291cmNlL0NvcmUvU2VyaWFsaXphdGlvbi9Qcm9qZWN0LnRzIiwiLi4vU291cmNlL0NvcmUvVGV4dHVyZS9UZXh0dXJlLnRzIiwiLi4vU291cmNlL0NvcmUvTWVzaC9NZXNoLnRzIiwiLi4vU291cmNlL0NvcmUvTWF0ZXJpYWwvTWF0ZXJpYWwudHMiLCIuLi9Tb3VyY2UvQ29yZS9QYXJ0aWNsZVN5c3RlbS9QYXJ0aWNsZVN5c3RlbS50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9SZW5kZXJJbmplY3RvckNvbXBvbmVudFNrZWxldG9uLnRzIiwiLi4vU291cmNlL0NvcmUvQ29tcG9uZW50L0NvbXBvbmVudFNrZWxldG9uLnRzIiwiLi4vU291cmNlL0NvcmUvUmVmZXJlbmNlcy50cyIsIi4uL1NvdXJjZS9Db3JlL0FuaW1hdGlvbi9BbmltYXRpb24udHMiLCIuLi9Tb3VyY2UvQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uRnVuY3Rpb24udHMiLCIuLi9Tb3VyY2UvQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uR0xURi50cyIsIi4uL1NvdXJjZS9Db3JlL0FuaW1hdGlvbi9BbmltYXRpb25LZXkudHMiLCIuLi9Tb3VyY2UvQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uTm9kZS50cyIsIi4uL1NvdXJjZS9Db3JlL0FuaW1hdGlvbi9BbmltYXRpb25TZXF1ZW5jZS50cyIsIi4uL1NvdXJjZS9Db3JlL0FuaW1hdGlvbi9BbmltYXRpb25TcHJpdGUudHMiLCIuLi9Tb3VyY2UvQ29yZS9BdWRpby9BdWRpby50cyIsIi4uL1NvdXJjZS9Db3JlL0V2ZW50L0V2ZW50QXVkaW8udHMiLCIuLi9Tb3VyY2UvQ29yZS9BdWRpby9BdWRpb01hbmFnZXIudHMiLCIuLi9Tb3VyY2UvQ29yZS9BdWRpby9BdWRpb09zY2lsbGF0b3IudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50QW1iaWVudE9jY2x1c2lvbi50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRBbmltYXRpb24udHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50QW5pbWF0aW9uR3JhcGgudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50QXVkaW8udHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50QXVkaW9MaXN0ZW5lci50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRCbG9vbS50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRDYW1lcmEudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50RmFjZUNhbWVyYS50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRGb2cudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50R3JhcGhGaWx0ZXIudHMiLCIuLi9Tb3VyY2UvQ29yZS9MaWdodC9MaWdodC50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRMaWdodC50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRNYXRlcmlhbC50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRNZXNoLnRzIiwiLi4vU291cmNlL0NvcmUvQ29tcG9uZW50L0NvbXBvbmVudE91dGxpbmUudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50UGFydGljbGVTeXN0ZW0udHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50UGljay50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRTY3JpcHQudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50VGV4dC50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRUcmFuc2Zvcm0udHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50VlJEZXZpY2UudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db250cm9sL0NvbnRyb2wudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db250cm9sL0F4aXMudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db250cm9sL0tleWJvYXJkLnRzIiwiLi4vU291cmNlL0NvcmUvRGVidWcvRGVidWdBbGVydC50cyIsIi4uL1NvdXJjZS9Db3JlL0RlYnVnL0RlYnVnRGlhbG9nLnRzIiwiLi4vU291cmNlL0NvcmUvRGVidWcvRGVidWdUZXh0QXJlYS50cyIsIi4uL1NvdXJjZS9Db3JlL0V2ZW50L0V2ZW50S2V5Ym9hcmQudHMiLCIuLi9Tb3VyY2UvQ29yZS9FdmVudC9FdmVudFRpbWVyLnRzIiwiLi4vU291cmNlL0NvcmUvRXZlbnQvRXZlbnRUb3VjaC50cyIsIi4uL1NvdXJjZS9Db3JlL0dyYXBoL0dyYXBoLnRzIiwiLi4vU291cmNlL0NvcmUvR3JhcGgvR3JhcGhHTFRGLnRzIiwiLi4vU291cmNlL0NvcmUvR3JhcGgvR3JhcGhJbnN0YW5jZS50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGVyaWFsL0NvYXQudHMiLCIuLi9Tb3VyY2UvQ29yZS9NYXRlcmlhbC9Db2F0Q29sb3JlZC50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGVyaWFsL0NvYXRSZW1pc3NpdmUudHMiLCIuLi9Tb3VyY2UvQ29yZS9NYXRlcmlhbC9Db2F0VGV4dHVyZWQudHMiLCIuLi9Tb3VyY2UvQ29yZS9NYXRlcmlhbC9Db2F0UmVtaXNzaXZlVGV4dHVyZWQudHMiLCIuLi9Tb3VyY2UvQ29yZS9NYXRlcmlhbC9Db2F0UmVtaXNzaXZlVGV4dHVyZWROb3JtYWxzLnRzIiwiLi4vU291cmNlL0NvcmUvTWF0ZXJpYWwvQ29hdFRvb24udHMiLCIuLi9Tb3VyY2UvQ29yZS9NYXRlcmlhbC9Db2xvci50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGVyaWFsL01hdGVyaWFsR0xURi50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvQ2FsYy50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvRnJhbWluZy50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvR2VvMi50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvR2VvMy50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvTEZJQjQudHMiLCIuLi9Tb3VyY2UvQ29yZS9NYXRoL01hdHJpeDN4My50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvTWF0cml4NHg0LnRzIiwiLi4vU291cmNlL0NvcmUvTWF0aC9Ob2lzZS50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvTm9pc2UyLnRzIiwiLi4vU291cmNlL0NvcmUvTWF0aC9Ob2lzZTMudHMiLCIuLi9Tb3VyY2UvQ29yZS9NYXRoL05vaXNlNC50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvUXVhdGVybmlvbi50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvUmFuZG9tLnRzIiwiLi4vU291cmNlL0NvcmUvTWF0aC9WZWN0b3IzLnRzIiwiLi4vU291cmNlL0NvcmUvTWF0aC9WZWN0b3I0LnRzIiwiLi4vU291cmNlL0NvcmUvTWVzaC9GYWNlLnRzIiwiLi4vU291cmNlL0NvcmUvTWVzaC9NZXNoQ3ViZS50cyIsIi4uL1NvdXJjZS9Db3JlL01lc2gvTWVzaFBvbHlnb24udHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL01lc2hFeHRydXNpb24udHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL01lc2hGQlgudHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL01lc2hGcm9tRGF0YS50cyIsIi4uL1NvdXJjZS9Db3JlL01lc2gvTWVzaEdMVEYudHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL01lc2hPQkoudHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL01lc2hQeXJhbWlkLnRzIiwiLi4vU291cmNlL0NvcmUvTWVzaC9NZXNoUXVhZC50cyIsIi4uL1NvdXJjZS9Db3JlL01lc2gvTWVzaFRlcnJhaW4udHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL01lc2hSZWxpZWYudHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL01lc2hSb3RhdGlvbi50cyIsIi4uL1NvdXJjZS9Db3JlL01lc2gvTWVzaFNwaGVyZS50cyIsIi4uL1NvdXJjZS9Db3JlL01lc2gvTWVzaFNwcml0ZS50cyIsIi4uL1NvdXJjZS9Db3JlL01lc2gvTWVzaFRvcnVzLnRzIiwiLi4vU291cmNlL0NvcmUvTWVzaC9RdWFkLnRzIiwiLi4vU291cmNlL0NvcmUvTWVzaC9WZXJ0ZXgudHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL1ZlcnRpY2VzLnRzIiwiLi4vU291cmNlL0NvcmUvUGFydGljbGVTeXN0ZW0vU2hhZGVyUGFydGljbGVTeXN0ZW0udHMiLCIuLi9Tb3VyY2UvQ29yZS9QYXRoaW5nL0NvbXBvbmVudFdhbGtlci50cyIsIi4uL1NvdXJjZS9Db3JlL1BhdGhpbmcvQ29tcG9uZW50V2F5cG9pbnQudHMiLCIuLi9Tb3VyY2UvQ29yZS9QYXRoaW5nL0Nvbm5lY3Rpb24udHMiLCIuLi9Tb3VyY2UvQ29yZS9QaHlzaWNzL0NvbXBvbmVudFJpZ2lkYm9keS50cyIsIi4uL1NvdXJjZS9Db3JlL1BoeXNpY3MvRGVidWdQaHlzaWNzRHJhdy50cyIsIi4uL1NvdXJjZS9Db3JlL1BoeXNpY3MvSm9pbnRDeWxpbmRyaWNhbC50cyIsIi4uL1NvdXJjZS9Db3JlL1BoeXNpY3MvSm9pbnRQcmlzbWF0aWMudHMiLCIuLi9Tb3VyY2UvQ29yZS9QaHlzaWNzL0pvaW50UmFnZG9sbC50cyIsIi4uL1NvdXJjZS9Db3JlL1BoeXNpY3MvSm9pbnRSZXZvbHV0ZS50cyIsIi4uL1NvdXJjZS9Db3JlL1BoeXNpY3MvSm9pbnRTcGhlcmljYWwudHMiLCIuLi9Tb3VyY2UvQ29yZS9QaHlzaWNzL0pvaW50VW5pdmVyc2FsLnRzIiwiLi4vU291cmNlL0NvcmUvUGh5c2ljcy9Kb2ludFdlbGRpbmcudHMiLCIuLi9Tb3VyY2UvQ29yZS9QaHlzaWNzL1BoeXNpY3MudHMiLCIuLi9Tb3VyY2UvQ29yZS9SYXkvQm94LnRzIiwiLi4vU291cmNlL0NvcmUvUmF5L1BpY2sudHMiLCIuLi9Tb3VyY2UvQ29yZS9SYXkvUGlja2VyLnRzIiwiLi4vU291cmNlL0NvcmUvUmF5L1JheS50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9HaXptb3MudHMiLCIuLi9Tb3VyY2UvQ29yZS9SZW5kZXIvUmVuZGVyLnRzIiwiLi4vU291cmNlL0NvcmUvUmVuZGVyL1JlbmRlck1lc2gudHMiLCIuLi9Tb3VyY2UvQ29yZS9SZW5kZXIvVmlld3BvcnQudHMiLCIuLi9Tb3VyY2UvQ29yZS9SZW5kZXIvWFJWaWV3cG9ydC50cyIsIi4uL1NvdXJjZS9Db3JlL1NlcmlhbGl6YXRpb24vRmlsZUlvQnJvd3NlckxvY2FsLnRzIiwiLi4vU291cmNlL0NvcmUvU2VyaWFsaXphdGlvbi9NdXRhYmxlQXJyYXkudHMiLCIuLi9Tb3VyY2UvQ29yZS9TZXJpYWxpemF0aW9uL0ZCWC9CdWZmZXJSZWFkZXIudHMiLCIuLi9Tb3VyY2UvQ29yZS9TZXJpYWxpemF0aW9uL0ZCWC9GQlgudHMiLCIuLi9Tb3VyY2UvQ29yZS9TZXJpYWxpemF0aW9uL0ZCWC9GQlhMb2FkZXIudHMiLCIuLi9Tb3VyY2UvQ29yZS9TZXJpYWxpemF0aW9uL0ZCWC9GQlhOb2RlLnRzIiwiLi4vU291cmNlL0NvcmUvU2VyaWFsaXphdGlvbi9GQlgvbG9hZEZyb21Ob2Rlcy50cyIsIi4uL1NvdXJjZS9Db3JlL1NlcmlhbGl6YXRpb24vRkJYL3BhcnNlTm9kZXNGcm9tQmluYXJ5LnRzIiwiLi4vU291cmNlL0NvcmUvU2VyaWFsaXphdGlvbi9HTFRGL0dMVEYudHMiLCIuLi9Tb3VyY2UvQ29yZS9TZXJpYWxpemF0aW9uL0dMVEYvR0xURkxvYWRlci50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9NZXJnZWRTaGFkZXJTb3VyY2VzLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlci50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJBbWJpZW50T2NjbHVzaW9uLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckJsb29tLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckZsYXQudHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyRmxhdFNraW4udHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyRmxhdFRleHR1cmVkLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckZsYXRUZXh0dXJlZFNraW4udHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyR2l6bW8udHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyR2l6bW9UZXh0dXJlZC50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJHb3VyYXVkLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckdvdXJhdWRTa2luLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckdvdXJhdWRUZXh0dXJlZC50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJHb3VyYXVkVGV4dHVyZWRTa2luLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckxpdC50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJMaXRTa2luLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckxpdFRleHR1cmVkLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckxpdFRleHR1cmVkU2tpbi50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJNYXRDYXAudHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyT3V0bGluZS50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJQaG9uZy50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJQaG9uZ1NraW4udHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyUGhvbmdUZXh0dXJlZC50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJQaG9uZ1RleHR1cmVkTm9ybWFscy50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJQaG9uZ1RleHR1cmVkTm9ybWFsc1NraW4udHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyUGhvbmdUZXh0dXJlZFNraW4udHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyUGljay50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJQaWNrVGV4dHVyZWQudHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyVG9vbi50cyIsIi4uL1NvdXJjZS9Db3JlL1RleHR1cmUvVGV4dHVyZURlZmF1bHQudHMiLCIuLi9Tb3VyY2UvQ29yZS9UaW1lL0xvb3AudHMiLCIuLi9Tb3VyY2UvQ29yZS9UaW1lL1RpbWUudHMiLCIuLi9Tb3VyY2UvQ29yZS9UaW1lL1RpbWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBVSxTQUFTLENBMElsQjtBQTFJRCxXQUFVLFNBQVM7SUFZakIsTUFBYSxrQkFBa0I7UUFFN0I7WUFDRSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLGtCQUFrQixFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzFILENBQUM7aUJBRWEsaUJBQVksR0FBOEMsRUFBRSxDQUFDO2lCQUVuRCxvQkFBZSxHQUFXLEVBQUUsQ0FBQztRQUU5QyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQWM7WUFDbEMsT0FB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QztRQUNuQixDQUFDO1FBQ0QsWUFBWTtRQUVaOztXQUVHO1FBQ0ksTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFtQixFQUFFLFNBQW9CO1lBQzdELElBQUksR0FBRyxHQUFXLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMzQyxJQUFJLEdBQUcsR0FBVyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDM0MsSUFBSSxHQUFHLEdBQVcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzNDLElBQUksR0FBRyxHQUFXLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMzQyxJQUFJLEdBQUcsR0FBVyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDM0MsSUFBSSxHQUFHLEdBQVcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzNDLElBQUksR0FBRyxHQUFXLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMzQyxJQUFJLEdBQUcsR0FBVyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDM0MsSUFBSSxHQUFHLEdBQVcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzNDLElBQUksR0FBRyxHQUFXLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM1QyxJQUFJLEdBQUcsR0FBVyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDNUMsSUFBSSxHQUFHLEdBQVcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzVDLElBQUksR0FBRyxHQUFXLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM1QyxJQUFJLEdBQUcsR0FBVyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDNUMsSUFBSSxHQUFHLEdBQVcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzVDLElBQUksR0FBRyxHQUFXLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM1QyxJQUFJLEdBQUcsR0FBVyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDNUMsSUFBSSxHQUFHLEdBQVcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzVDLElBQUksU0FBUyxHQUFjLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNyRCxTQUFTLENBQUMsR0FBRyxDQUFDO2dCQUNaLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDakMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUNqQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQ2pDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDakMsR0FBRyxHQUFHLEdBQUcs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RyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0IsU0FBUyxDQUFDLEdBQUcsQ0FBQztnQkFDWixHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDN0MsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7Z0JBQzdDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUM3QyxHQUFHLEdB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QUFXLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzQyxNQUFNLElBQUksR0FBVyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDM0MsTUFBTSxJQUFJLEdBQVcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzNDLE1BQU0sSUFBSSxHQUFXLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzQyxNQUFNLElBQUksR0FBVyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDM0MsVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUUxQixFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUk7Z0JBQWlCLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsSUFBSTtnQkFBaUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO2dCQUNsRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQztnQkFBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQztnQkFBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQztnQkFDeEcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7Z0JBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7Z0JBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7WUFDM0csQ0FBQztpQkFBTSxDQUFDO2dCQUNOLDhFQUE4RTtnQkFDOUUsTUFBTSxDQUFDLEdBQVcsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQVcsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQVcsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQVcsU0FBUyxDQUFDLENBQUMsQ0FBQztnQkFDekcsTUFBTSxFQUFFLEdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDckYsTUFBTSxFQUFFLEdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDakUsTUFBTSxFQUFFLEdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDN0MsTUFBTSxFQUFFLEdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFFekIsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUEsSUFBSTtnQkFBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUM1RSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUEsSUFBSTtnQkFBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO2dCQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQzVFLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQSxJQUFJO2dCQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQSxJQUFJO2dCQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7Z0JBRWpGLCtFQUErRTtnQkFDL0UsK0VBQStFO2dCQUMvRSxvRkFBb0Y7Z0JBQ3BGLHNDQUFzQztZQUN4QyxDQUFDO1FBQ0gsQ0FBQztRQUNELFlBQVk7UUFFWixvQkFBb0I7UUFDcEI7Ozs7V0FJRztRQUNILElBQVcsV0FBVztZQUNwQixJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO2dCQUMzQixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNuRSxJQUFJLENBQUMsaUJBQWlCLEdBQUcsS0FBSyxDQUFDO1lBQ2pDLENBQUM7WUFDRCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDM0IsQ0FBQztRQUNELElBQVcsV0FBVyxDQUFDLFlBQXFCO1lBQzFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxhQUFhLEVBQUUsWUFBWSxFQUFFLENBQUMsQ0FBQztRQUMvQyxDQUFDO1FBRUQ7Ozs7V0FJRztRQUNILElBQVcsUUFBUTtZQUNqQixJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQkFDeEIsSUFBSSxPQUFPLEdBQVksSUFBSSxDQUFDLE9BQU8sQ0FBQztnQkFFcEMsSUFBSSxFQUFFLEdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO2dCQUMxQyxJQUFJLEVBQUUsR0FBVyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUM7Z0JBQzFDLElBQUksRUFBRSxHQUFXLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQztnQkFDMUMsSUFBSSxFQUFFLEdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO2dCQUMxQyxJQUFJLEdBQUcsR0FBVyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUM7Z0JBRTVDLElBQUksRUFBRSxHQUFXLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsdURBQXVEO2dCQUU1RixJQUFJLFFBQVEsR0FBWSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsS0FBSztnQkFFeEMsSUFBSSxFQUFVLEVBQUUsRUFBVSxFQUFFLEVBQVUsQ0FBQztnQkFDdkMsSUFBSSxFQUFVLEVBQUUsRUFBVSxFQUFFLEVBQVUsQ0FBQztnQkFFdkMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO29CQUNkLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztvQkFDekIsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7b0JBQ3pCLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFFeEIsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDM0IsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDMUIsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFFMUIsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO3dCQUM1RixFQUFFLEdBQUcsRUFBRSxDQUFDO3dCQUNSLEVBQUUsR0FBRyxFQUFFLENBQUM7d0JBQ1IsRUFBRSxHQUFHLEVBQUUsQ0FBQztvQkFDVixDQUFDO2dCQUNILENBQUM7cUJBQU0sQ0FBQztvQkFDTixFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDckUsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7b0JBQy9DLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ1QsQ0FBQztnQkFFRCxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFB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QyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNuRCxNQUFNLEtBQUssR0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDbkQsTUFBTSxLQUFLLEdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRWxELE1BQU0sR0FBRyxHQUNQLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO2dCQUNuRCxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztnQkFDbkQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7Z0JBQ25ELENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFD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QUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksR0FBRyxHQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM3QixJQUFJLElBQUksR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzdCLElBQUksSUFBSSxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDN0IsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDOUIsSUFBSSxLQUFLLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztZQUM5QixJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsR0FBRyxDQUFDO1lBRTlCLElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUM7Z0JBQ3JELENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztZQUV6QyxJQUFJLEVBQUUsR0FBVyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDO2dCQUNyRCxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFDekMsSUFBSSxFQUFFLEdBQVcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQztnQkFDdEQsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBQzFDLElBQUksRUFBRSxHQUFXLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUM7Z0JBQ3RELENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQztZQUUxQyxJQUFJLENBQUMsR0FBVyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFFbEUsSUFBSSxDQUFDLEdBQUcsQ0FBQztnQkFDUCxDQUFDLEdBQUcsRUFBRSxFQUFFLE1BQU07Z0JBQ2QsQ0FBQyxHQUFHLEVBQUUsRUFBRSxNQUFNO2dCQUNkLENBQUMsR0FBRyxFQUFFLEVBQUUsTUFBTTtnQkFDZCxDQUFDLEdBQUcsRUFBRSxFQUFFLE1BQU07Z0JBQ2QsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFTLE1BQU07Z0JBQ3BHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBUyxNQUFNO2dCQUNwRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQU8sTUFBTTtnQkFDcEcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFPLE1BQU07Z0JBQ3BHLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRyxNQUFNO2dCQUNwRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUcsTUFBTTtnQkFDcEcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFHLE9BQU87Z0JBQ3JHLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRyxPQUFPO2dCQUNyRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUcsT0FBTztnQkFDckcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFHLE9BQU87Z0JBQ3JHLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdB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RUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMs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LEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQywrQ0FBK0M7Z0JBQ2pHLE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxnREFBZ0Q7Z0JBQ2xHLE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2pELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyw4Q0FBOEM7Z0JBQ2pHLE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2xELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBQ2xELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7Z0JBRWxELG1FQUFtRTtnQkFDbkUsTUFBTSxFQUFFLEdBQVcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDM0IsTUFBTSxFQUFFLEdBQVcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDM0IsTUFBTSxFQUFFLEdBQVcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDM0IsTUFBTSxFQUFFLEdBQVcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDM0IsTUFBTSxFQUFFLEdBQWEsTUFBTSxDQUFDLFFBQVEsQ0FDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQzdELEVBQUUsQ0FDSCxDQUFDO2dCQUNGLE1BQU0sRUFBRSxHQUFhLE1BQU0sQ0FBQyxRQUFRLENBQ2xDLElBQUksQ0FBQyxJQUFJLENBQ1AsRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FDdkUsR0FBRyxFQUFFLENBQ1AsQ0FBQztnQkFDRixNQUFNLEVBQUUsR0FBYSxNQUFNLENBQUMsUUFBUSxDQUNsQyxJQUFJLENBQUMsSUFBSSxDQUNQLEVBQUUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQ3ZFLEdBQUcsRUFBRSxDQUNQLENBQUM7Z0JBQ0YsTUFBTSxFQUFFLEdBQWEsTUFBTSxDQUFDLFFBQVEsQ0FDbEMsSUFBSSxDQUFDLElBQUksQ0FDUCxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUN2RSxHQUFHLEVBQUUsQ0FDUCxDQUFDO2dCQUNGLE1BQU0sRUFBRSxHQUFhLE1BQU0sQ0FBQyxRQUFRLENBQ2xDLElBQUksQ0FBQyxJQUFJLENBQ1AsRUFBRSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDbkUsR0FBRyxFQUFFLENBQ1AsQ0FBQztnQkFFRixtREFBbUQ7Z0JBQ25ELE1BQU0sRUFBRSxHQUFXLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO2dCQUMvRCxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsQ0FBQztvQkFDdkIsQ0FBQyxDQUFDLEdBQUc7b0JBQ0wsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUMxRSxNQUFNLEVBQUUsR0FBVyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDL0QsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLENBQUM7b0JBQ3ZCLENBQUMsQ0FBQyxHQUFHO29CQUNMLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFDMUUsTUFBTSxFQUFFLEdBQVcsR0FBRyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7Z0JBQy9ELE1BQU0sRUFBRSxHQUFXLEVBQUUsR0FBRyxDQUFDO29CQUN2QixDQUFDLENBQUMsR0FBRztvQkFDTCxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQzFFLE1BQU0sRUFBRSxHQUFXLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO2dCQUMvRCxNQUFNLEVBQUUsR0FBVyxFQUFFLEdBQUcsQ0FBQztvQkFDdkIsQ0FBQyxDQUFDLEdBQUc7b0JBQ0wsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUMxRSxNQUFNLEVBQUUsR0FBVyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDL0QsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLENBQUM7b0JBQ3ZCLENBQUMsQ0FBQyxHQUFHO29CQUNMLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFFMUUsd0RBQXdEO2dCQUN4RCxPQUFPLGlCQUFpQixHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQ3RELENBQUMsQ0FBQztRQUNKLENBQUM7O0lBMUlVLGdCQUFNLFNBK0lsQixDQUFBO0FBQ0gsQ0FBQyxFQTlKUyxTQUFTLEtBQVQsU0FBUyxRQThKbEI7QUM5SkQsSUFBVSxTQUFTLENBcVlsQjtBQXJZRCxXQUFVLFNBQVM7SUFDakI7Ozs7OztRQU1JO0lBQ0osTUFBYSxVQUFXLFNBQVEsVUFBQSxPQUFPO1FBTzVCLFlBQVksQ0FBMkIsQ0FBQyw0REFBNEQ7UUFDN0csaUJBQWlCLENBQVU7UUFFM0IsWUFBbUIsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDO1lBQy9FLEtBQUssRUFBRSxDQUFDO1lBTkYsWUFBTyxHQUFZLElBQUksQ0FBQyxDQUFDLDZIQUE2SDtZQUVySixpQkFBWSxHQUFZLFVBQUEsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsNERBQTREO1lBSzNHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDM0IsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLFFBQVE7WUFDcEIsTUFBTSxNQUFNLEdBQWUsVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3BELE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBYztZQUN4QyxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDOUIsQ0FBQztRQWdCTSxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQWdCLEVBQUUsVUFBNkI7WUFDcEUsTUFBTSxNQUFNLEdBQWUsVUFBQSxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3BELElBQUksVUFBVSxJQUFJLFNBQVMsRUFBRSxDQUFDO2dCQUM1QixNQUFNLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQztZQUMvQixDQUFDO2lCQUFNLElBQUksT0FBTyxVQUFVLElBQUksUUFBUSxFQUFFLENBQUM7Z0JBQ3pDLElBQUksU0FBUyxHQUFXLFVBQVUsR0FBRyxVQUFBLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO2dCQUN0RCxJQUFJLFlBQVksR0FBVyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUUvQyxNQUFNLENBQUMsR0FBRyxDQUNSLE9BQU8sQ0FBQyxDQUFDLEdBQUcsWUFBWSxFQUN4QixPQUFPLENBQUMsQ0FBQyxHQUFHLFlBQVksRUFDeEIsT0FBTyxDQUFDLENBQUMsR0FBRyxZQUFZLEVBQ3hCLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQ3BCLENBQUM7WUFDSixDQUFDO2lCQUFNLENBQUM7Z0JBQ04sTUFBTSxLQUFLLEdBQVksVUFBQSxPQUFPLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDMUQsTUFBTSxNQUFNLEdBQWMsVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLFVBQUEsU0FBUyxDQUFDLENBQUM7Z0JBQ3BELE1BQU0sQ0FBQyxHQUFHLENBQUM7b0JBQ1QsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQztvQkFDNUIsVUFBVSxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztvQkFDM0MsT0FBTyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQztvQkFDbEMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztpQkFDWCxDQUFDLENBQUM7Z0JBRUgsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQy9CLFVBQUEsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDeEMsQ0FBQztZQUVELE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBa0IsRUFBRSxPQUFtQjtZQUMzRCxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3hDLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBYztZQUNsQyxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDM0IsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFjO1lBQ3RDLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUM5QixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQWUsRUFBRSxHQUFlO1lBQ2hELE9BQU8sR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3ZFLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBaUIsRUFBRSxHQUFlLEVBQUUsT0FBZTtZQUNwRSxJQUFJLE1BQU0sR0FBZSxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbEQsTUFBTSxDQUFDLEdBQUcsQ0FDUixDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsRUFDM0MsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEVBQzNDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxFQUMzQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FDNUMsQ0FBQztZQUNGLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNuQixPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQWlCLEVBQUUsR0FBZSxFQUFFLE9BQWU7WUFDckUsMEZBQTBGO1lBQzFGLE1BQU0sTUFBTSxHQUFlLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN0RCxJQUFJLFlBQVksR0FBVyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDakcsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7Z0JBQzdCLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUU1QixJQUFJLFNBQVMsR0FBVyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ2hELElBQUksWUFBWSxHQUFXLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLFlBQVksR0FBRyxZQUFZLENBQUMsQ0FBQztZQUN0RSxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUM7Z0JBQ25DLE1BQU0sQ0FBQyxHQUFHLENBQ1IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUM3QixDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQzdCLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsRUFDN0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUM5QixDQUFDO2dCQUNGLE9BQU8sTUFBTSxDQUFDO1lBQ2hCLENBQUM7WUFFRCxJQUFJLE1BQU0sR0FBVyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLFlBQVksQ0FBQztZQUN4RSxJQUFJLE1BQU0sR0FBVyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUMsR0FBRyxZQUFZLENBQUM7WUFDbEUsTUFBTSxDQUFDLEdBQUcsQ0FDUixDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLEVBQ25DLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsRUFDbkMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxFQUNuQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQ3BDLENBQUM7WUFFRixPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQWM7WUFDakMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDYixFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNiLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2IsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDZixDQUFDO1FBRUQ7O1dBRUc7UUFDSCxJQUFXLEtBQUs7WUFDZCxJQUFJLE1BQU0sR0FBZSxVQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDcEQsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNsQixPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7Ozs7V0FJRztRQUNILElBQVcsV0FBVztZQUNwQixJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO2dCQUMzQixJQUFJLENBQUMsaUJBQWlCLEdBQUcsS0FBSyxDQUFDO2dCQUUvQixJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7b0JBQzdELElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBQy9CLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztnQkFDM0IsQ0FBQztnQkFFRCx5QkFBeUI7Z0JBQ3pCLElBQUksUUFBUSxHQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDL0QsSUFBSSxRQUFRLEdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbkUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBRXJELDBCQUEwQjtnQkFDMUIsSUFBSSxJQUFJLEdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzRCxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztvQkFDckIsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLGlDQUFpQzs7b0JBRWxILElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBRXhDLHdCQUF3QjtnQkFDeEIsSUFBSSxRQUFRLEdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMvRCxJQUFJLFFBQVEsR0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNuRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFFckQsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsVUFBQSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDeEMsQ0FBQztZQUVELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztRQUMzQixDQUFDO1FBRUQsSUFBVyxXQUFXLENBQUMsWUFBcUI7WUFDMUMsTUFBTSxtQkFBbUIsR0FBWSxVQUFBLE9BQU8sQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFLFVBQUEsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNuRixNQUFNLElBQUksR0FBVyxJQUFJLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JELE1BQU0sSUFBSSxHQUFXLElBQUksQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckQsTUFBTSxJQUFJLEdBQVcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyRCxNQUFNLElBQUksR0FBVyxJQUFJLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JELE1BQU0sSUFBSSxHQUFXLElBQUksQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckQsTUFBTSxJQUFJLEdBQVcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUVyRCxJQUFJLENBQUMsR0FBRyxDQUNOLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxFQUN2QyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksRUFDdkMsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEVBQ3ZDLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUN4QyxDQUFDO1lBRUYsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDckMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLEtBQUssQ0FBQztZQUMvQixVQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUN0QyxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxTQUFTO1lBQ2QsSUFBSSxNQUFNLEdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ3RGLElBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDO1lBQ2pCLElBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDO1lBQ2pCLElBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDO1lBQ2pCLElBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDO1lBQ2pCLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUNsQixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU07WUFDWCxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2IsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNiLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDYixJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2IsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ2xCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksT0FBTztZQUNaLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDdkIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTTtZQUNYLDRDQUE0QztZQUM1QyxPQUFPLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUMxQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxTQUFTO1lBQ2QsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNiLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDYixJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2IsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ2xCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOzs7V0FHRztRQUNJLE1BQU0sQ0FBQyxLQUFjLEVBQUUsTUFBYyxFQUFFLFlBQXFCLEtBQUs7WUFDdEUsTUFBTSxRQUFRLEdBQWUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDaEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDbkMsVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3pCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksUUFBUSxDQUFDLE1BQWtCLEVBQUUsWUFBcUIsS0FBSztZQUM1RCxNQUFNLENBQUMsR0FBZSxTQUFTLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ2hELE1BQU0sQ0FBQyxHQUFlLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7WUFDaEQsaUdBQWlHO1lBQ2pHLE1BQU0sRUFBRSxHQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkIsTUFBTSxFQUFFLEdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2QixNQUFNLEVBQUUsR0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZCLE1BQU0sRUFBRSxHQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkIsTUFBTSxFQUFFLEdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2QixNQUFNLEVBQUUsR0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZCLE1BQU0sRUFBRSxHQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkIsTUFBTSxFQUFFLEdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUV2QixJQUFJLENBQUMsR0FBRyxDQUNOLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQ3JDLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFDdEMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFDckMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUN2QyxDQUFDO1lBRUYsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxHQUFHLENBQUMsRUFBVSxFQUFFLEVBQVUsRUFBRSxFQUFVLEVBQUUsRUFBVTtZQUN2RCxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNuRCxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDbEIsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxJQUFJLENBQUMsU0FBcUI7WUFDL0IsSUFBSSxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQ3ZGLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxTQUFTLENBQUMsaUJBQWlCLENBQUM7WUFDckQsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUI7Z0JBQ3pCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUNqRCxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztZQUNwQixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRDs7V0FFRztRQUNJLFFBQVE7WUFDYixPQUFPLG1CQUFtQixJQUFJLENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDaEYsQ0FBQztRQUVELHlHQUF5RztRQUNsRyxTQUFTO1lBQ2QsSUFBSSxhQUFhLEdBQWtCLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUNyRCxhQUFhLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRSxHQUFHLE9BQU8sSUFBSSxJQUFJLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDeEYsT0FBTyxhQUFhLENBQUM7UUFDdkIsQ0FBQztRQUVNLEtBQUssQ0FBQyxXQUFXLENBQUMsY0FBNkI7WUFDcEQsSUFBSSxPQUFPLENBQUMsY0FBYyxDQUFDLElBQUksUUFBUSxFQUFFLENBQUM7Z0JBQ3hDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQWtCLGNBQWMsQ0FBQyxDQUFDO1lBQ2pGLENBQUM7O2dCQUNDLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDOUIsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRU0sVUFBVTtZQUNmLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTztnQkFDZixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUNoRSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDdEIsQ0FBQztRQUVNLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBaUI7WUFDbkMsSUFBSSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3BCLENBQUM7UUFFUyxhQUFhLENBQUMsUUFBaUIsSUFBZ0IsQ0FBQztRQUVsRCxVQUFVO1lBQ2hCLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUM7WUFDOUIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDdEIsQ0FBQztLQUNGO0lBNVhZLG9CQUFVLGFBNFh0QixDQUFBO0FBQ0gsQ0FBQyxFQXJZUyxTQUFTLEtBQVQsU0FBUyxRQXFZbEI7QUNyWUQsSUFBVSxTQUFTLENBd0lsQjtBQXhJRCxXQUFVLFNBQVM7SUFDakI7Ozs7O09BS0c7SUFDSCxNQUFhLE1BQU07aUJBQ0gsWUFBTyxHQUFXLElBQUksTUFBTSxFQUFFLEFBQXZCLENBQXdCO1FBRzdDOzs7O1dBSUc7UUFDSCxZQUFtQixlQUFtQztZQVA5QyxhQUFRLEdBQWEsSUFBSSxDQUFDLE1BQU0sQ0FBQztZQVF2QyxJQUFJLGVBQWUsWUFBWSxRQUFRO2dCQUNyQyxJQUFJLENBQUMsUUFBUSxHQUFHLGVBQWUsQ0FBQztpQkFDN0IsSUFBSSxlQUFlLElBQUksU0FBUztnQkFDbkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDOztnQkFFNUIsWUFBWTtnQkFDWixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksVUFBQSxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDL0MsQ0FBQztRQUVEOztXQUVHO1FBQ0ksT0FBTztZQUNaLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3pCLENBQUM7UUFFRDs7V0FFRztRQUNJLFFBQVEsQ0FBQyxJQUFZLEVBQUUsSUFBWTtZQUN4QyxPQUFPLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFDaEQsQ0FBQztRQUVEOztXQUVHO1FBQ0ksZUFBZSxDQUFDLElBQVksRUFBRSxJQUFZO1lBQy9DLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQy9DLENBQUM7UUFFRDs7V0FFRztRQUNJLFVBQVU7WUFDZixPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxHQUFHLENBQUM7UUFDL0IsQ0FBQztRQUVEOztXQUVHO1FBQ0ksT0FBTztZQUNaLE9BQU8sSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BDLENBQUM7UUFFRDs7V0FFRztRQUNJLFFBQVEsQ0FBSSxNQUFnQjtZQUNqQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQztnQkFDbkIsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDaEQsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUNaLENBQUM7UUFFRDs7V0FFRztRQUNJLFVBQVUsQ0FBSSxNQUFnQjtZQUNuQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQztnQkFDbkIsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ3ZDLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFJLE1BQWdCO1lBQy9CLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BELENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBTyxJQUFlO1lBQ2pDLElBQUksSUFBSSxHQUFZLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7WUFDNUMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ25DLENBQUM7UUFFRDs7V0FFRztRQUNJLGVBQWUsQ0FBSSxPQUFVO1lBQ2xDLElBQUksSUFBSSxHQUFhLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN6RCxPQUFnQixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzVDLENBQUM7UUFFRDs7V0FFRztRQUNJLGlCQUFpQixDQUFJLE9BQVU7WUFDcEMsSUFBSSxJQUFJLEdBQWEsTUFBTSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzNELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNuQyxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxVQUFVLENBQUMsUUFBaUIsRUFBRSxRQUFpQjtZQUNwRCxPQUFPLElBQUksVUFBQSxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxSSxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxVQUFVLENBQUMsUUFBaUIsRUFBRSxRQUFpQjtZQUNwRCxPQUFPLElBQUksVUFBQSxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkcsQ0FBQztRQUVEOztXQUVHO1FBQ0ksUUFBUTtZQUNiLE9BQU8sSUFBSSxVQUFBLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0RSxDQUFDOztJQTFIVSxnQkFBTSxTQTJIbEIsQ0FBQTtJQUVEOztPQUVHO0lBQ1UsZ0JBQU0sR0FBVyxJQUFJLE1BQU0sRUFBRSxDQUFDO0FBQzdDLENBQUMsRUF4SVMsU0FBUyxLQUFULFNBQVMsUUF3SWxCO0FDeElELElBQVUsU0FBUyxDQTJqQmxCO0FBM2pCRCxXQUFVLFNBQVM7SUFDakI7Ozs7Ozs7OztPQVNHO0lBQ0gsTUFBYSxPQUFRLFNBQVEsVUFBQSxPQUFPO1FBS2xDLFlBQW1CLEtBQWEsQ0FBQyxFQUFFLEtBQWEsQ0FBQyxFQUFFLEtBQWEsQ0FBQztZQUMvRCxLQUFLLEVBQUUsQ0FBQztZQUNSLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUN2QixDQUFDO1FBRUQsZ0JBQWdCO1FBQ2hCOztXQUVHO1FBQ0ksTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFpQixDQUFDO1lBQ2hDLE1BQU0sTUFBTSxHQUFZLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNoRCxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDekIsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFpQixDQUFDO1lBQ2hDLE1BQU0sTUFBTSxHQUFZLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNoRCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDekIsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFpQixDQUFDO1lBQ2hDLE1BQU0sTUFBTSxHQUFZLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNoRCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDekIsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLElBQUk7WUFDaEIsTUFBTSxNQUFNLEdBQVksVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ2hELE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLDBDQUEwQztZQUMvRCxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsR0FBRyxDQUFDLFNBQWlCLENBQUM7WUFDbEMsTUFBTSxNQUFNLEdBQVksVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ2hELE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztZQUNuQyxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsY0FBYyxDQUFDLE9BQWdCLEVBQUUsVUFBa0MsRUFBRSxzQkFBK0IsSUFBSTtZQUNwSCxNQUFNLE1BQU0sR0FBWSxVQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7WUFFaEQsSUFBSSxVQUFVLFlBQVksVUFBQSxTQUFTLEVBQUUsQ0FBQztnQkFDcEMsSUFBSSxDQUFDLEdBQWlCLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFFdkMsTUFBTSxDQUFDLEdBQUcsQ0FDUixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsRUFDdEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEVBQ3RELENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUN4RCxDQUFDO2dCQUVGLElBQUksbUJBQW1CO29CQUNyQixNQUFNLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUV2QyxDQUFDO2lCQUFNLENBQUM7Z0JBQ04sd0dBQXdHO2dCQUN4RyxxRUFBcUU7Z0JBRXJFLHNEQUFzRDtnQkFDdEQsTUFBTSxFQUFFLEdBQVcsVUFBVSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUM7Z0JBQ2xHLE1BQU0sRUFBRSxHQUFXLFVBQVUsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO2dCQUNsRyxNQUFNLEVBQUUsR0FBVyxVQUFVLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQztnQkFDbEcsTUFBTSxFQUFFLEdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQztnQkFFbkcsZ0JBQWdCO2dCQUNoQixNQUFNLENBQUMsR0FBRyxDQUNSLEVBQUUsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFFLFVBQVUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUUsVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBRSxVQUFVLENBQUMsQ0FBQyxFQUNuRixFQUFFLEdBQUcsVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBRSxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFFLFVBQVUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUUsVUFBVSxDQUFDLENBQUMsRUFDbkYsRUFBRSxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUUsVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBRSxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFFLFVBQVUsQ0FBQyxDQUFDLENBQ3BGLENBQUM7WUFDSixDQUFDO1lBRUQsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLGFBQWEsQ0FBQyxPQUFnQixFQUFFLFVBQWtCLENBQUM7WUFDL0QsSUFBSSxnQkFBZ0IsR0FBVyxPQUFPLENBQUMsZ0JBQWdCLENBQUM7WUFDeEQsSUFBSSxnQkFBZ0IsSUFBSSxDQUFDO2dCQUN2QixNQUFNLENBQUMsSUFBSSxVQUFVLENBQUMsMEJBQTBCLENBQUMsQ0FBQyxDQUFDO1lBQ3JELElBQUksTUFBTSxHQUFZLE9BQU8sQ0FBQyxLQUFLLENBQUM7WUFDcEMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7WUFDcEQsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQW1CO1lBQ3RDLElBQUksTUFBTSxHQUFZLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM1QyxLQUFLLElBQUksTUFBTSxJQUFJLFFBQVE7Z0JBQ3pCLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1RSxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQWlCLEVBQUUsV0FBb0I7WUFDOUQsSUFBSSxNQUFNLEdBQVksVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzlDLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMvRixPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQWdCLEVBQUUsUUFBZ0I7WUFDcEQsSUFBSSxNQUFNLEdBQVksVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzlDLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsR0FBRyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQztZQUM3RSxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQVcsRUFBRSxFQUFXO1lBQzFDLElBQUksTUFBTSxHQUFZLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM5QyxNQUFNLENBQUMsR0FBRyxDQUNSLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQ3pCLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQ3pCLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQzFCLENBQUM7WUFDRixPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBQ0Q7O1dBRUc7UUFDSSxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQVcsRUFBRSxFQUFXO1lBQ3hDLE9BQU8sRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFBQSxDQUFDO1FBQ2xELENBQUM7UUFFRDs7Ozs7Ozs7V0FRRztRQUNJLE1BQU0sQ0FBQyxVQUFVLENBQUMsU0FBa0IsRUFBRSxPQUFnQjtZQUMzRCxJQUFJLEdBQUcsR0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ25ELElBQUksVUFBVSxHQUFZLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ2xGLE9BQU8sVUFBVSxDQUFDO1FBQ3BCLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBa0IsRUFBRSxRQUFpQjtZQUN2RCxJQUFJLE1BQU0sR0FBWSxVQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDOUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3pGLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxHQUFHLENBQUMsYUFBcUIsQ0FBQyxFQUFFLFlBQW9CLENBQUMsRUFBRSxhQUFxQixDQUFDO1lBQ3JGLElBQUksTUFBTSxHQUFZLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM5QyxJQUFJLEdBQUcsR0FBUyxVQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsVUFBQSxJQUFJLENBQUMsQ0FBQztZQUNyQyxHQUFHLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFDM0MsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDakIsVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3BCLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBYyxFQUFFLEdBQVk7WUFDOUMsSUFBSSxLQUFLLEdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFBLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMseURBQXlEO1lBQ3hLLE9BQU8sS0FBSyxHQUFHLFVBQUEsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUM5QixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQVcsRUFBRSxFQUFXO1lBQy9DLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDOUIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFXLEVBQUUsRUFBVyxFQUFFLE9BQWU7WUFDMUQsT0FBTyxHQUFHLFVBQUEsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3BDLElBQUksTUFBTSxHQUFZLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM5QyxNQUFNLENBQUMsR0FBRyxDQUNSLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLEVBQzlCLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLEVBQzlCLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQy9CLENBQUM7WUFDRixPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQ7Ozs7Ozs7Ozs7O1dBV0c7UUFDSSxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQWlCLEVBQUUsT0FBZ0IsRUFBRSxTQUFrQixFQUFFLFdBQW1CLEVBQUUsVUFBa0IsRUFBRSxZQUFvQixRQUFRO1lBQ3JKLE1BQU0sS0FBSyxHQUFXLENBQUMsR0FBRyxXQUFXLENBQUM7WUFDdEMsTUFBTSxDQUFDLEdBQVcsS0FBSyxHQUFHLFVBQVUsQ0FBQztZQUNyQyxNQUFNLEdBQUcsR0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsMENBQTBDO1lBQzlHLE1BQU0sTUFBTSxHQUFZLE9BQU8sQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsaUNBQWlDO1lBRWhHLE1BQU0sU0FBUyxHQUFXLFNBQVMsR0FBRyxXQUFXLENBQUM7WUFDbEQsTUFBTSxnQkFBZ0IsR0FBVyxNQUFNLENBQUMsZ0JBQWdCLENBQUM7WUFDekQsSUFBSSxnQkFBZ0IsR0FBRyxTQUFTLEdBQUcsU0FBUyxFQUFFLENBQUM7Z0JBQzdDLE1BQU0sQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO2dCQUN0RCxPQUFPLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDakQsQ0FBQztZQUVELCtCQUErQjtZQUMvQixNQUFNLFdBQVcsR0FBWSxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztZQUMxRCxNQUFNLHNCQUFzQixHQUFZLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBQzVFLE1BQU0sSUFBSSxHQUFZLE9BQU8sQ0FBQyxLQUFLLENBQUMsc0JBQXNCLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFFeEUsTUFBTSxTQUFTLEdBQVksT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDdEQsTUFBTSwyQkFBMkIsR0FBWSxPQUFPLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUN0RixNQUFNLGdDQUFnQyxHQUFZLE9BQU8sQ0FBQyxLQUFLLENBQUMsMkJBQTJCLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDbEcsU0FBUyxDQUFDLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO1lBRWpELE1BQU0sYUFBYSxHQUFZLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ3pELE1BQU0scUJBQXFCLEdBQVksT0FBTyxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDekUsTUFBTSxNQUFNLEdBQVksT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUscUJBQXFCLENBQUMsQ0FBQztZQUVwRSx1QkFBdUI7WUFDdkIseUdBQXlHO1lBQ3pHLGlHQUFpRztZQUNqRywrRkFBK0Y7WUFFL0YsVUFBQSxRQUFRLENBQUMsYUFBYSxDQUFDLFdBQVcsRUFBRSxzQkFBc0IsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLDJCQUEyQixFQUFFLGdDQUFnQyxFQUFFLGFBQWEsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO1lBQ2xMLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUM7UUFDRCxZQUFZO1FBRVosbUJBQW1CO1FBQ25COztXQUVHO1FBQ0gsSUFBVyxTQUFTO1lBQ2xCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVDLENBQUM7UUFFRDs7V0FFRztRQUNILElBQVcsZ0JBQWdCO1lBQ3pCLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDakMsQ0FBQztRQUVEOzs7V0FHRztRQUNILElBQVcsR0FBRyxDQUFDLElBQVU7WUFDdkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUMvQixJQUFJLENBQUMsU0FBUyxDQUFDLFVBQUEsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ3JELElBQUksQ0FBQyxTQUFTLENBQUMsVUFBQSxTQUFTLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ3ZELENBQUM7UUFDRCxJQUFXLEdBQUc7WUFDWixJQUFJLEdBQUcsR0FBUyxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBQSxJQUFJLENBQUMsQ0FBQztZQUNuQyxHQUFHLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7WUFFL0IsSUFBSSxHQUFHLENBQUMsU0FBUyxLQUFLLENBQUM7Z0JBQ3JCLE9BQU8sR0FBRyxDQUFDO1lBRWIsR0FBRyxDQUFDLFNBQVMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztZQUMzRixHQUFHLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDakUsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDO1FBRUQ7O1dBRUc7UUFDSCxJQUFXLEtBQUs7WUFDZCxPQUFPLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDNUMsQ0FBQztRQUNELFlBQVk7UUFFWjs7V0FFRztRQUNJLElBQUksQ0FBQyxTQUFrQjtZQUM1QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN6RCxDQUFDO1FBRU0sT0FBTztZQUNaLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNwQixDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksTUFBTSxDQUFDLFFBQWlCLEVBQUUsYUFBcUIsTUFBTSxDQUFDLE9BQU87WUFDbEUsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVU7Z0JBQUUsT0FBTyxLQUFLLENBQUM7WUFDN0QsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVU7Z0JBQUUsT0FBTyxLQUFLLENBQUM7WUFDN0QsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVU7Z0JBQUUsT0FBTyxLQUFLLENBQUM7WUFDN0QsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxZQUFZLENBQUMsUUFBaUIsRUFBRSxRQUFpQjtZQUN0RCxJQUFJLFFBQVEsR0FBWSxPQUFPLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUMvRCxJQUFJLFFBQVEsR0FBWSxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztZQUMzRCxJQUFJLEtBQUssR0FBWSxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUN2RCxJQUFJLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQztnQkFDNUIsT0FBTyxLQUFLLENBQUM7WUFDZixJQUFJLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQztnQkFDNUIsT0FBTyxLQUFLLENBQUM7WUFDZixJQUFJLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQztnQkFDNUIsT0FBTyxLQUFLLENBQUM7WUFDZixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRDs7V0FFRztRQUNJLGNBQWMsQ0FBQyxPQUFnQixFQUFFLE9BQWU7WUFDckQsSUFBSSxVQUFVLEdBQVksT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDNUQsT0FBTyxVQUFVLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLENBQUM7UUFDM0QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksR0FBRyxDQUFDLE9BQWdCO1lBQ3pCLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQztZQUNwQixJQUFJLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDcEIsSUFBSSxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ3BCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksUUFBUSxDQUFDLFdBQW9CO1lBQ2xDLElBQUksQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQztZQUN4QixJQUFJLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFDeEIsSUFBSSxDQUFDLENBQUMsSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQ3hCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksS0FBSyxDQUFDLE9BQWU7WUFDMUIsSUFBSSxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUM7WUFDbEIsSUFBSSxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUM7WUFDbEIsSUFBSSxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUM7WUFDbEIsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxTQUFTLENBQUMsVUFBa0IsQ0FBQztZQUNsQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUN6RCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNO1lBQ1gsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDakIsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDakIsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDakIsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxPQUFPLENBQUMsR0FBWTtZQUN6QixJQUFJLE1BQU0sR0FBVyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsZ0JBQWdCLENBQUM7WUFDbkUsSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztZQUN4QixJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7WUFDeEIsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxHQUFHLENBQUMsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDO1lBQ3ZELElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ1osSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDWixJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNaLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksR0FBRztZQUNSLE9BQU8sSUFBSSxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEQsQ0FBQztRQUVEOzs7O1dBSUc7UUFDSSxTQUFTLENBQUMsVUFBa0MsRUFBRSxzQkFBK0IsSUFBSTtZQUN0RixJQUFJLFdBQVcsR0FBWSxPQUFPLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztZQUN6RixJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3ZCLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUM1QixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRDs7V0FFRztRQUNJLFNBQVM7WUFDZCxPQUFPLElBQUksVUFBQSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckMsQ0FBQztRQUVEOztXQUVHO1FBQ0ksT0FBTyxDQUFDLE9BQWdCO1lBQzdCLE1BQU0sU0FBUyxHQUFZLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQzdELElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNoRCxVQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDMUIsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxPQUFPO1lBQ1osSUFBSSxDQUFDLEdBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBQSxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFBLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ25FLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksV0FBVyxDQUFDLEdBQVk7WUFDN0IsSUFBSSxVQUFVLEdBQVksT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDeEQsVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQzNCLE9BQU8sVUFBVSxDQUFDLFNBQVMsQ0FBQztRQUM5QixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxHQUFHLENBQUMsUUFBaUI7WUFDMUIsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0QyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEMsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxHQUFHLENBQUMsUUFBaUI7WUFDMUIsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0QyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEMsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksR0FBRyxDQUFDLFNBQWdGO1lBQ3pGLElBQUksSUFBSSxHQUFZLFVBQUEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUMxQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQ3JELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksS0FBSyxDQUFDLFNBQWtGO1lBQzdGLElBQUksQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ25DLElBQUksQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ25DLElBQUksQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ25DLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksUUFBUTtZQUNiLElBQUksTUFBTSxHQUFXLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztZQUN0RyxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBRUQsa0JBQWtCO1FBQ1gsU0FBUztZQUNkLElBQUksYUFBYSxHQUFrQixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDckQsZ0hBQWdIO1lBQ2hILGFBQWEsQ0FBQyxNQUFNLEdBQUcsR0FBRyxFQUFFLEdBQUcsT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDN0UsT0FBTyxhQUFhLENBQUM7UUFDdkIsQ0FBQztRQUVNLEtBQUssQ0FBQyxXQUFXLENBQUMsY0FBNkI7WUFDcEQsSUFBSSxPQUFPLENBQUMsY0FBYyxDQUFDLElBQUksUUFBUSxFQUFFLENBQUM7Z0JBQ3hDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFrQixjQUFjLENBQUMsQ0FBQztZQUN6RSxDQUFDOztnQkFDQyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQzlCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVNLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBaUI7WUFDbkMsSUFBSSxRQUFRLENBQUMsQ0FBQyxLQUFLLFNBQVM7Z0JBQzFCLElBQUksQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUN0QixJQUFJLFFBQVEsQ0FBQyxDQUFDLEtBQUssU0FBUztnQkFDMUIsSUFBSSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ3RCLElBQUksUUFBUSxDQUFDLENBQUMsS0FBSyxTQUFTO2dCQUMxQixJQUFJLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDeEIsQ0FBQztRQUVNLFVBQVU7WUFDZixJQUFJLE9BQU8sR0FBWSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDM0QsT0FBTyxPQUFPLENBQUM7UUFDakIsQ0FBQztRQUNTLGFBQWEsQ0FBQyxRQUFpQixJQUFnQixDQUFDO0tBRTNEO0lBL2lCWSxpQkFBTyxVQStpQm5CLENBQUE7QUFDSCxDQUFDLEVBM2pCUyxTQUFTLEtBQVQsU0FBUyxRQTJqQmxCO0FDM2pCRCxJQUFVLFNBQVMsQ0FvSGxCO0FBcEhELFdBQVUsU0FBUztJQUNqQjs7O09BR0c7SUFDSCxNQUFhLE9BQVEsU0FBUSxVQUFBLE9BQU87UUFNbEMsWUFBbUIsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDLEVBQUUsS0FBYSxDQUFDO1lBQy9FLEtBQUssRUFBRSxDQUFDO1lBQ1IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUMzQixDQUFDO1FBRUQ7O1dBRUc7UUFDSCxJQUFXLFNBQVM7WUFDbEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwRCxDQUFDO1FBRUQ7O1dBRUc7UUFDSCxJQUFXLGdCQUFnQjtZQUN6QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEIsQ0FBQztRQUVEOztXQUVHO1FBQ0gsSUFBVyxLQUFLO1lBQ2QsT0FBTyxVQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVDLENBQUM7UUFFRDs7V0FFRztRQUNJLElBQUksQ0FBQyxTQUFrQjtZQUM1QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RFLENBQUM7UUFFRDs7V0FFRztRQUNJLEdBQUcsQ0FBQyxFQUFVLEVBQUUsRUFBVSxFQUFFLEVBQVUsRUFBRSxFQUFVO1lBQ3ZELElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ25ELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVEOztXQUVHO1FBQ0ksR0FBRztZQUNSLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUMsQ0FBQztRQUVEOztXQUVHO1FBQ0ksR0FBRyxDQUFDLE9BQWdCO1lBQ3pCLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQztZQUFDLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQztZQUFDLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQztZQUFDLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQztZQUNuRixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRDs7V0FFRztRQUNJLFFBQVEsQ0FBQyxXQUFvQjtZQUNsQyxJQUFJLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFDbkcsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxLQUFLLENBQUMsT0FBZTtZQUMxQixJQUFJLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQztZQUFDLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDO1lBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQztZQUMzRSxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRDs7V0FFRztRQUNJLFNBQVMsQ0FBQyxVQUFrQixDQUFDO1lBQ2xDLElBQUksZ0JBQWdCLEdBQVcsSUFBSSxDQUFDLGdCQUFnQixDQUFDO1lBQ3JELElBQUksZ0JBQWdCLElBQUksQ0FBQztnQkFDdkIsTUFBTSxDQUFDLElBQUksVUFBVSxDQUFDLDBCQUEwQixDQUFDLENBQUMsQ0FBQztZQUNyRCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQztZQUNsRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRDs7V0FFRztRQUNJLEdBQUcsQ0FBQyxNQUFlO1lBQ3hCLE9BQU8sSUFBSSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3ZGLENBQUM7UUFFTSxPQUFPO1lBQ1osSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN2QixDQUFDO1FBRU0sU0FBUztZQUNkLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUMxRSxDQUFDO1FBRU0sS0FBSyxDQUFDLFdBQVcsQ0FBQyxjQUE2QjtZQUNwRCxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFrQixjQUFjLENBQUMsQ0FBQztZQUMvRSxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFUyxhQUFhLENBQUMsUUFBaUIsSUFBaUIsQ0FBQztRQUFBLENBQUM7S0FDN0Q7SUE5R1ksaUJBQU8sVUE4R25CLENBQUE7QUFDSCxDQUFDLEVBcEhTLFNBQVMsS0FBVCxTQUFTLFFBb0hsQjtBQ3BIRCxJQUFVLFNBQVMsQ0EwRGxCO0FBMURELFdBQVUsU0FBUztJQUNqQjs7OztPQUlHO0lBQ0gsTUFBYSxJQUFJO1FBT2YsWUFBbUIsU0FBbUIsRUFBRSxPQUFlLEVBQUUsT0FBZSxFQUFFLE9BQWU7WUFObEYsWUFBTyxHQUFhLEVBQUUsQ0FBQztZQUN2QixXQUFNLEdBQWEsRUFBRSxDQUFDO1lBTTNCLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQzNDLElBQUksQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDO1lBQzFCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQzFCLENBQUM7UUFFRDs7V0FFRztRQUNJLFdBQVcsQ0FBQyxNQUFjO1lBQy9CLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3RELENBQUM7UUFFRDs7V0FFRztRQUNJLFFBQVEsQ0FBQyxNQUFlO1lBQzdCLElBQUksS0FBSyxHQUFjLEVBQUUsQ0FBQztZQUMxQixLQUFLLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDL0IsSUFBSSxJQUFJLEdBQVksVUFBQSxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUM5RSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ25CLENBQUM7WUFDRCxJQUFJLEVBQUUsR0FBWSxVQUFBLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3BELElBQUksRUFBRSxHQUFZLFVBQUEsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEQsSUFBSSxFQUFFLEdBQVksVUFBQSxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUVwRCxJQUFJLElBQUksR0FBVyxVQUFBLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ3ZDLElBQUksSUFBSSxHQUFXLFVBQUEsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFFdkMsT0FBTyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDakMsQ0FBQztRQUVPLGdCQUFnQjtZQUN0QixJQUFJLE1BQU0sR0FBYyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQWMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUM3RixJQUFJLEVBQUUsR0FBWSxVQUFBLE9BQU8sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNELElBQUksRUFBRSxHQUFZLFVBQUEsT0FBTyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDM0QsSUFBSSxDQUFDLGNBQWMsR0FBRyxVQUFBLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzVDLElBQUksQ0FBQyxNQUFNLEdBQUcsVUFBQSxPQUFPLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUN6RCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDZCxVQUFBLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUNyQixVQUFBLE9BQU8sQ0FBQyxLQUFLLENBQUMsVUFBQSxPQUFPLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFBLE9BQU8sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQ2pHLFVBQUEsT0FBTyxDQUFDLEtBQUssQ0FBQyxVQUFBLE9BQU8sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQUEsT0FBTyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDbEcsQ0FBQztRQUNKLENBQUM7S0FDRjtJQW5EWSxjQUFJLE9BbURoQixDQUFBO0FBQ0gsQ0FBQyxFQTFEUyxTQUFTLEtBQVQsU0FBUyxRQTBEbEI7QUMxREQsSUFBVSxTQUFTLENBK0NsQjtBQS9DRCxXQUFVLFNBQVM7SUFDakI7Ozs7Ozs7OztPQVNHO0lBQ0gsTUFBYSxRQUFTLFNBQVEsVUFBQSxJQUFJO2lCQUNULGNBQVMsR0FBVyxVQUFBLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUUzRSxZQUFtQixRQUFnQixVQUFVO1lBQzNDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUViLHVFQUF1RTtZQUN2RSxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksVUFBQSxRQUFRO1lBQzFCLGlCQUFpQjtZQUNqQixJQUFJLFVBQUEsTUFBTSxDQUFDLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSTtZQUNoRSxJQUFJLFVBQUEsTUFBTSxDQUFDLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJO1lBQ2pFLElBQUksVUFBQSxNQUFNLENBQUMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJO1lBQ2hFLElBQUksVUFBQSxNQUFNLENBQUMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRzthQUM5RCxDQUFDO1lBRUYsNkJBQTZCO1lBQzdCLEtBQUssSUFBSSxLQUFLLEdBQVcsRUFBRSxFQUFFLEtBQUssR0FBRyxHQUFHLEVBQUUsS0FBSyxJQUFJLEVBQUUsRUFBRSxDQUFDO2dCQUN0RCxJQUFJLFNBQVMsR0FBYyxVQUFBLFNBQVMsQ0FBQyxRQUFRLENBQUMsVUFBQSxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBQ2hFLElBQUksSUFBSSxHQUFhLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFVLEVBQUUsRUFBRSxDQUNoRSxJQUFJLFVBQUEsTUFBTSxDQUFDLFVBQUEsT0FBTyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNyRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO1lBQzlCLENBQUM7WUFDRCx1Q0FBdUM7WUFDdkMsS0FBSyxJQUFJLEtBQUssR0FBVyxFQUFFLEVBQUUsS0FBSyxHQUFHLEdBQUcsRUFBRSxLQUFLLElBQUksR0FBRyxFQUFFLENBQUM7Z0JBQ3ZELElBQUksU0FBUyxHQUFjLFVBQUEsU0FBUyxDQUFDLFFBQVEsQ0FBQyxVQUFBLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDaEUsSUFBSSxJQUFJLEdBQWEsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQVUsRUFBRSxFQUFFLENBQ2hFLElBQUksVUFBQSxNQUFNLENBQUMsVUFBQSxPQUFPLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ3JFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7WUFDOUIsQ0FBQztZQUVELElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO1lBQ2hCLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUM7Z0JBQ3BDLGlCQUFpQjtnQkFDakIsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLFVBQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2xGLENBQUM7O0lBbENVLGtCQUFRLFdBbUNwQixDQUFBO0FBQ0gsQ0FBQyxFQS9DUyxTQUFTLEtBQVQsU0FBUyxRQStDbEI7QUMvQ0QsSUFBVSxTQUFTLENBbUdsQjtBQW5HRCxXQUFVLFNBQVM7SUFDakI7Ozs7Ozs7Ozs7T0FVRztJQUNILE1BQWEsV0FBWSxTQUFRLFVBQUEsSUFBSTtpQkFDWixjQUFTLEdBQVcsVUFBQSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLEFBQTdDLENBQThDO2lCQUM3RCxpQkFBWSxHQUFjO1lBQ3pDLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbkIsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbEIsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ2xCLEFBSjRCLENBSTNCO1FBSUYsWUFBbUIsUUFBZ0IsYUFBYSxFQUFFLFNBQW9CLFdBQVcsQ0FBQyxZQUFZLEVBQUUsY0FBdUIsSUFBSTtZQUN6SCxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7WUFKTCxVQUFLLEdBQTBCLElBQUksVUFBQSxZQUFZLENBQVUsVUFBQSxPQUFPLENBQUMsQ0FBQztZQUsxRSxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQztRQUNuQyxDQUFDO1FBRUQsSUFBYyxXQUFXO1lBQ3ZCLE9BQU8sQ0FBQyxDQUFDO1FBQ1gsQ0FBQztRQUVEOztXQUVHO1FBQ0ksTUFBTSxDQUFDLFNBQW9CLEVBQUUsRUFBRSxjQUF1QixJQUFJO1lBQy9ELElBQUksQ0FBQyxLQUFLLEdBQTBCLFVBQUEsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDNUYsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUM7WUFFOUIsSUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDckMsVUFBQSxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLFdBQVcsZ0VBQWdFLENBQUMsQ0FBQztnQkFDekcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUM1QyxPQUFPO1lBQ1QsQ0FBQztZQUVELElBQUksS0FBSyxHQUFjLE1BQU0sQ0FBQztZQUU5QixJQUFJLEdBQUcsR0FBWSxVQUFBLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNsQyxJQUFJLEdBQUcsR0FBWSxVQUFBLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNsQyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksVUFBQSxRQUFRLEVBQUUsQ0FBQztZQUMvQixLQUFLLElBQUksTUFBTSxJQUFJLEtBQUssRUFBRSxDQUFDO2dCQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQUEsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBRW5ELEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbEMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNsQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2xDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQyxDQUFDO1lBQ0QsSUFBSSxJQUFJLEdBQVksSUFBSSxVQUFBLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFOUQsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7Z0JBQ3BCLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7b0JBQzlDLElBQUksU0FBUyxHQUFZLFVBQUEsT0FBTyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7b0JBQzNELElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLElBQUksVUFBQSxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDcEYsQ0FBQztZQUNILENBQUM7aUJBQU0sQ0FBQztnQkFDTixNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxVQUFBLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDN0YsQ0FBQztZQUVELElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO1lBQ2hCLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUU7Z0JBQ25ELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksVUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzFELENBQUM7UUFFRCxrQkFBa0I7UUFDWCxTQUFTO1lBQ2QsSUFBSSxhQUFhLEdBQWtCLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNyRCxhQUFhLENBQUMsS0FBSyxHQUFHLFVBQUEsVUFBVSxDQUFDLGNBQWMsQ0FBQyxVQUFBLE9BQU8sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDckUsYUFBYSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1lBQzNDLE9BQU8sYUFBYSxDQUFDO1FBQ3ZCLENBQUM7UUFDTSxLQUFLLENBQUMsV0FBVyxDQUFDLGNBQTZCO1lBQ3BELE1BQU0sS0FBSyxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUN4QyxJQUFJLE9BQU8sR0FBeUIsTUFBTSxVQUFBLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDNUYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2hELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVNLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBaUIsRUFBRSxhQUF1QixJQUFJLEVBQUUsa0JBQTJCLElBQUk7WUFDakcsTUFBTSxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxVQUFVLEVBQUUsZUFBZSxDQUFDLENBQUM7WUFDMUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN6QyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksS0FBSyw2QkFBYyxDQUFDLENBQUM7UUFDOUMsQ0FBQztRQUVTLGFBQWEsQ0FBQyxRQUFpQjtZQUN2QyxLQUFLLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2hDLENBQUM7O0lBcEZVLHFCQUFXLGNBc0Z2QixDQUFBO0FBQ0gsQ0FBQyxFQW5HUyxTQUFTLEtBQVQsU0FBUyxRQW1HbEI7QUNuR0QscUNBQXFDO0FBQ3JDLElBQVUsU0FBUyxDQXVIbEI7QUF4SEQscUNBQXFDO0FBQ3JDLFdBQVUsU0FBUztJQUNqQjs7Ozs7Ozs7OztPQVVHO0lBQ0gsTUFBYSxhQUFjLFNBQVEsVUFBQSxXQUFXO2lCQUNyQixjQUFTLEdBQVcsVUFBQSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLEFBQS9DLENBQWdEO2lCQUMvRCxnQkFBVyxHQUFnQjtZQUMxQyxVQUFBLFNBQVMsQ0FBQyxXQUFXLENBQUMsVUFBQSxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3JDLFVBQUEsU0FBUyxDQUFDLFdBQVcsQ0FBQyxVQUFBLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN2QyxBQUgyQixDQUcxQjtRQUdGLFlBQW1CLFFBQWdCLGVBQWUsRUFBRSxZQUF1QixVQUFBLFdBQVcsQ0FBQyxZQUFZLEVBQUUsaUJBQThCLGFBQWEsQ0FBQyxXQUFXLEVBQUUsY0FBdUIsSUFBSTtZQUN2TCxLQUFLLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxXQUFXLENBQUMsQ0FBQztZQUgvQixrQkFBYSxHQUE0QixJQUFJLFVBQUEsWUFBWSxDQUFDLFVBQUEsU0FBUyxDQUFDLENBQUM7WUFJM0UsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUM3Qiw2Q0FBNkM7UUFDL0MsQ0FBQztRQUVELGtCQUFrQjtRQUNYLFNBQVM7WUFDZCxJQUFJLGFBQWEsR0FBa0IsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ3JELGFBQWEsQ0FBQyxVQUFVLEdBQUcsVUFBQSxVQUFVLENBQUMsY0FBYyxDQUFDLFVBQUEsU0FBUyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUNwRixPQUFPLGFBQWEsQ0FBQztRQUN2QixDQUFDO1FBRU0sS0FBSyxDQUFDLFdBQVcsQ0FBQyxjQUE2QjtZQUNwRCxNQUFNLEtBQUssQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDeEMsSUFBSSxhQUEwQixDQUFDO1lBQy9CLElBQUksY0FBYyxDQUFDLFVBQVU7Z0JBQzNCLGFBQWEsR0FBZ0IsTUFBTSxVQUFBLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDNUYsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUM1QixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFTSxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQWlCLEVBQUUsYUFBdUIsSUFBSSxFQUFFLGtCQUEyQixJQUFJO1lBQ2pHLE1BQU0sS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFLGVBQWUsQ0FBQyxDQUFDO1lBQzFELElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxLQUFLLDZCQUFjLENBQUMsQ0FBQztRQUM5QyxDQUFDO1FBRVMsYUFBYSxDQUFDLFFBQWlCO1lBQ3ZDLEtBQUssQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEMsQ0FBQztRQUNELFlBQVk7UUFFSixPQUFPLENBQUMsaUJBQThCLGFBQWEsQ0FBQyxXQUFXO1lBQ3JFLElBQUksQ0FBQyxhQUFhLEdBQTRCLFVBQUEsWUFBWSxDQUFDLElBQUksQ0FBMEIsY0FBYyxDQUFDLENBQUM7WUFDekcsSUFBSSxXQUFXLEdBQVcsY0FBYyxDQUFDLE1BQU0sQ0FBQztZQUNoRCxJQUFJLGNBQWMsR0FBVyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztZQUVsRCwyREFBMkQ7WUFDM0QsSUFBSSxRQUFRLEdBQWEsSUFBSSxVQUFBLFFBQVEsRUFBRSxDQUFDO1lBRXhDLGdFQUFnRTtZQUNoRSxJQUFJLElBQUksR0FBYSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQVUsRUFBRSxFQUFFLENBQUMsSUFBSSxVQUFBLE1BQU0sQ0FBQyxVQUFBLE9BQU8sQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDeEksUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO1lBQ3ZCLDhEQUE4RDtZQUM5RCxJQUFJLEdBQUcsR0FBYSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQVUsRUFBRSxFQUFFLENBQUMsSUFBSSxVQUFBLE1BQU0sQ0FBQyxVQUFBLE9BQU8sQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxjQUFjLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3JKLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztZQUV0Qiw2Q0FBNkM7WUFDN0MsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQVcsRUFBRSxFQUFFLENBQUMsSUFBSSxVQUFBLElBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZILGtIQUFrSDtZQUNsSCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQ3hDLElBQUksVUFBQSxJQUFJLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsY0FBYyxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsY0FBYyxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsY0FBYyxDQUFDLENBQzVILENBQUMsQ0FBQztZQUVILEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztnQkFDN0MsSUFBSSxZQUFZLEdBQWMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNoRCxJQUFJLFlBQVksR0FBVyxRQUFRLENBQUMsTUFBTSxDQUFDO2dCQUMzQyxJQUFJLElBQUksR0FBYSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQVUsRUFBRSxFQUFVLEVBQUUsRUFBRSxDQUNoRSxJQUFJLFVBQUEsTUFBTSxDQUFDLFVBQUEsT0FBTyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLFlBQVksRUFBRSxJQUFJLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLEVBQUUsR0FBRyxjQUFjLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQ3ZILENBQUM7Z0JBQ0YsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO2dCQUN2QixRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksVUFBQSxNQUFNLENBQUMsWUFBWSxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pFLG9DQUFvQztnQkFDcEMsMkdBQTJHO1lBQzdHLENBQUM7WUFFRCw2QkFBNkI7WUFDN0IsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFO2dCQUM5QyxLQUFLLElBQUksQ0FBQyxHQUFXLENBQUMsRUFBRSxDQUFDLEdBQUcsY0FBYyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7b0JBQ2hELElBQUksS0FBSyxHQUNQLENBQUUsQ0FBQyxHQUFHLGNBQWMsQ0FBQywwQkFBMEI7MEJBQzdDLENBQUMsR0FBRyxDQUFDLGNBQWMsR0FBRyxDQUFDLENBQUMsQ0FBQyxpQ0FBaUM7MEJBQzFELENBQUMsQ0FBQztvQkFDTixJQUFJLElBQUksR0FBUyxJQUFJLFVBQUEsSUFBSSxDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsS0FBSyxHQUFHLGNBQWMsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLGNBQWMsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLENBQUMsRUFBRSxVQUFBLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDOUgsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ2pDLENBQUM7WUFFSCxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztZQUN6QixPQUFPO1FBQ1QsQ0FBQzs7SUF4RlUsdUJBQWEsZ0JBMEd6QixDQUFBO0FBQ0gsQ0FBQyxFQXZIUyxTQUFTLEtBQVQsU0FBUyxRQXVIbEI7QUN4SEQsSUFBVSxTQUFTLENBNElsQjtBQTVJRCxXQUFVLFNBQVM7SUFFakI7OztPQUdHO0lBQ0gsTUFBYSxPQUFRLFNBQVEsVUFBQSxpQ0FBaUMsQ0FBQyxVQUFBLElBQUksQ0FBQztRQUczRCxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQW9CLElBQUksQ0FBQyxHQUFHLEVBQUUsU0FBaUIsSUFBSSxDQUFDLEtBQUs7WUFDekUsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7WUFDaEIsSUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUM7WUFDcEIsTUFBTSxNQUFNLEdBQWMsTUFBTSxVQUFBLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1lBQ3BFLE1BQU0sV0FBVyxHQUFpQixDQUNoQyxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDO2dCQUNyQyxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDO2dCQUN4RSxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxPQUFPLElBQUksTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUM5RyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ1QsSUFBSSxXQUFXO2dCQUNiLElBQUksQ0FBQyxJQUFJLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztZQUUzRixJQUFJLFNBQVMsR0FBYyxFQUFFLENBQUM7WUFDOUIsSUFBSSxZQUFZLEdBQWlCLFdBQVcsQ0FBQyxRQUFRLENBQUM7WUFDdEQsS0FBSyxJQUFJLE9BQU8sR0FBVyxDQUFDLEVBQUUsT0FBTyxHQUFHLFlBQVksQ0FBQyxNQUFNLEVBQUUsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUMxRSxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksVUFBQSxPQUFPLENBQUMsWUFBWSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQy9HLENBQUM7WUFFRCxJQUFJLEdBQUcsR0FBYyxFQUFFLENBQUM7WUFDeEIsSUFBSSxXQUFXLENBQUMsY0FBYyxFQUFFLENBQUM7Z0JBQy9CLElBQUksUUFBUSxHQUFpQixXQUFXLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQztnQkFDM0QsS0FBSyxJQUFJLEdBQUcsR0FBVyxDQUFDLEVBQUUsR0FBRyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO29CQUMxRCxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksVUFBQSxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUQsQ0FBQztZQUNILENBQUM7WUFFRCxJQUFJLE9BQU8sR0FBYyxFQUFFLENBQUM7WUFDNUIsSUFBSSxXQUFXLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztnQkFDbkMsSUFBSSxZQUFZLEdBQWlCLFdBQVcsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUM7Z0JBQ3hFLEtBQUssSUFBSSxPQUFPLEdBQVcsQ0FBQyxFQUFFLE9BQU8sR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQztvQkFDMUUsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQUEsT0FBTyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsRUFBRSxZQUFZLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN6RyxDQUFDO1lBQ0gsQ0FBQztZQUVELElBQUksZ0JBQWdCLEdBQXdCLElBQUksR0FBRyxFQUFFLENBQUM7WUFDdEQsSUFBSSxnQkFBZ0IsR0FBZSxFQUFFLENBQUM7WUFDdEMsSUFBSSxRQUFRLEdBQVcsQ0FBQyxDQUFDO1lBQ3pCLElBQUksY0FBYyxHQUFZLEtBQUssQ0FBQztZQUNwQyxJQUFJLE9BQU8sR0FBYSxFQUFFLENBQUM7WUFFM0IsV0FBVyxDQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsRUFBRSxlQUFlLEVBQUUsRUFBRTtnQkFDbkUsSUFBSSxRQUFRLEdBQUcsQ0FBQyxFQUFFLENBQUM7b0JBQ2pCLFFBQVEsR0FBRyxRQUFRLEdBQUcsQ0FBRSxDQUFDLENBQUM7b0JBQzFCLGNBQWMsR0FBRyxJQUFJLENBQUM7Z0JBQ3hCLENBQUM7Z0JBRUQsSUFBSSxRQUFRLEdBQVksU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUM1QyxJQUFJLEVBQUUsR0FBWSxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsY0FBYyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsZUFBZSxDQUFDLENBQUMsQ0FBQztnQkFFMUcsSUFBSSxTQUFTLEdBQVcsUUFBUSxDQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDNUQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDO29CQUNyQyxJQUFJLE1BQU0sR0FBWSxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsa0JBQWtCLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDO29CQUV0SCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQUEsTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztvQkFDckQsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztvQkFDMUQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQzt3QkFDN0IsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUNsQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQzVELENBQUM7Z0JBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztnQkFFOUMsSUFBSSxjQUFjLEVBQUUsQ0FBQztvQkFDbkIsSUFBSSxPQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDO3dCQUN4QixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUMvRSxDQUFDO3lCQUFNLElBQUksT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQzt3QkFDL0IsSUFBSSxJQUFJLEdBQVMsSUFBSSxVQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUN6RixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDakMsQ0FBQzt5QkFBTSxDQUFDO3dCQUNOLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRTs0QkFDN0MsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxVQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUN2RixnR0FBZ0c7b0JBQ2xHLENBQUM7b0JBQ0QsT0FBTyxHQUFHLEVBQUUsQ0FBQztvQkFDYixjQUFjLEdBQUcsS0FBSyxDQUFDO29CQUN2QixRQUFRLEVBQUUsQ0FBQztnQkFDYixDQUFDO1lBQ0gsQ0FBQyxDQUFDLENBQUM7WUFFSCxJQUFJLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksVUFBVSxFQUFFLENBQUM7Z0JBQ2pELE1BQU0sV0FBVyxHQUFpQixXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMxRCxNQUFNLFFBQVEsR0FBc0IsTUFBTSxNQUFNLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxnQ0FBZ0M7Z0JBQ25JLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLGdCQUFnQixDQUFDLENBQUM7WUFDM0UsQ0FBQztZQUNELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVNLFNBQVM7WUFDZCxNQUFNLGFBQWEsR0FBa0IsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ3ZELGFBQWEsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUNqQyxPQUFPLGFBQWEsQ0FBQztRQUN2QixDQUFDO1FBRU0sS0FBSyxDQUFDLFdBQVcsQ0FBQyxjQUE2QjtZQUNwRCxJQUFJLENBQUMsS0FBSyxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7WUFDbEMsT0FBTyxLQUFLLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQzNDLENBQUM7UUFFTyxZQUFZLENBQUMsYUFBMEQsRUFBRSxRQUFnQixFQUFFLFNBQWlCLEVBQUUsZUFBdUI7WUFDM0ksSUFBSSxLQUFLLEdBQ1AsYUFBYSxDQUFDLHNCQUFzQixJQUFJLFVBQVUsQ0FBQyxDQUFDO2dCQUNsRCxRQUFRLENBQUMsQ0FBQztnQkFDVixhQUFhLENBQUMsc0JBQXNCLElBQUksV0FBVyxDQUFDLENBQUM7b0JBQ25ELFNBQVMsQ0FBQyxDQUFDO29CQUNYLGVBQWUsQ0FBQztZQUV0QixJQUFJLGFBQWEsQ0FBQyx3QkFBd0IsS0FBSyxlQUFlLEVBQUUsQ0FBQztnQkFDL0QsSUFBSSxPQUFPLEdBQWlCLGFBQW9DLENBQUMsT0FBTyxJQUFLLGFBQXdDLENBQUMsWUFBWSxDQUFDO2dCQUNuSSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3pCLENBQUM7WUFFRCxPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFFTyxXQUFXLENBQUMsWUFBMEIsRUFBRSxTQUE0QixFQUFFLFNBQW1CLEVBQUUsaUJBQThCO1lBQy9ILEtBQUssTUFBTSxjQUFjLElBQUksWUFBWSxDQUFDLFFBQTZCLEVBQUUsQ0FBQztnQkFDeEUsY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUN0QixJQUFJLGNBQWMsQ0FBQyxPQUFPO29CQUN4QixLQUFLLElBQUksY0FBYyxHQUFXLENBQUMsRUFBRSxjQUFjLEdBQUcsY0FBYyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsY0FBYyxFQUFFLEVBQUUsQ0FBQzt3QkFDdEcsTUFBTSxPQUFPLEdBQVcsY0FBYyxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQzt3QkFDL0QsS0FBSyxNQUFNLFVBQVUsSUFBSSxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQzs0QkFDcEYsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztnQ0FDdkUsS0FBSyxFQUFFLFNBQVMsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7Z0NBQ3pELE1BQU0sRUFBRSxjQUFjLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUM7NkJBQ3BELENBQUMsQ0FBQzt3QkFDTCxDQUFDO29CQUVILENBQUM7WUFDTCxDQUFDO1FBQ0gsQ0FBQztLQUNGO0lBcklZLGlCQUFPLFVBcUluQixDQUFBO0FBQ0gsQ0FBQyxFQTVJUyxTQUFTLEtBQVQsU0FBUyxRQTRJbEI7QUM1SUQsSUFBVSxTQUFTLENBaUNsQjtBQWpDRCxXQUFVLFNBQVM7SUFFakIscURBQXFEO0lBQ3JELE1BQWEsWUFBYSxTQUFRLFVBQUEsSUFBSTtRQU1wQyxZQUFtQixTQUF1QixFQUFFLFdBQXlCLEVBQUUsUUFBcUIsRUFBRSxZQUEwQjtZQUN0SCxLQUFLLEVBQUUsQ0FBQztZQUNSLElBQUksQ0FBQyxhQUFhLEdBQUcsU0FBUyxDQUFDO1lBQy9CLElBQUksQ0FBQyxlQUFlLEdBQUcsV0FBVyxDQUFDO1lBQ25DLElBQUksQ0FBQyxZQUFZLEdBQUcsUUFBUSxDQUFDO1lBQzdCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxZQUFZLENBQUM7UUFDdkMsQ0FBQztRQUVTLGNBQWM7WUFDdEIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQzVCLENBQUM7UUFFUyxnQkFBZ0I7WUFDeEIsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDO1FBQzlCLENBQUM7UUFFUyxhQUFhO1lBQ3JCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztRQUMzQixDQUFDO1FBRVMsaUJBQWlCO1lBQ3pCLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDO1FBQy9CLENBQUM7S0FDRjtJQTdCWSxzQkFBWSxlQTZCeEIsQ0FBQTtBQUNILENBQUMsRUFqQ1MsU0FBUyxLQUFULFNBQVMsUUFpQ2xCO0FDakNELElBQVUsU0FBUyxDQTJCbEI7QUEzQkQsV0FBVSxTQUFTO0lBRWpCOzs7T0FHRztJQUNILE1BQWEsUUFBUyxTQUFRLFVBQUEsaUNBQWlDLENBQUMsVUFBQSxJQUFJLENBQUM7UUFHNUQsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFvQixJQUFJLENBQUMsR0FBRyxFQUFFLFFBQWdCLElBQUksQ0FBQyxJQUFJLEVBQUUsY0FBc0IsSUFBSSxDQUFDLFVBQVU7WUFDOUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7WUFDaEIsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7WUFDbEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUM7WUFDOUIsT0FBTyxVQUFBLFVBQVUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkMsQ0FBQztRQUVNLFNBQVM7WUFDZCxNQUFNLGFBQWEsR0FBa0IsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ3ZELGFBQWEsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztZQUMzQyxPQUFPLGFBQWEsQ0FBQztRQUN2QixDQUFDO1FBRU0sV0FBVyxDQUFDLGNBQTZCO1lBQzlDLElBQUksQ0FBQyxVQUFVLEdBQUcsY0FBYyxDQUFDLFVBQVUsQ0FBQztZQUM1QyxPQUFPLEtBQUssQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDM0MsQ0FBQztLQUNGO0lBcEJZLGtCQUFRLFdBb0JwQixDQUFBO0FBQ0gsQ0FBQyxFQTNCUyxTQUFTLEtBQVQsU0FBUyxRQTJCbEI7QUMzQkQsSUFBVSxTQUFTLENBb0ZsQjtBQXBGRCxXQUFVLFNBQVM7SUFDakI7Ozs7Ozs7T0FPRztJQUNILE1BQWEsT0FBUSxTQUFRLFVBQUEsaUNBQWlDLENBQUMsVUFBQSxJQUFJLENBQUM7UUFFM0QsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFvQixJQUFJLENBQUMsR0FBRztZQUM1QyxNQUFNLEdBQUcsR0FBVyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsVUFBQSxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDekUsTUFBTSxJQUFJLEdBQVcsTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDckQsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ2pDLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDO1lBRWhCLE1BQU0sS0FBSyxHQUFhLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFekMsTUFBTSxPQUFPLEdBQWEsRUFBRSxDQUFDO1lBQzdCLE1BQU0sU0FBUyxHQUFjLEVBQUUsQ0FBQztZQUNoQyxNQUFNLEdBQUcsR0FBYyxFQUFFLENBQUM7WUFDMUIsTUFBTSxPQUFPLEdBQWMsRUFBRSxDQUFDO1lBQzlCLE1BQU0sS0FBSyxHQUFhLEVBQUUsQ0FBQztZQUUzQixNQUFNLFFBQVEsR0FBYSxJQUFJLFVBQUEsUUFBUSxFQUFFLENBQUM7WUFDMUMsTUFBTSxLQUFLLEdBQVcsRUFBRSxDQUFDO1lBQ3pCLE1BQU0sMEJBQTBCLEdBQThCLEVBQUUsQ0FBQztZQUNqRSxNQUFNLHdCQUF3QixHQUE4QixFQUFFLENBQUM7WUFFL0QsK0VBQStFO1lBQy9FLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxFQUFFLENBQUM7Z0JBQ3ZCLE1BQU0sS0FBSyxHQUFhLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQy9DLFFBQVEsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7b0JBQ3RCLEtBQUssR0FBRyxFQUFFLCtDQUErQzt3QkFDdkQsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQUEsT0FBTyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUM3RCxNQUFNO29CQUNSLEtBQUssSUFBSSxFQUFFLHFDQUFxQzt3QkFDOUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQUEsT0FBTyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUMzRCxNQUFNO29CQUNSLEtBQUssSUFBSSxFQUFFLDBDQUEwQzt3QkFDbkQsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQUEsT0FBTyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUMxRixNQUFNO29CQUNSLEtBQUssR0FBRyxFQUFFLGlJQUFpSTt3QkFDekksS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDOzRCQUNuQyxJQUFJLEdBQUcsR0FBVyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7NEJBQzNCLElBQUksS0FBSyxHQUF1QiwwQkFBMEIsQ0FBQyxHQUFHLENBQUMsQ0FBQzs0QkFDaEUsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFLENBQUM7Z0NBQ3hCLEtBQUssR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDO2dDQUN4QixNQUFNLFVBQVUsR0FBYSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dDQUNqRCxJQUFJLFFBQVEsR0FBWSxTQUFTLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQywyQkFBMkI7Z0NBQ2xGLElBQUksRUFBRSxHQUFZLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUM7Z0NBQ3ZELElBQUksTUFBTSxHQUFZLE9BQU8sQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUM7Z0NBRS9ELElBQUksTUFBTTtvQ0FDUixLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0NBRTNDLElBQUksVUFBVSxHQUFXLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2dDQUM3RCxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksVUFBQSxNQUFNLENBQUMsd0JBQXdCLENBQUMsVUFBVSxDQUFDLElBQUksUUFBUSxFQUFFLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO2dDQUN4RiwwQkFBMEIsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7Z0NBQ3hDLElBQUksd0JBQXdCLENBQUMsVUFBVSxDQUFDLElBQUksU0FBUztvQ0FDbkQsd0JBQXdCLENBQUMsVUFBVSxDQUFDLEdBQUcsS0FBSyxDQUFDOzRCQUNqRCxDQUFDOzRCQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBQ3RCLENBQUM7d0JBQ0QsSUFBSSxDQUFDOzRCQUNILEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxVQUFBLElBQUksQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUN4SCxDQUFDO3dCQUFDLE9BQU8sRUFBVyxFQUFFLENBQUM7NEJBQ3JCLFVBQUEsS0FBSyxDQUFDLEtBQUssQ0FBQyxlQUFlLEVBQVUsRUFBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO3dCQUNwRCxDQUFDO3dCQUNELE1BQU07Z0JBQ1YsQ0FBQztZQUNILENBQUM7WUFFRCxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDYixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztZQUN6QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztZQUNuQixJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLDBJQUEwSTtnQkFDOUosSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEdBQUcsSUFBSSxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDcEQsdUdBQXVHO1lBRXZHLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztLQUNGO0lBMUVZLGlCQUFPLFVBMEVuQixDQUFBO0FBQ0gsQ0FBQyxFQXBGUyxTQUFTLEtBQVQsU0FBUyxRQW9GbEI7QUNwRkQsSUFBVSxTQUFTLENBMENsQjtBQTFDRCxXQUFVLFNBQVM7SUFDakI7Ozs7Ozs7OztPQVNHO0lBQ0gsTUFBYSxXQUFZLFNBQVEsVUFBQSxJQUFJO2lCQUNaLGNBQVMsR0FBVyxVQUFBLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUU5RSxZQUFtQixRQUFnQixhQUFhO1lBQzlDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNiLGlCQUFpQjtZQUVqQixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksVUFBQSxRQUFRO1lBQzFCLGtCQUFrQjtZQUNsQixJQUFJLFVBQUEsTUFBTSxDQUFDLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQzFELElBQUksVUFBQSxNQUFNLENBQUMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQ3pELElBQUksVUFBQSxNQUFNLENBQUMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFDMUQsSUFBSSxVQUFBLE1BQU0sQ0FBQyxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzNELGtCQUFrQjtZQUNsQixJQUFJLFVBQUEsTUFBTSxDQUFDLElBQUksVUFBQSxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUM3RCxtQ0FBbUM7WUFDbkMsSUFBSSxVQUFBLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFDaEMsSUFBSSxVQUFBLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFDaEMsSUFBSSxVQUFBLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFDaEMsSUFBSSxVQUFBLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FDakMsQ0FBQztZQUNGLElBQUksQ0FBQyxLQUFLLEdBQUc7Z0JBQ1gsSUFBSSxVQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUNoQyxJQUFJLFVBQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ2hDLElBQUksVUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDaEMsSUFBSSxVQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUNoQyxJQUFJLFVBQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQzVDLElBQUksVUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUM3QyxDQUFDO1FBQ0osQ0FBQzs7SUE3QlUscUJBQVcsY0E4QnZCLENBQUE7QUFDSCxDQUFDLEVBMUNTLFNBQVMsS0FBVCxTQUFTLFFBMENsQjtBQzFDRCxJQUFVLFNBQVMsQ0F5Q2xCO0FBekNELFdBQVUsU0FBUztJQUNqQjs7Ozs7Ozs7T0FRRztJQUNILE1BQWEsUUFBUyxTQUFRLFVBQUEsV0FBVztpQkFDaEIsY0FBUyxHQUFXLFVBQUEsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDO2lCQUMxRCxVQUFLLEdBQWM7WUFDbEMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLFVBQUEsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUM7U0FDL0YsQ0FBQztRQUVGLFlBQW1CLFFBQWdCLFVBQVU7WUFDM0MsS0FBSyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDL0IsQ0FBQztRQUVELHdCQUF3QjtRQUN4QixvRUFBb0U7UUFDcEUsaUVBQWlFO1FBQ2pFLHdFQUF3RTtRQUV4RSxrQkFBa0I7UUFDWCxTQUFTO1lBQ2QsSUFBSSxhQUFhLEdBQWtCLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUNyRCxPQUFPLGFBQWEsQ0FBQztRQUN2QixDQUFDO1FBQ00sS0FBSyxDQUFDLFdBQVcsQ0FBQyxjQUE2QjtZQUNwRCxNQUFNLEtBQUssQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDeEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsd0VBQXdFO1lBQzNHLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUNTLGFBQWEsQ0FBQyxRQUFpQjtZQUN2QyxLQUFLLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzlCLE9BQU8sUUFBUSxDQUFDLEtBQUssQ0FBQztZQUN0QixPQUFPLFFBQVEsQ0FBQyxVQUFVLENBQUM7UUFDN0IsQ0FBQzs7SUE3QlUsa0JBQVEsV0E4QnBCLENBQUE7QUFDSCxDQUFDLEVBekNTLFNBQVMsS0FBVCxTQUFTLFFBeUNsQjtBQ3pDRCxJQUFVLFNBQVMsQ0FrTGxCO0FBbExELFdBQVUsU0FBUztJQVVqQjs7T0FFRztJQUNILE1BQWEsV0FBVztLQWF2QjtJQWJZLHFCQUFXLGNBYXZCLENBQUE7SUFFRDs7Ozs7O09BTUc7SUFDSCxNQUFhLFdBQVksU0FBUSxVQUFBLElBQUk7aUJBQ1osY0FBUyxHQUFXLFVBQUEsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxBQUE3QyxDQUE4QztRQU05RSxZQUFtQixRQUFnQixhQUFhLEVBQUUsY0FBdUIsVUFBQSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLGNBQXVCLFVBQUEsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLGtCQUE4QyxDQUFDO1lBQzVLLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUhMLHNCQUFpQixHQUFzQixJQUFJLENBQUM7WUFJcEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1FBQ3pELENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxjQUF1QixVQUFBLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsY0FBdUIsVUFBQSxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsa0JBQThDLENBQUM7WUFDeEksSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDLElBQUksR0FBRyxTQUFTLENBQUM7WUFDdEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLFVBQUEsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEYsSUFBSSxDQUFDLEtBQUssR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDO1lBRS9CLElBQUksZUFBZSxZQUFZLFFBQVE7Z0JBQ3JDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxlQUFlLENBQUM7aUJBQ3RDLElBQUksT0FBTyxDQUFDLGVBQWUsQ0FBQyxJQUFJLFFBQVEsRUFBRSxDQUFDO2dCQUM5QyxJQUFJLENBQUMsSUFBSSxHQUFHLGVBQWUsQ0FBQztnQkFDNUIsSUFBSSxJQUFJLEdBQVcsSUFBSSxVQUFBLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3pDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLFVBQUEsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLGlCQUFpQjtZQUNyRixDQUFDOztnQkFDQyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxVQUFBLE1BQU0sRUFBRSxDQUFDLE1BQU0sQ0FBQztZQUUvQyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksVUFBQSxRQUFRLEVBQUUsQ0FBQztZQUMvQixxREFBcUQ7WUFDckQsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7Z0JBQ3BELEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO29CQUNwRCxJQUFJLEtBQUssR0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7b0JBQzFDLElBQUksS0FBSyxHQUFXLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztvQkFDMUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxVQUFBLE1BQU0sQ0FDM0IsSUFBSSxVQUFBLE9BQU8sQ0FBQyxLQUFLLEdBQUcsR0FBRyxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxHQUFHLEdBQUcsQ0FBQyxFQUN6RyxJQUFJLFVBQUEsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FDMUIsQ0FBQyxDQUFDO2dCQUNMLENBQUM7WUFDSCxDQUFDO1lBRUQsSUFBSSxLQUFLLEdBQVcsRUFBRSxDQUFDO1lBQ3ZCLElBQUksS0FBSyxHQUFjLFVBQUEsU0FBUyxDQUFDLElBQUksQ0FBQztZQUN0QyxLQUFLLElBQUksQ0FBQyxHQUFXLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztnQkFDbkQsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7b0JBQ25ELEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxVQUFBLElBQUksQ0FDakIsSUFBSSxDQUFDLFFBQVEsRUFDYixDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUMzQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUMzQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUMzQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUMzQyxLQUFLLENBQ04sQ0FBQyxDQUFDO29CQUNILEtBQUssR0FBRyxDQUFDLEtBQUssSUFBSSxVQUFBLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBQSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFBLFNBQVMsQ0FBQyxJQUFJLENBQUM7Z0JBQ3RFLENBQUM7Z0JBQ0QsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLG9EQUFvRDtvQkFDbEYsS0FBSyxHQUFHLENBQUMsS0FBSyxJQUFJLFVBQUEsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFBLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFVBQUEsU0FBUyxDQUFDLElBQUksQ0FBQztZQUN4RSxDQUFDO1lBQ0QsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBVyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0QsQ0FBQztRQUVEOzs7O1dBSUc7UUFDSSxjQUFjLENBQUMsU0FBa0IsRUFBRSxZQUF1QixVQUFBLFNBQVMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxXQUF1QjtZQUM1RyxJQUFJLENBQUMsV0FBVztnQkFDZCxXQUFXLEdBQUcsVUFBQSxTQUFTLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBRTdDLElBQUksV0FBVyxHQUFnQixJQUFJLFdBQVcsQ0FBQztZQUUvQyxJQUFJLFFBQVEsR0FBWSxVQUFBLE9BQU8sQ0FBQyxjQUFjLENBQUMsU0FBUyxFQUFFLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUc3RSxJQUFJLENBQUMsR0FBVyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ25FLElBQUksQ0FBQyxHQUFXLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQztnQkFDMUUsT0FBTyxJQUFJLENBQUM7WUFFZCxJQUFJLEtBQUssR0FBVyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDcEQsSUFBSSxJQUFJLEdBQVMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUVuQyxJQUFJLEdBQUcsR0FBUSxJQUFJLFVBQUEsR0FBRyxDQUFDLFVBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQzlDLElBQUksS0FBSyxHQUFZLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNsRCxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUMxQixLQUFLLEVBQUUsQ0FBQztnQkFDUixJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDekIsS0FBSyxHQUFHLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN2QyxDQUFDO1lBRUQsV0FBVyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7WUFDMUIsV0FBVyxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7WUFDakMsV0FBVyxDQUFDLFFBQVEsR0FBRyxVQUFBLE9BQU8sQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUN0RSxXQUFXLENBQUMsTUFBTSxHQUFHLFVBQUEsT0FBTyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFVBQUEsU0FBUyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUNsRyxXQUFXLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDNUQsV0FBVyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDcEQsT0FBTyxXQUFXLENBQUM7UUFDckIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksb0JBQW9CLENBQUMsTUFBYztZQUN4QyxJQUFJLE1BQU0sR0FBWSxVQUFBLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBQSxPQUFPLENBQUMsQ0FBQztZQUM1QyxJQUFJLEtBQUssR0FBVyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMzQyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDN0UsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUVEOztXQUVHO1FBQ0ksc0JBQXNCLENBQUMsS0FBYztZQUMxQyxJQUFJLEtBQUssR0FBVyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNsRSxPQUFPLENBQUMsS0FBSyxFQUFFLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztRQUM1QixDQUFDO1FBRUQsa0JBQWtCO1FBQ1gsU0FBUztZQUNkLElBQUksYUFBYSxHQUFrQixLQUFLLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDckQsYUFBYSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQy9CLGFBQWEsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUM3QyxhQUFhLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDdkQsT0FBTyxhQUFhLENBQUM7UUFDdkIsQ0FBQztRQUNNLEtBQUssQ0FBQyxXQUFXLENBQUMsY0FBNkI7WUFDcEQsTUFBTSxLQUFLLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ3hDLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQzdELE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ25ELElBQUksQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQztZQUNoQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDcEQsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRU0sS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFpQixFQUFFLGFBQXVCLElBQUksRUFBRSxrQkFBMkIsSUFBSTtZQUNqRyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxVQUFVLEVBQUUsZUFBZSxDQUFDLENBQUM7WUFDcEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3RELENBQUM7O0lBNUlVLHFCQUFXLGNBOEl2QixDQUFBO0FBQ0gsQ0FBQyxFQWxMUyxTQUFTLEtBQVQsU0FBUyxRQWtMbEI7QUNsTEQscUNBQXFDO0FBQ3JDLElBQVUsU0FBUyxDQWtGbEI7QUFuRkQscUNBQXFDO0FBQ3JDLFdBQVUsU0FBUztJQUNqQjs7O09BR0c7UUFFVSxVQUFVO2dDQUR0QixVQUFBLFNBQVM7Ozs7MEJBQ3NCLFVBQUEsV0FBVzs7OzhCQUFuQixTQUFRLFdBQVc7Ozs7MkNBbUN4QyxVQUFBLFNBQVMsRUFDVCxVQUFBLElBQUksQ0FBQyxVQUFBLFlBQVksQ0FBQztnQkFDbkIsNEtBQVcsT0FBTyw2REFFakI7Z0JBdkNILDZLQTJFQzs7OztxQkExRXdCLGNBQVMsR0FBVyxVQUFBLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQUFBNUMsQ0FBNkM7WUFFN0UsUUFBUSxHQUhHLG1EQUFVLENBR0U7WUFFdkIsWUFBbUIsUUFBZ0IsWUFBWSxFQUFFLFFBQXVCO2dCQUN0RSxLQUFLLENBQUMsS0FBSyxFQUFFLFVBQUEsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxFQUFVLEVBQUUsRUFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDdkUsSUFBSSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUM7WUFDMUIsQ0FBQztZQUVPLE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxRQUFzQjtnQkFDM0QsSUFBSSxLQUFLLEdBQXNCLFVBQVUsQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDMUUsSUFBSSxpQkFBaUIsR0FBc0IsQ0FBQyxFQUFVLEVBQUUsRUFBVSxFQUFFLEVBQUU7b0JBQ3BFLElBQUksS0FBSyxHQUFXLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxDQUFDO29CQUMvRCxPQUFPLEtBQUssQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUNoQyxDQUFDLENBQUM7Z0JBQ0YsT0FBTyxpQkFBaUIsQ0FBQztZQUMzQixDQUFDO1lBRU8sTUFBTSxDQUFDLHFCQUFxQixDQUFDLFFBQXNCO2dCQUN6RCxJQUFJLE1BQU0sR0FBc0IsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDakUsTUFBTSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztnQkFDcEMsTUFBTSxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztnQkFFdEMsSUFBSSxHQUFHLEdBQTZCLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzVELEdBQUcsQ0FBQyxxQkFBcUIsR0FBRyxLQUFLLENBQUM7Z0JBQ2xDLEdBQUcsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBRXBDLE9BQU8sR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ2xGLENBQUM7WUFFRDs7O2VBR0c7WUFHSCxJQUFXLE9BQU87Z0JBQ2hCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUN2QixDQUFDO1lBQ0QsSUFBVyxPQUFPLENBQUMsUUFBc0I7Z0JBQ3ZDLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO2dCQUN6QixJQUFJLENBQUMsUUFBUTtvQkFDWCxPQUFPO2dCQUNULElBQUksVUFBVSxHQUFZLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxVQUFBLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUUsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztnQkFDbEgsS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ3JGLENBQUM7WUFFRCxrQkFBa0I7WUFDWCxTQUFTO2dCQUNkLElBQUksYUFBYSxHQUFrQixLQUFLLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQ3JELE9BQU8sYUFBYSxDQUFDLElBQUksQ0FBQztnQkFDMUIsT0FBTyxhQUFhLENBQUMsS0FBSyxDQUFDO2dCQUMzQixPQUFPLGFBQWEsQ0FBQyxVQUFVLENBQUM7Z0JBRWhDLElBQUksSUFBSSxDQUFDLFFBQVE7b0JBQ2YsYUFBYSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQztnQkFFcEQsT0FBTyxhQUFhLENBQUM7WUFDdkIsQ0FBQztZQUNNLEtBQUssQ0FBQyxXQUFXLENBQUMsY0FBNkI7Z0JBQ3BELE1BQU0sS0FBSyxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDeEMsSUFBSSxjQUFjLENBQUMsU0FBUztvQkFDMUIsSUFBSSxDQUFDLE9BQU8sR0FBaUIsTUFBTSxVQUFBLE9BQU8sQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUVuRixPQUFPLElBQUksQ0FBQztZQUNkLENBQUM7WUFFUyxhQUFhLENBQUMsUUFBaUI7Z0JBQ3ZDLEtBQUssQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQzlCLE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQztnQkFDckIsT0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDO2dCQUN0QixPQUFPLFFBQVEsQ0FBQyxVQUFVLENBQUM7WUFDN0IsQ0FBQzs7Z0JBekVVLHVEQUFVOzs7OztJQUFWLG9CQUFVLGFBMkV0QixDQUFBO0FBQ0gsQ0FBQyxFQWxGUyxTQUFTLEtBQVQsU0FBUyxRQWtGbEI7QUNuRkQsc0NBQXNDO0FBQ3RDLElBQVUsU0FBUyxDQWdIbEI7QUFqSEQsc0NBQXNDO0FBQ3RDLFdBQVUsU0FBUztJQUNqQjs7Ozs7Ozs7Ozs7O09BWUc7SUFDSCxNQUFhLFlBQWEsU0FBUSxVQUFBLElBQUk7aUJBQ2IsY0FBUyxHQUFXLFVBQUEsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxBQUE5QyxDQUErQztpQkFDOUQsb0JBQWUsR0FBYztZQUM1QyxJQUFJLFVBQUEsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUM7WUFDckIsSUFBSSxVQUFBLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7U0FDdkIsQUFIK0IsQ0FHOUI7UUFJRixZQUFtQixRQUFnQixjQUFjLEVBQUUsU0FBb0IsWUFBWSxDQUFDLGVBQWUsRUFBRSxjQUFzQixDQUFDO1lBQzFILEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUpMLFVBQUssR0FBMEIsSUFBSSxVQUFBLFlBQVksQ0FBVSxVQUFBLE9BQU8sQ0FBQyxDQUFDO1lBSzFFLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBQ2pDLDZDQUE2QztRQUMvQyxDQUFDO1FBRUQsSUFBYyxXQUFXO1lBQ3ZCLE9BQU8sQ0FBQyxDQUFDO1FBQ1gsQ0FBQztRQUVELGtCQUFrQjtRQUNYLFNBQVM7WUFDZCxJQUFJLGFBQWEsR0FBa0IsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ3JELGFBQWEsQ0FBQyxLQUFLLEdBQUcsVUFBQSxVQUFVLENBQUMsY0FBYyxDQUFDLFVBQUEsT0FBTyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNyRSxhQUFhLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7WUFDM0MsT0FBTyxhQUFhLENBQUM7UUFDdkIsQ0FBQztRQUVNLEtBQUssQ0FBQyxXQUFXLENBQUMsY0FBNkI7WUFDcEQsTUFBTSxLQUFLLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ3hDLElBQUksS0FBSyxHQUF5QixNQUFNLFVBQUEsVUFBVSxDQUFDLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMxRixJQUFJLENBQUMsVUFBVSxHQUFHLGNBQWMsQ0FBQyxVQUFVLENBQUM7WUFDNUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3BDLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVNLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBaUIsRUFBRSxhQUF1QixJQUFJLEVBQUUsa0JBQTJCLElBQUk7WUFDakcsTUFBTSxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxVQUFVLEVBQUUsZUFBZSxDQUFDLENBQUM7WUFDMUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN6QyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksS0FBSyw2QkFBYyxDQUFDLENBQUM7UUFDOUMsQ0FBQztRQUNELFlBQVk7UUFFRixNQUFNLENBQUMsTUFBaUIsRUFBRSxXQUFtQjtZQUNyRCxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDYixJQUFJLENBQUMsS0FBSyxHQUEwQixVQUFBLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzVGLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUMxQyxJQUFJLEtBQUssR0FBVyxHQUFHLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztZQUMxQyxJQUFJLFNBQVMsR0FBYyxVQUFBLFNBQVMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDdkQseUNBQXlDO1lBQ3pDLElBQUksT0FBTyxHQUFjLEVBQUUsQ0FBQztZQUM1QixJQUFJLFNBQVMsR0FBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzlCLElBQUksS0FBSyxHQUFXLENBQUMsQ0FBQztZQUN0QixLQUFLLElBQUksQ0FBQyxHQUFXLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztnQkFDbkQsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7Z0JBQ3hDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO29CQUNWLElBQUksUUFBUSxHQUFXLFVBQUEsT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO29CQUN0RixLQUFLLElBQUksUUFBUSxDQUFDO29CQUNsQixTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUN4QixDQUFDO1lBQ0gsQ0FBQztZQUNELFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLEVBQUUsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRS9FLElBQUksZ0JBQWdCLEdBQVcsT0FBTyxDQUFDLE1BQU0sQ0FBQztZQUU5QyxJQUFJLEtBQUssR0FBYSxJQUFJLFVBQUEsUUFBUSxFQUFFLENBQUM7WUFDckMsS0FBSyxJQUFJLFNBQVMsR0FBVyxDQUFDLEVBQUUsU0FBUyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsU0FBUyxFQUFFLEVBQUUsQ0FBQztnQkFDMUUsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGdCQUFnQixFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7b0JBQ2xELElBQUksRUFBRSxHQUFZLElBQUksVUFBQSxPQUFPLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3pFLG9FQUFvRTtvQkFDcEUsSUFBSSxTQUFTLElBQUksSUFBSSxDQUFDLFVBQVU7d0JBQzlCLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxVQUFBLE1BQU0sQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQzt5QkFDM0IsQ0FBQzt3QkFDSixJQUFJLFNBQVMsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLHFEQUFxRDs0QkFDOUYsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQUEsTUFBTSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDOzs0QkFFOUIsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQUEsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDakQsQ0FBQztnQkFDSCxDQUFDO2dCQUNELE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFnQixFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDdEUsQ0FBQztZQUdELGtDQUFrQztZQUNsQyxJQUFJLEtBQUssR0FBVyxFQUFFLENBQUM7WUFFdkIsS0FBSyxJQUFJLFNBQVMsR0FBVyxDQUFDLEVBQUUsU0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsU0FBUyxFQUFFLEVBQUUsQ0FBQztnQkFDekUsS0FBSyxJQUFJLFFBQVEsR0FBVyxDQUFDLEVBQUUsUUFBUSxHQUFHLGdCQUFnQixHQUFHLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxDQUFDO29CQUMzRSxJQUFJLEtBQUssR0FBVyxTQUFTLEdBQUcsZ0JBQWdCLEdBQUcsUUFBUSxDQUFDO29CQUM1RCxJQUFJLElBQUksR0FBUyxJQUFJLFVBQUEsSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxDQUFDLEdBQUcsZ0JBQWdCLEVBQUUsS0FBSyxHQUFHLGdCQUFnQixFQUFFLEtBQUssQ0FBQyxDQUFDO29CQUMzRyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUMxQiwwQ0FBMEM7Z0JBQzVDLENBQUM7WUFDSCxDQUFDO1lBRUQsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7WUFDdEIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDckIsQ0FBQzs7SUFoR1Usc0JBQVksZUFpR3hCLENBQUE7QUFDSCxDQUFDLEVBaEhTLFNBQVMsS0FBVCxTQUFTLFFBZ0hsQjtBQ2pIRCxJQUFVLFNBQVMsQ0F3RWxCO0FBeEVELFdBQVUsU0FBUztJQUNqQjs7OztPQUlHO0lBQ0gsTUFBYSxVQUFXLFNBQVEsVUFBQSxZQUFZO2lCQUNuQixjQUFTLEdBQVcsVUFBQSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFHN0UsWUFBbUIsUUFBZ0IsWUFBWSxFQUFFLGNBQXNCLENBQUMsRUFBRSxhQUFxQixDQUFDO1lBQzlGLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNiLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsK0VBQStFO1FBQ3ZILENBQUM7UUFFRDs7V0FFRztRQUNJLE1BQU0sQ0FBQyxjQUFzQixDQUFDLEVBQUUsYUFBcUIsQ0FBQztZQUMzRCxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDYixnREFBZ0Q7WUFDaEQsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDekQsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFFdkQsSUFBSSxXQUFXLEdBQUcsQ0FBQyxJQUFJLFVBQVUsR0FBRyxDQUFDLEVBQUUsQ0FBQztnQkFDdEMsVUFBQSxLQUFLLENBQUMsSUFBSSxDQUFDLDBGQUEwRixDQUFDLENBQUM7Z0JBQ3ZHLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUM7Z0JBQzNDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFDM0MsQ0FBQztZQUVELElBQUksS0FBSyxHQUFjLEVBQUUsQ0FBQztZQUMxQixJQUFJLElBQUksR0FBVyxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7WUFDNUMsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDakQsSUFBSSxLQUFLLEdBQVcsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQztnQkFDM0MsSUFBSSxDQUFDLEdBQVcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDaEMsSUFBSSxDQUFDLEdBQVcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFFaEMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMs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QUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM3TSxJQUFJLFFBQVEsR0FBYyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0TixJQUFJLFFBQVEsR0FBYyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwTSxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxhQUFhLENBQUMsQ0FBQztZQUMxQywrRUFBK0U7WUFDL0UsSUFBSSxDQUFDLFNBQVMs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LENBQUM7d0JBRXBELGtEQUFrRDt3QkFDbEQsSUFBSSxRQUFRLEdBQVksVUFBQSxPQUFPLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQzt3QkFDckQsSUFBSSxRQUFRLEdBQVksVUFBQSxPQUFPLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQzt3QkFFckQsNEJBQTRCO3dCQUM1QixJQUFJLENBQUMsR0FBVyxDQUFDLEdBQUcsVUFBQSxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFDdEQsSUFBSSxXQUFXLEdBQVksVUFBQSxPQUFPLENBQUMsS0FBSyxDQUFDLFVBQUEsT0FBTyxDQUFDLFVBQVUsQ0FBQyxVQUFBLE9BQU8sQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFBLE9BQU8sQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO3dCQUM1SSxJQUFJLGFBQWEsR0FBWSxVQUFBLE9BQU8sQ0FBQyxLQUFLLENBQUMsVUFBQSxPQUFPLENBQUMsVUFBVSxDQUFDLFVBQUEsT0FBTyxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBQSxPQUFPLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsc0NBQXNDO3dCQUV2TCxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQUEsT0FBTyxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQzdELFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBQSxPQUFPLENBQUMsS0FBSyxDQUFDLFdBQVcs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QUFDLENBQUM7WUFDMUIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDNUMsQ0FBQztRQUVNLFNBQVMsQ0FBQyxVQUFrQixJQUFJLENBQUMsTUFBTTtZQUM1QyxJQUFJLENBQUMsTUFBTSxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUM7WUFDMUIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDL0MsQ0FBQztRQUVNLFFBQVEsQ0FBQyxVQUFrQixJQUFJLENBQUMsTUFBTTtZQUMzQyxJQUFJLENBQUMsTUFBTSxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUM7WUFDMUIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDM0MsQ0FBQztRQUVNLFFBQVEsQ0FBQyxVQUFrQixJQUFJLENBQUMsTUFBTTtZQUMzQyxJQUFJLENBQUMsTUFBTSxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUM7WUFDMUIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDM0MsQ0FBQztRQUVNLFFBQVEsQ0FBQyxVQUFrQixJQUFJLENBQUMsTUFBTTtZQUMzQyxJQUFJLENBQUMsTUFBTSxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUM7WUFDMUIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDOUMsQ0FBQztRQUVNLFVBQVUsQ0FBQyxVQUFrQixJQUFJLENBQUMsTUFBTTtZQUM3QyxJQUFJLENBQUMsTUFBTSxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUM7WUFDMUIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDN0MsQ0FBQztRQUVNLFVBQVUsQ0FBQyxVQUFr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SUFBVyxLQUFLO1lBQ2QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3JCLENBQUM7UUFFRDs7V0FFRztRQUNJLFdBQVc7WUFDaEIsT0FBTyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDM0YsQ0FBQztRQUVEOztXQUVHO1FBQ0ksS0FBSztZQUNWLHlDQUF5QztZQUN6Qyx1QkFBdUI7WUFDdkIsdUVBQXVFO1lBQ3ZFLDJHQUEyRztZQUMzRyxvQ0FBb0M7WUFDcEMsSUFBSTtZQUNKLE9BQU87WUFDUCxrSEFBa0g7WUFDbEgsTUFBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDcEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDdEIsQ0FBQztLQUNGO0lBN0ZZLGVBQUssUUE2RmpCLENBQUE7QUFDSCxDQUFDLEVBM0dTLFNBQVMsS0FBVCxTQUFTLFFBMkdsQiIsInNvdXJjZXNDb250ZW50IjpbIlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIFBlcmZvcm1hbmNlTWVhc3VyZW1lbnQge1xyXG4gICAgc3RhcnQ/OiBudW1iZXI7XHJcbiAgICBmcmFtZVRpbWVNaW46IG51bWJlcjtcclxuICAgIGZyYW1lVGltZU1heDogbnVtYmVyO1xyXG4gICAgZnJhbWVUaW1lQXZnOiBudW1iZXI7XHJcbiAgICBjYWxsc1BlckZyYW1lOiBudW1iZXI7XHJcblxyXG4gICAgdGltZTogbnVtYmVyO1xyXG4gICAgY2FsbHM6IG51bWJlcjtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBjbGFzcyBQZXJmb3JtYW5jZU1vbml0b3Ige1xyXG4gICAgcHVibGljIHN0YXRpYyBkaXNwbGF5OiBIVE1MUHJlRWxlbWVudDtcclxuICAgIHN0YXRpYyB7XHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiBQZXJmb3JtYW5jZU1vbml0b3IuZGlzcGxheSA9IGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobmV3IFBlcmZvcm1hbmNlRGlzcGxheSgpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBtZWFzdXJlbWVudHM6IHsgW2tleTogc3RyaW5nXTogUGVyZm9ybWFuY2VNZWFzdXJlbWVudCB9ID0ge307XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgZnJhbWVzVG9BdmVyYWdlOiBudW1iZXIgPSA2MDtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIG1lYXN1cmUoX25hbWU/OiBzdHJpbmcpOiBGdW5jdGlvbiB7XHJcbiAgICAgIHJldHVybiAoX3ZhbHVlOiBHZW5lcmFsLCBfY29udGV4dDogQ2xhc3NNZXRob2REZWNvcmF0b3JDb250ZXh0IHwgQ2xhc3NHZXR0ZXJEZWNvcmF0b3JDb250ZXh0IHwgQ2xhc3NGaWVsZERlY29yYXRvckNvbnRleHQpID0+IHtcclxuICAgICAgICBjb25zdCBuYW1lOiBzdHJpbmcgPSBfbmFtZSA/PyBfY29udGV4dC5uYW1lLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKF9jb250ZXh0LmtpbmQgPT09IFwibWV0aG9kXCIgfHwgX2NvbnRleHQua2luZCA9PT0gXCJnZXR0ZXJcIikge1xyXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0aGlzOiBHZW5lcmFsLCAuLi5fYXJnczogR2VuZXJhbFtdKSB7XHJcbiAgICAgICAgICAgIFBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE1lYXN1cmUobmFtZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogR2VuZXJhbCA9IF92YWx1ZS5jYWxsKHRoaXMsIC4uLl9hcmdzKTtcclxuICAgICAgICAgICAgUGVyZm9ybWFuY2VNb25pdG9yLmVuZE1lYXN1cmUobmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX2NvbnRleHQua2luZCA9PT0gXCJmaWVsZFwiKSB7XHJcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRoaXM6IEdlbmVyYWwsIF9pbml0aWFsVmFsdWU6IEdlbmVyYWwpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBfaW5pdGlhbFZhbHVlICE9IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgICByZXR1cm4gX2luaXRpYWxWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50OiBHZW5lcmFsID0gZnVuY3Rpb24gKHRoaXM6IEdlbmVyYWwsIC4uLl9hcmdzOiBHZW5lcmFsW10pIHtcclxuICAgICAgICAgICAgICBQZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNZWFzdXJlKG5hbWUpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogR2VuZXJhbCA9IF9pbml0aWFsVmFsdWUuY2FsbCh0aGlzLCAuLi5fYXJncyk7XHJcbiAgICAgICAgICAgICAgUGVyZm9ybWFuY2VNb25pdG9yLmVuZE1lYXN1cmUobmFtZSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHN0YXJ0TWVhc3VyZShfbGFiZWw6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMubWVhc3VyZW1lbnRzW19sYWJlbF0pIHtcclxuICAgICAgICB0aGlzLm1lYXN1cmVtZW50c1tfbGFiZWxdID0ge1xyXG4gICAgICAgICAgZnJhbWVUaW1lTWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgZnJhbWVUaW1lTWF4OiAtTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgIGZyYW1lVGltZUF2ZzogMCxcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY2FsbHNQZXJGcmFtZTogMCxcclxuICAgICAgICAgIHRpbWU6IDAsXHJcbiAgICAgICAgICBjYWxsczogMFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5tZWFzdXJlbWVudHNbX2xhYmVsXS5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZW5kTWVhc3VyZShfbGFiZWw6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50OiBQZXJmb3JtYW5jZU1lYXN1cmVtZW50ID0gdGhpcy5tZWFzdXJlbWVudHNbX2xhYmVsXTtcclxuICAgICAgaWYgKCFtZWFzdXJlbWVudD8uc3RhcnQpIHJldHVybiAwO1xyXG5cclxuICAgICAgY29uc3QgZHVyYXRpb246IG51bWJlciA9IHBlcmZvcm1hbmNlLm5vdygpIC0gbWVhc3VyZW1lbnQuc3RhcnQ7XHJcbiAgICAgIG1lYXN1cmVtZW50LnRpbWUgKz0gZHVyYXRpb247XHJcbiAgICAgIG1lYXN1cmVtZW50LmNhbGxzKys7XHJcblxyXG4gICAgICByZXR1cm4gZHVyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBzdGFydEZyYW1lKCk6IHZvaWQge1xyXG4gICAgICBQZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNZWFzdXJlKFwiRnJhbWVcIik7XHJcbiAgICAgIGZvciAoY29uc3QgbGFiZWwgaW4gdGhpcy5tZWFzdXJlbWVudHMpIHtcclxuICAgICAgICB0aGlzLm1lYXN1cmVtZW50c1tsYWJlbF0udGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5tZWFzdXJlbWVudHNbbGFiZWxdLmNhbGxzID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZW5kRnJhbWUoKTogdm9pZCB7XHJcbiAgICAgIFBlcmZvcm1hbmNlTW9uaXRvci5lbmRNZWFzdXJlKFwiRnJhbWVcIik7XHJcbiAgICAgIGZvciAoY29uc3QgbGFiZWwgaW4gdGhpcy5tZWFzdXJlbWVudHMpIHtcclxuICAgICAgICBjb25zdCBtZWFzdXJlbWVudDogUGVyZm9ybWFuY2VNZWFzdXJlbWVudCA9IHRoaXMubWVhc3VyZW1lbnRzW2xhYmVsXTtcclxuICAgICAgICBpZiAobWVhc3VyZW1lbnQuY2FsbHMgPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCBmcmFtZVRvdGFsOiBudW1iZXIgPSBtZWFzdXJlbWVudC50aW1lO1xyXG4gICAgICAgICAgbWVhc3VyZW1lbnQuZnJhbWVUaW1lTWluID0gTWF0aC5taW4obWVhc3VyZW1lbnQuZnJhbWVUaW1lTWluLCBmcmFtZVRvdGFsKTtcclxuICAgICAgICAgIG1lYXN1cmVtZW50LmZyYW1lVGltZU1heCA9IE1hdGgubWF4KG1lYXN1cmVtZW50LmZyYW1lVGltZU1heCwgZnJhbWVUb3RhbCk7XHJcbiAgICAgICAgICBtZWFzdXJlbWVudC5mcmFtZVRpbWVBdmcgPSAoKHRoaXMuZnJhbWVzVG9BdmVyYWdlIC0gMSkgKiBtZWFzdXJlbWVudC5mcmFtZVRpbWVBdmcgKyBmcmFtZVRvdGFsKSAvIHRoaXMuZnJhbWVzVG9BdmVyYWdlO1xyXG4gICAgICAgICAgbWVhc3VyZW1lbnQuY2FsbHNQZXJGcmFtZSA9IG1lYXN1cmVtZW50LmNhbGxzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIFBlcmZvcm1hbmNlRGlzcGxheSBleHRlbmRzIEhUTUxQcmVFbGVtZW50IHtcclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zdHlsZS5jc3NUZXh0ID0gYFxyXG4gICAgICBmb250LWZhbWlseTogQ29uc29sYXMsIFwiQ291cmllciBOZXdcIiwgbW9ub3NwYWNlO1xyXG4gICAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgICAgY29sb3I6IHllbGxvdztcclxuICAgICAgdGV4dC1zaGFkb3c6IC0xcHggLTFweCAwIGJsYWNrLCAxcHggLTFweCAwIGJsYWNrLCAtMXB4IDFweCAwIGJsYWNrLCAxcHggMXB4IDAgYmxhY2s7XHJcbiAgICAgIHBhZGRpbmc6IDAuMnJlbTtcclxuICAgICAgbWFyZ2luOiAwO1xyXG4gICAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNyk7XHJcbiAgICAgIHdpZHRoOiBtaW4tY29udGVudDtcclxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICBsZWZ0OiAwO1xyXG4gICAgICB0b3A6IDA7XHJcbiAgICAgIHotaW5kZXg6IDEwMDA7XHJcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO2A7XHJcbiAgICAgIExvb3AuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5MT09QX0ZSQU1FLCB0aGlzLnVwZGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgbGV0IGxvbmdlc3RTdHJpbmc6IG51bWJlciA9IE9iamVjdC5rZXlzKFBlcmZvcm1hbmNlTW9uaXRvci5tZWFzdXJlbWVudHMpLnJlZHVjZSgoX2EsIF9iKSA9PiBfYS5sZW5ndGggPiBfYi5sZW5ndGggPyBfYSA6IF9iKS5sZW5ndGg7XHJcblxyXG4gICAgICBsZXQgdGV4dDogc3RyaW5nID0gYCR7XCJQZXJmb3JtYW5jZSBNb25pdG9yXCIucGFkRW5kKGxvbmdlc3RTdHJpbmcpfSB8ICB0aW1lICB8ICBjYWxsc1xcbmA7XHJcbiAgICAgIGZvciAobGV0IGtleSBpbiBQZXJmb3JtYW5jZU1vbml0b3IubWVhc3VyZW1lbnRzKSB7XHJcbiAgICAgICAgbGV0IG1lYXN1cmVtZW50OiBQZXJmb3JtYW5jZU1lYXN1cmVtZW50ID0gUGVyZm9ybWFuY2VNb25pdG9yLm1lYXN1cmVtZW50c1trZXldO1xyXG4gICAgICAgIGxldCBhdmc6IHN0cmluZyA9IG1lYXN1cmVtZW50LmZyYW1lVGltZUF2Zy50b0ZpeGVkKDIpLnBhZFN0YXJ0KDQpO1xyXG4gICAgICAgIGxldCBjYWxsczogc3RyaW5nID0gbWVhc3VyZW1lbnQuY2FsbHNQZXJGcmFtZS50b1N0cmluZygpLnBhZFN0YXJ0KDMpO1xyXG4gICAgICAgIHRleHQgKz0gYCR7a2V5LnBhZEVuZChsb25nZXN0U3RyaW5nKX0gfCAke2F2Z31tcyB8ICR7Y2FsbHN9Y3BmXFxuYDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IHRleHQ7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwidWktcGVyZm9ybWFuY2VcIiwgUGVyZm9ybWFuY2VEaXNwbGF5LCB7IGV4dGVuZHM6IFwicHJlXCIgfSk7XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQmFzZSBjbGFzcyBmb3IgdGhlIGRpZmZlcmVudCBEZWJ1Z1RhcmdldHMsIG1haW5seSBmb3IgdGVjaG5pY2FsIHB1cnBvc2Ugb2YgaW5oZXJpdGFuY2VcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgRGVidWdUYXJnZXQge1xyXG4gICAgcHVibGljIGRlbGVnYXRlczogTWFwRGVidWdGaWx0ZXJUb0RlbGVnYXRlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWVyZ2UgdGhlIGdpdmVuIG1lc3NhZ2UgYW5kIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIHN0cmluZywgc2VwYXJhdGVkIGJ5ICcsICdcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBtZXJnZUFyZ3VtZW50cyhfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiBzdHJpbmcge1xyXG4gICAgICBsZXQgb3V0OiBzdHJpbmcgPSBfbWVzc2FnZS50b1N0cmluZygpOyAvL0pTT04uc3RyaW5naWZ5KF9tZXNzYWdlKTtcclxuICAgICAgZm9yIChsZXQgYXJnIG9mIF9hcmdzKVxyXG4gICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBOdW1iZXIpXHJcbiAgICAgICAgICBvdXQgKz0gXCIsIFwiICsgYXJnLnRvUHJlY2lzaW9uKDIpLnRvU3RyaW5nKCk7IC8vSlNPTi5zdHJpbmdpZnkoYXJnLCBudWxsLCAyKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBvdXQgKz0gXCIsIFwiICsgYXJnLnRvU3RyaW5nKCk7IC8vSlNPTi5zdHJpbmdpZnkoYXJnLCBudWxsLCAyKTtcclxuICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z0FsZXJ0LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBUaGUgZmlsdGVycyBjb3JyZXNwb25kaW5nIHRvIGRlYnVnIGFjdGl2aXRpZXMsIG1vcmUgdG8gY29tZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIERFQlVHX0ZJTFRFUiB7XHJcbiAgICBOT05FID0gMHgwMCxcclxuICAgIElORk8gPSAweDAxLFxyXG4gICAgTE9HID0gMHgwMixcclxuICAgIFdBUk4gPSAweDA0LFxyXG4gICAgRVJST1IgPSAweDA4LFxyXG4gICAgRlVER0UgPSAweDEwLFxyXG4gICAgQ0xFQVIgPSAweDEwMCxcclxuICAgIEdST1VQID0gMHgxMDEsXHJcbiAgICBHUk9VUENPTExBUFNFRCA9IDB4MTAyLFxyXG4gICAgR1JPVVBFTkQgPSAweDEwNCxcclxuICAgIFNPVVJDRSA9IDB4MjAwLFxyXG4gICAgTUVTU0FHRVMgPSBJTkZPIHwgTE9HIHwgV0FSTiB8IEVSUk9SIHwgRlVER0UsXHJcbiAgICBGT1JNQVQgPSBDTEVBUiB8IEdST1VQIHwgR1JPVVBDT0xMQVBTRUQgfCBHUk9VUEVORCxcclxuICAgIEFMTCA9IE1FU1NBR0VTIHwgRk9STUFUXHJcbiAgfVxyXG5cclxuICBleHBvcnQgY29uc3QgREVCVUdfU1lNQk9MOiB7IFtmaWx0ZXI6IG51bWJlcl06IHN0cmluZyB9ID0ge1xyXG4gICAgW0RFQlVHX0ZJTFRFUi5JTkZPXTogXCLinJNcIixcclxuICAgIFtERUJVR19GSUxURVIuTE9HXTogXCLinI5cIixcclxuICAgIFtERUJVR19GSUxURVIuV0FSTl06IFwi4pqgXCIsXHJcbiAgICBbREVCVUdfRklMVEVSLkVSUk9SXTogXCLinYxcIixcclxuICAgIFtERUJVR19GSUxURVIuRlVER0VdOiBcIvCfjrJcIixcclxuICAgIFtERUJVR19GSUxURVIuU09VUkNFXTogXCLwn5SXXCJcclxuICB9O1xyXG5cclxuICBleHBvcnQgdHlwZSBNYXBEZWJ1Z1RhcmdldFRvRGVsZWdhdGUgPSBNYXA8RGVidWdUYXJnZXQsIEZ1bmN0aW9uPjtcclxuICBleHBvcnQgaW50ZXJmYWNlIE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZSB7IFtmaWx0ZXI6IG51bWJlcl06IEZ1bmN0aW9uIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdUYXJnZXQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFJvdXRpbmcgdG8gdGhlIHN0YW5kYXJkLWNvbnNvbGVcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRGVidWdDb25zb2xlIGV4dGVuZHMgRGVidWdUYXJnZXQge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWxlZ2F0ZXM6IE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZSA9IHtcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5JTkZPXTogY29uc29sZS5pbmZvLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkxPR106IGNvbnNvbGUubG9nLFxyXG4gICAgICBbREVCVUdfRklMVEVSLldBUk5dOiBjb25zb2xlLndhcm4sXHJcbiAgICAgIFtERUJVR19GSUxURVIuRVJST1JdOiBjb25zb2xlLmVycm9yLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkZVREdFXTogRGVidWdDb25zb2xlLmZ1ZGdlLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkNMRUFSXTogY29uc29sZS5jbGVhcixcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUF06IGNvbnNvbGUuZ3JvdXAsXHJcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBDT0xMQVBTRURdOiBjb25zb2xlLmdyb3VwQ29sbGFwc2VkLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQRU5EXTogY29uc29sZS5ncm91cEVuZCxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdOiBEZWJ1Z0NvbnNvbGUuc291cmNlXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdWxkIGJlIHVzZWQgdG8gZGlzcGxheSB1bmNyaXRpY2FsIHN0YXRlIGluZm9ybWF0aW9uIG9mIEZVREdFLCBvbmx5IHZpc2libGUgaW4gYnJvd3NlcidzIHZlcmJvc2UgbW9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZ1ZGdlKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICBjb25zb2xlLmRlYnVnKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuRlVER0VdLCBfbWVzc2FnZSwgLi4uX2FyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgYW4gZXh0cmEgbGluZSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzb3VyY2Ugb2YgdGhlIGRlYnVnIG1lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzb3VyY2UoX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgIGNvbnNvbGUubG9nKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuU09VUkNFXSwgX21lc3NhZ2UsIC4uLl9hcmdzKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnVGFyZ2V0LnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdJbnRlcmZhY2VzLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdDb25zb2xlLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBUaGUgRGVidWctQ2xhc3Mgb2ZmZXJzIGZ1bmN0aW9ucyBrbm93biBmcm9tIHRoZSBjb25zb2xlLW9iamVjdCBhbmQgYWRkaXRpb25zLCBcclxuICAgKiByb3V0aW5nIHRoZSBpbmZvcm1hdGlvbiB0byB2YXJpb3VzIHtAbGluayBEZWJ1Z1RhcmdldH1zIHRoYXQgY2FuIGJlIGVhc2lseSBkZWZpbmVkIGJ5IHRoZSBkZXZlbG9wZXJzIGFuZCByZWdpc3RlcmQgYnkgdXNlcnNcclxuICAgKiBPdmVycmlkZSBmdW5jdGlvbnMgaW4gc3ViY2xhc3NlcyBvZiB7QGxpbmsgRGVidWdUYXJnZXR9IGFuZCByZWdpc3RlciB0aGVtIGFzIHRoZWlyIGRlbGVnYXRlc1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBEZWJ1ZyB7XHJcbiAgICAvKipcclxuICAgICAqIEZvciBlYWNoIHNldCBmaWx0ZXIsIHRoaXMgYXNzb2NpYXRpdmUgYXJyYXkga2VlcHMgcmVmZXJlbmNlcyB0byB0aGUgcmVnaXN0ZXJlZCBkZWxlZ2F0ZSBmdW5jdGlvbnMgb2YgdGhlIGNob3NlbiB7QGxpbmsgRGVidWdUYXJnZXR9c1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBkZWxlZ2F0ZXM6IHsgW2ZpbHRlcjogbnVtYmVyXTogTWFwRGVidWdUYXJnZXRUb0RlbGVnYXRlIH0gPSBEZWJ1Zy5zZXR1cENvbnNvbGUoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlLSAvIEFjdGl2YXRlIGEgZmlsdGVyIGZvciB0aGUgZ2l2ZW4gRGVidWdUYXJnZXQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldEZpbHRlcihfdGFyZ2V0OiBEZWJ1Z1RhcmdldCwgX2ZpbHRlcjogREVCVUdfRklMVEVSKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGZpbHRlciBpbiBEZWJ1Zy5kZWxlZ2F0ZXMpXHJcbiAgICAgICAgRGVidWcuZGVsZWdhdGVzW2ZpbHRlcl0uZGVsZXRlKF90YXJnZXQpO1xyXG5cclxuICAgICAgZm9yIChsZXQgZmlsdGVyIGluIERFQlVHX0ZJTFRFUikge1xyXG4gICAgICAgIGxldCBwYXJzZWQ6IG51bWJlciA9IHBhcnNlSW50KGZpbHRlcik7XHJcbiAgICAgICAgaWYgKGlzTmFOKHBhcnNlZCkpXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBpZiAoW0RFQlVHX0ZJTFRFUi5NRVNTQUdFUywgREVCVUdfRklMVEVSLkZPUk1BVCwgREVCVUdfRklMVEVSLkFMTF0uaW5kZXhPZihwYXJzZWQpICE9IC0xKVxyXG4gICAgICAgICAgLy8gZG9udCBkZWxlZ2F0ZSBjb21ib3MuLi4gXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAoX2ZpbHRlciAmIHBhcnNlZClcclxuICAgICAgICAgIERlYnVnLmRlbGVnYXRlc1twYXJzZWRdLnNldChfdGFyZ2V0LCBfdGFyZ2V0LmRlbGVnYXRlc1twYXJzZWRdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBmaWx0ZXIocykgZm9yIHRoZSBnaXZlbiBEZWJ1Z1RhcmdldC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RmlsdGVyKF90YXJnZXQ6IERlYnVnVGFyZ2V0KTogREVCVUdfRklMVEVSIHtcclxuICAgICAgbGV0IHJlc3VsdDogREVCVUdfRklMVEVSID0gMDtcclxuICAgICAgZm9yIChsZXQgZmlsdGVyIGluIF90YXJnZXQuZGVsZWdhdGVzKVxyXG4gICAgICAgIHJlc3VsdCB8PSBwYXJzZUludChmaWx0ZXIpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgZmlsdGVyIHRvIHRoZSBnaXZlbiBEZWJ1Z1RhcmdldC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYWRkRmlsdGVyKF90YXJnZXQ6IERlYnVnVGFyZ2V0LCBfZmlsdGVyOiBERUJVR19GSUxURVIpOiB2b2lkIHtcclxuICAgICAgbGV0IGN1cnJlbnQ6IERFQlVHX0ZJTFRFUiA9IERlYnVnLmdldEZpbHRlcihfdGFyZ2V0KTtcclxuICAgICAgRGVidWcuc2V0RmlsdGVyKF90YXJnZXQsIGN1cnJlbnQgfCBfZmlsdGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhIGZpbHRlciBmcm9tIHRoZSBnaXZlbiBEZWJ1Z1RhcmdldC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVGaWx0ZXIoX3RhcmdldDogRGVidWdUYXJnZXQsIF9maWx0ZXI6IERFQlVHX0ZJTFRFUik6IHZvaWQge1xyXG4gICAgICBsZXQgY3VycmVudDogREVCVUdfRklMVEVSID0gRGVidWcuZ2V0RmlsdGVyKF90YXJnZXQpO1xyXG4gICAgICBEZWJ1Zy5zZXRGaWx0ZXIoX3RhcmdldCwgY3VycmVudCBeIF9maWx0ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5mbyguLi4pIGRpc3BsYXlzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gd2l0aCBsb3cgcHJpb3JpdHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpbmZvKF9tZXNzYWdlOiB1bmtub3duLCAuLi5fYXJnczogdW5rbm93bltdKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5JTkZPLCBfbWVzc2FnZSwgX2FyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwbGF5cyBpbmZvcm1hdGlvbiB3aXRoIG1lZGl1bSBwcmlvcml0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGxvZyhfbWVzc2FnZTogdW5rbm93biwgLi4uX2FyZ3M6IHVua25vd25bXSk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuTE9HLCBfbWVzc2FnZSwgX2FyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwbGF5cyBpbmZvcm1hdGlvbiBhYm91dCBub24tY29uZm9ybWl0aWVzIGluIHVzYWdlLCB3aGljaCBpcyBlbXBoYXNpemVkIGUuZy4gYnkgY29sb3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyB3YXJuKF9tZXNzYWdlOiB1bmtub3duLCAuLi5fYXJnczogdW5rbm93bltdKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5XQVJOLCBfbWVzc2FnZSwgX2FyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwbGF5cyBjcml0aWNhbCBpbmZvcm1hdGlvbiBhYm91dCBmYWlsdXJlcywgd2hpY2ggaXMgZW1waGFzaXplZCBlLmcuIGJ5IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZXJyb3IoX21lc3NhZ2U6IHVua25vd24sIC4uLl9hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkVSUk9SLCBfbWVzc2FnZSwgX2FyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwbGF5cyBtZXNzYWdlcyBmcm9tIEZVREdFXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZnVkZ2UoX21lc3NhZ2U6IHVua25vd24sIC4uLl9hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkZVREdFLCBfbWVzc2FnZSwgX2FyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIG91dHB1dCBhbmQgcmVtb3ZlcyBwcmV2aW91cyBtZXNzYWdlcyBpZiBwb3NzaWJsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuQ0xFQVIsIG51bGwsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBhIG5ldyBncm91cCBmb3IgbWVzc2FnZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBncm91cChfbmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5HUk9VUCwgX25hbWUsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBhIG5ldyBncm91cCBmb3IgbWVzc2FnZXMgdGhhdCBpcyBjb2xsYXBzZWQgYXQgZmlyc3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBncm91cENvbGxhcHNlZChfbmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5HUk9VUENPTExBUFNFRCwgX25hbWUsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXMgdGhlIHlvdW5nZXN0IGdyb3VwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXBFbmQoKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5HUk9VUEVORCwgbnVsbCwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvZyBhIGJyYW5jaCBvZiB0aGUgbm9kZSBoaWVyYXJjaHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBicmFuY2goX2JyYW5jaDogTm9kZSk6IHZvaWQge1xyXG4gICAgICBpZiAoX2JyYW5jaC5uQ2hpbGRyZW4gPiAwKVxyXG4gICAgICAgIERlYnVnLmdyb3VwKF9icmFuY2gubmFtZSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBEZWJ1Zy5mdWRnZShfYnJhbmNoLm5hbWUpO1xyXG5cclxuICAgICAgZm9yIChsZXQgY2hpbGQgb2YgX2JyYW5jaC5nZXRDaGlsZHJlbigpKSBEZWJ1Zy5icmFuY2goY2hpbGQpO1xyXG5cclxuICAgICAgaWYgKF9icmFuY2gubkNoaWxkcmVuID4gMClcclxuICAgICAgICBEZWJ1Zy5ncm91cEVuZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgbWVzc2FnZXMgYWJvdXQgdGhlIHNvdXJjZSBvZiB0aGUgZGVidWcgY2FsbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNvdXJjZShfbWVzc2FnZTogdW5rbm93biwgLi4uX2FyZ3M6IHVua25vd25bXSk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuU09VUkNFLCBfbWVzc2FnZSwgX2FyZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9va3VwIGFsbCBkZWxlZ2F0ZXMgcmVnaXN0ZXJlZCB0byB0aGUgZmlsdGVyIGFuZCBjYWxsIHRoZW0gdXNpbmcgdGhlIGdpdmVuIGFyZ3VtZW50c1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBkZWxlZ2F0ZShfZmlsdGVyOiBERUJVR19GSUxURVIsIF9tZXNzYWdlOiB1bmtub3duLCBfYXJnczogdW5rbm93bltdKTogdm9pZCB7XHJcbiAgICAgIGlmIChfZmlsdGVyID09IERFQlVHX0ZJTFRFUi5MT0cgfHwgX2ZpbHRlciA9PSBERUJVR19GSUxURVIuV0FSTiB8fCBfZmlsdGVyID09IERFQlVHX0ZJTFRFUi5FUlJPUikge1xyXG4gICAgICAgIGlmIChEZWJ1Zy5kZWxlZ2F0ZXNbREVCVUdfRklMVEVSLlNPVVJDRV0pXHJcbiAgICAgICAgICBmb3IgKGxldCBkZWxlZ2F0ZSBvZiBEZWJ1Zy5kZWxlZ2F0ZXNbREVCVUdfRklMVEVSLlNPVVJDRV0udmFsdWVzKCkpXHJcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xyXG4gICAgICAgICAgICAgIGxldCB0cmFjZTogc3RyaW5nW10gPSBuZXcgRXJyb3IoXCJUZXN0XCIpLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICAgICAgICAgIGRlbGVnYXRlKHRyYWNlWzNdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGxldCBkZWxlZ2F0ZXM6IE1hcERlYnVnVGFyZ2V0VG9EZWxlZ2F0ZSA9IERlYnVnLmRlbGVnYXRlc1tfZmlsdGVyXTtcclxuICAgICAgZm9yIChsZXQgZGVsZWdhdGUgb2YgZGVsZWdhdGVzLnZhbHVlcygpKVxyXG4gICAgICAgIGlmIChkZWxlZ2F0ZSlcclxuICAgICAgICAgIGlmIChfYXJncyAmJiBfYXJncy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICBkZWxlZ2F0ZShfbWVzc2FnZSwgLi4uX2FyZ3MpO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBkZWxlZ2F0ZShfbWVzc2FnZSk7XHJcblxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXR1cCByb3V0aW5nIHRvIHN0YW5kYXJkIGNvbnNvbGVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgc2V0dXBDb25zb2xlKCk6IHt9IHtcclxuICAgICAgbGV0IHJlc3VsdDogeyBbZmlsdGVyOiBudW1iZXJdOiBNYXBEZWJ1Z1RhcmdldFRvRGVsZWdhdGUgfSA9IHt9O1xyXG4gICAgICBsZXQgZmlsdGVyczogREVCVUdfRklMVEVSW10gPSBbXHJcbiAgICAgICAgREVCVUdfRklMVEVSLklORk8sIERFQlVHX0ZJTFRFUi5MT0csIERFQlVHX0ZJTFRFUi5XQVJOLCBERUJVR19GSUxURVIuRVJST1IsIERFQlVHX0ZJTFRFUi5GVURHRSxcclxuICAgICAgICBERUJVR19GSUxURVIuQ0xFQVIsIERFQlVHX0ZJTFRFUi5HUk9VUCwgREVCVUdfRklMVEVSLkdST1VQQ09MTEFQU0VELCBERUJVR19GSUxURVIuR1JPVVBFTkQsXHJcbiAgICAgICAgREVCVUdfRklMVEVSLlNPVVJDRVxyXG4gICAgICBdO1xyXG5cclxuICAgICAgZm9yIChsZXQgZmlsdGVyIG9mIGZpbHRlcnMpXHJcbiAgICAgICAgcmVzdWx0W2ZpbHRlcl0gPSBuZXcgTWFwKFtbRGVidWdDb25zb2xlLCBEZWJ1Z0NvbnNvbGUuZGVsZWdhdGVzW2ZpbHRlcl1dXSk7XHJcblxyXG4gICAgICByZXN1bHRbREVCVUdfRklMVEVSLlNPVVJDRV0uZGVsZXRlKERlYnVnQ29uc29sZSk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWFwRXZlbnRUeXBlVG9MaXN0ZW5lciB7XHJcbiAgICBbZXZlbnRUeXBlOiBzdHJpbmddOiBFdmVudExpc3RlbmVyVW5pZmllZFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHlwZXMgb2YgZXZlbnRzIHNwZWNpZmljIHRvIEZVREdFLCBpbiBhZGRpdGlvbiB0byB0aGUgc3RhbmRhcmQgRE9NL0Jyb3dzZXItVHlwZXMgYW5kIGN1c3RvbSBzdHJpbmdzXHJcbiAgICovXHJcbiAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlQge1xyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gdGFyZ2V0cyByZWdpc3RlcmVkIGF0IHtAbGluayBMb29wfSwgd2hlbiByZXF1ZXN0ZWQgYW5pbWF0aW9uIGZyYW1lIHN0YXJ0cyAqL1xyXG4gICAgTE9PUF9GUkFNRSA9IFwibG9vcEZyYW1lXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBDb21wb25lbnR9IHdoZW4gaXRzIGJlaW5nIGFkZGVkIHRvIGEge0BsaW5rIE5vZGV9ICovXHJcbiAgICBDT01QT05FTlRfQUREID0gXCJjb21wb25lbnRBZGRcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEge0BsaW5rIENvbXBvbmVudH0gd2hlbiBpdHMgYmVpbmcgcmVtb3ZlZCBmcm9tIGEge0BsaW5rIE5vZGV9ICovXHJcbiAgICBDT01QT05FTlRfUkVNT1ZFID0gXCJjb21wb25lbnRSZW1vdmVcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEge0BsaW5rIENvbXBvbmVudH0gd2hlbiBpdHMgYmVpbmcgYWN0aXZhdGVkICovXHJcbiAgICBDT01QT05FTlRfQUNUSVZBVEUgPSBcImNvbXBvbmVudEFjdGl2YXRlXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBDb21wb25lbnR9IHdoZW4gaXRzIGJlaW5nIGRlYWN0aXZhdGVkICovXHJcbiAgICBDT01QT05FTlRfREVBQ1RJVkFURSA9IFwiY29tcG9uZW50RGVhY3RpdmF0ZVwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gYSB7QGxpbmsgTm9kZX0sIGl0J3Mgc3VjY2Vzc29ycyBhbmQgYW5jZXN0b3JzIHdoZW4gaXRzIGJlaW5nIGFjdGl2YXRlZCAqL1xyXG4gICAgTk9ERV9BQ1RJVkFURSA9IFwibm9kZUFjdGl2YXRlXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBOb2RlfSwgaXQncyBzdWNjZXNzb3JzIGFuZCBhbmNlc3RvcnMgd2hlbiBpdHMgYmVpbmcgZGVhY3RpdmF0ZWQgKi9cclxuICAgIE5PREVfREVBQ1RJVkFURSA9IFwibm9kZURlYWN0aXZhdGVcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEgY2hpbGQge0BsaW5rIE5vZGV9IGFuZCBpdHMgYW5jZXN0b3JzIGFmdGVyIGl0IHdhcyBhcHBlbmRlZCB0byBhIHBhcmVudCAqL1xyXG4gICAgQ0hJTERfQVBQRU5EID0gXCJjaGlsZEFwcGVuZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gYSBjaGlsZCB7QGxpbmsgTm9kZX0gYW5kIGl0cyBhbmNlc3RvcnMganVzdCBiZWZvcmUgaXRzIGJlaW5nIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50ICovXHJcbiAgICBDSElMRF9SRU1PVkUgPSBcImNoaWxkUmVtb3ZlXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBNdXRhYmxlfSB3aGVuIGl0IG11dGF0ZXMgKi9cclxuICAgIE1VVEFURSA9IFwibXV0YXRlXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCBieSBhIHtAbGluayBHcmFwaH0gd2hlbiBpdCBtdXRhdGVzLCB7QGxpbmsgR3JhcGhJbnN0YW5jZX1zIGNvbm5lY3RlZCB0byB0aGUgZ3JhcGggbGlzdGVuICovXHJcbiAgICBNVVRBVEVfR1JBUEggPSBcIm11dGF0ZUdyYXBoXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCBieSBhIHtAbGluayBHcmFwaEluc3RhbmNlfSB3aGVuIGl0IHJlZmxlY3RlZCB0aGUgbXV0YXRpb24gb2YgdGhlIHtAbGluayBHcmFwaH0gaXQncyBjb25uZWN0ZWQgdG8gKi9cclxuICAgIE1VVEFURV9JTlNUQU5DRSA9IFwibXV0YXRlR3JhcGhEb25lXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgVmlld3BvcnR9IHdoZW4gaXQgZ2V0cyB0aGUgZm9jdXMgdG8gcmVjZWl2ZSBrZXlib2FyZCBpbnB1dCAqL1xyXG4gICAgRk9DVVNfSU4gPSBcImZvY3VzaW5cIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBWaWV3cG9ydH0gd2hlbiBpdCBsb3NlcyB0aGUgZm9jdXMgdG8gcmVjZWl2ZSBrZXlib2FyZCBpbnB1dCAqL1xyXG4gICAgRk9DVVNfT1VUID0gXCJmb2N1c291dFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIE5vZGV9IHdoZW4gaXQncyBkb25lIHNlcmlhbGl6aW5nICovXHJcbiAgICBOT0RFX1NFUklBTElaRUQgPSBcIm5vZGVTZXJpYWxpemVkXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgTm9kZX0gYW5kIGFsbCBpdHMge0BsaW5rIENvbXBvbmVudH1zIHdoZW4gaXQncyBkb25lIGRlc2VyaWFsaXppbmcsIHNvIGFsbCBjb21wb25lbnRzLCBjaGlsZHJlbiBhbmQgYXR0cmlidXRlcyBhcmUgYXZhaWxhYmxlICovXHJcbiAgICBOT0RFX0RFU0VSSUFMSVpFRCA9IFwibm9kZURlc2VyaWFsaXplZFwiLFxyXG4gICAgLyoqIGJyb2FkY2FzdCBmcm9tIGEge0BsaW5rIEdyYXBoSW5zdGFuY2V9IHRvIGFsbCBpdHMgZGVzY2VuZGFudHMgd2hlbiBpdCdzIGNvbnRlbnQgaXMgc2V0IGFjY29yZGluZyB0byBhIHNlcmlhbGl6YXRpb24gb2YgYSB7QGxpbmsgR3JhcGh9LiBCcm9hZGNhc3RlZCwgc28gbmVlZHMgdG8gYmUgY2F1Z2h0IGluIGNhcHR1cmUuICovXHJcbiAgICBHUkFQSF9JTlNUQU5USUFURUQgPSBcImdyYXBoSW5zdGFudGlhdGVkXCIsXHJcbiAgICAvKiogYnJvYWRjYXN0IGZyb20gYSB7QGxpbmsgR3JhcGh9IHRvIGFsbCBpdHMgZGVzY2VuZGFudHMgd2hlbiBpdCdzIGZpbmlzaGVkIGRlc2VyaWFsaXppbmcuIEJyb2FkY2FzdGVkLCBzbyBuZWVkcyB0byBiZSBjYXVnaHQgaW4gY2FwdHVyZS4gKi9cclxuICAgIEdSQVBIX0RFU0VSSUFMSVpFRCA9IFwiZ3JhcGhEZXNlcmlhbGl6ZWRcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIGJ5IGEge0BsaW5rIEdyYXBofSB3aGVuIGl0IGFuZCBpdHMgY29ubmVjdGVkIGluc3RhbmNlcyBoYXZlIGZpbmlzaGVkIG11dGF0aW5nICAqL1xyXG4gICAgR1JBUEhfTVVUQVRFRCA9IFwiZ3JhcGhNdXRhdGVkXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgVGltZX0gd2hlbiBpdCdzIHNjYWxpbmcgY2hhbmdlZCAgKi9cclxuICAgIFRJTUVfU0NBTEVEID0gXCJ0aW1lU2NhbGVkXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgRmlsZUlvQnJvd3NlckxvY2FsfSB3aGVuIGEgbGlzdCBvZiBmaWxlcyBoYXMgYmVlbiBsb2FkZWQgICovXHJcbiAgICBGSUxFX0xPQURFRCA9IFwiZmlsZUxvYWRlZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIEZpbGVJb0Jyb3dzZXJMb2NhbH0gd2hlbiBhIGxpc3Qgb2YgZmlsZXMgaGFzIGJlZW4gc2F2ZWQgKi9cclxuICAgIEZJTEVfU0FWRUQgPSBcImZpbGVTYXZlZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIE5vZGV9IHdoZW4gcmVjYWxjdWxhdGluZyB0cmFuc2Zvcm1zIGZvciByZW5kZXIgKi9cclxuICAgIFJFTkRFUl9QUkVQQVJFID0gXCJyZW5kZXJQcmVwYXJlXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgVmlld3BvcnR9IGFuZCB7QGxpbmsgTm9kZX0gd2hlbiByZWNhbGN1bGF0aW9uIG9mIHRoZSBicmFuY2ggdG8gcmVuZGVyIHN0YXJ0cy4gKi9cclxuICAgIFJFTkRFUl9QUkVQQVJFX1NUQVJUID0gXCJyZW5kZXJQcmVwYXJlU3RhcnRcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBWaWV3cG9ydH0gYW5kIHtAbGluayBOb2RlfSB3aGVuIHJlY2FsY3VsYXRpb24gb2YgdGhlIGJyYW5jaCB0byByZW5kZXIgZW5kcy4gVGhlIGJyYW5jaCBkaXNwYXRjaGVzIGJlZm9yZSB0aGUgbGlnaHRzIGFyZSB0cmFuc21pdHRlZCB0byB0aGUgc2hhZGVycyAgKi9cclxuICAgIFJFTkRFUl9QUkVQQVJFX0VORCA9IFwicmVuZGVyUHJlcGFyZUVuZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIFZpZXdwb3J0fSBhdCB0aGUgZW5kIG9mIGEgcmVuZGVyZWQgZnJhbWUgcmlnaHQgYmVmb3JlIGl0IGdldHMgZGlzcGxheWVkLiBBdCB0aGlzIHBvaW50IHtAbGluayBHaXptb3N9IGNhbiBzdGlsbCBiZSBkcmF3bi4gKi9cclxuICAgIFJFTkRFUl9FTkQgPSBcInJlbmRlckVuZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIEpvaW50fS1Db21wb25lbnRzIGluIG9yZGVyIHRvIGRpc2Nvbm5lY3QgKi9cclxuICAgIERJU0NPTk5FQ1RfSk9JTlQgPSBcImRpc2Nvbm5lY3RKb2ludFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIE5vZGV9IHdoZW4gaXQgZ2V0cyBhdHRhY2hlZCB0byBhIHZpZXdwb3J0IGZvciByZW5kZXJpbmcuIEJyb2FkY2FzdGVkLCBzbyBuZWVkcyB0byBiZSBjYXVnaHQgaW4gY2FwdHVyZS4gKi9cclxuICAgIEFUVEFDSF9CUkFOQ0ggPSBcImF0dGFjaEJyYW5jaFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIFByb2plY3R9IHdoZW4gaXQncyBkb25lIGxvYWRpbmcgcmVzb3VyY2VzIGZyb20gYSB1cmwgKi9cclxuICAgIFJFU09VUkNFU19MT0FERUQgPSBcInJlc291cmNlc0xvYWRlZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIENvbXBvbmVudFdhbGtlcn0gYW5kIHtAbGluayBDb21wb25lbnRXYXlwb2ludH0gd2hlbiBhIHtAbGluayBDb21wb25lbnRXYWxrZXJ9IHJlYWNoZXMgYSB7QGxpbmsgV2F5cG9pbnR9IG9yIHtAbGluayBDb21wb25lbnRXYXlwb2ludH0gKi9cclxuICAgIFdBWVBPSU5UX1JFQUNIRUQgPSBcIndheXBvaW50UmVhY2hlZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIENvbXBvbmVudFdhbGtlcn0gd2hlbiB0aGUgZmluYWwge0BsaW5rIFdheXBvaW50fSBpbiB0aGUgY3VycmVudCBwYXRoIGhhcyBiZWVuIHJlYWNoZWQgKi9cclxuICAgIFBBVEhJTkdfQ09OQ0xVREVEID0gXCJwYXRoaW5nQ29uY2x1ZGVkXCJcclxuICB9XHJcblxyXG4gIC8qKiBVbmlvbiB0eXBlIG9mIG90aGVyIGV2ZW50IHR5cGVzIHNlcnZpbmcgYXMgYW5ub3RhdGlvbiBmb3IgbGlzdGVuZXJzIGFuZCBoYW5kbGVycyAqL1xyXG4gIGV4cG9ydCB0eXBlIEV2ZW50VW5pZmllZCA9IEV2ZW50IHwgQ3VzdG9tRXZlbnQgfCBFdmVudFBoeXNpY3M7XHJcblxyXG4gIC8qKiBVbmlmaWVkIGxpc3RlbmVyIHR5cGUgZXh0ZW5kaW5nIEV2ZW50TGlzdGVuZXIgYW5kIEV2ZW50TGlzdGVuZXJPYmplY3QgZm9yIEN1c3RvbUV2ZW50IGFuZCBvdGhlcnMgKi9cclxuICBleHBvcnQgdHlwZSBFdmVudExpc3RlbmVyVW5pZmllZCA9XHJcbiAgICAoKF9ldmVudDogRXZlbnQpID0+IHZvaWQpIHxcclxuICAgICgoX2V2ZW50OiBDdXN0b21FdmVudCkgPT4gdm9pZCkgfFxyXG4gICAgKChfZXZlbnQ6IEV2ZW50UGh5c2ljcykgPT4gdm9pZCkgfFxyXG4gICAgKChfZXZlbnQ6IEV2ZW50VGltZXIpID0+IHZvaWQpIHxcclxuICAgIEV2ZW50TGlzdGVuZXIgfFxyXG4gICAgRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdDtcclxuXHJcbiAgLyoqIEV4dGVuZHMgRXZlbnRUYXJnZXQgdG8gd29yayB3aXRoIHtAbGluayBFdmVudExpc3RlbmVyVW5pZmllZH0gYW5kIHtAbGluayBFdmVudFVuaWZpZWR9ICovXHJcbiAgZXhwb3J0IGNsYXNzIEV2ZW50VGFyZ2V0VW5pZmllZCBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2VlIHtAbGluayBFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyfSBmb3IgcmVmZXJlbmNlLiBXb3JrcyB3aXRoIHtAbGluayBFdmVudExpc3RlbmVyVW5pZmllZH0gYW5kIHtAbGluayBFdmVudFVuaWZpZWR9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRFdmVudExpc3RlbmVyKF90eXBlOiBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyVW5pZmllZCwgX29wdGlvbnM/OiBib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpOiB2b2lkIHtcclxuICAgICAgc3VwZXIuYWRkRXZlbnRMaXN0ZW5lcihfdHlwZSwgPEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3Q+X2hhbmRsZXIsIF9vcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlZSB7QGxpbmsgRXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcn0gZm9yIHJlZmVyZW5jZS4gV29ya3Mgd2l0aCB7QGxpbmsgRXZlbnRMaXN0ZW5lclVuaWZpZWR9IGFuZCB7QGxpbmsgRXZlbnRVbmlmaWVkfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlRXZlbnRMaXN0ZW5lcihfdHlwZTogc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lclVuaWZpZWQsIF9vcHRpb25zPzogYm9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3R5cGUsIDxFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0Pl9oYW5kbGVyLCBfb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWUge0BsaW5rIEV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnR9IGZvciByZWZlcmVuY2UuIFdvcmtzIHdpdGggd2l0aCB7QGxpbmsgRXZlbnRVbmlmaWVkfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGlzcGF0Y2hFdmVudChfZXZlbnQ6IEV2ZW50VW5pZmllZCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gc3VwZXIuZGlzcGF0Y2hFdmVudChfZXZlbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmFzZSBjbGFzcyBmb3IgRXZlbnRUYXJnZXQgc2luZ2xldG9ucywgd2hpY2ggYXJlIGZpeGVkIGVudGl0aWVzIGluIHRoZSBzdHJ1Y3R1cmUgb2YgRlVER0UsIHN1Y2ggYXMgdGhlIGNvcmUgbG9vcCBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRXZlbnRUYXJnZXRTdGF0aWMgZXh0ZW5kcyBFdmVudFRhcmdldFVuaWZpZWQge1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyB0YXJnZXRTdGF0aWM6IEV2ZW50VGFyZ2V0U3RhdGljID0gbmV3IEV2ZW50VGFyZ2V0U3RhdGljKCk7XHJcblxyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHtAbGluayB0YXJnZXRTdGF0aWN9LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFkZEV2ZW50TGlzdGVuZXIoX3R5cGU6IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXIsIF9vcHRpb25zPzogYm9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgIEV2ZW50VGFyZ2V0U3RhdGljLnRhcmdldFN0YXRpYy5hZGRFdmVudExpc3RlbmVyKF90eXBlLCBfaGFuZGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSB7QGxpbmsgdGFyZ2V0U3RhdGljfS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVFdmVudExpc3RlbmVyKF90eXBlOiBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyLCBfb3B0aW9ucz86IGJvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICBFdmVudFRhcmdldFN0YXRpYy50YXJnZXRTdGF0aWMucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdHlwZSwgX2hhbmRsZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGF0Y2ggYW4gZXZlbnQgb24ge0BsaW5rIHRhcmdldFN0YXRpY30uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZGlzcGF0Y2hFdmVudChfZXZlbnQ6IEV2ZW50KTogYm9vbGVhbiB7XHJcbiAgICAgIEV2ZW50VGFyZ2V0U3RhdGljLnRhcmdldFN0YXRpYy5kaXNwYXRjaEV2ZW50KF9ldmVudCk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEludGVyZmFjZSBkZXNjcmliaW5nIHRoZSBkYXRhdHlwZXMgb2YgdGhlIGF0dHJpYnV0ZXMgYSBtdXRhdG9yIGFzIHN0cmluZ3MgXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgW2F0dHJpYnV0ZTogc3RyaW5nXTogc3RyaW5nIHwgT2JqZWN0O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBJbnRlcmZhY2UgZGVzY3JpYmluZyBhIG11dGF0b3IsIHdoaWNoIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IHdpdGggbmFtZXMgb2YgYXR0cmlidXRlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyB2YWx1ZXNcclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3Ige1xyXG4gICAgW2F0dHJpYnV0ZTogc3RyaW5nXTogR2VuZXJhbDtcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICogSW50ZXJmYWNlcyBkZWRpY2F0ZWQgZm9yIGVhY2ggcHVycG9zZS4gRXh0cmEgYXR0cmlidXRlIG5lY2Vzc2FyeSBmb3IgY29tcGlsZXRpbWUgdHlwZSBjaGVja2luZywgbm90IGV4aXN0ZW50IGF0IHJ1bnRpbWVcclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JGb3JBbmltYXRpb24gZXh0ZW5kcyBNdXRhdG9yIHsgcmVhZG9ubHkgZm9yQW5pbWF0aW9uOiBudWxsIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JGb3JVc2VySW50ZXJmYWNlIGV4dGVuZHMgTXV0YXRvciB7IHJlYWRvbmx5IGZvclVzZXJJbnRlcmZhY2U6IG51bGwgfVxyXG4gIC8vIGV4cG9ydCBpbnRlcmZhY2UgTXV0YXRvckZvckNvbXBvbmVudCBleHRlbmRzIE11dGF0b3IgeyByZWFkb25seSBmb3JVc2VyQ29tcG9uZW50OiBudWxsOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbGxlY3QgYXBwbGljYWJsZSBhdHRyaWJ1dGVzIG9mIHRoZSBpbnN0YW5jZSBhbmQgY29waWVzIG9mIHRoZWlyIHZhbHVlcyBpbiBhIE11dGF0b3Itb2JqZWN0XHJcbiAgICovXHJcbiAgZXhwb3J0IGZ1bmN0aW9uIGdldE11dGF0b3JPZkFyYml0cmFyeShfb2JqZWN0OiBPYmplY3QpOiBNdXRhdG9yIHtcclxuICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge307XHJcbiAgICBsZXQgYXR0cmlidXRlczogKHN0cmluZyB8IG51bWJlciB8IHN5bWJvbClbXSA9IFJlZmxlY3Qub3duS2V5cyhSZWZsZWN0LmdldFByb3RvdHlwZU9mKF9vYmplY3QpKTtcclxuICAgIGZvciAobGV0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgIGxldCB2YWx1ZTogT2JqZWN0ID0gUmVmbGVjdC5nZXQoX29iamVjdCwgYXR0cmlidXRlKTtcclxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pXHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIC8vIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTXV0YWJsZSkpXHJcbiAgICAgIC8vICAgY29udGludWU7XHJcbiAgICAgIG11dGF0b3JbYXR0cmlidXRlLnRvU3RyaW5nKCldID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbXV0YXRvcjtcclxuICB9XHJcblxyXG4gIC8vIEB0cy1pZ25vcmUgLSBhcyBvZiBub3cgd2UgbmVlZCB0byBwb2x5ZmlsbCB0aGUgc3ltYm9sIHRvIG1ha2UgZGVjb3JhdG9yIG1ldGFkYXRhIHdvcmssIHNlZSBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9yZWxlYXNlLW5vdGVzL3R5cGVzY3JpcHQtNS0yLmh0bWwjZGVjb3JhdG9yLW1ldGFkYXRhXHJcbiAgU3ltYm9sLm1ldGFkYXRhID8/PSBTeW1ib2woXCJTeW1ib2wubWV0YWRhdGFcIik7XHJcblxyXG4gIC8qKlxyXG4gICAqIEFzc29jaWF0aW9uIG9mIGFuIGF0dHJpYnV0ZSB3aXRoIGl0cyBzcGVjaWZpZWQgdHlwZSAoY29uc3RydWN0b3IpLlxyXG4gICAqIEBzZWUge0BsaW5rIE1ldGFkYXRhfS5cclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBNZXRhQXR0cmlidXRlVHlwZXMgPSBSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCBGdW5jdGlvbiB8IE9iamVjdD47XHJcblxyXG4gIC8qKlxyXG4gICAqIE1ldGFkYXRhIGZvciBjbGFzc2VzIGV4dGVuZGluZyB7QGxpbmsgTXV0YWJsZX0uIE1ldGFkYXRhIG5lZWRzIHRvIGJlIGV4cGxpY2l0bHkgc3BlY2lmaWVkIHVzaW5nIGRlY29yYXRvcnMuXHJcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTUtMi5odG1sI2RlY29yYXRvci1tZXRhZGF0YSB8IHR5cGUgc2NyaXB0IDUuMiBmZWF0dXJlIFwiZGVjb3JhdG9yIG1ldGFkYXRhXCJ9IGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWV0YWRhdGEgZXh0ZW5kcyBEZWNvcmF0b3JNZXRhZGF0YU9iamVjdCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzcGVjaWZpZWQgdHlwZXMgb2YgdGhlIGF0dHJpYnV0ZXMgb2YgYSBjbGFzcy4gVXNlIHRoZSB7QGxpbmsgdHlwZX0gZGVjb3JhdG9yIHRvIGFkZCB0eXBlIGluZm9ybWF0aW9uIHRvIHRoZSBtZXRhZGF0YSBvZiBhIGNsYXNzLlxyXG4gICAgICovXHJcbiAgICBhdHRyaWJ1dGVUeXBlcz86IE1ldGFBdHRyaWJ1dGVUeXBlcztcclxuICAgIGVudW1lcmF0ZUtleXM/OiBzdHJpbmdbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcCBvZiBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgdHlwZSBvZiBzZXJpYWxpemF0aW9uIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIHRoYXQgcHJvcGVydHkuXHJcbiAgICAgKi9cclxuICAgIHNlcmlhbGl6YWJsZXM/OiB7IFtrZXk6IHN0cmluZ106IFwicHJpbWl0aXZlXCIgfCBcInNlcmlhbGl6YWJsZVwiIHwgXCJyZXNvdXJjZVwiIHwgXCJub2RlXCIgfTtcclxuICAgIGltcGxlbWVudHM/OiBTZXQ8RnVuY3Rpb24+O1xyXG4gIH1cclxuXHJcbiAgLyoqIHtAbGluayBDbGFzc0ZpZWxkRGVjb3JhdG9yQ29udGV4dH0gb3Ige0BsaW5rIENsYXNzR2V0dGVyRGVjb3JhdG9yQ29udGV4dH0gb3Ige0BsaW5rIENsYXNzQWNjZXNzb3JEZWNvcmF0b3JDb250ZXh0fSAqL1xyXG4gIGV4cG9ydCB0eXBlIENsYXNzUHJvcGVydHlDb250ZXh0PFRoaXMgPSB1bmtub3duLCBWYWx1ZSA9IHVua25vd24+ID0gQ2xhc3NGaWVsZERlY29yYXRvckNvbnRleHQ8VGhpcywgVmFsdWU+IHwgQ2xhc3NHZXR0ZXJEZWNvcmF0b3JDb250ZXh0PFRoaXMsIFZhbHVlPiB8IENsYXNzQWNjZXNzb3JEZWNvcmF0b3JDb250ZXh0PFRoaXMsIFZhbHVlPjtcclxuICAvKipcclxuICAgKiBEZWNvcmF0b3IgdG8gc3BlY2lmeSBhIHR5cGUgKGNvbnN0cnVjdG9yKSBmb3IgYW4gYXR0cmlidXRlIHdpdGhpbiBhIGNsYXNzJ3Mge0BsaW5rIE1ldGFkYXRhIHwgbWV0YWRhdGF9LlxyXG4gICAqIFRoaXMgYWxsb3dzIHRoZSBpbnRlbmRlZCB0eXBlIG9mIGFuIGF0dHJpYnV0ZSB0byBiZSBrbm93biBhdCBydW50aW1lLCBtYWtpbmcgaXQgYSB2YWxpZCBkcm9wIHRhcmdldCBpbiB0aGUgZWRpdG9yLlxyXG4gICAqXHJcbiAgICogKipOb3RlOioqIEF0dHJpYnV0ZXMgd2l0aCBhIHNwZWNpZmllZCBtZXRhLXR5cGUgd2lsbCBhbHdheXMgYmUgaW5jbHVkZWQgaW4gdGhlIHtAbGluayBNdXRhdG9yIGJhc2UtbXV0YXRvcn0gXHJcbiAgICogKHZpYSB7QGxpbmsgTXV0YWJsZS5nZXRNdXRhdG9yfSksIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgb3duIHR5cGUuIE5vbi17QGxpbmsgTXV0YWJsZSBtdXRhYmxlfSBvYmplY3RzIFxyXG4gICAqIHdpbGwgYmUgZGlzcGxheWVkIHZpYSB0aGVpciB7QGxpbmsgdG9TdHJpbmd9IG1ldGhvZCBpbiB0aGUgZWRpdG9yLlxyXG4gICAqIEBhdXRob3IgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDI0LTIwMjVcclxuICAgKi9cclxuICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgYXJyYXlzIGFuZCBtYXliZSBvdGhlciBjb2xsZWN0aW9ucz9cclxuICAvLyBvYmplY3QgdHlwZVxyXG4gIGV4cG9ydCBmdW5jdGlvbiB0eXBlPFQsIEMgZXh0ZW5kcyBhYnN0cmFjdCBuZXcgKC4uLmFyZ3M6IEdlbmVyYWxbXSkgPT4gVD4oX2NvbnN0cnVjdG9yOiBDKTogKF92YWx1ZTogdW5rbm93biwgX2NvbnRleHQ6IENsYXNzUHJvcGVydHlDb250ZXh0PFQgZXh0ZW5kcyBOb2RlID8gTm9kZSBleHRlbmRzIFQgPyBDb21wb25lbnQgOiBTZXJpYWxpemFibGUgOiBTZXJpYWxpemFibGUsIFQ+KSA9PiB2b2lkO1xyXG4gIC8vIHByaW1pdGl2ZSB0eXBlXHJcbiAgZXhwb3J0IGZ1bmN0aW9uIHR5cGU8VCBleHRlbmRzIEJvb2xlYW4gfCBOdW1iZXIgfCBTdHJpbmc+KF9jb25zdHJ1Y3RvcjogYWJzdHJhY3QgbmV3ICguLi5hcmdzOiBHZW5lcmFsW10pID0+IFQpOiAoX3ZhbHVlOiB1bmtub3duLCBfY29udGV4dDogQ2xhc3NQcm9wZXJ0eUNvbnRleHQ8U2VyaWFsaXphYmxlLCBUPikgPT4gdm9pZDtcclxuICAvLyBlbnVtIHR5cGVcclxuICBleHBvcnQgZnVuY3Rpb24gdHlwZTxULCBFIGV4dGVuZHMgUmVjb3JkPGtleW9mIEUsIFQ+PihfZW51bTogRSk6IChfdmFsdWU6IHVua25vd24sIF9jb250ZXh0OiBDbGFzc1Byb3BlcnR5Q29udGV4dDxTZXJpYWxpemFibGUsIFQ+KSA9PiB2b2lkO1xyXG4gIGV4cG9ydCBmdW5jdGlvbiB0eXBlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24gfCBPYmplY3QpOiAoX3ZhbHVlOiB1bmtub3duLCBfY29udGV4dDogQ2xhc3NQcm9wZXJ0eUNvbnRleHQpID0+IHZvaWQge1xyXG4gICAgcmV0dXJuIChfdmFsdWUsIF9jb250ZXh0KSA9PiB7IC8vIGNvdWxkIGNhY2hlIHRoZSBkZWNvcmF0b3IgZnVuY3Rpb24gZm9yIGVhY2ggY2xhc3NcclxuICAgICAgbGV0IG1ldGE6IE1ldGFkYXRhID0gX2NvbnRleHQubWV0YWRhdGE7XHJcbiAgICAgIGlmICghT2JqZWN0Lmhhc093bihtZXRhLCBcImF0dHJpYnV0ZVR5cGVzXCIpKVxyXG4gICAgICAgIG1ldGEuYXR0cmlidXRlVHlwZXMgPSB7IC4uLm1ldGEuYXR0cmlidXRlVHlwZXMgfTtcclxuICAgICAgbWV0YS5hdHRyaWJ1dGVUeXBlc1tfY29udGV4dC5uYW1lXSA9IF9jb25zdHJ1Y3RvcjtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWNvcmF0b3IgZm9yIG1ha2luZyBnZXR0ZXJzIGluIGEge0BsaW5rIE11dGFibGV9IGNsYXNzIGVudW1lcmFibGUuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBnZXR0ZXJzIGFyZSBpbmNsdWRlZCBpbiBtdXRhdG9ycyBhbmQgYXJlIHN1YnNlcXVlbnRseSBkaXNwbGF5ZWQgaW4gdGhlIGVkaXRvci5cclxuICAgKiBcclxuICAgKiAqKlVzYWdlKio6IEFwcGx5IHRoaXMgZGVjb3JhdG9yIHRvIGJvdGggdGhlIGdldHRlciBtZXRob2QgYW5kIHRoZSBjbGFzcyB0byBtYWtlIGl0IGVmZmVjdGl2ZS5cclxuICAgKiBcclxuICAgKiAqKkV4YW1wbGUqKjpcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogQMaSLmVudW1lcmF0ZSAvLyBhcHBseSB0aGUgZGVjb3JhdG9yIHRvIHRoZSBjbGFzcy5cclxuICAgKiBleHBvcnQgY2xhc3MgU29tZVNjcmlwdCBleHRlbmRzIMaSLkNvbXBvbmVudFNjcmlwdCB7XHJcbiAgICogICAjc2l6ZTogbnVtYmVyID0gMTtcclxuICAgKiBcclxuICAgKiAgIEDGki5lbnVtZXJhdGUgLy8gYXBwbHkgdGhlIGRlY29yYXRvciB0byB0aGUgZ2V0dGVyXHJcbiAgICogICBwdWJsaWMgZ2V0IHNpemUoKTogbnVtYmVyIHtcclxuICAgKiAgICAgcmV0dXJuIHRoaXMuI3NpemU7XHJcbiAgICogICB9XHJcbiAgICogXHJcbiAgICogICAvLyBkZWZpbmUgYSBzZXR0ZXIgdG8gYWxsb3cgd3JpdGluZywgb3Igb21pdCBpdCB0byBsZWF2ZSB0aGUgcHJvcGVydHkgcmVhZC1vbmx5XHJcbiAgICogICBwdWJsaWMgc2V0IHNpemUoX3NpemU6IG51bWJlcikge1xyXG4gICAqICAgICB0aGlzLiNzaXplID0gX3NpemU7XHJcbiAgICogICB9XHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBmdW5jdGlvbiBlbnVtZXJhdGUoX3ZhbHVlOiB1bmtub3duLCBfY29udGV4dDogQ2xhc3NEZWNvcmF0b3JDb250ZXh0PG5ldyAoLi4uYXJnczogR2VuZXJhbFtdKSA9PiBNdXRhYmxlPik6IHZvaWQ7XHJcbiAgZXhwb3J0IGZ1bmN0aW9uIGVudW1lcmF0ZShfdmFsdWU6IHVua25vd24sIF9jb250ZXh0OiBDbGFzc0dldHRlckRlY29yYXRvckNvbnRleHQ8TXV0YWJsZT4gfCBDbGFzc0FjY2Vzc29yRGVjb3JhdG9yQ29udGV4dDxNdXRhYmxlPik6IHZvaWQ7XHJcbiAgZXhwb3J0IGZ1bmN0aW9uIGVudW1lcmF0ZShfdmFsdWU6IHVua25vd24sIF9jb250ZXh0OiBDbGFzc0RlY29yYXRvckNvbnRleHQgfCBDbGFzc0dldHRlckRlY29yYXRvckNvbnRleHQgfCBDbGFzc0FjY2Vzc29yRGVjb3JhdG9yQ29udGV4dCk6IHZvaWQge1xyXG4gICAgLy8gX2NvbnRleHQuYWRkSW5pdGlhbGl6ZXIoZnVuY3Rpb24gKHRoaXM6IHVua25vd24pIHsgLy8gdGhpcyBpcyBydW4gcGVyIGluc3RhbmNlLi4uIGlkZWFsbHkgd2Ugd291bGQgd2FudCB0byBydW4gdGhpcyBvbmNlIHBlciBjbGFzc1xyXG4gICAgLy8gICBjb25zdCBwcm90b3R5cGU6IHVua25vd24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XHJcbiAgICAvLyAgIGNvbnN0IGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBfY29udGV4dC5uYW1lKTtcclxuICAgIC8vICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlID09IGZhbHNlKVxyXG4gICAgLy8gICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIF9jb250ZXh0Lm5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuICAgIC8vIH0pO1xyXG5cclxuICAgIGxldCBtZXRhZGF0YTogTWV0YWRhdGEgPSBfY29udGV4dC5tZXRhZGF0YTtcclxuICAgIGlmIChfY29udGV4dC5raW5kID09IFwiZ2V0dGVyXCIgfHwgX2NvbnRleHQua2luZCA9PSBcImFjY2Vzc29yXCIpIHtcclxuICAgICAgaWYgKHR5cGVvZiBfY29udGV4dC5uYW1lICE9IFwic3RyaW5nXCIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgaWYgKCFPYmplY3QuaGFzT3duKG1ldGFkYXRhLCBcImVudW1lcmFibGVLZXlzXCIpKVxyXG4gICAgICAgIG1ldGFkYXRhLmVudW1lcmF0ZUtleXMgPSBbXTtcclxuXHJcbiAgICAgIG1ldGFkYXRhLmVudW1lcmF0ZUtleXMucHVzaChfY29udGV4dC5uYW1lLnRvU3RyaW5nKCkpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKF9jb250ZXh0LmtpbmQgPT0gXCJjbGFzc1wiKSB7XHJcbiAgICAgIGlmIChtZXRhZGF0YS5lbnVtZXJhdGVLZXlzKVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIG1ldGFkYXRhLmVudW1lcmF0ZUtleXMpXHJcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoKDxGdW5jdGlvbj5fdmFsdWUpLnByb3RvdHlwZSwga2V5LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJhc2UgY2xhc3MgZm9yIGFsbCB0eXBlcyB0aGF0IGFyZSBtdXRhYmxlIHVzaW5nIHtAbGluayBNdXRhdG9yfS1vYmplY3RzLCB0aHVzIHByb3ZpZGluZyBhbmQgdXNpbmcgaW50ZXJmYWNlcyBjcmVhdGVkIGF0IHJ1bnRpbWUuXHJcbiAgICogXHJcbiAgICogTXV0YWJsZXMgcHJvdmlkZSBhIHtAbGluayBNdXRhdG9yfSBidWlsdCBieSBjb2xsZWN0aW5nIGFsbCB0aGVpciBhcHBsaWNhYmxlIGVudW1lcmFibGUgcHJvcGVydGllcy4gQnkgZGVmYXVsdCwgdGhpcyBpbmNsdWRlcyBvbmx5IHByaW1pdGl2ZSB0eXBlcyBhbmQgbmVzdGVkIG11dGFibGUgb2JqZWN0cy5cclxuICAgKiBVc2luZyB0aGUge0BsaW5rIHR5cGV9LWRlY29yYXRvciBjYW4gYWxzbyBpbmNsdWRlIG5vbi1tdXRhYmxlIG9iamVjdHMsIHdoaWNoIHdpbGwgYmUgZGlzcGxheWVkIHZpYSB0aGVpciB7QGxpbmsgdG9TdHJpbmd9IG1ldGhvZCBpbiB0aGUgZWRpdG9yLlxyXG4gICAqIFxyXG4gICAqIFN1YmNsYXNzZXMgY2FuIGVpdGhlciByZWR1Y2UgdGhlIHN0YW5kYXJkIHtAbGluayBNdXRhdG9yfSBidWlsdCBieSB0aGlzIGJhc2UgY2xhc3MgYnkgZGVsZXRpbmcgcHJvcGVydGllcyBvciBpbXBsZW1lbnQgYW4gaW5kaXZpZHVhbCBnZXRNdXRhdG9yIG1ldGhvZC5cclxuICAgKiBUaGUgcHJvdmlkZWQgcHJvcGVydGllcyBvZiB0aGUge0BsaW5rIE11dGF0b3J9IG11c3QgbWF0Y2ggcHVibGljIHByb3BlcnRpZXMgb3IgZ2V0dGVycy9zZXR0ZXJzIG9mIHRoZSBvYmplY3QuXHJcbiAgICogT3RoZXJ3aXNlLCB0aGV5IHdpbGwgYmUgaWdub3JlZCB1bmxlc3MgaGFuZGxlZCBieSBhbiBvdmVycmlkZSBvZiB0aGUgbXV0YXRlIG1ldGhvZCBpbiB0aGUgc3ViY2xhc3MsIGFuZCB3aWxsIHRocm93IGVycm9ycyBpbiBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCB1c2VyIGludGVyZmFjZSBmb3IgdGhlIG9iamVjdC5cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgTXV0YWJsZSBleHRlbmRzIEV2ZW50VGFyZ2V0VW5pZmllZCB7XHJcbiAgICAvKipcclxuICAgICAqIERlY29yYXRvciBhbGxvd3MgdG8gYXR0YWNoIHtAbGluayBNdXRhYmxlfSBmdW5jdGlvbmFsaXR5IHRvIGV4aXN0aW5nIGNsYXNzZXMuIFxyXG4gICAgICovXHJcbiAgICAvLyBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgIC8vICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwidXNlUmVuZGVyRGF0YVwiLCB7XHJcbiAgICAvLyAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE11dGF0b3IodGhpczogTXV0YWJsZUZvclVzZXJJbnRlcmZhY2UpOiBNdXRhdG9yIHtcclxuICAgIC8vICAgICAgIHJldHVybiBnZXRNdXRhdG9yT2ZBcmJpdHJhcnkodGhpcyk7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICB9KTtcclxuICAgIC8vIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldE11dGF0b3JGcm9tUGF0aChfbXV0YXRvcjogTXV0YXRvciwgX3BhdGg6IHN0cmluZ1tdKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBrZXk6IHN0cmluZyA9IF9wYXRoWzBdO1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHt9O1xyXG4gICAgICBpZiAoX211dGF0b3Jba2V5XSA9PSB1bmRlZmluZWQpIC8vIGlmIHRoZSBwYXRoIGRldmlhdGVzIGZyb20gbXV0YXRvciBzdHJ1Y3R1cmUsIHJldHVybiB0aGUgbXV0YXRvclxyXG4gICAgICAgIHJldHVybiBfbXV0YXRvcjtcclxuICAgICAgbXV0YXRvcltrZXldID0gX211dGF0b3Jba2V5XTtcclxuICAgICAgaWYgKF9wYXRoLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgbXV0YXRvcltrZXldID0gTXV0YWJsZS5nZXRNdXRhdG9yRnJvbVBhdGgobXV0YXRvcltrZXldLCBfcGF0aC5zbGljZSgxLCBfcGF0aC5sZW5ndGgpKTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHR5cGUgb2YgdGhpcyBtdXRhYmxlIHN1YmNsYXNzIGFzIHRoZSBuYW1lIG9mIHRoZSBydW50aW1lIGNsYXNzXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgbXV0YWJsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHR5cGUoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3QgYXBwbGljYWJsZSBhdHRyaWJ1dGVzIG9mIHRoZSBpbnN0YW5jZSBhbmQgY29waWVzIG9mIHRoZWlyIHZhbHVlcyBpbiBhIE11dGF0b3Itb2JqZWN0LlxyXG4gICAgICogQnkgZGVmYXVsdCwgYSBtdXRhdG9yIGNhbm5vdCBiZSBleHRlbmRlZCwgc2luY2UgZXh0ZW5zaW9ucyBhcmUgbm90IGF2YWlsYWJsZSBpbiB0aGUgb2JqZWN0IHRoZSBtdXRhdG9yIGJlbG9uZ3MgdG8uXHJcbiAgICAgKiBBIG11dGF0b3IgbWF5IGJlIHJlZHVjZWQgYnkgdGhlIGRlc2NlbmRhbnRzIG9mIHtAbGluayBNdXRhYmxlfSB0byBjb250YWluIG9ubHkgdGhlIHByb3BlcnRpZXMgbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcihfZXh0ZW5kYWJsZTogYm9vbGVhbiA9IGZhbHNlKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge307XHJcblxyXG4gICAgICAvLyBjb2xsZWN0IHByaW1pdGl2ZSBhbmQgbXV0YWJsZSBhdHRyaWJ1dGVzXHJcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiB0aGlzKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBPYmplY3QgPSB0aGlzW2F0dHJpYnV0ZV07XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBNdXRhYmxlQXJyYXkpICYmICEodmFsdWUuaGFzT3duUHJvcGVydHkoXCJpZFJlc291cmNlXCIpKSAmJiB0aGlzLmdldE1ldGFBdHRyaWJ1dGVUeXBlcygpW2F0dHJpYnV0ZV0gPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgbXV0YXRvclthdHRyaWJ1dGVdID0gdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghX2V4dGVuZGFibGUpXHJcbiAgICAgICAgLy8gbXV0YXRvciBjYW4gYmUgcmVkdWNlZCBidXQgbm90IGV4dGVuZGVkIVxyXG4gICAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhtdXRhdG9yKTtcclxuICAgICAgLy8gZGVsZXRlIHVud2FudGVkIGF0dHJpYnV0ZXNcclxuICAgICAgdGhpcy5yZWR1Y2VNdXRhdG9yKG11dGF0b3IpO1xyXG5cclxuICAgICAgLy8gcmVwbGFjZSByZWZlcmVuY2VzIHRvIG11dGFibGUgb2JqZWN0cyB3aXRoIHJlZmVyZW5jZXMgdG8gbXV0YXRvcnNcclxuICAgICAgZm9yIChsZXQgYXR0cmlidXRlIGluIG11dGF0b3IpIHtcclxuICAgICAgICBsZXQgdmFsdWU6IE9iamVjdCA9IG11dGF0b3JbYXR0cmlidXRlXTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNdXRhYmxlKVxyXG4gICAgICAgICAgbXV0YXRvclthdHRyaWJ1dGVdID0gdmFsdWUuZ2V0TXV0YXRvcigpO1xyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGVBcnJheSlcclxuICAgICAgICAgIG11dGF0b3JbYXR0cmlidXRlXSA9IHZhbHVlLm1hcCgoX3ZhbHVlKSA9PiBfdmFsdWUuZ2V0TXV0YXRvcigpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBpbnN0YW5jZSBhbmQgdGhlaXIgdmFsdWVzIGFwcGxpY2FibGUgZm9yIGFuaW1hdGlvbi5cclxuICAgICAqIEJhc2ljIGZ1bmN0aW9uYWxpdHkgaXMgaWRlbnRpY2FsIHRvIHtAbGluayBnZXRNdXRhdG9yfSwgcmV0dXJuZWQgbXV0YXRvciBzaG91bGQgdGhlbiBiZSByZWR1Y2VkIGJ5IHRoZSBzdWJjbGFzc2VkIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yRm9yQW5pbWF0aW9uKF9leHRlbmRhYmxlOiBib29sZWFuID0gZmFsc2UpOiBNdXRhdG9yRm9yQW5pbWF0aW9uIHtcclxuICAgICAgcmV0dXJuIDxNdXRhdG9yRm9yQW5pbWF0aW9uPnRoaXMuZ2V0TXV0YXRvcihfZXh0ZW5kYWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBpbnN0YW5jZSBhbmQgdGhlaXIgdmFsdWVzIGFwcGxpY2FibGUgZm9yIHRoZSB1c2VyIGludGVyZmFjZS5cclxuICAgICAqIEJhc2ljIGZ1bmN0aW9uYWxpdHkgaXMgaWRlbnRpY2FsIHRvIHtAbGluayBnZXRNdXRhdG9yfSwgcmV0dXJuZWQgbXV0YXRvciBzaG91bGQgdGhlbiBiZSByZWR1Y2VkIGJ5IHRoZSBzdWJjbGFzc2VkIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yRm9yVXNlckludGVyZmFjZShfZXh0ZW5kYWJsZTogYm9vbGVhbiA9IGZhbHNlKTogTXV0YXRvckZvclVzZXJJbnRlcmZhY2Uge1xyXG4gICAgICByZXR1cm4gPE11dGF0b3JGb3JVc2VySW50ZXJmYWNlPnRoaXMuZ2V0TXV0YXRvcihfZXh0ZW5kYWJsZSk7ICAvLyBUT0RPOiBib3RoIG9mIHRoZXNlICh0aGlzIGFuZCBnZXRNdXRhdG9yRm9yQW5pbWF0aW9uKSBkb24ndCByZWFsbHkgd29yayBhcyB0aGV5IGRvbid0IHJlY3Vyc2l2ZWx5IGNhbGwgZ2V0TXV0YXRvckZvclVzZXJJbnRlcmZhY2Ugb24gc3ViLW11dGFibGUgb2JqZWN0cywgbWF5YmUgaW5zdGVhZCBpbXBsZW1lbnQgYSByZWR1Y2VNdXRhdG9yRm9yVXNlckludGVyZmFjZT8/P1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgaW5zdGFuY2UgYW5kIHRoZWlyIHZhbHVlcyBhcHBsaWNhYmxlIGZvciBpbmRpdml1YWxpemF0aW9uIGJ5IHRoZSBjb21wb25lbnQuXHJcbiAgICAgKiBCYXNpYyBmdW5jdGlvbmFsaXR5IGlzIGlkZW50aWNhbCB0byB7QGxpbmsgZ2V0TXV0YXRvcn0sIHJldHVybmVkIG11dGF0b3Igc2hvdWxkIHRoZW4gYmUgcmVkdWNlZCBieSB0aGUgc3ViY2xhc3NlZCBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICAvLyBwdWJsaWMgZ2V0TXV0YXRvckZvckNvbXBvbmVudCgpOiBNdXRhdG9yRm9yQ29tcG9uZW50IHtcclxuICAgIC8vICAgICByZXR1cm4gPE11dGF0b3JGb3JDb21wb25lbnQ+dGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAvLyB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgd2l0aCB0aGUgc2FtZSBhdHRyaWJ1dGVzIGFzIHRoZSBnaXZlbiBtdXRhdG9yLCBidXQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyB0eXBlcyBhcyBzdHJpbmctdmFsdWVzLlxyXG4gICAgICogRG9lcyBub3QgcmVjdXJzZSBpbnRvIG9iamVjdHMhIFRoaXMgd2lsbCByZXR1cm4gdGhlIGRlY29yYXRlZCB7QGxpbmsgTWV0YWRhdGEgbWV0YS10eXBlfSBpbnN0ZWFkIG9mIHRoZSBydW50aW1lLXR5cGUgb2YgdGhlIG9iamVjdCwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSB7fTtcclxuICAgICAgbGV0IG1ldGFUeXBlczogTWV0YUF0dHJpYnV0ZVR5cGVzID0gdGhpcy5nZXRNZXRhQXR0cmlidXRlVHlwZXMoKTtcclxuICAgICAgZm9yIChsZXQgYXR0cmlidXRlIGluIF9tdXRhdG9yKSB7XHJcbiAgICAgICAgbGV0IG1ldGFUeXBlOiBGdW5jdGlvbiB8IE9iamVjdCA9IG1ldGFUeXBlc1thdHRyaWJ1dGVdOyAvLyBjb25zdHJ1Y3RvciBvciBlbnVtXHJcbiAgICAgICAgbGV0IHR5cGU6IHN0cmluZyB8IE9iamVjdDtcclxuICAgICAgICBpZiAodHlwZW9mIG1ldGFUeXBlID09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgIHR5cGUgPSBtZXRhVHlwZS5uYW1lO1xyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXRhVHlwZSA9PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgdHlwZSA9IG1ldGFUeXBlO1xyXG5cclxuICAgICAgICBsZXQgdmFsdWU6IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmcgfCBvYmplY3QgfCBGdW5jdGlvbiA9IF9tdXRhdG9yW2F0dHJpYnV0ZV07XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSAhPSB1bmRlZmluZWQgJiYgdHlwZSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICAgIHR5cGUgPSAoPEdlbmVyYWw+dGhpcylbYXR0cmlidXRlXS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgdHlwZSA9IHZhbHVlLm5hbWU7XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHR5cGUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG5cclxuICAgICAgICB0eXBlc1thdHRyaWJ1dGVdID0gdHlwZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHNwZWNpZmllZCB7QGxpbmsgTWV0YWRhdGEuYXR0cmlidXRlVHlwZXMgfCBhdHRyaWJ1dGUgdHlwZXN9IGZyb20gdGhlIHtAbGluayBNZXRhZGF0YSB8IG1ldGFkYXRhfSBvZiB0aGlzIGluc3RhbmNlJ3MgY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNZXRhQXR0cmlidXRlVHlwZXMoKTogTWV0YUF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0TWV0YWRhdGEoKS5hdHRyaWJ1dGVUeXBlcyA/Pz0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogUmV0cmlldmVzIHRoZSB7QGxpbmsgTWV0YWRhdGEgfCBtZXRhZGF0YX0gb2YgdGhpcyBpbnN0YW5jZSdzIGNsYXNzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TWV0YWRhdGEoKTogTWV0YWRhdGEge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdID8/PSB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gbXV0YXRvciBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gX211dGF0b3IgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1cGRhdGVNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiBfbXV0YXRvcikge1xyXG4gICAgICAgIGxldCB2YWx1ZTogT2JqZWN0ID0gUmVmbGVjdC5nZXQodGhpcywgYXR0cmlidXRlKTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNdXRhYmxlKVxyXG4gICAgICAgICAgdmFsdWUudXBkYXRlTXV0YXRvcihfbXV0YXRvclthdHRyaWJ1dGVdKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBfbXV0YXRvclthdHRyaWJ1dGVdID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgYXR0cmlidXRlIHZhbHVlcyBvZiB0aGUgaW5zdGFuY2UgYWNjb3JkaW5nIHRvIHRoZSBzdGF0ZSBvZiB0aGUgbXV0YXRvci5cclxuICAgICAqIFRoZSBtdXRhdGlvbiBtYXkgYmUgcmVzdHJpY3RlZCB0byBhIHN1YnNldCBvZiB0aGUgbXV0YXRvciBhbmQgdGhlIGV2ZW50IGRpc3BhdGNoaW5nIHN1cHByZXNzZWQuXHJcbiAgICAgKiBVc2VzIG11dGF0ZUJhc2UsIGJ1dCBjYW4gYmUgb3ZlcndyaXR0ZW4gaW4gc3ViY2xhc3Nlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgYXdhaXQgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBfc2VsZWN0aW9uKTtcclxuICAgICAgaWYgKF9kaXNwYXRjaE11dGF0ZSlcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KEVWRU5ULk1VVEFURSwgeyBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHsgbXV0YXRvcjogX211dGF0b3IgfSB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIG1ldGhvZCBmb3IgbXV0YXRpb24sIGFsd2F5cyBhdmFpbGFibGUgdG8gc3ViY2xhc3Nlcy4gRG8gbm90IG92ZXJ3cml0ZSBpbiBzdWJjbGFzc2VzIVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYXN5bmMgbXV0YXRlQmFzZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbj86IHN0cmluZ1tdKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gX211dGF0b3I7XHJcblxyXG4gICAgICBpZiAoX3NlbGVjdGlvbikgeyAvLyBUT0RPOiB0aGlzIGRvZXNuJ3Qgd29yayBhcyBpdCBkb2VzIG5vdCByZWN1cnNlIGludG8gb2JqZWN0c1xyXG4gICAgICAgIG11dGF0b3IgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgb2YgX3NlbGVjdGlvbikgLy8gcmVkdWNlIHRoZSBtdXRhdG9yIHRvIHRoZSBzZWxlY3Rpb25cclxuICAgICAgICAgIGlmICh0eXBlb2YgKF9tdXRhdG9yW2F0dHJpYnV0ZV0pICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgICAgICBtdXRhdG9yW2F0dHJpYnV0ZV0gPSBfbXV0YXRvclthdHRyaWJ1dGVdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gbXV0YXRvcikge1xyXG4gICAgICAgIGlmICghUmVmbGVjdC5oYXModGhpcywgYXR0cmlidXRlKSlcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGxldCBtdXRhbnQ6IE9iamVjdCA9IFJlZmxlY3QuZ2V0KHRoaXMsIGF0dHJpYnV0ZSk7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBNdXRhdG9yID0gPE11dGF0b3I+bXV0YXRvclthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmIChtdXRhbnQgaW5zdGFuY2VvZiBNdXRhYmxlQXJyYXkgfHwgbXV0YW50IGluc3RhbmNlb2YgTXV0YWJsZSlcclxuICAgICAgICAgIGF3YWl0IG11dGFudC5tdXRhdGUodmFsdWUsIG51bGwsIGZhbHNlKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBSZWZsZWN0LnNldCh0aGlzLCBhdHRyaWJ1dGUsIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWR1Y2VzIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBnZW5lcmFsIG11dGF0b3IgYWNjb3JkaW5nIHRvIGRlc2lyZWQgb3B0aW9ucyBmb3IgbXV0YXRpb24uIFRvIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcclxuICAgICAqIEBwYXJhbSBfbXV0YXRvciBcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkO1xyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gIGV4cG9ydCB0eXBlIEdlbmVyYWwgPSBhbnk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEhvbGRzIGluZm9ybWF0aW9uIG5lZWRlZCB0byByZWNyZWF0ZSBhbiBvYmplY3QgaWRlbnRpY2FsIHRvIHRoZSBvbmUgaXQgb3JpZ2luYXRlZCBmcm9tLiBcclxuICAgKiBBIHNlcmlhbGl6YXRpb24gaXMgdXNlZCB0byBjcmVhdGUgY29waWVzIG9mIGV4aXN0aW5nIG9iamVjdHMgYXQgcnVudGltZSBvciB0byBzdG9yZSBvYmplY3RzIGFzIHN0cmluZ3Mgb3IgcmVjcmVhdGUgdGhlbS5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YXRpb24ge1xyXG4gICAgW3R5cGU6IHN0cmluZ106IEdlbmVyYWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBYnN0cmFjdCBjbGFzcyBzZXJ2aW5nIGFzIGEgYmFzZSBmb3IgaW50ZXJmYWNlLWxpa2UgcHVyZSBhYnN0cmFjdCBjbGFzc2VzIHRoYXQgd29yayB3aXRoIHRoZSBcImluc3RhbmNlb2ZcIi1vcGVyYXRvci4gXHJcbiAgICogXHJcbiAgICogKipVc2FnZSoqOlxyXG4gICAqICogQ3JlYXRlIGEgcHVyZSBhYnN0cmFjdCBjbGFzcyB0aGF0IGV4dGVuZHMge0BsaW5rIEltcGxlbWVudGFibGV9IHRoYXQgd2lsbCBzZXJ2ZSBhcyB5b3VyIGludGVyZmFjZS4gU3BlY2lmeSB0aGUgcmVxdWlyZWQgYXR0cmlidXRlcyBhbmQgbWV0aG9kcyB3aXRoaW4gaXQgYXMgYWJzdHJhY3QuIFxyXG4gICAqICogVXNlIHlvdXIgYWJzdHJhY3QgY2xhc3MgdmlhIHRoZSBgaW1wbGVtZW50c2Aga2V5d29yZCBleGFjdGx5IGhvdyB5b3Ugd291bGQgdXNlIGEgcmVndWxhciBgaW50ZXJmYWNlYC5cclxuICAgKiAqIERlY29yYXRlIHRoZSBjbGFzcyB0aGF0IGltcGxlbWVudHMgeW91ciBhYnN0cmFjdCBjbGFzcyB1c2luZyB0aGUgc3RhdGljIGBZT1VSX0FCU1RSQUNUX0NMQVNTYC57QGxpbmsgcmVnaXN0ZXJ9IG1ldGhvZC5cclxuICAgKiAqIE5vdyB5b3UgY2FuIHVzZSB0aGUgYGluc3RhbmNlb2ZgLW9wZXJhdG9yIHdpdGggeW91ciBhYnN0cmFjdCBjbGFzcy5cclxuICAgKiBcclxuICAgKiAqKkV4YW1wbGUqKjpcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogaW1wb3J0IMaSID0gRnVkZ2VDb3JlO1xyXG4gICAqIFxyXG4gICAqIGFic3RyYWN0IGNsYXNzIE15SW50ZXJmYWNlIGV4dGVuZHMgxpIuSW1wbGVtZW50YWJsZSB7XHJcbiAgICogICBwdWJsaWMgYWJzdHJhY3QgbXlBdHRyaWJ1dGU6IHN0cmluZztcclxuICAgKiAgIHB1YmxpYyBhYnN0cmFjdCBteU1ldGhvZCgpOiB2b2lkO1xyXG4gICAqIH1cclxuICAgKiBcclxuICAgKiBATXlJbnRlcmZhY2UucmVnaXN0ZXJcclxuICAgKiBjbGFzcyBNeUNsYXNzIGltcGxlbWVudHMgTXlJbnRlcmZhY2Uge1xyXG4gICAqICAgcHVibGljIG15QXR0cmlidXRlOiBzdHJpbmc7XHJcbiAgICogICBwdWJsaWMgbXlNZXRob2QoKTogdm9pZCB7fVxyXG4gICAqIH1cclxuICAgKiBcclxuICAgKiBsZXQgbXlJbnN0YW5jZTogTXlJbnRlcmZhY2UgPSBuZXcgTXlDbGFzcygpO1xyXG4gICAqIGNvbnNvbGUubG9nKG15SW5zdGFuY2UgaW5zdGFuY2VvZiBNeUludGVyZmFjZSk7IC8vIHRydWVcclxuICAgKiBjb25zb2xlLmxvZyhNeUNsYXNzLnByb3RvdHlwZSBpbnN0YW5jZW9mIE15SW50ZXJmYWNlKTsgLy8gdHJ1ZVxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbXBsZW1lbnRhYmxlIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXI8VCBleHRlbmRzIHR5cGVvZiBJbXBsZW1lbnRhYmxlPih0aGlzOiBULCBfY2xhc3M6IGFic3RyYWN0IG5ldyAoLi4uYXJnczogR2VuZXJhbFtdKSA9PiBJbnN0YW5jZVR5cGU8VD4sIF9jb250ZXh0OiBDbGFzc0RlY29yYXRvckNvbnRleHQpOiB2b2lkIHtcclxuICAgICAgbGV0IG1ldGE6IE1ldGFkYXRhID0gX2NvbnRleHQubWV0YWRhdGE7XHJcbiAgICAgIGlmICghT2JqZWN0Lmhhc093bihtZXRhLCBcImltcGxlbWVudHNcIikpXHJcbiAgICAgICAgbWV0YS5pbXBsZW1lbnRzID0gbmV3IFNldChtZXRhLmltcGxlbWVudHMpO1xyXG5cclxuICAgICAgbGV0IGltcGxlbWVudDogR2VuZXJhbCA9IHRoaXM7XHJcbiAgICAgIHdoaWxlIChpbXBsZW1lbnQgIT0gSW1wbGVtZW50YWJsZSkge1xyXG4gICAgICAgIG1ldGEuaW1wbGVtZW50cy5hZGQoaW1wbGVtZW50KTtcclxuICAgICAgICBpbXBsZW1lbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW1wbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0oX2luc3RhbmNlOiB1bmtub3duKTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBtZXRhOiBNZXRhZGF0YSA9IF9pbnN0YW5jZS5jb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdO1xyXG4gICAgICByZXR1cm4gbWV0YT8uaW1wbGVtZW50cz8uaGFzKHRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBTZXJpYWxpemFibGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIFNlcmlhbGl6YXRpb259IG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbjtcclxuICAgIC8qKlxyXG4gICAgICogUmVjcmVhdGVzIHRoaXMgaW5zdGFuY2Ugb2Yge0BsaW5rIFNlcmlhbGl6YWJsZX0gd2l0aCB0aGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgZ2l2ZW4ge0BsaW5rIFNlcmlhbGl6YXRpb259LlxyXG4gICAgICovXHJcbiAgICBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPjtcclxuICB9XHJcblxyXG4gIGludGVyZmFjZSBOYW1lc3BhY2VSZWdpc3RlciB7XHJcbiAgICBbbmFtZTogc3RyaW5nXTogT2JqZWN0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVjb3JhdG9yIHRvIG1hcmsgcHJvcGVydGllcyBvZiBhIHtAbGluayBTZXJpYWxpemFibGV9IGZvciBhdXRvbWF0aWMgc2VyaWFsaXphdGlvbiBhbmQgZWRpdG9yIGNvbmZpZ3VyYXRpb24uXHJcbiAgICogXHJcbiAgICogKipFZGl0b3IgQ29uZmlndXJhdGlvbjoqKlxyXG4gICAqIFNwZWNpZnkgYSB0eXBlIChjb25zdHJ1Y3RvcikgZm9yIGFuIGF0dHJpYnV0ZSB3aXRoaW4gYSBjbGFzcydzIHtAbGluayBNZXRhZGF0YSB8IG1ldGFkYXRhfS5cclxuICAgKiBUaGlzIGFsbG93cyB0aGUgaW50ZW5kZWQgdHlwZSBvZiBhbiBhdHRyaWJ1dGUgdG8gYmUga25vd24gYnkgdGhlIGVkaXRvciAoYXQgcnVudGltZSksIG1ha2luZyBpdDpcclxuICAgKiAtIEEgdmFsaWQgZHJvcCB0YXJnZXQgKGUuZy4sIGZvciBvYmplY3RzIGxpa2Uge0BsaW5rIE5vZGV9LCB7QGxpbmsgVGV4dHVyZX0sIHtAbGluayBNZXNofSkuXHJcbiAgICogLSBEaXNwbGF5IHRoZSBhcHByb3ByaWF0ZSBpbnB1dCBlbGVtZW50LCBldmVuIGlmIHRoZSBhdHRyaWJ1dGUgaGFzIG5vdCBiZWVuIHNldCAoYHVuZGVmaW5lZGApLlxyXG4gICAqIFxyXG4gICAqICoqU2VyaWFsaXphdGlvbjoqKlxyXG4gICAqIFRoZSBhdXRvbWF0aWMgc2VyaWFsaXphdGlvbiBvY2N1cnMgYWZ0ZXIgYW4gaW5zdGFuY2UncyB7QGxpbmsgU2VyaWFsaXphYmxlLnNlcmlhbGl6ZX0gLyB7QGxpbmsgU2VyaWFsaXphYmxlLmRlc2VyaWFsaXplfSBtZXRob2Qgd2FzIGNhbGxlZC5cclxuICAgKiAtIFByaW1pdGl2ZXMgYW5kIGVudW1zIHdpbGwgYmUgc2VyaWFsaXplZCBhcyBpcy5cclxuICAgKiAtIHtAbGluayBTZXJpYWxpemFibGV9cyB3aWxsIGJlIHNlcmlhbGl6ZWQgbmVzdGVkLiBcclxuICAgKiAtIHtAbGluayBTZXJpYWxpemFibGVSZXNvdXJjZX1zIHdpbGwgYmUgc2VyaWFsaXplZCB2aWEgdGhlaXIgcmVzb3VyY2UgaWQgYW5kIGZldGNoZWQgd2l0aCBpdCBmcm9tIHRoZSBwcm9qZWN0IHdoZW4gZGVzZXJpYWxpemVkLlxyXG4gICAqIC0ge0BsaW5rIE5vZGV9cyB3aWxsIGJlIHNlcmlhbGl6ZWQgYXMgYSBwYXRoIGNvbm5lY3RpbmcgdGhlbSB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGlmIGZvdW5kLiBEdXJpbmcgZGVzZXJpYWxpemF0aW9uLCB0aGUgcGF0aCB3aWxsIGJlIHVud291bmQgdG8gZmluZCB0aGUgaW5zdGFuY2UgaW4gdGhlIGN1cnJlbnQgaGllcmFyY2h5LiBUaGV5IHdpbGwgYmUgYXZhaWxhYmxlICoqKmFmdGVyKioqIHtAbGluayBFVkVOVC5HUkFQSF9ERVNFUklBTElaRUR9IC8ge0BsaW5rIEVWRU5ULkdSQVBIX0lOU1RBTlRJQVRFRH0gd2FzIGJyb2FkY2FzdCB0aHJvdWdoIHRoZSBoaWVyYXJjaHkuIE5vZGUgcmVmZXJlbmNlcyBjYW4gb25seSBiZSBzZXJpYWxpemVkIGZyb20gYSB7QGxpbmsgQ29tcG9uZW50fS5cclxuICAgKiBcclxuICAgKiAqKkV4YW1wbGU6KipcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogaW1wb3J0IMaSID0gRnVkZ2VDb3JlO1xyXG4gICAqXHJcbiAgICogQMaSLnNlcmlhbGl6ZVxyXG4gICAqIGV4cG9ydCBjbGFzcyBNeVNjcmlwdCBleHRlbmRzIMaSLkNvbXBvbmVudFNjcmlwdCB7XHJcbiAgICogICAjc2l6ZTogbnVtYmVyID0gMTtcclxuICAgKiBcclxuICAgKiAgIEDGki5zZXJpYWxpemUoU3RyaW5nKSAvLyBkaXNwbGF5IGEgc3RyaW5nIGluIHRoZSBlZGl0b3JcclxuICAgKiAgIHB1YmxpYyBpbmZvOiBzdHJpbmc7XHJcbiAgICpcclxuICAgKiAgIEDGki5zZXJpYWxpemUoxpIuVmVjdG9yMykgLy8gZGlzcGxheSBhIHZlY3RvciBpbiB0aGUgZWRpdG9yXHJcbiAgICogICBwdWJsaWMgcG9zaXRpb246IMaSLlZlY3RvcjMgPSBuZXcgxpIuVmVjdG9yMygxLCAyLCAzKTtcclxuICAgKlxyXG4gICAqICAgQMaSLnNlcmlhbGl6ZSjGki5NYXRlcmlhbCkgLy8gZHJvcCBhIG1hdGVyaWFsIGluc2lkZSB0aGUgZWRpdG9yIHRvIHJlZmVyZW5jZSBpdFxyXG4gICAqICAgcHVibGljIHJlc291cmNlOiDGki5NYXRlcmlhbDtcclxuICAgKlxyXG4gICAqICAgQMaSLnNlcmlhbGl6ZSjGki5Ob2RlKSAvLyBkcm9wIGEgbm9kZSBpbnNpZGUgdGhlIGVkaXRvciB0byByZWZlcmVuY2UgaXRcclxuICAgKiAgIHB1YmxpYyByZWZlcmVuY2U6IMaSLk5vZGVcclxuICAgKiBcclxuICAgKiAgIEDGki5zZXJpYWxpemUoTnVtYmVyKSAvLyBkaXNwbGF5IGEgbnVtYmVyIGluIHRoZSBlZGl0b3JcclxuICAgKiAgIHB1YmxpYyBnZXQgc2l6ZSgpOiBudW1iZXIge1xyXG4gICAqICAgICByZXR1cm4gdGhpcy4jc2l6ZTtcclxuICAgKiAgIH1cclxuICAgKiBcclxuICAgKiAgIC8vIGRlZmluZSBhIHNldHRlciB0byBhbGxvdyB3cml0aW5nIHRvIHNpemUsIG9yIG9taXQgaXQgdG8gbGVhdmUgdGhlIHByb3BlcnR5IHJlYWQtb25seVxyXG4gICAqICAgcHVibGljIHNldCBzaXplKF9zaXplOiBudW1iZXIpIHtcclxuICAgKiAgICAgdGhpcy4jc2l6ZSA9IF9zaXplO1xyXG4gICAqICAgfVxyXG4gICAqIH1cclxuICAgKiBgYGBcclxuICAgKiBcclxuICAgKiAqKlNpZGUgZWZmZWN0czoqKlxyXG4gICAqICogQXR0cmlidXRlcyB3aXRoIGEgc3BlY2lmaWVkIHR5cGUgd2lsbCBhbHdheXMgYmUgaW5jbHVkZWQgaW4gdGhlIHtAbGluayBNdXRhdG9yIGJhc2UtbXV0YXRvcn0gXHJcbiAgICogKHZpYSB7QGxpbmsgTXV0YWJsZS5nZXRNdXRhdG9yfSksIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgb3duIHR5cGUuIE5vbi17QGxpbmsgTXV0YWJsZSBtdXRhYmxlfSBvYmplY3RzIFxyXG4gICAqIHdpbGwgYmUgZGlzcGxheWVkIHZpYSB0aGVpciB7QGxpbmsgdG9TdHJpbmd9IG1ldGhvZCBpbiB0aGUgZWRpdG9yLlxyXG4gICAqICogRGVjb3JhdGVkIGdldHRlcnMgd2lsbCBiZSBtYWRlIGVudW1lcmFibGUsIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0VudW1lcmFiaWxpdHlfYW5kX293bmVyc2hpcF9vZl9wcm9wZXJ0aWVzXHJcbiAgICogXHJcbiAgICogQGF1dGhvciBKb25hcyBQbG90emt5LCBIRlUsIDIwMjQtMjAyNVxyXG4gICAqL1xyXG4gIC8vIGNsYXNzIGRlY29yYXRvclxyXG4gIGV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemUoX3ZhbHVlOiBhYnN0cmFjdCBuZXcgKC4uLmFyZ3M6IEdlbmVyYWxbXSkgPT4gU2VyaWFsaXphYmxlLCBfY29udGV4dDogQ2xhc3NEZWNvcmF0b3JDb250ZXh0KTogdm9pZDtcclxuICAvLyBvYmplY3QgdHlwZSwgY2hlY2sgaWYgdGhlIGFjdHVhbCB0eXBlIGlzIGFzc2lnbmFibGUgdG8gdGhlIGdpdmVuIHR5cGVcclxuICBleHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplPFQsIEMgZXh0ZW5kcyBhYnN0cmFjdCBuZXcgKC4uLmFyZ3M6IEdlbmVyYWxbXSkgPT4gVD4oX2NvbnN0cnVjdG9yOiBDKTogKF92YWx1ZTogdW5rbm93biwgX2NvbnRleHQ6IENsYXNzUHJvcGVydHlDb250ZXh0PFQgZXh0ZW5kcyBOb2RlID8gTm9kZSBleHRlbmRzIFQgPyBDb21wb25lbnQgOiBTZXJpYWxpemFibGUgOiBTZXJpYWxpemFibGUsIFQ+KSA9PiB2b2lkO1xyXG4gIC8vIHByaW1pdGl2ZSB0eXBlLCBjaGVjayBpZiB0aGUgZ2l2ZW4gdHlwZSAoYSBwcmltaXRpdmUgY29uc3RydWN0b3IpIGlzIGFzc2lnbmFibGUgdG8gdGhlIGFjdHVhbCB0eXBlIChwcmltaXRpdmUpLlxyXG4gIGV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemU8VCBleHRlbmRzIE51bWJlciB8IFN0cmluZyB8IEJvb2xlYW4+KF9jb25zdHJ1Y3RvcjogYWJzdHJhY3QgbmV3ICguLi5hcmdzOiBHZW5lcmFsW10pID0+IFQpOiAoX3ZhbHVlOiB1bmtub3duLCBfY29udGV4dDogQ2xhc3NQcm9wZXJ0eUNvbnRleHQ8U2VyaWFsaXphYmxlLCBUPikgPT4gdm9pZDtcclxuICAvLyBlbnVtIHR5cGVcclxuICBleHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplPFQsIEUgZXh0ZW5kcyBSZWNvcmQ8a2V5b2YgRSwgVD4+KF9lbnVtOiBFKTogKF92YWx1ZTogdW5rbm93biwgX2NvbnRleHQ6IENsYXNzUHJvcGVydHlDb250ZXh0PFNlcmlhbGl6YWJsZSwgVD4pID0+IHZvaWQ7XHJcbiAgZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShfY29uc3RydWN0b3I6IEZ1bmN0aW9uIHwgT2JqZWN0LCBfY29udGV4dD86IENsYXNzRGVjb3JhdG9yQ29udGV4dCk6ICgoX3ZhbHVlOiB1bmtub3duLCBfY29udGV4dDogQ2xhc3NQcm9wZXJ0eUNvbnRleHQpID0+IHZvaWQpIHwgdm9pZCB7XHJcbiAgICAvLyBkZWNvcmF0ZSBjbGFzc1xyXG4gICAgaWYgKF9jb250ZXh0KSB7XHJcbiAgICAgIGxldCBtZXRhOiBNZXRhZGF0YSA9IF9jb250ZXh0Lm1ldGFkYXRhO1xyXG5cclxuICAgICAgY29uc3QgcHJvdG90eXBlOiBTZXJpYWxpemFibGUgPSAoPEZ1bmN0aW9uPl9jb25zdHJ1Y3RvcikucHJvdG90eXBlO1xyXG5cclxuICAgICAgLy8gbWFrZSBnZXR0ZXJzIGVudW1lcmFibGVcclxuICAgICAgaWYgKG1ldGEuZW51bWVyYXRlS2V5cylcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBtZXRhLmVudW1lcmF0ZUtleXMpXHJcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuXHJcbiAgICAgIC8vIG92ZXJyaWRlIHNlcmlhbGl6ZSBhbmQgZGVzZXJpYWxpemUgbWV0aG9kc1xyXG4gICAgICBjb25zdCBvcmlnaW5hbFNlcmlhbGl6ZTogU2VyaWFsaXphYmxlW1wic2VyaWFsaXplXCJdID0gcHJvdG90eXBlLnNlcmlhbGl6ZTtcclxuICAgICAgY29uc3Qgb3JpZ2luYWxEZXNlcmlhbGl6ZTogU2VyaWFsaXphYmxlW1wiZGVzZXJpYWxpemVcIl0gPSBwcm90b3R5cGUuZGVzZXJpYWxpemU7XHJcbiAgICAgIGNvbnN0IHNlcmlhbGl6YWJsZXM6IE1ldGFkYXRhW1wic2VyaWFsaXphYmxlc1wiXSA9IG1ldGEuc2VyaWFsaXphYmxlcztcclxuXHJcbiAgICAgIHByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAodGhpczogU2VyaWFsaXphYmxlKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgICAgY29uc3Qgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IG9yaWdpbmFsU2VyaWFsaXplPy5jYWxsKHRoaXMpID8/IHt9O1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzZXJpYWxpemFibGVzKSB7XHJcbiAgICAgICAgICBsZXQgdmFsdWU6IEdlbmVyYWwgPSBSZWZsZWN0LmdldCh0aGlzLCBrZXkpO1xyXG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgIHN3aXRjaCAoc2VyaWFsaXphYmxlc1trZXldKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwcmltaXRpdmVcIjpcclxuICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInNlcmlhbGl6YWJsZVwiOlxyXG4gICAgICAgICAgICAgIHNlcmlhbGl6YXRpb25ba2V5XSA9IHZhbHVlLnNlcmlhbGl6ZSgpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicmVzb3VyY2VcIjpcclxuICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uW2tleV0gPSB2YWx1ZS5pZFJlc291cmNlO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibm9kZVwiOlxyXG4gICAgICAgICAgICAgIHNlcmlhbGl6YXRpb25ba2V5XSA9IE5vZGUuUEFUSF9GUk9NX1RPKDxDb21wb25lbnQ+dGhpcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBwcm90b3R5cGUuZGVzZXJpYWxpemUgPSBhc3luYyBmdW5jdGlvbiAodGhpczogU2VyaWFsaXphYmxlLCBfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsRGVzZXJpYWxpemUpXHJcbiAgICAgICAgICBhd2FpdCBvcmlnaW5hbERlc2VyaWFsaXplLmNhbGwodGhpcywgX3NlcmlhbGl6YXRpb24pO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzZXJpYWxpemFibGVzKSB7XHJcbiAgICAgICAgICBsZXQgdmFsdWU6IEdlbmVyYWwgPSBfc2VyaWFsaXphdGlvbltrZXldO1xyXG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgIHN3aXRjaCAoc2VyaWFsaXphYmxlc1trZXldKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwcmltaXRpdmVcIjpcclxuICAgICAgICAgICAgICBSZWZsZWN0LnNldCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInNlcmlhbGl6YWJsZVwiOlxyXG4gICAgICAgICAgICAgIGF3YWl0IFJlZmxlY3QuZ2V0KHRoaXMsIGtleSkuZGVzZXJpYWxpemUodmFsdWUpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicmVzb3VyY2VcIjpcclxuICAgICAgICAgICAgICBSZWZsZWN0LnNldCh0aGlzLCBrZXksIFByb2plY3QucmVzb3VyY2VzW3ZhbHVlXSA/PyBhd2FpdCBQcm9qZWN0LmdldFJlc291cmNlKHZhbHVlKSk7IC8vIGF3YWl0IGlzIGNvc3RseSBzbyBmaXJzdCB0cnkgdG8gZ2V0IHJlc291cmNlIGRpcmVjdGx5XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJub2RlXCI6XHJcbiAgICAgICAgICAgICAgbGV0IGluc3RhbmNlOiBDb21wb25lbnQgPSA8Q29tcG9uZW50PnRoaXM7XHJcbiAgICAgICAgICAgICAgY29uc3QgaG5kTm9kZURlc2VyaWFsaXplZDogRXZlbnRMaXN0ZW5lclVuaWZpZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBobmRHcmFwaERlc2VyaWFsaXplZDogRXZlbnRMaXN0ZW5lclVuaWZpZWQgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LnNldCh0aGlzLCBrZXksIE5vZGUuRklORChpbnN0YW5jZSwgdmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULkdSQVBIX0RFU0VSSUFMSVpFRCwgaG5kR3JhcGhEZXNlcmlhbGl6ZWQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZS5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuR1JBUEhfSU5TVEFOVElBVEVELCBobmRHcmFwaERlc2VyaWFsaXplZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQsIGhuZE5vZGVEZXNlcmlhbGl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5HUkFQSF9ERVNFUklBTElaRUQsIGhuZEdyYXBoRGVzZXJpYWxpemVkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5HUkFQSF9JTlNUQU5USUFURUQsIGhuZEdyYXBoRGVzZXJpYWxpemVkLCB0cnVlKTtcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIGluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQsIGhuZE5vZGVEZXNlcmlhbGl6ZWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZGVjb3JhdGUgcHJvcGVydHlcclxuICAgIHJldHVybiAoX3ZhbHVlLCBfY29udGV4dCkgPT4geyAvLyBjb3VsZCBjYWNoZSB0aGUgZGVjb3JhdG9yIGZ1bmN0aW9uIGZvciBlYWNoIGNsYXNzXHJcbiAgICAgIGlmICh0eXBlb2YgX2NvbnRleHQubmFtZSAhPSBcInN0cmluZ1wiKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBtZXRhOiBNZXRhZGF0YSA9IF9jb250ZXh0Lm1ldGFkYXRhO1xyXG5cclxuICAgICAgLy8gYWRkIGF0dHJpYnV0ZSB0eXBlIHRvIG1ldGFkYXRhXHJcbiAgICAgIGlmICghT2JqZWN0Lmhhc093bihtZXRhLCBcImF0dHJpYnV0ZVR5cGVzXCIpKVxyXG4gICAgICAgIG1ldGEuYXR0cmlidXRlVHlwZXMgPSB7IC4uLm1ldGEuYXR0cmlidXRlVHlwZXMgfTtcclxuICAgICAgbWV0YS5hdHRyaWJ1dGVUeXBlc1tfY29udGV4dC5uYW1lXSA9IF9jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICAgIC8vIGRldGVybWluZSBzZXJpYWxpemF0aW9uIHR5cGUgYW5kIGFkZCB0byBtZXRhZGF0YVxyXG4gICAgICBsZXQgdHlwZTogTWV0YWRhdGFbXCJzZXJpYWxpemFibGVzXCJdW3N0cmluZ107XHJcblxyXG4gICAgICBpZiAoX2NvbnN0cnVjdG9yID09IFN0cmluZyB8fCBfY29uc3RydWN0b3IgPT0gTnVtYmVyIHx8IF9jb25zdHJ1Y3RvciA9PSBCb29sZWFuIHx8IHR5cGVvZiBfY29uc3RydWN0b3IgPT0gXCJvYmplY3RcIikgLy8gcHJpbWl0aXZlIG9yIGVudW1cclxuICAgICAgICB0eXBlID0gXCJwcmltaXRpdmVcIjtcclxuICAgICAgZWxzZSBpZiAoX2NvbnN0cnVjdG9yID09IE5vZGUpXHJcbiAgICAgICAgdHlwZSA9IFwibm9kZVwiO1xyXG4gICAgICBlbHNlIGlmICgoPEZ1bmN0aW9uPl9jb25zdHJ1Y3RvcikucHJvdG90eXBlIGluc3RhbmNlb2YgU2VyaWFsaXphYmxlUmVzb3VyY2UpXHJcbiAgICAgICAgdHlwZSA9IFwicmVzb3VyY2VcIjtcclxuICAgICAgZWxzZSBpZiAoKDxGdW5jdGlvbj5fY29uc3RydWN0b3IpLnByb3RvdHlwZS5zZXJpYWxpemUgJiYgKDxGdW5jdGlvbj5fY29uc3RydWN0b3IpLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSlcclxuICAgICAgICB0eXBlID0gXCJzZXJpYWxpemFibGVcIjtcclxuXHJcbiAgICAgIGlmICghdHlwZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBpZiAoIU9iamVjdC5oYXNPd24obWV0YSwgXCJzZXJpYWxpemFibGVzXCIpKVxyXG4gICAgICAgIG1ldGEuc2VyaWFsaXphYmxlcyA9IHsgLi4ubWV0YS5zZXJpYWxpemFibGVzIH07XHJcbiAgICAgIG1ldGEuc2VyaWFsaXphYmxlc1tfY29udGV4dC5uYW1lXSA9IHR5cGU7XHJcblxyXG4gICAgICBpZiAoX2NvbnRleHQua2luZCAhPSBcImdldHRlclwiKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIC8vIG1hcmsgZ2V0dGVyIHRvIGJlIG1hZGUgZW51bWVyYWJsZVxyXG4gICAgICBpZiAoIU9iamVjdC5oYXNPd24obWV0YSwgXCJlbnVtZXJhYmxlS2V5c1wiKSlcclxuICAgICAgICBtZXRhLmVudW1lcmF0ZUtleXMgPSBbXTtcclxuXHJcbiAgICAgIG1ldGEuZW51bWVyYXRlS2V5cy5wdXNoKF9jb250ZXh0Lm5hbWUudG9TdHJpbmcoKSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyB0aGUgZXh0ZXJuYWwgc2VyaWFsaXphdGlvbiBhbmQgZGVzZXJpYWxpemF0aW9uIG9mIHtAbGluayBTZXJpYWxpemFibGV9IG9iamVjdHMuIFRoZSBpbnRlcm5hbCBwcm9jZXNzIGlzIGhhbmRsZWQgYnkgdGhlIG9iamVjdHMgdGhlbXNlbHZlcy4gIFxyXG4gICAqIEEge0BsaW5rIFNlcmlhbGl6YXRpb259IG9iamVjdCBjYW4gYmUgY3JlYXRlZCBmcm9tIGEge0BsaW5rIFNlcmlhbGl6YWJsZX0gb2JqZWN0IGFuZCBhIEpTT04tU3RyaW5nIG1heSBiZSBjcmVhdGVkIGZyb20gdGhhdC4gIFxyXG4gICAqIFZpY2UgdmVyc2EsIGEgSlNPTi1TdHJpbmcgY2FuIGJlIHBhcnNlZCB0byBhIHtAbGluayBTZXJpYWxpemF0aW9ufSB3aGljaCBjYW4gYmUgZGVzZXJpYWxpemVkIHRvIGEge0BsaW5rIFNlcmlhbGl6YWJsZX0gb2JqZWN0LlxyXG4gICAqIGBgYHRleHRcclxuICAgKiAgW1NlcmlhbGl6YWJsZV0g4oaSIChzZXJpYWxpemUpIOKGkiBbU2VyaWFsaXphdGlvbl0g4oaSIChzdHJpbmdpZnkpIOKGkiBbU3RyaW5nXSDihpIgKHNhdmUgb3Igc2VuZClcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpMgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaTICAgICAgICAgICAgICAgICAg4oaTICAgICAgICAgXHJcbiAgICogICAgICAgICAgICAgICAgW1NlcmlhbGl6YWJsZV0g4oaQIChkZXNlcmlhbGl6ZSkg4oaQIFtTZXJpYWxpemF0aW9uXSDihpAgKHBhcnNlKSDihpAgKGxvYWQpIOKGkCBbTWVkaXVtXVxyXG4gICAqIGBgYCAgICAgIFxyXG4gICAqIFdoaWxlIHRoZSBpbnRlcm5hbCBzZXJpYWxpemUvZGVzZXJpYWxpemUgbWV0aG9kMXMgb2YgdGhlIG9iamVjdHMgY2FyZSBvZiB0aGUgc2VsZWN0aW9uIG9mIGluZm9ybWF0aW9uIG5lZWRlZCB0byByZWNyZWF0ZSB0aGUgb2JqZWN0IGFuZCBpdHMgc3RydWN0dXJlLCAgXHJcbiAgICogdGhlIHtAbGluayBTZXJpYWxpemVyfSBrZWVwcyB0cmFjayBvZiB0aGUgbmFtZXNwYWNlcyBhbmQgY2xhc3NlcyBpbiBvcmRlciB0byByZWNyZWF0ZSB7QGxpbmsgU2VyaWFsaXphYmxlfSBvYmplY3RzLiBUaGUgZ2VuZXJhbCBzdHJ1Y3R1cmUgb2YgYSB7QGxpbmsgU2VyaWFsaXphdGlvbn0gaXMgYXMgZm9sbG93cyAgXHJcbiAgICogYGBgdGV4dFxyXG4gICAqIHtcclxuICAgKiAgICAgIG5hbWVzcGFjZU5hbWUuY2xhc3NOYW1lOiB7XHJcbiAgICogICAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eVZhbHVlLFxyXG4gICAqICAgICAgICAgIC4uLixcclxuICAgKiAgICAgICAgICBwcm9wZXJ0eU5hbWVPZlJlZmVyZW5jZTogU2VyaWFsaXphdGlvbk9mVGhlUmVmZXJlbmNlZE9iamVjdCxcclxuICAgKiAgICAgICAgICAuLi4sXHJcbiAgICogICAgICAgICAgY29uc3RydWN0b3JOYW1lT2ZTdXBlcmNsYXNzOiBTZXJpYWxpemF0aW9uT2ZTdXBlckNsYXNzXHJcbiAgICogICAgICB9XHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqIFNpbmNlIHRoZSBpbnN0YW5jZSBvZiB0aGUgc3VwZXJjbGFzcyBpcyBjcmVhdGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhbiBvYmplY3QgaXMgY3JlYXRlZCwgXHJcbiAgICogdGhlIFNlcmlhbGl6YXRpb25PZlN1cGVyQ2xhc3Mgb21pdHMgdGhlIHRoZSBuYW1lc3BhY2VOYW1lLmNsYXNzTmFtZSBrZXkgYW5kIGNvbnNpc3RzIG9ubHkgb2YgaXRzIHZhbHVlLiBcclxuICAgKiBUaGUgY29uc3RydWN0b3JOYW1lT2ZTdXBlcmNsYXNzIGlzIGdpdmVuIGluc3RlYWQgYXMgYSBwcm9wZXJ0eSBuYW1lIGluIHRoZSBzZXJpYWxpemF0aW9uIG9mIHRoZSBzdWJjbGFzcy5cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2VyaWFsaXplciB7XHJcbiAgICAvKiogSW4gb3JkZXIgZm9yIHRoZSBTZXJpYWxpemVyIHRvIGNyZWF0ZSBjbGFzcyBpbnN0YW5jZXMsIGl0IG5lZWRzIGFjY2VzcyB0byB0aGUgYXBwcm9wcmlhdGUgbmFtZXNwYWNlcyAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbmFtZXNwYWNlczogTmFtZXNwYWNlUmVnaXN0ZXIgPSB7IFwixpJcIjogRnVkZ2VDb3JlIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYSBuYW1lc3BhY2UgdG8gdGhlIHtAbGluayBTZXJpYWxpemVyfSwgdG8gZW5hYmxlIGF1dG9tYXRpYyBpbnN0YW50aWF0aW9uIG9mIGNsYXNzZXMgZGVmaW5lZCB3aXRoaW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWdpc3Rlck5hbWVzcGFjZShfbmFtZXNwYWNlOiBPYmplY3QpOiBzdHJpbmcge1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIFNlcmlhbGl6ZXIubmFtZXNwYWNlcylcclxuICAgICAgICBpZiAoU2VyaWFsaXplci5uYW1lc3BhY2VzW25hbWVdID09IF9uYW1lc3BhY2UpXHJcbiAgICAgICAgICByZXR1cm4gbmFtZTtcclxuXHJcbiAgICAgIGxldCBuYW1lOiBzdHJpbmcgPSBTZXJpYWxpemVyLmZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlLCB3aW5kb3cpO1xyXG4gICAgICBpZiAoIW5hbWUpXHJcbiAgICAgICAgZm9yIChsZXQgcGFyZW50TmFtZSBpbiBTZXJpYWxpemVyLm5hbWVzcGFjZXMpIHtcclxuICAgICAgICAgIG5hbWUgPSBTZXJpYWxpemVyLmZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlLCBTZXJpYWxpemVyLm5hbWVzcGFjZXNbcGFyZW50TmFtZV0pO1xyXG4gICAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgbmFtZSA9IHBhcmVudE5hbWUgKyBcIi5cIiArIG5hbWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIGlmICghbmFtZSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lc3BhY2Ugbm90IGZvdW5kLiBNYXliZSBwYXJlbnQgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQgYmVmb3JlP1wiKTtcclxuXHJcbiAgICAgIFNlcmlhbGl6ZXIubmFtZXNwYWNlc1tuYW1lXSA9IF9uYW1lc3BhY2U7XHJcbiAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6YWJsZSBGVURHRS1vYmplY3QgZ2l2ZW4sXHJcbiAgICAgKiBpbmNsdWRpbmcgYXR0YWNoZWQgY29tcG9uZW50cywgY2hpbGRyZW4sIHN1cGVyY2xhc3Mtb2JqZWN0cyBhbGwgaW5mb3JtYXRpb24gbmVlZGVkIGZvciByZWNvbnN0cnVjdGlvblxyXG4gICAgICogQHBhcmFtIF9vYmplY3QgQW4gb2JqZWN0IHRvIHNlcmlhbGl6ZSwgaW1wbGVtZW50aW5nIHRoZSB7QGxpbmsgU2VyaWFsaXphYmxlfSBpbnRlcmZhY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXJpYWxpemUoX29iamVjdDogU2VyaWFsaXphYmxlKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIC8vIFRPRE86IHNhdmUgdGhlIG5hbWVzcGFjZSB3aXRoIHRoZSBjb25zdHJ1Y3RvcnMgbmFtZVxyXG4gICAgICBsZXQgcGF0aDogc3RyaW5nID0gdGhpcy5nZXRGdWxsUGF0aChfb2JqZWN0KTtcclxuICAgICAgaWYgKCFwYXRoKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTmFtZXNwYWNlIG9mIHNlcmlhbGl6YWJsZSBvYmplY3Qgb2YgdHlwZSAke19vYmplY3QuY29uc3RydWN0b3IubmFtZX0gbm90IGZvdW5kLiBNYXliZSB0aGUgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQgb3IgdGhlIGNsYXNzIG5vdCBleHBvcnRlZD9gKTtcclxuXHJcbiAgICAgIHJldHVybiB7IFtwYXRoXTogX29iamVjdC5zZXJpYWxpemUoKSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIEZVREdFLW9iamVjdCByZWNvbnN0cnVjdGVkIGZyb20gdGhlIGluZm9ybWF0aW9uIGluIHRoZSB7QGxpbmsgU2VyaWFsaXphdGlvbn0gZ2l2ZW4sXHJcbiAgICAgKiBpbmNsdWRpbmcgYXR0YWNoZWQgY29tcG9uZW50cywgY2hpbGRyZW4sIHN1cGVyY2xhc3Mtb2JqZWN0c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgbGV0IHJlY29uc3RydWN0OiBTZXJpYWxpemFibGU7XHJcbiAgICAgIGxldCBwYXRoOiBzdHJpbmc7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gbG9vcCBjb25zdHJ1Y3RlZCBzb2xlbHkgdG8gYWNjZXNzIHR5cGUtcHJvcGVydHkuIE9ubHkgb25lIGV4cGVjdGVkIVxyXG4gICAgICAgIGZvciAocGF0aCBpbiBfc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgICAgcmVjb25zdHJ1Y3QgPSBTZXJpYWxpemVyLnJlY29uc3RydWN0KHBhdGgpO1xyXG4gICAgICAgICAgcmVjb25zdHJ1Y3QgPSBhd2FpdCByZWNvbnN0cnVjdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltwYXRoXSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgbGV0IG1lc3NhZ2U6IHN0cmluZyA9IGBEZXNlcmlhbGl6YXRpb24gb2YgJHtwYXRofSwgJHtyZWNvbnN0cnVjdCA/IFJlZmxlY3QuZ2V0KHJlY29uc3RydWN0LCBcImlkUmVzb3VyY2VcIikgOiBcIlwifSBmYWlsZWQ6IGAgKyBfZXJyb3I7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBBcnJheSBvZiBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6YWJsZSBGVURHRS1vYmplY3RzIGdpdmVuIGluIHRoZSBhcnJheSxcclxuICAgICAqIGluY2x1ZGluZyBhdHRhY2hlZCBjb21wb25lbnRzLCBjaGlsZHJlbiwgc3VwZXJjbGFzcy1vYmplY3RzIGFsbCBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIHJlY29uc3RydWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2VyaWFsaXplQXJyYXk8VCBleHRlbmRzIFNlcmlhbGl6YWJsZT4oX3R5cGU6IG5ldyAoKSA9PiBULCBfb2JqZWN0czogU2VyaWFsaXphYmxlW10pOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb25zOiBTZXJpYWxpemF0aW9uW10gPSBbXTtcclxuICAgICAgbGV0IHBhdGg6IHN0cmluZyA9IHRoaXMuZ2V0RnVsbFBhdGgobmV3IF90eXBlKCkpO1xyXG4gICAgICBpZiAoIXBhdGgpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOYW1lc3BhY2Ugb2Ygc2VyaWFsaXphYmxlIG9iamVjdCBvZiB0eXBlICR7X3R5cGUubmFtZX0gbm90IGZvdW5kLiBNYXliZSB0aGUgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQgb3IgdGhlIGNsYXNzIG5vdCBleHBvcnRlZD9gKTtcclxuXHJcbiAgICAgIGZvciAobGV0IG9iamVjdCBvZiBfb2JqZWN0cylcclxuICAgICAgICBzZXJpYWxpemF0aW9ucy5wdXNoKG9iamVjdC5zZXJpYWxpemUoKSk7XHJcblxyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHt9O1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3BhdGhdID0gc2VyaWFsaXphdGlvbnM7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBBcnJheSBvZiBGVURHRS1vYmplY3RzIHJlY29uc3RydWN0ZWQgZnJvbSB0aGUgaW5mb3JtYXRpb24gaW4gdGhlIGFycmF5IG9mIHtAbGluayBTZXJpYWxpemF0aW9ufXMgZ2l2ZW4sXHJcbiAgICAgKiBpbmNsdWRpbmcgYXR0YWNoZWQgY29tcG9uZW50cywgY2hpbGRyZW4sIHN1cGVyY2xhc3Mtb2JqZWN0c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplQXJyYXkoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVtdPiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemFibGVzOiBTZXJpYWxpemFibGVbXSA9IFtdO1xyXG4gICAgICBsZXQgY29uc3RydWN0OiBuZXcgKCkgPT4gU2VyaWFsaXphYmxlO1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbnM6IFNlcmlhbGl6YXRpb25bXSA9IFtdO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIGxvb3AgY29uc3RydWN0ZWQgc29sZWx5IHRvIGFjY2VzcyB0eXBlLXByb3BlcnR5LiBPbmx5IG9uZSBleHBlY3RlZCFcclxuICAgICAgICBmb3IgKGxldCBwYXRoIGluIF9zZXJpYWxpemF0aW9uKSB7XHJcbiAgICAgICAgICBjb25zdHJ1Y3QgPSBTZXJpYWxpemVyLmdldENvbnN0cnVjdG9yKHBhdGgpO1xyXG4gICAgICAgICAgc2VyaWFsaXphdGlvbnMgPSBfc2VyaWFsaXphdGlvbltwYXRoXTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVzZXJpYWxpemF0aW9uIGZhaWxlZDogXCIgKyBfZXJyb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGxldCBzZXJpYWxpemF0aW9uIG9mIHNlcmlhbGl6YXRpb25zKSB7XHJcbiAgICAgICAgbGV0IHNlcmlhbGl6YWJsZTogU2VyaWFsaXphYmxlID0gbmV3IGNvbnN0cnVjdCgpO1xyXG4gICAgICAgIGF3YWl0IHNlcmlhbGl6YWJsZS5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgICBzZXJpYWxpemFibGVzLnB1c2goc2VyaWFsaXphYmxlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YWJsZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy9UT0RPOiBpbXBsZW1lbnQgcHJldHRpZmllciB0byBtYWtlIEpTT04tU3RyaW5naWZpY2F0aW9uIG9mIHNlcmlhbGl6YXRpb25zIG1vcmUgcmVhZGFibGUsIGUuZy4gcGxhY2luZyB4LCB5IGFuZCB6IGluIG9uZSBsaW5lXHJcbiAgICAvKipcclxuICAgICAqIFByZXR0aWZ5IGEgSlNPTi1TdHJpbmcsIHRvIG1ha2UgaXQgbW9yZSByZWFkYWJsZS5cclxuICAgICAqIG5vdCBpbXBsZW1lbnRlZCB5ZXRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBwcmV0dGlmeShfanNvbjogc3RyaW5nKTogc3RyaW5nIHsgcmV0dXJuIF9qc29uOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkLCBodW1hbiByZWFkYWJsZSBKU09OLVN0cmluZywgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB7QGxpbmsgU2VyaWFsaXphdGlvbn0gdGhhdCBtYXkgaGF2ZSBiZWVuIGNyZWF0ZWQgYnkge0BsaW5rIFNlcmlhbGl6ZXJ9LnNlcmlhbGl6ZVxyXG4gICAgICogQHBhcmFtIF9zZXJpYWxpemF0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc3RyaW5naWZ5KF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogc3RyaW5nIHtcclxuICAgICAgLy8gYWRqdXN0bWVudHMgdG8gc2VyaWFsaXphdGlvbiBjYW4gYmUgbWFkZSBoZXJlIGJlZm9yZSBzdHJpbmdpZmljYXRpb24sIGlmIGRlc2lyZWRcclxuICAgICAgbGV0IGpzb246IHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KF9zZXJpYWxpemF0aW9uLCBudWxsLCAyKTtcclxuICAgICAgbGV0IHByZXR0eTogc3RyaW5nID0gU2VyaWFsaXplci5wcmV0dGlmeShqc29uKTtcclxuICAgICAgcmV0dXJuIHByZXR0eTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgU2VyaWFsaXphdGlvbn0gY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBKU09OLVN0cmluZy4gUmVzdWx0IG1heSBiZSBwYXNzZWQgdG8ge0BsaW5rIFNlcmlhbGl6ZXIuZGVzZXJpYWxpemV9XHJcbiAgICAgKiBAcGFyYW0gX2pzb24gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2UoX2pzb246IHN0cmluZyk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShfanNvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBvZiB0aGUgY2xhc3MgZGVmaW5lZCB3aXRoIHRoZSBmdWxsIHBhdGggaW5jbHVkaW5nIHRoZSBuYW1lc3BhY2VOYW1lKHMpIGFuZCB0aGUgY2xhc3NOYW1lIHNlcGVyYXRlZCBieSBkb3RzKC4pIFxyXG4gICAgICogQHBhcmFtIF9wYXRoIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlY29uc3RydWN0KF9wYXRoOiBzdHJpbmcpOiBTZXJpYWxpemFibGUge1xyXG4gICAgICBsZXQgY29uc3RydWN0b3I6IG5ldyAoKSA9PiBTZXJpYWxpemFibGUgPSBTZXJpYWxpemVyLmdldENvbnN0cnVjdG9yKF9wYXRoKTtcclxuICAgICAgbGV0IHJlY29uc3RydWN0aW9uOiBTZXJpYWxpemFibGUgPSBuZXcgY29uc3RydWN0b3IoKTtcclxuICAgICAgcmV0dXJuIHJlY29uc3RydWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgZ2V0Q29uc3RydWN0b3I8VCBleHRlbmRzIFNlcmlhbGl6YWJsZT4oX3R5cGU6IHN0cmluZywgX25hbWVzcGFjZTogT2JqZWN0ID0gRnVkZ2VDb3JlKTogbmV3ICgpID0+IFQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25zdHJ1Y3RvciBmcm9tIHRoZSBnaXZlbiBwYXRoIHRvIGEgY2xhc3NcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb25zdHJ1Y3RvcjxUIGV4dGVuZHMgU2VyaWFsaXphYmxlPihfcGF0aDogc3RyaW5nKTogbmV3ICgpID0+IFQge1xyXG4gICAgICBsZXQgdHlwZU5hbWU6IHN0cmluZyA9IF9wYXRoLnN1YnN0cmluZyhfcGF0aC5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcclxuICAgICAgbGV0IG5hbWVzcGFjZTogT2JqZWN0ID0gU2VyaWFsaXplci5nZXROYW1lc3BhY2UoX3BhdGgpO1xyXG4gICAgICBpZiAoIW5hbWVzcGFjZSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnN0cnVjdG9yIG9mIHNlcmlhbGl6YWJsZSBvYmplY3Qgb2YgdHlwZSAke19wYXRofSBub3QgZm91bmQuIE1heWJlIHRoZSBuYW1lc3BhY2UgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZD9gKTtcclxuICAgICAgcmV0dXJuICg8R2VuZXJhbD5uYW1lc3BhY2UpW3R5cGVOYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGZ1bGwgcGF0aCB0byB0aGUgY2xhc3Mgb2YgdGhlIG9iamVjdCwgaWYgZm91bmQgaW4gdGhlIHJlZ2lzdGVyZWQgbmFtZXNwYWNlc1xyXG4gICAgICogQHBhcmFtIF9vYmplY3QgXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGdldEZ1bGxQYXRoKF9vYmplY3Q6IFNlcmlhbGl6YWJsZSk6IHN0cmluZyB7XHJcbiAgICAgIGxldCB0eXBlTmFtZTogc3RyaW5nID0gX29iamVjdC5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAvLyBEZWJ1Zy5sb2coXCJTZWFyY2hpbmcgbmFtZXNwYWNlIG9mOiBcIiArIHR5cGVOYW1lKTtcclxuICAgICAgZm9yIChsZXQgbmFtZXNwYWNlTmFtZSBpbiBTZXJpYWxpemVyLm5hbWVzcGFjZXMpIHtcclxuICAgICAgICBsZXQgZm91bmQ6IEdlbmVyYWwgPSAoPEdlbmVyYWw+U2VyaWFsaXplci5uYW1lc3BhY2VzKVtuYW1lc3BhY2VOYW1lXVt0eXBlTmFtZV07XHJcbiAgICAgICAgaWYgKGZvdW5kICYmIF9vYmplY3QgaW5zdGFuY2VvZiBmb3VuZClcclxuICAgICAgICAgIHJldHVybiBuYW1lc3BhY2VOYW1lICsgXCIuXCIgKyB0eXBlTmFtZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5hbWVzcGFjZS1vYmplY3QgZGVmaW5lZCB3aXRoaW4gdGhlIGZ1bGwgcGF0aCwgaWYgcmVnaXN0ZXJlZFxyXG4gICAgICogQHBhcmFtIF9wYXRoXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGdldE5hbWVzcGFjZShfcGF0aDogc3RyaW5nKTogT2JqZWN0IHtcclxuICAgICAgbGV0IG5hbWVzcGFjZU5hbWU6IHN0cmluZyA9IF9wYXRoLnN1YnN0cigwLCBfcGF0aC5sYXN0SW5kZXhPZihcIi5cIikpO1xyXG4gICAgICByZXR1cm4gU2VyaWFsaXplci5uYW1lc3BhY2VzW25hbWVzcGFjZU5hbWVdIHx8IEZ1ZGdlQ29yZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIHRoZSBuYW1lc3BhY2Utb2JqZWN0IGluIHByb3BlcnRpZXMgb2YgdGhlIHBhcmVudC1vYmplY3QgKGUuZy4gd2luZG93KSwgaWYgcHJlc2VudFxyXG4gICAgICogQHBhcmFtIF9uYW1lc3BhY2UgXHJcbiAgICAgKiBAcGFyYW0gX3BhcmVudCBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmluZE5hbWVzcGFjZUluKF9uYW1lc3BhY2U6IE9iamVjdCwgX3BhcmVudDogT2JqZWN0KTogc3RyaW5nIHtcclxuICAgICAgZm9yIChsZXQgcHJvcCBpbiBfcGFyZW50KVxyXG4gICAgICAgIGlmICgoPEdlbmVyYWw+X3BhcmVudClbcHJvcF0gPT0gX25hbWVzcGFjZSlcclxuICAgICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgKGFic3RyYWN0KSBjbGFzcyBpbXBsZW1lbnRpbmcge0BsaW5rIFNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWx9IGZyb20gYW55IGNsYXNzIHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgU2VyaWFsaXphYmxlUmVzb3VyY2V9IGJ5IG1peGluZyBpbiB0aGUgZnVuY3Rpb25hbGl0eSB0byBsb2FkIHRoZSByZXNvdXJjZSBmcm9tIGFuIGV4dGVybmFsIHNvdXJjZS5cclxuICAgKiBAaW50ZXJuYWwgXHJcbiAgICogQGF1dGhvcnMgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDI0XHJcbiAgICovXHJcbiAgZXhwb3J0IGZ1bmN0aW9uIG1peGluU2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbDxUQmFzZSBleHRlbmRzIGFic3RyYWN0IG5ldyAoLi4uYXJnczogR2VuZXJhbFtdKSA9PiBTZXJpYWxpemFibGVSZXNvdXJjZT4oX2Jhc2U6IFRCYXNlKTogKGFic3RyYWN0IG5ldyAoLi4uYXJnczogR2VuZXJhbFtdKSA9PiBTZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsKSAmIFRCYXNlIHtcclxuICAgIGFic3RyYWN0IGNsYXNzIFNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWxNaXhpbiBleHRlbmRzIF9iYXNlIHtcclxuICAgICAgcHVibGljIHVybDogUmVxdWVzdEluZm87XHJcblxyXG4gICAgICBwdWJsaWMgc3RhdHVzOiBSRVNPVVJDRV9TVEFUVVMgPSBSRVNPVVJDRV9TVEFUVVMuUEVORElORztcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXR1cm5zIGEge0BsaW5rIFNlcmlhbGl6YXRpb259IG9mIHRoaXMgcmVzb3VyY2UuIE9ubHkgdGhlIGRhdGEgbmVlZGVkIHRvIGxvYWQgaXQgZnJvbSB0aGUgZXh0ZXJuYWwgc291cmNlIGlzIHNlcmlhbGl6ZWQgKFwidXJsXCIsIFwibmFtZVwiLCBcImlkUmVzb3VyY2VcIikuXHJcbiAgICAgICAqL1xyXG4gICAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2UsXHJcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICB1cmw6IHRoaXMudXJsLnRvU3RyaW5nKClcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcywgX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XHJcbiAgICAgICAgdGhpcy51cmwgPSBfc2VyaWFsaXphdGlvbi51cmw7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gX3NlcmlhbGl6YXRpb24ubmFtZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBhYnN0cmFjdCBsb2FkKCk6IFByb21pc2U8U2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbD47XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChfYmFzZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBNdXRhYmxlKSB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBNaXhpbiB0aGUge0BsaW5rIE11dGFibGV9IGZ1bmN0aW9uYWxpdHkgaW50byB0aGUgY2xhc3MgXHJcbiAgICAgICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNFxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gbWl4aW5NdXRhYmxlU2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbDxUQmFzZSBleHRlbmRzIChhYnN0cmFjdCBuZXcgKC4uLmFyZ3M6IEdlbmVyYWxbXSkgPT4gU2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbCAmIE11dGFibGUpPihfYmFzZTogVEJhc2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgICAgIGFic3RyYWN0IGNsYXNzIE11dGFibGVTZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsIGV4dGVuZHMgX2Jhc2Uge1xyXG4gICAgICAgICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoX211dGF0b3IudXJsICE9IHVuZGVmaW5lZCB8fCBfbXV0YXRvci5uYW1lICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxvYWQoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAgICAgICBkZWxldGUgX211dGF0b3Iuc3RhdHVzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIE11dGFibGVTZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbWl4aW5NdXRhYmxlU2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbCg8VEJhc2UgJiAoYWJzdHJhY3QgbmV3ICguLi5hcmdzOiBHZW5lcmFsW10pID0+IFNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWwgJiBNdXRhYmxlKT5TZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsTWl4aW4pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBTZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsTWl4aW47XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogTWFuYWdlcyB1bmlmb3JtIGRhdGEgdG8gYmUgdHJhbnNtaXR0ZWQgZHVyaW5nIHJlbmRlcmluZy4gQWxsIGRhdGEgaXMgY29sbGVjdGVkIGluIG9uZSBjb250aWd1b3VzIGJ1ZmZlciBhbmQgc2VudCB0byB0aGUgR1BVIGluIGEgc2luZ2xlIG9wZXJhdGlvbi5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAYXV0aG9ycyBKb25hcyBQbG90emt5LCBIRlUsIDIwMjVcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyQnVmZmVyTWFuYWdlciB7XHJcbiAgICBwcm90ZWN0ZWQgbWFwT2JqZWN0VG9PZmZzZXQ6IFdlYWtNYXA8V2Vha0tleSwgbnVtYmVyPiA9IG5ldyBXZWFrTWFwPFdlYWtLZXksIG51bWJlcj4oKTsgLy8gTWFwcyB0aGUgb2JqZWN0cyB0byB0aGVpciByZXNwZWN0aXZlIGJ5dGUgb2Zmc2V0IGluIHRoZSBncHUgYnVmZmVyXHJcblxyXG4gICAgLyoqIFRoZSB1bmlmb3JtIGJsb2NrIHNpemUgKGluc2lkZSB0aGUgc2hhZGVyKSBpbiBieXRlcywgaW5jbHVkZXMgbGF5b3V0IHN0ZDE0MCBwYWRkaW5nICovXHJcbiAgICBwcm90ZWN0ZWQgYmxvY2tTaXplOiBudW1iZXI7XHJcbiAgICBwcm90ZWN0ZWQgYmxvY2tCaW5kaW5nOiBudW1iZXI7XHJcblxyXG4gICAgcHJvdGVjdGVkIGJ1ZmZlcjogV2ViR0xCdWZmZXI7XHJcbiAgICAvKiogVGhlIG9mZnNldCBpbiBieXRlcyBiZXR3ZWVuIHRoZSBiZWdpbm5pbmcgb2YgY29uc2VjdXRpdmUgb2JqZWN0IGJsb2NrIGRhdGEsIHNldCB0byBhIG11bHRpcGxlIG9mIHtAbGluayBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSX09GRlNFVF9BTElHTk1FTlR9ICovXHJcbiAgICBwcm90ZWN0ZWQgc3BhY2VCdWZmZXI6IG51bWJlcjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgZGF0YTogRmxvYXQzMkFycmF5O1xyXG4gICAgLyoqIFRoZSBvZmZzZXQgaW4gZWxlbWVudHMgYmV0d2VlbiB0aGUgYmVnaW5uaW5nIG9mIGNvbnNlY3V0aXZlIG9iamVjdCBibG9jayBkYXRhICovXHJcbiAgICBwcm90ZWN0ZWQgc3BhY2VEYXRhOiBudW1iZXI7XHJcblxyXG4gICAgcHJvdGVjdGVkIGNvdW50OiBudW1iZXIgPSAwO1xyXG4gICAgXHJcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoX2Jsb2NrQmluZGluZzogbnVtYmVyLCBfYmxvY2tTaXplOiBudW1iZXIsIF9tYXhPYmplY3RzOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5ibG9ja1NpemUgPSBfYmxvY2tTaXplO1xyXG4gICAgICB0aGlzLmJsb2NrQmluZGluZyA9IF9ibG9ja0JpbmRpbmc7XHJcblxyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjb25zdCBhbGlnbm1lbnQ6IG51bWJlciA9IGNyYzMuZ2V0UGFyYW1ldGVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVJfT0ZGU0VUX0FMSUdOTUVOVCk7XHJcbiAgICAgIHRoaXMuc3BhY2VCdWZmZXIgPSBNYXRoLmNlaWwodGhpcy5ibG9ja1NpemUgLyBhbGlnbm1lbnQpICogYWxpZ25tZW50OyAvLyByb3VuZCB0byBtdWx0aXBsZSBvZiBhbGlnbm1lbnRcclxuICAgICAgdGhpcy5zcGFjZURhdGEgPSB0aGlzLnNwYWNlQnVmZmVyIC8gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuc3BhY2VEYXRhICogX21heE9iamVjdHMpO1xyXG5cclxuICAgICAgdGhpcy5idWZmZXIgPSBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xCdWZmZXI+KGNyYzMuY3JlYXRlQnVmZmVyKCkpO1xyXG4gICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG4gICAgICBjcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgdGhpcy5kYXRhLmJ5dGVMZW5ndGgsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFlOQU1JQ19EUkFXKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGdldCBpbnN0YW5jZSgpOiBSZW5kZXJCdWZmZXJNYW5hZ2VyIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5zdGFuY2VcIiwge1xyXG4gICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgIHZhbHVlOiBuZXcgdGhpcygpXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCBSZXJvdXRlcyB0aGUgZGVjb3JhdGVkIHN0YXRpYyBtZXRob2QgdG8gdGhlIGluc3RhbmNlIG1ldGhvZCBvZiB0aGUgKipzYW1lIG5hbWUqKiBvZiB0aGlzIG1hbmFnZXLigJlzIHNpbmdsZXRvbiBpbnN0YW5jZSAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkZWNvcmF0ZTxNIGV4dGVuZHMgKHRoaXM6IEdlbmVyYWwsIC4uLmFyZ3M6IEdlbmVyYWwpID0+IEdlbmVyYWw+KF9tZXRob2Q6IE0sIF9jb250ZXh0OiBDbGFzc01ldGhvZERlY29yYXRvckNvbnRleHQ8YWJzdHJhY3QgbmV3ICguLi5hcmdzOiBHZW5lcmFsW10pID0+IEdlbmVyYWwsIE0+KTogTSB7XHJcbiAgICAgIGNvbnN0IG1ldGhvZDogTSA9IFJlZmxlY3QuZ2V0KHRoaXMuaW5zdGFuY2UsIF9jb250ZXh0Lm5hbWUpOyBcclxuICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKHRoaXMuaW5zdGFuY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZXNldFJlbmRlckRhdGEoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCB1cGRhdGVSZW5kZXJidWZmZXIoKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XHJcbiAgICAgIGNyYzMuYnVmZmVyU3ViRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCAwLCB0aGlzLmRhdGEsIDAsIHRoaXMuY291bnQgKiB0aGlzLnNwYWNlRGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHVzZVJlbmRlckRhdGEoX29iamVjdDogV2Vha0tleSk6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjcmMzLmJpbmRCdWZmZXJSYW5nZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCB0aGlzLmJsb2NrQmluZGluZywgdGhpcy5idWZmZXIsIHRoaXMubWFwT2JqZWN0VG9PZmZzZXQuZ2V0KF9vYmplY3QpLCB0aGlzLmJsb2NrU2l6ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0b3JlKF9vYmplY3Q6IFdlYWtLZXkpOiBudW1iZXIge1xyXG4gICAgICBjb25zdCBvZmZzZXREYXRhOiBudW1iZXIgPSB0aGlzLmNvdW50ICogdGhpcy5zcGFjZURhdGE7XHJcbiAgICAgIHRoaXMubWFwT2JqZWN0VG9PZmZzZXQuc2V0KF9vYmplY3QsIHRoaXMuY291bnQgKiB0aGlzLnNwYWNlQnVmZmVyKTsgLy8gb2Zmc2V0IGluIGJ5dGVzXHJcbiAgICAgIHRoaXMuY291bnQrKztcclxuICAgICAgaWYgKG9mZnNldERhdGEgKyB0aGlzLnNwYWNlRGF0YSA+IHRoaXMuZGF0YS5sZW5ndGgpXHJcbiAgICAgICAgdGhpcy5ncm93KCk7XHJcblxyXG4gICAgICByZXR1cm4gb2Zmc2V0RGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdyb3coKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5kYXRhLmxlbmd0aCAqIDEuNSk7XHJcbiAgICAgIGRhdGEuc2V0KHRoaXMuZGF0YSk7XHJcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcblxyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG4gICAgICBjcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgdGhpcy5kYXRhLmJ5dGVMZW5ndGgsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFlOQU1JQ19EUkFXKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgdXBkYXRlUmVuZGVyRGF0YShfb2JqZWN0OiBXZWFrS2V5LCAuLi5fZGF0YTogR2VuZXJhbFtdKTogdm9pZDtcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogTWFuYWdlcyB7QGxpbmsgQ29hdH0gZGF0YSB0byBiZSB0cmFuc21pdHRlZCBkdXJpbmcgcmVuZGVyaW5nLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJNYW5hZ2VyQ29hdCBleHRlbmRzIFJlbmRlckJ1ZmZlck1hbmFnZXIge1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBvdmVycmlkZSByZWFkb25seSBpbnN0YW5jZTogUmVuZGVyTWFuYWdlckNvYXQ7IC8vIGxhenkgaW5pdGlhbGl6ZWQgaW4gYmFzZSBjbGFzc1xyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIGNvbnN0IG1heE1hdGVyaWFsczogbnVtYmVyID0gMTI4O1xyXG4gICAgICBjb25zdCBibG9ja1NpemU6IG51bWJlciA9ICg0ICsgMSArIDEgKyAxICsgMSArIDEpICogNDsgLy8gdmN0NCBjb2xvciwgZmxvYXQgZGlmZnVzZSwgZmxvYXQgc3BlY3VsYXIsIGZsb2F0IGludGVuc2l0eSwgZmxvYXQgbWV0YWxsaWMsIGZsb2F0IGFscGhhQ2xpcFxyXG4gICAgICBzdXBlcihVTklGT1JNX0JMT0NLLk1BVEVSSUFMLkJJTkRJTkcsIGJsb2NrU2l6ZSwgbWF4TWF0ZXJpYWxzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlPE0gZXh0ZW5kcyAodGhpczogR2VuZXJhbCwgLi4uYXJnczogR2VuZXJhbCkgPT4gR2VuZXJhbD4oX21ldGhvZDogTSwgX2NvbnRleHQ6IENsYXNzTWV0aG9kRGVjb3JhdG9yQ29udGV4dDx0eXBlb2YgQ29hdCwgTT4pOiBNIHtcclxuICAgICAgcmV0dXJuIHN1cGVyLmRlY29yYXRlKF9tZXRob2QsIF9jb250ZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgdXBkYXRlUmVuZGVyRGF0YShfY29hdDogQ29hdCk6IHZvaWQge1xyXG4gICAgICBjb25zdCBvZmZzZXQ6IG51bWJlciA9IHRoaXMuc3RvcmUoX2NvYXQpO1xyXG5cclxuICAgICAgY29uc3QgZGF0YTogRmxvYXQzMkFycmF5ID0gdGhpcy5kYXRhO1xyXG5cclxuICAgICAgaWYgKF9jb2F0IGluc3RhbmNlb2YgQ29hdENvbG9yZWQpXHJcbiAgICAgICAgZGF0YS5zZXQoX2NvYXQuY29sb3IuZ2V0KCksIG9mZnNldCk7XHJcblxyXG4gICAgICBpZiAoX2NvYXQgaW5zdGFuY2VvZiBDb2F0UmVtaXNzaXZlIHx8IF9jb2F0IGluc3RhbmNlb2YgQ29hdFJlbWlzc2l2ZVRleHR1cmVkKSB7XHJcbiAgICAgICAgZGF0YVtvZmZzZXQgKyA0XSA9IF9jb2F0LmRpZmZ1c2U7XHJcbiAgICAgICAgZGF0YVtvZmZzZXQgKyA1XSA9IF9jb2F0LnNwZWN1bGFyO1xyXG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgNl0gPSBfY29hdC5pbnRlbnNpdHk7XHJcbiAgICAgICAgZGF0YVtvZmZzZXQgKyA3XSA9IF9jb2F0Lm1ldGFsbGljO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkYXRhW29mZnNldCArIDhdID0gX2NvYXQuYWxwaGFDbGlwO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBvdmVycmlkZSB1c2VSZW5kZXJEYXRhKF9jb2F0OiBDb2F0KTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnVzZVJlbmRlckRhdGEoX2NvYXQpO1xyXG5cclxuICAgICAgaWYgKF9jb2F0IGluc3RhbmNlb2YgQ29hdFRleHR1cmVkKVxyXG4gICAgICAgIF9jb2F0LnRleHR1cmUudXNlUmVuZGVyRGF0YShURVhUVVJFX0xPQ0FUSU9OLkNPTE9SLlVOSVQpO1xyXG5cclxuICAgICAgaWYgKF9jb2F0IGluc3RhbmNlb2YgQ29hdFJlbWlzc2l2ZVRleHR1cmVkTm9ybWFscylcclxuICAgICAgICBfY29hdC5ub3JtYWxNYXAudXNlUmVuZGVyRGF0YShURVhUVVJFX0xPQ0FUSU9OLk5PUk1BTC5VTklUKTtcclxuXHJcbiAgICAgIGlmIChfY29hdCBpbnN0YW5jZW9mIENvYXRUb29uKVxyXG4gICAgICAgIF9jb2F0LnRleFRvb24udXNlUmVuZGVyRGF0YShURVhUVVJFX0xPQ0FUSU9OLlRPT04uVU5JVCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG5cclxuICAvKipcclxuICAgKiBNYW5hZ2VzIHtAbGluayBOb2RlfSBkYXRhIChkYXRhIHRoYXQgaXMgdW5pcXVlIGZvciBlYWNoIG5vZGUsIGkuZS4ge0BsaW5rIENvbXBvbmVudH0gZGF0YSkgdG8gYmUgdHJhbnNtaXR0ZWQgZHVyaW5nIHJlbmRlcmluZy5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAYXV0aG9ycyBKb25hcyBQbG90emt5LCBIRlUsIDIwMjVcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUmVuZGVyTWFuYWdlck5vZGUgZXh0ZW5kcyBSZW5kZXJCdWZmZXJNYW5hZ2VyIHtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgb3ZlcnJpZGUgcmVhZG9ubHkgaW5zdGFuY2U6IFJlbmRlck1hbmFnZXJOb2RlOyAvLyBsYXp5IGluaXRpYWxpemVkIGluIGJhc2UgY2xhc3NcclxuXHJcbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBjb25zdCBtYXhOb2RlczogbnVtYmVyID0gMjU2O1xyXG4gICAgICBjb25zdCBibG9ja1NpemU6IG51bWJlciA9ICgxNiArIDEyICsgNCArIDEgKyAxICsgMSArIDEgKyAxICsgMSkgKiA0OyAvLyBtYXQ0IG10eFdvcmxkLCBtYXQzIG10eFBpdm90LCB2ZWM0IGNvbG9yLCBmbG9hdCBibGVuZE1vZGUsIGZsb2F0IGR1cmF0aW9uLCBmbG9hdCBzaXplLCBmbG9hdCB0aW1lLCBib29sIGZhY2VDYW1lcmFBY3RpdmUsIGJvb2wgZmFjZUNhbWVyYVJlc3RyaWN0LCBcclxuICAgICAgc3VwZXIoVU5JRk9STV9CTE9DSy5OT0RFLkJJTkRJTkcsIGJsb2NrU2l6ZSwgbWF4Tm9kZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgb3ZlcnJpZGUgZGVjb3JhdGU8TSBleHRlbmRzICh0aGlzOiBHZW5lcmFsLCAuLi5hcmdzOiBHZW5lcmFsKSA9PiBHZW5lcmFsPihfbWV0aG9kOiBNLCBfY29udGV4dDogQ2xhc3NNZXRob2REZWNvcmF0b3JDb250ZXh0PHR5cGVvZiBOb2RlLCBNPik6IE0ge1xyXG4gICAgICByZXR1cm4gc3VwZXIuZGVjb3JhdGUoX21ldGhvZCwgX2NvbnRleHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBvdmVycmlkZSB1cGRhdGVSZW5kZXJEYXRhKF9ub2RlOiBOb2RlLCBfY21wTWVzaDogQ29tcG9uZW50TWVzaCwgX2NtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCwgX2NtcEZhY2VDYW1lcmE/OiBDb21wb25lbnRGYWNlQ2FtZXJhLCBfY21wUGFydGljbGVTeXN0ZW0/OiBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSk6IHZvaWQge1xyXG4gICAgICBjb25zdCBvZmZzZXQ6IG51bWJlciA9IHRoaXMuc3RvcmUoX25vZGUpO1xyXG5cclxuICAgICAgY29uc3QgZGF0YTogRmxvYXQzMkFycmF5ID0gdGhpcy5kYXRhO1xyXG4gICAgICAvLyBtdHggd29ybGRcclxuICAgICAgZGF0YS5zZXQoX2NtcE1lc2gubXR4V29ybGQuZ2V0RGF0YSgpLCBvZmZzZXQpO1xyXG5cclxuICAgICAgLy8gbXR4IHBpdm90XHJcbiAgICAgIGxldCBkYXRhUGl2b3Q6IEZsb2F0MzJBcnJheSA9IF9jbXBNYXRlcmlhbC5tdHhQaXZvdC5nZXQoKTtcclxuICAgICAgZGF0YVtvZmZzZXQgKyAxNl0gPSBkYXRhUGl2b3RbMF07XHJcbiAgICAgIGRhdGFbb2Zmc2V0ICsgMTddID0gZGF0YVBpdm90WzFdO1xyXG4gICAgICBkYXRhW29mZnNldCArIDE4XSA9IGRhdGFQaXZvdFsyXTtcclxuICAgICAgLy8gZGF0YVtvZmZzZXRQaXZvdCArIDE5XSA9IHBhZGRpbmdcclxuICAgICAgZGF0YVtvZmZzZXQgKyAyMF0gPSBkYXRhUGl2b3RbM107XHJcbiAgICAgIGRhdGFbb2Zmc2V0ICsgMjFdID0gZGF0YVBpdm90WzRdO1xyXG4gICAgICBkYXRhW29mZnNldCArIDIyXSA9IGRhdGFQaXZvdFs1XTtcclxuICAgICAgLy8gZGF0YVtvZmZzZXRQaXZvdCArIDIzXSA9IHBhZGRpbmdcclxuICAgICAgZGF0YVtvZmZzZXQgKyAyNF0gPSBkYXRhUGl2b3RbNl07XHJcbiAgICAgIGRhdGFbb2Zmc2V0ICsgMjVdID0gZGF0YVBpdm90WzddO1xyXG4gICAgICBkYXRhW29mZnNldCArIDI2XSA9IGRhdGFQaXZvdFs4XTtcclxuICAgICAgLy8gZGF0YVtvZmZzZXRQaXZvdCArIDI3XSA9IHBhZGRpbmdcclxuXHJcbiAgICAgIC8vIGNvbG9yXHJcbiAgICAgIGxldCBjb2xvcjogQ29sb3IgPSBfY21wTWF0ZXJpYWwuY2xyUHJpbWFyeTtcclxuICAgICAgZGF0YVtvZmZzZXQgKyAyOF0gPSBjb2xvci5yO1xyXG4gICAgICBkYXRhW29mZnNldCArIDI5XSA9IGNvbG9yLmc7XHJcbiAgICAgIGRhdGFbb2Zmc2V0ICsgMzBdID0gY29sb3IuYjtcclxuICAgICAgZGF0YVtvZmZzZXQgKyAzMV0gPSBjb2xvci5hO1xyXG5cclxuICAgICAgaWYgKF9jbXBQYXJ0aWNsZVN5c3RlbSkge1xyXG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMzJdID0gX2NtcFBhcnRpY2xlU3lzdGVtLmJsZW5kTW9kZTtcclxuICAgICAgICBkYXRhW29mZnNldCArIDMzXSA9IF9jbXBQYXJ0aWNsZVN5c3RlbS5kdXJhdGlvbjtcclxuICAgICAgICBkYXRhW29mZnNldCArIDM0XSA9IF9jbXBQYXJ0aWNsZVN5c3RlbS5zaXplO1xyXG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMzVdID0gX2NtcFBhcnRpY2xlU3lzdGVtLnRpbWU7XHJcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAzNl0gPSBfY21wRmFjZUNhbWVyYT8uaXNBY3RpdmUgPyAxIDogMDtcclxuICAgICAgICBkYXRhW29mZnNldCArIDM3XSA9IF9jbXBGYWNlQ2FtZXJhPy5yZXN0cmljdCA/IDEgOiAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIHVzZVJlbmRlckRhdGEoX25vZGU6IE5vZGUsIF9tdHhXb3JsZE92ZXJyaWRlPzogTWF0cml4NHg0KTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBsZXQgb2Zmc2V0OiBudW1iZXIgPSB0aGlzLm1hcE9iamVjdFRvT2Zmc2V0LmdldChfbm9kZSk7XHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlclJhbmdlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIHRoaXMuYmxvY2tCaW5kaW5nLCB0aGlzLmJ1ZmZlciwgb2Zmc2V0LCB0aGlzLmJsb2NrU2l6ZSk7XHJcblxyXG4gICAgICBpZiAoX210eFdvcmxkT3ZlcnJpZGUpIC8vIHRoaXMgaXMgcmVsYXRpdmVseSBzbG93LCBidXQgc2luY2UgcHJlcGFyZSBoYXMgbm8gY2FtZXJhIGluZm9ybWF0aW9uLCB3ZSBtYXkgbmVlZCB0byBvdmVycmlkZSB0aGUgd29ybGQgbWF0cml4IGhlcmVcclxuICAgICAgICBjcmMzLmJ1ZmZlclN1YkRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgb2Zmc2V0LCBfbXR4V29ybGRPdmVycmlkZS5nZXQoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEdpdmVzIFdlYkdMIEJ1ZmZlciB0aGUgZGF0YSBmcm9tIHRoZSB7QGxpbmsgU2hhZGVyfVxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvclNoYWRlciB7XHJcbiAgICAvKipcclxuICAgICAqIEluamVjdHMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhpcyBjbGFzcyBpbnRvIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZ2l2ZW4ge0BsaW5rIFNoYWRlcn0tc3ViY2xhc3NcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWNvcmF0ZShfY29uc3RydWN0b3I6IHR5cGVvZiBTaGFkZXIsIF9jb250ZXh0OiBDbGFzc0RlY29yYXRvckNvbnRleHQpOiB2b2lkIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3RvciwgX2NvbnN0cnVjdG9yLnVzZVByb2dyYW0ubmFtZSwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvclNoYWRlci51c2VQcm9ncmFtXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLCBfY29uc3RydWN0b3IuY3JlYXRlUHJvZ3JhbS5uYW1lLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yU2hhZGVyLmNyZWF0ZVByb2dyYW1cclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IsIF9jb25zdHJ1Y3Rvci5kZWxldGVQcm9ncmFtLm5hbWUsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JTaGFkZXIuZGVsZXRlUHJvZ3JhbVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGlzIHByb2dyYW0gdG8gdXNlIGFzIHRoZSBhY3RpdmUgcHJvZ3JhbSBpbiBXZWJHTFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHVzZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMucHJvZ3JhbSlcclxuICAgICAgICB0aGlzLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjcmMzLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhpcyBwcm9ncmFtIGZyb20gV2ViR0wsIGNsZWFyaW5nIHRoZSB1c2VkIG1lbW9yeSBvbiB0aGUgR1BVLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlbGV0ZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQge1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgaWYgKHRoaXMucHJvZ3JhbSkge1xyXG4gICAgICAgIGNyYzMuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnVuaWZvcm1zO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnByb2dyYW07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGNyZWF0ZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5mdWRnZShcIkNyZWF0ZSBzaGFkZXIgcHJvZ3JhbVwiLCB0aGlzLm5hbWUpO1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgbGV0IHByb2dyYW06IFdlYkdMUHJvZ3JhbSA9IGNyYzMuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsZXQgc2hkVmVydGV4OiBXZWJHTFNoYWRlciA9IGNvbXBpbGVTaGFkZXIodGhpcy5nZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5WRVJURVhfU0hBREVSKTtcclxuICAgICAgICBsZXQgc2hkRnJhZ21lbnQ6IFdlYkdMU2hhZGVyID0gY29tcGlsZVNoYWRlcih0aGlzLmdldEZyYWdtZW50U2hhZGVyU291cmNlKCksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBR01FTlRfU0hBREVSKTtcclxuXHJcbiAgICAgICAgY3JjMy5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMU2hhZGVyPihzaGRWZXJ0ZXgpKTtcclxuICAgICAgICBjcmMzLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xTaGFkZXI+KHNoZEZyYWdtZW50KSk7XHJcbiAgICAgICAgY3JjMy5saW5rUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcbiAgICAgICAgbGV0IGVycm9yOiBzdHJpbmcgPSBSZW5kZXJXZWJHTC5hc3NlcnQ8c3RyaW5nPihjcmMzLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcclxuICAgICAgICBpZiAoZXJyb3IgIT09IFwiXCIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGxpbmtpbmcgU2hhZGVyOiBcIiArIGVycm9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XHJcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IGRldGVjdFVuaWZvcm1zKCk7XHJcblxyXG4gICAgICAgIGJpbmRVbmlmb3JtQmxvY2socHJvZ3JhbSwgVU5JRk9STV9CTE9DSy5MSUdIVFMuTkFNRSwgVU5JRk9STV9CTE9DSy5MSUdIVFMuQklORElORyk7XHJcbiAgICAgICAgYmluZFVuaWZvcm1CbG9jayhwcm9ncmFtLCBVTklGT1JNX0JMT0NLLkNBTUVSQS5OQU1FLCBVTklGT1JNX0JMT0NLLkNBTUVSQS5CSU5ESU5HKTtcclxuICAgICAgICBiaW5kVW5pZm9ybUJsb2NrKHByb2dyYW0sIFVOSUZPUk1fQkxPQ0suTUFURVJJQUwuTkFNRSwgVU5JRk9STV9CTE9DSy5NQVRFUklBTC5CSU5ESU5HKTtcclxuICAgICAgICBiaW5kVW5pZm9ybUJsb2NrKHByb2dyYW0sIFVOSUZPUk1fQkxPQ0suTk9ERS5OQU1FLCBVTklGT1JNX0JMT0NLLk5PREUuQklORElORyk7XHJcbiAgICAgICAgYmluZFVuaWZvcm1CbG9jayhwcm9ncmFtLCBVTklGT1JNX0JMT0NLLlNLSU4uTkFNRSwgVU5JRk9STV9CTE9DSy5TS0lOLkJJTkRJTkcpO1xyXG4gICAgICAgIGJpbmRVbmlmb3JtQmxvY2socHJvZ3JhbSwgVU5JRk9STV9CTE9DSy5GT0cuTkFNRSwgVU5JRk9STV9CTE9DSy5GT0cuQklORElORyk7XHJcblxyXG4gICAgICAgIGNyYzMudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIGxldCB1bmlmb3JtOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IHRoaXMudW5pZm9ybXNbVEVYVFVSRV9MT0NBVElPTi5DT0xPUi5VTklGT1JNXTtcclxuICAgICAgICBpZiAodW5pZm9ybSlcclxuICAgICAgICAgIGNyYzMudW5pZm9ybTFpKHVuaWZvcm0sIFRFWFRVUkVfTE9DQVRJT04uQ09MT1IuSU5ERVgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW1RFWFRVUkVfTE9DQVRJT04uTk9STUFMLlVOSUZPUk1dO1xyXG4gICAgICAgIGlmICh1bmlmb3JtKVxyXG4gICAgICAgICAgY3JjMy51bmlmb3JtMWkodW5pZm9ybSwgVEVYVFVSRV9MT0NBVElPTi5OT1JNQUwuSU5ERVgpO1xyXG5cclxuICAgICAgICB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1tURVhUVVJFX0xPQ0FUSU9OLlRPT04uVU5JRk9STV07XHJcbiAgICAgICAgaWYgKHVuaWZvcm0pXHJcbiAgICAgICAgICBjcmMzLnVuaWZvcm0xaSh1bmlmb3JtLCBURVhUVVJFX0xPQ0FUSU9OLlRPT04uSU5ERVgpO1xyXG5cclxuICAgICAgICB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1tURVhUVVJFX0xPQ0FUSU9OLlBBUlRJQ0xFLlVOSUZPUk1dO1xyXG4gICAgICAgIGlmICh1bmlmb3JtKVxyXG4gICAgICAgICAgY3JjMy51bmlmb3JtMWkodW5pZm9ybSwgVEVYVFVSRV9MT0NBVElPTi5QQVJUSUNMRS5JTkRFWCk7XHJcblxyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICBEZWJ1Zy5lcnJvcihfZXJyb3IpO1xyXG4gICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21waWxlU2hhZGVyKF9zaGFkZXJDb2RlOiBzdHJpbmcsIF9zaGFkZXJUeXBlOiBHTGVudW0pOiBXZWJHTFNoYWRlciB8IG51bGwge1xyXG4gICAgICAgIGxldCB3ZWJHTFNoYWRlcjogV2ViR0xTaGFkZXIgPSBjcmMzLmNyZWF0ZVNoYWRlcihfc2hhZGVyVHlwZSk7XHJcbiAgICAgICAgY3JjMy5zaGFkZXJTb3VyY2Uod2ViR0xTaGFkZXIsIF9zaGFkZXJDb2RlKTtcclxuICAgICAgICBjcmMzLmNvbXBpbGVTaGFkZXIod2ViR0xTaGFkZXIpO1xyXG4gICAgICAgIGxldCBlcnJvcjogc3RyaW5nID0gUmVuZGVyV2ViR0wuYXNzZXJ0PHN0cmluZz4oY3JjMy5nZXRTaGFkZXJJbmZvTG9nKHdlYkdMU2hhZGVyKSk7XHJcbiAgICAgICAgaWYgKGVycm9yICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICBEZWJ1Zy5sb2coX3NoYWRlckNvZGUpO1xyXG5cclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGNvbXBpbGluZyBzaGFkZXI6IFwiICsgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBmb3IgYW55IGNvbXBpbGF0aW9uIGVycm9ycy5cclxuICAgICAgICBpZiAoIWNyYzMuZ2V0U2hhZGVyUGFyYW1ldGVyKHdlYkdMU2hhZGVyLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNPTVBJTEVfU1RBVFVTKSkge1xyXG4gICAgICAgICAgYWxlcnQoY3JjMy5nZXRTaGFkZXJJbmZvTG9nKHdlYkdMU2hhZGVyKSk7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdlYkdMU2hhZGVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBkZXRlY3RVbmlmb3JtcygpOiB7IFtuYW1lOiBzdHJpbmddOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB9IHtcclxuICAgICAgICBsZXQgZGV0ZWN0ZWRVbmlmb3JtczogeyBbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfSA9IHt9O1xyXG4gICAgICAgIGxldCB1bmlmb3JtQ291bnQ6IG51bWJlciA9IGNyYzMuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFDVElWRV9VTklGT1JNUyk7XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHVuaWZvcm1Db3VudDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgaW5mbzogV2ViR0xBY3RpdmVJbmZvID0gUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMQWN0aXZlSW5mbz4oY3JjMy5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpKTtcclxuICAgICAgICAgIGlmICghaW5mbykge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxldCBsb2NhdGlvbjogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBjcmMzLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBpbmZvLm5hbWUpO1xyXG4gICAgICAgICAgaWYgKGxvY2F0aW9uKVxyXG4gICAgICAgICAgICBkZXRlY3RlZFVuaWZvcm1zW2luZm8ubmFtZV0gPSBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xVbmlmb3JtTG9jYXRpb24+KGxvY2F0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRldGVjdGVkVW5pZm9ybXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGJpbmRVbmlmb3JtQmxvY2soX3Byb2dyYW06IFdlYkdMUHJvZ3JhbSwgX3VuaWZvcm1CbG9ja05hbWU6IHN0cmluZywgX3VuaWZvcm1CbG9ja0JpbmRpbmc6IEdMdWludCk6IHZvaWQge1xyXG4gICAgICAgIGxldCBibG9ja0luZGV4OiBudW1iZXIgPSBjcmMzLmdldFVuaWZvcm1CbG9ja0luZGV4KF9wcm9ncmFtLCBfdW5pZm9ybUJsb2NrTmFtZSk7XHJcbiAgICAgICAgaWYgKGJsb2NrSW5kZXggPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5JTlZBTElEX0lOREVYKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgcmVmZXJlbmNlZEJ5VmVydGV4U2hhZGVyOiBib29sZWFuID0gY3JjMy5nZXRBY3RpdmVVbmlmb3JtQmxvY2tQYXJhbWV0ZXIoX3Byb2dyYW0sIGJsb2NrSW5kZXgsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CTE9DS19SRUZFUkVOQ0VEX0JZX1ZFUlRFWF9TSEFERVIpO1xyXG4gICAgICAgIGxldCByZWZlcmVuY2VkQnlGcmFnbWVudFNoYWRlcjogYm9vbGVhbiA9IGNyYzMuZ2V0QWN0aXZlVW5pZm9ybUJsb2NrUGFyYW1ldGVyKF9wcm9ncmFtLCBibG9ja0luZGV4LCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQkxPQ0tfUkVGRVJFTkNFRF9CWV9GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgICAgIGlmICghcmVmZXJlbmNlZEJ5VmVydGV4U2hhZGVyICYmICFyZWZlcmVuY2VkQnlGcmFnbWVudFNoYWRlcilcclxuICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgY3JjMy51bmlmb3JtQmxvY2tCaW5kaW5nKF9wcm9ncmFtLCBibG9ja0luZGV4LCBfdW5pZm9ybUJsb2NrQmluZGluZyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQnVmZmVycyB0aGUgZGF0YSBmcm9tIHRoZSB7QGxpbmsgTWVzaH0gaW50byBhIFdlYkdMIEJ1ZmZlclxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3Rvck1lc2gge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbmplY3RzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIHRoaXMgY2xhc3MgaW50byB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGdpdmVuIHtAbGluayBNZXNofS1zdWJjbGFzc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogdHlwZW9mIE1lc2gsIF9jb250ZXh0OiBDbGFzc0RlY29yYXRvckNvbnRleHQpOiB2b2lkIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUudXNlUmVuZGVyQnVmZmVycy5uYW1lLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yTWVzaC51c2VSZW5kZXJCdWZmZXJzXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgX2NvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRSZW5kZXJCdWZmZXJzLm5hbWUsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JNZXNoLmdldFJlbmRlckJ1ZmZlcnNcclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBfY29uc3RydWN0b3IucHJvdG90eXBlLmRlbGV0ZVJlbmRlckJ1ZmZlcnMubmFtZSwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3Rvck1lc2guZGVsZXRlUmVuZGVyQnVmZmVyc1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGdldFJlbmRlckJ1ZmZlcnModGhpczogTWVzaCk6IFJlbmRlckJ1ZmZlcnMge1xyXG4gICAgICBsZXQgYnVmZmVyczogUmVuZGVyQnVmZmVycyA9IHRoaXMucmVuZGVyTWVzaC5idWZmZXJzO1xyXG4gICAgICBpZiAoYnVmZmVycylcclxuICAgICAgICByZXR1cm4gYnVmZmVycztcclxuXHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGNvbnN0IHZhbzogV2ViR0xWZXJ0ZXhBcnJheU9iamVjdCA9IFJlbmRlcldlYkdMLmFzc2VydDxXZWJHTFZlcnRleEFycmF5T2JqZWN0PihjcmMzLmNyZWF0ZVZlcnRleEFycmF5KCkpO1xyXG4gICAgICBjcmMzLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xyXG5cclxuICAgICAgYnVmZmVycyA9IHtcclxuICAgICAgICBpbmRpY2VzOiBjcmVhdGVCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJNZXNoLmluZGljZXMpLFxyXG4gICAgICAgIHBvc2l0aW9uczogY3JlYXRlQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlck1lc2gucG9zaXRpb25zKSxcclxuICAgICAgICBub3JtYWxzOiBjcmVhdGVCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMucmVuZGVyTWVzaC5ub3JtYWxzKSxcclxuICAgICAgICB0ZXh0dXJlVVZzOiBjcmVhdGVCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMucmVuZGVyTWVzaC50ZXh0dXJlVVZzKSxcclxuICAgICAgICBjb2xvcnM6IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJNZXNoLmNvbG9ycyksXHJcbiAgICAgICAgdGFuZ2VudHM6IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJNZXNoLnRhbmdlbnRzKSxcclxuICAgICAgICBuSW5kaWNlczogdGhpcy5yZW5kZXJNZXNoLmluZGljZXMubGVuZ3RoLFxyXG4gICAgICAgIHZhbzogdmFvXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAodGhpcy5yZW5kZXJNZXNoLmJvbmVzKVxyXG4gICAgICAgIGJ1ZmZlcnMuYm9uZXMgPSBjcmVhdGVCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMucmVuZGVyTWVzaC5ib25lcyk7XHJcblxyXG4gICAgICBpZiAodGhpcy5yZW5kZXJNZXNoLndlaWdodHMpXHJcbiAgICAgICAgYnVmZmVycy53ZWlnaHRzID0gY3JlYXRlQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlck1lc2gud2VpZ2h0cyk7XHJcblxyXG4gICAgICBzZXRBdHRyaWJ1dGVCdWZmZXIoYnVmZmVycy5wb3NpdGlvbnMsIFNIQURFUl9BVFRSSUJVVEUuUE9TSVRJT04sIDMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRkxPQVQpO1xyXG4gICAgICBzZXRBdHRyaWJ1dGVCdWZmZXIoYnVmZmVycy5ub3JtYWxzLCBTSEFERVJfQVRUUklCVVRFLk5PUk1BTCwgMywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCk7XHJcbiAgICAgIHNldEF0dHJpYnV0ZUJ1ZmZlcihidWZmZXJzLnRleHR1cmVVVnMsIFNIQURFUl9BVFRSSUJVVEUuVEVYQ09PUkRTLCAyLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FUKTtcclxuICAgICAgc2V0QXR0cmlidXRlQnVmZmVyKGJ1ZmZlcnMuY29sb3JzLCBTSEFERVJfQVRUUklCVVRFLkNPTE9SLCA0LCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FUKTtcclxuICAgICAgc2V0QXR0cmlidXRlQnVmZmVyKGJ1ZmZlcnMudGFuZ2VudHMsIFNIQURFUl9BVFRSSUJVVEUuVEFOR0VOVCwgNCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCk7XHJcbiAgICAgIGlmIChidWZmZXJzLmJvbmVzKVxyXG4gICAgICAgIHNldEF0dHJpYnV0ZUJ1ZmZlcihidWZmZXJzLmJvbmVzLCBTSEFERVJfQVRUUklCVVRFLkJPTkVTLCA0LCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0JZVEUpO1xyXG4gICAgICBpZiAoYnVmZmVycy53ZWlnaHRzKVxyXG4gICAgICAgIHNldEF0dHJpYnV0ZUJ1ZmZlcihidWZmZXJzLndlaWdodHMsIFNIQURFUl9BVFRSSUJVVEUuV0VJR0hUUywgNCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJNZXNoLmJ1ZmZlcnMgPSBidWZmZXJzO1xyXG5cclxuICAgICAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyKF90eXBlOiBHTGVudW0sIF9hcnJheTogRmxvYXQzMkFycmF5IHwgVWludDE2QXJyYXkgfCBVaW50OEFycmF5KTogV2ViR0xCdWZmZXIge1xyXG4gICAgICAgIGxldCBidWZmZXI6IFdlYkdMQnVmZmVyID0gUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMQnVmZmVyPihjcmMzLmNyZWF0ZUJ1ZmZlcigpKTtcclxuICAgICAgICBjcmMzLmJpbmRCdWZmZXIoX3R5cGUsIGJ1ZmZlcik7XHJcbiAgICAgICAgY3JjMy5idWZmZXJEYXRhKF90eXBlLCBfYXJyYXksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHNldEF0dHJpYnV0ZUJ1ZmZlcihfYnVmZmVyOiBXZWJHTEJ1ZmZlciwgX2xvY2F0aW9uOiBudW1iZXIsIF9zaXplOiBudW1iZXIsIF90eXBlOiBHTGVudW0pOiB2b2lkIHtcclxuICAgICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIF9idWZmZXIpO1xyXG4gICAgICAgIGNyYzMuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoX2xvY2F0aW9uKTtcclxuICAgICAgICBpZiAoX3R5cGUgPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVClcclxuICAgICAgICAgIGNyYzMudmVydGV4QXR0cmliUG9pbnRlcihfbG9jYXRpb24sIF9zaXplLCBfdHlwZSwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgIGlmIChfdHlwZSA9PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0JZVEUpXHJcbiAgICAgICAgICBjcmMzLnZlcnRleEF0dHJpYklQb2ludGVyKF9sb2NhdGlvbiwgX3NpemUsIF90eXBlLCAwLCAwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgdXNlUmVuZGVyQnVmZmVycyh0aGlzOiBNZXNoKTogUmVuZGVyQnVmZmVycyB7XHJcbiAgICAgIGNvbnN0IGJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMgPSB0aGlzLmdldFJlbmRlckJ1ZmZlcnMoKTtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgY3JjMy5iaW5kVmVydGV4QXJyYXkoYnVmZmVycy52YW8pO1xyXG4gICAgICByZXR1cm4gYnVmZmVycztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlbGV0ZVJlbmRlckJ1ZmZlcnMoX3JlbmRlckJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMpOiB2b2lkIHtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGlmIChfcmVuZGVyQnVmZmVycykge1xyXG4gICAgICAgIGNyYzMuZGVsZXRlVmVydGV4QXJyYXkoX3JlbmRlckJ1ZmZlcnMudmFvKTtcclxuICAgICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICBPYmplY3QudmFsdWVzKF9yZW5kZXJCdWZmZXJzKVxyXG4gICAgICAgICAgLmZpbHRlcihfdmFsdWUgPT4gX3ZhbHVlIGluc3RhbmNlb2YgV2ViR0xCdWZmZXIpXHJcbiAgICAgICAgICAuZm9yRWFjaChfYnVmZmVyID0+IGNyYzMuZGVsZXRlQnVmZmVyKF9idWZmZXIpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIGV4cG9ydCBuYW1lc3BhY2UgUGFydGljbGVEYXRhIHtcclxuXHJcbiAgICBleHBvcnQgZW51bSBGVU5DVElPTiB7XHJcbiAgICAgIC8vIFZBTFVFID0gXCJ2YWx1ZVwiLFxyXG4gICAgICBBRERJVElPTiA9IFwiYWRkaXRpb25cIixcclxuICAgICAgU1VCVFJBQ1RJT04gPSBcInN1YnRyYWN0aW9uXCIsXHJcbiAgICAgIE1VTFRJUExJQ0FUSU9OID0gXCJtdWx0aXBsaWNhdGlvblwiLFxyXG4gICAgICBESVZJU0lPTiA9IFwiZGl2aXNpb25cIixcclxuICAgICAgTU9EVUxPID0gXCJtb2R1bG9cIixcclxuICAgICAgUE9XRVIgPSBcInBvd2VyXCIsXHJcbiAgICAgIFBPTFlOT01JQUwzID0gXCJwb2x5bm9taWFsM1wiLFxyXG4gICAgICBTUVVBUkVfUk9PVCA9IFwic3F1YXJlUm9vdFwiLFxyXG4gICAgICBSQU5ET00gPSBcInJhbmRvbVwiLFxyXG4gICAgICBSQU5ET01fUkFOR0UgPSBcInJhbmRvbVJhbmdlXCJcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgY29uc3QgRlVOQ1RJT05fTUlOSU1VTV9QQVJBTUVURVJTOiB7IFtrZXkgaW4gUGFydGljbGVEYXRhLkZVTkNUSU9OXTogbnVtYmVyIH0gPSB7XHJcbiAgICAgIC8vIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uVkFMVUVdOiAxLFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLkFERElUSU9OXTogMixcclxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5TVUJUUkFDVElPTl06IDIsXHJcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uTVVMVElQTElDQVRJT05dOiAyLFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLkRJVklTSU9OXTogMixcclxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5NT0RVTE9dOiAyLFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlBPV0VSXTogMixcclxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5QT0xZTk9NSUFMM106IDUsXHJcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uU1FVQVJFX1JPT1RdOiAxLFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlJBTkRPTV06IDAsXHJcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uUkFORE9NX1JBTkdFXTogMlxyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnQgY29uc3QgUFJFREVGSU5FRF9WQVJJQUJMRVM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XHJcbiAgICAgIHN5c3RlbUR1cmF0aW9uOiBcInVfZlBhcnRpY2xlU3lzdGVtRHVyYXRpb25cIixcclxuICAgICAgc3lzdGVtU2l6ZTogXCJ1X2ZQYXJ0aWNsZVN5c3RlbVNpemVcIixcclxuICAgICAgc3lzdGVtVGltZTogXCJ1X2ZQYXJ0aWNsZVN5c3RlbVRpbWVcIixcclxuICAgICAgcGFydGljbGVJZDogXCJmUGFydGljbGVJZFwiXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGlsZXMgcGFydGljbGUgc3lzdGVtIHNoYWRlcnMgKHtAbGluayBTaGFkZXJQYXJ0aWNsZVN5c3RlbX0pIGZyb20gc2hhZGVyIHVuaXZlcnNhbCBkZXJpdmF0ZXMgZm9yIFdlYkdMXHJcbiAgICogQGF1dGhvcnMgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIyXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0ge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBGVU5DVElPTlM6IHsgW2tleSBpbiBQYXJ0aWNsZURhdGEuRlVOQ1RJT05dOiBGdW5jdGlvbiB9ID0ge1xyXG4gICAgICAvLyBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlZBTFVFXTogKF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgICAvLyAgIHJldHVybiBgKCR7X3BhcmFtZXRlcnNbMF19KWA7XHJcbiAgICAgIC8vIH0sXHJcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uQURESVRJT05dOiAoX3BhcmFtZXRlcnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGAoJHtfcGFyYW1ldGVycy5yZWR1Y2UoKF9hY2N1bXVsYXRvcjogc3RyaW5nLCBfdmFsdWU6IHN0cmluZykgPT4gYCR7X2FjY3VtdWxhdG9yfSArICR7X3ZhbHVlfWApfSlgO1xyXG4gICAgICB9LFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlNVQlRSQUNUSU9OXTogKF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBgKCR7X3BhcmFtZXRlcnMucmVkdWNlKChfYWNjdW11bGF0b3I6IHN0cmluZywgX3ZhbHVlOiBzdHJpbmcpID0+IGAke19hY2N1bXVsYXRvcn0gLSAke192YWx1ZX1gKX0pYDtcclxuICAgICAgfSxcclxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5NVUxUSVBMSUNBVElPTl06IChfcGFyYW1ldGVyczogc3RyaW5nW10pID0+IHtcclxuICAgICAgICByZXR1cm4gYCgke19wYXJhbWV0ZXJzLnJlZHVjZSgoX2FjY3VtdWxhdG9yOiBzdHJpbmcsIF92YWx1ZTogc3RyaW5nKSA9PiBgJHtfYWNjdW11bGF0b3J9ICogJHtfdmFsdWV9YCl9KWA7XHJcbiAgICAgIH0sXHJcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uRElWSVNJT05dOiAoX3BhcmFtZXRlcnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGAoJHtfcGFyYW1ldGVyc1swXX0gLyAke19wYXJhbWV0ZXJzWzFdfSlgO1xyXG4gICAgICB9LFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLk1PRFVMT106IChfcGFyYW1ldGVyczogc3RyaW5nW10pID0+IHtcclxuICAgICAgICByZXR1cm4gYCgke19wYXJhbWV0ZXJzLnJlZHVjZSgoX2FjY3VtdWxhdG9yOiBzdHJpbmcsIF92YWx1ZTogc3RyaW5nKSA9PiBgbW9kKCR7X2FjY3VtdWxhdG9yfSwgJHtfdmFsdWV9KWApfSlgO1xyXG4gICAgICB9LFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlBPV0VSXTogKF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBgcG93KCR7X3BhcmFtZXRlcnNbMF19LCAke19wYXJhbWV0ZXJzWzFdfSlgO1xyXG4gICAgICB9LFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlBPTFlOT01JQUwzXTogKF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgICAgIGxldCB4OiBzdHJpbmcgPSBfcGFyYW1ldGVyc1swXTtcclxuICAgICAgICBsZXQgYTogc3RyaW5nID0gX3BhcmFtZXRlcnNbMV07XHJcbiAgICAgICAgbGV0IGI6IHN0cmluZyA9IF9wYXJhbWV0ZXJzWzJdO1xyXG4gICAgICAgIGxldCBjOiBzdHJpbmcgPSBfcGFyYW1ldGVyc1szXTtcclxuICAgICAgICBsZXQgZDogc3RyaW5nID0gX3BhcmFtZXRlcnNbNF07XHJcbiAgICAgICAgcmV0dXJuIGAoJHthfSAqIHBvdygke3h9LCAzLjApICsgJHtifSAqIHBvdygke3h9LCAyLjApICsgJHtjfSAqICR7eH0gKyAke2R9KWA7XHJcbiAgICAgIH0sXHJcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uU1FVQVJFX1JPT1RdOiAoX3BhcmFtZXRlcnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgbGV0IHg6IHN0cmluZyA9IF9wYXJhbWV0ZXJzWzBdO1xyXG4gICAgICAgIHJldHVybiBgc3FydCgke3h9KWA7XHJcbiAgICAgIH0sXHJcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uUkFORE9NXTogKF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBgZmV0Y2hSYW5kb21OdW1iZXIoJHsoUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5yYW5kb21OdW1iZXJJbmRleE9mZnNldCsrKS50b0ZpeGVkKDApfSwgaVBhcnRpY2xlU3lzdGVtUmFuZG9tTnVtYmVyc1NpemUsIGlQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNMZW5ndGgpYDtcclxuICAgICAgfSxcclxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5SQU5ET01fUkFOR0VdOiAoX3BhcmFtZXRlcnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGAoJHtSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLkZVTkNUSU9OU1tcInJhbmRvbVwiXSgpfSAqICgke19wYXJhbWV0ZXJzWzFdfSAtICR7X3BhcmFtZXRlcnNbMF19KSArICR7X3BhcmFtZXRlcnNbMF19KWA7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmFuZG9tTnVtYmVySW5kZXhPZmZzZXQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWNvcmF0ZShfY29uc3RydWN0b3I6IHR5cGVvZiBTaGFkZXJQYXJ0aWNsZVN5c3RlbSwgX2NvbnRleHQ6IENsYXNzRGVjb3JhdG9yQ29udGV4dCk6IHZvaWQge1xyXG4gICAgICBSZW5kZXJJbmplY3RvclNoYWRlci5kZWNvcmF0ZSg8dHlwZW9mIFNoYWRlcj48R2VuZXJhbD5fY29uc3RydWN0b3IucHJvdG90eXBlLCBfY29udGV4dCk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBfY29uc3RydWN0b3IucHJvdG90eXBlLmdldFZlcnRleFNoYWRlclNvdXJjZS5uYW1lLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2V0VmVydGV4U2hhZGVyU291cmNlXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgX2NvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRGcmFnbWVudFNoYWRlclNvdXJjZS5uYW1lLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2VcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIHNvdXJjZSBjb2RlIGZvciB0aGUgdmVydGV4IHNoYWRlciBvZiB0aGUge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtfSBmcm9tIHRoZSBzZXQge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtLmRhdGF9IGFuZCB0aGUgb3JpZ2luYWwge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtLnZlcnRleFNoYWRlclNvdXJjZX0uXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKHRoaXM6IFNoYWRlclBhcnRpY2xlU3lzdGVtKTogc3RyaW5nIHtcclxuICAgICAgbGV0IGRhdGE6IFBhcnRpY2xlRGF0YS5TeXN0ZW0gPSB0aGlzLmRhdGE7XHJcbiAgICAgIGxldCBtdHhMb2NhbDogUGFydGljbGVEYXRhLlRyYW5zZm9ybWF0aW9uW10gPSBkYXRhPy5tdHhMb2NhbDtcclxuICAgICAgbGV0IG10eFdvcmxkOiBQYXJ0aWNsZURhdGEuVHJhbnNmb3JtYXRpb25bXSA9IGRhdGE/Lm10eFdvcmxkO1xyXG5cclxuICAgICAgUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5yYW5kb21OdW1iZXJJbmRleE9mZnNldCA9IDA7XHJcblxyXG4gICAgICBsZXQgc291cmNlOiBzdHJpbmcgPSB0aGlzLnZlcnRleFNoYWRlclNvdXJjZVxyXG4gICAgICAgIC5yZXBsYWNlKFwiI3ZlcnNpb24gMzAwIGVzXCIsIGAjdmVyc2lvbiAzMDAgZXNcXG4jZGVmaW5lICR7dGhpcy5kZWZpbmVbMF19JHtkYXRhLmNvbG9yID8gXCJcXG4jZGVmaW5lIFBBUlRJQ0xFX0NPTE9SXCIgOiBcIlwifWApXHJcbiAgICAgICAgLnJlcGxhY2UoXCIvKiR2YXJpYWJsZXMqL1wiLCBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLmdlbmVyYXRlVmFyaWFibGVzKGRhdGE/LnZhcmlhYmxlcywgZGF0YT8udmFyaWFibGVOYW1lcykpXHJcbiAgICAgICAgLnJlcGxhY2UoXCIvKiRtdHhMb2NhbCovXCIsIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2VuZXJhdGVUcmFuc2Zvcm1hdGlvbnMobXR4TG9jYWwsIFwiTG9jYWxcIikpXHJcbiAgICAgICAgLnJlcGxhY2UoXCIvKiRtdHhMb2NhbCovXCIsIG10eExvY2FsICYmIG10eExvY2FsLmxlbmd0aCA+IDAgPyBcIiogbXR4TG9jYWxcIiA6IFwiXCIpXHJcbiAgICAgICAgLnJlcGxhY2UoXCIvKiRtdHhXb3JsZCovXCIsIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2VuZXJhdGVUcmFuc2Zvcm1hdGlvbnMobXR4V29ybGQsIFwiV29ybGRcIikpXHJcbiAgICAgICAgLnJlcGxhY2UoXCIvKiRtdHhXb3JsZCovXCIsIG10eFdvcmxkICYmIG10eFdvcmxkLmxlbmd0aCA+IDAgPyBcIm10eFdvcmxkICpcIiA6IFwiXCIpXHJcbiAgICAgICAgLnJlcGxhY2VBbGwoXCIvKiRjb2xvciovXCIsIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2VuZXJhdGVDb2xvcihkYXRhPy5jb2xvcikpO1xyXG4gICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHRoZSBzb3VyY2UgY29kZSBmb3IgdGhlIGZyYWdtZW50IHNoYWRlciBvZiB0aGUge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtfSBmcm9tIHRoZSBzZXQge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtLmRhdGF9IGFuZCB0aGUgb3JpZ2luYWwge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtLmZyYWdtZW50U2hhZGVyU291cmNlfS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSh0aGlzOiBTaGFkZXJQYXJ0aWNsZVN5c3RlbSk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50U2hhZGVyU291cmNlLnJlcGxhY2UoXCIjdmVyc2lvbiAzMDAgZXNcIiwgYCN2ZXJzaW9uIDMwMCBlc1xcbiNkZWZpbmUgJHt0aGlzLmRlZmluZVswXX0ke3RoaXMuZGF0YS5jb2xvciA/IFwiXFxuI2RlZmluZSBQQVJUSUNMRV9DT0xPUlwiIDogXCJcIn1gKVxyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBjb2RlIGdlbmVyYXRpb25cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZVZhcmlhYmxlcyhfdmFyaWFibGVzOiBQYXJ0aWNsZURhdGEuU3lzdGVtW1widmFyaWFibGVzXCJdLCBfdmFyaWFibGVOYW1lczogUGFydGljbGVEYXRhLlN5c3RlbVtcInZhcmlhYmxlTmFtZXNcIl0pOiBzdHJpbmcge1xyXG4gICAgICBpZiAoIV92YXJpYWJsZXMpIHJldHVybiBcIlwiO1xyXG5cclxuICAgICAgcmV0dXJuIF92YXJpYWJsZXNcclxuICAgICAgICAubWFwKChfdmFyaWFibGUsIF9pbmRleCkgPT4gKHsgbmFtZTogXCJmUGFydGljbGVTeXN0ZW1WYXJpYWJsZV9cIiArIF92YXJpYWJsZU5hbWVzW19pbmRleF0sIHZhbHVlOiBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLmdlbmVyYXRlRXhwcmVzc2lvbihfdmFyaWFibGUpIH0pKVxyXG4gICAgICAgIC5tYXAoX3ZhcmlhYmxlID0+IGBmbG9hdCAke192YXJpYWJsZS5uYW1lfSA9ICR7X3ZhcmlhYmxlLnZhbHVlfTtgKVxyXG4gICAgICAgIC5yZWR1Y2UoKF9hY2N1bXVsYXRvcjogc3RyaW5nLCBfY29kZTogc3RyaW5nKSA9PiBgJHtfYWNjdW11bGF0b3J9XFxuJHtfY29kZX1gLCBcIlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZVRyYW5zZm9ybWF0aW9ucyhfdHJhbnNmb3JtYXRpb25zOiBQYXJ0aWNsZURhdGEuU3lzdGVtW1wibXR4TG9jYWxcIl0sIF9sb2NhbE9yV29ybGQ6IFwiTG9jYWxcIiB8IFwiV29ybGRcIik6IHN0cmluZyB7XHJcbiAgICAgIGlmICghX3RyYW5zZm9ybWF0aW9ucyB8fCBfdHJhbnNmb3JtYXRpb25zLmxlbmd0aCA9PSAwKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAgIGxldCB0cmFuc2Zvcm1hdGlvbnM6IFtQYXJ0aWNsZURhdGEuVHJhbnNmb3JtYXRpb25bXCJ0cmFuc2Zvcm1hdGlvblwiXSwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZ11bXSA9IF90cmFuc2Zvcm1hdGlvbnNcclxuICAgICAgICAubWFwKF9kYXRhID0+IHtcclxuICAgICAgICAgIGxldCBpc1NjYWxlOiBib29sZWFuID0gX2RhdGEudHJhbnNmb3JtYXRpb24gPT09IFwic2NhbGVcIjtcclxuICAgICAgICAgIGxldCBbeCwgeSwgel0gPSBbX2RhdGEucGFyYW1ldGVyc1swXSwgX2RhdGEucGFyYW1ldGVyc1sxXSwgX2RhdGEucGFyYW1ldGVyc1syXV1cclxuICAgICAgICAgICAgLm1hcCgoX3ZhbHVlKSA9PiBfdmFsdWUgPyBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLmdlbmVyYXRlRXhwcmVzc2lvbihfdmFsdWUpIDogKGlzU2NhbGUgPyBcIjEuMFwiIDogXCIwLjBcIikpIGFzIFtzdHJpbmcsIHN0cmluZywgc3RyaW5nXTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gW19kYXRhLnRyYW5zZm9ybWF0aW9uLCB4LCB5LCB6XTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIGxldCBjb2RlOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICBjb2RlICs9IHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgICAgIC5tYXAoKFtfdHJhbnNmb3JtYXRpb24sIF94LCBfeSwgX3pdLCBfaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgbGV0IHJvdGF0ZUlkOiBzdHJpbmcgPSBfaW5kZXggKyBfbG9jYWxPcldvcmxkO1xyXG4gICAgICAgICAgaWYgKF90cmFuc2Zvcm1hdGlvbiA9PSBcInJvdGF0ZVwiKSB7XHJcbiAgICAgICAgICAgIGxldCB0b1JhZGlhbnM6IChfdmFsdWU6IHN0cmluZykgPT4gc3RyaW5nID0gKF92YWx1ZTogc3RyaW5nKSA9PiBgJHtfdmFsdWV9ICogJHtDYWxjLmRlZzJyYWR9YDtcclxuICAgICAgICAgICAgcmV0dXJuIGBmbG9hdCBmWFJhZGlhbnMke3JvdGF0ZUlkfSA9ICR7dG9SYWRpYW5zKF94KX07XHJcbiAgICAgICAgICAgICAgZmxvYXQgZllSYWRpYW5zJHtyb3RhdGVJZH0gPSAke3RvUmFkaWFucyhfeSl9O1xyXG4gICAgICAgICAgICAgIGZsb2F0IGZaUmFkaWFucyR7cm90YXRlSWR9ID0gJHt0b1JhZGlhbnMoX3opfTtcclxuICAgICAgICAgICAgICBmbG9hdCBmU2luWCR7cm90YXRlSWR9ID0gc2luKGZYUmFkaWFucyR7cm90YXRlSWR9KTtcclxuICAgICAgICAgICAgICBmbG9hdCBmQ29zWCR7cm90YXRlSWR9ID0gY29zKGZYUmFkaWFucyR7cm90YXRlSWR9KTsgXHJcbiAgICAgICAgICAgICAgZmxvYXQgZlNpblkke3JvdGF0ZUlkfSA9IHNpbihmWVJhZGlhbnMke3JvdGF0ZUlkfSk7XHJcbiAgICAgICAgICAgICAgZmxvYXQgZkNvc1kke3JvdGF0ZUlkfSA9IGNvcyhmWVJhZGlhbnMke3JvdGF0ZUlkfSk7XHJcbiAgICAgICAgICAgICAgZmxvYXQgZlNpbloke3JvdGF0ZUlkfSA9IHNpbihmWlJhZGlhbnMke3JvdGF0ZUlkfSk7XHJcbiAgICAgICAgICAgICAgZmxvYXQgZkNvc1oke3JvdGF0ZUlkfSA9IGNvcyhmWlJhZGlhbnMke3JvdGF0ZUlkfSk7XFxuYDtcclxuICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5maWx0ZXIoKF90cmFuc2Zvcm1hdGlvbjogc3RyaW5nKSA9PiBfdHJhbnNmb3JtYXRpb24gIT0gXCJcIilcclxuICAgICAgICAucmVkdWNlKChfYWNjdW11bGF0b3I6IHN0cmluZywgX2NvZGU6IHN0cmluZykgPT4gYCR7X2FjY3VtdWxhdG9yfVxcbiR7X2NvZGV9YCwgXCJcIik7XHJcbiAgICAgIGNvZGUgKz0gXCJcXG5cIjtcclxuXHJcbiAgICAgIGNvZGUgKz0gYG1hdDQgbXR4JHtfbG9jYWxPcldvcmxkfSA9IGA7XHJcbiAgICAgIGNvZGUgKz0gdHJhbnNmb3JtYXRpb25zXHJcbiAgICAgICAgLm1hcCgoW190cmFuc2Zvcm1hdGlvbiwgX3gsIF95LCBfel0sIF9pbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICBsZXQgcm90YXRlSWQ6IHN0cmluZyA9IF9pbmRleCArIF9sb2NhbE9yV29ybGQ7XHJcbiAgICAgICAgICBzd2l0Y2ggKF90cmFuc2Zvcm1hdGlvbikge1xyXG4gICAgICAgICAgICBjYXNlIFwidHJhbnNsYXRlXCI6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGBtYXQ0KFxyXG4gICAgICAgICAgICAgIDEuMCwgMC4wLCAwLjAsIDAuMCxcclxuICAgICAgICAgICAgICAwLjAsIDEuMCwgMC4wLCAwLjAsXHJcbiAgICAgICAgICAgICAgMC4wLCAwLjAsIDEuMCwgMC4wLFxyXG4gICAgICAgICAgICAgICR7X3h9LCAke195fSwgJHtfen0sIDEuMClgO1xyXG4gICAgICAgICAgICBjYXNlIFwicm90YXRlXCI6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGBtYXQ0KFxyXG4gICAgICAgICAgICAgIGZDb3NaJHtyb3RhdGVJZH0gKiBmQ29zWSR7cm90YXRlSWR9LCBmU2luWiR7cm90YXRlSWR9ICogZkNvc1kke3JvdGF0ZUlkfSwgLWZTaW5ZJHtyb3RhdGVJZH0sIDAuMCxcclxuICAgICAgICAgICAgICBmQ29zWiR7cm90YXRlSWR9ICogZlNpblkke3JvdGF0ZUlkfSAqIGZTaW5YJHtyb3RhdGVJZH0gLSBmU2luWiR7cm90YXRlSWR9ICogZkNvc1gke3JvdGF0ZUlkfSwgZlNpbloke3JvdGF0ZUlkfSAqIGZTaW5ZJHtyb3RhdGVJZH0gKiBmU2luWCR7cm90YXRlSWR9ICsgZkNvc1oke3JvdGF0ZUlkfSAqIGZDb3NYJHtyb3RhdGVJZH0sIGZDb3NZJHtyb3RhdGVJZH0gKiBmU2luWCR7cm90YXRlSWR9LCAwLjAsXHJcbiAgICAgICAgICAgICAgZkNvc1oke3JvdGF0ZUlkfSAqIGZTaW5ZJHtyb3RhdGVJZH0gKiBmQ29zWCR7cm90YXRlSWR9ICsgZlNpbloke3JvdGF0ZUlkfSAqIGZTaW5YJHtyb3RhdGVJZH0sIGZTaW5aJHtyb3RhdGVJZH0gKiBmU2luWSR7cm90YXRlSWR9ICogZkNvc1gke3JvdGF0ZUlkfSAtIGZDb3NaJHtyb3RhdGVJZH0gKiBmU2luWCR7cm90YXRlSWR9LCBmQ29zWSR7cm90YXRlSWR9ICogZkNvc1gke3JvdGF0ZUlkfSwgMC4wLFxyXG4gICAgICAgICAgICAgIDAuMCwgMC4wLCAwLjAsIDEuMFxyXG4gICAgICAgICAgICAgIClgO1xyXG4gICAgICAgICAgICBjYXNlIFwic2NhbGVcIjpcclxuICAgICAgICAgICAgICByZXR1cm4gYG1hdDQoXHJcbiAgICAgICAgICAgICAgJHtfeH0sIDAuMCwgMC4wLCAwLjAsXHJcbiAgICAgICAgICAgICAgMC4wLCAke195fSwgMC4wLCAwLjAsXHJcbiAgICAgICAgICAgICAgMC4wLCAwLjAsICR7X3p9LCAwLjAsXHJcbiAgICAgICAgICAgICAgMC4wLCAwLjAsIDAuMCwgMS4wXHJcbiAgICAgICAgICAgICAgKWA7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgdGhyb3cgYEVycm9yIGluICR7UGFydGljbGVTeXN0ZW0ubmFtZX06IFwiJHtfdHJhbnNmb3JtYXRpb259XCIgaXMgbm90IGEgdHJhbnNmb3JtYXRpb25gO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnJlZHVjZSgoX2FjY3VtdWxhdG9yOiBzdHJpbmcsIF9jb2RlOiBzdHJpbmcpID0+IGAke19hY2N1bXVsYXRvcn0gKiBcXG4ke19jb2RlfWApO1xyXG4gICAgICBjb2RlICs9IFwiO1xcblwiO1xyXG5cclxuICAgICAgcmV0dXJuIGNvZGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJhdGVDb2xvcihfY29sb3I6IFBhcnRpY2xlRGF0YS5FeHByZXNzaW9uW10pOiBzdHJpbmcge1xyXG4gICAgICBpZiAoIV9jb2xvcikgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgICBsZXQgcmdiYTogc3RyaW5nID0gW19jb2xvclswXSwgX2NvbG9yWzFdLCBfY29sb3JbMl0sIF9jb2xvclszXV1cclxuICAgICAgICAubWFwKChfdmFsdWUpOiBzdHJpbmcgPT4gX3ZhbHVlID8gUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5nZW5lcmF0ZUV4cHJlc3Npb24oX3ZhbHVlKSA6IFwiMS4wXCIpXHJcbiAgICAgICAgLmpvaW4oXCIsIFwiKTtcclxuXHJcbiAgICAgIHJldHVybiBgdmVjNCgke3JnYmF9KTtgO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdlbmVyYXRlRXhwcmVzc2lvbihfZXhwcmVzc2lvbjogUGFydGljbGVEYXRhLkV4cHJlc3Npb24pOiBzdHJpbmcge1xyXG4gICAgICBpZiAoUGFydGljbGVEYXRhLmlzRnVuY3Rpb24oX2V4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgbGV0IHBhcmFtZXRlcnM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgcGFyYW0gb2YgX2V4cHJlc3Npb24ucGFyYW1ldGVycykge1xyXG4gICAgICAgICAgcGFyYW1ldGVycy5wdXNoKFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2VuZXJhdGVFeHByZXNzaW9uKHBhcmFtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLmdlbmVyYXRlRnVuY3Rpb24oX2V4cHJlc3Npb24uZnVuY3Rpb24sIHBhcmFtZXRlcnMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoUGFydGljbGVEYXRhLmlzVmFyaWFibGUoX2V4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIFBhcnRpY2xlRGF0YS5QUkVERUZJTkVEX1ZBUklBQkxFU1tfZXhwcmVzc2lvbi52YWx1ZV0gfHwgXCJmUGFydGljbGVTeXN0ZW1WYXJpYWJsZV9cIiArIF9leHByZXNzaW9uLnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoUGFydGljbGVEYXRhLmlzQ29uc3RhbnQoX2V4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBzdHJpbmcgPSBfZXhwcmVzc2lvbi52YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX0ke3ZhbHVlLmluY2x1ZGVzKFwiLlwiKSA/IFwiXCIgOiBcIi4wXCJ9YDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKFBhcnRpY2xlRGF0YS5pc0NvZGUoX2V4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgbGV0IGNvZGU6IHN0cmluZyA9IF9leHByZXNzaW9uLmNvZGVcclxuICAgICAgICAgIC5yZXBsYWNlQWxsKC9cXGJbYS16QS16XStcXHcqKD8hXFwoKVxcYi9nLCAoX21hdGNoKSA9PiBQYXJ0aWNsZURhdGEuUFJFREVGSU5FRF9WQVJJQUJMRVNbX21hdGNoXSB8fCBcImZQYXJ0aWNsZVN5c3RlbVZhcmlhYmxlX1wiICsgX21hdGNoKVxyXG4gICAgICAgICAgLnJlcGxhY2VBbGwoLyg/PCFcXC4pXFxiXFxkK1xcYig/IVxcLikvZywgKF9tYXRjaCkgPT4gX21hdGNoICsgXCIuMFwiKTtcclxuICAgICAgICBjb2RlID0gUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5yZXBsYWNlRnVuY3Rpb25zKGNvZGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gY29kZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhyb3cgYEVycm9yIGluICR7UGFydGljbGVTeXN0ZW0ubmFtZX06IGludmFsaWQgbm9kZSBzdHJ1Y3R1cmUgaW4gcGFydGljbGUgc3lzdGVtIHNlcmlhbGl6YXRpb25gO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdlbmVyYXRlRnVuY3Rpb24oX2Z1bmN0aW9uOiBQYXJ0aWNsZURhdGEuRlVOQ1RJT04sIF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSk6IHN0cmluZyB7XHJcbiAgICAgIGlmIChfcGFyYW1ldGVycy5sZW5ndGggPCBQYXJ0aWNsZURhdGEuRlVOQ1RJT05fTUlOSU1VTV9QQVJBTUVURVJTW19mdW5jdGlvbl0pXHJcbiAgICAgICAgdGhyb3cgYEVycm9yIGluICR7UGFydGljbGVTeXN0ZW0ubmFtZX06IFwiJHtfZnVuY3Rpb259XCIgbmVlZHMgYXQgbGVhc3QgJHtQYXJ0aWNsZURhdGEuRlVOQ1RJT05fTUlOSU1VTV9QQVJBTUVURVJTW19mdW5jdGlvbl19IHBhcmFtZXRlcnNgO1xyXG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhQYXJ0aWNsZURhdGEuRlVOQ1RJT04pLmluY2x1ZGVzKF9mdW5jdGlvbikpXHJcbiAgICAgICAgcmV0dXJuIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uRlVOQ1RJT05TW19mdW5jdGlvbl0oX3BhcmFtZXRlcnMpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhyb3cgYEVycm9yIGluICR7UGFydGljbGVTeXN0ZW0ubmFtZX06IFwiJHtfZnVuY3Rpb259XCIgaXMgbm90IGFuIG9wZXJhdGlvbmA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVwbGFjZUZ1bmN0aW9ucyhfY29kZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgbGV0IGZ1bmN0aW9uUmVnZXg6IFJlZ0V4cCA9IC9cXGJbYS16QS16X10rXFx3KlxcKC9nO1xyXG4gICAgICBsZXQgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheTtcclxuICAgICAgd2hpbGUgKChtYXRjaCA9IGZ1bmN0aW9uUmVnZXguZXhlYyhfY29kZSkpICE9IG51bGwpIHtcclxuICAgICAgICBsZXQgZnVuY3Rpb25HZW5lcmF0b3I6IEZ1bmN0aW9uID0gUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5GVU5DVElPTlNbPFBhcnRpY2xlRGF0YS5GVU5DVElPTj5tYXRjaFswXS5zbGljZSgwLCAtMSldO1xyXG4gICAgICAgIGlmICghZnVuY3Rpb25HZW5lcmF0b3IpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgbGV0IGNvbW1hSW5kaWNlczogbnVtYmVyW10gPSBbXTtcclxuICAgICAgICBsZXQgb3BlbkJyYWNrZXRzOiBudW1iZXIgPSAxO1xyXG4gICAgICAgIGxldCBhcmd1bWVudHNMYXN0SW5kZXg6IG51bWJlciA9IGZ1bmN0aW9uUmVnZXgubGFzdEluZGV4O1xyXG4gICAgICAgIHdoaWxlIChvcGVuQnJhY2tldHMgPiAwKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKF9jb2RlW2FyZ3VtZW50c0xhc3RJbmRleF0pIHtcclxuICAgICAgICAgICAgY2FzZSBcIihcIjpcclxuICAgICAgICAgICAgICBvcGVuQnJhY2tldHMrKztcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIilcIjpcclxuICAgICAgICAgICAgICBvcGVuQnJhY2tldHMtLTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIixcIjpcclxuICAgICAgICAgICAgICBpZiAob3BlbkJyYWNrZXRzID09IDEpXHJcbiAgICAgICAgICAgICAgICBjb21tYUluZGljZXMucHVzaChhcmd1bWVudHNMYXN0SW5kZXgpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYXJndW1lbnRzTGFzdEluZGV4Kys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgYXJnczogc3RyaW5nW10gPVxyXG4gICAgICAgICAgW2Z1bmN0aW9uUmVnZXgubGFzdEluZGV4IC0gMSwgLi4uY29tbWFJbmRpY2VzLCBhcmd1bWVudHNMYXN0SW5kZXggLSAxXS5yZWR1Y2U8c3RyaW5nW10+KChfYWNjdW11bGF0b3IsIF9wb3NpdGlvbiwgX2luZGV4LCBfcG9zaXRpb25zKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBfaW5kZXggPT0gX3Bvc2l0aW9ucy5sZW5ndGggLSAxID9cclxuICAgICAgICAgICAgICBfYWNjdW11bGF0b3IgOlxyXG4gICAgICAgICAgICAgIF9hY2N1bXVsYXRvci5jb25jYXQoX2NvZGUuc2xpY2UoX3Bvc2l0aW9uICsgMSwgX3Bvc2l0aW9uc1tfaW5kZXggKyAxXSkudHJpbSgpKTtcclxuICAgICAgICAgIH0sIFtdKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb25SZWdleC5sYXN0SW5kZXggPSBtYXRjaC5pbmRleDtcclxuICAgICAgICBfY29kZSA9IGAke19jb2RlLnNsaWNlKDAsIG1hdGNoLmluZGV4KX0oJHtmdW5jdGlvbkdlbmVyYXRvcihhcmdzKX0pJHtfY29kZS5zbGljZShhcmd1bWVudHNMYXN0SW5kZXgpfWA7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIF9jb2RlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQnVmZmVycyB0aGUgcmFuZG9tIG51bWJlciBkYXRhIGZvciB0aGUgcGFydGljbGUgc3lzdGVtICh7QGxpbmsgQ29tcG9uZW50UGFydGljbGVTeXN0ZW19KSBpbnRvIGEgV2ViR0wgVGV4dHVyZVxyXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyMlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvckNvbXBvbmVudFBhcnRpY2xlU3lzdGVtIHtcclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZXMgdGhlIGRlY29yYXRlZCBtZXRob2Qgd2l0aCB0aGUgc3RhdGljIG1ldGhvZCBvZiB0aGUgc2FtZSBuYW1lIG9mIGNsYXNzLiBVc2VkIGluIHtAbGluayBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbX1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWNvcmF0ZTxNIGV4dGVuZHMgKHRoaXM6IEdlbmVyYWwsIC4uLmFyZ3M6IEdlbmVyYWwpID0+IEdlbmVyYWw+KF9tZXRob2Q6IE0sIF9jb250ZXh0OiBDbGFzc01ldGhvZERlY29yYXRvckNvbnRleHQ8Q29tcG9uZW50UGFydGljbGVTeXN0ZW0sIE0+KTogTSB7XHJcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0aGlzLCBfY29udGV4dC5uYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVzZVJlbmRlckRhdGEodGhpczogQ29tcG9uZW50UGFydGljbGVTeXN0ZW0pOiB2b2lkIHtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5yZW5kZXJEYXRhKSB7XHJcbiAgICAgICAgY3JjMy5hY3RpdmVUZXh0dXJlKFRFWFRVUkVfTE9DQVRJT04uUEFSVElDTEUuVU5JVCk7IC8vIEFUVEVOVElPTiE6IGNoYW5naW5nIHRoaXMgaWQgcmVxdWlyZXMgY2hhbmdpbmcgb2YgY29ycmVzcG9uZGluZyBpZCBpbiBwYXJ0aWNsZSByZW5kZXIgbWV0aG9kLCB1c2UgY3RybCArIHNoaWZ0ICsgZiBzZWFyY2ghXHJcbiAgICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRoaXMucmVuZGVyRGF0YSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUgPSBSZW5kZXIuYXNzZXJ0PFdlYkdMVGV4dHVyZT4oY3JjMy5jcmVhdGVUZXh0dXJlKCkpO1xyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcblxyXG4gICAgICBsZXQgdGV4dHVyZVNpemU6IG51bWJlciA9IE1hdGguY2VpbChNYXRoLnNxcnQodGhpcy5zaXplKSk7XHJcbiAgICAgIHRleHR1cmVTaXplID0gTWF0aC5taW4odGV4dHVyZVNpemUsIGNyYzMuZ2V0UGFyYW1ldGVyKGNyYzMuTUFYX1RFWFRVUkVfU0laRSkpO1xyXG5cclxuICAgICAgLy8gVE9ETzogdXNlIGludGVybmFsIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLCBhZGRpdGlvbmFsbHkgbWF5YmUgdXNlIGEgc2VlZCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIHJlY3JlYXRlIHRoZSBzYW1lIHJhbmRvbSBudW1iZXJzXHJcbiAgICAgIGxldCByYW5kb21OdW1iZXJzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZTsgaSsrKVxyXG4gICAgICAgIHJhbmRvbU51bWJlcnMucHVzaChNYXRoLnJhbmRvbSgpKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY3JjMy50ZXhJbWFnZTJEKFxyXG4gICAgICAgICAgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlIzMkYsIHRleHR1cmVTaXplLCB0ZXh0dXJlU2l6ZSwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SRUQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRkxPQVQsXHJcbiAgICAgICAgICBGbG9hdDMyQXJyYXkuZnJvbShyYW5kb21OdW1iZXJzKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIERlYnVnLmVycm9yKF9lcnJvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShjcmMzLlRFWFRVUkVfMkQsIGNyYzMuVEVYVFVSRV9NSU5fRklMVEVSLCBjcmMzLk5FQVJFU1QpO1xyXG4gICAgICBjcmMzLnRleFBhcmFtZXRlcmkoY3JjMy5URVhUVVJFXzJELCBjcmMzLlRFWFRVUkVfTUFHX0ZJTFRFUiwgY3JjMy5ORUFSRVNUKTtcclxuXHJcbiAgICAgIHRoaXMucmVuZGVyRGF0YSA9IHRleHR1cmU7XHJcblxyXG4gICAgICB0aGlzLnVzZVJlbmRlckRhdGEoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlbGV0ZVJlbmRlckRhdGEodGhpczogQ29tcG9uZW50UGFydGljbGVTeXN0ZW0pOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLnJlbmRlckRhdGEpIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgbnVsbCk7XHJcbiAgICAgIGNyYzMuZGVsZXRlVGV4dHVyZSh0aGlzLnJlbmRlckRhdGEpO1xyXG4gICAgICBkZWxldGUgdGhpcy5yZW5kZXJEYXRhO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBJbnRlcmZhY2UgdG8gYmUgaW1wbGVtZW50ZWQgYnkgb2JqZWN0cyB0aGF0IGNhbiBiZSByZWN5Y2xlZCwgaS5lLiB0byBhdm9pZCBnYXJiYWdlIGNvbGxlY3Rpb24gYnkgcmV1c2luZyB0aGUgb2JqZWN0IGluc3RlYWQgb2YgcmVwbGFjaW5nIGl0IHdpdGggYSBuZXcgb25lLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVjeWNhYmxlIHtcclxuICAgIC8qKlxyXG4gICAgICogUmVjeWNsZXMgdGhlIG9iamVjdCBmb3IgdGhlIG5leHQgcmV1c2UgYnkgc2V0dGluZyBpdHMgcHJvcGVydGllcyB0byB0aGVpciBkZWZhdWx0IHN0YXRlcy5cclxuICAgICAqL1xyXG4gICAgcmVjeWNsZSgpOiB2b2lkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogS2VlcHMgYSBkZXBvdCBvZiBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZCBmb3IgcmV1c2UsIHNvcnRlZCBieSB0eXBlLiAgXHJcbiAgICogVXNpbmcge0BsaW5rIFJlY3ljbGVyfSByZWR1Y2VzIGxvYWQgb24gdGhlIGNhcmJhZ2UgY29sbGVjdG9yIGFuZCB0aHVzIHN1cHBvcnRzIHNtb290aCBwZXJmb3JtYW5jZS5cclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2hzLWZ1cnR3YW5nZW4vRlVER0Uvd2lraS9SZWN5Y2xlclxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWN5Y2xlciB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBkZXBvdDogeyBbdHlwZTogc3RyaW5nXTogUmVjeWNhYmxlQXJyYXk8T2JqZWN0PiB9ID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaGVzIGFuIG9iamVjdCBvZiB0aGUgcmVxdWVzdGVkIHR5cGUgZnJvbSB0aGUgZGVwb3QsIGNhbGxzIGl0cyByZWN5Y2xlLW1ldGhvZCBhbmQgcmV0dXJucyBpdC5cclxuICAgICAqIElmIHRoZSBkZXBvdCBmb3IgdGhhdCB0eXBlIGlzIGVtcHR5IGl0IHJldHVybnMgYSBuZXcgb2JqZWN0IG9mIHRoZSByZXF1ZXN0ZWQgdHlwZS5cclxuICAgICAqIEBwYXJhbSBfdCBUaGUgY2xhc3MgaWRlbnRpZmllciBvZiB0aGUgZGVzaXJlZCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQ8VCBleHRlbmRzIFJlY3ljYWJsZSB8IFJlY3ljYWJsZUFycmF5PFQ+IHwgT2JqZWN0PihfdDogbmV3ICgpID0+IFQpOiBUIHtcclxuICAgICAgbGV0IGtleTogc3RyaW5nID0gX3QubmFtZTtcclxuICAgICAgbGV0IGluc3RhbmNlczogUmVjeWNhYmxlQXJyYXk8T2JqZWN0PiA9IFJlY3ljbGVyLmRlcG90W2tleV07XHJcbiAgICAgIGlmIChpbnN0YW5jZXMgJiYgaW5zdGFuY2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBsZXQgaW5zdGFuY2U6IFQgPSA8VD5pbnN0YW5jZXMucG9wKCk7XHJcbiAgICAgICAgKDxSZWN5Y2FibGU+aW5zdGFuY2UpLnJlY3ljbGU/LigpO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgICAgfSBlbHNlXHJcbiAgICAgICAgcmV0dXJuIG5ldyBfdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2hlcyBhbiBvYmplY3Qgb2YgdGhlIHJlcXVlc3RlZCB0eXBlIGZyb20gdGhlIGRlcG90IGFuZCByZXR1cm5zIGl0LiDimqDvuI8qKkRPRVMgTk9UKiogY2FsbCBpdHMgcmVjeWNsZS1tZXRob2QuXHJcbiAgICAgKiBGYXN0ZXIgdGhhbiB7QGxpbmsgUmVjeWNsZXIuZ2V0fSwgYnV0IHNob3VsZCBiZSB1c2VkIHdpdGggY2F1dGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZXVzZTxUIGV4dGVuZHMgT2JqZWN0PihfdDogbmV3ICgpID0+IFQpOiBUIHtcclxuICAgICAgcmV0dXJuIDxUPlJlY3ljbGVyLmRlcG90W190Lm5hbWVdPy5wb3AoKSA/PyBuZXcgX3QoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3JlcyB0aGUgb2JqZWN0IGluIHRoZSBkZXBvdCBmb3IgbGF0ZXIgcmVjeWNsaW5nLiBVc2VycyBhcmUgcmVzcG9uc2libGUgZm9yIHRocm93aW5nIGluIG9iamVjdHMgdGhhdCBhcmUgYWJvdXQgdG8gbG9vc2Ugc2NvcGUgYW5kIGFyZSBub3QgcmVmZXJlbmNlZCBieSBhbnkgb3RoZXJcclxuICAgICAqIEBwYXJhbSBfaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzdG9yZShfaW5zdGFuY2U6IE9iamVjdCk6IHZvaWQge1xyXG4gICAgICAvLyBsZXQga2V5OiBzdHJpbmcgPSBfaW5zdGFuY2UuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgLy8gLy9EZWJ1Zy5sb2coa2V5KTtcclxuICAgICAgLy8gbGV0IGluc3RhbmNlczogUmVjeWNhYmxlQXJyYXk8T2JqZWN0PiA9IFJlY3ljbGVyTmV3LmRlcG90W2tleV0gfHwgbmV3IFJlY3ljYWJsZUFycmF5PE9iamVjdD4oKTtcclxuICAgICAgLy8gaW5zdGFuY2VzLnB1c2goX2luc3RhbmNlKTtcclxuICAgICAgLy8gUmVjeWNsZXJOZXcuZGVwb3Rba2V5XSA9IGluc3RhbmNlcztcclxuICAgICAgLy8gRGVidWcubG9nKGBPYmplY3RNYW5hZ2VyLmRlcG90WyR7a2V5fV06ICR7T2JqZWN0TWFuYWdlci5kZXBvdFtrZXldLmxlbmd0aH1gKTtcclxuICAgICAgLy9EZWJ1Zy5sb2codGhpcy5kZXBvdCk7XHJcbiAgICAgIChSZWN5Y2xlci5kZXBvdFtfaW5zdGFuY2UuY29uc3RydWN0b3IubmFtZV0gPz89IG5ldyBSZWN5Y2FibGVBcnJheTxPYmplY3Q+KCkpLnB1c2goX2luc3RhbmNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3JlcyB0aGUgcHJvdmlkZWQgb2JqZWN0cyB1c2luZyB0aGUge0BsaW5rIFJlY3ljbGVyLnN0b3JlfSBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzdG9yZU11bHRpcGxlKC4uLl9pbnN0YW5jZXM6IE9iamVjdFtdKTogdm9pZCB7IC8vIFRPRE86IG1heWJlIG1ha2UgdGhpcyB0aGUgZGVmYXVsdCBzdG9yZSBtZXRob2RcclxuICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBfaW5zdGFuY2VzKVxyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKGluc3RhbmNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVtcHR5cyB0aGUgZGVwb3Qgb2YgYSBnaXZlbiB0eXBlLCBsZWF2aW5nIHRoZSBvYmplY3RzIGZvciB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IuIE1heSByZXN1bHQgaW4gYSBzaG9ydCBzdGFsbCB3aGVuIG1hbnkgb2JqZWN0cyB3ZXJlIGluXHJcbiAgICAgKiBAcGFyYW0gX3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkdW1wPFQ+KF90OiBuZXcgKCkgPT4gVCk6IHZvaWQge1xyXG4gICAgICBSZWN5Y2xlci5kZXBvdFtfdC5uYW1lXSA9IG5ldyBSZWN5Y2FibGVBcnJheTxPYmplY3Q+KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbXB0eXMgYWxsIGRlcG90cywgbGVhdmluZyBhbGwgb2JqZWN0cyB0byB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IuIE1heSByZXN1bHQgaW4gYSBzaG9ydCBzdGFsbCB3aGVuIG1hbnkgb2JqZWN0cyB3ZXJlIGluXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHVtcEFsbCgpOiB2b2lkIHtcclxuICAgICAgUmVjeWNsZXIuZGVwb3QgPSB7fTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBTdG9yZXMgYW5kIG1hbmlwdWxhdGVzIGEgdHdvZGltZW5zaW9uYWwgdmVjdG9yIGNvbXByaXNlZCBvZiB0aGUgY29tcG9uZW50cyB4IGFuZCB5XHJcbiAgICogYGBgdGV4dFxyXG4gICAqICAgICAgICAgICAgK3lcclxuICAgKiAgICAgICAgICAgICB8X18gK3hcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBMdWthcyBTY2hldWVybGUsIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFZlY3RvcjIgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlLCBSZWN5Y2FibGUge1xyXG4gICAgcHVibGljIHg6IG51bWJlcjtcclxuICAgIHB1YmxpYyB5OiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNldChfeCwgX3kpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBTdGF0aWNcclxuICAgIC8qKiBcclxuICAgICAqIEEgc2hvcnRoYW5kIGZvciB3cml0aW5nIGBuZXcgVmVjdG9yMigwLCAwKWAuXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3Igd2l0aCB0aGUgdmFsdWVzICgwLCAwKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFpFUk8oKTogVmVjdG9yMiB7XHJcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMiA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjIpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KDAsIDApO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEEgc2hvcnRoYW5kIGZvciB3cml0aW5nIGBuZXcgVmVjdG9yMihfc2NhbGUsIF9zY2FsZSlgLlxyXG4gICAgICogQHBhcmFtIF9zY2FsZSB0aGUgc2NhbGUgb2YgdGhlIHZlY3Rvci4gRGVmYXVsdDogMVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE9ORShfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IyIHtcclxuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMik7XHJcbiAgICAgIHZlY3Rvci5zZXQoX3NjYWxlLCBfc2NhbGUpO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEEgc2hvcnRoYW5kIGZvciB3cml0aW5nIGBuZXcgVmVjdG9yMih4LCAwKWAuXHJcbiAgICAgKiBAcGFyYW0gX3NjYWxlIFRoZSBudW1iZXIgdG8gd3JpdGUgaW4gdGhlIHggY29vcmRpbmF0ZS4gRGVmYXVsdDogMVxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHdpdGggdGhlIHZhbHVlcyAoX3NjYWxlLCAwKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFgoX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XHJcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMiA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjIpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KF9zY2FsZSwgMCk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQSBzaG9ydGhhbmQgZm9yIHdyaXRpbmcgYG5ldyBWZWN0b3IyKDAsIHkpYC5cclxuICAgICAqIEBwYXJhbSBfc2NhbGUgVGhlIG51bWJlciB0byB3cml0ZSBpbiB0aGUgeSBjb29yZGluYXRlLiBEZWZhdWx0OiAxXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3Igd2l0aCB0aGUgdmFsdWVzICgwLCBfc2NhbGUpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgWShfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IyIHtcclxuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMik7XHJcbiAgICAgIHZlY3Rvci5zZXQoMCwgX3NjYWxlKTtcclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3IgdGhyb3VnaCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gdmVjdG9yIGJ5IHRoZSBnaXZlbiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUUkFOU0ZPUk1BVElPTihfdmVjdG9yOiBWZWN0b3IyLCBfbXR4VHJhbnNmb3JtOiBNYXRyaXgzeDMsIF9pbmNsdWRlVHJhbnNsYXRpb246IGJvb2xlYW4gPSB0cnVlKTogVmVjdG9yMiB7XHJcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMiA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjIpO1xyXG4gICAgICBsZXQgbTogRmxvYXQzMkFycmF5ID0gX210eFRyYW5zZm9ybS5nZXQoKTtcclxuICAgICAgdmVjdG9yLnNldChcclxuICAgICAgICBtWzBdICogX3ZlY3Rvci54ICsgbVszXSAqIF92ZWN0b3IueSxcclxuICAgICAgICBtWzFdICogX3ZlY3Rvci54ICsgbVs0XSAqIF92ZWN0b3IueVxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKF9pbmNsdWRlVHJhbnNsYXRpb24pXHJcbiAgICAgICAgdmVjdG9yLmFkZChfbXR4VHJhbnNmb3JtLnRyYW5zbGF0aW9uKTtcclxuXHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIHdoaWNoIGlzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdmVjdG9yIHNjYWxlZCB0byB0aGUgZ2l2ZW4gbGVuZ3RoLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE5PUk1BTElaQVRJT04oX3ZlY3RvcjogVmVjdG9yMiwgX2xlbmd0aDogbnVtYmVyID0gMSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgbWFnbml0dWRlU3F1YXJlZDogbnVtYmVyID0gX3ZlY3Rvci5tYWduaXR1ZGVTcXVhcmVkO1xyXG4gICAgICBpZiAobWFnbml0dWRlU3F1YXJlZCA9PSAwKVxyXG4gICAgICAgIHRocm93IChuZXcgUmFuZ2VFcnJvcihcIkltcG9zc2libGUgbm9ybWFsaXphdGlvblwiKSk7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjIgPSBfdmVjdG9yLmNsb25lO1xyXG4gICAgICB2ZWN0b3Iuc2NhbGUoX2xlbmd0aCAvIE1hdGguc3FydChtYWduaXR1ZGVTcXVhcmVkKSk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIHNjYWxpbmcgZmFjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0NBTEUoX3ZlY3RvcjogVmVjdG9yMiwgX3NjYWxlOiBudW1iZXIpOiBWZWN0b3IyIHtcclxuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMik7XHJcbiAgICAgIHZlY3Rvci5zZXQoX3ZlY3Rvci54ICogX3NjYWxlLCBfdmVjdG9yLnkgKiBfc2NhbGUpO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0aW5nIHZlY3RvciBhdHRhaW5lZCBieSBhZGRpdGlvbiBvZiBhbGwgZ2l2ZW4gdmVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTVU0oLi4uX3ZlY3RvcnM6IFZlY3RvcjJbXSk6IFZlY3RvcjIge1xyXG4gICAgICBjb25zdCByZXN1bHQ6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICAgIGZvciAobGV0IHZlY3RvciBvZiBfdmVjdG9ycylcclxuICAgICAgICByZXN1bHQuc2V0KHJlc3VsdC54ICsgdmVjdG9yLngsIHJlc3VsdC55ICsgdmVjdG9yLnkpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbiBvZiB0d28gdmVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBESUZGRVJFTkNFKF9taW51ZW5kOiBWZWN0b3IyLCBfc3VidHJhaGVuZDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjIgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IyKTtcclxuICAgICAgdmVjdG9yLnNldChfbWludWVuZC54IC0gX3N1YnRyYWhlbmQueCwgX21pbnVlbmQueSAtIF9zdWJ0cmFoZW5kLnkpO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gVmVjdG9ycy4gRHVlIHRvIHRoZW0gYmVpbmcgb25seSAyIERpbWVuc2lvbmFsLCB0aGUgcmVzdWx0IGlzIGEgc2luZ2xlIG51bWJlcixcclxuICAgICAqIHdoaWNoIGltcGxpY2l0bHkgaXMgb24gdGhlIFogYXhpcy4gSXQgaXMgYWxzbyB0aGUgc2lnbmVkIG1hZ25pdHVkZSBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENST1NTKF9hOiBWZWN0b3IyLCBfYjogVmVjdG9yMik6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBfYS54ICogX2IueSAtIF9hLnkgKiBfYi54O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIGRvdHByb2R1Y3Qgb2YgMiB2ZWN0b3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERPVChfYTogVmVjdG9yMiwgX2I6IFZlY3RvcjIpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gX2EueCAqIF9iLnggKyBfYS55ICogX2IueTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG9ydGhvZ29uYWwgdmVjdG9yIHRvIHRoZSBnaXZlbiB2ZWN0b3IuIFJvdGF0ZXMgY291bnRlcmNsb2Nrd2lzZSBieSBkZWZhdWx0LlxyXG4gICAgICogYGBgdGV4dFxyXG4gICAgICog4oaRID0+IOKGkCA9PiDihpMgPT4g4oaSID0+IOKGkVxyXG4gICAgICogYGBgXHJcbiAgICAgKiBAcGFyYW0gX3ZlY3RvciBWZWN0b3IgdG8gZ2V0IHRoZSBvcnRob2dvbmFsIGVxdWl2YWxlbnQgb2ZcclxuICAgICAqIEBwYXJhbSBfY2xvY2t3aXNlIFNob3VsZCB0aGUgcm90YXRpb24gYmUgY2xvY2t3aXNlIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgY291bnRlcmNsb2Nrd2lzZT8gZGVmYXVsdDogZmFsc2VcclxuICAgICAqIEByZXR1cm5zIEEgVmVjdG9yIHRoYXQgaXMgb3J0aG9nb25hbCB0byBhbmQgaGFzIHRoZSBzYW1lIG1hZ25pdHVkZSBhcyB0aGUgZ2l2ZW4gVmVjdG9yLiAgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgT1JUSE9HT05BTChfdmVjdG9yOiBWZWN0b3IyLCBfY2xvY2t3aXNlOiBib29sZWFuID0gZmFsc2UpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjIpO1xyXG4gICAgICBpZiAoX2Nsb2Nrd2lzZSlcclxuICAgICAgICByZXN1bHQuc2V0KF92ZWN0b3IueSwgLV92ZWN0b3IueCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICByZXN1bHQuc2V0KC1fdmVjdG9yLnksIF92ZWN0b3IueCk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY2FydGVzaWFuIHZlY3RvciBmcm9tIHBvbGFyIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgR0VPKF9hbmdsZTogbnVtYmVyID0gMCwgX21hZ25pdHVkZTogbnVtYmVyID0gMSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMik7XHJcbiAgICAgIGxldCBnZW86IEdlbzIgPSBSZWN5Y2xlci5yZXVzZShHZW8yKTtcclxuICAgICAgZ2VvLnNldChfYW5nbGUsIF9tYWduaXR1ZGUpO1xyXG4gICAgICB2ZWN0b3IuZ2VvID0gZ2VvO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShnZW8pO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIEFjY2Vzc29yc1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1hZ25pdHVkZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gTWF0aC5oeXBvdCh0aGlzLngsIHRoaXMueSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzcXVhcmUgb2YgdGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yIHdpdGhvdXQgY2FsY3VsYXRpbmcgYSBzcXVhcmUgcm9vdC4gRmFzdGVyIGZvciBzaW1wbGUgcHJveGltaXR5IGV2YWx1YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWFnbml0dWRlU3F1YXJlZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gVmVjdG9yMi5ET1QodGhpcywgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9sYXIgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBnZW8oKTogR2VvMiB7XHJcbiAgICAgIGxldCBnZW86IEdlbzIgPSBSZWN5Y2xlci5nZXQoR2VvMik7XHJcbiAgICAgIGdlby5tYWduaXR1ZGUgPSB0aGlzLm1hZ25pdHVkZTtcclxuXHJcbiAgICAgIGlmIChnZW8ubWFnbml0dWRlID09PSAwKVxyXG4gICAgICAgIHJldHVybiBnZW87XHJcblxyXG4gICAgICBnZW8uYW5nbGUgPSAxODAgKiBNYXRoLmF0YW4yKHRoaXMueSAvIGdlby5tYWduaXR1ZGUsIHRoaXMueCAvIGdlby5tYWduaXR1ZGUpIC8gTWF0aC5QSTtcclxuICAgICAgcmV0dXJuIGdlbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdCB0aGUgY2FydGVzaWFuIHZhbHVlcyBvZiB0aGlzIHZlY3RvciB0byByZXByZXNlbnQgdGhlIGdpdmVuIGFzIHBvbGFyIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgZ2VvKF9nZW86IEdlbzIpIHtcclxuICAgICAgdGhpcy5zZXQoX2dlby5tYWduaXR1ZGUsIDApO1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybShNYXRyaXgzeDMuUk9UQVRJT04oX2dlby5hbmdsZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGNsb25lIG9mIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNsb25lKCk6IFZlY3RvcjIge1xyXG4gICAgICByZXR1cm4gUmVjeWNsZXIucmV1c2UoVmVjdG9yMikuY29weSh0aGlzKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29waWVzIHRoZSBjb21wb25lbnRzIG9mIHRoZSBnaXZlbiB2ZWN0b3IgaW50byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvcHkoX29yaWdpbmFsOiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNldChfb3JpZ2luYWwueCwgX29yaWdpbmFsLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldCgwLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHZlY3RvciBhcmUgdG8gYmUgY29uc2lkZXJlZCBpZGVudGljYWwgd2l0aGluIHRoZSBnaXZlbiB0b2xlcmFuY2VcclxuICAgICAqIFRPRE86IGV4YW1pbmUsIGlmIHRvbGVyYW5jZSBhcyBjcml0ZXJpdW0gZm9yIHRoZSBkaWZmZXJlbmNlIGlzIGFwcHJvcHJpYXRlIHdpdGggdmVyeSBsYXJnZSBjb29yZGluYXRlIHZhbHVlcyBvciBpZiBfdG9sZXJhbmNlIHNob3VsZCBiZSBtdWx0aXBsaWVkIGJ5IGNvb3JkaW5hdGUgdmFsdWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGVxdWFscyhfY29tcGFyZTogVmVjdG9yMiwgX3RvbGVyYW5jZTogbnVtYmVyID0gTnVtYmVyLkVQU0lMT04pOiBib29sZWFuIHtcclxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMueCAtIF9jb21wYXJlLngpID4gX3RvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy55IC0gX2NvbXBhcmUueSkgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gdmVjdG9yIHRvIHRoZSBleGVjdXRpbmcgdmVjdG9yLCBjaGFuZ2luZyB0aGUgZXhlY3V0b3IuXHJcbiAgICAgKiBAcGFyYW0gX2FkZGVuZCBUaGUgdmVjdG9yIHRvIGFkZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZChfYWRkZW5kOiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIHRoaXMueCArPSBfYWRkZW5kLng7XHJcbiAgICAgIHRoaXMueSArPSBfYWRkZW5kLnk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIHRoZSBnaXZlbiB2ZWN0b3IgZnJvbSB0aGUgZXhlY3V0aW5nIHZlY3RvciwgY2hhbmdpbmcgdGhlIGV4ZWN1dG9yLlxyXG4gICAgICogQHBhcmFtIF9zdWJ0cmFoZW5kIFRoZSB2ZWN0b3IgdG8gc3VidHJhY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdWJ0cmFjdChfc3VidHJhaGVuZDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICB0aGlzLnggLT0gX3N1YnRyYWhlbmQueDtcclxuICAgICAgdGhpcy55IC09IF9zdWJ0cmFoZW5kLnk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIHRoZSBWZWN0b3IgYnkgdGhlIGdpdmVuIF9zY2FsYXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZShfc2NhbGFyOiBudW1iZXIpOiBWZWN0b3IyIHtcclxuICAgICAgdGhpcy54ICo9IF9zY2FsYXI7XHJcbiAgICAgIHRoaXMueSAqPSBfc2NhbGFyO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgdGhpcyB0byB0aGUgZ2l2ZW4gbGVuZ3RoLCAxIGJ5IGRlZmF1bHRcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vcm1hbGl6ZShfbGVuZ3RoOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvcHkoVmVjdG9yMi5OT1JNQUxJWkFUSU9OKHRoaXMsIF9sZW5ndGgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwKTogVmVjdG9yMiB7XHJcbiAgICAgIHRoaXMueCA9IF94O1xyXG4gICAgICB0aGlzLnkgPSBfeTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFt0aGlzLngsIHRoaXMueV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtcyB0aGlzIHZlY3RvciBieSB0aGUgZ2l2ZW4gbWF0cml4LCBpbmNsdWRpbmcgb3IgZXhsdWRpbmcgdGhlIHRyYW5zbGF0aW9uLlxyXG4gICAgICogSW5jbHVkaW5nIGlzIHRoZSBkZWZhdWx0LCBleGNsdWRpbmcgd2lsbCBvbmx5IHJvdGF0ZSBhbmQgc2NhbGUgdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oX210eFRyYW5zZm9ybTogTWF0cml4M3gzLCBfaW5jbHVkZVRyYW5zbGF0aW9uOiBib29sZWFuID0gdHJ1ZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgdHJhbnNmb3JtZWQ6IFZlY3RvcjIgPSBWZWN0b3IyLlRSQU5TRk9STUFUSU9OKHRoaXMsIF9tdHhUcmFuc2Zvcm0sIF9pbmNsdWRlVHJhbnNsYXRpb24pO1xyXG4gICAgICB0aGlzLmNvcHkodHJhbnNmb3JtZWQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh0cmFuc2Zvcm1lZCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yIGVhY2ggZGltZW5zaW9uLCBtb3ZlcyB0aGUgY29tcG9uZW50IHRvIHRoZSBtaW5pbXVtIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIG1pbihfY29tcGFyZTogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICB0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIF9jb21wYXJlLngpO1xyXG4gICAgICB0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIF9jb21wYXJlLnkpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yIGVhY2ggZGltZW5zaW9uLCBtb3ZlcyB0aGUgY29tcG9uZW50IHRvIHRoZSBtYXhpbXVtIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIG1heChfY29tcGFyZTogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICB0aGlzLnggPSBNYXRoLm1heCh0aGlzLngsIF9jb21wYXJlLngpO1xyXG4gICAgICB0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnksIF9jb21wYXJlLnkpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSB6LWNvbXBvbmVudCBvZiB0aGUgZ2l2ZW4gbWFnbml0dWRlIChkZWZhdWx0PTApIHRvIHRoZSB2ZWN0b3IgYW5kIHJldHVybnMgYSBuZXcgVmVjdG9yM1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9WZWN0b3IzKF96OiBudW1iZXIgPSAwKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLngsIHRoaXMueSwgX3opO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IHN0cmluZyA9IGAoJHt0aGlzLngudG9QcmVjaXNpb24oNSl9LCAke3RoaXMueS50b1ByZWNpc2lvbig1KX0pYDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZXMgdGhlIHN0YW5kYXJkIGFycmF5Lm1hcCBmdW5jdGlvbmFsaXR5IHRvIHBlcmZvcm0gdGhlIGdpdmVuIGZ1bmN0aW9uIG9uIGFsbCBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yXHJcbiAgICAgKiBhbmQgcmV0dXJuIGEgbmV3IHZlY3RvciB3aXRoIHRoZSByZXN1bHRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtYXAoX2Z1bmN0aW9uOiAodmFsdWU6IG51bWJlciwgaW5kZXg6IG51bWJlciwgYXJyYXk6IEFycmF5TGlrZTxudW1iZXI+KSA9PiBudW1iZXIpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IGNvcHk6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICAgIGNvcHkuc2V0KC4uLlt0aGlzLngsIHRoaXMueV0ubWFwKF9mdW5jdGlvbikpO1xyXG4gICAgICByZXR1cm4gY29weTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIC8vIHNlcmlhbGl6YXRpb24udG9KU09OID0gKCkgPT4geyByZXR1cm4gYHsgXCJyXCI6ICR7dGhpcy5yfSwgXCJnXCI6ICR7dGhpcy5nfSwgXCJiXCI6ICR7dGhpcy5ifSwgXCJhXCI6ICR7dGhpcy5hfX1gOyB9O1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnRvSlNPTiA9ICgpID0+IHsgcmV0dXJuIGBbJHt0aGlzLnh9LCAke3RoaXMueX1dYDsgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxWZWN0b3IyPiB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9zZXJpYWxpemF0aW9uKSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgW3RoaXMueCwgdGhpcy55XSA9IEpTT04ucGFyc2UoPHN0cmluZz48dW5rbm93bj5fc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIH0gZWxzZVxyXG4gICAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHg6IHRoaXMueCwgeTogdGhpcy55XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi4vUmVjeWNsZS9SZWN5Y2xlci50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiVmVjdG9yMi50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgdGhlIG9yaWdpbiBvZiBhIHJlY3RhbmdsZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIE9SSUdJTjJEIHtcclxuICAgIFRPUExFRlQgPSAweDAwLFxyXG4gICAgVE9QQ0VOVEVSID0gMHgwMSxcclxuICAgIFRPUFJJR0hUID0gMHgwMixcclxuICAgIENFTlRFUkxFRlQgPSAweDEwLFxyXG4gICAgQ0VOVEVSID0gMHgxMSxcclxuICAgIENFTlRFUlJJR0hUID0gMHgxMixcclxuICAgIEJPVFRPTUxFRlQgPSAweDIwLFxyXG4gICAgQk9UVE9NQ0VOVEVSID0gMHgyMSxcclxuICAgIEJPVFRPTVJJR0hUID0gMHgyMlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyBhIHJlY3RhbmdsZSB3aXRoIHBvc2l0aW9uIGFuZCBzaXplIGFuZCBhZGQgY29tZm9ydGFibGUgbWV0aG9kcyB0byBpdFxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUmVjdGFuZ2xlIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFJlY3ljYWJsZSB7XHJcbiAgICBwdWJsaWMgcG9zaXRpb246IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICBwdWJsaWMgc2l6ZTogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfd2lkdGg6IG51bWJlciA9IDEsIF9oZWlnaHQ6IG51bWJlciA9IDEsIF9vcmlnaW46IE9SSUdJTjJEID0gT1JJR0lOMkQuVE9QTEVGVCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNldFBvc2l0aW9uQW5kU2l6ZShfeCwgX3ksIF93aWR0aCwgX2hlaWdodCwgX29yaWdpbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSBjcmVhdGVkIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBHRVQoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfd2lkdGg6IG51bWJlciA9IDEsIF9oZWlnaHQ6IG51bWJlciA9IDEsIF9vcmlnaW46IE9SSUdJTjJEID0gT1JJR0lOMkQuVE9QTEVGVCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIGxldCByZWN0OiBSZWN0YW5nbGUgPSBSZWN5Y2xlci5nZXQoUmVjdGFuZ2xlKTtcclxuICAgICAgcmVjdC5zZXRQb3NpdGlvbkFuZFNpemUoX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpO1xyXG4gICAgICByZXR1cm4gcmVjdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHgoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXQgeSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldCB3aWR0aCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zaXplLng7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IGhlaWdodCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zaXplLnk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGxlZnRtb3N0IGV4cGFuc2lvbiwgcmVzcGVjdGluZyBhbHNvIG5lZ2F0aXZlIHZhbHVlcyBvZiB3aWR0aFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGxlZnQoKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMuc2l6ZS54ID4gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xyXG4gICAgICByZXR1cm4gKHRoaXMucG9zaXRpb24ueCArIHRoaXMuc2l6ZS54KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSB0b3Btb3N0IGV4cGFuc2lvbiwgcmVzcGVjdGluZyBhbHNvIG5lZ2F0aXZlIHZhbHVlcyBvZiBoZWlnaHRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB0b3AoKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMuc2l6ZS55ID4gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xyXG4gICAgICByZXR1cm4gKHRoaXMucG9zaXRpb24ueSArIHRoaXMuc2l6ZS55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSByaWdodG1vc3QgZXhwYW5zaW9uLCByZXNwZWN0aW5nIGFsc28gbmVnYXRpdmUgdmFsdWVzIG9mIHdpZHRoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcmlnaHQoKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMuc2l6ZS54ID4gMClcclxuICAgICAgICByZXR1cm4gKHRoaXMucG9zaXRpb24ueCArIHRoaXMuc2l6ZS54KTtcclxuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBsb3dlc3QgZXhwYW5zaW9uLCByZXNwZWN0aW5nIGFsc28gbmVnYXRpdmUgdmFsdWVzIG9mIGhlaWdodFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGJvdHRvbSgpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5zaXplLnkgPiAwKVxyXG4gICAgICAgIHJldHVybiAodGhpcy5wb3NpdGlvbi55ICsgdGhpcy5zaXplLnkpO1xyXG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgeChfeDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMucG9zaXRpb24ueCA9IF94O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCB5KF95OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5wb3NpdGlvbi55ID0gX3k7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHdpZHRoKF93aWR0aDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS54ID0gX3dpZHRoO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBoZWlnaHQoX2hlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS55ID0gX2hlaWdodDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbGVmdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNpemUueCA9IHRoaXMucmlnaHQgLSBfdmFsdWU7XHJcbiAgICAgIHRoaXMucG9zaXRpb24ueCA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgdG9wKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS55ID0gdGhpcy5ib3R0b20gLSBfdmFsdWU7XHJcbiAgICAgIHRoaXMucG9zaXRpb24ueSA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgcmlnaHQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zaXplLnggPSB0aGlzLnBvc2l0aW9uLnggKyBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGJvdHRvbShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNpemUueSA9IHRoaXMucG9zaXRpb24ueSArIF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGNsb25lKCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0UG9zaXRpb25BbmRTaXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhpcyByZWN0YW5nbGUgdG8gdGhlIHZhbHVlcyBnaXZlbiBieSB0aGUgcmVjdGFuZ2xlIHByb3ZpZGVkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb3B5KF9yZWN0OiBSZWN0YW5nbGUpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkFuZFNpemUoX3JlY3QueCwgX3JlY3QueSwgX3JlY3Qud2lkdGgsIF9yZWN0LmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgcmVjdGFuZ2xlIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gcGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UG9zaXRpb25BbmRTaXplKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCwgX3dpZHRoOiBudW1iZXIgPSAxLCBfaGVpZ2h0OiBudW1iZXIgPSAxLCBfb3JpZ2luOiBPUklHSU4yRCA9IE9SSUdJTjJELlRPUExFRlQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zaXplLnNldChfd2lkdGgsIF9oZWlnaHQpO1xyXG4gICAgICBzd2l0Y2ggKF9vcmlnaW4gJiAweDAzKSB7XHJcbiAgICAgICAgY2FzZSAweDAwOiB0aGlzLnBvc2l0aW9uLnggPSBfeDsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAweDAxOiB0aGlzLnBvc2l0aW9uLnggPSBfeCAtIF93aWR0aCAvIDI7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMHgwMjogdGhpcy5wb3NpdGlvbi54ID0gX3ggLSBfd2lkdGg7IGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHN3aXRjaCAoX29yaWdpbiAmIDB4MzApIHtcclxuICAgICAgICBjYXNlIDB4MDA6IHRoaXMucG9zaXRpb24ueSA9IF95OyBicmVhaztcclxuICAgICAgICBjYXNlIDB4MTA6IHRoaXMucG9zaXRpb24ueSA9IF95IC0gX2hlaWdodCAvIDI7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMHgyMDogdGhpcy5wb3NpdGlvbi55ID0gX3kgLSBfaGVpZ2h0OyBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gcG9pbnQgZnJvbSB0aGlzIHJlY3RhbmdsZXMgc3BhY2UgdG8gdGhlIHRhcmdldCByZWN0YW5nbGVzIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludFRvUmVjdChfcG9pbnQ6IFZlY3RvcjIsIF90YXJnZXQ6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gX3BvaW50LmNsb25lO1xyXG4gICAgICByZXN1bHQuc3VidHJhY3QodGhpcy5wb3NpdGlvbik7XHJcbiAgICAgIHJlc3VsdC54ICo9IF90YXJnZXQud2lkdGggLyB0aGlzLndpZHRoO1xyXG4gICAgICByZXN1bHQueSAqPSBfdGFyZ2V0LmhlaWdodCAvIHRoaXMuaGVpZ2h0O1xyXG4gICAgICByZXN1bHQuYWRkKF90YXJnZXQucG9zaXRpb24pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwb2ludCBpcyBpbnNpZGUgb2YgdGhpcyByZWN0YW5nbGUgb3Igb24gdGhlIGJvcmRlclxyXG4gICAgICogQHBhcmFtIF9wb2ludFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNJbnNpZGUoX3BvaW50OiBWZWN0b3IyKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAoX3BvaW50LnggPj0gdGhpcy5sZWZ0ICYmIF9wb2ludC54IDw9IHRoaXMucmlnaHQgJiYgX3BvaW50LnkgPj0gdGhpcy50b3AgJiYgX3BvaW50LnkgPD0gdGhpcy5ib3R0b20pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcmVjdGFuZ2xlIGNvbGxpZGVzIHdpdGggdGhlIHJlY3RhbmdsZSBnaXZlblxyXG4gICAgICogQHBhcmFtIF9yZWN0IFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29sbGlkZXMoX3JlY3Q6IFJlY3RhbmdsZSk6IGJvb2xlYW4ge1xyXG4gICAgICBpZiAodGhpcy5sZWZ0ID4gX3JlY3QucmlnaHQpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMucmlnaHQgPCBfcmVjdC5sZWZ0KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLnRvcCA+IF9yZWN0LmJvdHRvbSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy5ib3R0b20gPCBfcmVjdC50b3ApIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZWN0YW5nbGUgY3JlYXRlZCBieSB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiByZWN0YW5nbGUgb3IgbnVsbCwgaWYgdGhleSBkb24ndCBjb2xsaWRlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRJbnRlcnNlY3Rpb24oX3JlY3Q6IFJlY3RhbmdsZSk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIGlmICghdGhpcy5jb2xsaWRlcyhfcmVjdCkpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICBsZXQgaW50ZXJzZWN0aW9uOiBSZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKCk7XHJcbiAgICAgIGludGVyc2VjdGlvbi54ID0gTWF0aC5tYXgodGhpcy5sZWZ0LCBfcmVjdC5sZWZ0KTtcclxuICAgICAgaW50ZXJzZWN0aW9uLnkgPSBNYXRoLm1heCh0aGlzLnRvcCwgX3JlY3QudG9wKTtcclxuICAgICAgaW50ZXJzZWN0aW9uLndpZHRoID0gTWF0aC5taW4odGhpcy5yaWdodCwgX3JlY3QucmlnaHQpIC0gaW50ZXJzZWN0aW9uLng7XHJcbiAgICAgIGludGVyc2VjdGlvbi5oZWlnaHQgPSBNYXRoLm1pbih0aGlzLmJvdHRvbSwgX3JlY3QuYm90dG9tKSAtIGludGVyc2VjdGlvbi55O1xyXG5cclxuICAgICAgcmV0dXJuIGludGVyc2VjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICogUmV0dXJucyB0aGUgcmVjdGFuZ2xlIGNyZWF0ZWQgYnkgdGhlIGludGVyc2VjdGlvbiBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcmVjdGFuZ2xlIG9yIG51bGwsIGlmIHRoZXkgZG9uJ3QgY29sbGlkZVxyXG4gKi9cclxuICAgIHB1YmxpYyBjb3ZlcnMoX3JlY3Q6IFJlY3RhbmdsZSk6IGJvb2xlYW4ge1xyXG4gICAgICBpZiAodGhpcy5sZWZ0ID4gX3JlY3QubGVmdCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy5yaWdodCA8IF9yZWN0LnJpZ2h0KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLnRvcCA+IF9yZWN0LnRvcCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy5ib3R0b20gPCBfcmVjdC5ib3R0b20pIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcmVjdGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICBsZXQgcmVzdWx0OiBzdHJpbmcgPSBgxpIuUmVjdGFuZ2xlKHBvc2l0aW9uOiR7dGhpcy5wb3NpdGlvbi50b1N0cmluZygpfSwgc2l6ZToke3RoaXMuc2l6ZS50b1N0cmluZygpfWA7XHJcbiAgICAgIHJlc3VsdCArPSBgLCBsZWZ0OiR7dGhpcy5sZWZ0LnRvUHJlY2lzaW9uKDUpfSwgdG9wOiR7dGhpcy50b3AudG9QcmVjaXNpb24oNSl9LCByaWdodDoke3RoaXMucmlnaHQudG9QcmVjaXNpb24oNSl9LCBib3R0b206JHt0aGlzLmJvdHRvbS50b1ByZWNpc2lvbig1KX1gO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyogKi8gfVxyXG4gIH1cclxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlckJ1ZmZlck1hbmFnZXIudHNcIi8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlck1hbmFnZXJDb2F0LnRzXCIvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJSZW5kZXJNYW5hZ2VyTm9kZS50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVySW5qZWN0b3JTaGFkZXIudHNcIi8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlckluamVjdG9yTWVzaC50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVySW5qZWN0b3JDb21wb25lbnRQYXJ0aWNsZVN5c3RlbS50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi4vTWF0aC9SZWN0YW5nbGUudHNcIi8+XHJcblxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvLyBleHBvcnQgZGVjbGFyZSBsZXQgZnVkZ2VDb25maWc6IEdlbmVyYWw7XHJcblxyXG4gIGV4cG9ydCB0eXBlIFJlbmRlclRleHR1cmUgPSBXZWJHTFRleHR1cmU7XHJcblxyXG4gIGV4cG9ydCBlbnVtIEJMRU5EIHtcclxuICAgIE9QQVFVRSwgVFJBTlNQQVJFTlQsIEFERElUSVZFLCBTVUJUUkFDVElWRSwgTU9EVUxBVEVcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIERFUFRIX0ZVTkNUSU9OIHtcclxuICAgIE5FVkVSLCBMRVNTLCBFUVVBTCwgTEVTU19FUVVBTCwgR1JFQVRFUiwgTk9UX0VRVUFMLCBHUkVBVEVSX0VRVUFMLCBBTFdBWVNcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIFNIQURFUl9BVFRSSUJVVEUgeyAvLyBrZWVwIGluIHN5bmMgd2l0aCBzaGFkZXIgc291cmNlIGNvZGVcclxuICAgIFBPU0lUSU9OLFxyXG4gICAgTk9STUFMLFxyXG4gICAgVEVYQ09PUkRTLFxyXG4gICAgQ09MT1IsXHJcbiAgICBUQU5HRU5ULFxyXG4gICAgQk9ORVMsXHJcbiAgICBXRUlHSFRTXHJcbiAgfVxyXG5cclxuICAvLyB3ZSB3YW50IHR5cGUgaW5mZXJlbmNlIGhlcmUgc28gd2UgY2FuIHVzZSB2cyBjb2RlIHRvIHNlYXJjaCBmb3IgcmVmZXJlbmNlc1xyXG4gIGV4cG9ydCBjb25zdCBVTklGT1JNX0JMT0NLID0geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICBMSUdIVFM6IHtcclxuICAgICAgTkFNRTogXCJMaWdodHNcIixcclxuICAgICAgQklORElORzogMFxyXG4gICAgfSxcclxuICAgIENBTUVSQToge1xyXG4gICAgICBOQU1FOiBcIkNhbWVyYVwiLFxyXG4gICAgICBCSU5ESU5HOiAxXHJcbiAgICB9LFxyXG4gICAgTUFURVJJQUw6IHtcclxuICAgICAgTkFNRTogXCJNYXRlcmlhbFwiLFxyXG4gICAgICBCSU5ESU5HOiAyXHJcbiAgICB9LFxyXG4gICAgTk9ERToge1xyXG4gICAgICBOQU1FOiBcIk5vZGVcIixcclxuICAgICAgQklORElORzogM1xyXG4gICAgfSxcclxuICAgIFNLSU46IHtcclxuICAgICAgTkFNRTogXCJTa2luXCIsXHJcbiAgICAgIEJJTkRJTkc6IDRcclxuICAgIH0sXHJcbiAgICBGT0c6IHtcclxuICAgICAgTkFNRTogXCJGb2dcIixcclxuICAgICAgQklORElORzogNVxyXG4gICAgfVxyXG4gIH0gYXMgY29uc3Q7XHJcblxyXG4gIGV4cG9ydCBjb25zdCBURVhUVVJFX0xPQ0FUSU9OID0geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICBDT0xPUjoge1xyXG4gICAgICBVTklGT1JNOiBcInVfdGV4Q29sb3JcIixcclxuICAgICAgVU5JVDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMCxcclxuICAgICAgSU5ERVg6IDAgLy8gY291bGQgY29tcHV0ZSB0aGVzZSBieSBVTklUIC0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMCBcclxuICAgIH0sXHJcbiAgICBOT1JNQUw6IHtcclxuICAgICAgVU5JRk9STTogXCJ1X3RleE5vcm1hbFwiLFxyXG4gICAgICBVTklUOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkUxLFxyXG4gICAgICBJTkRFWDogMVxyXG4gICAgfSxcclxuICAgIFBBUlRJQ0xFOiB7XHJcbiAgICAgIFVOSUZPUk06IFwidV9wYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNcIixcclxuICAgICAgVU5JVDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMixcclxuICAgICAgSU5ERVg6IDJcclxuICAgIH0sXHJcbiAgICBURVhUOiB7XHJcbiAgICAgIFVOSUZPUk06IFwidV90ZXhUZXh0XCIsIC8vIFRPRE86IGFkZCB0ZXh0IHVuaWZvcm0gdG8gc2hhZGVyLi4uXHJcbiAgICAgIFVOSVQ6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTMsXHJcbiAgICAgIElOREVYOiAzXHJcbiAgICB9LFxyXG4gICAgVE9PTjoge1xyXG4gICAgICBVTklGT1JNOiBcInVfdGV4VG9vblwiLFxyXG4gICAgICBVTklUOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkU0LFxyXG4gICAgICBJTkRFWDogNFxyXG4gICAgfVxyXG4gIH0gYXMgY29uc3Q7XHJcblxyXG4gIC8qKlxyXG4gICAqIEJhc2UgY2xhc3MgZm9yIFJlbmRlck1hbmFnZXIsIGhhbmRsaW5nIHRoZSBjb25uZWN0aW9uIHRvIHRoZSByZW5kZXJpbmcgc3lzdGVtLCBpbiB0aGlzIGNhc2UgV2ViR0wuXHJcbiAgICogTWV0aG9kcyBhbmQgYXR0cmlidXRlcyBvZiB0aGlzIGNsYXNzIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LCBvbmx5IHRocm91Z2gge0BsaW5rIFJlbmRlcn1cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyV2ViR0wgZXh0ZW5kcyBFdmVudFRhcmdldFN0YXRpYyB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5pbml0aWFsaXplKCk7XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVjdFJlbmRlcjogUmVjdGFuZ2xlID0gUmVuZGVyV2ViR0wuZ2V0Q2FudmFzUmVjdCgpO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGZib01haW46IFdlYkdMRnJhbWVidWZmZXI7IC8vIHVzZWQgZm9yIGZvcndhcmQgcmVuZGVyaW5nIHBhc3NlcywgZS5nLiBvcGFxdWUgYW5kIHRyYW5zcGFyZW50IG9iamVjdHNcclxuICAgIHByaXZhdGUgc3RhdGljIGZib1Bvc3Q6IFdlYkdMRnJhbWVidWZmZXI7IC8vIHVzZWQgZm9yIHBvc3QtcHJvY2Vzc2luZyBlZmZlY3RzLCBhdHRhY2htZW50cyBnZXQgc3dhcHBlZCBmb3IgZGlmZmVyZW50IGVmZmVjdHNcclxuICAgIHByaXZhdGUgc3RhdGljIGZib1RhcmdldDogV2ViR0xGcmFtZWJ1ZmZlcjsgLy8gdXNlZCB0byByZW5kZXIgdGhlIGZpbmFsIGltYWdlIHRvLCB1c3VhbGx5IFwibnVsbFwiIHRvIHJlbmRlciB0byB0aGUgY2FudmFzIGRlZmF1bHQgZnJhbWVidWZmZXIuIFVzZWQgYnkgWFIgdG8gcmVuZGVyIHRvIHRoZSBYUldlYkdMTGF5ZXIgZnJhbWVidWZmZXIuXHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdGV4Q29sb3I6IFdlYkdMVGV4dHVyZTsgLy8gc3RvcmVzIHRoZSBjb2xvciBvZiBlYWNoIHBpeGVsIHJlbmRlcmVkXHJcbiAgICBwcml2YXRlIHN0YXRpYyB0ZXhQb3NpdGlvbjogV2ViR0xUZXh0dXJlOyAvLyBzdG9yZXMgdGhlIHBvc2l0aW9uIG9mIGVhY2ggcGl4ZWwgaW4gd29ybGQgc3BhY2VcclxuICAgIHByaXZhdGUgc3RhdGljIHRleE5vcm1hbDogV2ViR0xUZXh0dXJlOyAvLyBzdG9yZXMgdGhlIG5vcm1hbCBvZiBlYWNoIHBpeGVsIGluIHdvcmxkIHNwYWNlXHJcbiAgICBwcml2YXRlIHN0YXRpYyB0ZXhOb2lzZTogV2ViR0xUZXh0dXJlOyAvLyBzdG9yZXMgcmFuZG9tIHZhbHVlcyBmb3IgZWFjaCBwaXhlbCwgdXNlZCBmb3IgYW1iaWVudCBvY2NsdXNpb25cclxuICAgIHByaXZhdGUgc3RhdGljIHRleERlcHRoU3RlbmNpbDogV2ViR0xUZXh0dXJlOyAvLyBzdG9yZXMgdGhlIGRlcHRoIG9mIGVhY2ggcGl4ZWwsIGN1cnJlbnRseSB1bnVzZWRcclxuICAgIHByaXZhdGUgc3RhdGljIHRleEJsb29tU2FtcGxlczogV2ViR0xUZXh0dXJlW107IC8vIHN0b3JlcyBkb3duIGFuZCB1cHNhbXBsZWQgdmVyc2lvbnMgb2YgdGhlIGNvbG9yIHRleHR1cmUsIHVzZWQgZm9yIGJsb29tXHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdGV4RGVwdGhTdGVuY2lsT3V0bGluZTogV2ViR0xUZXh0dXJlO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGZib1BpY2s6IFdlYkdMQnVmZmVyO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdGV4UGljazogV2ViR0xUZXh0dXJlO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdGV4RGVwdGhQaWNrOiBXZWJHTFRleHR1cmU7XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdWJvQ2FtZXJhOiBXZWJHTEJ1ZmZlcjsgLy8gVE9ETzogdGVjaG5pY2FsbHkgd2Ugc2hvdWxkIGhhdmUgb25lIGJ1ZmZlciBwZXIgY2FtZXJhLCBhbmQgc3dpdGNoIGJldHdlZW4gdGhlbSwgc2ltaWxhciB0byBob3cgc2tlbGV0b25zIGFyZSBoYW5kbGVkLiBCdXQgaGF2aW5nIGNhbWVyYXMgb3V0c2lkZSBvZiBhbnkgc2NlbmUgcHJvdmVzIHRvIGJlIGEgcHJvYmxlbS4uLlxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdWJvTGlnaHRzOiBXZWJHTEJ1ZmZlcjtcclxuICAgIHByaXZhdGUgc3RhdGljIHVib0xpZ2h0c09mZnNldHM6IHsgW19uYW1lOiBzdHJpbmddOiBudW1iZXIgfTsgLy8gTWFwcyB0aGUgbmFtZXMgb2YgdGhlIHZhcmlhYmxlcyBpbnNpZGUgdGhlIExpZ2h0cyB1bmlmb3JtIGJsb2NrIHRvIHRoZWlyIHJlc3BlY3RpdmUgYnl0ZSBvZmZzZXRcclxuICAgIHByaXZhdGUgc3RhdGljIHVib0ZvZzogV2ViR0xCdWZmZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBvZmZzY3JlZW4tY2FudmFzLCByZW5kZXJpbmdjb250ZXh0IGFuZCBoYXJkd2FyZSB2aWV3cG9ydC4gQ2FsbCBvbmNlIGJlZm9yZSBjcmVhdGluZyBhbnkgcmVzb3VyY2VzIGxpa2UgbWVzaGVzIG9yIHNoYWRlcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpbml0aWFsaXplKF9hbnRpYWxpYXM/OiBib29sZWFuLCBfYWxwaGE/OiBib29sZWFuKTogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCB7XHJcbiAgICAgIGxldCBmdWRnZUNvbmZpZzogR2VuZXJhbCA9IFJlZmxlY3QuZ2V0KGdsb2JhbFRoaXMsIFwiZnVkZ2VDb25maWdcIikgfHwge307XHJcbiAgICAgIGNvbnN0IGFudGlhbGlhczogYm9vbGVhbiA9IChfYW50aWFsaWFzICE9IHVuZGVmaW5lZCkgPyBfYW50aWFsaWFzIDogZnVkZ2VDb25maWcuYW50aWFsaWFzIHx8IGZhbHNlO1xyXG4gICAgICBpZiAoYW50aWFsaWFzKVxyXG4gICAgICAgIERlYnVnLmVycm9yKFwiVGhlIGRlZmF1bHQgYW50aWFsaWFzaW5nIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgcG9zdC1wcm9jZXNzaW5nIGVmZmVjdHMgYW5kIHdpbGwgdGhlcmVmb3JlIGJlIGRpc2FibGVkLlwiKTtcclxuICAgICAgbGV0IGNvbnRleHRBdHRyaWJ1dGVzOiBXZWJHTENvbnRleHRBdHRyaWJ1dGVzID0geyAvLyBUT0RPOiBcclxuICAgICAgICBhbHBoYTogKF9hbHBoYSAhPSB1bmRlZmluZWQpID8gX2FscGhhIDogZnVkZ2VDb25maWcuYWxwaGEgfHwgZmFsc2UsXHJcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcclxuICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxyXG4gICAgICAgIHN0ZW5jaWw6IHRydWVcclxuICAgICAgfTtcclxuICAgICAgRGVidWcuZnVkZ2UoXCJJbml0aWFsaXplIFJlbmRlcldlYkdMXCIsIGNvbnRleHRBdHRyaWJ1dGVzKTtcclxuICAgICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcclxuICAgICAgY3JjMyA9IFJlbmRlcldlYkdMLmFzc2VydDxXZWJHTDJSZW5kZXJpbmdDb250ZXh0PihcclxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBjb250ZXh0QXR0cmlidXRlcyksXHJcbiAgICAgICAgXCJXZWJHTC1jb250ZXh0IGNvdWxkbid0IGJlIGNyZWF0ZWRcIlxyXG4gICAgICApO1xyXG4gICAgICBSZW5kZXJXZWJHTC5jcmMzID0gY3JjMztcclxuICAgICAgLy8gRW5hYmxlIGJhY2tmYWNlLSBhbmQgekJ1ZmZlci1jdWxsaW5nLlxyXG4gICAgICBjcmMzLmVuYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNVTExfRkFDRSk7XHJcbiAgICAgIGNyYzMuZW5hYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfVEVTVCk7XHJcbiAgICAgIGNyYzMuZW5hYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQkxFTkQpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5zZXRCbGVuZE1vZGUoQkxFTkQuVFJBTlNQQVJFTlQpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5yZWN0UmVuZGVyID0gUmVuZGVyV2ViR0wuZ2V0Q2FudmFzUmVjdCgpO1xyXG5cclxuICAgICAgUmVuZGVyV2ViR0wuaW5pdGlhbGl6ZUF0dGFjaG1lbnRzKCk7XHJcbiAgICAgIFJlbmRlcldlYkdMLmFkanVzdEF0dGFjaG1lbnRzKCk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTC5pbml0aWFsaXplQ2FtZXJhKCk7XHJcbiAgICAgIFJlbmRlcldlYkdMLmluaXRpYWxpemVMaWdodHMoKTtcclxuICAgICAgUmVuZGVyV2ViR0wuaW5pdGlhbGl6ZUZvZygpO1xyXG5cclxuICAgICAgcmV0dXJuIGNyYzM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENoZWNrcyB0aGUgZmlyc3QgcGFyYW1ldGVyIGFuZCB0aHJvd3MgYW4gZXhjZXB0aW9uIHdpdGggdGhlIFdlYkdMLWVycm9yY29kZSBpZiB0aGUgdmFsdWUgaXMgbnVsbFxyXG4gICAgKiBAcGFyYW0gX3ZhbHVlICB2YWx1ZSB0byBjaGVjayBhZ2FpbnN0IG51bGxcclxuICAgICogQHBhcmFtIF9tZXNzYWdlICBvcHRpb25hbCwgYWRkaXRpb25hbCBtZXNzYWdlIGZvciB0aGUgZXhjZXB0aW9uXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhc3NlcnQ8VD4oX3ZhbHVlOiBUIHwgbnVsbCwgX21lc3NhZ2U6IHN0cmluZyA9IFwiXCIpOiBUIHtcclxuICAgICAgaWYgKF92YWx1ZSA9PT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzc2VydGlvbiBmYWlsZWQuICR7X21lc3NhZ2V9LCBXZWJHTC1FcnJvcjogJHtSZW5kZXJXZWJHTC5jcmMzID8gUmVuZGVyV2ViR0wuY3JjMy5nZXRFcnJvcigpIDogXCJcIn1gKTtcclxuICAgICAgcmV0dXJuIF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgb2Zmc2NyZWVuLWNhbnZhc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENhbnZhcygpOiBIVE1MQ2FudmFzRWxlbWVudCB7XHJcbiAgICAgIHJldHVybiA8SFRNTENhbnZhc0VsZW1lbnQ+UmVuZGVyV2ViR0wuY3JjMy5jYW52YXM7IC8vIFRPRE86IGVuYWJsZSBPZmZzY3JlZW5DYW52YXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRSZW5kZXJpbmdDb250ZXh0KCk6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQge1xyXG4gICAgICByZXR1cm4gUmVuZGVyV2ViR0wuY3JjMztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHJlY3RhbmdsZSBkZXNjcmliaW5nIHRoZSBzaXplIG9mIHRoZSBvZmZzY3JlZW4tY2FudmFzLiB4LHkgYXJlIDAgYXQgYWxsIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENhbnZhc1JlY3QoKTogUmVjdGFuZ2xlIHtcclxuICAgICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSA8SFRNTENhbnZhc0VsZW1lbnQ+UmVuZGVyV2ViR0wuY3JjMy5jYW52YXM7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHNpemUgb2YgdGhlIG9mZnNjcmVlbi1jYW52YXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0Q2FudmFzU2l6ZShfd2lkdGg6IG51bWJlciwgX2hlaWdodDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMuY2FudmFzLndpZHRoID0gX3dpZHRoO1xyXG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLmNhbnZhcy5oZWlnaHQgPSBfaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBhcmVhIG9uIHRoZSBvZmZzY3JlZW4tY2FudmFzIHRvIHJlbmRlciB0aGUgY2FtZXJhIGltYWdlIHRvLlxyXG4gICAgICogQHBhcmFtIF9yZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0UmVuZGVyUmVjdGFuZ2xlKF9yZWN0OiBSZWN0YW5nbGUpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wucmVjdFJlbmRlci5zZXRQb3NpdGlvbkFuZFNpemUoX3JlY3QueCwgX3JlY3QueSwgX3JlY3Qud2lkdGgsIF9yZWN0LmhlaWdodCk7XHJcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMudmlld3BvcnQoX3JlY3QueCwgX3JlY3QueSwgX3JlY3Qud2lkdGgsIF9yZWN0LmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciB0aGUgb2Zmc2NyZWVuIHJlbmRlcmJ1ZmZlciB3aXRoIHRoZSBnaXZlbiB7QGxpbmsgQ29sb3J9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYXIoX2NvbG9yPzogQ29sb3IsIF9jb2xvcnM6IGJvb2xlYW4gPSB0cnVlLCBfZGVwdGg6IGJvb2xlYW4gPSB0cnVlLCBfc3RlbmNpbDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5jbGVhckNvbG9yKF9jb2xvcj8uciA/PyAwLCBfY29sb3I/LmcgPz8gMCwgX2NvbG9yPy5iID8/IDAsIF9jb2xvcj8uYSA/PyAxKTtcclxuICAgICAgbGV0IG1hc2s6IG51bWJlciA9IDA7XHJcbiAgICAgIGlmIChfY29sb3JzKVxyXG4gICAgICAgIG1hc2sgfD0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9CVUZGRVJfQklUO1xyXG4gICAgICBpZiAoX2RlcHRoKVxyXG4gICAgICAgIG1hc2sgfD0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9CVUZGRVJfQklUO1xyXG4gICAgICBpZiAoX3N0ZW5jaWwpXHJcbiAgICAgICAgbWFzayB8PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNURU5DSUxfQlVGRkVSX0JJVDtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5jbGVhcihtYXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZmluYWwgZnJhbWVidWZmZXIgdG8gcmVuZGVyIHRvLiBJZiBudWxsLCB0aGUgY2FudmFzIGRlZmF1bHQgZnJhbWVidWZmZXIgaXMgdXNlZC5cclxuICAgICAqIFVzZWQgYnkgWFIgdG8gcmVuZGVyIHRvIHRoZSBYUldlYkdMTGF5ZXIgZnJhbWVidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0RnJhbWVidWZmZXJUYXJnZXQoX2J1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlcik6IHZvaWQge1xyXG4gICAgICBSZW5kZXJXZWJHTC5mYm9UYXJnZXQgPSBfYnVmZmVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGZyYW1lYnVmZmVyIHRvIHRoZSBtYWluIGNvbG9yIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZXNldEZyYW1lYnVmZmVyKCk6IHZvaWQge1xyXG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBSZW5kZXJXZWJHTC5mYm9NYWluKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBhcmVhIG9uIHRoZSBvZmZzY3JlZW4tY2FudmFzIHRoZSBjYW1lcmEgaW1hZ2UgZ2V0cyByZW5kZXJlZCB0by5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRSZW5kZXJSZWN0YW5nbGUoKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIFJlbmRlcldlYkdMLnJlY3RSZW5kZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgLyBEaXNhYmxlIFdlYkdMcyBkZXB0aCB0ZXN0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldERlcHRoVGVzdChfdGVzdDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAoX3Rlc3QpXHJcbiAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5lbmFibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9URVNUKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMuZGlzYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX1RFU1QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjb21wYXJpc29uIG9wZXJhdGlvbiB1c2VkIHRvIHRlc3QgZnJhZ21lbnQgZGVwdGhzIGFnYWluc3QgY3VycmVudCBkZXB0aCBidWZmZXIgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldERlcHRoRnVuY3Rpb24oX2Z1bmN0aW9uOiBERVBUSF9GVU5DVElPTiA9IERFUFRIX0ZVTkNUSU9OLkxFU1MpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5kZXB0aEZ1bmMoX2Z1bmN0aW9uICsgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORVZFUik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgLyBEaXNhYmxlIFdlYkdMcyBzY2lzc29yIHRlc3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0U2Npc3NvclRlc3QoX3Rlc3Q6IGJvb2xlYW4sIF94PzogbnVtYmVyLCBfeT86IG51bWJlciwgX3dpZHRoPzogbnVtYmVyLCBfaGVpZ2h0PzogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGlmIChfdGVzdClcclxuICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmVuYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNDSVNTT1JfVEVTVCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmRpc2FibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TQ0lTU09SX1RFU1QpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLnNjaXNzb3IoX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHdoaWNoIGNvbG9yIGNvbXBvbmVudHMgdG8gZW5hYmxlIG9yIHRvIGRpc2FibGUgd2hlbiByZW5kZXJpbmcgdG8gYSBjb2xvciBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0Q29sb3JXcml0ZU1hc2soX3I6IGJvb2xlYW4sIF9nOiBib29sZWFuLCBfYjogYm9vbGVhbiwgX2E6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5jb2xvck1hc2soX3IsIF9nLCBfYiwgX2EpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IFdlYkdMcyB2aWV3cG9ydC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXRWaWV3cG9ydChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfd2lkdGg6IG51bWJlciwgX2hlaWdodDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMudmlld3BvcnQoX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBibGVuZCBtb2RlIHRvIHJlbmRlciB3aXRoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0QmxlbmRNb2RlKF9tb2RlOiBCTEVORCk6IHZvaWQge1xyXG4gICAgICBzd2l0Y2ggKF9tb2RlKSB7XHJcbiAgICAgICAgY2FzZSBCTEVORC5PUEFRVUU6XHJcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRXF1YXRpb24oV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GVU5DX0FERCk7XHJcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5aRVJPKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQkxFTkQuVFJBTlNQQVJFTlQ6XHJcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRXF1YXRpb24oV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GVU5DX0FERCk7XHJcbiAgICAgICAgICAvLyBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1JDX0FMUEhBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCTEVORC5BRERJVElWRTpcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRFcXVhdGlvbihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZVTkNfQUREKTtcclxuICAgICAgICAgIC8vIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuT05FLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORSk7XHJcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNSQ19BTFBIQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5PTkUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCTEVORC5TVUJUUkFDVElWRTpcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRFcXVhdGlvbihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZVTkNfUkVWRVJTRV9TVUJUUkFDVCk7XHJcbiAgICAgICAgICAvLyBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5PTkUpO1xyXG4gICAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5ibGVuZEZ1bmMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TUkNfQUxQSEEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuT05FKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQkxFTkQuTU9EVUxBVEU6IC8vIGNvbG9yIGdldHMgbXVsdGlwbGllZCwgdHJpZWQgdG8gY29weSB1bml0eXMgXCJQYXJ0aWNsZSBTaGFkZXI6IEJsZW5kaW5nIE9wdGlvbjogUmVuZGVyaW5nIE1vZGU6IE1vZHVsYXRlXCJcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRFcXVhdGlvbihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZVTkNfQUREKTtcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFNUX0NPTE9SLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCB0aGUgKHdvcmxkKSBwb3NpdGlvbiBmcm9tIHRoZSBwaXhlbCBhdCB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIHJlbmRlci1yZWN0YW5nbGUgKG9yaWdpbiB0b3AgbGVmdCkuXHJcbiAgICAgKiDimqDvuI8gQ0FVVElPTjogQ3VycmVudGx5IG9ubHkgd29ya3Mgd2hlbiBhbWJpZW50IG9jY2x1c2lvbiBpcyBhY3RpdmUgZHVlIHRvIHdyaXRpbmcgdG8gdGhlIHBvc2l0aW9uIHRleHR1cmUgYmVpbmcgZGlzYWJsZWQgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHBvaW50UmVuZGVyVG9Xb3JsZChfcmVuZGVyOiBWZWN0b3IyKTogVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGNvbnN0IGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XHJcbiAgICAgIGNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFJlbmRlcldlYkdMLmZib01haW4pO1xyXG4gICAgICBjcmMzLnJlYWRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9BVFRBQ0hNRU5UMSk7XHJcbiAgICAgIGNyYzMucmVhZFBpeGVscyhfcmVuZGVyLngsIFJlbmRlcldlYkdMLnJlY3RSZW5kZXIuaGVpZ2h0IC0gX3JlbmRlci55LCAxLCAxLCBjcmMzLlJHQkEsIGNyYzMuRkxPQVQsIGRhdGEpO1xyXG4gICAgICBjcmMzLnJlYWRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9BVFRBQ0hNRU5UMCk7XHJcbiAgICAgIGxldCBwb3NpdGlvbjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgcG9zaXRpb24uc2V0KGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0pO1xyXG4gICAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBkaWZmZXJlbnQgZnJhbWVidWZmZXJzIGFzd2VsbCBhcyB0ZXh0dXJlIGF0dGFjaG1lbnRzIHRvIHVzZSBhcyByZW5kZXIgdGFyZ2V0c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGluaXRpYWxpemVBdHRhY2htZW50cygpOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmNyYzM7XHJcblxyXG4gICAgICBjcmMzLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIik7IC8vIFRPRE86IGRpc2FibGUgc3NhbyBpZiBub3Qgc3VwcG9ydGVkXHJcblxyXG4gICAgICBSZW5kZXJXZWJHTC5mYm9NYWluID0gUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMRnJhbWVidWZmZXI+KGNyYzMuY3JlYXRlRnJhbWVidWZmZXIoKSk7XHJcbiAgICAgIFJlbmRlcldlYkdMLmZib1Bvc3QgPSBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xGcmFtZWJ1ZmZlcj4oY3JjMy5jcmVhdGVGcmFtZWJ1ZmZlcigpKTtcclxuICAgICAgUmVuZGVyV2ViR0wuZmJvVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgUmVuZGVyV2ViR0wuZmJvUGljayA9IFJlbmRlcldlYkdMLmFzc2VydChjcmMzLmNyZWF0ZUZyYW1lYnVmZmVyKCkpO1xyXG5cclxuICAgICAgUmVuZGVyV2ViR0wudGV4Q29sb3IgPSBjcmVhdGVUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgUmVuZGVyV2ViR0wudGV4UG9zaXRpb24gPSBjcmVhdGVUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgUmVuZGVyV2ViR0wudGV4Tm9ybWFsID0gY3JlYXRlVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkxJTkVBUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgUmVuZGVyV2ViR0wudGV4RGVwdGhTdGVuY2lsID0gY3JlYXRlVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgIFJlbmRlcldlYkdMLnRleE5vaXNlID0gY3JlYXRlVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgIFJlbmRlcldlYkdMLnRleFBpY2sgPSBjcmVhdGVUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgUmVuZGVyV2ViR0wudGV4RGVwdGhQaWNrID0gY3JlYXRlVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTC50ZXhEZXB0aFN0ZW5jaWxPdXRsaW5lID0gY3JlYXRlVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTC50ZXhCbG9vbVNhbXBsZXMgPSBuZXcgQXJyYXkoNik7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBSZW5kZXJXZWJHTC50ZXhCbG9vbVNhbXBsZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgUmVuZGVyV2ViR0wudGV4Qmxvb21TYW1wbGVzW2ldID0gY3JlYXRlVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkxJTkVBUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKTtcclxuXHJcbiAgICAgIGNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFJlbmRlcldlYkdMLmZib01haW4pO1xyXG4gICAgICBjcmMzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0wudGV4Q29sb3IsIDApO1xyXG4gICAgICBjcmMzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0wudGV4UG9zaXRpb24sIDApO1xyXG4gICAgICBjcmMzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0wudGV4Tm9ybWFsLCAwKTtcclxuICAgICAgY3JjMy5mcmFtZWJ1ZmZlclRleHR1cmUyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBSZW5kZXJXZWJHTC50ZXhEZXB0aFN0ZW5jaWwsIDApO1xyXG5cclxuICAgICAgY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgUmVuZGVyV2ViR0wuZmJvUGljayk7XHJcbiAgICAgIGNyYzMuZnJhbWVidWZmZXJUZXh0dXJlMkQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9BVFRBQ0hNRU5UMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBSZW5kZXJXZWJHTC50ZXhQaWNrLCAwKTtcclxuICAgICAgY3JjMy5mcmFtZWJ1ZmZlclRleHR1cmUyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX0FUVEFDSE1FTlQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0wudGV4RGVwdGhQaWNrLCAwKTtcclxuXHJcbiAgICAgIGNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG5cclxuICAgICAgZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShfZmlsdGVyOiBudW1iZXIsIF93cmFwOiBudW1iZXIpOiBXZWJHTFRleHR1cmUge1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmU6IFdlYkdMVGV4dHVyZSA9IFJlbmRlcldlYkdMLmFzc2VydDxXZWJHTFRleHR1cmU+KGNyYzMuY3JlYXRlVGV4dHVyZSgpKTtcclxuICAgICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcbiAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01JTl9GSUxURVIsIF9maWx0ZXIpO1xyXG4gICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NQUdfRklMVEVSLCBfZmlsdGVyKTtcclxuICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfV1JBUF9TLCBfd3JhcCk7XHJcbiAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX1dSQVBfVCwgX3dyYXApO1xyXG4gICAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBudWxsKTtcclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0cyB0aGUgc2l6ZSBvZiB0aGUgZGlmZmVyZW50IHRleHR1cmUgYXR0YWNobWVudHMgKHJlbmRlciB0YXJnZXRzKSB0byB0aGUgY2FudmFzIHNpemVcclxuICAgICAqIOKaoO+4jyBDQVVUSU9OOiBFeHBlbnNpdmUgb3BlcmF0aW9uLCB1c2Ugb25seSB3aGVuIGNhbnZhcyBzaXplIGNoYW5nZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhZGp1c3RBdHRhY2htZW50cygpOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgY29uc3Qgd2lkdGg6IG51bWJlciA9IGNyYzMuY2FudmFzLndpZHRoIHx8IDE7XHJcbiAgICAgIGNvbnN0IGhlaWdodDogbnVtYmVyID0gY3JjMy5jYW52YXMuaGVpZ2h0IHx8IDE7XHJcblxyXG4gICAgICBjcmMzLmFjdGl2ZVRleHR1cmUoY3JjMy5URVhUVVJFMCk7XHJcblxyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0wudGV4Q29sb3IpO1xyXG4gICAgICBjcmMzLnRleEltYWdlMkQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIHdpZHRoLCBoZWlnaHQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9CWVRFLCBudWxsKTtcclxuXHJcbiAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBSZW5kZXJXZWJHTC50ZXhQb3NpdGlvbik7XHJcbiAgICAgIC8vIEluIHZpZXcgc3BhY2UgMTZGIHdvdWxkIGJlIHByZWNpc2UgZW5vdWdoLi4uIGJ1dCB3ZSB3YW50IHRvIHVzZSB3b3JsZCBzcGFjZSBmb3IgY2FsY3VsYXRpb25zXHJcbiAgICAgIGNyYzMudGV4SW1hZ2UyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQTMyRiwgd2lkdGgsIGhlaWdodCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FULCBudWxsKTtcclxuXHJcbiAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBSZW5kZXJXZWJHTC50ZXhOb3JtYWwpO1xyXG4gICAgICBjcmMzLnRleEltYWdlMkQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkExNkYsIHdpZHRoLCBoZWlnaHQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCwgbnVsbCk7XHJcblxyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0wudGV4RGVwdGhTdGVuY2lsKTtcclxuICAgICAgY3JjMy50ZXhJbWFnZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSDI0X1NURU5DSUw4LCB3aWR0aCwgaGVpZ2h0LCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX1NURU5DSUwsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfSU5UXzI0XzgsIG51bGwpO1xyXG5cclxuICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFJlbmRlcldlYkdMLnRleERlcHRoU3RlbmNpbE91dGxpbmUpO1xyXG4gICAgICBjcmMzLnRleEltYWdlMkQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIMjRfU1RFTkNJTDgsIHdpZHRoLCBoZWlnaHQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfU1RFTkNJTCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9JTlRfMjRfOCwgbnVsbCk7XHJcblxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwLCBkaXZpc29yOiBudW1iZXIgPSAxOyBpIDwgUmVuZGVyV2ViR0wudGV4Qmxvb21TYW1wbGVzLmxlbmd0aDsgaSsrLCBkaXZpc29yICo9IDIpIHtcclxuICAgICAgICBsZXQgd2lkdGg6IG51bWJlciA9IE1hdGgubWF4KE1hdGgucm91bmQoY3JjMy5jYW52YXMud2lkdGggLyBkaXZpc29yKSwgMSk7XHJcbiAgICAgICAgbGV0IGhlaWdodDogbnVtYmVyID0gTWF0aC5tYXgoTWF0aC5yb3VuZChjcmMzLmNhbnZhcy5oZWlnaHQgLyBkaXZpc29yKSwgMSk7XHJcbiAgICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFJlbmRlcldlYkdMLnRleEJsb29tU2FtcGxlc1tpXSk7XHJcbiAgICAgICAgY3JjMy50ZXhJbWFnZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCB3aWR0aCwgaGVpZ2h0LCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfQllURSwgbnVsbCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG5WYWx1ZXM6IG51bWJlciA9IHdpZHRoICogaGVpZ2h0ICogNDtcclxuICAgICAgY29uc3Qgbm9pc2VEYXRhOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoblZhbHVlcyk7XHJcblxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgblZhbHVlczsgaSArPSA0KSB7XHJcbiAgICAgICAgbm9pc2VEYXRhW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcclxuICAgICAgICBub2lzZURhdGFbaSArIDFdID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcclxuICAgICAgICBub2lzZURhdGFbaSArIDJdID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcclxuICAgICAgICBub2lzZURhdGFbaSArIDNdID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY3JjMy5iaW5kVGV4dHVyZShjcmMzLlRFWFRVUkVfMkQsIFJlbmRlcldlYkdMLnRleE5vaXNlKTtcclxuICAgICAgY3JjMy50ZXhJbWFnZTJEKGNyYzMuVEVYVFVSRV8yRCwgMCwgY3JjMy5SR0JBLCB3aWR0aCwgaGVpZ2h0LCAwLCBjcmMzLlJHQkEsIGNyYzMuVU5TSUdORURfQllURSwgbm9pc2VEYXRhKTtcclxuICAgICAgY3JjMy5iaW5kVGV4dHVyZShjcmMzLlRFWFRVUkVfMkQsIG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVmZmVyIHRoZSBjYW1lcmEgZGF0YSBpbnRvIHRoZSBjYW1lcmEgdWJvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYnVmZmVyQ2FtZXJhKF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSk6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjb25zdCBtdHhWaWV3OiBNYXRyaXg0eDQgPSBfY21wQ2FtZXJhLm10eENhbWVyYUludmVyc2U7XHJcbiAgICAgIGNvbnN0IG10eFByb2plY3Rpb246IE1hdHJpeDR4NCA9IF9jbXBDYW1lcmEubXR4UHJvamVjdGlvbjtcclxuICAgICAgY29uc3QgbXR4Vmlld1Byb2plY3Rpb246IE1hdHJpeDR4NCA9IF9jbXBDYW1lcmEubXR4V29ybGRUb1ZpZXc7XHJcbiAgICAgIGNvbnN0IHZjdFBvc2l0aW9uOiBWZWN0b3IzID0gX2NtcENhbWVyYS5tdHhXb3JsZC50cmFuc2xhdGlvbjtcclxuXHJcbiAgICAgIGNvbnN0IGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMTYgKyAxNiArIDE2ICsgMyk7XHJcbiAgICAgIGRhdGEuc2V0KG10eFZpZXcuZ2V0KCksIDApO1xyXG4gICAgICBkYXRhLnNldChtdHhQcm9qZWN0aW9uLmdldCgpLCAxNik7XHJcbiAgICAgIGRhdGEuc2V0KG10eFZpZXdQcm9qZWN0aW9uLmdldCgpLCAzMik7XHJcbiAgICAgIGRhdGEuc2V0KHZjdFBvc2l0aW9uLmdldCgpLCA0OCk7XHJcblxyXG4gICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgUmVuZGVyV2ViR0wudWJvQ2FtZXJhKTtcclxuICAgICAgY3JjMy5idWZmZXJEYXRhKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIGRhdGEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFlOQU1JQ19EUkFXKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHVzZU5vZGVVbmlmb3Jtcyhfc2hhZGVyOiBTaGFkZXJJbnRlcmZhY2UsIF9tdHhXb3JsZDogTWF0cml4NHg0LCBfbXR4UGl2b3Q6IE1hdHJpeDN4MywgX2NvbG9yOiBDb2xvciwgX2lkPzogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5jcmMzO1xyXG5cclxuICAgICAgbGV0IHVuaWZvcm06IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gX3NoYWRlci51bmlmb3Jtc1tcInVfbXR4TWVzaFRvV29ybGRcIl07XHJcbiAgICAgIGlmICh1bmlmb3JtICYmIF9tdHhXb3JsZClcclxuICAgICAgICBjcmMzLnVuaWZvcm1NYXRyaXg0ZnYodW5pZm9ybSwgZmFsc2UsIF9tdHhXb3JsZC5nZXREYXRhKCkpO1xyXG5cclxuICAgICAgdW5pZm9ybSA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X210eFBpdm90XCJdO1xyXG4gICAgICBpZiAodW5pZm9ybSAmJiBfbXR4UGl2b3QpXHJcbiAgICAgICAgY3JjMy51bmlmb3JtTWF0cml4M2Z2KF9zaGFkZXIudW5pZm9ybXNbXCJ1X210eFBpdm90XCJdLCBmYWxzZSwgX210eFBpdm90LmdldERhdGEoKSk7XHJcblxyXG4gICAgICB1bmlmb3JtID0gX3NoYWRlci51bmlmb3Jtc1tcInVfdmN0Q29sb3JQcmltYXJ5XCJdO1xyXG4gICAgICBpZiAodW5pZm9ybSAmJiBfY29sb3IpXHJcbiAgICAgICAgY3JjMy51bmlmb3JtNGZ2KHVuaWZvcm0sIF9jb2xvci5nZXQoKSk7XHJcblxyXG4gICAgICB1bmlmb3JtID0gX3NoYWRlci51bmlmb3Jtc1tcInVfaWRcIl07XHJcbiAgICAgIGlmICh1bmlmb3JtKVxyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMudW5pZm9ybTFpKHVuaWZvcm0sIF9pZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFBpY2tpbmdcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB3aXRoIGEge0BsaW5rIFBpY2tlcn0tY2FtZXJhLCB0aGlzIG1ldGhvZCByZW5kZXJzIG9uZSBwaXhlbCB3aXRoIHBpY2tpbmcgaW5mb3JtYXRpb24gXHJcbiAgICAgKiBmb3IgZWFjaCBwaWNrYWJsZSBvYmplY3QgaW4gdGhlIGxpbmUgb2Ygc2lnaHQgYW5kIHJldHVybnMgdGhhdCBhcyBhbiB1bnNvcnRlZCBhcnJheSBvZiB7QGxpbmsgUGlja31zLlxyXG4gICAgICogVGhlIGZ1bmN0aW9uIHRvIHJlbmRlciB0aGUgb2JqZWN0cyBpbnRvIHRoZSBwaWNrIGJ1ZmZlciBtdXN0IGJlIHByb3ZpZGVkIGJ5IHRoZSBjYWxsZXIuXHJcbiAgICAgKiBAcGFyYW0gX3BpY2sgVGhlIGZ1bmN0aW9uIHdoaWNoIHJlbmRlcnMgb2JqZWN0cyBpbnRvIHRoZSBwaWNrIGJ1ZmZlci4gUmV0dXJucyBhIHtAbGluayBQaWNrfSBmb3IgZWFjaCByZW5kZXJlZCBvYmplY3QuIFxyXG4gICAgICogKipNVVNUKiogdXNlIHtAbGluayBTaGFkZXJQaWNrfSBvciB7QGxpbmsgU2hhZGVyUGlja1RleHR1cmVkfSB0byByZW5kZXIgb2JqZWN0cy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBwaWNrRnJvbTxUPihfZnJvbTogVFtdLCBfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEsIF9waWNrOiAoX2Zyb206IFRbXSwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKSA9PiBQaWNrW10pOiBQaWNrW10geyAvLyBUT0RPOiBzZWUgaWYgdGhpcmQgcGFyYW1ldGVyIF93b3JsZD86IE1hdHJpeDR4NCB3b3VsZCBiZSB1c2VmdWxsXHJcbiAgICAgIGNvbnN0IHNpemU6IG51bWJlciA9IE1hdGguY2VpbChNYXRoLnNxcnQoX2Zyb20ubGVuZ3RoKSk7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICAvLyBhZGp1c3QgcGljayBidWZmZXIgc2l6ZVxyXG4gICAgICBjcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBSZW5kZXJXZWJHTC5mYm9QaWNrKTtcclxuICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFJlbmRlcldlYkdMLnRleFBpY2spO1xyXG4gICAgICBjcmMzLnRleEltYWdlMkQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEzMkksIHNpemUsIHNpemUsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQV9JTlRFR0VSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LklOVCwgbnVsbCk7IC8vIGNvdWxkIHVzZSBSQkdBMzJGIGluIHRoZSBmdXR1cmUgZS5nLiBXZWJHUFVcclxuICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFJlbmRlcldlYkdMLnRleERlcHRoUGljayk7XHJcbiAgICAgIGNyYzMudGV4SW1hZ2UyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfQ09NUE9ORU5UMjQsIHNpemUsIHNpemUsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfQ09NUE9ORU5ULCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0lOVCwgbnVsbCk7XHJcbiAgICAgIGNyYzMuY2xlYXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9CVUZGRVJfQklUKTtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMLmJ1ZmZlckNhbWVyYShfY21wQ2FtZXJhKTtcclxuXHJcbiAgICAgIC8vIGJ1ZmZlciBzaXplIGludG8gcGljayBzaGFkZXJzXHJcbiAgICAgIFNoYWRlclBpY2sudXNlUHJvZ3JhbSgpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0yZnYoU2hhZGVyUGljay51bmlmb3Jtc1tcInVfdmN0U2l6ZVwiXSwgW3NpemUsIHNpemVdKTtcclxuXHJcbiAgICAgIFNoYWRlclBpY2tUZXh0dXJlZC51c2VQcm9ncmFtKCk7XHJcbiAgICAgIGNyYzMudW5pZm9ybTJmdihTaGFkZXJQaWNrVGV4dHVyZWQudW5pZm9ybXNbXCJ1X3ZjdFNpemVcIl0sIFtzaXplLCBzaXplXSk7XHJcblxyXG4gICAgICAvLyByZW5kZXIgcGlja3MgaW50byBwaWNrIGJ1ZmZlclxyXG4gICAgICBSZW5kZXJXZWJHTC5zZXRCbGVuZE1vZGUoQkxFTkQuT1BBUVVFKTtcclxuICAgICAgbGV0IHBpY2tzOiBQaWNrW10gPSBfcGljayhfZnJvbSwgX2NtcENhbWVyYSk7XHJcbiAgICAgIFJlbmRlcldlYkdMLnNldEJsZW5kTW9kZShCTEVORC5UUkFOU1BBUkVOVCk7XHJcblxyXG4gICAgICAvLyBnZXQvZmlsdGVyIHBpY2tzXHJcbiAgICAgIC8vIGV2YWx1YXRlIHRleHR1cmUgYnkgcmVhZGluZyBwaXhlbHMgYW5kIGV4dHJhY3QsIGNvbnZlcnQgYW5kIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIG1lc2ggaGl0XHJcbiAgICAgIGxldCBkYXRhOiBJbnQzMkFycmF5ID0gbmV3IEludDMyQXJyYXkoc2l6ZSAqIHNpemUgKiA0KTtcclxuICAgICAgUmVuZGVyLmNyYzMucmVhZFBpeGVscygwLCAwLCBzaXplLCBzaXplLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkFfSU5URUdFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5JTlQsIGRhdGEpO1xyXG5cclxuICAgICAgbGV0IHBpY2tlZDogUGlja1tdID0gW107XHJcbiAgICAgIGxldCBtdHhWaWV3VG9Xb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklOVkVSU0UoX2NtcENhbWVyYS5tdHhXb3JsZFRvVmlldyk7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBwaWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCB6QnVmZmVyOiBudW1iZXIgPSBkYXRhWzQgKiBpICsgMF0gKyBkYXRhWzQgKiBpICsgMV0gLyAyNTY7XHJcbiAgICAgICAgaWYgKHpCdWZmZXIgPT0gMCkgLy8gZGlzY2FyZCBtaXNzZXMgXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBsZXQgcGljazogUGljayA9IHBpY2tzW2ldO1xyXG4gICAgICAgIHBpY2suekJ1ZmZlciA9IGNvbnZlcnRJbnQzMnRvRmxvYXQzMihkYXRhLCA0ICogaSArIDApICogMiAtIDE7XHJcbiAgICAgICAgcGljay5jb2xvciA9IGNvbnZlcnRJbnQzMnRvQ29sb3IoZGF0YSwgNCAqIGkgKyAxKTtcclxuICAgICAgICBwaWNrLnRleHR1cmVVViA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjIpO1xyXG4gICAgICAgIHBpY2sudGV4dHVyZVVWLnNldChjb252ZXJ0SW50MzJ0b0Zsb2F0MzIoZGF0YSwgNCAqIGkgKyAyKSwgY29udmVydEludDMydG9GbG9hdDMyKGRhdGEsIDQgKiBpICsgMykpO1xyXG4gICAgICAgIHBpY2subXR4Vmlld1RvV29ybGQgPSBtdHhWaWV3VG9Xb3JsZDtcclxuXHJcbiAgICAgICAgcGlja2VkLnB1c2gocGljayk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFJlbmRlcldlYkdMLnJlc2V0RnJhbWVidWZmZXIoKTtcclxuXHJcbiAgICAgIHJldHVybiBwaWNrZWQ7XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb252ZXJ0SW50MzJ0b0Zsb2F0MzIoX2ludDMyQXJyYXk6IEludDMyQXJyYXksIF9pbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgYnVmZmVyOiBBcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcclxuICAgICAgICBsZXQgdmlldzogRGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcclxuICAgICAgICB2aWV3LnNldEludDMyKDAsIF9pbnQzMkFycmF5W19pbmRleF0pO1xyXG4gICAgICAgIHJldHVybiB2aWV3LmdldEZsb2F0MzIoMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbnZlcnRJbnQzMnRvQ29sb3IoX2ludDMyQXJyYXk6IEludDMyQXJyYXksIF9pbmRleDogbnVtYmVyKTogQ29sb3Ige1xyXG4gICAgICAgIGxldCBidWZmZXI6IEFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpO1xyXG4gICAgICAgIGxldCB2aWV3OiBEYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xyXG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgX2ludDMyQXJyYXlbX2luZGV4XSk7XHJcbiAgICAgICAgbGV0IGNvbG9yOiBDb2xvciA9IENvbG9yLkNTUyhgcmdiKCR7dmlldy5nZXRVaW50OCgwKX0sICR7dmlldy5nZXRVaW50OCgxKX0sICR7dmlldy5nZXRVaW50OCgyKX0pYCwgdmlldy5nZXRVaW50OCgzKSAvIDI1NSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVuZGVyIGZ1bmN0aW9uIGZvciBwaWNraW5nIG5vZGVzLiBcclxuICAgICAqIEEgY2FtZXJhcHJvamVjdGlvbiB3aXRoIGV4dHJlbWVseSBuYXJyb3cgZm9jdXMgaXMgdXNlZCwgc28gZWFjaCBwaXhlbCBvZiB0aGUgYnVmZmVyIHdvdWxkIGhvbGQgdGhlIHNhbWUgaW5mb3JtYXRpb24gZnJvbSB0aGUgbm9kZSwgIFxyXG4gICAgICogYnV0IHRoZSBmcmFnbWVudCBzaGFkZXIgcmVuZGVycyBvbmx5IDEgcGl4ZWwgZm9yIGVhY2ggbm9kZSBpbnRvIHRoZSByZW5kZXIgYnVmZmVyLCAxc3Qgbm9kZSB0byAxc3QgcGl4ZWwsIDJuZCBub2RlIHRvIHNlY29uZCBwaXhlbCBldGMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcGljayhfbm9kZXM6IE5vZGVbXSwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogUGlja1tdIHtcclxuICAgICAgbGV0IHBpY2tzOiBQaWNrW10gPSBbXTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBfbm9kZXMpIHtcclxuICAgICAgICBsZXQgY21wTWVzaDogQ29tcG9uZW50TWVzaCA9IG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpO1xyXG4gICAgICAgIGxldCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwgPSBub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNYXRlcmlhbCk7XHJcbiAgICAgICAgaWYgKCEoY21wTWVzaCAmJiBjbXBNZXNoLmlzQWN0aXZlICYmIGNtcE1hdGVyaWFsICYmIGNtcE1hdGVyaWFsLmlzQWN0aXZlKSlcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBsZXQgY29hdDogQ29hdCA9IGNtcE1hdGVyaWFsLm1hdGVyaWFsLmNvYXQ7XHJcbiAgICAgICAgbGV0IHNoYWRlcjogU2hhZGVySW50ZXJmYWNlID0gY29hdCBpbnN0YW5jZW9mIENvYXRUZXh0dXJlZCA/IFNoYWRlclBpY2tUZXh0dXJlZCA6IFNoYWRlclBpY2s7XHJcblxyXG4gICAgICAgIHNoYWRlci51c2VQcm9ncmFtKCk7XHJcbiAgICAgICAgY29hdC51c2VSZW5kZXJEYXRhKCk7XHJcblxyXG4gICAgICAgIGxldCBtdHhNZXNoVG9Xb3JsZDogTWF0cml4NHg0ID0gUmVuZGVyV2ViR0wuZmFjZUNhbWVyYShub2RlLCBjbXBNZXNoLm10eFdvcmxkLCBfY21wQ2FtZXJhLm10eFdvcmxkKTtcclxuICAgICAgICBSZW5kZXJXZWJHTC51c2VOb2RlVW5pZm9ybXMoc2hhZGVyLCBtdHhNZXNoVG9Xb3JsZCwgY21wTWF0ZXJpYWwubXR4UGl2b3QsIGNtcE1hdGVyaWFsLmNsclByaW1hcnksIHBpY2tzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlbmRlckJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMgPSBjbXBNZXNoLm1lc2gudXNlUmVuZGVyQnVmZmVycygpO1xyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMuZHJhd0VsZW1lbnRzKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLCByZW5kZXJCdWZmZXJzLm5JbmRpY2VzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX1NIT1JULCAwKTtcclxuXHJcbiAgICAgICAgcGlja3MucHVzaChuZXcgUGljayhub2RlKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBwaWNrcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgaW5pdGlhbGl6ZUNhbWVyYSgpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wudWJvQ2FtZXJhID0gUmVuZGVyV2ViR0wuYXNzZXJ0KFJlbmRlcldlYkdMLmNyYzMuY3JlYXRlQnVmZmVyKCkpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLmJpbmRCdWZmZXJCYXNlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIFVOSUZPUk1fQkxPQ0suQ0FNRVJBLkJJTkRJTkcsIFJlbmRlcldlYkdMLnVib0NhbWVyYSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBpbml0aWFsaXplRm9nKCk6IHZvaWQge1xyXG4gICAgICBSZW5kZXJXZWJHTC51Ym9Gb2cgPSBSZW5kZXJXZWJHTC5hc3NlcnQoUmVuZGVyV2ViR0wuY3JjMy5jcmVhdGVCdWZmZXIoKSk7XHJcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmluZEJ1ZmZlckJhc2UoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgVU5JRk9STV9CTE9DSy5GT0cuQklORElORywgUmVuZGVyV2ViR0wudWJvRm9nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1ZmZlciB0aGUgZm9nIHBhcmFtZXRlcnMgaW50byB0aGUgZm9nIHVib1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGJ1ZmZlckZvZyhfY21wRm9nOiBDb21wb25lbnRGb2cpOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHJcbiAgICAgIGNvbnN0IGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XHJcblxyXG4gICAgICBkYXRhWzBdID0gX2NtcEZvZz8uaXNBY3RpdmUgPyAxIDogMDtcclxuICAgICAgaWYgKF9jbXBGb2cpIHtcclxuICAgICAgICBkYXRhWzFdID0gX2NtcEZvZy5uZWFyO1xyXG4gICAgICAgIGRhdGFbMl0gPSBfY21wRm9nLmZhcjtcclxuICAgICAgICBkYXRhLnNldChfY21wRm9nLmNvbG9yLmdldCgpLCA0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYnVmZmVyIGRhdGEgdG8gYm91bmQgYnVmZmVyXHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCBSZW5kZXJXZWJHTC51Ym9Gb2cpO1xyXG4gICAgICBjcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgZGF0YSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5EWU5BTUlDX0RSQVcpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgaW5pdGlhbGl6ZUxpZ2h0cygpOiB2b2lkIHtcclxuICAgICAgY29uc3QgTUFYX0xJR0hUU19ESVJFQ1RJT05BTDogbnVtYmVyID0gMTU7IC8vIG11c3QgbWF0Y2ggdGhlIGRlZmluZSBpbiB0aGUgc2hhZGVyXHJcbiAgICAgIGNvbnN0IE1BWF9MSUdIVFNfUE9JTlQ6IG51bWJlciA9IDEwMDtcclxuICAgICAgY29uc3QgTUFYX0xJR0hUU19TUE9UOiBudW1iZXIgPSAxMDA7XHJcbiAgICAgIGNvbnN0IEJZVEVTX1BFUl9MSUdIVDogbnVtYmVyID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogKDQgKyAxNiArIDE2KTsgLy8gdmN0Q29sb3IgKyBtdHhTaGFwZSArIG10eFNoYXBlSW52ZXJzZSBhcyBmbG9hdDMycyBpbiBzaGFkZXJcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMLnVib0xpZ2h0c09mZnNldHMgPSB7fTtcclxuICAgICAgUmVuZGVyV2ViR0wudWJvTGlnaHRzT2Zmc2V0c1tcInVfbkxpZ2h0c0RpcmVjdGlvbmFsXCJdID0gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQgKiAwO1xyXG4gICAgICBSZW5kZXJXZWJHTC51Ym9MaWdodHNPZmZzZXRzW1widV9uTGlnaHRzUG9pbnRcIl0gPSBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIDE7XHJcbiAgICAgIFJlbmRlcldlYkdMLnVib0xpZ2h0c09mZnNldHNbXCJ1X25MaWdodHNTcG90XCJdID0gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQgKiAyO1xyXG4gICAgICBSZW5kZXJXZWJHTC51Ym9MaWdodHNPZmZzZXRzW1widV9hbWJpZW50XCJdID0gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQgKiA0O1xyXG4gICAgICBSZW5kZXJXZWJHTC51Ym9MaWdodHNPZmZzZXRzW1widV9kaXJlY3Rpb25hbFwiXSA9IFJlbmRlcldlYkdMLnVib0xpZ2h0c09mZnNldHNbXCJ1X2FtYmllbnRcIl0gKyBCWVRFU19QRVJfTElHSFQgKiAxO1xyXG4gICAgICBSZW5kZXJXZWJHTC51Ym9MaWdodHNPZmZzZXRzW1widV9wb2ludFwiXSA9IFJlbmRlcldlYkdMLnVib0xpZ2h0c09mZnNldHNbXCJ1X2RpcmVjdGlvbmFsXCJdICsgQllURVNfUEVSX0xJR0hUICogTUFYX0xJR0hUU19ESVJFQ1RJT05BTDtcclxuICAgICAgUmVuZGVyV2ViR0wudWJvTGlnaHRzT2Zmc2V0c1tcInVfc3BvdFwiXSA9IFJlbmRlcldlYkdMLnVib0xpZ2h0c09mZnNldHNbXCJ1X3BvaW50XCJdICsgQllURVNfUEVSX0xJR0hUICogTUFYX0xJR0hUU19QT0lOVDtcclxuXHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIFJlbmRlcldlYkdMLnVib0xpZ2h0cyA9IFJlbmRlcldlYkdMLmFzc2VydChjcmMzLmNyZWF0ZUJ1ZmZlcigpKTtcclxuICAgICAgY29uc3QgYmxvY2tTaXplOiBudW1iZXIgPSBSZW5kZXJXZWJHTC51Ym9MaWdodHNPZmZzZXRzW1widV9zcG90XCJdICsgQllURVNfUEVSX0xJR0hUICogTUFYX0xJR0hUU19TUE9UO1xyXG5cclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIFJlbmRlcldlYkdMLnVib0xpZ2h0cyk7XHJcbiAgICAgIGNyYzMuYnVmZmVyRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCBibG9ja1NpemUsIGNyYzMuRFlOQU1JQ19EUkFXKTtcclxuICAgICAgY3JjMy5iaW5kQnVmZmVyQmFzZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCBVTklGT1JNX0JMT0NLLkxJR0hUUy5CSU5ESU5HLCBSZW5kZXJXZWJHTC51Ym9MaWdodHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVmZmVyIHRoZSBkYXRhIGZyb20gdGhlIGxpZ2h0cyBpbiB0aGUgc2NlbmVncmFwaCBpbnRvIHRoZSBsaWdodHMgdWJvXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgYnVmZmVyTGlnaHRzKF9saWdodHM6IE1hcExpZ2h0VHlwZVRvTGlnaHRMaXN0KTogdm9pZCB7XHJcbiAgICAgIGlmICghUmVuZGVyV2ViR0wudWJvTGlnaHRzKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCBSZW5kZXJXZWJHTC51Ym9MaWdodHMpO1xyXG5cclxuICAgICAgLy8gZmlsbCB0aGUgYnVmZmVyIHdpdGggdGhlIGFtYmllbnQgbGlnaHQgY29sb3JcclxuICAgICAgbGV0IGNtcExpZ2h0czogUmVjeWNhYmxlQXJyYXk8Q29tcG9uZW50TGlnaHQ+ID0gX2xpZ2h0cy5nZXQoTGlnaHRBbWJpZW50KTtcclxuICAgICAgaWYgKGNtcExpZ2h0cykge1xyXG4gICAgICAgIGxldCBjbHJTdW06IENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xyXG4gICAgICAgIGZvciAobGV0IGNtcExpZ2h0IG9mIGNtcExpZ2h0cykge1xyXG4gICAgICAgICAgbGV0IGNsckxpZ2h0OiBDb2xvciA9IENvbG9yLlBST0RVQ1QoY21wTGlnaHQubGlnaHQuY29sb3IsIGNtcExpZ2h0LmxpZ2h0LmludGVuc2l0eSk7XHJcbiAgICAgICAgICBjbHJTdW0uYWRkKGNsckxpZ2h0KTtcclxuICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKGNsckxpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYnVmZmVyU3ViRGF0YShcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuVU5JRk9STV9CVUZGRVIsXHJcbiAgICAgICAgICBSZW5kZXJXZWJHTC51Ym9MaWdodHNPZmZzZXRzW1widV9hbWJpZW50XCJdLCAvLyBieXRlIG9mZnNldCBvZiB0aGUgc3RydWN0IExpZ2h0IFwidV9hbWJpZW50XCIgaW5zaWRlIHRoZSB1Ym9cclxuICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoY2xyU3VtLmdldCgpKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGZpbGwgdGhlIGJ1ZmZlciB3aXRoIHRoZSBsaWdodCBkYXRhIGZvciBlYWNoIGxpZ2h0IHR5cGVcclxuICAgICAgLy8gd2UgYXJlIGN1cnJlbnRseSBkb2luZyBhIG1heGltdW0gb2YgNCBjcmMzLmJ1ZmZlclN1YkRhdGEoKSBjYWxscywgYnV0IHdlIGNvdWxkIGRvIHRoaXMgaW4gb25lIGNhbGxcclxuICAgICAgYnVmZmVyTGlnaHRzT2ZUeXBlKExpZ2h0RGlyZWN0aW9uYWwsIFwidV9uTGlnaHRzRGlyZWN0aW9uYWxcIiwgXCJ1X2RpcmVjdGlvbmFsXCIpO1xyXG4gICAgICBidWZmZXJMaWdodHNPZlR5cGUoTGlnaHRQb2ludCwgXCJ1X25MaWdodHNQb2ludFwiLCBcInVfcG9pbnRcIik7XHJcbiAgICAgIGJ1ZmZlckxpZ2h0c09mVHlwZShMaWdodFNwb3QsIFwidV9uTGlnaHRzU3BvdFwiLCBcInVfc3BvdFwiKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGJ1ZmZlckxpZ2h0c09mVHlwZShfdHlwZTogVHlwZU9mTGlnaHQsIF91bmlOYW1lOiBzdHJpbmcsIF91bmlTdHJ1Y3Q6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGNtcExpZ2h0czogUmVjeWNhYmxlQXJyYXk8Q29tcG9uZW50TGlnaHQ+ID0gX2xpZ2h0cy5nZXQoX3R5cGUpO1xyXG5cclxuICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmJ1ZmZlclN1YkRhdGEoXHJcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLlVOSUZPUk1fQlVGRkVSLFxyXG4gICAgICAgICAgUmVuZGVyV2ViR0wudWJvTGlnaHRzT2Zmc2V0c1tfdW5pTmFtZV0sIC8vIGJ5dGUgb2Zmc2V0IG9mIHRoZSB1aW50IFwidV9uTGlnaHRzRGlyZWN0aW9uYWxcIiBpbnNpZGUgdGhlIHVib1xyXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoW2NtcExpZ2h0cz8ubGVuZ3RoID8/IDBdKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmICghY21wTGlnaHRzKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBsaWdodERhdGFTaXplOiBudW1iZXIgPSA0ICsgMTYgKyAxNjsgLy8gdmN0Q29sb3IgKyBtdHhTaGFwZSArIG10eFNoYXBlSW52ZXJzZSwgYXMgZmxvYXQzMnNcclxuICAgICAgICBjb25zdCBsaWdodHNEYXRhOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGNtcExpZ2h0cy5sZW5ndGggKiBsaWdodERhdGFTaXplKTtcclxuXHJcbiAgICAgICAgbGV0IGlMaWdodDogbnVtYmVyID0gMDtcclxuICAgICAgICBmb3IgKGxldCBjbXBMaWdodCBvZiBjbXBMaWdodHMpIHtcclxuICAgICAgICAgIGNvbnN0IGxpZ2h0RGF0YU9mZnNldDogbnVtYmVyID0gaUxpZ2h0ICogbGlnaHREYXRhU2l6ZTtcclxuXHJcbiAgICAgICAgICAvLyBzZXQgdmN0Q29sb3JcclxuICAgICAgICAgIGxldCBjbHJMaWdodDogQ29sb3IgPSBDb2xvci5QUk9EVUNUKGNtcExpZ2h0LmxpZ2h0LmNvbG9yLCBjbXBMaWdodC5saWdodC5pbnRlbnNpdHkpO1xyXG4gICAgICAgICAgbGlnaHRzRGF0YS5zZXQoY2xyTGlnaHQuZ2V0KCksIGxpZ2h0RGF0YU9mZnNldCArIDApO1xyXG4gICAgICAgICAgUmVjeWNsZXIuc3RvcmUoY2xyTGlnaHQpO1xyXG5cclxuICAgICAgICAgIC8vIHNldCBtdHhTaGFwZVxyXG4gICAgICAgICAgbGV0IG10eFRvdGFsOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUFJPRFVDVChjbXBMaWdodC5ub2RlLm10eFdvcmxkLCBjbXBMaWdodC5tdHhQaXZvdCk7XHJcbiAgICAgICAgICBpZiAoX3R5cGUgPT0gTGlnaHREaXJlY3Rpb25hbCkge1xyXG4gICAgICAgICAgICBsZXQgemVybzogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpO1xyXG4gICAgICAgICAgICBtdHhUb3RhbC50cmFuc2xhdGlvbiA9IHplcm87XHJcbiAgICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKHplcm8pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGxpZ2h0c0RhdGEuc2V0KG10eFRvdGFsLmdldCgpLCBsaWdodERhdGFPZmZzZXQgKyA0KTsgLy8gb2Zmc2V0ICsgdmN0Q29sb3JcclxuXHJcbiAgICAgICAgICAvLyBzZXQgbXR4U2hhcGVJbnZlcnNlXHJcbiAgICAgICAgICBpZiAoX3R5cGUgIT0gTGlnaHREaXJlY3Rpb25hbCkge1xyXG4gICAgICAgICAgICBsZXQgbXR4SW52ZXJzZTogTWF0cml4NHg0ID0gTWF0cml4NHg0LklOVkVSU0UobXR4VG90YWwpO1xyXG4gICAgICAgICAgICBsaWdodHNEYXRhLnNldChtdHhJbnZlcnNlLmdldCgpLCBsaWdodERhdGFPZmZzZXQgKyA0ICsgMTYpOyAvLyBvZmZzZXQgKyB2Y3RDb2xvciArIG10eFNoYXBlXHJcbiAgICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eEludmVyc2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFRvdGFsKTtcclxuICAgICAgICAgIGlMaWdodCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5idWZmZXJTdWJEYXRhKFxyXG4gICAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5VTklGT1JNX0JVRkZFUixcclxuICAgICAgICAgIFJlbmRlcldlYkdMLnVib0xpZ2h0c09mZnNldHNbX3VuaVN0cnVjdF0sIC8vIGJ5dGUgb2Zmc2V0IG9mIHRoZSBzdHJ1Y3QgTGlnaHQgYXJyYXkgaW5zaWRlIHRoZSB1Ym9cclxuICAgICAgICAgIGxpZ2h0c0RhdGFcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgZ2l2ZW4gbm9kZXMgdXNpbmcgdGhlIGdpdmVuIGNhbWVyYSBhbmQgdGhlIHBvc3QgcHJvY2VzcyBjb21wb25lbnRzIGF0dGFjaGVkIHRvIHRoZSBzYW1lIG5vZGUgYXMgdGhlIGNhbWVyYVxyXG4gICAgICogVGhlIG9wYXF1ZSBub2RlcyBhcmUgZHJhd24gZmlyc3QsIHRoZW4gc3NhbyBpcyBhcHBsaWVkLCB0aGVuIGJsb29tIGlzIGFwcGxpZWQsIHRoZW4gbm9kZXMgYWxwaGEgKHNvcnRGb3JBbHBoYSkgYXJlIGRyYXduLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRyYXdOb2Rlcyhfbm9kZXNPcGFxdWU6IEl0ZXJhYmxlPE5vZGU+LCBfbm9kZXNBbHBoYTogSXRlcmFibGU8Tm9kZT4sIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSk6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG5cclxuICAgICAgY29uc3QgY21wRm9nOiBDb21wb25lbnRGb2cgPSBfY21wQ2FtZXJhLm5vZGU/LmdldENvbXBvbmVudChDb21wb25lbnRGb2cpO1xyXG4gICAgICBjb25zdCBjbXBBbWJpZW50T2NjbHVzaW9uOiBDb21wb25lbnRBbWJpZW50T2NjbHVzaW9uID0gX2NtcENhbWVyYS5ub2RlPy5nZXRDb21wb25lbnQoQ29tcG9uZW50QW1iaWVudE9jY2x1c2lvbik7XHJcbiAgICAgIGNvbnN0IGNtcEJsb29tOiBDb21wb25lbnRCbG9vbSA9IF9jbXBDYW1lcmEubm9kZT8uZ2V0Q29tcG9uZW50KENvbXBvbmVudEJsb29tKTtcclxuICAgICAgY29uc3QgY21wT3V0bGluZTogQ29tcG9uZW50T3V0bGluZSA9IF9jbXBDYW1lcmEubm9kZT8uZ2V0Q29tcG9uZW50KENvbXBvbmVudE91dGxpbmUpO1xyXG5cclxuICAgICAgUmVuZGVyV2ViR0wuYnVmZmVyRm9nKGNtcEZvZyk7XHJcbiAgICAgIFJlbmRlcldlYkdMLmJ1ZmZlckNhbWVyYShfY21wQ2FtZXJhKTtcclxuXHJcbiAgICAgIC8vIG9wYXF1ZSBwYXNzIFxyXG4gICAgICAvLyBUT0RPOiB0aGluayBhYm91dCBkaXNhYmxpbmcgYmxlbmRpbmcgZm9yIGFsbCBvcGFxdWUgb2JqZWN0cywgdGhpcyBtaWdodCBpbXByb3ZlIHBlcmZvcm1hbmNlIFxyXG4gICAgICAvLyBhcyBvdGhlcndpc2UgdGhlIDMgY29sb3IgYXR0YWNobWVudHMgKGNvbG9yLCBwb3NpdGlvbiBhbmQgbm9ybWFscykgYWxsIG5lZWQgdG8gYmUgYmxlbmRlZFxyXG4gICAgICBjcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBSZW5kZXJXZWJHTC5mYm9NYWluKTtcclxuICAgICAgY3JjMy5kcmF3QnVmZmVycyhjbXBBbWJpZW50T2NjbHVzaW9uPy5pc0FjdGl2ZSA/IC8vIG9ubHkgdXNlIHBvc2l0aW9uIGFuZCBub3JtYWwgdGV4dHVyZXMgaWYgYW1iaWVudCBvY2NsdXNpb24gaXMgYWN0aXZlXHJcbiAgICAgICAgW1dlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDJdIDpcclxuICAgICAgICBbV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9BVFRBQ0hNRU5UMF1cclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNyYzMuZGlzYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkJMRU5EKTtcclxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBfbm9kZXNPcGFxdWUpXHJcbiAgICAgICAgUmVuZGVyV2ViR0wuZHJhd05vZGUobm9kZSwgX2NtcENhbWVyYSk7XHJcbiAgICAgIGNyYzMuZW5hYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQkxFTkQpO1xyXG5cclxuICAgICAgLy8gYW1iaWVudCBvY2NsdXNpb24gcGFzc1xyXG4gICAgICBpZiAoY21wQW1iaWVudE9jY2x1c2lvbj8uaXNBY3RpdmUpXHJcbiAgICAgICAgUmVuZGVyV2ViR0wuZHJhd0FtYmllbnRPY2NsdXNpb24oX2NtcENhbWVyYSwgY21wQW1iaWVudE9jY2x1c2lvbik7XHJcblxyXG4gICAgICAvLyB0cmFuc3BhcmVudCBwYXNzIFRPRE86IHRoaW5rIGFib3V0IGRpc2FibGluZyBkZXB0aCB3cml0ZSBmb3IgYWxsIHRyYW5zcGFyZW50IG9iamVjdHMgLT4gdGhpcyBtaWdodCBtYWtlIGRlcHRoIG1hc2sgb3B0aW9uIGluIGNvbXBvbmVudCBwYXJ0aWNsZSBzeXN0ZW0gb2Jzb2xldGVcclxuICAgICAgY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgUmVuZGVyV2ViR0wuZmJvTWFpbik7XHJcbiAgICAgIGNyYzMuZHJhd0J1ZmZlcnMoW1dlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDBdKTtcclxuXHJcbiAgICAgIC8vIGNyYzMuZGVwdGhNYXNrKGZhbHNlKTtcclxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBfbm9kZXNBbHBoYSlcclxuICAgICAgICBSZW5kZXJXZWJHTC5kcmF3Tm9kZShub2RlLCBfY21wQ2FtZXJhKTtcclxuICAgICAgLy8gY3JjMy5kZXB0aE1hc2sodHJ1ZSk7XHJcblxyXG4gICAgICAvLyBibG9vbSBwYXNzXHJcbiAgICAgIGlmIChjbXBCbG9vbT8uaXNBY3RpdmUpXHJcbiAgICAgICAgUmVuZGVyV2ViR0wuZHJhd0Jsb29tKGNtcEJsb29tKTtcclxuXHJcbiAgICAgIGlmIChjbXBPdXRsaW5lPy5pc0FjdGl2ZSlcclxuICAgICAgICBSZW5kZXJXZWJHTC5kcmF3T3V0bGluZShjbXBPdXRsaW5lLnNlbGVjdGlvbiwgX2NtcENhbWVyYSwgY21wT3V0bGluZSk7XHJcblxyXG4gICAgICAvLyBjb3B5IGZyYW1lYnVmZmVyIHRvIGNhbnZhc1xyXG4gICAgICBjcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJFQURfRlJBTUVCVUZGRVIsIFJlbmRlcldlYkdMLmZib01haW4pO1xyXG4gICAgICBjcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRSQVdfRlJBTUVCVUZGRVIsIFJlbmRlcldlYkdMLmZib1RhcmdldCk7XHJcbiAgICAgIGNyYzMuYmxpdEZyYW1lYnVmZmVyKDAsIDAsIGNyYzMuY2FudmFzLndpZHRoLCBjcmMzLmNhbnZhcy5oZWlnaHQsIDAsIDAsIGNyYzMuY2FudmFzLndpZHRoLCBjcmMzLmNhbnZhcy5oZWlnaHQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQlVGRkVSX0JJVCB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfQlVGRkVSX0JJVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBvY2NsdXNpb24gb3ZlciB0aGUgY29sb3ItYnVmZmVyLCB1c2luZyB0aGUgZ2l2ZW4gYW1iaWVudC1vY2NsdXNpb24tY29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBQZXJmb3JtYW5jZU1vbml0b3IubWVhc3VyZSgpXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRyYXdBbWJpZW50T2NjbHVzaW9uKF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX2NtcEFtYmllbnRPY2NsdXNpb246IENvbXBvbmVudEFtYmllbnRPY2NsdXNpb24pOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgU2hhZGVyQW1iaWVudE9jY2x1c2lvbi51c2VQcm9ncmFtKCk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTC5iaW5kVGV4dHVyZShTaGFkZXJBbWJpZW50T2NjbHVzaW9uLCBSZW5kZXJXZWJHTC50ZXhQb3NpdGlvbiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMCwgXCJ1X3RleFBvc2l0aW9uXCIpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5iaW5kVGV4dHVyZShTaGFkZXJBbWJpZW50T2NjbHVzaW9uLCBSZW5kZXJXZWJHTC50ZXhOb3JtYWwsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTEsIFwidV90ZXhOb3JtYWxcIik7XHJcbiAgICAgIFJlbmRlcldlYkdMLmJpbmRUZXh0dXJlKFNoYWRlckFtYmllbnRPY2NsdXNpb24sIFJlbmRlcldlYkdMLnRleE5vaXNlLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkUyLCBcInVfdGV4Tm9pc2VcIik7XHJcblxyXG4gICAgICBjcmMzLnVuaWZvcm0xZihTaGFkZXJBbWJpZW50T2NjbHVzaW9uLnVuaWZvcm1zW1widV9mTmVhclwiXSwgX2NtcENhbWVyYS5nZXROZWFyKCkpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0xZihTaGFkZXJBbWJpZW50T2NjbHVzaW9uLnVuaWZvcm1zW1widV9mRmFyXCJdLCBfY21wQ2FtZXJhLmdldEZhcigpKTtcclxuICAgICAgY3JjMy51bmlmb3JtMWYoU2hhZGVyQW1iaWVudE9jY2x1c2lvbi51bmlmb3Jtc1tcInVfZkJpYXNcIl0sIF9jbXBBbWJpZW50T2NjbHVzaW9uLmJpYXMpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0xZihTaGFkZXJBbWJpZW50T2NjbHVzaW9uLnVuaWZvcm1zW1widV9mU2FtcGxlUmFkaXVzXCJdLCBfY21wQW1iaWVudE9jY2x1c2lvbi5zYW1wbGVSYWRpdXMpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0xZihTaGFkZXJBbWJpZW50T2NjbHVzaW9uLnVuaWZvcm1zW1widV9mQXR0ZW51YXRpb25Db25zdGFudFwiXSwgX2NtcEFtYmllbnRPY2NsdXNpb24uYXR0ZW51YXRpb25Db25zdGFudCk7XHJcbiAgICAgIGNyYzMudW5pZm9ybTFmKFNoYWRlckFtYmllbnRPY2NsdXNpb24udW5pZm9ybXNbXCJ1X2ZBdHRlbnVhdGlvbkxpbmVhclwiXSwgX2NtcEFtYmllbnRPY2NsdXNpb24uYXR0ZW51YXRpb25MaW5lYXIpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0xZihTaGFkZXJBbWJpZW50T2NjbHVzaW9uLnVuaWZvcm1zW1widV9mQXR0ZW51YXRpb25RdWFkcmF0aWNcIl0sIF9jbXBBbWJpZW50T2NjbHVzaW9uLmF0dGVudWF0aW9uUXVhZHJhdGljKTtcclxuICAgICAgY3JjMy51bmlmb3JtMmYoU2hhZGVyQW1iaWVudE9jY2x1c2lvbi51bmlmb3Jtc1tcInVfdmN0UmVzb2x1dGlvblwiXSwgUmVuZGVyV2ViR0wuZ2V0Q2FudmFzKCkud2lkdGgsIFJlbmRlcldlYkdMLmdldENhbnZhcygpLmhlaWdodCk7XHJcbiAgICAgIGNyYzMudW5pZm9ybTNmdihTaGFkZXJBbWJpZW50T2NjbHVzaW9uLnVuaWZvcm1zW1widV92Y3RDYW1lcmFcIl0sIF9jbXBDYW1lcmEubXR4V29ybGQudHJhbnNsYXRpb24uZ2V0KCkpO1xyXG5cclxuICAgICAgY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgUmVuZGVyV2ViR0wuZmJvUG9zdCk7XHJcbiAgICAgIGNyYzMuZnJhbWVidWZmZXJUZXh0dXJlMkQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9BVFRBQ0hNRU5UMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBSZW5kZXJXZWJHTC50ZXhDb2xvciwgMCk7XHJcbiAgICAgIFJlbmRlcldlYkdMLnNldEJsZW5kTW9kZShCTEVORC5TVUJUUkFDVElWRSk7XHJcbiAgICAgIGNyYzMuZHJhd0FycmF5cyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUywgMCwgMyk7XHJcbiAgICAgIFJlbmRlcldlYkdMLnNldEJsZW5kTW9kZShCTEVORC5UUkFOU1BBUkVOVCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgYmxvb20tZWZmZWN0IG92ZXIgdGhlIGNvbG9yLWJ1ZmZlciwgdXNpbmcgdGhlIGdpdmVuIGJsb29tLWNvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBAUGVyZm9ybWFuY2VNb25pdG9yLm1lYXN1cmUoKVxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkcmF3Qmxvb20oX2NtcEJsb29tOiBDb21wb25lbnRCbG9vbSk6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBTaGFkZXJCbG9vbS51c2VQcm9ncmFtKCk7XHJcblxyXG4gICAgICAvLyBleHRyYWN0IGJyaWdodCBjb2xvcnMsIGNvdWxkIG1vdmUgdGhpcyB0byBtYWluIHJlbmRlciBwYXNzIHNvIHRoYXQgaW5kaXZpZHVhbCBvYmplY3RzIGNhbiBiZSBleGVtcHQgZnJvbSBibG9vbVxyXG4gICAgICBjcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBSZW5kZXJXZWJHTC5mYm9Qb3N0KTtcclxuICAgICAgY3JjMy5mcmFtZWJ1ZmZlclRleHR1cmUyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNPTE9SX0FUVEFDSE1FTlQwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFJlbmRlcldlYkdMLnRleEJsb29tU2FtcGxlc1swXSwgMCk7XHJcbiAgICAgIFJlbmRlcldlYkdMLmNsZWFyKCk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTC5iaW5kVGV4dHVyZShTaGFkZXJCbG9vbSwgUmVuZGVyV2ViR0wudGV4Q29sb3IsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTAsIFwidV90ZXhTb3VyY2VcIik7XHJcbiAgICAgIGNyYzMudW5pZm9ybTFmKFNoYWRlckJsb29tLnVuaWZvcm1zW1widV9mVGhyZXNob2xkXCJdLCBfY21wQmxvb20udGhyZXNob2xkKTtcclxuICAgICAgY3JjMy51bmlmb3JtMWkoU2hhZGVyQmxvb20udW5pZm9ybXNbXCJ1X2lNb2RlXCJdLCAwKTtcclxuICAgICAgY3JjMy5kcmF3QXJyYXlzKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLCAwLCAzKTtcclxuXHJcbiAgICAgIC8vIGRvd25zYW1wbGVcclxuICAgICAgY29uc3QgaXRlcmF0aW9uczogbnVtYmVyID0gUmVuZGVyV2ViR0wudGV4Qmxvb21TYW1wbGVzLmxlbmd0aDtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMSwgZGl2aXNvcjogbnVtYmVyID0gMjsgaSA8IGl0ZXJhdGlvbnM7IGkrKywgZGl2aXNvciAqPSAyKSB7XHJcbiAgICAgICAgbGV0IHdpZHRoOiBudW1iZXIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGNyYzMuY2FudmFzLndpZHRoIC8gZGl2aXNvciksIDEpO1xyXG4gICAgICAgIGxldCBoZWlnaHQ6IG51bWJlciA9IE1hdGgubWF4KE1hdGgucm91bmQoY3JjMy5jYW52YXMuaGVpZ2h0IC8gZGl2aXNvciksIDEpO1xyXG5cclxuICAgICAgICBjcmMzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0wudGV4Qmxvb21TYW1wbGVzW2ldLCAwKTtcclxuICAgICAgICBjcmMzLnZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICBSZW5kZXJXZWJHTC5jbGVhcigpO1xyXG5cclxuICAgICAgICBSZW5kZXJXZWJHTC5iaW5kVGV4dHVyZShTaGFkZXJCbG9vbSwgUmVuZGVyV2ViR0wudGV4Qmxvb21TYW1wbGVzW2kgLSAxXSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMCwgXCJ1X3RleFNvdXJjZVwiKTtcclxuICAgICAgICBjcmMzLnVuaWZvcm0xaShTaGFkZXJCbG9vbS51bmlmb3Jtc1tcInVfaU1vZGVcIl0sIDEpO1xyXG4gICAgICAgIGNyYzMudW5pZm9ybTJmKFNoYWRlckJsb29tLnVuaWZvcm1zW1widV92Y3RUZXhlbFwiXSwgMC41IC8gd2lkdGgsIDAuNSAvIGhlaWdodCk7IC8vIGhhbGYgdGV4ZWwgc2l6ZVxyXG4gICAgICAgIC8vIGNyYzMudW5pZm9ybTJmKFNoYWRlckJsb29tLnVuaWZvcm1zW1widV92Y3RSZXNvbHV0aW9uXCJdLCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgY3JjMy5kcmF3QXJyYXlzKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLCAwLCAzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgUmVuZGVyV2ViR0wuc2V0QmxlbmRNb2RlKEJMRU5ELkFERElUSVZFKTtcclxuXHJcbiAgICAgIC8vIHVwc2FtcGxlXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IGl0ZXJhdGlvbnMgLSAxLCBkaXZpc29yOiBudW1iZXIgPSAyICoqIChpdGVyYXRpb25zIC0gMik7IGkgPiAwOyBpLS0sIGRpdmlzb3IgLz0gMikge1xyXG4gICAgICAgIGxldCB3aWR0aDogbnVtYmVyID0gTWF0aC5tYXgoTWF0aC5yb3VuZChjcmMzLmNhbnZhcy53aWR0aCAvIGRpdmlzb3IpLCAxKTtcclxuICAgICAgICBsZXQgaGVpZ2h0OiBudW1iZXIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGNyYzMuY2FudmFzLmhlaWdodCAvIGRpdmlzb3IpLCAxKTtcclxuXHJcbiAgICAgICAgY3JjMy5mcmFtZWJ1ZmZlclRleHR1cmUyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNPTE9SX0FUVEFDSE1FTlQwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFJlbmRlcldlYkdMLnRleEJsb29tU2FtcGxlc1tpIC0gMV0sIDApO1xyXG4gICAgICAgIGNyYzMudmlld3BvcnQoMCwgMCwgTWF0aC5yb3VuZCh3aWR0aCksIE1hdGgucm91bmQoaGVpZ2h0KSk7XHJcblxyXG4gICAgICAgIFJlbmRlcldlYkdMLmJpbmRUZXh0dXJlKFNoYWRlckJsb29tLCBSZW5kZXJXZWJHTC50ZXhCbG9vbVNhbXBsZXNbaV0sIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTAsIFwidV90ZXhTb3VyY2VcIik7XHJcbiAgICAgICAgY3JjMy51bmlmb3JtMWkoU2hhZGVyQmxvb20udW5pZm9ybXNbXCJ1X2lNb2RlXCJdLCAyKTtcclxuICAgICAgICBjcmMzLnVuaWZvcm0yZihTaGFkZXJCbG9vbS51bmlmb3Jtc1tcInVfdmN0VGV4ZWxcIl0sIDAuNSAvIHdpZHRoLCAwLjUgLyBoZWlnaHQpOyAvLyBoYWxmIHRleGVsIHNpemVcclxuICAgICAgICAvLyBjcmMzLnVuaWZvcm0yZihTaGFkZXJCbG9vbS51bmlmb3Jtc1tcInVfdmN0UmVzb2x1dGlvblwiXSwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIGNyYzMuZHJhd0FycmF5cyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUywgMCwgMyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNyYzMudmlld3BvcnQoMCwgMCwgY3JjMy5jYW52YXMud2lkdGgsIGNyYzMuY2FudmFzLmhlaWdodCk7XHJcblxyXG4gICAgICBjcmMzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0wudGV4Q29sb3IsIDApO1xyXG4gICAgICBSZW5kZXJXZWJHTC5iaW5kVGV4dHVyZShTaGFkZXJCbG9vbSwgUmVuZGVyV2ViR0wudGV4Qmxvb21TYW1wbGVzWzBdLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkUwLCBcInVfdGV4U291cmNlXCIpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0xaShTaGFkZXJCbG9vbS51bmlmb3Jtc1tcInVfaU1vZGVcIl0sIDMpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0xZihTaGFkZXJCbG9vbS51bmlmb3Jtc1tcInVfZkludGVuc2l0eVwiXSwgX2NtcEJsb29tLmludGVuc2l0eSk7XHJcbiAgICAgIGNyYzMudW5pZm9ybTFmKFNoYWRlckJsb29tLnVuaWZvcm1zW1widV9mSGlnaGxpZ2h0RGVzYXR1cmF0aW9uXCJdLCBfY21wQmxvb20uaGlnaGxpZ2h0RGVzYXR1cmF0aW9uKTtcclxuICAgICAgY3JjMy5kcmF3QXJyYXlzKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLCAwLCAzKTtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMLnNldEJsZW5kTW9kZShCTEVORC5UUkFOU1BBUkVOVCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkcmF3T3V0bGluZShfbm9kZXM6IEl0ZXJhYmxlPE5vZGU+LCBfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEsIF9jbXBPdXRsaW5lOiBDb21wb25lbnRPdXRsaW5lKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBjcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBSZW5kZXJXZWJHTC5mYm9Qb3N0KTtcclxuXHJcbiAgICAgIGNyYzMuZnJhbWVidWZmZXJUZXh0dXJlMkQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9BVFRBQ0hNRU5UMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBudWxsLCAwKTtcclxuICAgICAgY3JjMy5mcmFtZWJ1ZmZlclRleHR1cmUyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBSZW5kZXJXZWJHTC50ZXhEZXB0aFN0ZW5jaWxPdXRsaW5lLCAwKTtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMLmNsZWFyKCk7XHJcblxyXG4gICAgICBjcmMzLmRpc2FibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5CTEVORCk7XHJcbiAgICAgIGZvciAobGV0IHNlbGVjdGVkIG9mIF9ub2RlcylcclxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc2VsZWN0ZWQpIHtcclxuICAgICAgICAgIGlmIChub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKT8uaXNBY3RpdmUgJiYgbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWF0ZXJpYWwpPy5pc0FjdGl2ZSlcclxuICAgICAgICAgICAgUmVuZGVyV2ViR0wuZHJhd05vZGUobm9kZSwgX2NtcENhbWVyYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICBjcmMzLmVuYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkJMRU5EKTtcclxuXHJcbiAgICAgIFNoYWRlck91dGxpbmUudXNlUHJvZ3JhbSgpO1xyXG4gICAgICBjcmMzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0wudGV4Q29sb3IsIDApO1xyXG4gICAgICBjcmMzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIG51bGwsIDApO1xyXG5cclxuICAgICAgY3JjMy5mcmFtZWJ1ZmZlclRleHR1cmUyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNPTE9SX0FUVEFDSE1FTlQyLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIG51bGwsIDApO1xyXG4gICAgICBjcmMzLmRyYXdCdWZmZXJzKFtXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNPTE9SX0FUVEFDSE1FTlQwXSk7XHJcbiAgICAgIFJlbmRlcldlYkdMLmJpbmRUZXh0dXJlKFNoYWRlck91dGxpbmUsIFJlbmRlcldlYkdMLnRleERlcHRoU3RlbmNpbE91dGxpbmUsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTAsIFwidV90ZXhEZXB0aE91dGxpbmVcIik7XHJcbiAgICAgIFJlbmRlcldlYkdMLmJpbmRUZXh0dXJlKFNoYWRlck91dGxpbmUsIFJlbmRlcldlYkdMLnRleERlcHRoU3RlbmNpbCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMSwgXCJ1X3RleERlcHRoU2NlbmVcIik7XHJcblxyXG5cclxuICAgICAgY3JjMy51bmlmb3JtNGZ2KFNoYWRlck91dGxpbmUudW5pZm9ybXNbXCJ1X3ZjdENvbG9yXCJdLCBfY21wT3V0bGluZS5jb2xvci5nZXQoKSk7XHJcbiAgICAgIGNyYzMudW5pZm9ybTRmdihTaGFkZXJPdXRsaW5lLnVuaWZvcm1zW1widV92Y3RDb2xvck9jY2x1ZGVkXCJdLCBfY21wT3V0bGluZS5jb2xvck9jY2x1ZGVkLmdldCgpKTtcclxuXHJcbiAgICAgIGNyYzMudW5pZm9ybTJmKFNoYWRlck91dGxpbmUudW5pZm9ybXNbXCJ1X3ZjdFRleGVsXCJdLCAxIC8gTWF0aC5yb3VuZChjcmMzLmNhbnZhcy53aWR0aCksIDEgLyBNYXRoLnJvdW5kKGNyYzMuY2FudmFzLmhlaWdodCkpOyAvLyBoYWxmIHRleGVsIHNpemVcclxuXHJcbiAgICAgIGNyYzMuZHJhd0FycmF5cyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUywgMCwgMyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgbWVzaCBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIGluZm9zIGFuZCB0aGUgY29tcGxldGUgcHJvamVjdGlvbiBtYXRyaXhcclxuICAgICovXHJcbiAgICAvLyBAUGVyZm9ybWFuY2VNb25pdG9yLm1lYXN1cmUoXCJSZW5kZXIuZHJhd05vZGVcIilcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZHJhd05vZGUoX25vZGU6IE5vZGUsIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSk6IHZvaWQge1xyXG4gICAgICAvLyBQZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNZWFzdXJlKFwiUmVuZGVyLmRyYXdOb2RlIGdldCBjb21wb25lbnRzXCIpO1xyXG4gICAgICBsZXQgY21wTWVzaDogQ29tcG9uZW50TWVzaCA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuICAgICAgbGV0IGNtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNYXRlcmlhbCk7XHJcbiAgICAgIGxldCBjbXBUZXh0OiBDb21wb25lbnRUZXh0ID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudFRleHQpO1xyXG4gICAgICBsZXQgY21wRmFjZUNhbWVyYTogQ29tcG9uZW50RmFjZUNhbWVyYSA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRGYWNlQ2FtZXJhKTtcclxuICAgICAgbGV0IGNtcFBhcnRpY2xlU3lzdGVtOiBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSk7XHJcbiAgICAgIGxldCBkcmF3UGFydGljbGVzOiBib29sZWFuID0gY21wUGFydGljbGVTeXN0ZW0/LmlzQWN0aXZlO1xyXG4gICAgICBsZXQgc2hhZGVyOiBTaGFkZXJJbnRlcmZhY2UgPSBjbXBNYXRlcmlhbC5tYXRlcmlhbC5nZXRTaGFkZXIoKTtcclxuICAgICAgaWYgKGRyYXdQYXJ0aWNsZXMpXHJcbiAgICAgICAgc2hhZGVyID0gY21wUGFydGljbGVTeXN0ZW0ucGFydGljbGVTeXN0ZW0uZ2V0U2hhZGVyRnJvbShzaGFkZXIpO1xyXG4gICAgICAvLyBQZXJmb3JtYW5jZU1vbml0b3IuZW5kTWVhc3VyZShcIlJlbmRlci5kcmF3Tm9kZSBnZXQgY29tcG9uZW50c1wiKTtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE1lYXN1cmUoXCJSZW5kZXIuZHJhd05vZGUgdXNlUHJvZ3JhbVwiKTtcclxuICAgICAgc2hhZGVyLnVzZVByb2dyYW0oKTtcclxuICAgICAgLy8gUGVyZm9ybWFuY2VNb25pdG9yLmVuZE1lYXN1cmUoXCJSZW5kZXIuZHJhd05vZGUgdXNlUHJvZ3JhbVwiKTtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE1lYXN1cmUoXCJSZW5kZXIuZHJhd05vZGUgdXNlUmVuZGVyRGF0YVwiKTtcclxuICAgICAgY21wTWF0ZXJpYWwubWF0ZXJpYWwuY29hdC51c2VSZW5kZXJEYXRhKCk7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtYW5jZU1vbml0b3IuZW5kTWVhc3VyZShcIlJlbmRlci5kcmF3Tm9kZSB1c2VSZW5kZXJEYXRhXCIpO1xyXG5cclxuICAgICAgaWYgKGNtcE1lc2guc2tlbGV0b24/LmlzQWN0aXZlKVxyXG4gICAgICAgIGNtcE1lc2guc2tlbGV0b24udXNlUmVuZGVyQnVmZmVyKCk7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNZWFzdXJlKFwiUmVuZGVyLmRyYXdOb2RlIG90aGVyXCIpO1xyXG5cclxuICAgICAgbGV0IG10eFdvcmxkT3ZlcnJpZGU6IE1hdHJpeDR4NDtcclxuXHJcbiAgICAgIGlmIChjbXBUZXh0Py5pc0FjdGl2ZSlcclxuICAgICAgICBtdHhXb3JsZE92ZXJyaWRlID0gY21wVGV4dC51c2VSZW5kZXJEYXRhKGNtcE1lc2gubXR4V29ybGQsIF9jbXBDYW1lcmEpO1xyXG5cclxuICAgICAgaWYgKGNtcEZhY2VDYW1lcmE/LmlzQWN0aXZlICYmICFkcmF3UGFydGljbGVzKVxyXG4gICAgICAgIG10eFdvcmxkT3ZlcnJpZGUgPSBSZW5kZXJXZWJHTC5mYWNlQ2FtZXJhKF9ub2RlLCBtdHhXb3JsZE92ZXJyaWRlID8/IGNtcE1lc2gubXR4V29ybGQsIF9jbXBDYW1lcmEubXR4V29ybGQpO1xyXG5cclxuICAgICAgLy8gUmVuZGVyV2ViR0wudXNlUmVuZGVyRGF0YU5vZGUoX25vZGUsIG10eFdvcmxkT3ZlcnJpZGUpO1xyXG4gICAgICBfbm9kZS51c2VSZW5kZXJEYXRhKG10eFdvcmxkT3ZlcnJpZGUpO1xyXG4gICAgICAvLyBQZXJmb3JtYW5jZU1vbml0b3IuZW5kTWVhc3VyZShcIlJlbmRlci5kcmF3Tm9kZSBvdGhlclwiKTtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE1lYXN1cmUoXCJSZW5kZXIuZHJhd05vZGUgZ2V0UmVuZGVyQnVmZmVyc1wiKTtcclxuICAgICAgY29uc3QgcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVycyA9IGNtcE1lc2gubWVzaC51c2VSZW5kZXJCdWZmZXJzKCk7IC8vIFRPRE86IGZpbmQgb3V0IHdoeSB0aGlzIGdldHMgc2xvd2VyIHRoZSBtb3JlIGRpZmZlcmVudCBtZXNoZXMgYXJlIGRyYXduPz8/XHJcbiAgICAgIC8vIFBlcmZvcm1hbmNlTW9uaXRvci5lbmRNZWFzdXJlKFwiUmVuZGVyLmRyYXdOb2RlIGdldFJlbmRlckJ1ZmZlcnNcIik7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNZWFzdXJlKFwiUmVuZGVyLmRyYXdOb2RlIGRyYXdFbGVtZW50c1wiKTtcclxuICAgICAgaWYgKGRyYXdQYXJ0aWNsZXMpXHJcbiAgICAgICAgUmVuZGVyV2ViR0wuZHJhd1BhcnRpY2xlcyhjbXBQYXJ0aWNsZVN5c3RlbSwgcmVuZGVyQnVmZmVycy5uSW5kaWNlcyk7XHJcbiAgICAgIGVsc2UgXHJcbiAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5kcmF3RWxlbWVudHMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsIHJlbmRlckJ1ZmZlcnMubkluZGljZXMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgICBcclxuICAgICAgLy8gUGVyZm9ybWFuY2VNb25pdG9yLmVuZE1lYXN1cmUoXCJSZW5kZXIuZHJhd05vZGUgZHJhd0VsZW1lbnRzXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZHJhd1BhcnRpY2xlcyhfY21wUGFydGljbGVTeXN0ZW06IENvbXBvbmVudFBhcnRpY2xlU3lzdGVtLCBfbkluZGljZXM6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG5cclxuICAgICAgX2NtcFBhcnRpY2xlU3lzdGVtLnVzZVJlbmRlckRhdGEoKTtcclxuICAgICAgY3JjMy5kZXB0aE1hc2soX2NtcFBhcnRpY2xlU3lzdGVtLmRlcHRoTWFzayk7XHJcbiAgICAgIFJlbmRlcldlYkdMLnNldEJsZW5kTW9kZShfY21wUGFydGljbGVTeXN0ZW0uYmxlbmRNb2RlKTtcclxuICAgICAgY3JjMy5kcmF3RWxlbWVudHNJbnN0YW5jZWQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsIF9uSW5kaWNlcywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9TSE9SVCwgMCwgX2NtcFBhcnRpY2xlU3lzdGVtLnNpemUpO1xyXG4gICAgICBjcmMzLmRlcHRoTWFzayh0cnVlKTtcclxuICAgICAgUmVuZGVyV2ViR0wuc2V0QmxlbmRNb2RlKEJMRU5ELlRSQU5TUEFSRU5UKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBmYWNlQ2FtZXJhKF9ub2RlOiBOb2RlLCBfbXR4TWVzaFRvV29ybGQ6IE1hdHJpeDR4NCwgX210eENhbWVyYTogTWF0cml4NHg0KTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IGNtcEZhY2VDYW1lcmE6IENvbXBvbmVudEZhY2VDYW1lcmEgPSBfbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50RmFjZUNhbWVyYSk7XHJcbiAgICAgIGlmIChjbXBGYWNlQ2FtZXJhPy5pc0FjdGl2ZSlcclxuICAgICAgICByZXR1cm4gX210eE1lc2hUb1dvcmxkLmNsb25lLmxvb2tBdChfbXR4Q2FtZXJhLnRyYW5zbGF0aW9uLCBjbXBGYWNlQ2FtZXJhLnVwTG9jYWwgPyBudWxsIDogY21wRmFjZUNhbWVyYS51cCwgY21wRmFjZUNhbWVyYS5yZXN0cmljdCk7XHJcblxyXG4gICAgICByZXR1cm4gX210eE1lc2hUb1dvcmxkO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGJpbmRUZXh0dXJlKF9zaGFkZXI6IFNoYWRlckludGVyZmFjZSwgX3RleHR1cmU6IFdlYkdMVGV4dHVyZSwgX3VuaXQ6IG51bWJlciwgX3VuaWZvcm06IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjcmMzLmFjdGl2ZVRleHR1cmUoX3VuaXQpO1xyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgX3RleHR1cmUpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0xaShfc2hhZGVyLnVuaWZvcm1zW191bmlmb3JtXSwgX3VuaXQgLSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkUwKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogR2l2ZXMgV2ViR0wgQnVmZmVyIHRoZSBkYXRhIGZyb20gdGhlIHtAbGluayBUZXh0dXJlfVxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvclRleHR1cmUge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWNvcmF0ZShfY29uc3RydWN0b3I6IHR5cGVvZiBUZXh0dXJlLCBfY29udGV4dDogQ2xhc3NEZWNvcmF0b3JDb250ZXh0KTogdm9pZCB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBfY29uc3RydWN0b3IucHJvdG90eXBlLnVzZVJlbmRlckRhdGEubmFtZSwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvclRleHR1cmUudXNlUmVuZGVyRGF0YVxyXG4gICAgICB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUuZGVsZXRlUmVuZGVyRGF0YS5uYW1lLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yVGV4dHVyZS5kZWxldGVSZW5kZXJEYXRhXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgdXNlUmVuZGVyRGF0YSh0aGlzOiBUZXh0dXJlLCBfdGV4dHVyZVVuaXQ6IG51bWJlciA9IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTApOiB2b2lkIHtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGlmICghdGhpcy5yZW5kZXJEYXRhKVxyXG4gICAgICAgIHRoaXMucmVuZGVyRGF0YSA9IFJlbmRlcldlYkdMLmFzc2VydDxXZWJHTFRleHR1cmU+KGNyYzMuY3JlYXRlVGV4dHVyZSgpKTsgLy8gVE9ETzogY2hlY2sgaWYgYWxsIFdlYkdMLUNyZWF0aW9ucyBhcmUgYXNzZXJ0ZWRcclxuXHJcbiAgICAgIGNyYzMuYWN0aXZlVGV4dHVyZShfdGV4dHVyZVVuaXQpO1xyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGhpcy5yZW5kZXJEYXRhKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnRleHR1cmVEaXJ0eSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyBBbHdheXMgcHJlbXVsdGlwbHkgYWxwaGEgd2hpbGUgbG9hZGluZyB0ZXh0dXJlc1xyXG4gICAgICAgICAgY3JjMy5waXhlbFN0b3JlaShjcmMzLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdHJ1ZSk7XHJcbiAgICAgICAgICBjcmMzLnRleEltYWdlMkQoXHJcbiAgICAgICAgICAgIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfQllURSxcclxuICAgICAgICAgICAgdGhpcy50ZXhJbWFnZVNvdXJjZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGNyYzMucGl4ZWxTdG9yZWkoY3JjMy5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICB0aGlzLm1pcG1hcERpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgIHRoaXMudGV4dHVyZURpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgICBEZWJ1Zy5lcnJvcihfZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMubWlwbWFwRGlydHkpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMubWlwbWFwKSB7XHJcbiAgICAgICAgICBjYXNlIE1JUE1BUC5DUklTUDpcclxuICAgICAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01BR19GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCk7XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NSU5fRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgTUlQTUFQLk1FRElVTTpcclxuICAgICAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01BR19GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCk7XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NSU5fRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1RfTUlQTUFQX0xJTkVBUik7XHJcbiAgICAgICAgICAgIGNyYzMuZ2VuZXJhdGVNaXBtYXAoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJEKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIE1JUE1BUC5CTFVSUlk6XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NQUdfRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkxJTkVBUik7XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NSU5fRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkxJTkVBUl9NSVBNQVBfTElORUFSKTtcclxuICAgICAgICAgICAgY3JjMy5nZW5lcmF0ZU1pcG1hcChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgTUlQTUFQLlNNT09USDpcclxuICAgICAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01BR19GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTElORUFSKTtcclxuICAgICAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01JTl9GSUxURVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTElORUFSKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubWlwbWFwRGlydHkgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMud3JhcERpcnR5KSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLndyYXApIHtcclxuICAgICAgICAgIGNhc2UgV1JBUC5SRVBFQVQ6XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9XUkFQX1MsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkVQRUFUKTtcclxuICAgICAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX1dSQVBfVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SRVBFQVQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgV1JBUC5DTEFNUDpcclxuICAgICAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX1dSQVBfUywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX1dSQVBfVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFdSQVAuTUlSUk9SOlxyXG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfV1JBUF9TLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1JUlJPUkVEX1JFUEVBVCk7XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9XUkFQX1QsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTUlSUk9SRURfUkVQRUFUKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLndyYXBEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkZWxldGVSZW5kZXJEYXRhKHRoaXM6IFRleHR1cmUpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLnJlbmRlckRhdGEpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBudWxsKTtcclxuICAgICAgY3JjMy5kZWxldGVUZXh0dXJlKHRoaXMucmVuZGVyRGF0YSk7XHJcbiAgICAgIHRoaXMucmVuZGVyRGF0YSA9IG51bGw7XHJcbiAgICAgIHRoaXMudGV4dHVyZURpcnR5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5taXBtYXBEaXJ0eSA9IHRydWU7XHJcbiAgICAgIHRoaXMud3JhcERpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIE1hcENsYXNzVG9Db21wb25lbnRzIHtcclxuICAgIFtjbGFzc05hbWU6IHN0cmluZ106IENvbXBvbmVudFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyBhIG5vZGUgaW4gdGhlIHNjZW5ldHJlZS5cclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2hzLWZ1cnR3YW5nZW4vRlVER0Uvd2lraS9HcmFwaFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBOb2RlIGV4dGVuZHMgRXZlbnRUYXJnZXRVbmlmaWVkIGltcGxlbWVudHMgU2VyaWFsaXphYmxlIHtcclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmc7IC8vIFRoZSBuYW1lIHRvIGNhbGwgdGhpcyBub2RlIGJ5LlxyXG4gICAgcHVibGljIHJlYWRvbmx5IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgIHB1YmxpYyB0aW1lc3RhbXBVcGRhdGU6IG51bWJlciA9IDA7XHJcbiAgICAvKiogVGhlIG51bWJlciBvZiBub2RlcyBvZiB0aGUgd2hvbGUgYnJhbmNoIGluY2x1ZGluZyB0aGlzIG5vZGUgYW5kIGFsbCBzdWNjZXNzb3JzICovXHJcbiAgICBwdWJsaWMgbk5vZGVzSW5CcmFuY2g6IG51bWJlciA9IDA7XHJcbiAgICAvKiogVGhlIHJhZGl1cyBvZiB0aGUgYm91bmRpbmcgc3BoZXJlIGluIHdvcmxkIGRpbWVuc2lvbnMgZW5jbG9zaW5nIHRoZSBnZW9tZXRyeSBvZiB0aGlzIG5vZGUgYW5kIGFsbCBzdWNjZXNzb3JzIGluIHRoZSBicmFuY2ggKi9cclxuICAgIHB1YmxpYyByYWRpdXM6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHJpdmF0ZSBwYXJlbnQ6IE5vZGUgfCBudWxsID0gbnVsbDsgLy8gVGhlIHBhcmVudCBvZiB0aGlzIG5vZGUuXHJcbiAgICBwcml2YXRlIGNoaWxkcmVuOiBOb2RlW10gPSBbXTsgLy8gYXJyYXkgb2YgY2hpbGQgbm9kZXMgYXBwZW5kZWQgdG8gdGhpcyBub2RlLlxyXG4gICAgcHJpdmF0ZSBjb21wb25lbnRzOiBNYXBDbGFzc1RvQ29tcG9uZW50cyA9IHt9O1xyXG4gICAgLy8gcHJpdmF0ZSB0YWdzOiBzdHJpbmdbXSA9IFtdOyAvLyBOYW1lcyBvZiB0YWdzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIHRoaXMgbm9kZS4gKFRPRE86IEFzIG9mIHlldCBubyBmdW5jdGlvbmFsaXR5KVxyXG4gICAgLy8gcHJpdmF0ZSBsYXllcnM6IHN0cmluZ1tdID0gW107IC8vIE5hbWVzIG9mIHRoZSBsYXllcnMgdGhpcyBub2RlIGlzIG9uLiAoVE9ETzogQXMgb2YgeWV0IG5vIGZ1bmN0aW9uYWxpdHkpXHJcbiAgICBwcml2YXRlIGxpc3RlbmVyczogTWFwRXZlbnRUeXBlVG9MaXN0ZW5lciA9IHt9O1xyXG4gICAgcHJpdmF0ZSBjYXB0dXJlczogTWFwRXZlbnRUeXBlVG9MaXN0ZW5lciA9IHt9O1xyXG4gICAgcHJpdmF0ZSBhY3RpdmU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgICNtdHhXb3JsZEludmVyc2VVcGRhdGVkOiBudW1iZXI7XHJcbiAgICAjbXR4V29ybGRJbnZlcnNlOiBNYXRyaXg0eDQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG5vZGUgd2l0aCBhIG5hbWUgYW5kIGluaXRpYWxpemVzIGFsbCBhdHRyaWJ1dGVzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBtdXRhdG9yLWxpa2UgcGF0aCBzdHJpbmcgdG8gZ2V0IGZyb20gb25lIG5vZGUgdG8gYW5vdGhlciBvciBudWxsIGlmIG5vIHBhdGggaXMgZm91bmQgZS5nLjpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIFwibm9kZS9wYXJlbnQvY2hpbGRyZW4vMS9jb21wb25lbnRzL0NvbXBvbmVudFNrZWxldG9uLzBcIlxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUEFUSF9GUk9NX1RPKF9mcm9tOiBOb2RlIHwgQ29tcG9uZW50LCBfdG86IE5vZGUgfCBDb21wb25lbnQpOiBzdHJpbmcgfCBudWxsIHtcclxuICAgICAgY29uc3QgZnJvbTogTm9kZSA9IF9mcm9tIGluc3RhbmNlb2YgQ29tcG9uZW50ID8gX2Zyb20ubm9kZSA6IF9mcm9tO1xyXG4gICAgICBjb25zdCB0bzogTm9kZSA9IF90byBpbnN0YW5jZW9mIENvbXBvbmVudCA/IF90by5ub2RlIDogX3RvO1xyXG4gICAgICBpZiAoIWZyb20gfHwgIXRvKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgLy8gZmluZCBwYXRocyB0byBsb3dlc3QgY29tbW9uIGFuY2VzdG9yXHJcbiAgICAgIGxldCBwYXRoRnJvbTogTm9kZVtdID0gZnJvbS5nZXRQYXRoKCk7XHJcbiAgICAgIGxldCBwYXRoVG86IE5vZGVbXSA9IHRvLmdldFBhdGgoKTtcclxuICAgICAgbGV0IGFuY2VzdG9yOiBOb2RlID0gbnVsbDtcclxuICAgICAgd2hpbGUgKHBhdGhGcm9tLmxlbmd0aCAmJiBwYXRoVG8ubGVuZ3RoICYmIHBhdGhGcm9tWzBdID09IHBhdGhUb1swXSkge1xyXG4gICAgICAgIGFuY2VzdG9yID0gcGF0aEZyb20uc2hpZnQoKTtcclxuICAgICAgICBwYXRoVG8uc2hpZnQoKTtcclxuICAgICAgfVxyXG4gICAgICBwYXRoVG8udW5zaGlmdChhbmNlc3Rvcik7XHJcblxyXG4gICAgICBpZiAoIWFuY2VzdG9yKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgLy8gY3JlYXRlIHJlbGF0aXZlIHBhdGhcclxuICAgICAgbGV0IHBhdGhUb0FuY2VzdG9yOiBzdHJpbmdbXSA9IHBhdGhGcm9tLm1hcChfbm9kZSA9PiBcInBhcmVudFwiKTsgLy8gVE9ETzogdXNlIFwia2V5b2YgTm9kZVwiIGFzIHR5cGVcclxuICAgICAgbGV0IHBhdGhGcm9tQW5jZXN0b3I6IHN0cmluZ1tdID0gcGF0aFRvXHJcbiAgICAgICAgLmZsYXRNYXAoKF9ub2RlLCBfaW5kZXgsIF9hcnJheSkgPT4gW1wiY2hpbGRyZW5cIiwgX25vZGUuZmluZENoaWxkKF9hcnJheVtfaW5kZXggKyAxXSkudG9TdHJpbmcoKV0pXHJcbiAgICAgICAgLnNsaWNlKDAsIC0yKTtcclxuXHJcbiAgICAgIGlmIChfZnJvbSBpbnN0YW5jZW9mIENvbXBvbmVudClcclxuICAgICAgICBwYXRoVG9BbmNlc3Rvci51bnNoaWZ0KFwibm9kZVwiKTtcclxuICAgICAgaWYgKF90byBpbnN0YW5jZW9mIENvbXBvbmVudClcclxuICAgICAgICBwYXRoRnJvbUFuY2VzdG9yLnB1c2goXCJjb21wb25lbnRzXCIsIF90by50eXBlLCB0by5jb21wb25lbnRzW190by50eXBlXS5pbmRleE9mKF90bykudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgICByZXR1cm4gcGF0aFRvQW5jZXN0b3IuY29uY2F0KHBhdGhGcm9tQW5jZXN0b3IpLmpvaW4oXCIvXCIpOyAvLyBUT0RPOiBvciBtYXliZSB2YWxpZGF0ZSB0aGlzIHN0cmluZyB3aXRoIG5vZGUgYW5kIGNvbXBvbmVudCBvYmplY3RzP1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSB7QGxpbmsgTm9kZX0gb3Ige0BsaW5rIENvbXBvbmVudH0gZm91bmQgYXQgdGhlIGdpdmVuIHBhdGggc3RhcnRpbmcgZnJvbSB0aGUgZ2l2ZW4gbm9kZSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRklORDxUID0gTm9kZSB8IENvbXBvbmVudD4oX2Zyb206IE5vZGUgfCBDb21wb25lbnQsIF9wYXRoOiBzdHJpbmcpOiBUIHtcclxuICAgICAgaWYgKF9wYXRoID09IFwiXCIpXHJcbiAgICAgICAgcmV0dXJuIDxUPl9mcm9tO1xyXG5cclxuICAgICAgbGV0IHBhdGg6IHN0cmluZ1tdID0gX3BhdGguc3BsaXQoXCIvXCIpO1xyXG4gICAgICBsZXQgdG86IEdlbmVyYWwgPSBfZnJvbTtcclxuXHJcbiAgICAgIHdoaWxlIChwYXRoLmxlbmd0aCAmJiB0bylcclxuICAgICAgICB0byA9IFJlZmxlY3QuZ2V0KHRvLCBwYXRoLnNoaWZ0KCkpO1xyXG5cclxuICAgICAgcmV0dXJuIHRvO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgcmVyb3V0ZSB0byB7QGxpbmsgUmVuZGVyTWFuYWdlck5vZGUucmVzZXRSZW5kZXJEYXRhfSAqL1xyXG4gICAgQFJlbmRlck1hbmFnZXJOb2RlLmRlY29yYXRlXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlc2V0UmVuZGVyRGF0YSgpOiB2b2lkIHsgLyogaW5qZWN0ZWQgKi8gfTtcclxuXHJcbiAgICAvKiogQGludGVybmFsIHJlcm91dGUgdG8ge0BsaW5rIFJlbmRlck1hbmFnZXJOb2RlLnVwZGF0ZVJlbmRlcmJ1ZmZlcn0gKi9cclxuICAgIEBSZW5kZXJNYW5hZ2VyTm9kZS5kZWNvcmF0ZVxyXG4gICAgcHVibGljIHN0YXRpYyB1cGRhdGVSZW5kZXJidWZmZXIoKTogdm9pZCB7IC8qIGluamVjdGVkICovIH07XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCByZXJvdXRlIHRvIHtAbGluayBSZW5kZXJNYW5hZ2VyTm9kZS51cGRhdGVSZW5kZXJEYXRhfSAqL1xyXG4gICAgQFJlbmRlck1hbmFnZXJOb2RlLmRlY29yYXRlIFxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyB1cGRhdGVSZW5kZXJEYXRhKF9ub2RlOiBOb2RlLCBfY21wTWVzaDogQ29tcG9uZW50TWVzaCwgX2NtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCwgX2NtcEZhY2VDYW1lcmE6IENvbXBvbmVudEZhY2VDYW1lcmEsIF9jbXBQYXJ0aWNsZVN5c3RlbTogQ29tcG9uZW50UGFydGljbGVTeXN0ZW0pOiB2b2lkIHsgLyogaW5qZWN0ZWQgKi8gfTtcclxuXHJcbiAgICAvKiogQGludGVybmFsIHJlcm91dGUgdG8ge0BsaW5rIFJlbmRlck1hbmFnZXJOb2RlLnVzZVJlbmRlckRhdGF9ICovXHJcbiAgICBAUmVuZGVyTWFuYWdlck5vZGUuZGVjb3JhdGUgXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVzZVJlbmRlckRhdGEoX25vZGU6IE5vZGUsIF9tdHhXb3JsZE92ZXJyaWRlOiBNYXRyaXg0eDQpOiB2b2lkIHsgLyogaW5qZWN0ZWQgKi8gfTtcclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzQWN0aXZlKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG9ydGN1dCB0byByZXRyaWV2ZSB0aGlzIG5vZGVzIHtAbGluayBDb21wb25lbnRUcmFuc2Zvcm19XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY21wVHJhbnNmb3JtKCk6IENvbXBvbmVudFRyYW5zZm9ybSB7XHJcbiAgICAgIHJldHVybiA8Q29tcG9uZW50VHJhbnNmb3JtPnRoaXMuZ2V0Q29tcG9uZW50cyhDb21wb25lbnRUcmFuc2Zvcm0pPy5bMF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG9ydGN1dCB0byByZXRyaWV2ZSB0aGUgbG9jYWwge0BsaW5rIE1hdHJpeDR4NH0gYXR0YWNoZWQgdG8gdGhpcyBub2RlcyB7QGxpbmsgQ29tcG9uZW50VHJhbnNmb3JtfSAgXHJcbiAgICAgKiBGYWlscyBpZiBubyB7QGxpbmsgQ29tcG9uZW50VHJhbnNmb3JtfSBpcyBhdHRhY2hlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG10eExvY2FsKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNtcFRyYW5zZm9ybT8ubXR4TG9jYWw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBtdHhXb3JsZEludmVyc2UoKTogTWF0cml4NHg0IHtcclxuICAgICAgaWYgKHRoaXMuI210eFdvcmxkSW52ZXJzZVVwZGF0ZWQgIT0gdGhpcy50aW1lc3RhbXBVcGRhdGUpXHJcbiAgICAgICAgdGhpcy4jbXR4V29ybGRJbnZlcnNlID0gTWF0cml4NHg0LklOVkVSU0UodGhpcy5tdHhXb3JsZCk7XHJcblxyXG4gICAgICB0aGlzLiNtdHhXb3JsZEludmVyc2VVcGRhdGVkID0gdGhpcy50aW1lc3RhbXBVcGRhdGU7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtdHhXb3JsZEludmVyc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gYXR0YWNoZWQgdG8gdGhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG5DaGlsZHJlbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0b3IgeWllbGRpbmcgdGhlIG5vZGUgYW5kIGFsbCBkZWNlbmRhbnRzIGluIHRoZSBncmFwaCBiZWxvdyBmb3IgaXRlcmF0aW9uXHJcbiAgICAgKiBJbmFjdGl2ZSBub2RlcyBhbmQgdGhlaXIgZGVzY2VuZGFudHMgY2FuIGJlIGZpbHRlcmVkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyAqIGdldEl0ZXJhdG9yKF9hY3RpdmU6IGJvb2xlYW4gPSBmYWxzZSk6IEl0ZXJhYmxlSXRlcmF0b3I8Tm9kZT4ge1xyXG4gICAgICBpZiAoIV9hY3RpdmUgfHwgdGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICAgIHlpZWxkIHRoaXM7XHJcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcclxuICAgICAgICAgIHlpZWxkKiBjaGlsZC5nZXRJdGVyYXRvcihfYWN0aXZlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoaXMgbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cyBpbiB0aGUgZ3JhcGggYmVsb3dcclxuICAgICAqL1xyXG4gICAgcHVibGljIFtTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhYmxlSXRlcmF0b3I8Tm9kZT4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRJdGVyYXRvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgcmVyb3V0ZSB0byB7QGxpbmsgUmVuZGVyTWFuYWdlck5vZGUudXBkYXRlUmVuZGVyRGF0YX0gKi9cclxuICAgIHB1YmxpYyB1cGRhdGVSZW5kZXJEYXRhKF9jbXBNZXNoOiBDb21wb25lbnRNZXNoLCBfY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsLCBfY21wRmFjZUNhbWVyYTogQ29tcG9uZW50RmFjZUNhbWVyYSwgX2NtcFBhcnRpY2xlU3lzdGVtOiBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSk6IHZvaWQgeyBOb2RlLnVwZGF0ZVJlbmRlckRhdGEodGhpcywgX2NtcE1lc2gsIF9jbXBNYXRlcmlhbCwgX2NtcEZhY2VDYW1lcmEsIF9jbXBQYXJ0aWNsZVN5c3RlbSk7IH07XHJcbiAgICBcclxuICAgIC8qKiBAaW50ZXJuYWwgcmVyb3V0ZSB0byB7QGxpbmsgUmVuZGVyTWFuYWdlck5vZGUudXNlUmVuZGVyRGF0YX0gKi9cclxuICAgIHB1YmxpYyB1c2VSZW5kZXJEYXRhKF9tdHhXb3JsZE92ZXJyaWRlOiBNYXRyaXg0eDQpOiB2b2lkIHsgTm9kZS51c2VSZW5kZXJEYXRhKHRoaXMsIF9tdHhXb3JsZE92ZXJyaWRlKTsgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlLSAvIEFjdGl2YXRlIHRoaXMgbm9kZS4gSW5hY3RpdmUgbm9kZXMgd2lsbCBub3QgYmUgcHJvY2Vzc2VkIGJ5IHRoZSByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlKF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IF9vbjtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChfb24gPyBFVkVOVC5OT0RFX0FDVElWQVRFIDogRVZFTlQuTk9ERV9ERUFDVElWQVRFLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xyXG4gICAgICB0aGlzLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChfb24gPyBFVkVOVC5OT0RFX0FDVElWQVRFIDogRVZFTlQuTk9ERV9ERUFDVElWQVRFKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gI3JlZ2lvbiBTY2VuZXRyZWVcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIG5vZGVzIHBhcmVudCBub2RlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQYXJlbnQoKTogTm9kZSB8IG51bGwge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFjZXMgYmFjayB0aGUgYW5jZXN0b3JzIG9mIHRoaXMgbm9kZSBhbmQgcmV0dXJucyB0aGUgZmlyc3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEFuY2VzdG9yKCk6IE5vZGUgfCBudWxsIHtcclxuICAgICAgbGV0IGFuY2VzdG9yOiBOb2RlID0gdGhpcztcclxuICAgICAgd2hpbGUgKGFuY2VzdG9yLmdldFBhcmVudCgpKVxyXG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IuZ2V0UGFyZW50KCk7XHJcbiAgICAgIHJldHVybiBhbmNlc3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYWNlcyB0aGUgaGllcmFyY2h5IHVwd2FyZHMgdG8gdGhlIGZpcnN0IGFuY2VzdG9yIGFuZCByZXR1cm5zIHRoZSBwYXRoIHRocm91Z2ggdGhlIGdyYXBoIHRvIHRoaXMgbm9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UGF0aCgpOiBOb2RlW10ge1xyXG4gICAgICBsZXQgYW5jZXN0b3I6IE5vZGUgPSB0aGlzO1xyXG4gICAgICBsZXQgcGF0aDogTm9kZVtdID0gW3RoaXNdO1xyXG4gICAgICB3aGlsZSAoYW5jZXN0b3IuZ2V0UGFyZW50KCkpXHJcbiAgICAgICAgcGF0aC51bnNoaWZ0KGFuY2VzdG9yID0gYW5jZXN0b3IuZ2V0UGFyZW50KCkpO1xyXG4gICAgICByZXR1cm4gcGF0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY2hpbGQgYXQgdGhlIGdpdmVuIGluZGV4IGluIHRoZSBsaXN0IG9mIGNoaWxkcmVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDaGlsZChfaW5kZXg6IG51bWJlcik6IE5vZGUge1xyXG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltfaW5kZXhdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBsaXN0IG9mIGNoaWxkcmVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDaGlsZHJlbigpOiBOb2RlW10ge1xyXG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5zbGljZSgwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcmVmZXJlbmNlcyB0byBjaGlsZG5vZGVzIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2hpbGRyZW5CeU5hbWUoX25hbWU6IHN0cmluZyk6IE5vZGVbXSB7XHJcbiAgICAgIGxldCBmb3VuZDogTm9kZVtdID0gW107XHJcbiAgICAgIGZvdW5kID0gdGhpcy5jaGlsZHJlbi5maWx0ZXIoKF9ub2RlOiBOb2RlKSA9PiBfbm9kZS5uYW1lID09IF9uYW1lKTtcclxuICAgICAgcmV0dXJuIGZvdW5kO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2ltcGx5IGNhbGxzIHtAbGluayBhZGRDaGlsZH0uIFRoaXMgcmVmZXJlbmNlIGlzIGhlcmUgc29sZWx5IGJlY2F1c2UgYXBwZW5kQ2hpbGQgaXMgdGhlIGVxdWl2YWxlbnQgbWV0aG9kIGluIERPTS5cclxuICAgICAqIFNlZSBhbmQgcHJlZmVyYWJseSB1c2Uge0BsaW5rIGFkZENoaWxkfVxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZ1xyXG4gICAgcHVibGljIHJlYWRvbmx5IGFwcGVuZENoaWxkOiAoX2NoaWxkOiBOb2RlKSA9PiB2b2lkID0gdGhpcy5hZGRDaGlsZDtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiByZWZlcmVuY2UgdG8gYSBub2RlIHRvIHRoZSBsaXN0IG9mIGNoaWxkcmVuLCBpZiBub3QgYWxyZWFkeSBpblxyXG4gICAgICogQHRocm93cyBFcnJvciB3aGVuIHRyeWluZyB0byBhZGQgYW4gYW5jZXN0b3Igb2YgdGhpcyBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZENoaWxkKF9jaGlsZDogTm9kZSk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHJlZmVyZW5jZSB0byBhIG5vZGUgdG8gdGhlIGxpc3Qgb2YgY2hpbGRyZW4gYXQgdGhlIGdpdmVuIGluZGV4LiBJZiBpdCBpcyBhbHJlYWR5IGEgY2hpbGQsIGl0IGlzIG1vdmVkIHRvIHRoZSBuZXcgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRDaGlsZChfY2hpbGQ6IE5vZGUsIF9pbmRleDogbnVtYmVyKTogdm9pZDtcclxuICAgIHB1YmxpYyBhZGRDaGlsZChfY2hpbGQ6IE5vZGUsIF9pbmRleD86IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy5jaGlsZHJlbi5pbmNsdWRlcyhfY2hpbGQpICYmIF9pbmRleCA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgLy8gX25vZGUgaXMgYWxyZWFkeSBhIGNoaWxkIG9mIHRoaXNcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBsZXQgaW5BdWRpb0dyYXBoOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgIGxldCBncmFwaExpc3RlbmVkOiBOb2RlID0gQXVkaW9NYW5hZ2VyLmRlZmF1bHQuZ2V0R3JhcGhMaXN0ZW5pbmdUbygpO1xyXG4gICAgICBsZXQgYW5jZXN0b3I6IE5vZGUgPSB0aGlzO1xyXG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcclxuICAgICAgICBhbmNlc3Rvci50aW1lc3RhbXBVcGRhdGUgPSAwO1xyXG4gICAgICAgIGluQXVkaW9HcmFwaCA9IGluQXVkaW9HcmFwaCB8fCAoYW5jZXN0b3IgPT0gZ3JhcGhMaXN0ZW5lZCk7XHJcbiAgICAgICAgaWYgKGFuY2VzdG9yID09IF9jaGlsZClcclxuICAgICAgICAgIHRocm93IChuZXcgRXJyb3IoXCJDeWNsaWMgcmVmZXJlbmNlIHByb2hpYml0ZWQgaW4gbm9kZSBoaWVyYXJjaHksIGFuY2VzdG9ycyBtdXN0IG5vdCBiZSBhZGRlZCBhcyBjaGlsZHJlblwiKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBwcmV2aW91c1BhcmVudDogTm9kZSA9IF9jaGlsZC5wYXJlbnQ7XHJcbiAgICAgIGlmIChwcmV2aW91c1BhcmVudCA9PSB0aGlzICYmIF9pbmRleCA+IHByZXZpb3VzUGFyZW50LmZpbmRDaGlsZChfY2hpbGQpKVxyXG4gICAgICAgIF9pbmRleC0tO1xyXG5cclxuICAgICAgaWYgKHByZXZpb3VzUGFyZW50KVxyXG4gICAgICAgIHByZXZpb3VzUGFyZW50LnJlbW92ZUNoaWxkKF9jaGlsZCk7XHJcblxyXG4gICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShfaW5kZXggPz8gdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIF9jaGlsZCk7XHJcbiAgICAgIF9jaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICBfY2hpbGQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuQ0hJTERfQVBQRU5ELCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xyXG4gICAgICBpZiAoaW5BdWRpb0dyYXBoKVxyXG4gICAgICAgIF9jaGlsZC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5EKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSByZWZlcmVuY2UgdG8gdGhlIGdpdmUgbm9kZSBmcm9tIHRoZSBsaXN0IG9mIGNoaWxkcmVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVDaGlsZChfY2hpbGQ6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgbGV0IGZvdW5kOiBudW1iZXIgPSB0aGlzLmZpbmRDaGlsZChfY2hpbGQpO1xyXG4gICAgICBpZiAoZm91bmQgPCAwKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIF9jaGlsZC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5DSElMRF9SRU1PVkUsIHsgYnViYmxlczogdHJ1ZSB9KSk7XHJcbiAgICAgIF9jaGlsZC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlQuTk9ERV9ERUFDVElWQVRFKSk7XHJcbiAgICAgIGlmICh0aGlzLmlzRGVzY2VuZGFudE9mKEF1ZGlvTWFuYWdlci5kZWZhdWx0LmdldEdyYXBoTGlzdGVuaW5nVG8oKSkpXHJcbiAgICAgICAgX2NoaWxkLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVF9BVURJTy5DSElMRF9SRU1PVkUpKTtcclxuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoZm91bmQsIDEpO1xyXG4gICAgICBfY2hpbGQucGFyZW50ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIHJlZmVyZW5jZXMgaW4gdGhlIGxpc3Qgb2YgY2hpbGRyZW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUFsbENoaWxkcmVuKCk6IHZvaWQge1xyXG4gICAgICB3aGlsZSAodGhpcy5jaGlsZHJlbi5sZW5ndGgpXHJcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmNoaWxkcmVuWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGluIHRoZSBsaXN0IG9mIGNoaWxkcmVuIG9yIC0xIGlmIG5vdCBmb3VuZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZmluZENoaWxkKF9zZWFyY2g6IE5vZGUpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5pbmRleE9mKF9zZWFyY2gpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZXMgYSBjaGlsZCBub2RlIHdpdGggYW5vdGhlciwgcHJlc2VydmluZyB0aGUgcG9zaXRpb24gaW4gdGhlIGxpc3Qgb2YgY2hpbGRyZW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlcGxhY2VDaGlsZChfcmVwbGFjZTogTm9kZSwgX3dpdGg6IE5vZGUpOiBib29sZWFuIHtcclxuICAgICAgbGV0IGZvdW5kOiBudW1iZXIgPSB0aGlzLmZpbmRDaGlsZChfcmVwbGFjZSk7XHJcbiAgICAgIGlmIChmb3VuZCA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgX3dpdGguZ2V0UGFyZW50KCk/LnJlbW92ZUNoaWxkKF93aXRoKTtcclxuICAgICAgdGhpcy5yZW1vdmVDaGlsZChfcmVwbGFjZSk7XHJcblxyXG4gICAgICB0aGlzLmFkZENoaWxkKF93aXRoLCBmb3VuZCk7XHJcblxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdGltZXN0YW1wIG1hdGNoZXMgdGhlIGxhc3QgdXBkYXRlIHRpbWVzdGFtcCB0aGlzIG5vZGUgdW5kZXJ3ZW50LCBlbHNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc1VwZGF0ZWQoX3RpbWVzdGFtcFVwZGF0ZTogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAodGhpcy50aW1lc3RhbXBVcGRhdGUgPT0gX3RpbWVzdGFtcFVwZGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbm9kZSBpcyBhIGRlc2NlbmRhbnQgb2YgdGhlIGdpdmVuIG5vZGUsIGRpcmVjdGx5IG9yIGluZGlyZWN0bHksIGVsc2UgZmFsc2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzRGVzY2VuZGFudE9mKF9hbmNlc3RvcjogTm9kZSk6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQgbm9kZTogTm9kZSA9IHRoaXM7XHJcbiAgICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT0gX2FuY2VzdG9yKVxyXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgICAgcmV0dXJuIChub2RlICE9IG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBhIE11dGF0b3IgZnJvbSB7QGxpbmsgQW5pbWF0aW9ufSB0byBhbGwgaXRzIGNvbXBvbmVudHMgYW5kIHRyYW5zZmVycyBpdCB0byBpdHMgY2hpbGRyZW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhcHBseUFuaW1hdGlvbihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBpZiAoXCJjb21wb25lbnRzXCIgaW4gX211dGF0b3IpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudFR5cGUgaW4gX211dGF0b3IuY29tcG9uZW50cykge1xyXG4gICAgICAgICAgbGV0IGNvbXBvbmVudHNPZlR5cGU6IENvbXBvbmVudFtdID0gdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudFR5cGVdOyAvLyBUT0RPOiBhZGQgZXJyb3JzIGlmIG5vZGUgZG9lc24ndCBjb250YWluIHByb3BlcnR5XHJcbiAgICAgICAgICBsZXQgbXV0YXRvcnNGb3JUeXBlOiBNdXRhdG9yW10gPSBfbXV0YXRvci5jb21wb25lbnRzW2NvbXBvbmVudFR5cGVdO1xyXG4gICAgICAgICAgaWYgKGNvbXBvbmVudHNPZlR5cGUgIT0gdW5kZWZpbmVkICYmIG11dGF0b3JzRm9yVHlwZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIG11dGF0b3JzRm9yVHlwZSkge1xyXG4gICAgICAgICAgICAgIFBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE1lYXN1cmUoXCJhcHBseUFuaW1hdGlvbiBtdXRhdGUgY29tcG9uZW50c1wiKTtcclxuICAgICAgICAgICAgICBjb21wb25lbnRzT2ZUeXBlW2ldLm11dGF0ZShtdXRhdG9yc0ZvclR5cGVbaV0sIG51bGwsIGZhbHNlKTtcclxuICAgICAgICAgICAgICBQZXJmb3JtYW5jZU1vbml0b3IuZW5kTWVhc3VyZShcImFwcGx5QW5pbWF0aW9uIG11dGF0ZSBjb21wb25lbnRzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChcImNoaWxkcmVuXCIgaW4gX211dGF0b3IpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTmFtZSBpbiBfbXV0YXRvci5jaGlsZHJlbikge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBjaGlsZE5vZGUgb2YgdGhpcy5nZXRDaGlsZHJlbkJ5TmFtZShjaGlsZE5hbWUpKSB7XHJcbiAgICAgICAgICAgIGNoaWxkTm9kZS5hcHBseUFuaW1hdGlvbihfbXV0YXRvci5jaGlsZHJlbltjaGlsZE5hbWVdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICAvLyAjcmVnaW9uIENvbXBvbmVudHNcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIGNvbXBvbmVudHMgYXR0YWNoZWQgdG8gdGhpcyBub2RlLCBpbmRlcGVuZGVudCBvZiB0eXBlLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEFsbENvbXBvbmVudHMoKTogQ29tcG9uZW50W10ge1xyXG4gICAgICBsZXQgYWxsOiBDb21wb25lbnRbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCB0eXBlIGluIHRoaXMuY29tcG9uZW50cykge1xyXG4gICAgICAgIGFsbCA9IGFsbC5jb25jYXQodGhpcy5jb21wb25lbnRzW3R5cGVdKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBsaXN0IG9mIGNvbXBvbmVudHMgb2YgdGhlIGdpdmVuIGNsYXNzIGF0dGFjaGVkIHRvIHRoaXMgbm9kZS4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnRzPFQgZXh0ZW5kcyBDb21wb25lbnQ+KF9jbGFzczogbmV3ICgpID0+IFQpOiBUW10ge1xyXG4gICAgICByZXR1cm4gPFRbXT4odGhpcy5jb21wb25lbnRzW19jbGFzcy5uYW1lXSB8fCBbXSkuc2xpY2UoMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGNvbXBvbnRlbnQgZm91bmQgb2YgdGhlIGdpdmVuIGNsYXNzIGF0dGFjaGVkIHRoaXMgbm9kZSBvciBudWxsLCBpZiBsaXN0IGlzIGVtcHR5IG9yIGRvZXNuJ3QgZXhpc3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50PihfY2xhc3M6IG5ldyAoKSA9PiBUKTogVCB7XHJcbiAgICAgIHJldHVybiA8VD50aGlzLmNvbXBvbmVudHNbX2NsYXNzLm5hbWVdPy5bMF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2ggdGhlIGdpdmVuIGNvbXBvbmVudCB0byB0aGlzIG5vZGUuIElkZW50aWNhbCB0byB7QGxpbmsgYWRkQ29tcG9uZW50fVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXR0YWNoKF9jb21wb25lbnQ6IENvbXBvbmVudCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmFkZENvbXBvbmVudChfY29tcG9uZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaCB0aGUgZ2l2ZW4gY29tcG9uZW50IHRvIHRoaXMgbm9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkQ29tcG9uZW50KF9jb21wb25lbnQ6IENvbXBvbmVudCk6IHZvaWQge1xyXG4gICAgICBpZiAoX2NvbXBvbmVudC5ub2RlID09IHRoaXMpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBsZXQgY21wTGlzdDogQ29tcG9uZW50W10gPSB0aGlzLmNvbXBvbmVudHNbX2NvbXBvbmVudC50eXBlXTtcclxuICAgICAgaWYgKGNtcExpc3QgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbX2NvbXBvbmVudC50eXBlXSA9IFtfY29tcG9uZW50XTtcclxuICAgICAgZWxzZSBpZiAoY21wTGlzdC5sZW5ndGggJiYgX2NvbXBvbmVudC5pc1NpbmdsZXRvbilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBvbmVudCAke19jb21wb25lbnQudHlwZX0gaXMgbWFya2VkIHNpbmdsZXRvbiBhbmQgY2FuJ3QgYmUgYXR0YWNoZWQsIG5vIG1vcmUgdGhhbiBvbmUgYWxsb3dlZGApO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgY21wTGlzdC5wdXNoKF9jb21wb25lbnQpO1xyXG5cclxuICAgICAgX2NvbXBvbmVudC5hdHRhY2hUb05vZGUodGhpcyk7XHJcbiAgICAgIF9jb21wb25lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuQ09NUE9ORU5UX0FERCkpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnRUb1RhcmdldE9ubHkobmV3IEN1c3RvbUV2ZW50KEVWRU5ULkNPTVBPTkVOVF9BREQsIHsgZGV0YWlsOiBfY29tcG9uZW50IH0pKTsgLy8gVE9ETzogc2VlIGlmIHRoaXMgaXMgYmUgZmVhc2FibGVcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGFjaCB0aGUgZ2l2ZW4gY29tcG9uZW50IGZyb20gdGhpcyBub2RlLiBJZGVudGljYWwgdG8ge0BsaW5rIHJlbW92ZUNvbXBvbmVudH1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRldGFjaChfY29tcG9uZW50OiBDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5yZW1vdmVDb21wb25lbnQoX2NvbXBvbmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCBjb21wb25lbnRzIG9mIHRoZSBnaXZlbiBjbGFzcyBhdHRhY2hlZCB0byB0aGlzIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVDb21wb25lbnRzKF9jbGFzczogbmV3ICgpID0+IENvbXBvbmVudCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmdldENvbXBvbmVudHMoX2NsYXNzKS5mb3JFYWNoKF9jb21wb25lbnQgPT4gdGhpcy5yZW1vdmVDb21wb25lbnQoX2NvbXBvbmVudCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGNvbXBvbmVudCBmcm9tIHRoZSBub2RlLCBpZiBpdCB3YXMgYXR0YWNoZWQsIGFuZCBzZXRzIGl0cyBwYXJlbnQgdG8gbnVsbC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVDb21wb25lbnQoX2NvbXBvbmVudDogQ29tcG9uZW50KTogdm9pZCB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbGV0IGNvbXBvbmVudHNPZlR5cGU6IENvbXBvbmVudFtdID0gdGhpcy5jb21wb25lbnRzW19jb21wb25lbnQudHlwZV07XHJcbiAgICAgICAgbGV0IGZvdW5kQXQ6IG51bWJlciA9IGNvbXBvbmVudHNPZlR5cGUuaW5kZXhPZihfY29tcG9uZW50KTtcclxuICAgICAgICBpZiAoZm91bmRBdCA8IDApXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgX2NvbXBvbmVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5DT01QT05FTlRfUkVNT1ZFKSk7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50VG9UYXJnZXRPbmx5KG5ldyBDdXN0b21FdmVudChFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB7IGRldGFpbDogX2NvbXBvbmVudCB9KSk7IC8vIFRPRE86IHNlZSBpZiB0aGlzIHdvdWxkIGJlIGZlYXNhYmxlXHJcbiAgICAgICAgY29tcG9uZW50c09mVHlwZS5zcGxpY2UoZm91bmRBdCwgMSk7XHJcbiAgICAgICAgX2NvbXBvbmVudC5hdHRhY2hUb05vZGUobnVsbCk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlbW92ZSBjb21wb25lbnQgJyR7X2NvbXBvbmVudH0naW4gbm9kZSBuYW1lZCAnJHt0aGlzLm5hbWV9J2ApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gICAgLy8gI3JlZ2lvbiBTZXJpYWxpemF0aW9uXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgYWN0aXZlOiB0aGlzLmFjdGl2ZVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgbGV0IGNvbXBvbmVudHM6IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgZm9yIChsZXQgdHlwZSBpbiB0aGlzLmNvbXBvbmVudHMpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnRzW3R5cGVdLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgIGNvbXBvbmVudHNbdHlwZV0gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBjb21wb25lbnQgb2YgdGhpcy5jb21wb25lbnRzW3R5cGVdKSB7XHJcbiAgICAgICAgICAvLyBjb21wb25lbnRzW3R5cGVdLnB1c2goY29tcG9uZW50LnNlcmlhbGl6ZSgpKTtcclxuICAgICAgICAgIGNvbXBvbmVudHNbdHlwZV0ucHVzaChTZXJpYWxpemVyLnNlcmlhbGl6ZShjb21wb25lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgc2VyaWFsaXphdGlvbltcImNvbXBvbmVudHNcIl0gPSBjb21wb25lbnRzO1xyXG5cclxuICAgICAgbGV0IGNoaWxkcmVuOiBTZXJpYWxpemF0aW9uW10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgIGNoaWxkcmVuLnB1c2goU2VyaWFsaXplci5zZXJpYWxpemUoY2hpbGQpKTtcclxuICAgICAgfVxyXG4gICAgICBzZXJpYWxpemF0aW9uW1wiY2hpbGRyZW5cIl0gPSBjaGlsZHJlbjtcclxuXHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTk9ERV9TRVJJQUxJWkVEKSk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XHJcbiAgICAgIC8vIHRoaXMucGFyZW50ID0gaXMgc2V0IHdoZW4gdGhlIG5vZGVzIGFyZSBhZGRlZFxyXG5cclxuICAgICAgLy8gZGVzZXJpYWxpemUgY29tcG9uZW50cyBmaXJzdCBzbyBzY3JpcHRzIGNhbiByZWFjdCB0byBjaGlsZHJlbiBiZWluZyBhcHBlbmRlZFxyXG4gICAgICBmb3IgKGxldCB0eXBlIGluIF9zZXJpYWxpemF0aW9uLmNvbXBvbmVudHMpIHtcclxuICAgICAgICBmb3IgKGxldCBzZXJpYWxpemVkQ29tcG9uZW50IG9mIF9zZXJpYWxpemF0aW9uLmNvbXBvbmVudHNbdHlwZV0pIHtcclxuICAgICAgICAgIGxldCBkZXNlcmlhbGl6ZWRDb21wb25lbnQ6IENvbXBvbmVudCA9IDxDb21wb25lbnQ+YXdhaXQgU2VyaWFsaXplci5kZXNlcmlhbGl6ZShzZXJpYWxpemVkQ29tcG9uZW50KTtcclxuICAgICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KGRlc2VyaWFsaXplZENvbXBvbmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoX3NlcmlhbGl6YXRpb24uY2hpbGRyZW4pXHJcbiAgICAgICAgZm9yIChsZXQgc2VyaWFsaXplZENoaWxkIG9mIF9zZXJpYWxpemF0aW9uLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICBsZXQgZGVzZXJpYWxpemVkQ2hpbGQ6IE5vZGUgPSA8Tm9kZT5hd2FpdCBTZXJpYWxpemVyLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRDaGlsZCk7XHJcbiAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGRlc2VyaWFsaXplZENoaWxkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk5PREVfREVTRVJJQUxJWkVEKSk7XHJcbiAgICAgIGZvciAobGV0IGNvbXBvbmVudCBvZiB0aGlzLmdldEFsbENvbXBvbmVudHMoKSlcclxuICAgICAgICBjb21wb25lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQpKTtcclxuXHJcbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGlmIHRoaXMgaXMgYSBnb29kIGlkZWFcclxuICAgICAgLy8gY29uc3QgaG5kR3JhcGhEZXNlcmlhbGl6ZWQ6IEV2ZW50TGlzdGVuZXJVbmlmaWVkID0gKCkgPT4ge1xyXG4gICAgICAvLyAgIGZvciAobGV0IGNvbXBvbmVudCBvZiB0aGlzLmdldEFsbENvbXBvbmVudHMoKSlcclxuICAgICAgLy8gICAgIGNvbXBvbmVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5HUkFQSF9ERVNFUklBTElaRUQsIHsgYnViYmxlczogZmFsc2UgfSkpO1xyXG4gICAgICAvLyAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5HUkFQSF9ERVNFUklBTElaRUQsIGhuZEdyYXBoRGVzZXJpYWxpemVkLCB0cnVlKTtcclxuICAgICAgLy8gICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuR1JBUEhfSU5TVEFOVElBVEVELCBobmRHcmFwaERlc2VyaWFsaXplZCwgdHJ1ZSk7XHJcbiAgICAgIC8vIH07XHJcbiAgICAgIC8vIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5HUkFQSF9ERVNFUklBTElaRUQsIGhuZEdyYXBoRGVzZXJpYWxpemVkLCB0cnVlKTtcclxuICAgICAgLy8gdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkdSQVBIX0lOU1RBTlRJQVRFRCwgaG5kR3JhcGhEZXNlcmlhbGl6ZWQsIHRydWUpO1xyXG5cclxuICAgICAgdGhpcy5hY3RpdmF0ZShfc2VyaWFsaXphdGlvbi5hY3RpdmUpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMubmFtZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzdHJpbmcgYXMgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlIGFuZCBpdHMgZGVzY2VuZGFudHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvSGllcmFyY2h5U3RyaW5nKF9ub2RlOiBOb2RlID0gbnVsbCwgX2xldmVsOiBudW1iZXIgPSAwKTogc3RyaW5nIHtcclxuICAgICAgLy8gVE9ETzogcmVmYWN0b3IgZm9yIGJldHRlciByZWFkYWJpbGl0eVxyXG4gICAgICBpZiAoIV9ub2RlKVxyXG4gICAgICAgIF9ub2RlID0gdGhpcztcclxuXHJcbiAgICAgIGxldCBwcmVmaXg6IHN0cmluZyA9IFwiK1wiLnJlcGVhdChfbGV2ZWwpO1xyXG5cclxuICAgICAgbGV0IG91dHB1dDogc3RyaW5nID0gcHJlZml4ICsgXCIgXCIgKyBfbm9kZS5uYW1lICsgXCIgfCBcIjtcclxuICAgICAgZm9yIChsZXQgdHlwZSBpbiBfbm9kZS5jb21wb25lbnRzKVxyXG4gICAgICAgIG91dHB1dCArPSBfbm9kZS5jb21wb25lbnRzW3R5cGVdLmxlbmd0aCArIFwiIFwiICsgdHlwZS5zcGxpdChcIkNvbXBvbmVudFwiKS5wb3AoKSArIFwiLCBcIjtcclxuICAgICAgb3V0cHV0ID0gb3V0cHV0LnNsaWNlKDAsIC0yKSArIFwiPC9icj5cIjtcclxuICAgICAgZm9yIChsZXQgY2hpbGQgb2YgX25vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICBvdXRwdXQgKz0gdGhpcy50b0hpZXJhcmNoeVN0cmluZyhjaGlsZCwgX2xldmVsICsgMSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAjcmVnaW9uIEV2ZW50c1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBub2RlLiBUaGUgZ2l2ZW4gaGFuZGxlciB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgbWF0Y2hpbmcgZXZlbnQgaXMgcGFzc2VkIHRvIHRoZSBub2RlLlxyXG4gICAgICogRGV2aWF0aW5nIGZyb20gdGhlIHN0YW5kYXJkIEV2ZW50VGFyZ2V0LCBoZXJlIHRoZSBfaGFuZGxlciBtdXN0IGJlIGEgZnVuY3Rpb24gYW5kIF9jYXB0dXJlIGlzIHRoZSBvbmx5IG9wdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZEV2ZW50TGlzdGVuZXIoX3R5cGU6IEVWRU5UIHwgc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lclVuaWZpZWQsIF9jYXB0dXJlOiBib29sZWFuIC8qfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyovID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgbGV0IGxpc3RMaXN0ZW5lcnM6IE1hcEV2ZW50VHlwZVRvTGlzdGVuZXIgPSBfY2FwdHVyZSA/IHRoaXMuY2FwdHVyZXMgOiB0aGlzLmxpc3RlbmVycztcclxuICAgICAgaWYgKCFsaXN0TGlzdGVuZXJzW190eXBlXSlcclxuICAgICAgICBsaXN0TGlzdGVuZXJzW190eXBlXSA9IFtdO1xyXG4gICAgICBsaXN0TGlzdGVuZXJzW190eXBlXS5wdXNoKF9oYW5kbGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBmcm9tIHRoZSBub2RlLiBUaGUgc2lnbmF0dXJlIG11c3QgbWF0Y2ggdGhlIG9uZSB1c2VkIHdpdGggYWRkRXZlbnRMaXN0ZW5lclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlRXZlbnRMaXN0ZW5lcihfdHlwZTogRVZFTlQgfCBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyVW5pZmllZCwgX2NhcHR1cmU6IGJvb2xlYW4gLyp8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKi8gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBsZXQgbGlzdGVuZXJzRm9yVHlwZTogRXZlbnRMaXN0ZW5lclVuaWZpZWRbXSA9IF9jYXB0dXJlID8gdGhpcy5jYXB0dXJlc1tfdHlwZV0gOiB0aGlzLmxpc3RlbmVyc1tfdHlwZV07XHJcbiAgICAgIGlmIChsaXN0ZW5lcnNGb3JUeXBlKVxyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IGxpc3RlbmVyc0ZvclR5cGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgICBpZiAobGlzdGVuZXJzRm9yVHlwZVtpXSA9PSBfaGFuZGxlcilcclxuICAgICAgICAgICAgbGlzdGVuZXJzRm9yVHlwZS5zcGxpY2UoaSwgMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3BhdGNoZXMgYSBzeW50aGV0aWMgZXZlbnQgdG8gdGFyZ2V0LiBUaGlzIGltcGxlbWVudGF0aW9uIGFsd2F5cyByZXR1cm5zIHRydWUgKHN0YW5kYXJkOiByZXR1cm4gdHJ1ZSBvbmx5IGlmIGVpdGhlciBldmVudCdzIGNhbmNlbGFibGUgYXR0cmlidXRlIHZhbHVlIGlzIGZhbHNlIG9yIGl0cyBwcmV2ZW50RGVmYXVsdCgpIG1ldGhvZCB3YXMgbm90IGludm9rZWQpXHJcbiAgICAgKiBUaGUgZXZlbnQgdHJhdmVscyBpbnRvIHRoZSBoaWVyYXJjaHkgdG8gdGhpcyBub2RlIGRpc3BhdGNoaW5nIHRoZSBldmVudCwgaW52b2tpbmcgbWF0Y2hpbmcgaGFuZGxlcnMgb2YgdGhlIG5vZGVzIGFuY2VzdG9ycyBsaXN0ZW5pbmcgdG8gdGhlIGNhcHR1cmUgcGhhc2UsIFxyXG4gICAgICogdGhhbiB0aGUgbWF0Y2hpbmcgaGFuZGxlciBvZiB0aGUgdGFyZ2V0IG5vZGUgaW4gdGhlIHRhcmdldCBwaGFzZSwgYW5kIGJhY2sgb3V0IG9mIHRoZSBoaWVyYXJjaHkgaW4gdGhlIGJ1YmJsaW5nIHBoYXNlLCBpbnZva2luZyBhcHByb3ByaWF0ZSBoYW5kbGVycyBvZiB0aGUgYW52ZXN0b3JzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkaXNwYXRjaEV2ZW50KF9ldmVudDogRXZlbnQpOiBib29sZWFuIHtcclxuICAgICAgbGV0IGFuY2VzdG9yczogTm9kZVtdID0gW107XHJcbiAgICAgIGxldCB1cGNvbWluZzogTm9kZSA9IHRoaXM7XHJcbiAgICAgIC8vIG92ZXJ3cml0ZSBldmVudCB0YXJnZXRcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJ0YXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRoaXMgfSk7XHJcbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIHVzaW5nIFJlZmxlY3QgaW5zdGVhZCBvZiBPYmplY3QgdGhyb3VnaG91dC4gU2VlIGFsc28gUmVuZGVyIGFuZCBNdXRhYmxlLi4uXHJcbiAgICAgIHdoaWxlICh1cGNvbWluZy5wYXJlbnQpXHJcbiAgICAgICAgYW5jZXN0b3JzLnB1c2godXBjb21pbmcgPSB1cGNvbWluZy5wYXJlbnQpO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcInBhdGhcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IG5ldyBBcnJheTxOb2RlPih0aGlzLCAuLi5hbmNlc3RvcnMpIH0pO1xyXG5cclxuICAgICAgLy8gY2FwdHVyZSBwaGFzZVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImV2ZW50UGhhc2VcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IEV2ZW50LkNBUFRVUklOR19QSEFTRSB9KTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gYW5jZXN0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgbGV0IGFuY2VzdG9yOiBOb2RlID0gYW5jZXN0b3JzW2ldO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogYW5jZXN0b3IgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsTGlzdGVuZXJzKGFuY2VzdG9yLmNhcHR1cmVzW19ldmVudC50eXBlXSwgX2V2ZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gdGFyZ2V0IHBoYXNlXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiZXZlbnRQaGFzZVwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogRXZlbnQuQVRfVEFSR0VUIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRoaXMgfSk7XHJcbiAgICAgIHRoaXMuY2FsbExpc3RlbmVycyh0aGlzLmNhcHR1cmVzW19ldmVudC50eXBlXSwgX2V2ZW50KTtcclxuICAgICAgdGhpcy5jYWxsTGlzdGVuZXJzKHRoaXMubGlzdGVuZXJzW19ldmVudC50eXBlXSwgX2V2ZW50KTtcclxuXHJcbiAgICAgIGlmICghX2V2ZW50LmJ1YmJsZXMpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAvLyBidWJibGUgcGhhc2VcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJldmVudFBoYXNlXCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBFdmVudC5CVUJCTElOR19QSEFTRSB9KTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IGFuY2VzdG9yc1tpXTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGFuY2VzdG9yIH0pO1xyXG4gICAgICAgIHRoaXMuY2FsbExpc3RlbmVycyhhbmNlc3Rvci5saXN0ZW5lcnNbX2V2ZW50LnR5cGVdLCBfZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlOyAvL1RPRE86IHJldHVybiBhIG1lYW5pbmdmdWwgdmFsdWUsIHNlZSBkb2N1bWVudGF0aW9uIG9mIGRpc3BhdGNoIGV2ZW50XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3BhdGNoZXMgYSBzeW50aGV0aWMgZXZlbnQgdG8gdGFyZ2V0IHdpdGhvdXQgdHJhdmVsbGluZyB0aHJvdWdoIHRoZSBncmFwaCBoaWVyYXJjaHkgbmVpdGhlciBkdXJpbmcgY2FwdHVyZSBub3IgYnViYmxpbmcgcGhhc2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGRpc3BhdGNoRXZlbnRUb1RhcmdldE9ubHkoX2V2ZW50OiBFdmVudCk6IGJvb2xlYW4ge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImV2ZW50UGhhc2VcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IEV2ZW50LkFUX1RBUkdFVCB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJjdXJyZW50VGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0aGlzIH0pO1xyXG4gICAgICB0aGlzLmNhbGxMaXN0ZW5lcnModGhpcy5saXN0ZW5lcnNbX2V2ZW50LnR5cGVdLCBfZXZlbnQpOyAvLyBUT0RPOiBleGFtaW5lIGlmIHRoaXMgc2hvdWxkIGdvIHRvIHRoZSBjYXB0dXJlcyBpbnN0ZWFkIG9mIHRoZSBsaXN0ZW5lcnNcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJyb2FkY2FzdHMgYSBzeW50aGV0aWMgZXZlbnQgdG8gdGhpcyBub2RlIGFuZCBmcm9tIHRoZXJlIHRvIGFsbCBub2RlcyBkZWVwZXIgaW4gdGhlIGhpZXJhcmNoeSxcclxuICAgICAqIGludm9raW5nIG1hdGNoaW5nIGhhbmRsZXJzIG9mIHRoZSBub2RlcyBsaXN0ZW5pbmcgdG8gdGhlIGNhcHR1cmUgcGhhc2UuIFdhdGNoIHBlcmZvcm1hbmNlIHdoZW4gdGhlcmUgYXJlIG1hbnkgbm9kZXMgaW52b2x2ZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGJyb2FkY2FzdEV2ZW50KF9ldmVudDogRXZlbnQpOiB2b2lkIHtcclxuICAgICAgLy8gb3ZlcndyaXRlIGV2ZW50IHRhcmdldCBhbmQgcGhhc2VcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJldmVudFBoYXNlXCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBFdmVudC5DQVBUVVJJTkdfUEhBU0UgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwidGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0aGlzIH0pO1xyXG4gICAgICB0aGlzLmJyb2FkY2FzdEV2ZW50UmVjdXJzaXZlKF9ldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBicm9hZGNhc3RFdmVudFJlY3Vyc2l2ZShfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICAgIC8vIGNhcHR1cmUgcGhhc2Ugb25seVxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImN1cnJlbnRUYXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRoaXMgfSk7XHJcbiAgICAgIGxldCBjYXB0dXJlczogRXZlbnRMaXN0ZW5lclVuaWZpZWRbXSA9IHRoaXMuY2FwdHVyZXNbX2V2ZW50LnR5cGVdO1xyXG4gICAgICBpZiAoY2FwdHVyZXMpIHtcclxuICAgICAgICBjYXB0dXJlcyA9IFsuLi5jYXB0dXJlc107IC8vIGNyZWF0ZSBhIGNvcHkgdG8gYXZvaWQgcHJvYmxlbXMgd2l0aCBoYW5kbGVycyB0aGF0IGRldGFjaCB0aGVtc2VsdmVzXHJcbiAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBjYXB0dXJlcylcclxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgIGhhbmRsZXIoX2V2ZW50KTtcclxuICAgICAgICAvLyBhcHBlYXJzIHRvIGJlIHNsb3dlciwgYXN0b25pc2hpbmdseS4uLlxyXG4gICAgICAgIC8vIGNhcHR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXI6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgLy8gICAgIGhhbmRsZXIoX2V2ZW50KTtcclxuICAgICAgICAvLyB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc2FtZSBmb3IgY2hpbGRyZW5cclxuICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgIGNoaWxkLmJyb2FkY2FzdEV2ZW50UmVjdXJzaXZlKF9ldmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNhbGxMaXN0ZW5lcnMoX2xpc3RlbmVyczogRXZlbnRMaXN0ZW5lclVuaWZpZWRbXSwgX2V2ZW50OiBFdmVudCk6IHZvaWQge1xyXG4gICAgICBpZiAoX2xpc3RlbmVycz8ubGVuZ3RoID4gMClcclxuICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIF9saXN0ZW5lcnMpXHJcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICBoYW5kbGVyKF9ldmVudCk7XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UcmFuc2Zlci9TZXJpYWxpemVyLnRzXCIvPlxyXG4vLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RyYW5zZmVyL011dGFibGUudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKiBcclxuICAgKiBTdXBlcmNsYXNzIGZvciBhbGwge0BsaW5rIENvbXBvbmVudH1zIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIHtAbGluayBOb2RlfXMuXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjAgfCBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSAgXHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2hzLWZ1cnR3YW5nZW4vRlVER0Uvd2lraS9Db21wb25lbnRcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSwgR2l6bW8ge1xyXG4gICAgLyoqIHN1YmNsYXNzZXMgZ2V0IGEgaVN1YmNsYXNzIG51bWJlciBmb3IgaWRlbnRpZmljYXRpb24gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXI7XHJcbiAgICAvKiogcmVmZXJzIGJhY2sgdG8gdGhpcyBjbGFzcyBmcm9tIGFueSBzdWJjbGFzcyBlLmcuIGluIG9yZGVyIHRvIGZpbmQgY29tcGF0aWJsZSBvdGhlciByZXNvdXJjZXMqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBiYXNlQ2xhc3M6IHR5cGVvZiBDb21wb25lbnQgPSBDb21wb25lbnQ7XHJcbiAgICAvKiogbGlzdCBvZiBhbGwgdGhlIHN1YmNsYXNzZXMgZGVyaXZlZCBmcm9tIHRoaXMgY2xhc3MsIGlmIHRoZXkgcmVnaXN0ZXJlZCBwcm9wZXJseSovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN1YmNsYXNzZXM6IHR5cGVvZiBDb21wb25lbnRbXSA9IFtdO1xyXG5cclxuICAgIHByb3RlY3RlZCBzaW5nbGV0b246IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgcHJvdGVjdGVkIGFjdGl2ZTogYm9vbGVhbiA9IHRydWU7XHJcbiAgICAjbm9kZTogTm9kZSB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk1VVEFURSwgKF9ldmVudDogQ3VzdG9tRXZlbnQpID0+IHtcclxuICAgICAgICBpZiAodGhpcy4jbm9kZSkge1xyXG4gICAgICAgICAgLy8gVE9ETzogZmluZCB0aGUgbnVtYmVyIG9mIHRoZSBjb21wb25lbnQgaW4gdGhlIGFycmF5IGlmIG5vdCBzaW5nbGV0b25cclxuICAgICAgICAgIF9ldmVudC5kZXRhaWwuY29tcG9uZW50ID0gdGhpcztcclxuICAgICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgICAgX2V2ZW50LmRldGFpbC5jb21wb25lbnRJbmRleCA9IHRoaXMubm9kZS5nZXRDb21wb25lbnRzKHRoaXMuY29uc3RydWN0b3IpLmluZGV4T2YodGhpcyk7XHJcbiAgICAgICAgICB0aGlzLiNub2RlLmRpc3BhdGNoRXZlbnQoX2V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViY2xhc3M6IHR5cGVvZiBDb21wb25lbnQpOiBudW1iZXIgeyByZXR1cm4gQ29tcG9uZW50LnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaXNBY3RpdmUoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIElzIHRydWUsIHdoZW4gb25seSBvbmUgaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCBjbGFzcyBjYW4gYmUgYXR0YWNoZWQgdG8gYSBub2RlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgaXNTaW5nbGV0b24oKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNpbmdsZXRvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgbm9kZSwgdGhpcyBjb21wb25lbnQgaXMgY3VycmVudGx5IGF0dGFjaGVkIHRvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbm9kZSgpOiBOb2RlIHwgbnVsbCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGUtIC8gQWN0aXZhdGUgdGhpcyBjb21wb25lbnQuIEluYWN0aXZlIGNvbXBvbmVudHMgd2lsbCBub3QgYmUgcHJvY2Vzc2VkIGJ5IHRoZSByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlKF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IF9vbjtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChfb24gPyBFVkVOVC5DT01QT05FTlRfQUNUSVZBVEUgOiBFVkVOVC5DT01QT05FTlRfREVBQ1RJVkFURSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJpZXMgdG8gYXR0YWNoIHRoZSBjb21wb25lbnQgdG8gdGhlIGdpdmVuIG5vZGUsIHJlbW92aW5nIGl0IGZyb20gdGhlIG5vZGUgaXQgd2FzIGF0dGFjaGVkIHRvIGlmIGFwcGxpY2FibGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGF0dGFjaFRvTm9kZShfY29udGFpbmVyOiBOb2RlIHwgbnVsbCk6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy4jbm9kZSA9PSBfY29udGFpbmVyKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgbGV0IHByZXZpb3VzQ29udGFpbmVyOiBOb2RlID0gdGhpcy4jbm9kZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAocHJldmlvdXNDb250YWluZXIpXHJcbiAgICAgICAgICBwcmV2aW91c0NvbnRhaW5lci5yZW1vdmVDb21wb25lbnQodGhpcyk7XHJcbiAgICAgICAgdGhpcy4jbm9kZSA9IF9jb250YWluZXI7XHJcbiAgICAgICAgaWYgKHRoaXMuI25vZGUpXHJcbiAgICAgICAgICB0aGlzLiNub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgdGhpcy4jbm9kZSA9IHByZXZpb3VzQ29udGFpbmVyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZSB0aGlzIHRvIGRyYXcgdmlzdWFsIGFpZHMgZm9yIHRoaXMgY29tcG9uZW50IGluc2lkZSB0aGUgZWRpdG9ycyByZW5kZXIgdmlldy4gVXNlIHtAbGluayBHaXptb3N9IGluc2lkZSB0aGUgb3ZlcnJpZGUgdG8gZHJhdyBzdHVmZi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRyYXdHaXptb3M/KF9jbXBDYW1lcmE/OiBDb21wb25lbnRDYW1lcmEpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VlIHtAbGluayBkcmF3R2l6bW9zfS4gT25seSBkaXNwbGF5ZWQgd2hpbGUgdGhlIGNvcnJlc3BvbmRpbmcgbm9kZSBpcyBzZWxlY3RlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRyYXdHaXptb3NTZWxlY3RlZD8oX2NtcENhbWVyYT86IENvbXBvbmVudENhbWVyYSk6IHZvaWQ7XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBhY3RpdmU6IHRoaXMuYWN0aXZlXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuYWN0aXZhdGUoX3NlcmlhbGl6YXRpb24uYWN0aXZlKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IuYWN0aXZlKSAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICB0aGlzLmFjdGl2YXRlKF9tdXRhdG9yLmFjdGl2ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNpbmdsZXRvbjtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLm10eFdvcmxkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFdyYXBzIGEgcmVndWxhciBKYXZhc2NyaXB0IEFycmF5IGFuZCBvZmZlcnMgdmVyeSBsaW1pdGVkIGZ1bmN0aW9uYWxpdHkgZ2VhcmVkIHNvbGVseSB0b3dhcmRzIGF2b2lkaW5nIGdhcmJhZ2UgY29sbGV0aW9uLlxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vaHMtZnVydHdhbmdlbi9GVURHRS93aWtpL1JlY3ljbGVyXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFJlY3ljYWJsZUFycmF5PFQ+IHsgLy8gVE9ETzogZml4IHNwZWxsaW5nIFJlY3ljYWJsZSAtPiBSZWN5Y2xhYmxlXHJcbiAgICAjbGVuZ3RoOiBudW1iZXIgPSAwO1xyXG4gICAgI2FycmF5OiBBcnJheTxUPiA9IG5ldyBBcnJheTxUPigpO1xyXG4gICAgLy8gI3R5cGU6IG5ldyAoKSA9PiBUO1xyXG5cclxuICAgIC8vIC8vdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgLy8gY29uc3RydWN0b3IoX3R5cGU6IG5ldyAoLi4uYXJnczogYW55W10pID0+IFQpIHtcclxuICAgIC8vICAgdGhpcy4jdHlwZSA9IF90eXBlO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNsZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB2aXJ0dWFsIGxlbmd0aCBvZiB0aGUgYXJyYXkgdG8gemVybyBidXQga2VlcHMgdGhlIGVudHJpZXMgYmV5b25kLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI2xlbmd0aCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWN5Y2xlIHRoaXMgYXJyYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgYSBuZXcgZW50cnkgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXksIGFuZCByZXR1cm5zIHRoZSBuZXcgbGVuZ3RoIG9mIHRoZSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHB1c2goX2VudHJ5OiBUKTogbnVtYmVyIHtcclxuICAgICAgdGhpcy4jYXJyYXlbdGhpcy4jbGVuZ3RoXSA9IF9lbnRyeTtcclxuICAgICAgdGhpcy4jbGVuZ3RoKys7XHJcbiAgICAgIHJldHVybiB0aGlzLiNsZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBsYXN0IGVudHJ5IGZyb20gdGhlIGFycmF5IGFuZCByZXR1cm5zIGl0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9wKCk6IFQge1xyXG4gICAgICBpZiAodGhpcy4jbGVuZ3RoID09IDApXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIHRoaXMuI2xlbmd0aC0tO1xyXG4gICAgICByZXR1cm4gdGhpcy4jYXJyYXlbdGhpcy4jbGVuZ3RoXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3ljbGVzIHRoZSBvYmplY3QgZm9sbG93aW5nIHRoZSBsYXN0IGluIHRoZSBhcnJheSBhbmQgaW5jcmVhc2VzIHRoZSBhcnJheSBsZW5ndGhcclxuICAgICAqIEl0IG11c3QgYmUgYXNzdXJlZCwgdGhhdCBub25lIG9mIHRoZSBvYmplY3RzIGluIHRoZSBhcnJheSBpcyBzdGlsbCBpbiBhbnkgdXNlIG9mIGFueSBraW5kIVxyXG4gICAgICovXHJcbiAgICAvLyBwdWJsaWMgcmVjeWNsZSgpOiBUIHtcclxuICAgIC8vICAgaWYgKHRoaXMuI2xlbmd0aCA8IHRoaXMuI2FycmF5Lmxlbmd0aCkge1xyXG4gICAgLy8gICAgIHRoaXMuI2xlbmd0aCsrO1xyXG4gICAgLy8gICAgIHJldHVybiB0aGlzLiNhcnJheVt0aGlzLiNsZW5ndGgrK107XHJcbiAgICAvLyAgIH1cclxuICAgIC8vICAgdGhpcy4jYXJyYXkucHVzaChSZWN5Y2xlci5nZXQodGhpcy4jdHlwZSkpO1xyXG4gICAgLy8gICByZXR1cm4gdGhpcy4jYXJyYXlbdGhpcy4jbGVuZ3RoKytdO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHB1YmxpYyAqW1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmFibGVJdGVyYXRvcjxUPiB7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLiNsZW5ndGg7IGkrKylcclxuICAgICAgICB5aWVsZCB0aGlzLiNhcnJheVtpXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBhcnJheSBzb3J0ZWQgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBjb21wYXJlIGZ1bmN0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTb3J0ZWQoX3NvcnQ6IChhOiBULCBiOiBUKSA9PiBudW1iZXIpOiBUW10ge1xyXG4gICAgICBsZXQgc29ydGVkOiBUW10gPSB0aGlzLiNhcnJheS5zbGljZSgwLCB0aGlzLiNsZW5ndGgpO1xyXG4gICAgICBzb3J0ZWQuc29ydChfc29ydCk7XHJcbiAgICAgIHJldHVybiBzb3J0ZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX1BIWVNJQ1Mge1xyXG4gICAgVFJJR0dFUl9FTlRFUiA9IFwiVHJpZ2dlckVudGVyZWRDb2xsaXNpb25cIixcclxuICAgIFRSSUdHRVJfRVhJVCA9IFwiVHJpZ2dlckxlZnRDb2xsaXNpb25cIixcclxuICAgIENPTExJU0lPTl9FTlRFUiA9IFwiQ29sbGlkZXJFbnRlcmVkQ29sbGlzaW9uXCIsXHJcbiAgICBDT0xMSVNJT05fRVhJVCA9IFwiQ29sbGlkZXJMZWZ0Q29sbGlzaW9uXCJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNwZWNpYWwgdHlwZSBvZiB7QGxpbmsgRXZlbnR9IGZvciBwaHlzaWNzLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBFdmVudFBoeXNpY3MgZXh0ZW5kcyBFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIENvbXBvbmVudFJpZ2lkYm9keSB0aGF0IGNvbGxpZGVkIHdpdGggdGhpcyBDb21wb25lbnRSaWdpZGJvZHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNtcFJpZ2lkYm9keTogQ29tcG9uZW50UmlnaWRib2R5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbm9ybWFsIGltcHVsc2UgYmV0d2VlbiB0aGUgdHdvIGNvbGxpZGluZyBvYmplY3RzLiBOb3JtYWwgcmVwcmVzZW50cyB0aGUgZGVmYXVsdCBpbXB1bHNlLlxyXG4gICAgICogSW1wdWxzZSBpcyBvbmx5IGhhcHBlbmluZyBvbiBDT0xMSVNJT05fRU5URVIsIHNvIHRoZXJlIGlzIG5vIGltcHVsc2Ugb24gZXhpdCBub3Igb24gdHJpZ2dlcnMuXHJcbiAgICAgKiBVc2UgdGhlIHZlbG9jaXR5IG9mIHRoZSBjbXBSaWdpZGJvZHkgdG8gZGV0ZXJtaW5lIHRoZSBpbnRlbnNpdHkgb2YgdGhlIEVWRU5UIGluc3RlYWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBub3JtYWxJbXB1bHNlOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgdGFuZ2VudEltcHVsc2U6IG51bWJlcjtcclxuICAgIHB1YmxpYyBiaW5vbWFsSW1wdWxzZTogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBwb2ludCB3aGVyZSB0aGUgY29sbGlzaW9uL3RyaWdnZXJpbmcgaW5pdGlhbGx5IGhhcHBlbmVkLiBUaGUgY29sbGlzaW9uIHBvaW50IGV4aXN0cyBvbmx5IG9uIENPTExJU0lPTl9FTlRFUiAvIFRSSUdHRVJfRU5URVIuICovXHJcbiAgICBwdWJsaWMgY29sbGlzaW9uUG9pbnQ6IFZlY3RvcjM7XHJcbiAgICAvKiogVGhlIG5vcm1hbCB2ZWN0b3Igb2YgdGhlIGNvbGxpc2lvbi4gT25seSBleGlzdGluZyBvbiBDT0xMSVNJT05fRU5URVIgKi9cclxuICAgIHB1YmxpYyBjb2xsaXNpb25Ob3JtYWw6IFZlY3RvcjM7XHJcblxyXG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgZXZlbnQgY3VzdG9taXplZCBmb3IgcGh5c2ljcy4gSG9sZGluZyBpbmZvcm1hdGlvbnMgYWJvdXQgaW1wdWxzZXMuIENvbGxpc2lvbiBwb2ludCBhbmQgdGhlIGJvZHkgdGhhdCBpcyBjb2xsaWRpbmcgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfdHlwZTogRVZFTlRfUEhZU0lDUywgX2hpdFJpZ2lkYm9keTogQ29tcG9uZW50UmlnaWRib2R5LCBfbm9ybWFsSW1wdWxzZTogbnVtYmVyLCBfdGFuZ2VudEltcHVsc2U6IG51bWJlciwgX2Jpbm9ybWFsSW1wdWxzZTogbnVtYmVyLCBfY29sbGlzaW9uUG9pbnQ6IFZlY3RvcjMgPSBudWxsLCBfY29sbGlzaW9uTm9ybWFsOiBWZWN0b3IzID0gbnVsbCkge1xyXG4gICAgICBzdXBlcihfdHlwZSk7XHJcbiAgICAgIHRoaXMuY21wUmlnaWRib2R5ID0gX2hpdFJpZ2lkYm9keTtcclxuICAgICAgdGhpcy5ub3JtYWxJbXB1bHNlID0gX25vcm1hbEltcHVsc2U7XHJcbiAgICAgIHRoaXMudGFuZ2VudEltcHVsc2UgPSBfdGFuZ2VudEltcHVsc2U7XHJcbiAgICAgIHRoaXMuYmlub21hbEltcHVsc2UgPSBfYmlub3JtYWxJbXB1bHNlO1xyXG4gICAgICB0aGlzLmNvbGxpc2lvblBvaW50ID0gX2NvbGxpc2lvblBvaW50O1xyXG4gICAgICB0aGlzLmNvbGxpc2lvbk5vcm1hbCA9IF9jb2xsaXNpb25Ob3JtYWw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIEdyb3VwcyB0byBwbGFjZSBhIG5vZGUgaW4sIG5vdCBldmVyeSBncm91cCBzaG91bGQgY29sbGlkZSB3aXRoIGV2ZXJ5IGdyb3VwLiBVc2UgYSBNYXNrIGluIHRvIGV4Y2x1ZGUgY29sbGlzaW9uc1xyXG4gICovXHJcbiAgZXhwb3J0IGVudW0gQ09MTElTSU9OX0dST1VQIHsgLy9UT0RPIEdpdmUgYSBwb3NzaWJsaXRoeSB0byBzZXQgd2hpY2ggbGF5ZXIgY29sbGlkZXMgd2l0aCB3aGljaCwgQ29sbGlzaW9uTWF0cml4P1xyXG4gICAgREVGQVVMVCA9IDEsXHJcbiAgICBHUk9VUF8xID0gMixcclxuICAgIEdST1VQXzIgPSA0LFxyXG4gICAgR1JPVVBfMyA9IDgsXHJcbiAgICBHUk9VUF80ID0gMTYsXHJcbiAgICBHUk9VUF81ID0gMzJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogRGVmaW5lcyB0aGUgdHlwZSBvZiB0aGUgcmlnaWRib2R5IHdoaWNoIGRldGVybWluZXMgdGhlIHdheSBpdCBpbnRlcmFjdHMgd2l0aCB0aGUgcGh5c2ljYWwgYW5kIHRoZSB2aXN1YWwgd29ybGRcclxuICAqL1xyXG4gIGV4cG9ydCBlbnVtIEJPRFlfVFlQRSB7XHJcbiAgICAvKiogVGhlIGJvZHkgaWdub3JlcyB0aGUgaGllcmFyY2h5IG9mIHRoZSByZW5kZXIgZ3JhcGgsIGlzIGNvbXBsZXRlbHkgY29udHJvbGxlZCAgYnkgcGh5c2ljcyBhbmQgdGFrZXMgaXRzIG5vZGUgd2l0aCBpdCAgKi9cclxuICAgIERZTkFNSUMsIC8vID0gT0lNTy5SaWdpZEJvZHlUeXBlLkRZTkFNSUMsXHJcbiAgICAvKiogVGhlIGJvZHkgaWdub3JlcyB0aGUgaGllcmFyY2h5IG9mIHRoZSByZW5kZXIgZ3JhcGgsIGlzIGNvbXBsZXRlbHkgaW1tb3ZlYmxlIGFuZCBrZWVwcyBpdHMgbm9kZSBmcm9tIG1vdmluZyAgKi9cclxuICAgIFNUQVRJQywgLy8gPSBPSU1PLlJpZ2lkQm9keVR5cGUuU1RBVElDLFxyXG4gICAgLyoqIFRoZSBib2R5IGlzIGNvbnRyb2xsZWQgYnkgaXRzIG5vZGUgYW5kIG1vdmVzIHdpdGggaXQsIHdoaWxlIGl0IGltcGFjdHMgdGhlIHBoeXNpY2FsIHdvcmxkIGUuZy4gYnkgY29sbGlzaW9ucyAqL1xyXG4gICAgS0lORU1BVElDIC8vID0gT0lNTy5SaWdpZEJvZHlUeXBlLktJTkVNQVRJQ1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgKiBEaWZmZXJlbnQgdHlwZXMgb2YgY29sbGlkZXIgc2hhcGVzLCB3aXRoIGRpZmZlcmVudCBvcHRpb25zIGluIHNjYWxpbmcgQk9YID0gVmVjdG9yMyhsZW5ndGgsIGhlaWdodCwgZGVwdGgpLFxyXG4gICogU1BIRVJFID0gVmVjdG9yMyhkaWFtZXRlciwgeCwgeCksIENBUFNVTEUgPSBWZWN0b3IzKGRpYW1ldGVyLCBoZWlnaHQsIHgpLCBDWUxJTkRFUiA9IFZlY3RvcjMoZGlhbWV0ZXIsIGhlaWdodCwgeCksXHJcbiAgKiBDT05FID0gVmVjdG9yKGRpYW1ldGVyLCBoZWlnaHQsIHgpLCBQWVJBTUlEID0gVmVjdG9yMyhsZW5ndGgsIGhlaWdodCwgZGVwdGgpOyB4ID09IHVudXNlZC5cclxuICAqIENPTlZFWCA9IENvbXBvbmVudE1lc2ggbmVlZHMgdG8gYmUgYXZhaWxhYmxlIGluIHRoZSBSQiBQcm9wZXJ0eSBjb252ZXhNZXNoLCB0aGUgcG9pbnRzIG9mIHRoYXQgY29tcG9uZW50IGFyZSB1c2VkIHRvIGNyZWF0ZSBhIGNvbGxpZGVyIHRoYXQgbWF0Y2hlcyxcclxuICAqIHRoZSBjbG9zZXN0IHBvc3NpYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoYXQgZm9ybSwgaW4gZm9ybSBvZiBhIGh1bGwuIENvbnZleCBpcyBleHBlcmltZW50YWwgYW5kIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgYmVoYXZpb3VyIHdoZW4gdmVydGljZXNcclxuICAqIGFyZSB0b28gY2xvc2UgdG8gb25lIGFub3RoZXIgYW5kIHRoZSBnaXZlbiB2ZXJ0aWNlcyBkbyBub3QgZm9ybSBhIGluIGl0c2VsZiBjbG9zZWQgc2hhcGUgYW5kIGhhdmluZyBhIGdlbnVzIG9mIDAgKG5vIGhvbGVzKS4gVmVydGljZXMgaW4gdGhlIENvbXBvbmVudE1lc2ggY2FuIGJlIHNjYWxlZCBkaWZmZXJlbnRseSBcclxuICAqIGZvciB0ZXh0dXJpbmcvbm9ybWFsIG9yIG90aGVyIHJlYXNvbnMsIHNvIHRoZSBjb2xsaWRlciBtaWdodCBiZSBvZmYgY29tcGFyZWQgdG8gdGhlIHZpc3VhbCBzaGFwZSwgdGhpcyBjYW4gYmUgY29ycmVjdGVkIGJ5IGNoYW5naW5nIHRoZSBwaXZvdCBzY2FsZSBvZiB0aGUgQ29tcG9uZW50UmlnaWRib2R5LiAgXHJcbiAgKi9cclxuICBleHBvcnQgZW51bSBDT0xMSURFUl9UWVBFIHtcclxuICAgIENVQkUsXHJcbiAgICBTUEhFUkUsXHJcbiAgICBDQVBTVUxFLFxyXG4gICAgQ1lMSU5ERVIsXHJcbiAgICBDT05FLFxyXG4gICAgUFlSQU1JRCxcclxuICAgIENPTlZFWFxyXG4gIH1cclxuXHJcbiAgLyoqIERpc3BsYXlpbmcgZGlmZmVyZW50IHR5cGVzIG9mIGRlYnVnIGluZm9ybWF0aW9uIGFib3V0IGRpZmZlcmVudCBwaHlzaWMgZmVhdHVyZXMuIERlZmF1bHQgPSBKT0lOVFNfQU5EX0NPTExJREVSLiAqL1xyXG4gIGV4cG9ydCBlbnVtIFBIWVNJQ1NfREVCVUdNT0RFIHtcclxuICAgIE5PTkUsXHJcbiAgICBDT0xMSURFUlMsXHJcbiAgICBKT0lOVFNfQU5EX0NPTExJREVSLFxyXG4gICAgQk9VTkRJTkdfQk9YRVMsXHJcbiAgICBDT05UQUNUUyxcclxuICAgIFBIWVNJQ19PQkpFQ1RTX09OTFlcclxuICB9XHJcblxyXG4gIC8qKiBJbmZvIGFib3V0IFJheWNhc3RzIHNob3QgZnJvbSB0aGUgcGh5c2ljcyBzeXN0ZW0uICovXHJcbiAgZXhwb3J0IGNsYXNzIFJheUhpdEluZm8gaW1wbGVtZW50cyBSZWN5Y2FibGUge1xyXG4gICAgcHVibGljIGhpdDogYm9vbGVhbjtcclxuICAgIHB1YmxpYyBoaXREaXN0YW5jZTogbnVtYmVyO1xyXG4gICAgcHVibGljIGhpdFBvaW50OiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7XHJcbiAgICBwdWJsaWMgcmlnaWRib2R5Q29tcG9uZW50OiBDb21wb25lbnRSaWdpZGJvZHk7XHJcbiAgICBwdWJsaWMgaGl0Tm9ybWFsOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7XHJcbiAgICBwdWJsaWMgcmF5RW5kOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7XHJcbiAgICBwdWJsaWMgcmF5T3JpZ2luOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICB0aGlzLnJlY3ljbGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5oaXQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5oaXREaXN0YW5jZSA9IDA7XHJcbiAgICAgIHRoaXMuaGl0UG9pbnQucmVjeWNsZSgpO1xyXG4gICAgICB0aGlzLnJpZ2lkYm9keUNvbXBvbmVudCA9IG51bGw7XHJcbiAgICAgIHRoaXMuaGl0Tm9ybWFsLnJlY3ljbGUoKTtcclxuICAgICAgdGhpcy5yYXlPcmlnaW4ucmVjeWNsZSgpO1xyXG4gICAgICB0aGlzLnJheUVuZC5yZWN5Y2xlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogR2VuZXJhbCBzZXR0aW5ncyBmb3IgdGhlIHBoeXNpYyBzaW11bGF0aW9uIGFuZCB0aGUgZGVidWcgb2YgaXQuICovXHJcbiAgZXhwb3J0IGNsYXNzIFBoeXNpY3NTZXR0aW5ncyB7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9kZWZhdWx0Q29sbGlzaW9uR3JvdXA6IG51bWJlciwgX2RlZmF1bHRDb2xsaXNpb25NYXNrOiBudW1iZXIpIHtcclxuICAgICAgaWYgKHR5cGVvZiBPSU1PID09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB0aGlzLmRlZmF1bHRDb2xsaXNpb25Hcm91cCA9IF9kZWZhdWx0Q29sbGlzaW9uR3JvdXA7XHJcbiAgICAgIHRoaXMuZGVmYXVsdENvbGxpc2lvbk1hc2sgPSBfZGVmYXVsdENvbGxpc2lvbk1hc2s7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENoYW5nZSBpZiByaWdpZGJvZGllcyBhcmUgYWJsZSB0byBzbGVlcCAoZG9uJ3QgYmUgY29uc2lkZXJlZCBpbiBwaHlzaWNhbCBjYWxjdWxhdGlvbnMpIHdoZW4gdGhlaXIgbW92ZW1lbnQgaXMgYmVsb3cgYSB0aHJlc2hvbGQuIERlYWN0aXZhdGlvbiBpcyBkZWNyZWFzaW5nIHBlcmZvcm1hbmNlIGZvciBtaW5vciBhZHZhbnRhZ2UgaW4gcHJlY2lzaW9uLiAqL1xyXG4gICAgcHVibGljIGdldCBkaXNhYmxlU2xlZXBpbmcoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuZGlzYWJsZVNsZWVwaW5nO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBkaXNhYmxlU2xlZXBpbmcoX3ZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgIE9JTU8uU2V0dGluZy5kaXNhYmxlU2xlZXBpbmcgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKiogU2xlZXBpbmcgVGhyZXNob2xkIGZvciBNb3ZlbWVudCBWZWxvY3RpeS4gKi9cclxuICAgIHB1YmxpYyBnZXQgc2xlZXBpbmdWZWxvY2l0eVRocmVzaG9sZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLnNsZWVwaW5nVmVsb2NpdHlUaHJlc2hvbGQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNsZWVwaW5nVmVsb2NpdHlUaHJlc2hvbGQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgT0lNTy5TZXR0aW5nLnNsZWVwaW5nVmVsb2NpdHlUaHJlc2hvbGQgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFNsZWVwaW5nIFRocmVzaG9sZCBmb3IgUm90YXRpb24gVmVsb2NpdHkuICovXHJcbiAgICBwdWJsaWMgZ2V0IHNsZWVwaW5nQW5ndWxhclZlbG9jaXR5VGhyZXNob2xkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuc2xlZXBpbmdBbmd1bGFyVmVsb2NpdHlUaHJlc2hvbGQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNsZWVwaW5nQW5ndWxhclZlbG9jaXR5VGhyZXNob2xkKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIE9JTU8uU2V0dGluZy5zbGVlcGluZ0FuZ3VsYXJWZWxvY2l0eVRocmVzaG9sZCA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhyZXNob2xkIGhvdyBsb25nIHRoZSBSaWdpZGJvZHkgbXVzdCBiZSBiZWxvdy9hYm92ZSB0aGUgdGhyZXNob2xkIHRvIGNvdW50IGFzIHNsZWVwaW5nLiAqL1xyXG4gICAgcHVibGljIGdldCBzbGVlcGluZ1RpbWVUaHJlc2hvbGQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIE9JTU8uU2V0dGluZy5zbGVlcGluZ1RpbWVUaHJlc2hvbGQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNsZWVwaW5nVGltZVRocmVzaG9sZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBPSU1PLlNldHRpbmcuc2xlZXBpbmdUaW1lVGhyZXNob2xkID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBFcnJvciB0aHJlc2hvbGQuIERlZmF1bHQgaXMgMC4wNS4gVGhlIGhpZ2hlciB0aGUgbW9yZSBsaWtlbHkgY29sbGlzaW9ucyBnZXQgZGV0ZWN0ZWQgYmVmb3JlIGFjdHVhbCBpbXBhY3QgYXQgaGlnaCBzcGVlZHMgYnV0IGl0J3MgdmlzdWFsbHkgbGVzcyBhY2N1cmF0ZS4gKi9cclxuICAgIHB1YmxpYyBnZXQgZGVmYXVsdENvbGxpc2lvbk1hcmdpbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLmRlZmF1bHRHSktNYXJnaW47XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGRlZmF1bHRDb2xsaXNpb25NYXJnaW4oX3RoaWNrbmVzczogbnVtYmVyKSB7XHJcbiAgICAgIE9JTU8uU2V0dGluZy5kZWZhdWx0R0pLTWFyZ2luID0gX3RoaWNrbmVzcztcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIGRlZmF1bHQgYXBwbGllZCBmcmljdGlvbiBiZXR3ZWVuIHR3byByaWdpZGJvZGllcyB3aXRoIHRoZSBkZWZhdWx0IHZhbHVlLiBIb3cgbXVjaCB2ZWxvY2l0eSBpcyBzbG93ZWQgZG93biB3aGVuIG1vdmluZyBhY2Nyb3NzIHRoaXMgc3VyZmFjZS4gKi9cclxuICAgIHB1YmxpYyBnZXQgZGVmYXVsdEZyaWN0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuZGVmYXVsdEZyaWN0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBkZWZhdWx0RnJpY3Rpb24oX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgT0lNTy5TZXR0aW5nLmRlZmF1bHRGcmljdGlvbiA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQm91bmNpbmVzcyBvZiByaWdpZGJvZGllcy4gSG93IG11Y2ggb2YgdGhlIGltcGFjdCBpcyByZXN0aXR1dGVkLiAqL1xyXG4gICAgcHVibGljIGdldCBkZWZhdWx0UmVzdGl0dXRpb24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIE9JTU8uU2V0dGluZy5kZWZhdWx0UmVzdGl0dXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGRlZmF1bHRSZXN0aXR1dGlvbihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBPSU1PLlNldHRpbmcuZGVmYXVsdFJlc3RpdHV0aW9uID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHcm91cHMgdGhlIGRlZmF1bHQgcmlnaWRib2R5IHdpbGwgY29sbGlkZSB3aXRoLiBTZXQgaXQgbGlrZTogKFBIWVNJQ1NfR1JPVVAuREVGQVVMVCB8IFBIWVNJQ1NfR1JPVVAuR1JPVVBfMSB8IFBIWVNJQ1NfR1JPVVAuR1JPVVBfMiB8IFBIWVNJQ1NfR1JPVVAuR1JPVVBfMykgXHJcbiAgICAgKiB0byBjb2xsaWRlIHdpdGggbXVsdGlwbGUgZ3JvdXBzLiBEZWZhdWx0IGlzIGNvbGxpc2lvbiB3aXRoIGV2ZXJ5dGhpbmcgYnV0IHRyaWdnZXJzLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBnZXQgZGVmYXVsdENvbGxpc2lvbk1hc2soKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIE9JTU8uU2V0dGluZy5kZWZhdWx0Q29sbGlzaW9uTWFzaztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgZGVmYXVsdENvbGxpc2lvbk1hc2soX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgT0lNTy5TZXR0aW5nLmRlZmF1bHRDb2xsaXNpb25NYXNrID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgZ3JvdXAgdGhhdCB0aGlzIHJpZ2lkYm9keSBiZWxvbmdzIHRvLiBEZWZhdWx0IGlzIHRoZSBERUZBVUxUIEdyb3VwIHdoaWNoIG1lYW5zIGl0cyBqdXN0IGEgbm9ybWFsIFJpZ2lkYm9keSBub3QgYSB0cmlnZ2VyIG5vciBhbnl0aGluZyBzcGVjaWFsLiAqL1xyXG4gICAgcHVibGljIGdldCBkZWZhdWx0Q29sbGlzaW9uR3JvdXAoKTogQ09MTElTSU9OX0dST1VQIHtcclxuICAgICAgcmV0dXJuIDxDT0xMSVNJT05fR1JPVVA+T0lNTy5TZXR0aW5nLmRlZmF1bHRDb2xsaXNpb25Hcm91cDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgZGVmYXVsdENvbGxpc2lvbkdyb3VwKF92YWx1ZTogQ09MTElTSU9OX0dST1VQKSB7XHJcbiAgICAgIE9JTU8uU2V0dGluZy5kZWZhdWx0Q29sbGlzaW9uR3JvdXAgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENoYW5nZSB0aGUgdHlwZSBvZiBqb2ludCBzb2x2ZXIgYWxnb3JpdGhtLiBEZWZhdWx0IEl0ZXJhdGl2ZSA9PSAwLCBpcyBmYXN0ZXIgYnV0IGxlc3Mgc3RhYmxlLiBEaXJlY3QgPT0gMSwgc2xvdyBidXQgbW9yZSBzdGFibGUsIHJlY29tbWVuZGVkIGZvciBjb21wbGV4IGpvaW50IHdvcmsuIENoYW5nZSB0aGlzIHNldHRpbmcgb25seSBhdCB0aGUgc3RhcnQgb2YgeW91ciBnYW1lLiAqL1xyXG4gICAgcHVibGljIGdldCBkZWZhdWx0Q29uc3RyYWludFNvbHZlclR5cGUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIE9JTU8uU2V0dGluZy5kZWZhdWx0Sm9pbnRDb25zdHJhaW50U29sdmVyVHlwZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgZGVmYXVsdENvbnN0cmFpbnRTb2x2ZXJUeXBlKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIE9JTU8uU2V0dGluZy5kZWZhdWx0Sm9pbnRDb25zdHJhaW50U29sdmVyVHlwZSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIGNvcnJlY3Rpb24gYWxnb3JpdGhtIHVzZWQgdG8gY29ycmVjdCBwaHlzaWNzIGNhbGN1bGF0aW9ucy4gQ2hhbmdlIHRoaXMgb25seSBhdCB0aGUgYmVnaW5uaW5nIG9mIHlvdXIgZ2FtZS4gRWFjaCBoYXMgZGlmZmVyZW50IGFwcHJvYWNoZXMsIHNvIGlmIHlvdSBoYXZlIHByb2JsZW1zIHRlc3QgYW5vdGhlclxyXG4gICAgICogIERlZmF1bHQgMCA9IEJhdW1nYXJ0ZSAoZmFzdCBidXQgbGVzcyBjb3JyZWN0IGluZHVjZXMgc29tZSBlbmVyZ3kgZXJyb3JzKSwgMSA9IFNwbGl0LUltcHVsc2UgKGZhc3QgYW5kIG5vIGVuZ2VyeSBlcnJvcnMsIGJ1dCBtb3JlIGluYWNjdXJhdGUgZm9yIGpvaW50cyksIDIgPSBOb24tbGluZWFyIEdhdXNzIFNlaWRlbCAoc2xvd2VzdCBidXQgbW9zdCBhY2N1cmF0ZSkqL1xyXG4gICAgcHVibGljIGdldCBkZWZhdWx0Q29ycmVjdGlvbkFsZ29yaXRobSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLmRlZmF1bHRKb2ludFBvc2l0aW9uQ29ycmVjdGlvbkFsZ29yaXRobTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgZGVmYXVsdENvcnJlY3Rpb25BbGdvcml0aG0oX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgT0lNTy5TZXR0aW5nLmRlZmF1bHRKb2ludFBvc2l0aW9uQ29ycmVjdGlvbkFsZ29yaXRobSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIHByZWNpc2lvbiBvZiB0aGUgc2ltdWxhdGlvbiBpbiBmb3JtIG9mIG51bWJlciBvZiBpdGVyYXRpb25zIHRoZSBzaW11bGF0aW9ucyBydW5zIHRocm91Z2ggdW50aWwgaXQgYWNjZXB0cyB0aGUgcmVzdWx0LlxyXG4gICAgICogIDEwIERlZmF1bHQgLSBIaWdoZXIgbWVhbnMgbW9yZSBwcmVjaXNpb24gYnV0IHJlc3VsdHMgaW4gYSBwZXJmb3JtYW5jZSBkZWNyZWFzZS4gVGhpcyBoZWxwcyBlc3BlY2lhbGx5IHdpdGggam9pbnRzLFxyXG4gICAgICogYnV0IGFsc28gdGhlIGdlbmVyYWwgc3RhYmlsaXR5IG9mIHRoZSBzaW11bGF0aW9uIGR1ZSB0byBzaW11bGF0aW9uIHN0ZXBzIGJlaW5nIHJlY2hlY2tlZCBtdWx0aXBsZSB0aW1lcyBiZWZvcmUgYmVpbmcgc2V0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNvbHZlckl0ZXJhdGlvbnMoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIFBoeXNpY3MuYWN0aXZlSW5zdGFuY2UuZ2V0T2ltb1dvcmxkKCkuZ2V0TnVtUG9zaXRpb25JdGVyYXRpb25zKCk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNvbHZlckl0ZXJhdGlvbnMoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgUGh5c2ljcy5hY3RpdmVJbnN0YW5jZS5nZXRPaW1vV29ybGQoKS5zZXROdW1Qb3NpdGlvbkl0ZXJhdGlvbnMoX3ZhbHVlKTtcclxuICAgICAgUGh5c2ljcy5hY3RpdmVJbnN0YW5jZS5nZXRPaW1vV29ybGQoKS5zZXROdW1WZWxvY2l0eUl0ZXJhdGlvbnMoX3ZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgICAqIEFjdHMgYXMgdGhlIHBoeXNpY2FsIHJlcHJlc2VudGF0aW9uIG9mIGEgY29ubmVjdGlvbiBiZXR3ZWVuIHR3byB7QGxpbmsgTm9kZX0ncy5cclxuICAgICAqIFRoZSB0eXBlIG9mIGNvbm5jZXRpb24gaXMgZGVmaW5lZCBieSB0aGUgc3ViY2xhc3NlcyBsaWtlIHByaXNtYXRpYyBqb2ludCwgY3lsaW5kZXIgam9pbnQgZXRjLlxyXG4gICAgICogQSBSaWdpZGJvZHkgb24gdGhlIHtAbGluayBOb2RlfSB0aGF0IHRoaXMgY29tcG9uZW50IGlzIGFkZGVkIHRvIGlzIG5lZWRlZC4gU2V0dGluZyB0aGUgY29ubmVjdGVkUmlnaWRib2R5IGFuZFxyXG4gICAgICogaW5pdGlhbGl6aW5nIHRoZSBjb25uZWN0aW9uIGNyZWF0ZXMgYSBwaHlzaWNhbCBjb25uZWN0aW9uIGJldHdlZW4gdGhlbS4gVGhpcyBkaWZmZXJzIGZyb20gYSBjb25uZWN0aW9uIHRocm91Z2ggaGllcmFyY2h5XHJcbiAgICAgKiBpbiB0aGUgbm9kZSBzdHJ1Y3R1cmUgb2YgZnVkZ2UuIEpvaW50cyBjYW4gaGF2ZSBkaWZmZXJlbnQgRE9GJ3MgKERlZ3JlZXMgT2YgRnJlZWRvbSksIDEgQXhpcyB0aGF0IGNhbiBlaXRoZXIgdHdpc3Qgb3Igc3dpbmcgaXMgYSBkZWdyZWUgb2YgZnJlZWRvbS5cclxuICAgICAqIEEgam9pbnQgdHlwaWNhbGx5IGNvbnNpc3RzIG9mIGEgbW90b3IgdGhhdCBsaW1pdHMgbW92ZW1lbnQvcm90YXRpb24gb3IgaXMgYWN0aXZseSB0cnlpbmcgdG8gbW92ZSB0byBhIGxpbWl0LiBBbmQgYSBzcHJpbmcgd2hpY2ggZGVmaW5lcyB0aGUgcmlnaWRpdHkuXHJcbiAgICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSAyMDIwXHJcbiAgICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgSm9pbnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgLyoqIHJlZmVycyBiYWNrIHRvIHRoaXMgY2xhc3MgZnJvbSBhbnkgc3ViY2xhc3MgZS5nLiBpbiBvcmRlciB0byBmaW5kIGNvbXBhdGlibGUgb3RoZXIgcmVzb3VyY2VzKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgYmFzZUNsYXNzOiB0eXBlb2YgSm9pbnQgPSBKb2ludDtcclxuICAgIC8qKiBsaXN0IG9mIGFsbCB0aGUgc3ViY2xhc3NlcyBkZXJpdmVkIGZyb20gdGhpcyBjbGFzcywgaWYgdGhleSByZWdpc3RlcmVkIHByb3Blcmx5Ki9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgc3ViY2xhc3NlczogdHlwZW9mIEpvaW50W10gPSBbXTtcclxuXHJcbiAgICAvLyBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50Sm9pbnQpO1xyXG4gICAgcHJvdGVjdGVkIHNpbmdsZXRvbjogYm9vbGVhbiA9IGZhbHNlOyAvL011bHRpcGxlIGpvaW50cyBjYW4gYmUgYXR0YWNoZWQgdG8gb25lIE5vZGVcclxuXHJcbiAgICAjaWRCb2R5QW5jaG9yOiBudW1iZXIgPSAwO1xyXG4gICAgI2lkQm9keVRpZWQ6IG51bWJlciA9IDA7XHJcbiAgICAjYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5O1xyXG4gICAgI2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHk7XHJcblxyXG4gICAgI2Nvbm5lY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgI2FuY2hvcjogT0lNTy5WZWMzO1xyXG4gICAgI2ludGVybmFsQ29sbGlzaW9uOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgI2JyZWFrRm9yY2U6IG51bWJlciA9IDA7XHJcbiAgICAjYnJlYWtUb3JxdWU6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI25hbWVDaGlsZFRvQ29ubmVjdDogc3RyaW5nO1xyXG5cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBqb2ludDogT0lNTy5Kb2ludDtcclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBjb25maWc6IE9JTU8uSm9pbnRDb25maWc7XHJcblxyXG4gICAgLyoqIENyZWF0ZSBhIGpvaW50IGNvbm5lY3Rpb24gYmV0d2VlbiB0aGUgdHdvIGdpdmVuIFJpZ2lkYm9keUNvbXBvbmVudHMuICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmJvZHlBbmNob3IgPSBfYm9keUFuY2hvcjtcclxuICAgICAgdGhpcy5ib2R5VGllZCA9IF9ib2R5VGllZDtcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAgVGVsbCB0aGUgcGh5c2ljcyB0aGF0IHRoZXJlIGlzIGEgbmV3IGpvaW50IGFuZCBvbiB0aGUgcGh5c2ljcyBzdGFydCB0aGUgYWN0dWFsIGpvaW50IGlzIGZpcnN0IGNyZWF0ZWQuIFZhbHVlcyBjYW4gYmUgc2V0IGJ1dCB0aGVcclxuICAgICAgICBhY3R1YWwgY29uc3RyYWludCBhaW4ndCBleGlzdGVudCB1bnRpbCB0aGUgZ2FtZSBzdGFydHNcclxuICAgICAgKi9cclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIHRoaXMuaG5kRXZlbnQpO1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgdGhpcy5obmRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWdpc3RlclN1YmNsYXNzKF9zdWJjbGFzczogdHlwZW9mIEpvaW50KTogbnVtYmVyIHsgcmV0dXJuIEpvaW50LnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxyXG5cclxuICAgIC8qKiBHZXQvU2V0IHRoZSBmaXJzdCBDb21wb25lbnRSaWdpZGJvZHkgb2YgdGhpcyBjb25uZWN0aW9uLiBJdCBzaG91bGQgYWx3YXlzIGJlIHRoZSBvbmUgdGhhdCB0aGlzIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0b28gaW4gdGhlIHNjZW5lVHJlZS4gKi9cclxuICAgIHB1YmxpYyBnZXQgYm9keUFuY2hvcigpOiBDb21wb25lbnRSaWdpZGJvZHkge1xyXG4gICAgICByZXR1cm4gdGhpcy4jYm9keUFuY2hvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGJvZHlBbmNob3IoX2NtcFJCOiBDb21wb25lbnRSaWdpZGJvZHkpIHtcclxuICAgICAgdGhpcy4jaWRCb2R5QW5jaG9yID0gX2NtcFJCICE9IG51bGwgPyBfY21wUkIuaWQgOiAtMTtcclxuICAgICAgdGhpcy4jYm9keUFuY2hvciA9IF9jbXBSQjtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0L1NldCB0aGUgc2Vjb25kIENvbXBvbmVudFJpZ2lkYm9keSBvZiB0aGlzIGNvbm5lY3Rpb24uICovXHJcbiAgICBwdWJsaWMgZ2V0IGJvZHlUaWVkKCk6IENvbXBvbmVudFJpZ2lkYm9keSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNib2R5VGllZDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgYm9keVRpZWQoX2NtcFJCOiBDb21wb25lbnRSaWdpZGJvZHkpIHtcclxuICAgICAgdGhpcy4jaWRCb2R5VGllZCA9IF9jbXBSQiAhPSBudWxsID8gX2NtcFJCLmlkIDogLTE7XHJcbiAgICAgIHRoaXMuI2JvZHlUaWVkID0gX2NtcFJCO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGV4YWN0IHBvc2l0aW9uIHdoZXJlIHRoZSB0d28ge0BsaW5rIE5vZGV9cyBhcmUgY29ubmVjdGVkLiBXaGVuIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gdGhlIGpvaW50IG5lZWRzIHRvIGJlIHJlY29ubmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGFuY2hvcigpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuI2FuY2hvci54LCB0aGlzLiNhbmNob3IueSwgdGhpcy4jYW5jaG9yLnopO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBhbmNob3IoX3ZhbHVlOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuI2FuY2hvciA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XHJcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYW1vdW50IG9mIGZvcmNlIG5lZWRlZCB0byBicmVhayB0aGUgSk9JTlQsIHdoaWxlIHJvdGF0aW5nLCBpbiBOZXd0b24uIDAgZXF1YWxzIHVuYnJlYWthYmxlIChkZWZhdWx0KSBcclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGJyZWFrVG9ycXVlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNicmVha1RvcnF1ZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgYnJlYWtUb3JxdWUoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jYnJlYWtUb3JxdWUgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuc2V0QnJlYWtUb3JxdWUodGhpcy4jYnJlYWtUb3JxdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFtb3VudCBvZiBmb3JjZSBuZWVkZWQgdG8gYnJlYWsgdGhlIEpPSU5ULCBpbiBOZXd0b24uIDAgZXF1YWxzIHVuYnJlYWthYmxlIChkZWZhdWx0KSBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBicmVha0ZvcmNlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNicmVha0ZvcmNlO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBicmVha0ZvcmNlKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI2JyZWFrRm9yY2UgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuc2V0QnJlYWtGb3JjZSh0aGlzLiNicmVha0ZvcmNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBJZiB0aGUgdHdvIGNvbm5lY3RlZCBSaWdpZEJvZGllcyBjb2xsaWRlIHdpdGggZWF0aCBvdGhlci4gKERlZmF1bHQgPSBmYWxzZSlcclxuICAgICAgKiBPbiBhIHdlbGRpbmcgam9pbnQgdGhlIGNvbm5lY3RlZCBib2RpZXMgc2hvdWxkIG5vdCBiZSBjb2xsaWRpbmcgd2l0aCBlYWNoIG90aGVyLFxyXG4gICAgICAqIGZvciBiZXN0IHJlc3VsdHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBpbnRlcm5hbENvbGxpc2lvbigpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2ludGVybmFsQ29sbGlzaW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBpbnRlcm5hbENvbGxpc2lvbihfdmFsdWU6IGJvb2xlYW4pIHtcclxuICAgICAgdGhpcy4jaW50ZXJuYWxDb2xsaXNpb24gPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuc2V0QWxsb3dDb2xsaXNpb24odGhpcy4jaW50ZXJuYWxDb2xsaXNpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdCBhIGNoaWxkIG5vZGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgam9pbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25uZWN0Q2hpbGQoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNuYW1lQ2hpbGRUb0Nvbm5lY3QgPSBfbmFtZTtcclxuICAgICAgaWYgKCF0aGlzLm5vZGUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGNoaWxkcmVuOiBOb2RlW10gPSB0aGlzLm5vZGUuZ2V0Q2hpbGRyZW5CeU5hbWUoX25hbWUpO1xyXG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09IDEpXHJcbiAgICAgICAgdGhpcy5jb25uZWN0Tm9kZShjaGlsZHJlbi5wb3AoKSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBEZWJ1Zy53YXJuKGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gYXQgJHt0aGlzLm5vZGUubmFtZX0gZmFpbHMgdG8gY29ubmVjdCBjaGlsZCB3aXRoIG5vbiBleGlzdGVudCBvciBhbWJpZ291cyBuYW1lICR7X25hbWV9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0IHRoZSBnaXZlbiBub2RlIHRvIHRoZSBqb2ludC4gVGllaW5nIGl0cyByaWdpZGJvZHkgdG8gdGhlIG5vZGVzIHJpZ2lkYm9keSB0aGlzIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0by5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbm5lY3ROb2RlKF9ub2RlOiBOb2RlKTogdm9pZCB7XHJcbiAgICAgIGlmICghX25vZGUgfHwgIXRoaXMubm9kZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBEZWJ1Zy5mdWRnZShgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGNvbm5lY3RlZCAke3RoaXMubm9kZS5uYW1lfSBhbmQgJHtfbm9kZS5uYW1lfWApO1xyXG5cclxuICAgICAgbGV0IGNvbm5lY3RCb2R5OiBDb21wb25lbnRSaWdpZGJvZHkgPSBfbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50UmlnaWRib2R5KTtcclxuICAgICAgbGV0IHRoaXNCb2R5OiBDb21wb25lbnRSaWdpZGJvZHkgPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudFJpZ2lkYm9keSk7XHJcblxyXG4gICAgICBpZiAoIWNvbm5lY3RCb2R5IHx8ICF0aGlzQm9keSkge1xyXG4gICAgICAgIERlYnVnLndhcm4oYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBhdCAke3RoaXMubm9kZS5uYW1lfSBmYWlscyBkdWUgdG8gbWlzc2luZyByaWdpZGJvZGllcyBvbiAke3RoaXMubm9kZS5uYW1lfSBvciAke19ub2RlLm5hbWV9YCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmJvZHlBbmNob3IgPSB0aGlzQm9keTtcclxuICAgICAgdGhpcy5ib2R5VGllZCA9IGNvbm5lY3RCb2R5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDaGVjayBpZiBjb25uZWN0aW9uIGlzIGRpcnR5LCBzbyB3aGVuIGVpdGhlciByYiBpcyBjaGFuZ2VkIGRpc2Nvbm5lY3QgYW5kIHJlY29ubmVjdC4gSW50ZXJuYWxseSB1c2VkIG5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkLiAqL1xyXG4gICAgcHVibGljIGlzQ29ubmVjdGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY29ubmVjdGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6aW5nIGFuZCBjb25uZWN0aW5nIHRoZSB0d28gcmlnaWRib2RpZXMgd2l0aCB0aGUgY29uZmlndXJlZCBqb2ludCBwcm9wZXJ0aWVzXHJcbiAgICAgKiBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSB0aGUgcGh5c2ljcyBzeXN0ZW0uIE5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29ubmVjdCgpOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuI2Nvbm5lY3RlZCA9PSBmYWxzZSkge1xyXG4gICAgICAgIGlmICh0aGlzLiNpZEJvZHlBbmNob3IgPT0gLTEgfHwgdGhpcy4jaWRCb2R5VGllZCA9PSAtMSkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuI25hbWVDaGlsZFRvQ29ubmVjdClcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0Q2hpbGQodGhpcy4jbmFtZUNoaWxkVG9Db25uZWN0KTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29uc3RydWN0Sm9pbnQoKTtcclxuICAgICAgICB0aGlzLiNjb25uZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWRkSm9pbnQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzY29ubmVjdGluZyB0aGUgdHdvIHJpZ2lkYm9kaWVzIGFuZCByZW1vdmluZyB0aGVtIGZyb20gdGhlIHBoeXNpY3Mgc3lzdGVtLFxyXG4gICAgICogaXMgYXV0b21hdGljYWxseSBjYWxsZWQgYnkgdGhlIHBoeXNpY3Mgc3lzdGVtLiBObyB1c2VyIGludGVyYWN0aW9uIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRpc2Nvbm5lY3QoKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLiNjb25uZWN0ZWQgPT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlSm9pbnQoKTtcclxuICAgICAgICB0aGlzLiNjb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgSm9pbnQgdXNlZCBieSB0aGUgcGh5c2ljcyBlbmdpbmUuIFVzZWQgaW50ZXJuYWxseSBubyB1c2VyIGludGVyYWN0aW9uIG5lZWRlZC5cclxuICAgICAqIE9ubHkgdG8gYmUgdXNlZCB3aGVuIGZ1bmN0aW9uYWxpdHkgdGhhdCBpcyBub3QgYWRkZWQgd2l0aGluIEZVREdFIGlzIG5lZWRlZC5cclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0T2ltb0pvaW50KCk6IE9JTU8uSm9pbnQge1xyXG4gICAgICByZXR1cm4gdGhpcy5qb2ludDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuI2dldE11dGF0b3IoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5hbmNob3IgPSB0aGlzLmFuY2hvci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLmFuY2hvciA9IGF3YWl0IG5ldyBWZWN0b3IzKCkuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYW5jaG9yKTtcclxuICAgICAgdGhpcy4jbXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICB0aGlzLmNvbm5lY3RDaGlsZChfc2VyaWFsaXphdGlvbi5uYW1lQ2hpbGRUb0Nvbm5lY3QpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKHRydWUpO1xyXG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIG11dGF0b3IuYW5jaG9yID0gdGhpcy5hbmNob3IuZ2V0TXV0YXRvcigpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSBzdXBlci5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xyXG4gICAgICB0eXBlcy5uYW1lQ2hpbGRUb0Nvbm5lY3QgPSBcIlN0cmluZ1wiO1xyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9IFxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5hbmNob3IpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMuYW5jaG9yID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmFuY2hvcikpKTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmFuY2hvcjtcclxuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IubmFtZUNoaWxkVG9Db25uZWN0KSAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICB0aGlzLmNvbm5lY3RDaGlsZChfbXV0YXRvci5uYW1lQ2hpbGRUb0Nvbm5lY3QpO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmRlbGV0ZUZyb21NdXRhdG9yKF9tdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IsIF9zZWxlY3Rpb24sIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iuc3ByaW5nRGFtcGVyO1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iuam9pbnQ7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5tb3RvcjtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRlbGwgdGhlIEZ1ZGdlUGh5c2ljcyBzeXN0ZW0gdGhhdCB0aGlzIGpvaW50IG5lZWRzIHRvIGJlIGhhbmRsZWQgaW4gdGhlIG5leHQgZnJhbWUuICovXHJcbiAgICBwcm90ZWN0ZWQgZGlydHlTdGF0dXMoKTogdm9pZCB7XHJcbiAgICAgIFBoeXNpY3MuY2hhbmdlSm9pbnRTdGF0dXModGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFkZEpvaW50KCk6IHZvaWQge1xyXG4gICAgICBQaHlzaWNzLmFkZEpvaW50KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZW1vdmVKb2ludCgpOiB2b2lkIHtcclxuICAgICAgUGh5c2ljcy5yZW1vdmVKb2ludCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0Sm9pbnQoLi4uX2NvbmZpZ1BhcmFtczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgbGV0IHBvc0JvZHlBbmNob3I6IFZlY3RvcjMgPSB0aGlzLmJvZHlBbmNob3Iubm9kZS5tdHhXb3JsZC50cmFuc2xhdGlvbjsgLy9TZXR0aW5nIHRoZSBhbmNob3IgcG9zaXRpb24gbG9jYWxseSBmcm9tIHRoZSBmaXJzdCByaWdpZGJvZHlcclxuICAgICAgbGV0IHdvcmxkQW5jaG9yOiBPSU1PLlZlYzMgPSBuZXcgT0lNTy5WZWMzKHBvc0JvZHlBbmNob3IueCArIHRoaXMuI2FuY2hvci54LCBwb3NCb2R5QW5jaG9yLnkgKyB0aGlzLiNhbmNob3IueSwgcG9zQm9keUFuY2hvci56ICsgdGhpcy4jYW5jaG9yLnopO1xyXG5cclxuICAgICAgLy8gQHRzLWlnbm9yZSAgICAvLyB1bmZvcnR1bmF0ZWx5LCBtZXRob2QgaW5pdCBpcyBub3QgYSBtZW1iZXIgb2YgdGhlIGJhc2UgY2xhc3MgT0lNTy5Kb2ludENvbmZpZ1xyXG4gICAgICB0aGlzLmNvbmZpZy5pbml0KHRoaXMuI2JvZHlBbmNob3IuZ2V0T2ltb1JpZ2lkYm9keSgpLCB0aGlzLiNib2R5VGllZC5nZXRPaW1vUmlnaWRib2R5KCksIHdvcmxkQW5jaG9yLCAuLi5fY29uZmlnUGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY29uZmlndXJlSm9pbnQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuam9pbnQuc2V0QnJlYWtGb3JjZSh0aGlzLmJyZWFrRm9yY2UpO1xyXG4gICAgICB0aGlzLmpvaW50LnNldEJyZWFrVG9ycXVlKHRoaXMuYnJlYWtUb3JxdWUpO1xyXG4gICAgICB0aGlzLmpvaW50LnNldEFsbG93Q29sbGlzaW9uKHRoaXMuI2ludGVybmFsQ29sbGlzaW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgZGVsZXRlRnJvbU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IsIF9kZWxldGU6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQga2V5IGluIF9kZWxldGUpXHJcbiAgICAgICAgZGVsZXRlIF9tdXRhdG9yW2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBobmRFdmVudCA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIHN3aXRjaCAoX2V2ZW50LnR5cGUpIHtcclxuICAgICAgICBjYXNlIEVWRU5ULkNPTVBPTkVOVF9BREQ6XHJcbiAgICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5ESVNDT05ORUNUX0pPSU5ULCAoKSA9PiB7IHRoaXMuZGlzY29ubmVjdCgpOyB0aGlzLmRpcnR5U3RhdHVzKCk7IH0sIHRydWUpO1xyXG4gICAgICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFVkVOVC5DT01QT05FTlRfUkVNT1ZFOlxyXG4gICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuRElTQ09OTkVDVF9KT0lOVCwgKCkgPT4geyB0aGlzLmRpc2Nvbm5lY3QoKTsgdGhpcy5kaXJ0eVN0YXR1cygpOyB9LCB0cnVlKTtcclxuICAgICAgICAgIHRoaXMucmVtb3ZlSm9pbnQoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgICNnZXRNdXRhdG9yID0gKCk6IE11dGF0b3IgPT4ge1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICBuYW1lQ2hpbGRUb0Nvbm5lY3Q6IHRoaXMuI25hbWVDaGlsZFRvQ29ubmVjdCxcclxuICAgICAgICBpbnRlcm5hbENvbGxpc2lvbjogdGhpcy4jaW50ZXJuYWxDb2xsaXNpb24sXHJcbiAgICAgICAgYnJlYWtGb3JjZTogdGhpcy4jYnJlYWtGb3JjZSxcclxuICAgICAgICBicmVha1RvcnF1ZTogdGhpcy4jYnJlYWtUb3JxdWVcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9O1xyXG5cclxuICAgICNtdXRhdGUgPSAoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkID0+IHtcclxuICAgICAgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBbXCJpbnRlcm5hbENvbGxpc2lvblwiLCBcImJyZWFrRm9yY2VcIiwgXCJicmVha1RvcnF1ZVwiXSk7XHJcbiAgICB9O1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAgICogQmFzZSBjbGFzcyBmb3Igam9pbnRzIG9wZXJhdGluZyB3aXRoIGV4YWN0bHkgb25lIGF4aXNcclxuICAgICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgSm9pbnRBeGlhbCBleHRlbmRzIEpvaW50IHtcclxuICAgIHByb3RlY3RlZCBzcHJpbmdEYW1wZXI6IE9JTU8uU3ByaW5nRGFtcGVyO1xyXG4gICAgXHJcbiAgICAvL0ludGVybmFsIFZhcmlhYmxlc1xyXG4gICAgI21heE1vdG9yOiBudW1iZXIgPSAxMDtcclxuICAgICNtaW5Nb3RvcjogbnVtYmVyID0gLTEwO1xyXG4gICAgI21vdG9yU3BlZWQ6IG51bWJlciA9IDA7XHJcbiAgICAjYXhpczogT0lNTy5WZWMzO1xyXG4gICAgI3NwcmluZ0ZyZXF1ZW5jeTogbnVtYmVyID0gMDtcclxuICAgICNzcHJpbmdEYW1waW5nOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIC8qKiBDcmVhdGluZyBhIGN5bGluZHJpY2FsIGpvaW50IGJldHdlZW4gdHdvIENvbXBvbmVudFJpZ2lkYm9kaWVzIG1vdmluZyBvbiBvbmUgYXhpcyBhbmQgcm90YXRpbmcgYXJvdW5kIGFub3RoZXIgYm91bmQgb24gYSBsb2NhbCBhbmNob3Jwb2ludC4gKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYXhpczogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDEsIDApLCBfbG9jYWxBbmNob3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAwKSkge1xyXG4gICAgICBzdXBlcihfYm9keUFuY2hvciwgX2JvZHlUaWVkKTtcclxuICAgICAgdGhpcy5heGlzID0gX2F4aXM7XHJcbiAgICAgIHRoaXMuYW5jaG9yID0gX2xvY2FsQW5jaG9yO1xyXG4gICAgICB0aGlzLm1pbk1vdG9yID0gLTEwO1xyXG4gICAgICB0aGlzLm1heE1vdG9yID0gMTA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIEdldC9TZXQgdHJhbnNmb3Igb2YgZnVkZ2UgcHJvcGVydGllcyB0byB0aGUgcGh5c2ljcyBlbmdpbmVcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGF4aXMgY29ubmVjdGluZyB0aGUgdGhlIHR3byB7QGxpbmsgTm9kZX1zIGUuZy4gVmVjdG9yMygwLDEsMCkgdG8gaGF2ZSBhIHVwd2FyZCBjb25uZWN0aW9uLlxyXG4gICAgICogIFdoZW4gY2hhbmdlZCBhZnRlciBpbml0aWFsaXphdGlvbiB0aGUgam9pbnQgbmVlZHMgdG8gYmUgcmVjb25uZWN0ZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgYXhpcygpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuI2F4aXMueCwgdGhpcy4jYXhpcy55LCB0aGlzLiNheGlzLnopO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBheGlzKF92YWx1ZTogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLiNheGlzID0gbmV3IE9JTU8uVmVjMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KTtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgVXBwZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWF4TW90b3IoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21heE1vdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgbWF4TW90b3IoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWF4TW90b3IgPSBfdmFsdWU7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgKDxPSU1PLlByaXNtYXRpY0pvaW50Pjx1bmtub3duPnRoaXMuam9pbnQpLmdldExpbWl0TW90b3IoKS51cHBlckxpbWl0ID0gX3ZhbHVlO1xyXG4gICAgICB9IGNhdGNoIChfZTogdW5rbm93bikgeyAvKiAqLyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIExvd2VyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWluTW90b3IoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21pbk1vdG9yO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBtaW5Nb3RvcihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtaW5Nb3RvciA9IF92YWx1ZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAoPE9JTU8uUHJpc21hdGljSm9pbnQ+PHVua25vd24+dGhpcy5qb2ludCkuZ2V0TGltaXRNb3RvcigpLmxvd2VyTGltaXQgPSBfdmFsdWU7XHJcbiAgICAgIH0gY2F0Y2ggKF9lOiB1bmtub3duKSB7IC8qICovIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkYW1waW5nIG9mIHRoZSBzcHJpbmcuIDEgZXF1YWxzIGNvbXBsZXRseSBkYW1wZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc3ByaW5nRGFtcGluZygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRGFtcGluZztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRGFtcGluZyhfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdEYW1waW5nID0gX3ZhbHVlO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgICg8T0lNTy5QcmlzbWF0aWNKb2ludD48dW5rbm93bj50aGlzLmpvaW50KS5nZXRTcHJpbmdEYW1wZXIoKS5kYW1waW5nUmF0aW8gPSBfdmFsdWU7XHJcbiAgICAgIH0gY2F0Y2ggKF9lOiB1bmtub3duKSB7IC8qICovIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgdGFyZ2V0IHNwZWVkIG9mIHRoZSBtb3RvciBpbiBtL3MuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbW90b3JTcGVlZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbW90b3JTcGVlZDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IG1vdG9yU3BlZWQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbW90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAoPE9JTU8uUHJpc21hdGljSm9pbnQ+dGhpcy5qb2ludCkuZ2V0TGltaXRNb3RvcigpLm1vdG9yU3BlZWQgPSBfdmFsdWU7XHJcbiAgICAgIH0gY2F0Y2ggKF9lOiB1bmtub3duKSB7IC8qICovIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNwcmluZyBpbiBIei4gQXQgMCB0aGUgc3ByaW5nIGlzIHJpZ2lkLCBlcXVhbHMgbm8gc3ByaW5nLiBUaGUgc21hbGxlciB0aGUgdmFsdWUgdGhlIGxlc3MgcmVzdHJpY3RpdmUgaXMgdGhlIHNwcmluZy5cclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0ZyZXF1ZW5jeSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzcHJpbmdGcmVxdWVuY3koX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRnJlcXVlbmN5ID0gX3ZhbHVlO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgICg8T0lNTy5QcmlzbWF0aWNKb2ludD50aGlzLmpvaW50KS5nZXRTcHJpbmdEYW1wZXIoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICAgIH0gY2F0Y2ggKF9lOiB1bmtub3duKSB7IC8qICovIH1cclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB0aGlzLiNnZXRNdXRhdG9yKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uYXhpcyA9IHRoaXMuYXhpcy5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLmF4aXMgPSBhd2FpdCBuZXcgVmVjdG9yMygpLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmF4aXMpO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5heGlzKSAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICB0aGlzLmF4aXMgPSBuZXcgVmVjdG9yMyguLi48bnVtYmVyW10+KE9iamVjdC52YWx1ZXMoX211dGF0b3IuYXhpcykpKTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmF4aXM7XHJcbiAgICAgIHRoaXMuI211dGF0ZShfbXV0YXRvcik7XHJcbiAgICAgIHRoaXMuZGVsZXRlRnJvbU11dGF0b3IoX211dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIG11dGF0b3IuYXhpcyA9IHRoaXMuYXhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24obXV0YXRvciwgdGhpcy4jZ2V0TXV0YXRvcigpKTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgICBcclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zcHJpbmdEYW1wZXIgPSBuZXcgT0lNTy5TcHJpbmdEYW1wZXIoKS5zZXRTcHJpbmcodGhpcy4jc3ByaW5nRnJlcXVlbmN5LCB0aGlzLiNzcHJpbmdEYW1waW5nKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQodGhpcy4jYXhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgI2dldE11dGF0b3IgPSAoKTogTXV0YXRvciA9PiB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHNwcmluZ0RhbXBpbmc6IHRoaXMuI3NwcmluZ0RhbXBpbmcsXHJcbiAgICAgICAgc3ByaW5nRnJlcXVlbmN5OiB0aGlzLiNzcHJpbmdGcmVxdWVuY3ksXHJcbiAgICAgICAgbWF4TW90b3I6IHRoaXMuI21heE1vdG9yLFxyXG4gICAgICAgIG1pbk1vdG9yOiB0aGlzLiNtaW5Nb3RvcixcclxuICAgICAgICBtb3RvclNwZWVkOiB0aGlzLiNtb3RvclNwZWVkXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfTtcclxuXHJcbiAgICAjbXV0YXRlID0gKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCA9PiB7XHJcbiAgICAgIHRoaXMubXV0YXRlQmFzZShfbXV0YXRvciwgW1wic3ByaW5nRGFtcGluZ1wiLCBcInNwcmluZ0ZyZXF1ZW5jeVwiLCBcIm1heE1vdG9yXCIsIFwibWluTW90b3JcIiwgXCJtb3RvclNwZWVkXCJdKTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGVudW0gTU9ERSB7XHJcbiAgICBFRElUT1IsIFJVTlRJTUVcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIFJFU09VUkNFX1NUQVRVUyB7XHJcbiAgICBQRU5ESU5HLCBSRUFEWSwgRVJST1JcclxuICB9XHJcblxyXG4gIC8qKiBBIHNlcmlhbGl6YWJsZSByZXNvdXJjZSBpbXBsZW1lbnRpbmcgYW4gaWQgYW5kIGEgbmFtZSBzbyBpdCBjYW4gYmUgbWFuYWdlZCBieSB0aGUge0BsaW5rIFByb2plY3R9ICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNlcmlhbGl6YWJsZVJlc291cmNlIGV4dGVuZHMgSW1wbGVtZW50YWJsZSB7fSAvLyBhbGxvdyBjaGVjayB3aXRoIGluc3RhbmNlb2YgXHJcbiAgZXhwb3J0IGludGVyZmFjZSBTZXJpYWxpemFibGVSZXNvdXJjZSBleHRlbmRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICBpZFJlc291cmNlOiBzdHJpbmc7XHJcbiAgICByZWFkb25seSB0eXBlOiBzdHJpbmc7XHJcbiAgfVxyXG5cclxuICAvKiogQSBzZXJpYWxpemFibGUgcmVzb3VyY2UgdGhhdCBpcyBsb2FkZWQgZnJvbSBhbiBleHRlcm5hbCBzb3VyY2UgKGUuZy4gZnJvbSBhIGdsVEYtZmlsZSkgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWwgZXh0ZW5kcyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICB1cmw6IFJlcXVlc3RJbmZvO1xyXG4gICAgc3RhdHVzOiBSRVNPVVJDRV9TVEFUVVM7XHJcbiAgICBsb2FkKCk6IFByb21pc2U8U2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbD47XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFJlc291cmNlcyB7XHJcbiAgICBbaWRSZXNvdXJjZTogc3RyaW5nXTogU2VyaWFsaXphYmxlUmVzb3VyY2U7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyB7XHJcbiAgICBbaWRSZXNvdXJjZTogc3RyaW5nXTogU2VyaWFsaXphdGlvbjtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2NyaXB0TmFtZXNwYWNlcyB7XHJcbiAgICBbbmFtZTogc3RyaW5nXTogT2JqZWN0O1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBDb21wb25lbnRTY3JpcHRzIHtcclxuICAgIFtuYW1lc3BhY2U6IHN0cmluZ106IENvbXBvbmVudFNjcmlwdFtdO1xyXG4gIH1cclxuXHJcbiAgaW50ZXJmYWNlIEdyYXBoSW5zdGFuY2VzVG9SZXN5bmMge1xyXG4gICAgW2lkUmVzb3VyY2U6IHN0cmluZ106IEdyYXBoSW5zdGFuY2VbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXRpYyBjbGFzcyBoYW5kbGluZyB0aGUgcmVzb3VyY2VzIHVzZWQgd2l0aCB0aGUgY3VycmVudCBGVURHRS1pbnN0YW5jZS4gIFxyXG4gICAqIEtlZXBzIGEgbGlzdCBvZiB0aGUgcmVzb3VyY2VzIGFuZCBnZW5lcmF0ZXMgaWRzIHRvIHJldHJpZXZlIHRoZW0uICBcclxuICAgKiBSZXNvdXJjZXMgYXJlIG9iamVjdHMgcmVmZXJlbmNlZCBtdWx0aXBsZSB0aW1lcyBidXQgc3VwcG9zZWQgdG8gYmUgc3RvcmVkIG9ubHkgb25jZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQcm9qZWN0IGV4dGVuZHMgRXZlbnRUYXJnZXRTdGF0aWMge1xyXG4gICAgcHVibGljIHN0YXRpYyByZXNvdXJjZXM6IFJlc291cmNlcyA9IHt9O1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uT2ZSZXNvdXJjZXMgPSB7fTtcclxuICAgIHB1YmxpYyBzdGF0aWMgc2NyaXB0TmFtZXNwYWNlczogU2NyaXB0TmFtZXNwYWNlcyA9IHt9O1xyXG4gICAgcHVibGljIHN0YXRpYyBiYXNlVVJMOiBVUkwgPSBuZXcgVVJMKGxvY2F0aW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgcHVibGljIHN0YXRpYyBtb2RlOiBNT0RFID0gTU9ERS5SVU5USU1FO1xyXG4gICAgcHVibGljIHN0YXRpYyBncmFwaEluc3RhbmNlc1RvUmVzeW5jOiBHcmFwaEluc3RhbmNlc1RvUmVzeW5jID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgdGhlIHJlc291cmNlIGFuZCBnZW5lcmF0ZXMgYW4gaWQgZm9yIGl0IGJ5IGRlZmF1bHQuICBcclxuICAgICAqIElmIHRoZSByZXNvdXJjZSBhbHJlYWR5IGhhcyBhbiBpZCwgdGh1cyBoYXZpbmcgYmVlbiByZWdpc3RlcmVkLCBpdHMgZGVsZXRlZCBmcm9tIHRoZSBsaXN0IGFuZCByZWdpc3RlcmVkIGFuZXcuXHJcbiAgICAgKiBJdCdzIHBvc3NpYmxlIHRvIHBhc3MgYW4gaWQsIGJ1dCBzaG91bGQgbm90IGJlIGRvbmUgZXhjZXB0IGJ5IHRoZSBTZXJpYWxpemVyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlZ2lzdGVyKF9yZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UsIF9pZFJlc291cmNlPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIGlmIChfcmVzb3VyY2UuaWRSZXNvdXJjZSAmJiBfcmVzb3VyY2UuaWRSZXNvdXJjZSA9PSBfaWRSZXNvdXJjZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBpZiAoX3Jlc291cmNlLmlkUmVzb3VyY2UpIC8vIGRlcmVnaXN0ZXIgdGhlIG9sZCBpZFxyXG4gICAgICAgIHRoaXMuZGVyZWdpc3RlcihfcmVzb3VyY2UpO1xyXG5cclxuICAgICAgaWYgKF9pZFJlc291cmNlKSB7XHJcbiAgICAgICAgX3Jlc291cmNlLmlkUmVzb3VyY2UgPSBfaWRSZXNvdXJjZTtcclxuICAgICAgICB0aGlzLmRlcmVnaXN0ZXIoX3Jlc291cmNlKTsgLy8gZGVyZWdpc3RlciB0aGUgbmV3IGlkXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghX3Jlc291cmNlLmlkUmVzb3VyY2UpXHJcbiAgICAgICAgX3Jlc291cmNlLmlkUmVzb3VyY2UgPSBQcm9qZWN0LmdlbmVyYXRlSWQoX3Jlc291cmNlKTtcclxuXHJcbiAgICAgIFByb2plY3QucmVzb3VyY2VzW19yZXNvdXJjZS5pZFJlc291cmNlXSA9IF9yZXNvdXJjZTtcclxuXHJcbiAgICAgIGlmIChfcmVzb3VyY2UgaW5zdGFuY2VvZiBHcmFwaClcclxuICAgICAgICBfcmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5HUkFQSF9NVVRBVEVELCAoX2V2ZW50OiBFdmVudCkgPT4gdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChFVkVOVC5HUkFQSF9NVVRBVEVELCB7IGRldGFpbDogX3Jlc291cmNlIH0pKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSByZXNvdXJjZSBmcm9tIHRoZSBsaXN0IG9mIHJlc291cmNlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkZXJlZ2lzdGVyKF9yZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIChQcm9qZWN0LnJlc291cmNlc1tfcmVzb3VyY2UuaWRSZXNvdXJjZV0pO1xyXG4gICAgICBkZWxldGUgKFByb2plY3Quc2VyaWFsaXphdGlvbltfcmVzb3VyY2UuaWRSZXNvdXJjZV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBsaXN0IG9mIHJlc291cmNlcyBhbmQgdGhlaXIgc2VyaWFsaXphdGlvbiwgdGh1cyByZW1vdmluZyBhbGwgcmVzb3VyY2VzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICBQcm9qZWN0LnJlc291cmNlcyA9IHt9O1xyXG4gICAgICBQcm9qZWN0LnNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgUHJvamVjdC5jbGVhclNjcmlwdE5hbWVzcGFjZXMoKTtcclxuICAgICAgLy8gUHJvamVjdC5zY3JpcHROYW1lc3BhY2VzID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPFQgZXh0ZW5kcyBDb21wb25lbnQ+KF9jbGFzczogbmV3ICgpID0+IFQpOiBUW10ge1xyXG4gICAgLy8gICByZXR1cm4gPFRbXT4odGhpcy5jb21wb25lbnRzW19jbGFzcy5uYW1lXSB8fCBbXSkuc2xpY2UoMCk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCByZXNvdXJjZXMgb2YgdGhlIHJlcXVlc3RlZCB0eXBlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFJlc291cmNlc0J5VHlwZTxUPihfdHlwZTogbmV3IChfYXJnczogR2VuZXJhbCkgPT4gVCk6IFNlcmlhbGl6YWJsZVJlc291cmNlW10ge1xyXG4gICAgICBsZXQgZm91bmQ6IFNlcmlhbGl6YWJsZVJlc291cmNlW10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgcmVzb3VyY2VJZCBpbiBQcm9qZWN0LnJlc291cmNlcykge1xyXG4gICAgICAgIGxldCByZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UgPSBQcm9qZWN0LnJlc291cmNlc1tyZXNvdXJjZUlkXTtcclxuICAgICAgICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBfdHlwZSlcclxuICAgICAgICAgIGZvdW5kLnB1c2gocmVzb3VyY2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3VuZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHJlc291cmNlcyB3aXRoIHRoZSByZXF1ZXN0ZWQgbmFtZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRSZXNvdXJjZXNCeU5hbWUoX25hbWU6IHN0cmluZyk6IFNlcmlhbGl6YWJsZVJlc291cmNlW10ge1xyXG4gICAgICBsZXQgZm91bmQ6IFNlcmlhbGl6YWJsZVJlc291cmNlW10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgcmVzb3VyY2VJZCBpbiBQcm9qZWN0LnJlc291cmNlcykge1xyXG4gICAgICAgIGxldCByZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UgPSBQcm9qZWN0LnJlc291cmNlc1tyZXNvdXJjZUlkXTtcclxuICAgICAgICBpZiAocmVzb3VyY2UubmFtZSA9PSBfbmFtZSlcclxuICAgICAgICAgIGZvdW5kLnB1c2gocmVzb3VyY2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3VuZDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSBhIHVzZXIgcmVhZGFibGUgYW5kIHVuaXF1ZSBpZCB1c2luZyB0aGUgdHlwZSBvZiB0aGUgcmVzb3VyY2UsIHRoZSBkYXRlIGFuZCByYW5kb20gbnVtYmVyc1xyXG4gICAgICogQHBhcmFtIF9yZXNvdXJjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdlbmVyYXRlSWQoX3Jlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSk6IHN0cmluZyB7XHJcbiAgICAgIC8vIFRPRE86IGJ1aWxkIGlkIGFuZCBpbnRlZ3JhdGUgaW5mbyBmcm9tIHJlc291cmNlLCBub3QganVzdCBkYXRlXHJcbiAgICAgIGxldCBpZFJlc291cmNlOiBzdHJpbmc7XHJcbiAgICAgIGRvXHJcbiAgICAgICAgaWRSZXNvdXJjZSA9IF9yZXNvdXJjZS5jb25zdHJ1Y3Rvci5uYW1lICsgXCJ8XCIgKyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyBcInxcIiArIE1hdGgucmFuZG9tKCkudG9QcmVjaXNpb24oNSkuc3Vic3RyKDIsIDUpO1xyXG4gICAgICB3aGlsZSAoUHJvamVjdC5yZXNvdXJjZXNbaWRSZXNvdXJjZV0pO1xyXG4gICAgICByZXR1cm4gaWRSZXNvdXJjZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzLCBpZiBhbiBvYmplY3QgaXMgYSB7QGxpbmsgU2VyaWFsaXphYmxlUmVzb3VyY2V9XHJcbiAgICAgKiBAcGFyYW0gX29iamVjdCBUaGUgb2JqZWN0IHRvIGV4YW1pbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpc1Jlc291cmNlKF9vYmplY3Q6IFNlcmlhbGl6YWJsZSk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gKFJlZmxlY3QuaGFzKF9vYmplY3QsIFwiaWRSZXNvdXJjZVwiKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHJlc291cmNlIHN0b3JlZCB3aXRoIHRoZSBnaXZlbiBpZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGdldFJlc291cmNlKF9pZFJlc291cmNlOiBzdHJpbmcpOiBQcm9taXNlPFNlcmlhbGl6YWJsZVJlc291cmNlPiB7XHJcbiAgICAgIGxldCByZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UgPSBQcm9qZWN0LnJlc291cmNlc1tfaWRSZXNvdXJjZV07XHJcbiAgICAgIGlmICghcmVzb3VyY2UpIHtcclxuICAgICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IFByb2plY3Quc2VyaWFsaXphdGlvbltfaWRSZXNvdXJjZV07XHJcbiAgICAgICAgaWYgKCFzZXJpYWxpemF0aW9uKSB7XHJcbiAgICAgICAgICBEZWJ1Zy5lcnJvcihcIlJlc291cmNlIG5vdCBmb3VuZFwiLCBfaWRSZXNvdXJjZSk7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzb3VyY2UgPSBhd2FpdCBQcm9qZWN0LmRlc2VyaWFsaXplUmVzb3VyY2Uoc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgY2xvbmVSZXNvdXJjZShfcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlKTogUHJvbWlzZTxTZXJpYWxpemFibGVSZXNvdXJjZT4ge1xyXG4gICAgICBpZiAoIV9yZXNvdXJjZSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gU2VyaWFsaXplci5zZXJpYWxpemUoX3Jlc291cmNlKTtcclxuICAgICAgbGV0IHR5cGU6IHN0cmluZyA9IDxzdHJpbmc+UmVmbGVjdC5vd25LZXlzKHNlcmlhbGl6YXRpb24pWzBdO1xyXG4gICAgICBkZWxldGUgKHNlcmlhbGl6YXRpb25bdHlwZV0uaWRSZXNvdXJjZSk7XHJcbiAgICAgIGxldCBjbG9uZTogdHlwZW9mIF9yZXNvdXJjZSA9IGF3YWl0IFByb2plY3QuZGVzZXJpYWxpemVSZXNvdXJjZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgUHJvamVjdC5yZWdpc3RlcihjbG9uZSk7XHJcbiAgICAgIGNsb25lLm5hbWUgKz0gXCJfY2xvbmVcIjtcclxuICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmVnaXN0ZXJzIGEgcmVzb3VyY2UgZnJvbSBhIHtAbGluayBOb2RlfSwgY29weWluZyB0aGUgY29tcGxldGUgZ3JhcGggc3RhcnRpbmcgd2l0aCBpdFxyXG4gICAgICogQHBhcmFtIF9ub2RlIEEgbm9kZSB0byBjcmVhdGUgdGhlIHJlc291cmNlIGZyb21cclxuICAgICAqIEBwYXJhbSBfcmVwbGFjZVdpdGhJbnN0YW5jZSBpZiB0cnVlIChkZWZhdWx0KSwgdGhlIG5vZGUgdXNlZCBhcyBvcmlnaW4gaXMgcmVwbGFjZWQgYnkgYSB7QGxpbmsgR3JhcGhJbnN0YW5jZX0gb2YgdGhlIHtAbGluayBHcmFwaH0gY3JlYXRlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIHJlZ2lzdGVyQXNHcmFwaChfbm9kZTogTm9kZSwgX3JlcGxhY2VXaXRoSW5zdGFuY2U6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTxHcmFwaD4ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IF9ub2RlLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBsZXQgZ3JhcGg6IEdyYXBoID0gbmV3IEdyYXBoKF9ub2RlLm5hbWUpO1xyXG4gICAgICBhd2FpdCBncmFwaC5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgUHJvamVjdC5yZWdpc3RlcihncmFwaCk7XHJcblxyXG4gICAgICBpZiAoX3JlcGxhY2VXaXRoSW5zdGFuY2UgJiYgX25vZGUuZ2V0UGFyZW50KCkpIHtcclxuICAgICAgICBsZXQgaW5zdGFuY2U6IEdyYXBoSW5zdGFuY2UgPSBhd2FpdCBQcm9qZWN0LmNyZWF0ZUdyYXBoSW5zdGFuY2UoZ3JhcGgpO1xyXG4gICAgICAgIF9ub2RlLmdldFBhcmVudCgpLnJlcGxhY2VDaGlsZChfbm9kZSwgaW5zdGFuY2UpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZ3JhcGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEge0BsaW5rIEdyYXBoSW5zdGFuY2V9IG9mIHRoZSBnaXZlbiB7QGxpbmsgR3JhcGh9IFxyXG4gICAgICogYW5kIGNvbm5lY3RzIGl0IHRvIHRoZSBncmFwaCBmb3Igc3luY2hyb25pc2F0aW9uIG9mIG11dGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGNyZWF0ZUdyYXBoSW5zdGFuY2UoX2dyYXBoOiBHcmFwaCk6IFByb21pc2U8R3JhcGhJbnN0YW5jZT4ge1xyXG4gICAgICBsZXQgaW5zdGFuY2U6IEdyYXBoSW5zdGFuY2UgPSBuZXcgR3JhcGhJbnN0YW5jZShfZ3JhcGgpOyAvLyBUT0RPOiBjbGVhbnVwIHNpbmNlIGNyZWF0aW9uIG1vdmVkIGhlcmVcclxuICAgICAgYXdhaXQgaW5zdGFuY2UuY29ubmVjdFRvR3JhcGgoKTtcclxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIHtAbGluayBHcmFwaEluc3RhbmNlfSB0byBiZSByZXN5bmNlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlZ2lzdGVyR3JhcGhJbnN0YW5jZUZvclJlc3luYyhfaW5zdGFuY2U6IEdyYXBoSW5zdGFuY2UpOiB2b2lkIHtcclxuICAgICAgbGV0IGluc3RhbmNlczogR3JhcGhJbnN0YW5jZVtdID0gUHJvamVjdC5ncmFwaEluc3RhbmNlc1RvUmVzeW5jW19pbnN0YW5jZS5pZFNvdXJjZV0gfHwgW107XHJcbiAgICAgIGluc3RhbmNlcy5wdXNoKF9pbnN0YW5jZSk7XHJcbiAgICAgIFByb2plY3QuZ3JhcGhJbnN0YW5jZXNUb1Jlc3luY1tfaW5zdGFuY2UuaWRTb3VyY2VdID0gaW5zdGFuY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzeW5jIGFsbCB7QGxpbmsgR3JhcGhJbnN0YW5jZX0gcmVnaXN0ZXJlZCB0byB0aGUgZ2l2ZW4ge0BsaW5rIEdyYXBofVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIHJlc3luY0dyYXBoSW5zdGFuY2VzKF9ncmFwaDogR3JhcGgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgbGV0IGluc3RhbmNlczogR3JhcGhJbnN0YW5jZVtdID0gUHJvamVjdC5ncmFwaEluc3RhbmNlc1RvUmVzeW5jW19ncmFwaC5pZFJlc291cmNlXTtcclxuICAgICAgaWYgKCFpbnN0YW5jZXMpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBmb3IgKGxldCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpXHJcbiAgICAgICAgYXdhaXQgaW5zdGFuY2UuY29ubmVjdFRvR3JhcGgoKTtcclxuICAgICAgZGVsZXRlIChQcm9qZWN0LmdyYXBoSW5zdGFuY2VzVG9SZXN5bmNbX2dyYXBoLmlkUmVzb3VyY2VdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBuYW1lc3BhY2UgdG8gdGhlIGxpc3Qgb2Ygc2NyaXB0LW5hbWVzcGFjZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXJTY3JpcHROYW1lc3BhY2UoX25hbWVzcGFjZTogT2JqZWN0KTogdm9pZCB7XHJcbiAgICAgIGxldCBuYW1lOiBzdHJpbmcgPSBTZXJpYWxpemVyLnJlZ2lzdGVyTmFtZXNwYWNlKF9uYW1lc3BhY2UpO1xyXG4gICAgICBpZiAoIVByb2plY3Quc2NyaXB0TmFtZXNwYWNlc1tuYW1lXSlcclxuICAgICAgICBQcm9qZWN0LnNjcmlwdE5hbWVzcGFjZXNbbmFtZV0gPSBfbmFtZXNwYWNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgdGhlIGxpc3Qgb2Ygc2NyaXB0LW5hbWVzcGFjZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYXJTY3JpcHROYW1lc3BhY2VzKCk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlcykge1xyXG4gICAgICAgIFJlZmxlY3Quc2V0KHdpbmRvdywgbmFtZSwgdW5kZWZpbmVkKTtcclxuICAgICAgICBQcm9qZWN0LnNjcmlwdE5hbWVzcGFjZXNbbmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZGVsZXRlIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlc1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdHMgYWxsIHtAbGluayBDb21wb25lbnRTY3JpcHR9cyByZWdpc3RlcmVkIGluIHtAbGluayBQcm9qZWN0LnNjcmlwdE5hbWVzcGFjZXN9IGFuZCByZXR1cm5zIHRoZW0uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29tcG9uZW50U2NyaXB0cygpOiBDb21wb25lbnRTY3JpcHRzIHtcclxuICAgICAgbGV0IGNvbXBvbWVudHM6IENvbXBvbmVudFNjcmlwdHMgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbmFtZXNwYWNlIGluIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlcykge1xyXG4gICAgICAgIGNvbXBvbWVudHNbbmFtZXNwYWNlXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gUHJvamVjdC5zY3JpcHROYW1lc3BhY2VzW25hbWVzcGFjZV0pIHtcclxuICAgICAgICAgIGxldCBzY3JpcHQ6IENvbXBvbmVudFNjcmlwdCA9IFJlZmxlY3QuZ2V0KFByb2plY3Quc2NyaXB0TmFtZXNwYWNlc1tuYW1lc3BhY2VdLCBuYW1lKTtcclxuICAgICAgICAgIC8vIFVzaW5nIE9iamVjdC5jcmVhdGUgZG9lc24ndCBjYWxsIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGluc3RhbmNlb2YgY2FuIGJlIHVzZWQuIE1vcmUgZWxlZ2FudCB0aGFuIHRoZSBsb29wIGFib3ZlLCB0aG91Z2ggbWF5YmUgbm90IGFzIHBlcmZvcm1hbnQuIFxyXG5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBvOiBHZW5lcmFsID0gT2JqZWN0LmNyZWF0ZShzY3JpcHQpO1xyXG4gICAgICAgICAgICBpZiAoby5wcm90b3R5cGUgaW5zdGFuY2VvZiBDb21wb25lbnRTY3JpcHQpXHJcbiAgICAgICAgICAgICAgY29tcG9tZW50c1tuYW1lc3BhY2VdLnB1c2goc2NyaXB0KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKF9lKSB7IC8qICovIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvbXBvbWVudHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIHNjcmlwdCBmcm9tIHRoZSBnaXZlbiBVUkwgYW5kIGludGVncmF0ZXMgaXQgaW50byBhIHtAbGluayBIVE1MU2NyaXB0RWxlbWVudH0gaW4gdGhlIHtAbGluayBkb2N1bWVudC5oZWFkfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWRTY3JpcHQoX3VybDogUmVxdWVzdEluZm8pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgbGV0IHNjcmlwdDogSFRNTFNjcmlwdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG4gICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XHJcbiAgICAgIC8vIHNjcmlwdC50eXBlID0gXCJtb2R1bGVcIjtcclxuICAgICAgc2NyaXB0LmFzeW5jID0gZmFsc2U7XHJcbiAgICAgIC8vIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBoYW5kbGVMb2FkZWRTY3JpcHQpXHJcbiAgICAgIGxldCBoZWFkOiBIVE1MSGVhZEVsZW1lbnQgPSBkb2N1bWVudC5oZWFkO1xyXG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XHJcbiAgICAgIERlYnVnLmxvZyhcIkxvYWRpbmc6IFwiLCBfdXJsKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcclxuICAgICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4gX3Jlc29sdmUoKSk7XHJcbiAgICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XHJcbiAgICAgICAgICBEZWJ1Zy5lcnJvcihcIkxvYWRpbmcgc2NyaXB0XCIsIF91cmwpO1xyXG4gICAgICAgICAgX3JlamVjdCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNjcmlwdC5zcmMgPSBfdXJsLnRvU3RyaW5nKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCB7QGxpbmsgUmVzb3VyY2VzfSBmcm9tIHRoZSBnaXZlbiB1cmxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2FkUmVzb3VyY2VzKF91cmw6IFJlcXVlc3RJbmZvKTogUHJvbWlzZTxSZXNvdXJjZXM+IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2U6IFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goX3VybCk7XHJcbiAgICAgIGNvbnN0IHJlc291cmNlRmlsZUNvbnRlbnQ6IHN0cmluZyA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuXHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gU2VyaWFsaXplci5wYXJzZShyZXNvdXJjZUZpbGVDb250ZW50KTtcclxuICAgICAgbGV0IHJlY29uc3RydWN0aW9uOiBSZXNvdXJjZXMgPSBhd2FpdCBQcm9qZWN0LmRlc2VyaWFsaXplKHNlcmlhbGl6YXRpb24pO1xyXG4gICAgICBQcm9qZWN0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KEVWRU5ULlJFU09VUkNFU19MT0FERUQsIHsgZGV0YWlsOiB7IHVybDogX3VybCwgcmVzb3VyY2VzOiByZWNvbnN0cnVjdGlvbiB9IH0pKTtcclxuICAgICAgcmV0dXJuIHJlY29uc3RydWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBhbGwgcmVzb3VyY2VzIGZyb20gdGhlIHtAbGluayBkb2N1bWVudC5oZWFkfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWRSZXNvdXJjZXNGcm9tSFRNTCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgY29uc3QgaGVhZDogSFRNTEhlYWRFbGVtZW50ID0gZG9jdW1lbnQuaGVhZDtcclxuICAgICAgbGV0IGxpbmtzOiBOb2RlTGlzdE9mPEhUTUxMaW5rRWxlbWVudD4gPSBoZWFkLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW3R5cGU9cmVzb3VyY2VzXVwiKTtcclxuICAgICAgZm9yIChsZXQgbGluayBvZiBsaW5rcykge1xyXG4gICAgICAgIGxldCB1cmw6IFJlcXVlc3RJbmZvID0gbGluay5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XHJcbiAgICAgICAgYXdhaXQgUHJvamVjdC5sb2FkUmVzb3VyY2VzKHVybCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlcmlhbGl6ZSBhbGwgcmVzb3VyY2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uT2ZSZXNvdXJjZXMgPSB7fTtcclxuICAgICAgZm9yIChsZXQgaWRSZXNvdXJjZSBpbiBQcm9qZWN0LnJlc291cmNlcykge1xyXG4gICAgICAgIGxldCByZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UgPSBQcm9qZWN0LnJlc291cmNlc1tpZFJlc291cmNlXTtcclxuICAgICAgICBpZiAoaWRSZXNvdXJjZSAhPSByZXNvdXJjZS5pZFJlc291cmNlKVxyXG4gICAgICAgICAgRGVidWcuZXJyb3IoXCJSZXNvdXJjZS1pZCBtaXNtYXRjaFwiLCByZXNvdXJjZSk7XHJcbiAgICAgICAgc2VyaWFsaXphdGlvbltpZFJlc291cmNlXSA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplKHJlc291cmNlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSByZXNvdXJjZXMgZnJvbSBhIHNlcmlhbGl6YXRpb24sIGRlbGV0aW5nIGFsbCByZXNvdXJjZXMgcHJldmlvdXNseSByZWdpc3RlcmVkXHJcbiAgICAgKiBAcGFyYW0gX3NlcmlhbGl6YXRpb24gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyk6IFByb21pc2U8UmVzb3VyY2VzPiB7XHJcbiAgICAgIFByb2plY3Quc2VyaWFsaXphdGlvbiA9IF9zZXJpYWxpemF0aW9uO1xyXG4gICAgICBQcm9qZWN0LnJlc291cmNlcyA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBpZFJlc291cmNlIGluIF9zZXJpYWxpemF0aW9uKSB7XHJcbiAgICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBfc2VyaWFsaXphdGlvbltpZFJlc291cmNlXTtcclxuICAgICAgICBsZXQgcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlID0gYXdhaXQgUHJvamVjdC5kZXNlcmlhbGl6ZVJlc291cmNlKHNlcmlhbGl6YXRpb24pO1xyXG4gICAgICAgIGlmIChyZXNvdXJjZSlcclxuICAgICAgICAgIFByb2plY3QucmVzb3VyY2VzW2lkUmVzb3VyY2VdID0gcmVzb3VyY2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFByb2plY3QucmVzb3VyY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplUmVzb3VyY2UoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVJlc291cmNlPiB7XHJcbiAgICAgIHJldHVybiA8UHJvbWlzZTxTZXJpYWxpemFibGVSZXNvdXJjZT4+U2VyaWFsaXplci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqIHtAbGluayBUZXhJbWFnZVNvdXJjZX0gaXMgYSB1bmlvbiB0eXBlIHdoaWNoIGFzIG9mIG5vdyBpbmNsdWRlcyB7QGxpbmsgVmlkZW9GcmFtZX0uIEFsbCBvdGhlciBwYXJ0cyBvZiB0aGlzIHVuaW9uIGhhdmUgYSAud2lkdGggYW5kIC5oZWlnaHQgcHJvcGVydHkgYnV0IFZpZGVvRnJhbWUgZG9lcyBub3QuIEFuZCBzaW5jZSB3ZSBvbmx5IGV2ZXIgdXNlIHtAbGluayBIVE1MSW1hZ2VFbGVtZW50fSBhbmQge0BsaW5rIE9mZnNjcmVlbkNhbnZhc30gY3VycmVudGx5IFZpZGVvRnJhbWUgY2FuIGJlIGV4Y2x1ZGVkIGZvciBjb252ZW5pZW5jZSBvZiBhY2Nlc3NpbmcgLndpZHRoIGFuZCAuaGVpZ2h0ICovXHJcbiAgdHlwZSBJbWFnZVNvdXJjZSA9IEV4Y2x1ZGU8VGV4SW1hZ2VTb3VyY2UsIFZpZGVvRnJhbWU+O1xyXG5cclxuICAvKipcclxuICAgKiAtIENSSVNQOiBubyBtaXBtYXBwaW5nLCBtYWcgZmlsdGVyIG5lYXJlc3QsIG1pbiBmaWx0ZXIgbmVhcmVzdFxyXG4gICAqIC0gTUVESVVNOiBtaXBtYXBwaW5nLCBtYWcgZmlsdGVyIG5lYXJlc3QsIG1pbiBmaWx0ZXIgbmVhcmVzdF9taXBtYXBfbGluZWFyXHJcbiAgICogLSBCTFVSUlk6IG1pcG1hcHBpbmcsIG1hZyBmaWx0ZXIgbGluZWFyLCBtaW4gZmlsdGVyIGxpbmVhcl9taXBtYXBfbGluZWFyXHJcbiAgICogLSBTTU9PVEg6IG5vIG1pcG1hcHBpbmcsIG1hZyBmaWx0ZXIgbGluZWFyLCBtaW4gZmlsdGVyIGxpbmVhclxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIE1JUE1BUCB7XHJcbiAgICBDUklTUCwgTUVESVVNLCBCTFVSUlksIFNNT09USFxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gV1JBUCB7XHJcbiAgICBSRVBFQVQsIENMQU1QLCBNSVJST1JcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJhc2VjbGFzcyBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIHRleHR1cmVzLiBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIEBSZW5kZXJJbmplY3RvclRleHR1cmUuZGVjb3JhdGVcclxuICBAU2VyaWFsaXphYmxlUmVzb3VyY2UucmVnaXN0ZXJcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgVGV4dHVyZSBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG4gICAgcHVibGljIGlkUmVzb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyRGF0YTogdW5rbm93bjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgdGV4dHVyZURpcnR5OiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHByb3RlY3RlZCBtaXBtYXBEaXJ0eTogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBwcm90ZWN0ZWQgd3JhcERpcnR5OiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICAjbWlwbWFwOiBNSVBNQVAgPSBNSVBNQVAuQ1JJU1A7XHJcbiAgICAjd3JhcDogV1JBUCA9IFdSQVAuUkVQRUFUO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJUZXh0dXJlXCIpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBtaXBtYXAoX21pcG1hcDogTUlQTUFQKSB7XHJcbiAgICAgIHRoaXMuI21pcG1hcCA9IF9taXBtYXA7XHJcbiAgICAgIHRoaXMubWlwbWFwRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgbWlwbWFwKCk6IE1JUE1BUCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtaXBtYXA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCB3cmFwKF93cmFwOiBXUkFQKSB7XHJcbiAgICAgIHRoaXMuI3dyYXAgPSBfd3JhcDtcclxuICAgICAgdGhpcy53cmFwRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgd3JhcCgpOiBXUkFQIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3dyYXA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbWFnZSBzb3VyY2Ugb2YgdGhpcyB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IHRleEltYWdlU291cmNlKCk6IEltYWdlU291cmNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGFuZCBiaW5kcyB0aGUgdGV4dHVyZSBpbiBXZWJHTCBmcm9tIHRoZSB7QGxpbmsgdGV4SW1hZ2VTb3VyY2V9LiBcclxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvclRleHR1cmV9LiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1c2VSZW5kZXJEYXRhKF90ZXh0dXJlVW5pdDogbnVtYmVyID0gMCk6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgdGV4dHVyZSBpbiBXZWJHTCBmcmVlaW5nIHRoZSBhbGxvY2F0ZWQgZ3B1IG1lbW9yeS5cclxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvclRleHR1cmV9LlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWxldGVSZW5kZXJEYXRhKCk6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIHRoZSBpbWFnZSBkYXRhIGluIHRoZSByZW5kZXIgZW5naW5lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVmcmVzaCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy50ZXh0dXJlRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgaWRSZXNvdXJjZTogdGhpcy5pZFJlc291cmNlLFxyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICBtaXBtYXA6IE1JUE1BUFt0aGlzLiNtaXBtYXBdLFxyXG4gICAgICAgIHdyYXA6IFdSQVBbdGhpcy4jd3JhcF1cclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMsIF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xyXG4gICAgICB0aGlzLiNtaXBtYXAgPSA8bnVtYmVyPjx1bmtub3duPk1JUE1BUFtfc2VyaWFsaXphdGlvbi5taXBtYXBdO1xyXG4gICAgICB0aGlzLiN3cmFwID0gPG51bWJlcj48dW5rbm93bj5XUkFQW19zZXJpYWxpemF0aW9uLndyYXBdO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcihfZXh0ZW5kYWJsZT86IGJvb2xlYW4pOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKHRydWUpO1xyXG4gICAgICBtdXRhdG9yLm1pcG1hcCA9IHRoaXMuI21pcG1hcDtcclxuICAgICAgbXV0YXRvci53cmFwID0gdGhpcy4jd3JhcDtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gc3VwZXIuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKHR5cGVzLm1pcG1hcClcclxuICAgICAgICB0eXBlcy5taXBtYXAgPSBNSVBNQVA7XHJcbiAgICAgIGlmICh0eXBlcy53cmFwKVxyXG4gICAgICAgIHR5cGVzLndyYXAgPSBXUkFQO1xyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmlkUmVzb3VyY2U7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5yZW5kZXJEYXRhO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IudGV4dHVyZURpcnR5O1xyXG4gICAgICBkZWxldGUgX211dGF0b3IubWlwbWFwRGlydHk7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5taXBtYXBHZW5lcmF0ZWQ7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci53cmFwRGlydHk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhbiBleGlzdGluZyBpbWFnZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlSW1hZ2UgZXh0ZW5kcyBUZXh0dXJlIHtcclxuICAgIHB1YmxpYyBpbWFnZTogSFRNTEltYWdlRWxlbWVudCA9IG51bGw7XHJcbiAgICBwdWJsaWMgdXJsOiBSZXF1ZXN0SW5mbztcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3VybD86IFJlcXVlc3RJbmZvKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIGlmIChfdXJsKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkKF91cmwpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IF91cmwudG9TdHJpbmcoKS5zcGxpdChcIi9cIikucG9wKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB0ZXhJbWFnZVNvdXJjZSgpOiBJbWFnZVNvdXJjZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmltYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXN5bmNocm9ub3VzbHkgbG9hZHMgdGhlIGltYWdlIGZyb20gdGhlIGdpdmVuIHVybFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZChfdXJsOiBSZXF1ZXN0SW5mbyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICB0aGlzLnVybCA9IF91cmw7XHJcbiAgICAgIHRoaXMuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuXHJcblxyXG4gICAgICAvLyBjb25zdCByZXNwb25zZTogUmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuZmV0Y2godGhpcy51cmwpO1xyXG4gICAgICAvLyBjb25zdCBibG9iOiBCbG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xyXG4gICAgICAvLyBsZXQgb2JqZWN0VVJMOiBzdHJpbmcgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgICAvLyB0aGlzLmltYWdlLnNyYyA9IG9iamVjdFVSTDtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcclxuICAgICAgICB0aGlzLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcclxuICAgICAgICAgIHRoaXMucmVuZGVyRGF0YSA9IG51bGw7IC8vIHJlZnJlc2ggcmVuZGVyIGRhdGEgb24gbmV4dCBkcmF3IGNhbGxcclxuICAgICAgICAgIF9yZXNvbHZlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5pbWFnZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKCkgPT4gX3JlamVjdCgpKTtcclxuICAgICAgICB0aGlzLmltYWdlLnNyYyA9IG5ldyBVUkwodGhpcy51cmwudG9TdHJpbmcoKSwgUHJvamVjdC5iYXNlVVJMKS50b1N0cmluZygpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdXJsOiB0aGlzLnVybCxcclxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsIC8vIHNlcmlhbGl6ZSBmb3IgZWRpdG9yIHZpZXdzXHJcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICBhd2FpdCB0aGlzLmxvYWQoX3NlcmlhbGl6YXRpb24udXJsKTtcclxuICAgICAgLy8gdGhpcy50eXBlIGlzIGFuIGFjY2Vzc29yIG9mIE11dGFibGUgZG9lc24ndCBuZWVkIHRvIGJlIGRlc2VyaWFsaXplZFxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgaWYgKF9tdXRhdG9yLnVybCAmJiBfbXV0YXRvci51cmwgIT0gdGhpcy51cmwudG9TdHJpbmcoKSlcclxuICAgICAgICBhd2FpdCB0aGlzLmxvYWQoX211dGF0b3IudXJsKTtcclxuICAgICAgLy8gZXhjZXB0IHVybCBmcm9tIG11dGF0b3IgZm9yIGZ1cnRoZXIgcHJvY2Vzc2luZ1xyXG4gICAgICBkZWxldGUgKF9tdXRhdG9yLnVybCk7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgICAgLy8gVE9ETzogZXhhbWluZSBuZWNlc3NpdHkgdG8gcmVjb25zdHJ1Y3QsIGlmIG11dGF0b3IgaXMga2VwdCBieSBjYWxsZXJcclxuICAgICAgLy8gX211dGF0b3IudXJsID0gdGhpcy51cmw7IFxyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhIGNhbnZhc1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlQmFzZTY0IGV4dGVuZHMgVGV4dHVyZSB7XHJcbiAgICBwdWJsaWMgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZywgX2Jhc2U2NDogc3RyaW5nLCBfbWlwbWFwOiBNSVBNQVAgPSBNSVBNQVAuQ1JJU1AsIF93cmFwOiBXUkFQID0gV1JBUC5SRVBFQVQsIF93aWR0aD86IG51bWJlciwgX2hlaWdodD86IG51bWJlcikge1xyXG4gICAgICBzdXBlcihfbmFtZSk7XHJcbiAgICAgIHRoaXMuaW1hZ2Uuc3JjID0gX2Jhc2U2NDtcclxuICAgICAgdGhpcy5taXBtYXAgPSBfbWlwbWFwO1xyXG4gICAgICB0aGlzLndyYXAgPSBfd3JhcDtcclxuICAgICAgaWYgKF93aWR0aClcclxuICAgICAgICB0aGlzLmltYWdlLndpZHRoID0gX3dpZHRoO1xyXG4gICAgICBpZiAoX2hlaWdodClcclxuICAgICAgICB0aGlzLmltYWdlLmhlaWdodCA9IF9oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB0ZXhJbWFnZVNvdXJjZSgpOiBJbWFnZVNvdXJjZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmltYWdlO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhIGNhbnZhc1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlQ2FudmFzIGV4dGVuZHMgVGV4dHVyZSB7XHJcbiAgICBwdWJsaWMgY3JjMjogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfY3JjMjogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgdGhpcy5jcmMyID0gX2NyYzI7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IHRleEltYWdlU291cmNlKCk6IEltYWdlU291cmNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY3JjMi5jYW52YXM7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhIHRleHQuIFRleHR1cmUgdXBhdGVzIHdoZW4gdGhlIHRleHQgb3IgZm9udCBjaGFuZ2VzLiBUaGUgdGV4dHVyZSBpcyByZXNpemVkIHRvIGZpdCB0aGUgdGV4dC5cclxuICAgKiBAYXV0aG9ycyBKb25hcyBQbG90emt5LCBIRlUsIDIwMjRcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVGV4dHVyZVRleHQgZXh0ZW5kcyBUZXh0dXJlIHtcclxuICAgIHByb3RlY3RlZCBjcmMyOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcbiAgICAjdGV4dDogc3RyaW5nO1xyXG4gICAgI2ZvbnQ6IHN0cmluZztcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZywgX3RleHQ6IHN0cmluZyA9IFwiVGV4dFwiLCBfZm9udDogc3RyaW5nID0gXCIyMHB4IG1vbm9zcGFjZVwiKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgdGhpcy5jcmMyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgIHRoaXMudGV4dCA9IF90ZXh0O1xyXG4gICAgICB0aGlzLmZvbnQgPSBfZm9udDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHRleHQoX3RleHQ6IHN0cmluZykge1xyXG4gICAgICB0aGlzLiN0ZXh0ID0gX3RleHQ7XHJcbiAgICAgIHRoaXMudGV4dHVyZURpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHRleHQoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3RleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBmb250KF9mb250OiBzdHJpbmcpIHtcclxuICAgICAgdGhpcy4jZm9udCA9IF9mb250O1xyXG4gICAgICBkb2N1bWVudC5mb250cy5sb2FkKHRoaXMuI2ZvbnQpXHJcbiAgICAgICAgLmNhdGNoKChfZXJyb3IpID0+IERlYnVnLmVycm9yKGAke1RleHR1cmVUZXh0Lm5hbWV9OiAke19lcnJvcn1gKSlcclxuICAgICAgICAuZmluYWxseSgoKSA9PiB0aGlzLnRleHR1cmVEaXJ0eSA9IHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgZm9udCgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy4jZm9udDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHRleEltYWdlU291cmNlKCk6IEltYWdlU291cmNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgd2lkdGgoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLndpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaGVpZ2h0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBoYXNUcmFuc3BhcmVuY3koKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0IGNhbnZhcygpOiBIVE1MQ2FudmFzRWxlbWVudCB8IE9mZnNjcmVlbkNhbnZhcyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNyYzIuY2FudmFzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1c2VSZW5kZXJEYXRhKF90ZXh0dXJlVW5pdD86IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy50ZXh0dXJlRGlydHkpIHtcclxuICAgICAgICB0aGlzLmNyYzIuZm9udCA9IHRoaXMuZm9udDtcclxuXHJcbiAgICAgICAgbGV0IG1ldHJpY3M6IFRleHRNZXRyaWNzID0gdGhpcy5jcmMyLm1lYXN1cmVUZXh0KHRoaXMudGV4dCk7XHJcbiAgICAgICAgbGV0IHdpZHRoOiBudW1iZXIgPSBtZXRyaWNzLndpZHRoO1xyXG4gICAgICAgIGxldCBoZWlnaHQ6IG51bWJlciA9IG1ldHJpY3MuZm9udEJvdW5kaW5nQm94QXNjZW50ICsgbWV0cmljcy5mb250Qm91bmRpbmdCb3hEZXNjZW50O1xyXG5cclxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoICsgdGhpcy5jcmMyLm1lYXN1cmVUZXh0KFwiICBcIikud2lkdGg7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogMS4xOyAvLyBwYWRkaW5nLCBvdGhlcndpc2Ugb24gc29tZSBnbHlwaHMgbWlnaHQgZ2V0IGN1dCBvZmZcclxuICAgICAgICBpZiAodGhpcy5jYW52YXMud2lkdGggPT0gMClcclxuICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgdGhpcy5jcmMyLmZvbnQgPSB0aGlzLmZvbnQ7IC8vIFRPRE86IHdhaXQgZm9yIGZvbnQgdG8gYmUgbG9hZGVkIHVzaW5nIGRvY3VtZW50LmZvbnRzXHJcbiAgICAgICAgdGhpcy5jcmMyLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgdGhpcy5jcmMyLnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcbiAgICAgICAgdGhpcy5jcmMyLmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcclxuICAgICAgICB0aGlzLmNyYzIuY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuY3JjMi5maWxsVGV4dCh0aGlzLiN0ZXh0LCB0aGlzLmNhbnZhcy53aWR0aCAvIDIsIHRoaXMuY2FudmFzLmhlaWdodCAvIDIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdXBlci51c2VSZW5kZXJEYXRhKF90ZXh0dXJlVW5pdCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIHRleHQ6IHRoaXMudGV4dCxcclxuICAgICAgICBmb250OiB0aGlzLmZvbnRcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHRoaXMudGV4dCA9IF9zZXJpYWxpemF0aW9uLnRleHQ7XHJcbiAgICAgIHRoaXMuZm9udCA9IF9zZXJpYWxpemF0aW9uLmZvbnQ7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKF9leHRlbmRhYmxlPzogYm9vbGVhbik6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IodHJ1ZSk7XHJcbiAgICAgIG11dGF0b3IudGV4dCA9IHRoaXMudGV4dDtcclxuICAgICAgbXV0YXRvci5mb250ID0gdGhpcy5mb250O1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGEgRlVER0UtU2tldGNoXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFRleHR1cmVTa2V0Y2ggZXh0ZW5kcyBUZXh0dXJlQ2FudmFzIHtcclxuICAgIHB1YmxpYyBnZXQgdGV4SW1hZ2VTb3VyY2UoKTogSW1hZ2VTb3VyY2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogVGV4dHVyZSBjcmVhdGVkIGZyb20gYW4gSFRNTC1wYWdlXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFRleHR1cmVIVE1MIGV4dGVuZHMgVGV4dHVyZUNhbnZhcyB7XHJcbiAgICBwdWJsaWMgZ2V0IHRleEltYWdlU291cmNlKCk6IEltYWdlU291cmNlIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYWxsIG1lc2hlcy4gXHJcbiAgICogTWVzaGVzIHByb3ZpZGUgaW5kZXhlZCB2ZXJ0aWNlcywgdGhlIG9yZGVyIG9mIGluZGljZXMgdG8gY3JlYXRlIHRyaWdvbnMgYW5kIG5vcm1hbHMsIGFuZCB0ZXh0dXJlIGNvb3JkaW5hdGVzXHJcbiAgICogXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTkvMjJcclxuICAgKi9cclxuICBAUmVuZGVySW5qZWN0b3JNZXNoLmRlY29yYXRlXHJcbiAgQFNlcmlhbGl6YWJsZVJlc291cmNlLnJlZ2lzdGVyXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIE1lc2ggZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgLyoqIHJlZmVycyBiYWNrIHRvIHRoaXMgY2xhc3MgZnJvbSBhbnkgc3ViY2xhc3MgZS5nLiBpbiBvcmRlciB0byBmaW5kIGNvbXBhdGlibGUgb3RoZXIgcmVzb3VyY2VzKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgYmFzZUNsYXNzOiB0eXBlb2YgTWVzaCA9IE1lc2g7XHJcbiAgICAvKiogbGlzdCBvZiBhbGwgdGhlIHN1YmNsYXNzZXMgZGVyaXZlZCBmcm9tIHRoaXMgY2xhc3MsIGlmIHRoZXkgcmVnaXN0ZXJlZCBwcm9wZXJseSovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN1YmNsYXNzZXM6IHR5cGVvZiBNZXNoW10gPSBbXTtcclxuXHJcbiAgICAvLyBUT0RPOiByZW5hbWUgdmVydGljZXMgdG8gdmVydGljZXNTbW9vdGggb3IganVzdCBjbG91ZCwgYW5kIGNsb3VkIHRvIHZlcnRpY2VzXHJcblxyXG4gICAgcHVibGljIGlkUmVzb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmcgPSBcIk1lc2hcIjtcclxuICAgIC8vIGJhc2Ugc3RydWN0dXJlIGZvciBtZXNoZXMgaW4gRlVER0VcclxuICAgIHB1YmxpYyB2ZXJ0aWNlczogVmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuICAgIHB1YmxpYyBmYWNlczogRmFjZVtdID0gW107XHJcblxyXG4gICAgLyoqIGJvdW5kaW5nIGJveCBBQUJCICovXHJcbiAgICBwcm90ZWN0ZWQgxpJib3g6IEJveDtcclxuICAgIC8vIFRPRE86IGV4cGxvcmUgbWF0aGVtYXRpY3MgZm9yIGVhc3kgdHJhbnNmb3JtYXRpb25zIG9mIHJhZGl1cyBcclxuICAgIC8qKiBib3VuZGluZyByYWRpdXMgKi9cclxuICAgIHByb3RlY3RlZCDGknJhZGl1czogbnVtYmVyO1xyXG5cclxuICAgICNyZW5kZXJNZXNoOiBSZW5kZXJNZXNoO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoXCIpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlZ2lzdGVyU3ViY2xhc3MoX3N1YkNsYXNzOiB0eXBlb2YgTWVzaCk6IG51bWJlciB7IHJldHVybiBNZXNoLnN1YmNsYXNzZXMucHVzaChfc3ViQ2xhc3MpIC0gMTsgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgcmVuZGVyTWVzaCgpOiBSZW5kZXJNZXNoIHtcclxuICAgICAgaWYgKHRoaXMuI3JlbmRlck1lc2ggPT0gbnVsbClcclxuICAgICAgICB0aGlzLiNyZW5kZXJNZXNoID0gbmV3IFJlbmRlck1lc2godGhpcyk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy4jcmVuZGVyTWVzaDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGJvdW5kaW5nQm94KCk6IEJveCB7XHJcbiAgICAgIGlmICh0aGlzLsaSYm94ID09IG51bGwpXHJcbiAgICAgICAgdGhpcy7GkmJveCA9IHRoaXMuY3JlYXRlQm91bmRpbmdCb3goKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLsaSYm94O1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldCByYWRpdXMoKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMuxpJyYWRpdXMgPT0gbnVsbClcclxuICAgICAgICB0aGlzLsaScmFkaXVzID0gdGhpcy5jcmVhdGVSYWRpdXMoKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLsaScmFkaXVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yTWVzaH0uXHJcbiAgICAgKiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi8gLy8gVE9ETzogcmVuYW1lIHRoaXNcclxuICAgIHB1YmxpYyB1c2VSZW5kZXJCdWZmZXJzKCk6IFJlbmRlckJ1ZmZlcnMgeyByZXR1cm4gbnVsbDsgLyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XHJcbiAgICAvKipcclxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3Rvck1lc2h9LlxyXG4gICAgICogVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmVuZGVyQnVmZmVycygpOiBSZW5kZXJCdWZmZXJzIHsgcmV0dXJuIG51bGw7IC8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JNZXNofS5cclxuICAgICAqIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGRlbGV0ZVJlbmRlckJ1ZmZlcnMoX3JlbmRlckJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgYm91bmRzIG9mIHRoaXMgbWVzaCBhc3dlbGwgYXMgdGhlIGJ1ZmZlcnMgb2YgdGhlIGFzc29jaWF0ZWQge0BsaW5rIFJlbmRlck1lc2h9LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuxpJib3ggPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMuxpJyYWRpdXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgIFxyXG4gICAgICB0aGlzLmRlbGV0ZVJlbmRlckJ1ZmZlcnModGhpcy5yZW5kZXJNZXNoLmJ1ZmZlcnMpO1xyXG4gICAgICB0aGlzLnJlbmRlck1lc2guY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIC8vIFNlcmlhbGl6ZS9EZXNlcmlhbGl6ZSBmb3IgYWxsIG1lc2hlcyB0aGF0IGNhbGN1bGF0ZSB3aXRob3V0IHBhcmFtZXRlcnNcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGlkUmVzb3VyY2U6IHRoaXMuaWRSZXNvdXJjZSxcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgdHlwZTogdGhpcy50eXBlIC8vIHN0b3JlIGZvciBlZGl0b3Igdmlld1xyXG4gICAgICB9OyAvLyBubyBkYXRhIG5lZWRlZCAuLi5cclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMsIF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xyXG4gICAgICAvLyB0eXBlIGlzIGFuIGFjY2Vzc29yIGFuZCBtdXN0IG5vdCBiZSBkZXNlcmlhbGl6ZWRcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgLy8gVE9ETzogc28gbXVjaCB0byBkZWxldGUuLi4gcmF0aGVyIGp1c3QgZ2F0aGVyIHdoYXQgdG8gbXV0YXRlXHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci7GkmJveDtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLsaScmFkaXVzO1xyXG5cclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnJlbmRlckJ1ZmZlcnM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVJhZGl1cygpOiBudW1iZXIge1xyXG4gICAgICAvL1RPRE86IHJhZGl1cyBhbmQgYm91bmRpbmcgYm94IGNvdWxkIGJlIGNyZWF0ZWQgb24gY29uc3RydWN0aW9uIG9mIHZlcnRleC1hcnJheVxyXG4gICAgICBsZXQgcmFkaXVzOiBudW1iZXIgPSAwO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgdGhpcy52ZXJ0aWNlcy5wb3NpdGlvbihpKS5tYWduaXR1ZGVTcXVhcmVkKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHJhZGl1cyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUJvdW5kaW5nQm94KCk6IEJveCB7XHJcbiAgICAgIGxldCBib3g6IEJveCA9IFJlY3ljbGVyLmdldChCb3gpO1xyXG4gICAgICBib3guc2V0KCk7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHBvaW50OiBWZWN0b3IzID0gdGhpcy52ZXJ0aWNlcy5wb3NpdGlvbihpKTtcclxuICAgICAgICBib3guZXhwYW5kKHBvaW50KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYm94O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBCYXNlY2xhc3MgZm9yIG1hdGVyaWFscy4gQ29tYmluZXMgYSB7QGxpbmsgU2hhZGVyfSB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQ29hdH1cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIEBlbnVtZXJhdGVcclxuICBAU2VyaWFsaXphYmxlUmVzb3VyY2UucmVnaXN0ZXJcclxuICBleHBvcnQgY2xhc3MgTWF0ZXJpYWwgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgLyoqIFRoZSBuYW1lIHRvIGNhbGwgdGhlIE1hdGVyaWFsIGJ5LiAqL1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcclxuICAgIHB1YmxpYyBpZFJlc291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgcHJpdmF0ZSBzaGFkZXJUeXBlOiB0eXBlb2YgU2hhZGVyOyAvLyBUaGUgc2hhZGVyIHByb2dyYW0gdXNlZCBieSB0aGlzIEJhc2VNYXRlcmlhbFxyXG4gICAgI2NvYXQ6IENvYXQ7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcsIF9zaGFkZXI/OiB0eXBlb2YgU2hhZGVyLCBfY29hdD86IENvYXQpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMuc2hhZGVyVHlwZSA9IF9zaGFkZXI7XHJcbiAgICAgIGlmIChfc2hhZGVyKSB7XHJcbiAgICAgICAgaWYgKF9jb2F0KVxyXG4gICAgICAgICAgdGhpcy5jb2F0ID0gX2NvYXQ7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhpcy5jb2F0ID0gdGhpcy5jcmVhdGVDb2F0TWF0Y2hpbmdTaGFkZXIoKTtcclxuICAgICAgfVxyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IHJlZmVyZW5jZWQge0BsaW5rIENvYXR9IGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIEB0eXBlKENvYXQpXHJcbiAgICBAZW51bWVyYXRlXHJcbiAgICBwdWJsaWMgZ2V0IGNvYXQoKTogQ29hdCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNjb2F0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyB0aGlzIG1hdGVyaWFsIHJlZmVyZW5jZSB0aGUgZ2l2ZW4ge0BsaW5rIENvYXR9IGlmIGl0IGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgcmVmZXJlbmNlZCB7QGxpbmsgU2hhZGVyfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IGNvYXQoX2NvYXQ6IENvYXQpIHtcclxuICAgICAgaWYgKHRoaXMuc2hhZGVyVHlwZSlcclxuICAgICAgICBpZiAoX2NvYXQuY29uc3RydWN0b3IgIT0gdGhpcy5zaGFkZXJUeXBlLmdldENvYXQoKSlcclxuICAgICAgICAgIGlmIChfY29hdCBpbnN0YW5jZW9mIHRoaXMuc2hhZGVyVHlwZS5nZXRDb2F0KCkpXHJcbiAgICAgICAgICAgIERlYnVnLmZ1ZGdlKFwiQ29hdCBpcyBleHRlbnNpb24gb2YgQ29hdCByZXF1aXJlZCBieSBzaGFkZXJcIik7XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRocm93IChuZXcgRXJyb3IoXCJTaGFkZXIgYW5kIGNvYXQgZG9uJ3QgbWF0Y2hcIikpO1xyXG4gICAgICB0aGlzLiNjb2F0ID0gX2NvYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBDb2F0fSBpbnN0YW5jZSB0aGF0IGlzIHZhbGlkIGZvciB0aGUge0BsaW5rIFNoYWRlcn0gcmVmZXJlbmNlZCBieSB0aGlzIG1hdGVyaWFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGVDb2F0TWF0Y2hpbmdTaGFkZXIoKTogQ29hdCB7XHJcbiAgICAgIGxldCBjb2F0OiBDb2F0ID0gbmV3ICh0aGlzLnNoYWRlclR5cGUuZ2V0Q29hdCgpKSgpO1xyXG4gICAgICByZXR1cm4gY29hdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIG1hdGVyaWFscyByZWZlcmVuY2UgdG8gdGhlIGdpdmVuIHtAbGluayBTaGFkZXJ9LCBjcmVhdGVzIGFuZCByZWZlcmVuY2VzIGEgbmV3IHtAbGluayBDb2F0fSBpbnN0YW5jZSAgXHJcbiAgICAgKiBhbmQgbXV0YXRlcyB0aGUgbmV3IGNvYXQgdG8gcHJlc2VydmUgbWF0Y2hpbmcgcHJvcGVydGllcy5cclxuICAgICAqIEBwYXJhbSBfc2hhZGVyVHlwZSBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNoYWRlcihfc2hhZGVyVHlwZTogdHlwZW9mIFNoYWRlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLnNoYWRlclR5cGUgPSBfc2hhZGVyVHlwZTtcclxuICAgICAgbGV0IGNvYXQ6IENvYXQgPSB0aGlzLmNyZWF0ZUNvYXRNYXRjaGluZ1NoYWRlcigpO1xyXG4gICAgICBjb2F0Lm11dGF0ZSh0aGlzLiNjb2F0Py5nZXRNdXRhdG9yKCkpO1xyXG4gICAgICB0aGlzLmNvYXQgPSBjb2F0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIFNoYWRlcn0gcmVmZXJlbmNlZCBieSB0aGlzIG1hdGVyaWFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTaGFkZXIoKTogdHlwZW9mIFNoYWRlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNoYWRlclR5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICAvLyBUT0RPOiB0aGlzIHR5cGUgb2Ygc2VyaWFsaXphdGlvbiB3YXMgaW1wbGVtZW50ZWQgZm9yIGltcGxpY2l0IE1hdGVyaWFsIGNyZWF0ZS4gQ2hlY2sgaWYgb2Jzb2xldGUgd2hlbiBvbmx5IG9uZSBtYXRlcmlhbCBjbGFzcyBleGlzdHMgYW5kL29yIG1hdGVyaWFscyBhcmUgc3RvcmVkIHNlcGFyYXRlbHlcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2UsXHJcbiAgICAgICAgc2hhZGVyOiB0aGlzLnNoYWRlclR5cGUubmFtZSxcclxuICAgICAgICBjb2F0OiBTZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLiNjb2F0KSxcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMsIF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UpO1xyXG4gICAgICB0aGlzLnNoYWRlclR5cGUgPSAoPEdlbmVyYWw+RnVkZ2VDb3JlKVtfc2VyaWFsaXphdGlvbi5zaGFkZXJdO1xyXG4gICAgICBsZXQgY29hdDogQ29hdCA9IDxDb2F0PmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uY29hdCk7XHJcbiAgICAgIHRoaXMuY29hdCA9IGNvYXQ7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIC8vIGRlbGV0ZSBfbXV0YXRvci5pZFJlc291cmNlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBuYW1lc2FwY2UgZm9yIGhhbmRsaW5nIHRoZSBwYXJ0aWNsZSBkYXRhXHJcbiAgICovXHJcbiAgZXhwb3J0IG5hbWVzcGFjZSBQYXJ0aWNsZURhdGEge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhdGEgc3RydWN0dXJlIGZvciBhIHBhcnRpY2xlIHN5c3RlbS4gRGVzY3JpYmVzIHRoZSBwYXJ0aWNsZSBiZWhhdmlvciBhbmQgYXBwZWFyYW5jZS5cclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGludGVyZmFjZSBTeXN0ZW0ge1xyXG4gICAgICB2YXJpYWJsZU5hbWVzPzogc3RyaW5nW107XHJcbiAgICAgIHZhcmlhYmxlcz86IEV4cHJlc3Npb25bXTsgLy97IFtuYW1lOiBzdHJpbmddOiBFeHByZXNzaW9uIH07XHJcbiAgICAgIGNvbG9yPzogRXhwcmVzc2lvbltdO1xyXG4gICAgICBtdHhMb2NhbD86IFRyYW5zZm9ybWF0aW9uW107XHJcbiAgICAgIG10eFdvcmxkPzogVHJhbnNmb3JtYXRpb25bXTtcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgdHlwZSBSZWN1cnNpdmUgPSBTeXN0ZW0gfCBFeHByZXNzaW9uW10gfCBUcmFuc2Zvcm1hdGlvbltdIHwgVHJhbnNmb3JtYXRpb24gfCBFeHByZXNzaW9uO1xyXG5cclxuICAgIGV4cG9ydCB0eXBlIEV4cHJlc3Npb24gPSBGdW5jdGlvbiB8IFZhcmlhYmxlIHwgQ29uc3RhbnQgfCBDb2RlO1xyXG5cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xyXG4gICAgICBmdW5jdGlvbjogRlVOQ1RJT047XHJcbiAgICAgIHBhcmFtZXRlcnM6IEV4cHJlc3Npb25bXTtcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIFZhcmlhYmxlIHtcclxuICAgICAgdmFsdWU6IHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIENvbnN0YW50IHtcclxuICAgICAgdmFsdWU6IG51bWJlcjtcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIENvZGUge1xyXG4gICAgICBjb2RlOiBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBUcmFuc2Zvcm1hdGlvbiB7XHJcbiAgICAgIHRyYW5zZm9ybWF0aW9uOiBcInRyYW5zbGF0ZVwiIHwgXCJyb3RhdGVcIiB8IFwic2NhbGVcIjtcclxuICAgICAgcGFyYW1ldGVyczogRXhwcmVzc2lvbltdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBkYXRhIGlzIGEge0BsaW5rIEV4cHJlc3Npb259XHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0V4cHJlc3Npb24oX2RhdGE6IFJlY3Vyc2l2ZSk6IF9kYXRhIGlzIEV4cHJlc3Npb24ge1xyXG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihfZGF0YSkgfHwgaXNWYXJpYWJsZShfZGF0YSkgfHwgaXNDb25zdGFudChfZGF0YSkgfHwgaXNDb2RlKF9kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZGF0YSBpcyBhIHtAbGluayBGdW5jdGlvbn1cclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24oX2RhdGE6IFJlY3Vyc2l2ZSk6IF9kYXRhIGlzIEZ1bmN0aW9uIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBfZGF0YSA9PSBcIm9iamVjdFwiICYmIFwiZnVuY3Rpb25cIiBpbiBfZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZGF0YSBpcyBhIHtAbGluayBWYXJpYWJsZX1cclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzVmFyaWFibGUoX2RhdGE6IFJlY3Vyc2l2ZSk6IF9kYXRhIGlzIFZhcmlhYmxlIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBfZGF0YSA9PSBcIm9iamVjdFwiICYmIFwidmFsdWVcIiBpbiBfZGF0YSAmJiB0eXBlb2YgX2RhdGEudmFsdWUgPT0gXCJzdHJpbmdcIjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZGF0YSBpcyBhIHtAbGluayBDb25zdGFudH1cclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzQ29uc3RhbnQoX2RhdGE6IFJlY3Vyc2l2ZSk6IF9kYXRhIGlzIENvbnN0YW50IHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBfZGF0YSA9PSBcIm9iamVjdFwiICYmIFwidmFsdWVcIiBpbiBfZGF0YSAmJiB0eXBlb2YgX2RhdGEudmFsdWUgPT0gXCJudW1iZXJcIjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZGF0YSBpcyBhIHtAbGluayBDb2RlfVxyXG4gICAgICovXHJcbiAgICBleHBvcnQgZnVuY3Rpb24gaXNDb2RlKF9kYXRhOiBSZWN1cnNpdmUpOiBfZGF0YSBpcyBDb2RlIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBfZGF0YSA9PSBcIm9iamVjdFwiICYmIFwiY29kZVwiIGluIF9kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBkYXRhIGlzIGEge0BsaW5rIFRyYW5zZm9ybWF0aW9ufVxyXG4gICAgICovXHJcbiAgICBleHBvcnQgZnVuY3Rpb24gaXNUcmFuc2Zvcm1hdGlvbihfZGF0YTogUmVjdXJzaXZlKTogX2RhdGEgaXMgVHJhbnNmb3JtYXRpb24ge1xyXG4gICAgICByZXR1cm4gdHlwZW9mIF9kYXRhID09IFwib2JqZWN0XCIgJiYgXCJ0cmFuc2Zvcm1hdGlvblwiIGluIF9kYXRhO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSG9sZHMgaW5mb3JtYXRpb24gb24gaG93IHRvIG11dGF0ZSB0aGUgcGFydGljbGVzIG9mIGEgcGFydGljbGUgc3lzdGVtLlxyXG4gICAqIEEgZnVsbCBwYXJ0aWNsZSBzeXN0ZW0gaXMgY29tcG9zZWQgYnkgYXR0YWNoaW5nIGEge0BsaW5rIENvbXBvbmVudFBhcnRpY2xlU3lzdGVtfSwge0BsaW5rIENvbXBvbmVudE1lc2h9IGFuZCB7QGxpbmsgQ29tcG9uZW50TWF0ZXJpYWx9IHRvIHRoZSBzYW1lIHtAbGluayBOb2RlfS4gXHJcbiAgICogQWRkaXRpb25hbGx5IGEge0BsaW5rIENvbXBvbmVudEZhY2VDYW1lcmF9IGNhbiBiZSBhdHRhY2hlZCB0byBtYWtlIHRoZSBwYXJ0aWNsZXMgZmFjZSB0aGUgY2FtZXJhLlxyXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyMlxyXG4gICAqL1xyXG4gIEBTZXJpYWxpemFibGVSZXNvdXJjZS5yZWdpc3RlclxyXG4gIGV4cG9ydCBjbGFzcyBQYXJ0aWNsZVN5c3RlbSBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG4gICAgcHVibGljIGlkUmVzb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAjZGF0YTogUGFydGljbGVEYXRhLlN5c3RlbTtcclxuICAgIC8qKiBNYXAgb2Ygc2hhZGVyIHVuaXZlcnNhbCBkZXJpdmF0ZXMgdG8gY29ycmVzcG9uZGluZyBjb21wdXRlZCB7QGxpbmsgU2hhZGVyUGFydGljbGVTeXN0ZW19LiBcclxuICAgICAqIFRoaXMgd2F5IGVhY2ggcGFydGljbGUgc3lzdGVtIHJlc291cmNlIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggbXVsdGlwbGUgc2hhZGVyIHVuaXZlcnNhbCBkZXJpdmF0ZXMgKi9cclxuICAgICNzaGFkZXJUb1NoYWRlclBhcnRpY2xlU3lzdGVtOiBNYXA8U2hhZGVySW50ZXJmYWNlLCBTaGFkZXJQYXJ0aWNsZVN5c3RlbT4gPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBQYXJ0aWNsZVN5c3RlbS5uYW1lLCBfZGF0YTogUGFydGljbGVEYXRhLlN5c3RlbSA9IHt9KSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICB0aGlzLmRhdGEgPSBfZGF0YTtcclxuXHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBkYXRhKCk6IFBhcnRpY2xlRGF0YS5TeXN0ZW0ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGRhdGEoX2RhdGE6IFBhcnRpY2xlRGF0YS5TeXN0ZW0pIHtcclxuICAgICAgdGhpcy4jZGF0YSA9IF9kYXRhO1xyXG4gICAgICB0aGlzLiNzaGFkZXJUb1NoYWRlclBhcnRpY2xlU3lzdGVtLmZvckVhY2goX3NoYWRlciA9PiBfc2hhZGVyLmRlbGV0ZVByb2dyYW0oKSk7XHJcbiAgICAgIHRoaXMuI3NoYWRlclRvU2hhZGVyUGFydGljbGVTeXN0ZW0uY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3JyZXNwb25kaW5nIHtAbGluayBTaGFkZXJQYXJ0aWNsZVN5c3RlbX0gZm9yIHRoZSBnaXZlbiBzaGFkZXIgdW5pdmVyc2FsIGRlcml2YXRlLlxyXG4gICAgICogVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbSB0byByZW5kZXIgdGhlIHBhcnRpY2xlIHN5c3RlbS5cclxuICAgICAqIEByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHtAbGluayBTaGFkZXJQYXJ0aWNsZVN5c3RlbX1cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U2hhZGVyRnJvbShfc291cmNlOiBTaGFkZXJJbnRlcmZhY2UpOiBTaGFkZXJQYXJ0aWNsZVN5c3RlbSB7XHJcbiAgICAgIGlmICghdGhpcy4jc2hhZGVyVG9TaGFkZXJQYXJ0aWNsZVN5c3RlbS5oYXMoX3NvdXJjZSkpIHtcclxuICAgICAgICBsZXQgcGFydGljbGVTaGFkZXI6IFNoYWRlclBhcnRpY2xlU3lzdGVtID0gbmV3IFNoYWRlclBhcnRpY2xlU3lzdGVtKCk7XHJcbiAgICAgICAgcGFydGljbGVTaGFkZXIuZGF0YSA9IHRoaXMuZGF0YTtcclxuICAgICAgICBwYXJ0aWNsZVNoYWRlci5kZWZpbmUgPSBbLi4ucGFydGljbGVTaGFkZXIuZGVmaW5lLCAuLi5fc291cmNlLmRlZmluZV07XHJcbiAgICAgICAgcGFydGljbGVTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gX3NvdXJjZS5nZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTtcclxuICAgICAgICBwYXJ0aWNsZVNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IF9zb3VyY2UuZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTtcclxuICAgICAgICB0aGlzLiNzaGFkZXJUb1NoYWRlclBhcnRpY2xlU3lzdGVtLnNldChfc291cmNlLCBwYXJ0aWNsZVNoYWRlcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLiNzaGFkZXJUb1NoYWRlclBhcnRpY2xlU3lzdGVtLmdldChfc291cmNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGlkUmVzb3VyY2U6IHRoaXMuaWRSZXNvdXJjZSxcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcywgX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XHJcbiAgICAgIHRoaXMuZGF0YSA9IF9zZXJpYWxpemF0aW9uLmRhdGE7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5jYWNoZWRNdXRhdG9ycztcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNoYWRlck1hcDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBCdWZmZXJzIHRoZSBib25lIGRhdGEgZnJvbSB0aGUge0BsaW5rIENvbXBvbmVudFNrZWxldG9ufSBpbnRvIGEgV2ViR0wgQnVmZmVyXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFJlbmRlckluamVjdG9yQ29tcG9uZW50U2tlbGV0b24ge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWNvcmF0ZShfY29uc3RydWN0b3I6IHR5cGVvZiBDb21wb25lbnRTa2VsZXRvbiwgX2NvbnRleHQ6IENsYXNzRGVjb3JhdG9yQ29udGV4dCk6IHZvaWQge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgX2NvbnN0cnVjdG9yLnByb3RvdHlwZS51c2VSZW5kZXJCdWZmZXIubmFtZSwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvckNvbXBvbmVudFNrZWxldG9uLnVzZVJlbmRlckJ1ZmZlclxyXG4gICAgICB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUudXBkYXRlUmVuZGVyQnVmZmVyLm5hbWUsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JDb21wb25lbnRTa2VsZXRvbi51cGRhdGVSZW5kZXJCdWZmZXJcclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBfY29uc3RydWN0b3IucHJvdG90eXBlLmRlbGV0ZVJlbmRlckJ1ZmZlci5uYW1lLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yQ29tcG9uZW50U2tlbGV0b24uZGVsZXRlUmVuZGVyQnVmZmVyXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgdXNlUmVuZGVyQnVmZmVyKHRoaXM6IENvbXBvbmVudFNrZWxldG9uKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5yZW5kZXJCdWZmZXIpXHJcbiAgICAgICAgY3JjMy5iaW5kQnVmZmVyQmFzZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCBVTklGT1JNX0JMT0NLLlNLSU4uQklORElORywgdGhpcy5yZW5kZXJCdWZmZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgdXBkYXRlUmVuZGVyQnVmZmVyKHRoaXM6IENvbXBvbmVudFNrZWxldG9uKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBpZiAoIXRoaXMucmVuZGVyQnVmZmVyKSB7XHJcbiAgICAgICAgY29uc3QgYm9uZXNCeXRlU2l6ZTogbnVtYmVyID0gMjU2ICogMTYgKiA0OyAvLyBDQVVUSU9OOiB0aGlzIGlzIGRlcGVuZGVudCBvbiB0aGUgc2hhZGVyIHNvdXJjZSBjb2RlIHdoZXJlIDI1NiBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgYm9uZXNcclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJCdWZmZXIgPSBSZW5kZXJXZWJHTC5hc3NlcnQoY3JjMy5jcmVhdGVCdWZmZXIoKSk7XHJcbiAgICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIHRoaXMucmVuZGVyQnVmZmVyKTtcclxuICAgICAgICBjcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgYm9uZXNCeXRlU2l6ZSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5EWU5BTUlDX0RSQVcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMubXR4Qm9uZXMubGVuZ3RoICogMTYpO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tdHhCb25lcy5sZW5ndGg7IGkrKylcclxuICAgICAgICBkYXRhLnNldCh0aGlzLm10eEJvbmVzW2ldLmdldCgpLCBpICogMTYpO1xyXG5cclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIHRoaXMucmVuZGVyQnVmZmVyKTtcclxuICAgICAgY3JjMy5idWZmZXJTdWJEYXRhKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIDAsIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZGVsZXRlUmVuZGVyQnVmZmVyKHRoaXM6IENvbXBvbmVudFNrZWxldG9uKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5yZW5kZXJCdWZmZXIpXHJcbiAgICAgICAgY3JjMy5kZWxldGVCdWZmZXIodGhpcy5yZW5kZXJCdWZmZXIpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIi4vLi4vUmVuZGVyL1JlbmRlckluamVjdG9yQ29tcG9uZW50U2tlbGV0b24udHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBIb2xkcyBhbiBhcnJheSBvZiBib25lcyAoe0BsaW5rIE5vZGV9cyB3aXRoaW4gYSB7QGxpbmsgR3JhcGh9KS4gUmVmZXJlbmNlZCBmcm9tIGEge0BsaW5rIENvbXBvbmVudE1lc2h9IGl0IGNhbiBiZSBhc3NvY2lhdGVkIHdpdGggYSB7QGxpbmsgTWVzaH0gYW5kIGVuYWJsZSBza2lubmluZyBmb3IgdGhlIG1lc2guXHJcbiAgICogQGF1dGhvcnMgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjItMjAyMyB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xyXG4gICAqL1xyXG4gIEBSZW5kZXJJbmplY3RvckNvbXBvbmVudFNrZWxldG9uLmRlY29yYXRlXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudFNrZWxldG9uIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIC8qKiBUaGUgYm9uZXMgdXNlZCBmb3Igc2tpbm5pbmcgKi9cclxuICAgIHB1YmxpYyBib25lczogTm9kZVtdO1xyXG4gICAgLyoqIFdoZW4gYXBwbGllZCB0byB2ZXJ0aWNlcywgaXQgbW92ZXMgdGhlbSBmcm9tIG9iamVjdC9tb2RlbCBzcGFjZSB0byBib25lLWxvY2FsIHNwYWNlIGFzIGlmIHRoZSBib25lIHdlcmUgYXQgaXRzIGluaXRpYWwgcG9zZSAqL1xyXG4gICAgcHVibGljIG10eEJpbmRJbnZlcnNlczogTWF0cml4NHg0W107IC8vIFRPRE86IHRoaW5rIGFib3V0IHNlcmlhbGl6aW5nIHRoaXMgc2VwYXJhdGVseSB0byBtYWtlIGl0IHNoYXJlYWJsZSBiZXR3ZWVuIHNrZWxldG9uIHNlcmlhbGl6YXRpb25zXHJcblxyXG4gICAgcHJvdGVjdGVkIHJlbmRlckJ1ZmZlcjogdW5rbm93bjtcclxuICAgIHByb3RlY3RlZCBzaW5nbGV0b246IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIC8qKiBDb250YWlucyB0aGUgYm9uZSB0cmFuc2Zvcm1hdGlvbnMgYXBwbGljYWJsZSB0byB0aGUgdmVydGljZXMgb2YgYSB7QGxpbmsgTWVzaH0gKi9cclxuICAgIHByb3RlY3RlZCByZWFkb25seSBtdHhCb25lczogTWF0cml4NHg0W10gPSBbXTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2JvbmVzOiBOb2RlW10gPSBbXSwgX210eEJvbmVJbnZlcnNlczogTWF0cml4NHg0W10gPSBbXSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmJvbmVzID0gX2JvbmVzO1xyXG4gICAgICB0aGlzLm10eEJpbmRJbnZlcnNlcyA9IF9tdHhCb25lSW52ZXJzZXM7XHJcblxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkrKylcclxuICAgICAgICBpZiAodGhpcy5tdHhCaW5kSW52ZXJzZXNbaV0gPT0gbnVsbClcclxuICAgICAgICAgIHRoaXMubXR4QmluZEludmVyc2VzW2ldID0gdGhpcy5ib25lc1tpXS5tdHhXb3JsZEludmVyc2UuY2xvbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JDb21wb25lbnRTa2VsZXRvbn0uXHJcbiAgICAgKiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1c2VSZW5kZXJCdWZmZXIoKTogdm9pZCB7IC8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfTtcclxuICAgIC8qKlxyXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yQ29tcG9uZW50U2tlbGV0b259LlxyXG4gICAgICogVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlUmVuZGVyQnVmZmVyKCk6IHZvaWQgeyAvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yQ29tcG9uZW50U2tlbGV0b259LlxyXG4gICAgICogVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVsZXRlUmVuZGVyQnVmZmVyKCk6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5vZGUgYXMgYSBib25lIHdpdGggaXRzIGJpbmQgaW52ZXJzZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZEJvbmUoX2JvbmU6IE5vZGUsIF9tdHhCaW5kSW52ZXJzZTogTWF0cml4NHg0ID0gX2JvbmUubXR4V29ybGRJbnZlcnNlLmNsb25lKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuYm9uZXMucHVzaChfYm9uZSk7XHJcbiAgICAgIHRoaXMubXR4QmluZEludmVyc2VzLnB1c2goX210eEJpbmRJbnZlcnNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGJvbmUgaW4gdGhlIGJvbmVzIGFycmF5IHdoaWNoIGhhcyB0aGUgZ2l2ZW4gbmFtZSwgYW5kIC0xIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGluZGV4T2YoX25hbWU6IHN0cmluZyk6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgZ2l2ZW4gYm9uZSBub2RlIGluIHRoZSBib25lIGFycmF5LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGluZGV4T2YoX25vZGU6IE5vZGUpOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgaW5kZXhPZihfbmFtZTogc3RyaW5nIHwgTm9kZSk6IG51bWJlciB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9uYW1lKSA9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmJvbmVzLmZpbmRJbmRleCgoX2JvbmU6IE5vZGUpID0+IF9ib25lLm5hbWUgPT0gX25hbWUpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9uZXMuaW5kZXhPZihfbmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBib25lIG1hdHJpY2VzIHRvIGJlIHVzZWQgYnkgdGhlIHNoYWRlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlKCk6IHZvaWQge1xyXG4gICAgICBmb3IgKGNvbnN0IG10eEJvbmUgb2YgdGhpcy5tdHhCb25lcylcclxuICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhCb25lKTtcclxuICAgICAgdGhpcy5tdHhCb25lcy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBQZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNZWFzdXJlKFwiQ29tcG9uZW50U2tlbGV0b24udXBkYXRlIG10eFdvcmxkICogbXR4QmluZEludmVyc2VzXCIpO1xyXG4gICAgICAgIGxldCBtdHhCb25lOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUFJPRFVDVCh0aGlzLmJvbmVzW2ldLm10eFdvcmxkLCB0aGlzLm10eEJpbmRJbnZlcnNlc1tpXSk7XHJcbiAgICAgICAgUGVyZm9ybWFuY2VNb25pdG9yLmVuZE1lYXN1cmUoXCJDb21wb25lbnRTa2VsZXRvbi51cGRhdGUgbXR4V29ybGQgKiBtdHhCaW5kSW52ZXJzZXNcIik7XHJcbiAgICAgICAgdGhpcy5tdHhCb25lcy5wdXNoKG10eEJvbmUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIHBvc2Ugb2YgdGhpcyBza2VsZXRvbiB0byB0aGUgZGVmYXVsdCBwb3NlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXNldFBvc2UoKTogdm9pZCB7IC8vIFRPRE86IHRlc3QgdGhpc1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB0aGlzLmJvbmVzW2ldLm10eExvY2FsLmNvcHkoTWF0cml4NHg0LklOVkVSU0UodGhpcy5tdHhCaW5kSW52ZXJzZXNbaV0pKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBjb25zdCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge307XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5ib25lcyA9IHRoaXMuYm9uZXMubWFwKF9ib25lID0+IE5vZGUuUEFUSF9GUk9NX1RPKHRoaXMsIF9ib25lKSk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24ubXR4QmluZEludmVyc2VzID0gU2VyaWFsaXplci5zZXJpYWxpemVBcnJheShNYXRyaXg0eDQsIHRoaXMubXR4QmluZEludmVyc2VzKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxDb21wb25lbnRTa2VsZXRvbj4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcblxyXG4gICAgICBjb25zdCBobmROb2RlRGVzZXJpYWxpemVkOiBFdmVudExpc3RlbmVyVW5pZmllZCA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLmJvbmVzID0gX3NlcmlhbGl6YXRpb24uYm9uZXMubWFwKChfcGF0aDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICBsZXQgYm9uZTogTm9kZSA9IE5vZGUuRklORCh0aGlzLCBfcGF0aCk7XHJcbiAgICAgICAgICBpZiAoIWJvbmUpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtOb2RlLm5hbWV9IFwiJHt0aGlzLm5vZGUubmFtZX1cIiAke0NvbXBvbmVudFNrZWxldG9uLm5hbWV9OiBDb3VsZCBub3QgZmluZCBib25lICR7X3BhdGh9YCk7XHJcbiAgICAgICAgICByZXR1cm4gYm9uZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQsIGhuZE5vZGVEZXNlcmlhbGl6ZWQpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQsIGhuZE5vZGVEZXNlcmlhbGl6ZWQpO1xyXG5cclxuICAgICAgdGhpcy5tdHhCaW5kSW52ZXJzZXMgPSA8TWF0cml4NHg0W10+YXdhaXQgU2VyaWFsaXplci5kZXNlcmlhbGl6ZUFycmF5KF9zZXJpYWxpemF0aW9uLm10eEJpbmRJbnZlcnNlcyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWcvUGVyZm9ybWFuY2UudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Zy9EZWJ1Z1RhcmdldC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnL0RlYnVnLnRzXCIvPlxyXG4vLyAvIDxyZWZlcmVuY2UgcGF0aD1cIlRpbWUvVGltZS50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkV2ZW50L0V2ZW50LnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU2VyaWFsaXphdGlvbi9NdXRhYmxlLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU2VyaWFsaXphdGlvbi9TZXJpYWxpemVyLnRzXCIvPiBcclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlci9SZW5kZXJXZWJHTC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlci9SZW5kZXJJbmplY3RvclRleHR1cmUudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJHcmFwaC9Ob2RlLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ29tcG9uZW50L0NvbXBvbmVudC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlJlY3ljbGUvUmVjeWNhYmxlQXJyYXkudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJQaHlzaWNzL0hlbHBlcnNQaHlzaWNzLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUGh5c2ljcy9Kb2ludC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlBoeXNpY3MvSm9pbnRBeGlhbC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlNlcmlhbGl6YXRpb24vUHJvamVjdC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlRleHR1cmUvVGV4dHVyZS50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIk1lc2gvTWVzaC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIk1hdGVyaWFsL01hdGVyaWFsLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUGFydGljbGVTeXN0ZW0vUGFydGljbGVTeXN0ZW0udHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDb21wb25lbnQvQ29tcG9uZW50U2tlbGV0b24udHNcIi8+XHJcblxyXG5cclxuLy9nbG9iYWwgZnVuY3Rpb25zXHJcbmZ1bmN0aW9uIGlmTnVtYmVyKF9jaGVjazogbnVtYmVyLCBfZGVmYXVsdDogbnVtYmVyKTogbnVtYmVyIHtcclxuICByZXR1cm4gdHlwZW9mIF9jaGVjayA9PSBcInVuZGVmaW5lZFwiID8gX2RlZmF1bHQgOiBfY2hlY2s7XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBIb2xkcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgQW5pbWF0aW9uU3RydWN0dXJlIHRoYXQgdGhlIEFuaW1hdGlvbiB1c2VzIHRvIG1hcCB0aGUgU2VxdWVuY2VzIHRvIHRoZSBBdHRyaWJ1dGVzLlxyXG4gICAqIEJ1aWx0IG91dCBvZiBhIHtAbGluayBOb2RlfSdzIHNlcmlhbHNhdGlvbiwgaXQgc3dhcHMgdGhlIHZhbHVlcyB3aXRoIHtAbGluayBBbmltYXRpb25TZXF1ZW5jZX1zLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uU3RydWN0dXJlIHtcclxuICAgIFthdHRyaWJ1dGU6IHN0cmluZ106IEFuaW1hdGlvblN0cnVjdHVyZVtdIHwgQW5pbWF0aW9uU3RydWN0dXJlIHwgQW5pbWF0aW9uU2VxdWVuY2U7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvblNlcXVlbmNlVmVjdG9yMyBleHRlbmRzIEFuaW1hdGlvblN0cnVjdHVyZSB7XHJcbiAgICB4PzogQW5pbWF0aW9uU2VxdWVuY2U7XHJcbiAgICB5PzogQW5pbWF0aW9uU2VxdWVuY2U7XHJcbiAgICB6PzogQW5pbWF0aW9uU2VxdWVuY2U7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvblNlcXVlbmNlVmVjdG9yNCBleHRlbmRzIEFuaW1hdGlvblN0cnVjdHVyZSB7XHJcbiAgICB4PzogQW5pbWF0aW9uU2VxdWVuY2U7XHJcbiAgICB5PzogQW5pbWF0aW9uU2VxdWVuY2U7XHJcbiAgICB6PzogQW5pbWF0aW9uU2VxdWVuY2U7XHJcbiAgICB3PzogQW5pbWF0aW9uU2VxdWVuY2U7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvblNlcXVlbmNlTWF0cml4NHg0IGV4dGVuZHMgQW5pbWF0aW9uU3RydWN0dXJlIHtcclxuICAgIHJvdGF0aW9uPzogQW5pbWF0aW9uU2VxdWVuY2VWZWN0b3IzIHwgQW5pbWF0aW9uU2VxdWVuY2VWZWN0b3I0O1xyXG4gICAgc2NhbGU/OiBBbmltYXRpb25TZXF1ZW5jZVZlY3RvcjM7XHJcbiAgICB0cmFuc2xhdGlvbj86IEFuaW1hdGlvblNlcXVlbmNlVmVjdG9yMztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogQW4gYXNzb2NpYXRpdmUgYXJyYXkgbWFwcGluZyBuYW1lcyBvZiBsYWJsZXMgdG8gdGltZXN0YW1wcy5cclxuICAqIExhYmVscyBuZWVkIHRvIGJlIHVuaXF1ZSBwZXIgQW5pbWF0aW9uLlxyXG4gICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBbmltYXRpb25MYWJlbCB7XHJcbiAgICBbbmFtZTogc3RyaW5nXTogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgKiBIb2xkcyBpbmZvcm1hdGlvbiBhYm91dCBBbmltYXRpb24gRXZlbnQgVHJpZ2dlcnNcclxuICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyIHtcclxuICAgIFtuYW1lOiBzdHJpbmddOiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnRlcm5hbGx5IHVzZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSB2YXJpb3VzIGdlbmVyYXRlZCBzdHJ1Y3R1cmVzIGFuZCBldmVudHMuXHJcbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGVudW0gQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFIHtcclxuICAgIC8qKkRlZmF1bHQ6IGZvcndhcmQsIGNvbnRpbm91cyAqL1xyXG4gICAgTk9STUFMLFxyXG4gICAgLyoqYmFja3dhcmQsIGNvbnRpbm91cyAqL1xyXG4gICAgUkVWRVJTRSxcclxuICAgIC8qKmZvcndhcmQsIHJhc3RlcmVkICovXHJcbiAgICBSQVNURVJFRCxcclxuICAgIC8qKmJhY2t3YXJkLCByYXN0ZXJlZCAqL1xyXG4gICAgUkFTVEVSRURSRVZFUlNFXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIb2xkcyBkaWZmZXJlbnQgcGxheW1vZGVzIHRoZSBhbmltYXRpb24gdXNlcyB0byBwbGF5IGJhY2sgaXRzIGFuaW1hdGlvbi5cclxuICAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gQU5JTUFUSU9OX1BMQVlNT0RFIHtcclxuICAgIC8qKlBsYXlzIGFuaW1hdGlvbiBpbiBhIGxvb3A6IGl0IHJlc3RhcnRzIG9uY2UgaXQgaGl0IHRoZSBlbmQuKi9cclxuICAgIExPT1AgPSBcImxvb3BcIixcclxuICAgIC8qKlBsYXlzIGFuaW1hdGlvbiBvbmNlIGFuZCBzdG9wcyBhdCB0aGUgbGFzdCBrZXkvZnJhbWUqL1xyXG4gICAgUExBWV9PTkNFID0gXCJwbGF5T25jZVwiLFxyXG4gICAgLyoqUGxheXMgYW5pbWF0aW9uIG9uY2UgYW5kIHN0b3BzIG9uIHRoZSBmaXJzdCBrZXkvZnJhbWUgKi9cclxuICAgIFBMQVlfT05DRV9SRVNFVCA9IFwicGxheU9uY2VSZXNldFwiLFxyXG4gICAgLyoqUGxheXMgYW5pbWF0aW9uIGxpa2UgTE9PUCwgYnV0IGJhY2t3YXJkcy4qL1xyXG4gICAgUkVWRVJTRV9MT09QID0gXCJyZXZlcnNlTG9vcFwiLFxyXG4gICAgLyoqQ2F1c2VzIHRoZSBhbmltYXRpb24gbm90IHRvIHBsYXkgYXQgYWxsLiBVc2VmdWwgZm9yIGp1bXBpbmcgdG8gdmFyaW91cyBwb3NpdGlvbnMgaW4gdGhlIGFuaW1hdGlvbiB3aXRob3V0IHByb2NlZWRpbmcgaW4gdGhlIGFuaW1hdGlvbi4qL1xyXG4gICAgU1RPUCA9IFwic3RvcFwiXHJcbiAgICAvL1RPRE86IGFkZCBhbiBJTkhFUklUIGFuZCBhIFBJTkdQT05HIG1vZGVcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIEFOSU1BVElPTl9RVUFOVElaQVRJT04ge1xyXG4gICAgLy9UT0RPOiBhZGQgYW4gaW4tZGVwdGggZGVzY3JpcHRpb24gb2Ygd2hhdCBoYXBwZW5zIHRvIHRoZSBhbmltYXRpb24gKGFuZCBldmVudHMpIGRlcGVuZGluZyBvbiB0aGUgcXVhbnRpemF0aW9uLiBVc2UgR3JhcGhzIHRvIGV4cGxhaW4uXHJcbiAgICAvKipDYWxjdWxhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgYW5pbWF0aW9uIGF0IHRoZSBleGFjdCBwb3NpdGlvbiBvZiB0aW1lLiBJZ25vcmVzIEZQUyB2YWx1ZSBvZiBhbmltYXRpb24uKi9cclxuICAgIENPTlRJTk9VUyA9IFwiY29udGlub3VzXCIsXHJcbiAgICAvKipMaW1pdHMgdGhlIGNhbGN1bGF0aW9uIG9mIHRoZSBzdGF0ZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHRoZSBGUFMgdmFsdWUgb2YgdGhlIGFuaW1hdGlvbi4gU2tpcHMgZnJhbWVzIGlmIG5lZWRlZC4qL1xyXG4gICAgRElTQ1JFVEUgPSBcImRpc2NyZXRlXCIsXHJcbiAgICAvKiogQWR2YW5jZXMgdGhlIHRpbWUgZWFjaCBmcmFtZSBhY2NvcmRpbmcgdG8gdGhlIEZQUyB2YWx1ZSBvZiB0aGUgYW5pbWF0aW9uLCBpZ25vcmluZyB0aGUgYWN0dWFsIGR1cmF0aW9uIG9mIHRoZSBmcmFtZXMuIERvZXNuJ3Qgc2tpcCBhbnkgZnJhbWVzLiovXHJcbiAgICBGUkFNRVMgPSBcImZyYW1lc1wiXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgYW5kIGNvbnRyb2xzIGFuZCBhbmltYXRpb24gYnkgeWllbGRpbmcgbXV0YXRvcnMgXHJcbiAgICogYWNjb3JkaW5nIHRvIHRoZSBzdG9yZWQge0BsaW5rIEFuaW1hdGlvblN0cnVjdHVyZX0gYW5kIHtAbGluayBBbmltYXRpb25TZXF1ZW5jZX1zXHJcbiAgICogQXBwbGllZCB0byBhIHtAbGluayBOb2RlfSBkaXJlY3RseSB2aWEgc2NyaXB0IG9yIHtAbGluayBDb21wb25lbnRBbmltYXRpb259LlxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIxMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyM1xyXG4gICAqL1xyXG4gIEBTZXJpYWxpemFibGVSZXNvdXJjZS5yZWdpc3RlclxyXG4gIGV4cG9ydCBjbGFzcyBBbmltYXRpb24gZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgLy8gLyoqIHJlZmVycyBiYWNrIHRvIHRoaXMgY2xhc3MgZnJvbSBhbnkgc3ViY2xhc3MgZS5nLiBpbiBvcmRlciB0byBmaW5kIGNvbXBhdGlibGUgb3RoZXIgcmVzb3VyY2VzKi9cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgYmFzZUNsYXNzOiB0eXBlb2YgQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xyXG4gICAgLy8gLyoqIGxpc3Qgb2YgYWxsIHRoZSBzdWJjbGFzc2VzIGRlcml2ZWQgZnJvbSB0aGlzIGNsYXNzLCBpZiB0aGV5IHJlZ2lzdGVyZWQgcHJvcGVybHkqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBzdWJjbGFzc2VzOiB0eXBlb2YgQW5pbWF0aW9uW10gPSBbXTtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBBbmltYXRpb24ucmVnaXN0ZXJTdWJjbGFzcyhBbmltYXRpb24pO1xyXG4gICAgcHVibGljIGlkUmVzb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgdG90YWxUaW1lOiBudW1iZXIgPSAwOyAvLyBXaHkgaXNuJ3QgdGhpcyBjYWxsZWQgZHVyYXRpb24gb3IgbGVuZ3RoP1xyXG4gICAgcHVibGljIGxhYmVsczogQW5pbWF0aW9uTGFiZWwgPSB7fTsgLy8gYSBsYWJlbCBtYXJrcyBhIHNwZWNpZmljIHRpbWUgdG8gY29udmVuaWVudGx5IGp1bXAgdG8gdXNpbmcgYSB0ZXh0IGlkZW50aWZpZXJcclxuICAgIC8vIHN0ZXBzUGVyU2Vjb25kOiBudW1iZXIgPSAxMDtcclxuICAgIHB1YmxpYyBhbmltYXRpb25TdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZTsgLy8gVE9ETzogaWYgc2V0IHRoZSBjYWNoZSBuZWVkcyB0byBiZSBhZGp1c3RlZCAoYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZClcclxuICAgIHB1YmxpYyBldmVudHM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciA9IHt9O1xyXG4gICAgcHJvdGVjdGVkIGZyYW1lc1BlclNlY29uZDogbnVtYmVyID0gNjA7IC8vIFRPRE86IGNoYW5nZSB0aGlzIGFuZCBpdHMgYWNjZXNzb3JzIHRvICNmcmFtZXNQZXJTZWNvbmQ/XHJcblxyXG4gICAgLy8gcHJvY2Vzc2VkIGV2ZW50bGlzdCBhbmQgYW5pbWF0aW9uIHN0cnVjdXRyZXMgZm9yIHBsYXliYWNrLlxyXG4gICAgcHJpdmF0ZSBldmVudHNQcm9jZXNzZWQ6IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcj4gPSBuZXcgTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyPigpO1xyXG4gICAgI2FuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQ6IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvblN0cnVjdHVyZT4gPSBuZXcgTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uU3RydWN0dXJlPigpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gQW5pbWF0aW9uLm5hbWUsIF9hbmltU3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSB7fSwgX2ZwczogbnVtYmVyID0gNjApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlID0gX2FuaW1TdHJ1Y3R1cmU7XHJcbiAgICAgIHRoaXMuI2FuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQuc2V0KEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUwsIF9hbmltU3RydWN0dXJlKTtcclxuICAgICAgdGhpcy5mcmFtZXNQZXJTZWNvbmQgPSBfZnBzO1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsVGltZSgpO1xyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIE92ZXJyaWRlIHRoZSBnaXZlbiBiYXNlIG11dGF0b3Igd2l0aCB0aGUgZ2l2ZW4gb3ZlcnJpZGUgbXV0YXRvciB1c2luZyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHRoZSB2YWx1ZXMgd2l0aCB0aGUgZ2l2ZW4gd2VpZ2h0LlxyXG4gICAgICogU2V0IHRoZSBpbnRlcnNlY3QgZmxhZyB0byBvbmx5IGluY2x1ZGUgcHJvcGVydGllcyBpbiB0aGUgcmVzdWx0IHRoYXQgZXhpc3QgaW4gYm90aCBvZiB0aGUgZ2l2ZW4gbXV0YXRvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYmxlbmRPdmVycmlkZShfYmFzZTogTXV0YXRvciwgX292ZXJyaWRlOiBNdXRhdG9yLCBfd2VpZ2h0OiBudW1iZXIsIF9pbnRlcnNlY3Q6IGJvb2xlYW4gPSBmYWxzZSk6IE11dGF0b3Ige1xyXG4gICAgICByZXR1cm4gQW5pbWF0aW9uLmJsZW5kUmVjdXJzaXZlKF9iYXNlLCBfb3ZlcnJpZGUsIDEgLSBfd2VpZ2h0LCBfd2VpZ2h0LCBfaW50ZXJzZWN0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCB0aGUgZ2l2ZW4gYWRkaXRpdmUgbXV0YXRvciB0byB0aGUgZ2l2ZW4gYmFzZSBtdXRhdG9yLiBUaGUgdmFsdWVzIG9mIHRoZSBhZGRpdGl2ZSBtdXRhdG9yIHdpbGwgYmUgbXVsdGlwbGllZCBieSB0aGUgZ2l2ZW4gd2VpZ2h0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGJsZW5kQWRkaXRpdmUoX2Jhc2U6IE11dGF0b3IsIF9hZGQ6IE11dGF0b3IsIF93ZWlnaHQ6IG51bWJlcik6IE11dGF0b3Ige1xyXG4gICAgICByZXR1cm4gQW5pbWF0aW9uLmJsZW5kUmVjdXJzaXZlKF9iYXNlLCBfYWRkLCAxLCBfd2VpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJsZW5kIHRoZSB0d28gZ2l2ZW4gbXV0YXRvcnMgdG9nZXRoZXIsIHVzaW5nIHRoZSBnaXZlbiB3ZWlnaHRzIHRvIGRldGVybWluZSB0aGUgaW5mbHVlbmNlIG9mIGVhY2guIFxyXG4gICAgICogVGhlIHJlc3VsdGluZyBtdXRhdG9yIHdpbGwgY29udGFpbiBhbGwgcHJvcGVydGllcyBvZiB0aGUgYmFzZSBtdXRhdG9yLCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBibGVuZCBtdXRhdG9yIGJsZW5kZWQgaW4uXHJcbiAgICAgKiBCbGVuZCBtdXRhdG9yIHByb3BlcnRpZXMgdGhhdCBkb24ndCBleGlzdCBpbiB0aGUgYmFzZSBtdXRhdG9yIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHJlc3VsdCBtdXRhdG9yLlxyXG4gICAgICogU2V0IHRoZSBpbnRlcnNlY3QgZmxhZyB0byBvbmx5IGluY2x1ZGUgcHJvcGVydGllcyBpbiB0aGUgcmVzdWx0IHRoYXQgZXhpc3QgaW4gYm90aCBvZiB0aGUgZ2l2ZW4gbXV0YXRvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYmxlbmRSZWN1cnNpdmUoX2Jhc2U6IE11dGF0b3IsIF9ibGVuZDogTXV0YXRvciwgX3dlaWdodEJhc2U6IG51bWJlciwgX3dlaWdodEJsZW5kOiBudW1iZXIsIF9pbnRlcnNlY3Q6IGJvb2xlYW4gPSBmYWxzZSk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IF9pbnRlcnNlY3QgPyB7fSA6IHsgLi4uX2Jhc2UgfTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIF9ibGVuZCkge1xyXG4gICAgICAgIGlmIChfaW50ZXJzZWN0ICYmIF9iYXNlW2tleV0gPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgX2JsZW5kW2tleV0gPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgbXV0YXRvcltrZXldID0gKF9iYXNlW2tleV0gPz8gMCkgKiBfd2VpZ2h0QmFzZSArIF9ibGVuZFtrZXldICogX3dlaWdodEJsZW5kO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIF9iYXNlW2tleV0gPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgbGV0IGJhc2U6IE11dGF0b3IgPSBfYmFzZVtrZXldO1xyXG4gICAgICAgICAgbGV0IGJsZW5kOiBNdXRhdG9yID0gX2JsZW5kW2tleV07XHJcbiAgICAgICAgICBpZiAoYmFzZS54ICE9IHVuZGVmaW5lZCAmJiBiYXNlLnkgIT0gdW5kZWZpbmVkICYmIGJhc2UueiAhPSB1bmRlZmluZWQgJiYgYmFzZS53ICE9IHVuZGVmaW5lZCAmJiBRdWF0ZXJuaW9uLkRPVCg8UXVhdGVybmlvbj5iYXNlLCA8UXVhdGVybmlvbj5ibGVuZCkgPCAwKVxyXG4gICAgICAgICAgICBRdWF0ZXJuaW9uLm5lZ2F0ZSg8UXVhdGVybmlvbj5iYXNlKTsgLy8gVE9ETzogZWxpbWluYXRlIHRoaXMgc2lkZSBlZmZlY3RcclxuICAgICAgICAgIG11dGF0b3Jba2V5XSA9IHRoaXMuYmxlbmRSZWN1cnNpdmUoYmFzZSwgYmxlbmQsIF93ZWlnaHRCYXNlLCBfd2VpZ2h0QmxlbmQsIF9pbnRlcnNlY3QpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIF9ibGVuZFtrZXldID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICBtdXRhdG9yW2tleV0gPSB0aGlzLmJsZW5kUmVjdXJzaXZlKHt9LCBfYmxlbmRba2V5XSwgX3dlaWdodEJhc2UsIF93ZWlnaHRCbGVuZCwgX2ludGVyc2VjdCk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViQ2xhc3M6IHR5cGVvZiBBbmltYXRpb24pOiBudW1iZXIgeyByZXR1cm4gQW5pbWF0aW9uLnN1YmNsYXNzZXMucHVzaChfc3ViQ2xhc3MpIC0gMTsgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgZ2V0TGFiZWxzKCk6IEVudW1lcmF0b3Ige1xyXG4gICAgICAvL1RPRE86IHRoaXMgYWN0dWFsbHkgbmVlZHMgdGVzdGluZ1xyXG4gICAgICBsZXQgZW46IEVudW1lcmF0b3IgPSBuZXcgRW51bWVyYXRvcih0aGlzLmxhYmVscyk7XHJcbiAgICAgIHJldHVybiBlbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGZwcygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5mcmFtZXNQZXJTZWNvbmQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBmcHMoX2ZwczogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZnJhbWVzUGVyU2Vjb25kID0gX2ZwcztcclxuICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQuY2xlYXIoKTtcclxuICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciB0aGlzIGFuaW1hdGlvbnMgY2FjaGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbGVhckNhY2hlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNhbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYW5kIHJldHVybnMgYSB7QGxpbmsgTXV0YXRvcn0gd2l0aCB0aGUgaW5mb3JtYXRpb24gdG8gYXBwbHkgdG8gdGhlIHtAbGluayBOb2RlfSB0byBhbmltYXRlXHJcbiAgICAgKiBpbiB0aGUgc3RhdGUgdGhlIGFuaW1hdGlvbiBpcyBpbiBhdCB0aGUgZ2l2ZW4gdGltZSwgZGlyZWN0aW9uIGFuZCBxdWFudGl6YXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFN0YXRlKF90aW1lOiBudW1iZXIsIF9kaXJlY3Rpb246IG51bWJlciwgX3F1YW50aXphdGlvbjogQU5JTUFUSU9OX1FVQU5USVpBVElPTik6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbTogTXV0YXRvciA9IHt9O1xyXG4gICAgICBsZXQgYW5pbWF0aW9uU3RydWN0dXJlOiBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEU7XHJcblxyXG4gICAgICBpZiAoX3F1YW50aXphdGlvbiA9PSBBTklNQVRJT05fUVVBTlRJWkFUSU9OLkNPTlRJTk9VUylcclxuICAgICAgICBhbmltYXRpb25TdHJ1Y3R1cmUgPSBfZGlyZWN0aW9uIDwgMCA/IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFIDogQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLk5PUk1BTDtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGFuaW1hdGlvblN0cnVjdHVyZSA9IF9kaXJlY3Rpb24gPCAwID8gQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEUkVWRVJTRSA6IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRDtcclxuXHJcbiAgICAgIG0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTXV0YXRvcih0aGlzLmdldFByb2Nlc3NlZEFuaW1hdGlvblN0cnVjdHVyZShhbmltYXRpb25TdHJ1Y3R1cmUpLCBfdGltZSk7XHJcbiAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIG5hbWVzIG9mIHRoZSBldmVudHMgdGhlIHtAbGluayBDb21wb25lbnRBbmltYXRpb259IG5lZWRzIHRvIGZpcmUgYmV0d2VlbiBfbWluIGFuZCBfbWF4IGlucHV0IHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSBfZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdGhlIGFuaW1hdGlvbiBpcyBzdXBwb3NlZCB0byBydW4gaW4uID4wID09IGZvcndhcmQsIDAgPT0gc3RvcCwgPDAgPT0gYmFja3dhcmRzXHJcbiAgICAgKiBAcmV0dXJucyBhIGxpc3Qgb2Ygc3RyaW5ncyB3aXRoIHRoZSBuYW1lcyBvZiB0aGUgY3VzdG9tIGV2ZW50cyB0byBmaXJlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RXZlbnRzVG9GaXJlKF9taW46IG51bWJlciwgX21heDogbnVtYmVyLCBfcXVhbnRpemF0aW9uOiBBTklNQVRJT05fUVVBTlRJWkFUSU9OLCBfZGlyZWN0aW9uOiBudW1iZXIpOiBzdHJpbmdbXSB7XHJcbiAgICAgIGxldCBldmVudExpc3Q6IHN0cmluZ1tdID0gW107XHJcbiAgICAgIGxldCBtaW5TZWN0aW9uOiBudW1iZXIgPSBNYXRoLmZsb29yKF9taW4gLyB0aGlzLnRvdGFsVGltZSk7XHJcbiAgICAgIGxldCBtYXhTZWN0aW9uOiBudW1iZXIgPSBNYXRoLmZsb29yKF9tYXggLyB0aGlzLnRvdGFsVGltZSk7XHJcbiAgICAgIF9taW4gPSBfbWluICUgdGhpcy50b3RhbFRpbWU7XHJcbiAgICAgIF9tYXggPSBfbWF4ICUgdGhpcy50b3RhbFRpbWU7XHJcblxyXG4gICAgICB3aGlsZSAobWluU2VjdGlvbiA8PSBtYXhTZWN0aW9uKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50VHJpZ2dlcnM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciA9IHRoaXMuZ2V0Q29ycmVjdEV2ZW50TGlzdChfZGlyZWN0aW9uLCBfcXVhbnRpemF0aW9uKTtcclxuICAgICAgICBpZiAobWluU2VjdGlvbiA9PSBtYXhTZWN0aW9uKSB7XHJcbiAgICAgICAgICBldmVudExpc3QgPSBldmVudExpc3QuY29uY2F0KHRoaXMuY2hlY2tFdmVudHNCZXR3ZWVuKGV2ZW50VHJpZ2dlcnMsIF9taW4sIF9tYXgpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZXZlbnRMaXN0ID0gZXZlbnRMaXN0LmNvbmNhdCh0aGlzLmNoZWNrRXZlbnRzQmV0d2VlbihldmVudFRyaWdnZXJzLCBfbWluLCB0aGlzLnRvdGFsVGltZSkpO1xyXG4gICAgICAgICAgX21pbiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1pblNlY3Rpb24rKztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGV2ZW50TGlzdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gRXZlbnQgdG8gdGhlIExpc3Qgb2YgZXZlbnRzLlxyXG4gICAgICogQHBhcmFtIF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCAobmVlZHMgdG8gYmUgdW5pcXVlIHBlciBBbmltYXRpb24pLlxyXG4gICAgICogQHBhcmFtIF90aW1lIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGV2ZW50IChpbiBtaWxsaXNlY29uZHMpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0RXZlbnQoX25hbWU6IHN0cmluZywgX3RpbWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmV2ZW50c1tfbmFtZV0gPSBfdGltZTtcclxuICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGV2ZW50IHdpdGggdGhlIGdpdmVuIG5hbWUgZnJvbSB0aGUgbGlzdCBvZiBldmVudHMuXHJcbiAgICAgKiBAcGFyYW0gX25hbWUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlRXZlbnQoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNbX25hbWVdO1xyXG4gICAgICB0aGlzLmV2ZW50c1Byb2Nlc3NlZC5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIChSZS0pQ2FsY3VsYXRlIHRoZSB0b3RhbCB0aW1lIG9mIHRoZSBBbmltYXRpb24uIENhbGN1bGF0aW9uLWhlYXZ5LCB1c2Ugb25seSBpZiBhY3R1YWxseSBuZWVkZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjYWxjdWxhdGVUb3RhbFRpbWUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudG90YWxUaW1lID0gMDtcclxuICAgICAgdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvclRpbWUodGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUpO1xyXG4gICAgICAvLyBpZiAodGhpcy50b3RhbFRpbWUgPT0gMCkgLy8gYW5pbWF0aW9ucyB3aXRoIG9uZSBrZXlmcmFtZSBuZWVkIGEgdG90YWwgdGltZSAhPSAwIHRvIHdvcmtcclxuICAgICAgLy8gICB0aGlzLnRvdGFsVGltZSA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0aW1lIHRvIHVzZSBmb3IgYW5pbWF0aW9uIHNhbXBsaW5nIHdoZW4gYXBwbHlpbmcgYSBwbGF5bW9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TW9kYWxUaW1lKF90aW1lOiBudW1iZXIsIF9wbGF5bW9kZTogQU5JTUFUSU9OX1BMQVlNT0RFLCBfdGltZVN0b3A6IG51bWJlciA9IF90aW1lKTogbnVtYmVyIHtcclxuICAgICAgc3dpdGNoIChfcGxheW1vZGUpIHtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5TVE9QOlxyXG4gICAgICAgICAgLy8gcmV0dXJuIHRoaXMubG9jYWxUaW1lLmdldE9mZnNldCgpO1xyXG4gICAgICAgICAgcmV0dXJuIF90aW1lU3RvcDtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5QTEFZX09OQ0U6XHJcbiAgICAgICAgICBpZiAoX3RpbWUgPj0gdGhpcy50b3RhbFRpbWUpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZSAtIDAuMDE7ICAgICAvL1RPRE86IHRoaXMgbWlnaHQgY2F1c2Ugc29tZSBpc3N1ZXNcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5QTEFZX09OQ0VfUkVTRVQ6XHJcbiAgICAgICAgICBpZiAoX3RpbWUgPj0gdGhpcy50b3RhbFRpbWUpXHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJldHVybiBfdGltZVN0b3AgaW5zdGVhZD9cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxUaW1lICsgMC4wMTsgICAgIC8vVE9ETzogdGhpcyBtaWdodCBjYXVzZSBzb21lIGlzc3Vlc1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBfdGltZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIGRpcmVjdGlvbiB0aGUgYW5pbWF0aW9uIHNob3VsZCBjdXJyZW50bHkgYmUgcGxheWluZyBpbi5cclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgdGltZSBhdCB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGRpcmVjdGlvblxyXG4gICAgICogQHJldHVybnMgMSBpZiBmb3J3YXJkLCAwIGlmIHN0b3AsIC0xIGlmIGJhY2t3YXJkc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2FsY3VsYXRlRGlyZWN0aW9uKF90aW1lOiBudW1iZXIsIF9wbGF5bW9kZTogQU5JTUFUSU9OX1BMQVlNT0RFKTogbnVtYmVyIHtcclxuICAgICAgc3dpdGNoIChfcGxheW1vZGUpIHtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5TVE9QOlxyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgLy8gY2FzZSBBTklNQVRJT05fUExBWU1PREUuUElOR1BPTkc6XHJcbiAgICAgICAgLy8gICBpZiAoTWF0aC5mbG9vcihfdGltZSAvIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZSkgJSAyID09IDApXHJcbiAgICAgICAgLy8gICAgIHJldHVybiAxO1xyXG4gICAgICAgIC8vICAgZWxzZVxyXG4gICAgICAgIC8vICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuUkVWRVJTRV9MT09QOlxyXG4gICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlBMQVlfT05DRTpcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5QTEFZX09OQ0VfUkVTRVQ6XHJcbiAgICAgICAgICBpZiAoX3RpbWUgPj0gdGhpcy50b3RhbFRpbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIHRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgczogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2UsXHJcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIGxhYmVsczoge30sXHJcbiAgICAgICAgZXZlbnRzOiB7fSxcclxuICAgICAgICBmcmFtZXNQZXJTZWNvbmQ6IHRoaXMuZnJhbWVzUGVyU2Vjb25kXHJcbiAgICAgICAgLy8gc3BzOiB0aGlzLnN0ZXBzUGVyU2Vjb25kXHJcbiAgICAgIH07XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5sYWJlbHMpIHtcclxuICAgICAgICBzLmxhYmVsc1tuYW1lXSA9IHRoaXMubGFiZWxzW25hbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5ldmVudHMpIHtcclxuICAgICAgICBzLmV2ZW50c1tuYW1lXSA9IHRoaXMuZXZlbnRzW25hbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIHMuYW5pbWF0aW9uU3RydWN0dXJlID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvclNlcmlhbGl6YXRpb24odGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUpO1xyXG4gICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMsIF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xyXG4gICAgICB0aGlzLmZyYW1lc1BlclNlY29uZCA9IF9zZXJpYWxpemF0aW9uLmZyYW1lc1BlclNlY29uZDtcclxuICAgICAgLy8gdGhpcy5zdGVwc1BlclNlY29uZCA9IF9zZXJpYWxpemF0aW9uLnNwcztcclxuICAgICAgdGhpcy5sYWJlbHMgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfc2VyaWFsaXphdGlvbi5sYWJlbHMpIHtcclxuICAgICAgICB0aGlzLmxhYmVsc1tuYW1lXSA9IF9zZXJpYWxpemF0aW9uLmxhYmVsc1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmV2ZW50cyA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIF9zZXJpYWxpemF0aW9uLmV2ZW50cykge1xyXG4gICAgICAgIHRoaXMuZXZlbnRzW25hbWVdID0gX3NlcmlhbGl6YXRpb24uZXZlbnRzW25hbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZXZlbnRzUHJvY2Vzc2VkID0gbmV3IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcj4oKTtcclxuXHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlID0gYXdhaXQgdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvckRlc2VyaWFsaXphdGlvbihfc2VyaWFsaXphdGlvbi5hbmltYXRpb25TdHJ1Y3R1cmUpO1xyXG5cclxuICAgICAgdGhpcy4jYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZCA9IG5ldyBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25TdHJ1Y3R1cmU+KCk7XHJcblxyXG4gICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsVGltZSgpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgIC8vICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnRvdGFsVGltZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIGFuIEFuaW1hdGlvblN0cnVjdHVyZSBhbmQgcmV0dXJucyB0aGUgU2VyaWFsaXphdGlvbiBvZiBzYWlkIFN0cnVjdHVyZS5cclxuICAgICAqIEBwYXJhbSBfc3RydWN0dXJlIFRoZSBBbmltYXRpb24gU3RydWN0dXJlIGF0IHRoZSBjdXJyZW50IGxldmVsIHRvIHRyYW5zZm9ybSBpbnRvIHRoZSBTZXJpYWxpemF0aW9uLlxyXG4gICAgICogQHJldHVybnMgdGhlIGZpbGxlZCBTZXJpYWxpemF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRyYXZlcnNlU3RydWN0dXJlRm9yU2VyaWFsaXphdGlvbihfc3RydWN0dXJlOiBPYmplY3QpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBfc3RydWN0dXJlKSB7XHJcbiAgICAgICAgbGV0IHN0cnVjdHVyZU9yU2VxdWVuY2U6IE9iamVjdCA9ICg8R2VuZXJhbD5fc3RydWN0dXJlKVtwcm9wZXJ0eV07XHJcbiAgICAgICAgaWYgKHN0cnVjdHVyZU9yU2VxdWVuY2UgaW5zdGFuY2VvZiBBbmltYXRpb25TZXF1ZW5jZSlcclxuICAgICAgICAgIHNlcmlhbGl6YXRpb25bcHJvcGVydHldID0gc3RydWN0dXJlT3JTZXF1ZW5jZS5zZXJpYWxpemUoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBzZXJpYWxpemF0aW9uW3Byb3BlcnR5XSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JTZXJpYWxpemF0aW9uKHN0cnVjdHVyZU9yU2VxdWVuY2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgYSBTZXJpYWxpemF0aW9uIHRvIGNyZWF0ZSBhIG5ldyBBbmltYXRpb25TdHJ1Y3R1cmUuXHJcbiAgICAgKiBAcGFyYW0gX3NlcmlhbGl6YXRpb24gVGhlIHNlcmlhbGl6YXRpb24gdG8gdHJhbnNmZXIgaW50byBhbiBBbmltYXRpb25TdHJ1Y3R1cmVcclxuICAgICAqIEByZXR1cm5zIHRoZSBuZXdseSBjcmVhdGVkIEFuaW1hdGlvblN0cnVjdHVyZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyB0cmF2ZXJzZVN0cnVjdHVyZUZvckRlc2VyaWFsaXphdGlvbihfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8QW5pbWF0aW9uU3RydWN0dXJlPiB7XHJcbiAgICAgIGxldCBzdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuIGluIF9zZXJpYWxpemF0aW9uKSB7XHJcbiAgICAgICAgaWYgKF9zZXJpYWxpemF0aW9uW25dLmFuaW1hdGlvblNlcXVlbmNlKSB7XHJcbiAgICAgICAgICBsZXQgYW5pbVNlcTogQW5pbWF0aW9uU2VxdWVuY2UgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcclxuICAgICAgICAgIHN0cnVjdHVyZVtuXSA9IDxBbmltYXRpb25TZXF1ZW5jZT4oYXdhaXQgYW5pbVNlcS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltuXSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHJ1Y3R1cmVbbl0gPSBhd2FpdCB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yRGVzZXJpYWxpemF0aW9uKF9zZXJpYWxpemF0aW9uW25dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHN0cnVjdHVyZTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgYW5kIHJldHVybnMgdGhlIGxpc3Qgb2YgZXZlbnRzIHRvIGJlIHVzZWQgd2l0aCB0aGVzZSBzZXR0aW5ncy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRDb3JyZWN0RXZlbnRMaXN0KF9kaXJlY3Rpb246IG51bWJlciwgX3F1YW50aXphdGlvbjogQU5JTUFUSU9OX1FVQU5USVpBVElPTik6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICAgIGlmIChfcXVhbnRpemF0aW9uICE9IEFOSU1BVElPTl9RVUFOVElaQVRJT04uRlJBTUVTKSB7XHJcbiAgICAgICAgaWYgKF9kaXJlY3Rpb24gPj0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoX2RpcmVjdGlvbiA+PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRFJFVkVSU0UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIGFuIHtAbGluayBBbmltYXRpb25TdHJ1Y3R1cmV9IGFuZCByZXR1cm5zIGEge0BsaW5rIE11dGF0b3J9IGRlc2NyaWJpbmcgdGhlIHN0YXRlIGF0IHRoZSBnaXZlbiB0aW1lXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JNdXRhdG9yKF9zdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSwgX3RpbWU6IG51bWJlcik6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbmV3TXV0YXRvcjogTXV0YXRvciA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuIGluIF9zdHJ1Y3R1cmUpIHtcclxuICAgICAgICBpZiAoX3N0cnVjdHVyZVtuXSBpbnN0YW5jZW9mIEFuaW1hdGlvblNlcXVlbmNlKSB7XHJcbiAgICAgICAgICBuZXdNdXRhdG9yW25dID0gKDxBbmltYXRpb25TZXF1ZW5jZT5fc3RydWN0dXJlW25dKS5ldmFsdWF0ZShfdGltZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld011dGF0b3Jbbl0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTXV0YXRvcig8QW5pbWF0aW9uU3RydWN0dXJlPl9zdHJ1Y3R1cmVbbl0sIF90aW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuZXdNdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSBjdXJyZW50IEFuaW1hdGlvblN0cmN1dHVyZSB0byBmaW5kIHRoZSB0b3RhbFRpbWUgb2YgdGhpcyBhbmltYXRpb24uXHJcbiAgICAgKiBAcGFyYW0gX3N0cnVjdHVyZSBUaGUgc3RydWN0dXJlIHRvIHRyYXZlcnNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JUaW1lKF9zdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBuIGluIF9zdHJ1Y3R1cmUpIHtcclxuICAgICAgICBpZiAoX3N0cnVjdHVyZVtuXSBpbnN0YW5jZW9mIEFuaW1hdGlvblNlcXVlbmNlKSB7XHJcbiAgICAgICAgICBsZXQgc2VxdWVuY2U6IEFuaW1hdGlvblNlcXVlbmNlID0gPEFuaW1hdGlvblNlcXVlbmNlPl9zdHJ1Y3R1cmVbbl07XHJcbiAgICAgICAgICBpZiAoc2VxdWVuY2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgc2VxdWVuY2VUaW1lOiBudW1iZXIgPSBzZXF1ZW5jZS5nZXRLZXkoc2VxdWVuY2UubGVuZ3RoIC0gMSkudGltZTtcclxuICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgPSBNYXRoLm1heChzZXF1ZW5jZVRpbWUsIHRoaXMudG90YWxUaW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvclRpbWUoPEFuaW1hdGlvblN0cnVjdHVyZT5fc3RydWN0dXJlW25dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGV4aXN0YW5jZSBvZiB0aGUgcmVxdWVzdGVkIHtAbGluayBBbmltYXRpb25TdHJjdXR1cmV9IGFuZCByZXR1cm5zIGl0LlxyXG4gICAgICogQHBhcmFtIF90eXBlIHRoZSB0eXBlIG9mIHRoZSBzdHJ1Y3R1cmUgdG8gZ2V0XHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVxdWVzdGVkIFtbQGxpbmsgQW5pbWF0aW9uU3RydWN0dXJlXV1cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRQcm9jZXNzZWRBbmltYXRpb25TdHJ1Y3R1cmUoX3R5cGU6IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSk6IEFuaW1hdGlvblN0cnVjdHVyZSB7XHJcbiAgICAgIGlmICghdGhpcy4jYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZC5oYXMoX3R5cGUpKSB7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuICAgICAgICBsZXQgYWU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoX3R5cGUpIHtcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLk5PUk1BTDpcclxuICAgICAgICAgICAgYWUgPSB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFOlxyXG4gICAgICAgICAgICBhZSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JOZXdTdHJ1Y3R1cmUodGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUsIHRoaXMuY2FsY3VsYXRlUmV2ZXJzZVNlcXVlbmNlLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEOlxyXG4gICAgICAgICAgICBhZSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JOZXdTdHJ1Y3R1cmUodGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUsIHRoaXMuY2FsY3VsYXRlUmFzdGVyZWRTZXF1ZW5jZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRFJFVkVSU0U6XHJcbiAgICAgICAgICAgIGFlID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck5ld1N0cnVjdHVyZSh0aGlzLmdldFByb2Nlc3NlZEFuaW1hdGlvblN0cnVjdHVyZShBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRSksIHRoaXMuY2FsY3VsYXRlUmFzdGVyZWRTZXF1ZW5jZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI2FuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQuc2V0KF90eXBlLCBhZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuI2FuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQuZ2V0KF90eXBlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGV4aXN0YW5jZSBvZiB0aGUgcmVxdWVzdGVkIHtAbGluayBBbmltYXRpb25FdmVudFRyaWdnZXJ9IGFuZCByZXR1cm5zIGl0LlxyXG4gICAgICogQHBhcmFtIF90eXBlIFRoZSB0eXBlIG9mIEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB0byBnZXRcclxuICAgICAqIEByZXR1cm5zIHRoZSByZXF1ZXN0ZWQge0BsaW5rIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcn1cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoX3R5cGU6IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSk6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICAgIGlmICghdGhpcy5ldmVudHNQcm9jZXNzZWQuaGFzKF90eXBlKSkge1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxUaW1lKCk7XHJcbiAgICAgICAgbGV0IGV2OiBBbmltYXRpb25FdmVudFRyaWdnZXIgPSB7fTtcclxuICAgICAgICBzd2l0Y2ggKF90eXBlKSB7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUw6XHJcbiAgICAgICAgICAgIGV2ID0gdGhpcy5ldmVudHM7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRTpcclxuICAgICAgICAgICAgZXYgPSB0aGlzLmNhbGN1bGF0ZVJldmVyc2VFdmVudFRyaWdnZXJzKHRoaXMuZXZlbnRzKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRDpcclxuICAgICAgICAgICAgZXYgPSB0aGlzLmNhbGN1bGF0ZVJhc3RlcmVkRXZlbnRUcmlnZ2Vycyh0aGlzLmV2ZW50cyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRURSRVZFUlNFOlxyXG4gICAgICAgICAgICBldiA9IHRoaXMuY2FsY3VsYXRlUmFzdGVyZWRFdmVudFRyaWdnZXJzKHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV2ZW50c1Byb2Nlc3NlZC5zZXQoX3R5cGUsIGV2KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5ldmVudHNQcm9jZXNzZWQuZ2V0KF90eXBlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyBhbiBleGlzdGluZyBzdHJ1Y3R1cmUgdG8gYXBwbHkgYSByZWNhbGN1bGF0aW9uIGZ1bmN0aW9uIHRvIHRoZSBBbmltYXRpb25TdHJ1Y3R1cmUgdG8gc3RvcmUgaW4gYSBuZXcgU3RydWN0dXJlLlxyXG4gICAgICogQHBhcmFtIF9vbGRTdHJ1Y3R1cmUgVGhlIG9sZCBzdHJ1Y3R1cmUgdG8gdHJhdmVyc2VcclxuICAgICAqIEBwYXJhbSBfZnVuY3Rpb25Ub1VzZSBUaGUgZnVuY3Rpb24gdG8gdXNlIHRvIHJlY2FsY3VsYXRlZCB0aGUgc3RydWN0dXJlLlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgQW5pbWF0aW9uIFN0cnVjdHVyZSB3aXRoIHRoZSByZWNhbHVsYXRlZCBBbmltYXRpb24gU2VxdWVuY2VzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRyYXZlcnNlU3RydWN0dXJlRm9yTmV3U3RydWN0dXJlKF9vbGRTdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSwgX2Z1bmN0aW9uVG9Vc2U6IEZ1bmN0aW9uKTogQW5pbWF0aW9uU3RydWN0dXJlIHtcclxuICAgICAgbGV0IG5ld1N0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlID0ge307XHJcbiAgICAgIGZvciAobGV0IG4gaW4gX29sZFN0cnVjdHVyZSkge1xyXG4gICAgICAgIGlmIChfb2xkU3RydWN0dXJlW25dIGluc3RhbmNlb2YgQW5pbWF0aW9uU2VxdWVuY2UpIHtcclxuICAgICAgICAgIG5ld1N0cnVjdHVyZVtuXSA9IF9mdW5jdGlvblRvVXNlKF9vbGRTdHJ1Y3R1cmVbbl0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdTdHJ1Y3R1cmVbbl0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTmV3U3RydWN0dXJlKDxBbmltYXRpb25TdHJ1Y3R1cmU+X29sZFN0cnVjdHVyZVtuXSwgX2Z1bmN0aW9uVG9Vc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3U3RydWN0dXJlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHJldmVyc2VkIEFuaW1hdGlvbiBTZXF1ZW5jZSBvdXQgb2YgYSBnaXZlbiBTZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSBfc2VxdWVuY2UgVGhlIHNlcXVlbmNlIHRvIGNhbGN1bGF0ZSB0aGUgbmV3IHNlcXVlbmNlIG91dCBvZlxyXG4gICAgICogQHJldHVybnMgVGhlIHJldmVyc2VkIFNlcXVlbmNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlUmV2ZXJzZVNlcXVlbmNlKF9zZXF1ZW5jZTogQW5pbWF0aW9uU2VxdWVuY2UpOiBBbmltYXRpb25TZXF1ZW5jZSB7XHJcbiAgICAgIGxldCBzZXE6IEFuaW1hdGlvblNlcXVlbmNlID0gbmV3IEFuaW1hdGlvblNlcXVlbmNlKCk7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBfc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgb2xkS2V5OiBBbmltYXRpb25LZXkgPSBfc2VxdWVuY2UuZ2V0S2V5KGkpO1xyXG4gICAgICAgIGxldCBrZXk6IEFuaW1hdGlvbktleSA9IG5ldyBBbmltYXRpb25LZXkodGhpcy50b3RhbFRpbWUgLSBvbGRLZXkudGltZSwgb2xkS2V5LnZhbHVlLCBvbGRLZXkuaW50ZXJwb2xhdGlvbiwgb2xkS2V5LnNsb3BlT3V0LCBvbGRLZXkuc2xvcGVJbik7XHJcbiAgICAgICAgc2VxLmFkZEtleShrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZXE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcmFzdGVyZWQge0BsaW5rIEFuaW1hdGlvblNlcXVlbmNlfSBvdXQgb2YgYSBnaXZlbiBzZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSBfc2VxdWVuY2UgVGhlIHNlcXVlbmNlIHRvIGNhbGN1bGF0ZSB0aGUgbmV3IHNlcXVlbmNlIG91dCBvZlxyXG4gICAgICogQHJldHVybnMgdGhlIHJhc3RlcmVkIHNlcXVlbmNlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZVJhc3RlcmVkU2VxdWVuY2UoX3NlcXVlbmNlOiBBbmltYXRpb25TZXF1ZW5jZSk6IEFuaW1hdGlvblNlcXVlbmNlIHtcclxuICAgICAgbGV0IHNlcTogQW5pbWF0aW9uU2VxdWVuY2UgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoKTtcclxuICAgICAgbGV0IGZyYW1lVGltZTogbnVtYmVyID0gMTAwMCAvIHRoaXMuZnJhbWVzUGVyU2Vjb25kO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy50b3RhbFRpbWU7IGkgKz0gZnJhbWVUaW1lKSB7XHJcbiAgICAgICAgbGV0IGtleTogQW5pbWF0aW9uS2V5ID0gbmV3IEFuaW1hdGlvbktleShpLCBfc2VxdWVuY2UuZXZhbHVhdGUoaSksIEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkNPTlNUQU5ULCAwLCAwKTtcclxuICAgICAgICBzZXEuYWRkS2V5KGtleSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlcTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmV2ZXJzZWQge0BsaW5rIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcn0gb2JqZWN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvbmUuICBcclxuICAgICAqIEBwYXJhbSBfZXZlbnRzIHRoZSBldmVudCBvYmplY3QgdG8gY2FsY3VsYXRlIHRoZSBuZXcgb25lIG91dCBvZlxyXG4gICAgICogQHJldHVybnMgdGhlIHJldmVyc2VkIGV2ZW50IG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZVJldmVyc2VFdmVudFRyaWdnZXJzKF9ldmVudHM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlcik6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICAgIGxldCBhZTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0ge307XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX2V2ZW50cykge1xyXG4gICAgICAgIGFlW25hbWVdID0gdGhpcy50b3RhbFRpbWUgLSBfZXZlbnRzW25hbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSByYXN0ZXJlZCB7QGxpbmsgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyfSBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIG9uZS4gIFxyXG4gICAgICogQHBhcmFtIF9ldmVudHMgdGhlIGV2ZW50IG9iamVjdCB0byBjYWxjdWxhdGUgdGhlIG5ldyBvbmUgb3V0IG9mXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmFzdGVyZWQgZXZlbnQgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlUmFzdGVyZWRFdmVudFRyaWdnZXJzKF9ldmVudHM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlcik6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICAgIGxldCBhZTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0ge307XHJcbiAgICAgIGxldCBmcmFtZVRpbWU6IG51bWJlciA9IDEwMDAgLyB0aGlzLmZyYW1lc1BlclNlY29uZDtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfZXZlbnRzKSB7XHJcbiAgICAgICAgYWVbbmFtZV0gPSBfZXZlbnRzW25hbWVdIC0gKF9ldmVudHNbbmFtZV0gJSBmcmFtZVRpbWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGljaCBldmVudHMgbGF5IGJldHdlZW4gdHdvIGdpdmVuIHRpbWVzIGFuZCByZXR1cm5zIHRoZSBuYW1lcyBvZiB0aGUgb25lcyB0aGF0IGRvLlxyXG4gICAgICogQHBhcmFtIF9ldmVudFRyaWdnZXJzIFRoZSBldmVudCBvYmplY3QgdG8gY2hlY2sgdGhlIGV2ZW50cyBpbnNpZGUgb2ZcclxuICAgICAqIEBwYXJhbSBfbWluIHRoZSBtaW5pbXVtIG9mIHRoZSByYW5nZSB0byBjaGVjayBiZXR3ZWVuIChpbmNsdXNpdmUpXHJcbiAgICAgKiBAcGFyYW0gX21heCB0aGUgbWF4aW11bSBvZiB0aGUgcmFuZ2UgdG8gY2hlY2sgYmV0d2VlbiAoZXhjbHVzaXZlKVxyXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIG5hbWVzIG9mIHRoZSBldmVudHMgaW4gdGhlIGdpdmVuIHJhbmdlLiBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjaGVja0V2ZW50c0JldHdlZW4oX2V2ZW50VHJpZ2dlcnM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciwgX21pbjogbnVtYmVyLCBfbWF4OiBudW1iZXIpOiBzdHJpbmdbXSB7XHJcbiAgICAgIGxldCBldmVudHNUb1RyaWdnZXI6IHN0cmluZ1tdID0gW107XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX2V2ZW50VHJpZ2dlcnMpIHtcclxuICAgICAgICBpZiAoX21pbiA8PSBfZXZlbnRUcmlnZ2Vyc1tuYW1lXSAmJiBfZXZlbnRUcmlnZ2Vyc1tuYW1lXSA8IF9tYXgpIHtcclxuICAgICAgICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZXZlbnRzVG9UcmlnZ2VyO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIHZhbHVlcyBiZXR3ZWVuIHtAbGluayBBbmltYXRpb25LZXl9cy5cclxuICAgKiBSZXByZXNlbnRlZCBpbnRlcm5hbGx5IGJ5IGEgY3ViaWMgZnVuY3Rpb24gKGBmKHgpID0gYXjCsyArIGJ4wrIgKyBjeCArIGRgKS4gXHJcbiAgICogT25seSBuZWVkcyB0byBiZSByZWNhbGN1bGF0ZWQgd2hlbiB0aGUga2V5cyBjaGFuZ2UsIHNvIGF0IHJ1bnRpbWUgaXQgc2hvdWxkIG9ubHkgYmUgY2FsY3VsYXRlZCBvbmNlLlxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uRnVuY3Rpb24ge1xyXG4gICAgcHJpdmF0ZSBhOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBiOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBjOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBkOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBrZXlJbjogQW5pbWF0aW9uS2V5O1xyXG4gICAgcHJpdmF0ZSBrZXlPdXQ6IEFuaW1hdGlvbktleTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2tleUluOiBBbmltYXRpb25LZXksIF9rZXlPdXQ6IEFuaW1hdGlvbktleSA9IG51bGwpIHtcclxuICAgICAgdGhpcy5rZXlJbiA9IF9rZXlJbjtcclxuICAgICAgdGhpcy5rZXlPdXQgPSBfa2V5T3V0O1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgc2V0S2V5SW4oX2tleUluOiBBbmltYXRpb25LZXkpIHtcclxuICAgICAgdGhpcy5rZXlJbiA9IF9rZXlJbjtcclxuICAgICAgdGhpcy5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHNldEtleU91dChfa2V5T3V0OiBBbmltYXRpb25LZXkpIHtcclxuICAgICAgdGhpcy5rZXlPdXQgPSBfa2V5T3V0O1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcGFyYW1ldGVyIHZhbHVlcyBvZiB0aGlzIGN1YmljIGZ1bmN0aW9uLiBgZih4KSA9IGF4wrMgKyBieMKyICsgY3ggKyBkYFxyXG4gICAgICogVXNlZCBieSBlZGl0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQYXJhbWV0ZXJzKCk6IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlcjsgZDogbnVtYmVyIH0ge1xyXG4gICAgICByZXR1cm4geyBhOiB0aGlzLmEsIGI6IHRoaXMuYiwgYzogdGhpcy5jLCBkOiB0aGlzLmQgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiBhdCB0aGUgZ2l2ZW4gdGltZS5cclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgcG9pbnQgaW4gdGltZSBhdCB3aGljaCB0byBldmFsdWF0ZSB0aGUgZnVuY3Rpb24gaW4gbWlsbGlzZWNvbmRzLiBXaWxsIGJlIGNvcnJlY3RlZCBmb3Igb2Zmc2V0IGludGVybmFsbHkuXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGV2YWx1YXRlKF90aW1lOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICBfdGltZSAtPSB0aGlzLmtleUluLnRpbWU7XHJcbiAgICAgIGxldCB0aW1lMjogbnVtYmVyID0gX3RpbWUgKiBfdGltZTtcclxuICAgICAgbGV0IHRpbWUzOiBudW1iZXIgPSB0aW1lMiAqIF90aW1lO1xyXG4gICAgICByZXR1cm4gdGhpcy5hICogdGltZTMgKyB0aGlzLmIgKiB0aW1lMiArIHRoaXMuYyAqIF90aW1lICsgdGhpcy5kO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogKFJlLSlDYWxjdWxhdGVzIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBjdWJpYyBmdW5jdGlvbi5cclxuICAgICAqIFNlZSBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzMxNzM0NjkvY2FsY3VsYXRlLWN1YmljLWVxdWF0aW9uLWZyb20tdHdvLXBvaW50cy1hbmQtdHdvLXNsb3Blcy12YXJpYWJseVxyXG4gICAgICogYW5kIGh0dHBzOi8vamlya2FkZWxsb3JvLmdpdGh1Yi5pby9GVURHRS9Eb2N1bWVudGF0aW9uL0xvZ3MvMTkwNDEwX05vdGl6ZW5fTFNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNhbGN1bGF0ZSgpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLmtleUluKSB7XHJcbiAgICAgICAgdGhpcy5kID0gdGhpcy5jID0gdGhpcy5iID0gdGhpcy5hID0gMDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLmtleU91dCB8fCB0aGlzLmtleUluLmludGVycG9sYXRpb24gPT0gQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04uQ09OU1RBTlQpIHtcclxuICAgICAgICB0aGlzLmQgPSB0aGlzLmtleUluLnZhbHVlO1xyXG4gICAgICAgIHRoaXMuYyA9IHRoaXMuYiA9IHRoaXMuYSA9IDA7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgeDE6IG51bWJlciA9IHRoaXMua2V5T3V0LnRpbWUgLSB0aGlzLmtleUluLnRpbWU7XHJcblxyXG4gICAgICB0aGlzLmQgPSB0aGlzLmtleUluLnZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5rZXlJbi5pbnRlcnBvbGF0aW9uID09IEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkxJTkVBUikge1xyXG4gICAgICAgIHRoaXMuYyA9ICh0aGlzLmtleU91dC52YWx1ZSAtIHRoaXMua2V5SW4udmFsdWUpIC8geDE7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmMgPSB0aGlzLmtleUluLnNsb3BlT3V0O1xyXG4gICAgICB0aGlzLmEgPSAoLXgxICogKHRoaXMua2V5SW4uc2xvcGVPdXQgKyB0aGlzLmtleU91dC5zbG9wZUluKSAtIDIgKiB0aGlzLmtleUluLnZhbHVlICsgMiAqIHRoaXMua2V5T3V0LnZhbHVlKSAvIC1NYXRoLnBvdyh4MSwgMyk7XHJcbiAgICAgIHRoaXMuYiA9ICh0aGlzLmtleU91dC5zbG9wZUluIC0gdGhpcy5rZXlJbi5zbG9wZU91dCAtIDMgKiB0aGlzLmEgKiBNYXRoLnBvdyh4MSwgMikpIC8gKDIgKiB4MSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQW4ge0BsaW5rIEFuaW1hdGlvbn0gbG9hZGVkIGZyb20gYSBnbFRGLUZpbGUuXHJcbiAgICogQGF1dGhvcnMgSm9uYXMgUGxvdHpreVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBbmltYXRpb25HTFRGIGV4dGVuZHMgbWl4aW5TZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsKEFuaW1hdGlvbikge1xyXG4gICAgcHVibGljIGFzeW5jIGxvYWQoX3VybDogUmVxdWVzdEluZm8gPSB0aGlzLnVybCwgX25hbWU6IHN0cmluZyA9IHRoaXMubmFtZSk6IFByb21pc2U8QW5pbWF0aW9uR0xURj4ge1xyXG4gICAgICB0aGlzLnVybCA9IF91cmw7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICByZXR1cm4gR0xURkxvYWRlci5sb2FkUmVzb3VyY2UodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgY29uc3Qgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmV2ZW50cyA9IHsgLi4udGhpcy5ldmVudHMgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB0aGlzLmV2ZW50cyA9IHsgLi4uX3NlcmlhbGl6YXRpb24uZXZlbnRzIH07XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIFxyXG4gIGV4cG9ydCBlbnVtIEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OIHtcclxuICAgIENPTlNUQU5ULFxyXG4gICAgTElORUFSLFxyXG4gICAgQ1VCSUNcclxuICB9XHJcbiAgLy8gdHlwZSBBbmltYXRpb25JbnRlcnBvbGF0aW9uID0gXCJjb25zdGFudFwiIHwgXCJsaW5lYXJcIiB8IFwiY3ViaWNcIjtcclxuXHJcbiAgLyoqXHJcbiAgICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgY29udGlub3VzIHBvaW50cyBpbiB0aW1lIHRoZWlyIGFjY29tcGFueWluZyB2YWx1ZXMgYXMgd2VsbCBhcyB0aGVpciBzbG9wZXMuIFxyXG4gICAqIEFsc28gaG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlIHtAbGluayBBbmltYXRpb25GdW5jdGlvbn1zIHRoYXQgY29tZSBpbiBhbmQgb3V0IG9mIHRoZSBzaWRlcy4gXHJcbiAgICogVGhlIHtAbGluayBBbmltYXRpb25GdW5jdGlvbn1zIGFyZSBoYW5kbGVkIGJ5IHRoZSB7QGxpbmsgQW5pbWF0aW9uU2VxdWVuY2V9cy5cclxuICAgKiBJZiB0aGUgcHJvcGVydHkgY29uc3RhbnQgaXMgdHJ1ZSwgdGhlIHZhbHVlIGRvZXMgbm90IGNoYW5nZSBhbmQgd2lsIG5vdCBiZSBpbnRlcnBvbGF0ZWQgYmV0d2VlbiB0aGlzIGFuZCB0aGUgbmV4dCBrZXkgaW4gYSBzZXF1ZW5jZVxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uS2V5IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICAvLyBUT0RPOiBjaGVjayBpZiBmdW5jdGlvbkluIGNhbiBiZSByZW1vdmVkXHJcbiAgICAvKipEb24ndCBtb2RpZnkgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuKi9cclxuICAgIHB1YmxpYyBmdW5jdGlvbkluOiBBbmltYXRpb25GdW5jdGlvbjtcclxuICAgIC8qKkRvbid0IG1vZGlmeSB0aGlzIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy4qL1xyXG4gICAgcHVibGljIGZ1bmN0aW9uT3V0OiBBbmltYXRpb25GdW5jdGlvbjtcclxuXHJcbiAgICAjdGltZTogbnVtYmVyO1xyXG4gICAgI3ZhbHVlOiBudW1iZXI7XHJcbiAgICAjaW50ZXJwb2xhdGlvbjogQU5JTUFUSU9OX0lOVEVSUE9MQVRJT047XHJcblxyXG4gICAgI3Nsb3BlSW46IG51bWJlciA9IDA7XHJcbiAgICAjc2xvcGVPdXQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF90aW1lOiBudW1iZXIgPSAwLCBfdmFsdWU6IG51bWJlciA9IDAsIF9pbnRlcnBvbGF0aW9uOiBBTklNQVRJT05fSU5URVJQT0xBVElPTiA9IEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkNVQklDLCBfc2xvcGVJbjogbnVtYmVyID0gMCwgX3Nsb3BlT3V0OiBudW1iZXIgPSAwKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuI3RpbWUgPSBfdGltZTtcclxuICAgICAgdGhpcy4jdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgIHRoaXMuI2ludGVycG9sYXRpb24gPSBfaW50ZXJwb2xhdGlvbjtcclxuICAgICAgdGhpcy4jc2xvcGVJbiA9IF9zbG9wZUluO1xyXG4gICAgICB0aGlzLiNzbG9wZU91dCA9IF9zbG9wZU91dDtcclxuXHJcbiAgICAgIHRoaXMuZnVuY3Rpb25PdXQgPSBuZXcgQW5pbWF0aW9uRnVuY3Rpb24odGhpcywgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGF0aWMgY29tcGFyYXRpb24gZnVuY3Rpb24gdG8gdXNlIGluIGFuIGFycmF5IHNvcnQgZnVuY3Rpb24gdG8gc29ydCB0aGUga2V5cyBieSB0aGVpciB0aW1lLlxyXG4gICAgICogQHBhcmFtIF9hIHRoZSBhbmltYXRpb24ga2V5IHRvIGNoZWNrXHJcbiAgICAgKiBAcGFyYW0gX2IgdGhlIGFuaW1hdGlvbiBrZXkgdG8gY2hlY2sgYWdhaW5zdFxyXG4gICAgICogQHJldHVybnMgPjAgaWYgYT5iLCAwIGlmIGE9YiwgPDAgaWYgYTxiXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY29tcGFyZShfYTogQW5pbWF0aW9uS2V5LCBfYjogQW5pbWF0aW9uS2V5KTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIF9hLnRpbWUgLSBfYi50aW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdGltZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jdGltZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHRpbWUoX3RpbWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiN0aW1lID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25Jbi5jYWxjdWxhdGUoKTtcclxuICAgICAgdGhpcy5mdW5jdGlvbk91dC5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHZhbHVlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiN2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHZhbHVlKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uSW4uY2FsY3VsYXRlKCk7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25PdXQuY2FsY3VsYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpbnRlcnBvbGF0aW9uKCk6IEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2ludGVycG9sYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBpbnRlcnBvbGF0aW9uKF9pbnRlcnBvbGF0aW9uOiBBTklNQVRJT05fSU5URVJQT0xBVElPTikge1xyXG4gICAgICB0aGlzLiNpbnRlcnBvbGF0aW9uID0gX2ludGVycG9sYXRpb247XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25Jbi5jYWxjdWxhdGUoKTtcclxuICAgICAgdGhpcy5mdW5jdGlvbk91dC5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHNsb3BlSW4oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3Nsb3BlSW47XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBzbG9wZUluKF9zbG9wZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3Nsb3BlSW4gPSBfc2xvcGU7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25Jbi5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHNsb3BlT3V0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzbG9wZU91dDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHNsb3BlT3V0KF9zbG9wZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3Nsb3BlT3V0ID0gX3Nsb3BlO1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uT3V0LmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiB0cmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgc2VyaWFsaXphdGlvbi50aW1lID0gdGhpcy4jdGltZTtcclxuICAgICAgc2VyaWFsaXphdGlvbi52YWx1ZSA9IHRoaXMuI3ZhbHVlO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmludGVycG9sYXRpb24gPSB0aGlzLiNpbnRlcnBvbGF0aW9uO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnNsb3BlSW4gPSB0aGlzLiNzbG9wZUluO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnNsb3BlT3V0ID0gdGhpcy4jc2xvcGVPdXQ7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuI3RpbWUgPSBfc2VyaWFsaXphdGlvbi50aW1lO1xyXG4gICAgICB0aGlzLiN2YWx1ZSA9IF9zZXJpYWxpemF0aW9uLnZhbHVlO1xyXG4gICAgICB0aGlzLiNpbnRlcnBvbGF0aW9uID0gX3NlcmlhbGl6YXRpb24uaW50ZXJwb2xhdGlvbjtcclxuICAgICAgdGhpcy4jc2xvcGVJbiA9IF9zZXJpYWxpemF0aW9uLnNsb3BlSW47XHJcbiAgICAgIHRoaXMuI3Nsb3BlT3V0ID0gX3NlcmlhbGl6YXRpb24uc2xvcGVPdXQ7XHJcbiAgICAgIC8vIGlmIChfc2VyaWFsaXphdGlvbi5pbnRlcnBvbGF0aW9uID09IHVuZGVmaW5lZClcclxuICAgICAgLy8gICBpZiAoX3NlcmlhbGl6YXRpb24uY29uc3RhbnQpIC8vIFRPRE86IHJlbW92ZSB0aGlzIHdoZW4gY29uc3RhbnQgaXMgcmVtb3ZlZFxyXG4gICAgICAvLyAgICAgdGhpcy4jaW50ZXJwb2xhdGlvbiA9IFwiY29uc3RhbnRcIjtcclxuICAgICAgLy8gICBlbHNlXHJcbiAgICAgIC8vICAgICB0aGlzLiNpbnRlcnBvbGF0aW9uID0gXCJjdWJpY1wiO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIC8vXHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqIEJsZW5kaW5nIG1vZGVzIHVzZWQgaW4ge0BsaW5rIEFuaW1hdGlvbk5vZGVCbGVuZH0uICovXHJcbiAgZXhwb3J0IGVudW0gQU5JTUFUSU9OX0JMRU5ESU5HIHtcclxuICAgIC8qKiBBZGRzIHRoaXMgYW5pbWF0aW9uIHRvIHRoZSBwcmV2aW91cyBhbmltYXRpb25zLiAqL1xyXG4gICAgQURESVRJVkUgPSBcIkFkZGl0aXZlXCIsXHJcbiAgICAvKiogT3ZlcnJpZGVzIHRoZSBwcmV2aW91cyBhbmltYXRpb25zIHVzaW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLiAqL1xyXG4gICAgT1ZFUlJJREUgPSBcIk92ZXJyaWRlXCJcclxuICB9XHJcblxyXG4gIC8qKiBcclxuICAgKiBCYXNlIGNsYXNzIGZvciBhbGwgYW5pbWF0aW9uIG5vZGVzLiBBbmltYXRpb24gbm9kZXMgZm9ybSBhbiBhbmltYXRpb24gZ3JhcGggZW5hYmxpbmcgaGllcmFjaGljYWwgYW5pbWF0aW9uIGJsZW5kaW5nIGFuZCBhbmltYXRpb24gdHJhbnNpdGlvbnMuIFxyXG4gICAqIENhbiBiZSBhdHRhY2hlZCB0byBhIHtAbGluayBOb2RlfSB2aWEge0BsaW5rIENvbXBvbmVudEFuaW1hdGlvbkdyYXBofS4gXHJcbiAgICogQGF1dGhvciBKb25hcyBQbG90emt5LCBIRlUsIDIwMjQtMjAyNVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBbmltYXRpb25Ob2RlIHtcclxuICAgIC8qKiBUaGUgKGJsZW5kZWQpIHtAbGluayBBbmltYXRpb24uZ2V0U3RhdGUgYW5pbWF0aW9uIG11dGF0b3J9IGF0IHRoZSBzdGF0ZSBvZiB0aGUgbGFzdCBjYWxsIHRvIHtAbGluayB1cGRhdGV9LiAqL1xyXG4gICAgcHVibGljIG11dGF0b3I6IE11dGF0b3I7XHJcbiAgICAvKiogVGhlIHtAbGluayBBbmltYXRpb24uZXZlbnRzIGV2ZW50c30gdGhhdCBvY2N1cmVkIGJldHdlZW4gdGhlIG5vZGVzIGxhc3QgdHdvIHtAbGluayB1cGRhdGV9cy4gKi9cclxuICAgIHB1YmxpYyBldmVudHM6IHN0cmluZ1tdO1xyXG5cclxuICAgIC8qKiBUaGUgcGxheWJhY2sgc3BlZWQgKi9cclxuICAgIHB1YmxpYyBzcGVlZDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgd2VpZ2h0IHVzZWQgZm9yIGJsZW5kaW5nIHRoaXMgbm9kZSB3aXRoIG90aGVycyBpbiBhbiB7QGxpbmsgQW5pbWF0aW9uTm9kZUJsZW5kfS4gRGVmYXVsdDogMS4qL1xyXG4gICAgcHVibGljIHdlaWdodDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBtb2RlIHVzZWQgZm9yIGJsZW5kaW5nIHRoaXMgbm9kZSB3aXRoIG90aGVycyBpbiBhbiB7QGxpbmsgQW5pbWF0aW9uTm9kZUJsZW5kfS4gRGVmYXVsdDoge0BsaW5rIEFOSU1BVElPTl9CTEVORElORy5PVkVSUklERX0uICovXHJcbiAgICBwdWJsaWMgYmxlbmRpbmc6IEFOSU1BVElPTl9CTEVORElORztcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX29wdGlvbnM/OiB7IHNwZWVkPzogbnVtYmVyOyB3ZWlnaHQ/OiBudW1iZXI7IGJsZW5kaW5nPzogQU5JTUFUSU9OX0JMRU5ESU5HIH0pIHtcclxuICAgICAgdGhpcy5zcGVlZCA9IF9vcHRpb25zPy5zcGVlZCA/PyAxO1xyXG4gICAgICB0aGlzLndlaWdodCA9IF9vcHRpb25zPy53ZWlnaHQgPz8gMTtcclxuICAgICAgdGhpcy5ibGVuZGluZyA9IF9vcHRpb25zPy5ibGVuZGluZyA/PyBBTklNQVRJT05fQkxFTkRJTkcuT1ZFUlJJREU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJlc2V0cyB0aGUgdGltZS4gKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCByZXNldCgpOiB2b2lkO1xyXG5cclxuICAgIC8qKiBVcGRhdGVzIHRoZSB7QGxpbmsgbXV0YXRvcn0gYW5kIHtAbGluayBldmVudHN9IGFjY29yZGluZyB0aGUgZ2l2ZW4gZGVsdGEgdGltZSAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IHVwZGF0ZShfZGVsdGFUaW1lOiBudW1iZXIsIF9wb3NlPzogTXV0YXRvcik6IHZvaWQ7XHJcbiAgfVxyXG5cclxuICAvKiogXHJcbiAgICogRXZhbHVhdGVzIGEgc2luZ2xlIHtAbGluayBBbmltYXRpb259IHByb3ZpZGluZyBhIHtAbGluayBtdXRhdG9yfSBhbmQge0BsaW5rIGV2ZW50c30uIFxyXG4gICAqIFVzZWQgYXMgYW4gaW5wdXQgZm9yIG90aGVyIHtAbGluayBBbmltYXRpb25Ob2RlfXMuIFxyXG4gICAqIEBhdXRob3IgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDI0LTIwMjVcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uTm9kZUFuaW1hdGlvbiBleHRlbmRzIEFuaW1hdGlvbk5vZGUge1xyXG4gICAgcHVibGljIGFuaW1hdGlvbjogQW5pbWF0aW9uO1xyXG4gICAgcHVibGljIHBsYXltb2RlOiBBTklNQVRJT05fUExBWU1PREU7XHJcblxyXG4gICAgLyoqIFRoZSB0aW1lIGFmdGVyIHRoZSBsYXN0IGNhbGwgdG8ge0BsaW5rIHVwZGF0ZX0uICovXHJcbiAgICBwdWJsaWMgdGltZTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgdGltZSBvZmZzZXQgZnJvbSB3aGljaCB0aGUgYW5pbWF0aW9uIHN0YXJ0cyB3aGVuIHJlc2V0LiAqL1xyXG4gICAgcHVibGljIG9mZnNldD86IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2FuaW1hdGlvbjogQW5pbWF0aW9uLCBfb3B0aW9ucz86IHsgc3BlZWQ/OiBudW1iZXI7IG9mZnNldD86IG51bWJlcjsgcGxheW1vZGU/OiBBTklNQVRJT05fUExBWU1PREU7IHdlaWdodD86IG51bWJlcjsgYmxlbmRpbmc/OiBBTklNQVRJT05fQkxFTkRJTkcgfSk7XHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKTtcclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbXV0YXRvcjogTXV0YXRvcik7XHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2FuaW1hdGlvbj86IEFuaW1hdGlvbiB8IE11dGF0b3IsIF9vcHRpb25zPzogeyBzcGVlZD86IG51bWJlcjsgb2Zmc2V0PzogbnVtYmVyOyBwbGF5bW9kZT86IEFOSU1BVElPTl9QTEFZTU9ERTsgd2VpZ2h0PzogbnVtYmVyOyBibGVuZGluZz86IEFOSU1BVElPTl9CTEVORElORyB9KSB7XHJcbiAgICAgIHN1cGVyKF9vcHRpb25zKTtcclxuXHJcbiAgICAgIGlmICghX2FuaW1hdGlvbilcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBpZiAoIShfYW5pbWF0aW9uIGluc3RhbmNlb2YgQW5pbWF0aW9uKSkge1xyXG4gICAgICAgIHRoaXMubXV0YXRvciA9IF9hbmltYXRpb247XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmFuaW1hdGlvbiA9IF9hbmltYXRpb247XHJcbiAgICAgIHRoaXMub2Zmc2V0ID0gX29wdGlvbnM/Lm9mZnNldCA/PyAwO1xyXG4gICAgICB0aGlzLnBsYXltb2RlID0gX29wdGlvbnM/LnBsYXltb2RlO1xyXG4gICAgICB0aGlzLnRpbWUgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXNldHMgdGhpcyBub2RlIHRvIGl0cyB7QGxpbmsgb2Zmc2V0fSB0aW1lLiAqL1xyXG4gICAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnRpbWUgPSB0aGlzLm9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlKF9kZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMuYW5pbWF0aW9uKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIF9kZWx0YVRpbWUgKj0gdGhpcy5zcGVlZDtcclxuXHJcbiAgICAgIGxldCB1cGRhdGVkVGltZTogbnVtYmVyID0gdGhpcy50aW1lICsgX2RlbHRhVGltZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWUgPT0gMClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICB1cGRhdGVkVGltZSA9IHRoaXMuYW5pbWF0aW9uLmdldE1vZGFsVGltZSh1cGRhdGVkVGltZSwgdGhpcy5wbGF5bW9kZSk7XHJcblxyXG4gICAgICBsZXQgZGlyZWN0aW9uOiBudW1iZXIgPSB0aGlzLmFuaW1hdGlvbi5jYWxjdWxhdGVEaXJlY3Rpb24odXBkYXRlZFRpbWUsIHRoaXMucGxheW1vZGUpO1xyXG5cclxuICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmFuaW1hdGlvbi5nZXRFdmVudHNUb0ZpcmUodGhpcy50aW1lLCB1cGRhdGVkVGltZSwgQU5JTUFUSU9OX1FVQU5USVpBVElPTi5DT05USU5PVVMsIGRpcmVjdGlvbik7XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IHRoaXMuYW5pbWF0aW9uLmdldFN0YXRlKHVwZGF0ZWRUaW1lICUgdGhpcy5hbmltYXRpb24udG90YWxUaW1lLCBkaXJlY3Rpb24sIEFOSU1BVElPTl9RVUFOVElaQVRJT04uQ09OVElOT1VTKTtcclxuICAgICAgdGhpcy50aW1lID0gdXBkYXRlZFRpbWU7XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogXHJcbiAgICogQmxlbmRzIG11bHRpcGxlIGlucHV0IHtAbGluayBBbmltYXRpb25Ob2RlfXMgcHJvdmlkaW5nIGEgYmxlbmRlZCB7QGxpbmsgbXV0YXRvcn0gYW5kIHRoZSB7QGxpbmsgZXZlbnRzfSBmcm9tIGFsbCBub2Rlcy4gXHJcbiAgICogRWFjaCBjaGlsZCBub2RlIG11c3Qgc3BlY2lmeSBpdHMgb3duIGJsZW5kIHtAbGluayB3ZWlnaHR9IGFuZCB7QGxpbmsgYmxlbmRpbmd9LiBQcm9jZXNzZXMgbm9kZXMgc2VxdWVudGlhbGx5LCBlYWNoIG5vZGUgYmxlbmRzIHdpdGggdGhlIGFjY3VtdWxhdGVkIHJlc3VsdC5cclxuICAgKiBXaGVuIGNvbWJpbmVkIHdpdGgge0BsaW5rIEFuaW1hdGlvbk5vZGVUcmFuc2l0aW9ufXMgYXMgY2hpbGRyZW4sIHRyYW5zaXRpb25zIGZyb20vaW50byBhbiBlbXB0eSBzdGF0ZSB3aWxsIGJsZW5kIGZyb20vaW50byB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHRoaXMgbm9kZS5cclxuICAgKiBAYXV0aG9yIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNC0yMDI1XHJcbiAgICogXHJcbiAgICogKipFeGFtcGxlIHdhbGstcnVuLWJsZW5kOioqXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGltcG9ydCDGkiA9IEZ1ZGdlQ29yZTtcclxuICAgKiAvLyBpbml0aWFsaXphdGlvblxyXG4gICAqIGNvbnN0IHdhbGs6IMaSLkFuaW1hdGlvbiA9IG5ldyDGki5BbmltYXRpb24oKTtcclxuICAgKiBjb25zdCBydW46IMaSLkFuaW1hdGlvbiA9IG5ldyDGki5BbmltYXRpb24oKTtcclxuICAgKiBjb25zdCBub2RlV2FsazogxpIuQW5pbWF0aW9uTm9kZUFuaW1hdGlvbiA9IG5ldyDGki5BbmltYXRpb25Ob2RlQW5pbWF0aW9uKHdhbGspO1xyXG4gICAqIGNvbnN0IG5vZGVSdW46IMaSLkFuaW1hdGlvbk5vZGVBbmltYXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uTm9kZUFuaW1hdGlvbihydW4sIHsgc3BlZWQ6IHJ1bi50b3RhbFRpbWUgLyB3YWxrLnRvdGFsVGltZSB9KSAvLyBzbG93IGRvd24gdGhlIHBsYXliYWNrIHNwZWVkIG9mIHJ1biB0byBzeW5jaHJvbml6ZSB0aGUgbW90aW9uIHdpdGggd2Fsay5cclxuICAgKiBjb25zdCBub2RlTW92ZTogxpIuQW5pbWF0aW9uTm9kZUJsZW5kID0gbmV3IMaSLkFuaW1hdGlvbk5vZGVCbGVuZChbbm9kZVdhbGssIG5vZGVSdW5dKTtcclxuICAgKiBjb25zdCBjbXBBbmltYXRpb25HcmFwaDogxpIuQ29tcG9uZW50QW5pbWF0aW9uR3JhcGggPSBuZXcgxpIuQ29tcG9uZW50QW5pbWF0aW9uR3JhcGgoKTsgLy8gZ2V0IHRoZSBhbmltYXRpb24gY29tcG9uZW50XHJcbiAgICogY21wQW5pbWF0aW9uR3JhcGgucm9vdCA9IG5vZGVNb3ZlO1xyXG4gICAqIFxyXG4gICAqIC8vIGR1cmluZyB0aGUgZ2FtZVxyXG4gICAqIG5vZGVSdW4ud2VpZ2h0ID0gMC41OyAvLyBhZGp1c3QgdGhlIHdlaWdodDogMCBpcyB3YWxraW5nLCAxIGlzIHJ1bm5pbmcuXHJcbiAgICogbm9kZU1vdmUuc3BlZWQgPSAxICsgbm9kZVJ1bi53ZWlnaHQgKiBub2RlUnVuLnNwZWVkOyAvLyBhZGp1c3QgdGhlIHBsYXliYWNrIHNwZWVkIG9mIHRoZSBibGVuZCB0byBhY2NvdW50IGZvciB0aGUgc2xvd2VkIGRvd24gcnVuIGFuaW1hdGlvbi5cclxuICAgKiBgYGBcclxuICAgKiAqKkV4YW1wbGUgdHJhbnNpdGlvbi1lbXB0eS1zdGF0ZToqKlxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiBpbXBvcnQgxpIgPSBGdWRnZUNvcmU7XHJcbiAgICogLy8gaW5pdGlhbGl6YXRpb25cclxuICAgKiBjb25zdCBpZGxlOiDGki5BbmltYXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uKCk7XHJcbiAgICogY29uc3Qgd2FsazogxpIuQW5pbWF0aW9uID0gbmV3IMaSLkFuaW1hdGlvbigpO1xyXG4gICAqIGNvbnN0IGRyYXc6IMaSLkFuaW1hdGlvbiA9IG5ldyDGki5BbmltYXRpb24oKTtcclxuICAgKiBjb25zdCBzaGVhdGhlOiDGki5BbmltYXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uKCk7XHJcbiAgICogXHJcbiAgICogY29uc3Qgbm9kZUVtcHR5OiDGki5BbmltYXRpb25Ob2RlQW5pbWF0aW9uID0gbmV3IMaSLkFuaW1hdGlvbk5vZGVBbmltYXRpb24oKTtcclxuICAgKiBjb25zdCBub2RlSWRsZTogxpIuQW5pbWF0aW9uTm9kZUFuaW1hdGlvbiA9IG5ldyDGki5BbmltYXRpb25Ob2RlQW5pbWF0aW9uKGlkbGUpO1xyXG4gICAqIGNvbnN0IG5vZGVXYWxrOiDGki5BbmltYXRpb25Ob2RlQW5pbWF0aW9uID0gbmV3IMaSLkFuaW1hdGlvbk5vZGVBbmltYXRpb24od2Fsayk7XHJcbiAgICogY29uc3Qgbm9kZURyYXc6IMaSLkFuaW1hdGlvbk5vZGVBbmltYXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uTm9kZUFuaW1hdGlvbihkcmF3LCB7IHBsYXltb2RlOiDGki5BTklNQVRJT05fUExBWU1PREUuUExBWV9PTkNFIH0pO1xyXG4gICAqIGNvbnN0IG5vZGVTaGVhdGhlOiDGki5BbmltYXRpb25Ob2RlQW5pbWF0aW9uID0gbmV3IMaSLkFuaW1hdGlvbk5vZGVBbmltYXRpb24oc2hlYXRoZSwgeyBwbGF5bW9kZTogxpIuQU5JTUFUSU9OX1BMQVlNT0RFLlBMQVlfT05DRSB9KTtcclxuICAgKiBcclxuICAgKiBjb25zdCBub2RlV2hvbGVCb2R5OiDGki5BbmltYXRpb25Ob2RlVHJhbnNpdGlvbiA9IG5ldyDGki5BbmltYXRpb25Ob2RlVHJhbnNpdGlvbihub2RlSWRsZSk7XHJcbiAgICogY29uc3Qgbm9kZVVwcGVyQm9keTogxpIuQW5pbWF0aW9uTm9kZVRyYW5zaXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uTm9kZVRyYW5zaXRpb24obm9kZUVtcHR5KTtcclxuICAgKiBjb25zdCBub2RlUm9vdDogxpIuQW5pbWF0aW9uTm9kZUJsZW5kID0gbmV3IMaSLkFuaW1hdGlvbk5vZGVCbGVuZChbbm9kZVdob2xlQm9keSwgbm9kZVVwcGVyQm9keV0pO1xyXG4gICAqIGNvbnN0IGNtcEFuaW1hdGlvbkdyYXBoOiDGki5Db21wb25lbnRBbmltYXRpb25HcmFwaCA9IG5ldyDGki5Db21wb25lbnRBbmltYXRpb25HcmFwaCgpOyAvLyBnZXQgdGhlIGFuaW1hdGlvbiBjb21wb25lbnRcclxuICAgKiBjbXBBbmltYXRpb25HcmFwaC5yb290ID0gbm9kZVJvb3Q7XHJcbiAgICogXHJcbiAgICogLy8gZHVyaW5nIHRoZSBnYW1lXHJcbiAgICogbm9kZVdob2xlQm9keS50cmFuc2l0KG5vZGVXYWxrLCAzMDApOyAvLyB0cmFuc2l0IHdob2xlIGJvZHkgaW50byB3YWxrLlxyXG4gICAqIC8vIGluIHBhcmFsbGVsIHRvIHRoZSB3aG9sZSBib2R5LCB0aGUgdXBwZXIgYm9keSBjYW4gdHJhbnNpdCBmcm9tIGVtcHR5IHRvIGRyYXcvc2hlYXRoIGFuZCBiYWNrIHRvIGVtcHR5LlxyXG4gICAqIG5vZGVVcHBlckJvZHkudHJhbnNpdChub2RlRHJhdywgMzAwKTsgLy8gdHJhbnNpdCB1cHBlciBib2R5IGZyb20gZW1wdHkgaW50byBkcmF3LlxyXG4gICAqIG5vZGVVcHBlckJvZHkudHJhbnNpdChub2RlU2hlYXRoZSwgMzAwKTsgLy8gdHJhbnNpdCB1cHBlciBib2R5IGZyb20gZHJhdyBpbnRvIHNoZWF0aGUuXHJcbiAgICogbm9kZVVwcGVyQm9keS50cmFuc2l0KG5vZGVFbXB0eSwgMzAwKTsgLy8gdHJhbnNpdCB1cHBlciBib2R5IGZyb20gc2hlYXRoZSBpbnRvIGVtcHR5LlxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBbmltYXRpb25Ob2RlQmxlbmQgZXh0ZW5kcyBBbmltYXRpb25Ob2RlIHtcclxuICAgIHB1YmxpYyBub2RlczogQW5pbWF0aW9uTm9kZVtdO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihfbm9kZXM6IEFuaW1hdGlvbk5vZGVbXSwgX29wdGlvbnM/OiB7IHNwZWVkPzogbnVtYmVyOyB3ZWlnaHQ/OiBudW1iZXI7IGJsZW5kaW5nPzogQU5JTUFUSU9OX0JMRU5ESU5HIH0pIHtcclxuICAgICAgc3VwZXIoX29wdGlvbnMpO1xyXG4gICAgICB0aGlzLm5vZGVzID0gX25vZGVzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMubm9kZXMpXHJcbiAgICAgICAgbm9kZS5yZXNldCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGUoX2RlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgX2RlbHRhVGltZSAqPSB0aGlzLnNwZWVkO1xyXG5cclxuICAgICAgdGhpcy5ub2Rlc1swXS51cGRhdGUoX2RlbHRhVGltZSwge30pOyAvLyBUT0RPOiBhZGQgYmFzZSBwb3NlIHNuYXBzaG90IHRvIGJsZW5kIGZyb21cclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB0aGlzLm5vZGVzWzBdLm11dGF0b3IgPz8ge307XHJcbiAgICAgIGxldCBldmVudHM6IHN0cmluZ1tdID0gdGhpcy5ub2Rlc1swXS5ldmVudHMgPz8gW107XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDE7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZTogQW5pbWF0aW9uTm9kZSA9IHRoaXMubm9kZXNbaV07XHJcbiAgICAgICAgbm9kZS51cGRhdGUoX2RlbHRhVGltZSwgbXV0YXRvcik7XHJcblxyXG4gICAgICAgIGlmICghbm9kZS5tdXRhdG9yKVxyXG4gICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgIHN3aXRjaCAobm9kZS5ibGVuZGluZykge1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fQkxFTkRJTkcuQURESVRJVkU6XHJcbiAgICAgICAgICAgIG11dGF0b3IgPSBBbmltYXRpb24uYmxlbmRBZGRpdGl2ZShtdXRhdG9yLCBub2RlLm11dGF0b3IsIG5vZGUud2VpZ2h0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9CTEVORElORy5PVkVSUklERTpcclxuICAgICAgICAgICAgbXV0YXRvciA9IEFuaW1hdGlvbi5ibGVuZE92ZXJyaWRlKG11dGF0b3IsIG5vZGUubXV0YXRvciwgbm9kZS53ZWlnaHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQobm9kZS5ldmVudHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLm11dGF0b3IgPSBtdXRhdG9yO1xyXG4gICAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBcclxuICAgKiBBbGxvd3MgdG8gdHJhbnNpdGlvbiBmcm9tIG9uZSB7QGxpbmsgQW5pbWF0aW9uTm9kZX0gdG8gYW5vdGhlciBvdmVyIGEgc3BlY2lmaWVkIHRpbWUuIFxyXG4gICAqIElmIG5lc3RlZCBpbnNpZGUgYW4ge0BsaW5rIEFuaW1hdGlvbk5vZGVCbGVuZH0sIHRyYW5zaXQgZnJvbS9pbnRvIGFuIGVtcHR5IHN0YXRlIHRvIGJsZW5kIGZyb20vaW50byB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHRoZSBjb250YWluZXIgYmxlbmQgbm9kZS5cclxuICAgKiBAYXV0aG9yIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNC0yMDI1XHJcbiAgICogXHJcbiAgICogKipFeGFtcGxlOioqXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGltcG9ydCDGkiA9IEZ1ZGdlQ29yZTtcclxuICAgKiAvLyBpbml0aWFsaXphdGlvblxyXG4gICAqIGNvbnN0IGlkbGU6IMaSLkFuaW1hdGlvbiA9IG5ldyDGki5BbmltYXRpb24oKTtcclxuICAgKiBjb25zdCB3YWxrOiDGki5BbmltYXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uKCk7XHJcbiAgICogY29uc3Qgbm9kZUlkbGU6IMaSLkFuaW1hdGlvbk5vZGVBbmltYXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uTm9kZUFuaW1hdGlvbihpZGxlKTtcclxuICAgKiBjb25zdCBub2RlV2FsazogxpIuQW5pbWF0aW9uTm9kZUFuaW1hdGlvbiA9IG5ldyDGki5BbmltYXRpb25Ob2RlQW5pbWF0aW9uKHdhbGspO1xyXG4gICAqIGNvbnN0IG5vZGVUcmFuc2l0aW9uOiDGki5BbmltYXRpb25Ob2RlVHJhbnNpdGlvbiA9IG5ldyDGki5BbmltYXRpb25Ob2RlVHJhbnNpdGlvbihub2RlSWRsZSk7XHJcbiAgICogY29uc3QgY21wQW5pbWF0aW9uR3JhcGg6IMaSLkNvbXBvbmVudEFuaW1hdGlvbkdyYXBoID0gbmV3IMaSLkNvbXBvbmVudEFuaW1hdGlvbkdyYXBoKCk7IC8vIGdldCB0aGUgYW5pbWF0aW9uIGNvbXBvbmVudFxyXG4gICAqIGNtcEFuaW1hdGlvbkdyYXBoLnJvb3QgPSBub2RlVHJhbnNpdGlvbjtcclxuICAgKiBcclxuICAgKiAvLyBkdXJpbmcgdGhlIGdhbWVcclxuICAgKiBub2RlVHJhbnNpdGlvbi50cmFuc2l0KG5vZGVXYWxrLCAzMDApOyAvLyB0cmFuc2l0IHRvIHRoZSB3YWxrIGFuaW1hdGlvbiBpbiAzMDBtcy5cclxuICAgKiBub2RlVHJhbnNpdGlvbi50cmFuc2l0KG5vZGVJZGxlLCAzMDApOyAvLyB0cmFuc2l0IGJhY2sgdG8gdGhlIGlkbGUgYW5pbWF0aW9uLlxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBbmltYXRpb25Ob2RlVHJhbnNpdGlvbiBleHRlbmRzIEFuaW1hdGlvbk5vZGUge1xyXG4gICAgcHVibGljIGZyb206IEFuaW1hdGlvbk5vZGU7XHJcbiAgICBwdWJsaWMgdG86IEFuaW1hdGlvbk5vZGU7XHJcblxyXG4gICAgcHVibGljIGR1cmF0aW9uOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgdGltZTogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYW5pbWF0aW9uOiBBbmltYXRpb25Ob2RlLCBfb3B0aW9ucz86IHsgc3BlZWQ/OiBudW1iZXI7IHdlaWdodD86IG51bWJlcjsgYmxlbmRpbmc/OiBBTklNQVRJT05fQkxFTkRJTkcgfSkge1xyXG4gICAgICBzdXBlcihfb3B0aW9ucyk7XHJcbiAgICAgIHRoaXMuZnJvbSA9IF9hbmltYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmZyb20ucmVzZXQoKTtcclxuICAgICAgdGhpcy50bz8ucmVzZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVHJhbnNpdCB0byB0aGUgZ2l2ZW4ge0BsaW5rIEFuaW1hdGlvbk5vZGV9IG92ZXIgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi4gVGhlIGdpdmVuIG5vZGUgd2lsbCBiZSB7QGxpbmsgcmVzZXR9LiAqL1xyXG4gICAgcHVibGljIHRyYW5zaXQoX3RvOiBBbmltYXRpb25Ob2RlLCBfZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBfdG8ucmVzZXQoKTtcclxuICAgICAgaWYgKHRoaXMudG8pXHJcbiAgICAgICAgdGhpcy5mcm9tID0gbmV3IEFuaW1hdGlvbk5vZGVBbmltYXRpb24odGhpcy5tdXRhdG9yKTtcclxuICAgICAgdGhpcy50byA9IF90bztcclxuICAgICAgdGhpcy5kdXJhdGlvbiA9IF9kdXJhdGlvbjtcclxuICAgICAgdGhpcy50aW1lID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlKF9kZWx0YVRpbWU6IG51bWJlciwgX3Bvc2U6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgX2RlbHRhVGltZSAqPSB0aGlzLnNwZWVkO1xyXG5cclxuICAgICAgdGhpcy50aW1lICs9IF9kZWx0YVRpbWU7XHJcblxyXG4gICAgICB0aGlzLmZyb20udXBkYXRlKF9kZWx0YVRpbWUpO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLnRvKSB7XHJcbiAgICAgICAgdGhpcy5tdXRhdG9yID0gdGhpcy5mcm9tLm11dGF0b3I7XHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmZyb20uZXZlbnRzO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy50by51cGRhdGUoX2RlbHRhVGltZSk7XHJcblxyXG4gICAgICBsZXQgcHJvZ3Jlc3M6IG51bWJlciA9IE1hdGgubWluKHRoaXMudGltZSAvIHRoaXMuZHVyYXRpb24sIDEpO1xyXG5cclxuICAgICAgbGV0IGZyb206IE11dGF0b3IgPSB0aGlzLmZyb20ubXV0YXRvciA/PyBfcG9zZTtcclxuICAgICAgbGV0IHRvOiBNdXRhdG9yID0gdGhpcy50by5tdXRhdG9yID8/IF9wb3NlO1xyXG5cclxuICAgICAgaWYgKGZyb20gPT0gdG8pIHtcclxuICAgICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5tdXRhdG9yID0gQW5pbWF0aW9uLmJsZW5kT3ZlcnJpZGUoZnJvbSwgdG8sIHByb2dyZXNzLCBmcm9tID09IF9wb3NlIHx8IHRvID09IF9wb3NlKTtcclxuICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLnRvLmV2ZW50cztcclxuXHJcbiAgICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XHJcbiAgICAgICAgdGhpcy5mcm9tID0gdGhpcy50bztcclxuICAgICAgICB0aGlzLnRvID0gbnVsbDtcclxuICAgICAgICB0aGlzLmR1cmF0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRpbWUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQSBzZXF1ZW5jZSBvZiB7QGxpbmsgQW5pbWF0aW9uS2V5fXMgdGhhdCBpcyBtYXBwZWQgdG8gYW4gYXR0cmlidXRlIG9mIGEge0BsaW5rIE5vZGV9IG9yIGl0cyB7QGxpbmsgQ29tcG9uZW50fXMgaW5zaWRlIHRoZSB7QGxpbmsgQW5pbWF0aW9ufS5cclxuICAgKiBQcm92aWRlcyBmdW5jdGlvbnMgdG8gbW9kaWZ5IHNhaWQga2V5c1xyXG4gICAqIEBhdXRob3JzIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5IHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIyXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvblNlcXVlbmNlIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICBwcml2YXRlIGtleXM6IEFuaW1hdGlvbktleVtdO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihfa2V5czogQW5pbWF0aW9uS2V5W10gPSBbXSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmtleXMgPSBfa2V5cztcclxuICAgICAgdGhpcy5yZWdlbmVyYXRlRnVuY3Rpb25zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBsZW5ndGgoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMua2V5cy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFdmFsdWF0ZXMgdGhlIHNlcXVlbmNlIGF0IHRoZSBnaXZlbiBwb2ludCBpbiB0aW1lLlxyXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSBwb2ludCBpbiB0aW1lIGF0IHdoaWNoIHRvIGV2YWx1YXRlIHRoZSBzZXF1ZW5jZSBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHNlcXVlbmNlIGF0IHRoZSBnaXZlbiB0aW1lLiB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIGtleXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBldmFsdWF0ZShfdGltZTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMua2V5cy5sZW5ndGggPT0gMClcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvL1RPRE86IHNob3VsZG4ndCByZXR1cm4gMCBidXQgc29tZXRoaW5nIGluZGljYXRpbmcgbm8gY2hhbmdlLCBsaWtlIG51bGwuIHByb2JhYmx5IG5lZWRzIHRvIGJlIGNoYW5nZWQgaW4gTm9kZSBhcyB3ZWxsIHRvIGlnbm9yZSBub24tbnVtZXJpYyB2YWx1ZXMgaW4gdGhlIGFwcGx5QW5pbWF0aW9uIGZ1bmN0aW9uXHJcbiAgICAgIGlmICh0aGlzLmtleXMubGVuZ3RoID09IDEgfHwgdGhpcy5rZXlzWzBdLnRpbWUgPj0gX3RpbWUpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5c1swXS52YWx1ZTtcclxuXHJcblxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgIGlmICh0aGlzLmtleXNbaV0udGltZSA8PSBfdGltZSAmJiBfdGltZSA8IHRoaXMua2V5c1tpICsgMV0udGltZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMua2V5c1tpXS5mdW5jdGlvbk91dC5ldmFsdWF0ZShfdGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmICh0aGlzLmtleXNbaV0udGltZSA9PSBfdGltZSlcclxuICAgICAgICAvLyAgIHJldHVybiB0aGlzLmtleXNbaV0udmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMua2V5c1t0aGlzLmtleXMubGVuZ3RoIC0gMV0udmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IGtleSB0byB0aGUgc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gX2tleSB0aGUga2V5IHRvIGFkZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkS2V5KF9rZXk6IEFuaW1hdGlvbktleSk6IHZvaWQge1xyXG4gICAgICB0aGlzLmtleXMucHVzaChfa2V5KTtcclxuICAgICAgdGhpcy5rZXlzLnNvcnQoQW5pbWF0aW9uS2V5LmNvbXBhcmUpO1xyXG4gICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmeXMgYSBnaXZlbiBrZXkgaW4gdGhlIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIF9rZXkgdGhlIGtleSB0byBhZGRcclxuICAgICAqL1xyXG4gICAgcHVibGljIG1vZGlmeUtleShfa2V5OiBBbmltYXRpb25LZXksIF90aW1lPzogbnVtYmVyLCBfdmFsdWU/OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgaWYgKF90aW1lICE9IG51bGwpXHJcbiAgICAgICAgX2tleS50aW1lID0gX3RpbWU7XHJcbiAgICAgIGlmIChfdmFsdWUgIT0gbnVsbClcclxuICAgICAgICBfa2V5LnZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICB0aGlzLmtleXMuc29ydChBbmltYXRpb25LZXkuY29tcGFyZSk7XHJcbiAgICAgIHRoaXMucmVnZW5lcmF0ZUZ1bmN0aW9ucygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGdpdmVuIGtleSBmcm9tIHRoZSBzZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSBfa2V5IHRoZSBrZXkgdG8gcmVtb3ZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVLZXkoX2tleTogQW5pbWF0aW9uS2V5KTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAodGhpcy5rZXlzW2ldID09IF9rZXkpIHtcclxuICAgICAgICAgIHRoaXMua2V5cy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgYSBrZXkgaW4gdGhlIHNlcXVlbmNlIGV4YWN0bHkgbWF0Y2hpbmcgdGhlIGdpdmVuIHRpbWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBmaW5kS2V5KF90aW1lOiBudW1iZXIpOiBBbmltYXRpb25LZXkge1xyXG4gICAgICBmb3IgKGxldCBrZXkgb2YgdGhpcy5rZXlzKVxyXG4gICAgICAgIGlmIChrZXkudGltZSA9PSBfdGltZSlcclxuICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgQW5pbWF0aW9uIEtleSBhdCB0aGUgZ2l2ZW4gaW5kZXggZnJvbSB0aGUga2V5cy5cclxuICAgICAqIEBwYXJhbSBfaW5kZXggdGhlIHplcm8tYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gcmVtb3ZlIHRoZSBrZXlcclxuICAgICAqIEByZXR1cm5zIHRoZSByZW1vdmVkIEFuaW1hdGlvbktleSBpZiBzdWNjZXNzZnVsLCBudWxsIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUtleUF0SW5kZXgoX2luZGV4OiBudW1iZXIpOiBBbmltYXRpb25LZXkge1xyXG4gICAgICBpZiAoX2luZGV4IDwgMCB8fCBfaW5kZXggPj0gdGhpcy5rZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBhazogQW5pbWF0aW9uS2V5ID0gdGhpcy5rZXlzW19pbmRleF07XHJcbiAgICAgIHRoaXMua2V5cy5zcGxpY2UoX2luZGV4LCAxKTtcclxuICAgICAgdGhpcy5yZWdlbmVyYXRlRnVuY3Rpb25zKCk7XHJcbiAgICAgIHJldHVybiBhaztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBrZXkgZnJvbSB0aGUgc2VxdWVuY2UgYXQgdGhlIGRlc2lyZWQgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0gX2luZGV4IHRoZSB6ZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIGdldCB0aGUga2V5XHJcbiAgICAgKiBAcmV0dXJucyB0aGUgQW5pbWF0aW9uS2V5IGF0IHRoZSBpbmRleCBpZiBpdCBleGlzdHMsIG51bGwgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0S2V5KF9pbmRleDogbnVtYmVyKTogQW5pbWF0aW9uS2V5IHtcclxuICAgICAgaWYgKF9pbmRleCA8IDAgfHwgX2luZGV4ID49IHRoaXMua2V5cy5sZW5ndGgpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIHJldHVybiB0aGlzLmtleXNbX2luZGV4XTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBzZXF1ZW5jZSdzIGtleXMuIFRoaXMgaXMgbm90IGEgY29weSwgYnV0IHRoZSBhY3R1YWwgYXJyYXkgdXNlZCBpbnRlcm5hbGx5LiBIYW5kbGUgd2l0aCBjYXJlIVxyXG4gICAgICogVXNlZCBieSBFZGl0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRLZXlzKCk6IEFuaW1hdGlvbktleVtdIHtcclxuICAgICAgcmV0dXJuIHRoaXMua2V5cztcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gdHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGtleXM6IFtdLFxyXG4gICAgICAgIGFuaW1hdGlvblNlcXVlbmNlOiB0cnVlXHJcbiAgICAgIH07XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzLmtleXNbaV0gPSB0aGlzLmtleXNbaV0uc2VyaWFsaXplKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF9zZXJpYWxpemF0aW9uLmtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyB0aGlzLmtleXMucHVzaCg8QW5pbWF0aW9uS2V5PlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ua2V5c1tpXSkpO1xyXG4gICAgICAgIGxldCBrOiBBbmltYXRpb25LZXkgPSBuZXcgQW5pbWF0aW9uS2V5KCk7XHJcbiAgICAgICAgYXdhaXQgay5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5rZXlzW2ldKTtcclxuICAgICAgICB0aGlzLmtleXNbaV0gPSBrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgeyAvKiAqLyB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdGhhdCAocmUtKWdlbmVyYXRlcyBhbGwgZnVuY3Rpb25zIGluIHRoZSBzZXF1ZW5jZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZWdlbmVyYXRlRnVuY3Rpb25zKCk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGY6IEFuaW1hdGlvbkZ1bmN0aW9uID0gbmV3IEFuaW1hdGlvbkZ1bmN0aW9uKHRoaXMua2V5c1tpXSk7XHJcbiAgICAgICAgdGhpcy5rZXlzW2ldLmZ1bmN0aW9uT3V0ID0gZjtcclxuICAgICAgICBpZiAoaSA9PSB0aGlzLmtleXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgLy9UT0RPOiBjaGVjayBpZiB0aGlzIGlzIGV2ZW4gdXNlZnVsLiBNYXliZSB1cGRhdGUgdGhlIHJ1bmNvbmRpdGlvbiB0byBsZW5ndGggLSAxIGluc3RlYWQuIE1pZ2h0IGJlIHJlZHVuZGFudCBpZiBmdW5jdGlvbkluIGlzIHJlbW92ZWQsIHNlZSBUT0RPIGluIEFuaW1hdGlvbktleS5cclxuICAgICAgICAgIGYuc2V0S2V5T3V0ID0gdGhpcy5rZXlzWzBdO1xyXG4gICAgICAgICAgdGhpcy5rZXlzWzBdLmZ1bmN0aW9uSW4gPSBmO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGYuc2V0S2V5T3V0ID0gdGhpcy5rZXlzW2kgKyAxXTtcclxuICAgICAgICB0aGlzLmtleXNbaSArIDFdLmZ1bmN0aW9uSW4gPSBmO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgQGVudW1lcmF0ZVxyXG4gIGV4cG9ydCBjbGFzcyBBbmltYXRpb25TcHJpdGUgZXh0ZW5kcyBBbmltYXRpb24ge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IEFuaW1hdGlvbi5yZWdpc3RlclN1YmNsYXNzKEFuaW1hdGlvblNwcml0ZSk7XHJcbiAgICBwcml2YXRlIGZyYW1lczogbnVtYmVyID0gMjU7XHJcbiAgICBwcml2YXRlIHdyYXBBZnRlcjogbnVtYmVyID0gNTtcclxuICAgIHByaXZhdGUgc3RhcnQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMigwLCAwKTtcclxuICAgIHByaXZhdGUgc2l6ZTogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKDgwLCA4MCk7XHJcbiAgICBwcml2YXRlIG5leHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMig4MCwgMCk7XHJcbiAgICBwcml2YXRlIHdyYXA6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMigwLCA4MCk7XHJcblxyXG4gICAgI3RleHR1cmU6IFRleHR1cmUgPSBUZXh0dXJlRGVmYXVsdC5jb2xvcjtcclxuXHJcbiAgICAvLyBUT0RPOiBmcHMgc2hvdWxkIGJlIGEgcGFyYW1ldGVyIHRvb1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIkFuaW1hdGlvblNwcml0ZVwiKSB7IC8vfSwgX2ZwczogbnVtYmVyID0gMTUpIHtcclxuICAgICAgc3VwZXIoX25hbWUsIHt9LCAxKTtcclxuICAgICAgdGhpcy5mcmFtZXNQZXJTZWNvbmQgPSB0aGlzLmZyYW1lcztcclxuICAgICAgdGhpcy5jcmVhdGUodGhpcy50ZXh0dXJlLCB0aGlzLmZyYW1lcywgdGhpcy53cmFwQWZ0ZXIsIHRoaXMuc3RhcnQsIHRoaXMuc2l6ZSwgdGhpcy5uZXh0LCB0aGlzLndyYXAsIHRoaXMuZnJhbWVzUGVyU2Vjb25kKTtcclxuICAgIH1cclxuXHJcbiAgICBAZW51bWVyYXRlXHJcbiAgICBAdHlwZShUZXh0dXJlKVxyXG4gICAgcHVibGljIGdldCB0ZXh0dXJlKCk6IFRleHR1cmUge1xyXG4gICAgICByZXR1cm4gdGhpcy4jdGV4dHVyZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdGV4dHVyZSB0byBiZSB1c2VkIGFzIHRoZSBzcHJpdGVzaGVldFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IHRleHR1cmUoX3RleHR1cmU6IFRleHR1cmUpIHtcclxuICAgICAgdGhpcy4jdGV4dHVyZSA9IF90ZXh0dXJlO1xyXG4gICAgICB0aGlzLmNyZWF0ZSh0aGlzLnRleHR1cmUsIHRoaXMuZnJhbWVzLCB0aGlzLndyYXBBZnRlciwgdGhpcy5zdGFydCwgdGhpcy5zaXplLCB0aGlzLm5leHQsIHRoaXMud3JhcCwgdGhpcy5mcmFtZXNQZXJTZWNvbmQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGlzIGFuaW1hdGlvbiBzcHJpdGUgZnJvbSB0aGUgZ2l2ZW4gYXJndW1lbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGUoX3RleHR1cmU6IFRleHR1cmUsIF9mcmFtZXM6IG51bWJlciwgX3dyYXBBZnRlcjogbnVtYmVyLCBfc3RhcnQ6IFZlY3RvcjIsIF9zaXplOiBWZWN0b3IyLCBfbmV4dDogVmVjdG9yMiwgX3dyYXA6IFZlY3RvcjIsIF9mcmFtZXNQZXJTZWNvbmQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLiN0ZXh0dXJlID0gX3RleHR1cmU7XHJcbiAgICAgIHRoaXMuZnJhbWVzID0gX2ZyYW1lcztcclxuICAgICAgdGhpcy53cmFwQWZ0ZXIgPSBfd3JhcEFmdGVyO1xyXG4gICAgICB0aGlzLnN0YXJ0ID0gX3N0YXJ0O1xyXG4gICAgICB0aGlzLnNpemUgPSBfc2l6ZTtcclxuICAgICAgdGhpcy5uZXh0ID0gX25leHQ7XHJcbiAgICAgIHRoaXMud3JhcCA9IF93cmFwO1xyXG4gICAgICB0aGlzLmZyYW1lc1BlclNlY29uZCA9IF9mcmFtZXNQZXJTZWNvbmQ7XHJcblxyXG4gICAgICBsZXQgc2NhbGU6IFZlY3RvcjIgPSB0aGlzLmdldFNjYWxlKCk7XHJcbiAgICAgIGxldCBwb3NpdGlvbnM6IFZlY3RvcjJbXSA9IHRoaXMuZ2V0UG9zaXRpb25zKCk7XHJcblxyXG4gICAgICBsZXQgeFRyYW5zbGF0aW9uOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xyXG4gICAgICBsZXQgeVRyYW5zbGF0aW9uOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xyXG4gICAgICBsZXQgeFNjYWxlOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xyXG4gICAgICBsZXQgeVNjYWxlOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xyXG4gICAgICB4U2NhbGUuYWRkS2V5KG5ldyBBbmltYXRpb25LZXkoMCwgc2NhbGUueCkpO1xyXG4gICAgICB5U2NhbGUuYWRkS2V5KG5ldyBBbmltYXRpb25LZXkoMCwgc2NhbGUueSkpO1xyXG5cclxuICAgICAgZm9yIChsZXQgZnJhbWU6IG51bWJlciA9IDA7IGZyYW1lIDw9IHRoaXMuZnJhbWVzOyBmcmFtZSsrKSB7XHJcbiAgICAgICAgbGV0IHRpbWU6IG51bWJlciA9IDEwMDAgKiBmcmFtZSAvIHRoaXMuZnJhbWVzUGVyU2Vjb25kO1xyXG4gICAgICAgIGxldCBwb3NpdGlvbjogVmVjdG9yMiA9IHBvc2l0aW9uc1tNYXRoLm1pbihmcmFtZSwgdGhpcy5mcmFtZXMgLSAxKV07IC8vcmVwZWF0IHRoZSBsYXN0IGtleSB0byBnaXZlIHRoZSBsYXN0IGZyYW1lIHNvbWUgdGltZVxyXG4gICAgICAgIHhUcmFuc2xhdGlvbi5hZGRLZXkobmV3IEFuaW1hdGlvbktleSh0aW1lLCBwb3NpdGlvbi54IC8gdGhpcy4jdGV4dHVyZS50ZXhJbWFnZVNvdXJjZS53aWR0aCkpOy8vLCAwLCAwLCB0cnVlKSlcclxuICAgICAgICB5VHJhbnNsYXRpb24uYWRkS2V5KG5ldyBBbmltYXRpb25LZXkodGltZSwgcG9zaXRpb24ueSAvIHRoaXMuI3RleHR1cmUudGV4SW1hZ2VTb3VyY2UuaGVpZ2h0KSk7Ly8sIDAsIDAsIHRydWUpKVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSA9IHtcclxuICAgICAgICBcImNvbXBvbmVudHNcIjoge1xyXG4gICAgICAgICAgXCJDb21wb25lbnRNYXRlcmlhbFwiOiBbe1xyXG4gICAgICAgICAgICBcIm10eFBpdm90XCI6IHtcclxuICAgICAgICAgICAgICBcInRyYW5zbGF0aW9uXCI6IHtcclxuICAgICAgICAgICAgICAgIHg6IHhUcmFuc2xhdGlvbixcclxuICAgICAgICAgICAgICAgIHk6IHlUcmFuc2xhdGlvblxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgXCJzY2FsaW5nXCI6IHtcclxuICAgICAgICAgICAgICAgIHg6IHhTY2FsZSxcclxuICAgICAgICAgICAgICAgIHk6IHlTY2FsZVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfV1cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsVGltZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2NhbGUgb2YgdGhlIHNwcml0ZXNoZWV0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTY2FsZSgpOiBWZWN0b3IyIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIHRoaXMuc2l6ZS54IC8gdGhpcy4jdGV4dHVyZS50ZXhJbWFnZVNvdXJjZS53aWR0aCxcclxuICAgICAgICB0aGlzLnNpemUueSAvIHRoaXMuI3RleHR1cmUudGV4SW1hZ2VTb3VyY2UuaGVpZ2h0XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbnMgb2YgdGhlIHNwcml0ZXNoZWV0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQb3NpdGlvbnMoKTogVmVjdG9yMltdIHtcclxuICAgICAgbGV0IGlOZXh0OiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgaVdyYXA6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCBwb3NpdGlvbnM6IFZlY3RvcjJbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBmcmFtZTogbnVtYmVyID0gMDsgZnJhbWUgPCB0aGlzLmZyYW1lczsgZnJhbWUrKykge1xyXG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKG5ldyBWZWN0b3IyKFxyXG4gICAgICAgICAgdGhpcy5zdGFydC54ICsgaU5leHQgKiB0aGlzLm5leHQueCArIGlXcmFwICogdGhpcy53cmFwLngsXHJcbiAgICAgICAgICB0aGlzLnN0YXJ0LnkgKyBpTmV4dCAqIHRoaXMubmV4dC55ICsgaVdyYXAgKiB0aGlzLndyYXAueVxyXG4gICAgICAgICkpO1xyXG5cclxuICAgICAgICBpTmV4dCsrO1xyXG4gICAgICAgIGlmIChpTmV4dCA+PSB0aGlzLndyYXBBZnRlcikge1xyXG4gICAgICAgICAgaU5leHQgPSAwO1xyXG4gICAgICAgICAgaVdyYXArKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHBvc2l0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gdHJhbnNmZXJcclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb24/OiBzdHJpbmdbXSwgX2Rpc3BhdGNoTXV0YXRlPzogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IsIF9zZWxlY3Rpb24sIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKHRoaXMudGV4dHVyZSwgdGhpcy5mcmFtZXMsIHRoaXMud3JhcEFmdGVyLCB0aGlzLnN0YXJ0LCB0aGlzLnNpemUsIHRoaXMubmV4dCwgdGhpcy53cmFwLCB0aGlzLmZyYW1lc1BlclNlY29uZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pZFJlc291cmNlID0gdGhpcy5pZFJlc291cmNlO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmlkVGV4dHVyZSA9IHRoaXMuI3RleHR1cmUuaWRSZXNvdXJjZTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5mcmFtZXMgPSB0aGlzLmZyYW1lcztcclxuICAgICAgc2VyaWFsaXphdGlvbi53cmFwQWZ0ZXIgPSB0aGlzLndyYXBBZnRlcjtcclxuICAgICAgZm9yIChsZXQgbmFtZSBvZiBbXCJzdGFydFwiLCBcInNpemVcIiwgXCJuZXh0XCIsIFwid3JhcFwiXSlcclxuICAgICAgICBzZXJpYWxpemF0aW9uW25hbWVdID0gKDxWZWN0b3IyPlJlZmxlY3QuZ2V0KHRoaXMsIG5hbWUpKS5zZXJpYWxpemUoKTtcclxuXHJcbiAgICAgIGxldCBhbmltYXRpb25zU3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZTtcclxuICAgICAgdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUgPSB7fTsgLy8gbm8gbmVlZCB0byBzZXJpYWxpemUgc3RydWN0dXJlXHJcbiAgICAgIC8vIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUgPSBhbmltYXRpb25zU3RydWN0dXJlOyAvLyByZXN0b3JlIGV4aXN0ZW50IHN0cnVjdHVyZVxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi5pZFRleHR1cmUpXHJcbiAgICAgICAgdGhpcy4jdGV4dHVyZSA9IDxUZXh0dXJlPmF3YWl0IFByb2plY3QuZ2V0UmVzb3VyY2UoX3NlcmlhbGl6YXRpb24uaWRUZXh0dXJlKTtcclxuXHJcbiAgICAgIGZvciAobGV0IG5hbWUgb2YgW1wic3RhcnRcIiwgXCJzaXplXCIsIFwibmV4dFwiLCBcIndyYXBcIl0pXHJcbiAgICAgICAgKDxWZWN0b3IyPlJlZmxlY3QuZ2V0KHRoaXMsIG5hbWUpKS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltuYW1lXSk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKHRoaXMudGV4dHVyZSwgX3NlcmlhbGl6YXRpb24uZnJhbWVzLCBfc2VyaWFsaXphdGlvbi53cmFwQWZ0ZXIsIHRoaXMuc3RhcnQsIHRoaXMuc2l6ZSwgdGhpcy5uZXh0LCB0aGlzLndyYXAsIHRoaXMuZnJhbWVzUGVyU2Vjb25kKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSB7QGxpbmsgQW5pbWF0aW9uU3ByaXRlfSBpbnRvIGFuIHtAbGluayBBbmltYXRpb259XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb252ZXJ0VG9BbmltYXRpb24oKTogQW5pbWF0aW9uIHtcclxuICAgICAgbGV0IGFuaW1hdGlvbjogQW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih0aGlzLm5hbWUsIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlLCB0aGlzLmZyYW1lc1BlclNlY29uZCk7XHJcbiAgICAgIHJldHVybiBhbmltYXRpb247XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRXh0ZW5zaW9uIG9mIEF1ZGlvQnVmZmVyIHdpdGggYSBsb2FkIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSBidWZmZXIgaW4gdGhlIHtAbGluayBBdWRpb01hbmFnZXJ9LmRlZmF1bHQgdG8gYmUgdXNlZCB3aXRoIHtAbGluayBDb21wb25lbnRBdWRpb31cclxuICAgKiBAYXV0aG9ycyBUaG9tYXMgRG9ybmVyLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMFxyXG4gICAqL1xyXG4gIEBTZXJpYWxpemFibGVSZXNvdXJjZS5yZWdpc3RlclxyXG4gIGV4cG9ydCBjbGFzcyBBdWRpbyBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nID0gXCJBdWRpb1wiO1xyXG4gICAgcHVibGljIGlkUmVzb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuICAgIHB1YmxpYyBidWZmZXI6IEF1ZGlvQnVmZmVyID0gdW5kZWZpbmVkO1xyXG4gICAgcHVibGljIHBhdGg6IFVSTCA9IHVuZGVmaW5lZDtcclxuICAgIHByaXZhdGUgdXJsOiBSZXF1ZXN0SW5mbyA9IHVuZGVmaW5lZDtcclxuICAgIHByaXZhdGUgcmVhZHk6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3VybD86IFJlcXVlc3RJbmZvKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIGlmIChfdXJsKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkKF91cmwpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IF91cmwudG9TdHJpbmcoKS5zcGxpdChcIi9cIikucG9wKCk7XHJcbiAgICAgIH1cclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzUmVhZHkoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnJlYWR5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXN5bmNocm9ub3VzbHkgbG9hZHMgdGhlIGF1ZGlvIChtcDMpIGZyb20gdGhlIGdpdmVuIHVybFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZChfdXJsOiBSZXF1ZXN0SW5mbyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBEZWJ1Zy5mdWRnZShcIkF1ZGlvTG9hZFwiLCBfdXJsKTtcclxuICAgICAgdGhpcy51cmwgPSBfdXJsO1xyXG4gICAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XHJcbiAgICAgIHRoaXMucGF0aCA9IG5ldyBVUkwodGhpcy51cmwudG9TdHJpbmcoKSwgUHJvamVjdC5iYXNlVVJMKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2U6IFJlc3BvbnNlID0gYXdhaXQgd2luZG93LmZldGNoKHRoaXMucGF0aC50b1N0cmluZygpKTtcclxuICAgICAgY29uc3QgYXJyYXlCdWZmZXI6IEFycmF5QnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcclxuICAgICAgbGV0IGJ1ZmZlcjogQXVkaW9CdWZmZXIgPSBhd2FpdCBBdWRpb01hbmFnZXIuZGVmYXVsdC5kZWNvZGVBdWRpb0RhdGEoYXJyYXlCdWZmZXIpO1xyXG4gICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uUkVBRFkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdXJsOiB0aGlzLnVybCxcclxuICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2UsXHJcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzLCBfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlKTtcclxuICAgICAgYXdhaXQgdGhpcy5sb2FkKF9zZXJpYWxpemF0aW9uLnVybCk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb24/OiBzdHJpbmdbXSwgX2Rpc3BhdGNoTXV0YXRlPzogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBsZXQgdXJsOiBzdHJpbmcgPSBfbXV0YXRvci51cmw7IC8vIHNhdmUgdXJsIGZvciByZWNvbnN0cnVjdGlvbiBhZnRlciBleGNsdXNpb25cclxuICAgICAgaWYgKF9tdXRhdG9yLnVybCAhPSB0aGlzLnVybC50b1N0cmluZygpKVxyXG4gICAgICAgIHRoaXMubG9hZChfbXV0YXRvci51cmwpO1xyXG4gICAgICAvLyBleGNlcHQgdXJsIGZyb20gbXV0YXRvciBmb3IgZnVydGhlciBwcm9jZXNzaW5nXHJcbiAgICAgIGRlbGV0ZSAoX211dGF0b3IudXJsKTtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yLCBfc2VsZWN0aW9uLCBfZGlzcGF0Y2hNdXRhdGUpO1xyXG4gICAgICAvLyByZWNvbnN0cnVjdCwgZm9yIG11dGF0b3IgbWF5IGJlIGtlcHQgYnkgY2FsbGVyXHJcbiAgICAgIFJlZmxlY3Quc2V0KF9tdXRhdG9yLCBcInVybFwiLCB1cmwpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIC8vIGRlbGV0ZSBfbXV0YXRvci5pZFJlc291cmNlOyBcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnJlYWR5O1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfQVVESU8ge1xyXG4gICAgLyoqIGJyb2FkY2FzdCB0byBhIHtAbGluayBOb2RlfSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cyBpbiB0aGUgZ3JhcGggYWZ0ZXIgaXQgd2FzIGFwcGVuZGVkIHRvIGEgcGFyZW50ICovXHJcbiAgICBDSElMRF9BUFBFTkQgPSBcImNoaWxkQXBwZW5kVG9BdWRpb0dyYXBoXCIsXHJcbiAgICAvKiogYnJvYWRjYXN0IHRvIGEge0BsaW5rIE5vZGV9IGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzIGluIHRoZSBncmFwaCBqdXN0IGJlZm9yZSBpdHMgYmVpbmcgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgKi9cclxuICAgIENISUxEX1JFTU9WRSA9IFwiY2hpbGRSZW1vdmVGcm9tQXVkaW9HcmFwaFwiLFxyXG4gICAgLyoqIGJyb2FkY2FzdCB0byBhIHtAbGluayBOb2RlfSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cyBpbiB0aGUgZ3JhcGggdG8gdXBkYXRlIHRoZSBwYW5uZXJzIGluIEF1ZGlvQ29tcG9uZW50cyAqL1xyXG4gICAgVVBEQVRFID0gXCJ1cGRhdGVBdWRpb0dyYXBoXCIsXHJcbiAgICAvKiogZmlyZWQgd2hlbiB0aGUgYXVkaW8gZmlsZSB3YXMgbG9hZGVkIGFuZCBpcyByZWFkeSBmb3IgcGxheWluZyAqL1xyXG4gICAgUkVBRFkgPSBcInJlYWR5XCIsXHJcbiAgICAvKiogZmlyZWQgd2hlbiB0aGUgZW5kIG9mIHRoZSBhdWRpbyBpcyByZWFjaGVkIHdoaWxlIHBsYXlpbmcgKi9cclxuICAgIEVOREVEID0gXCJlbmRlZFwiXHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi4vRXZlbnQvRXZlbnRBdWRpby50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRXh0ZW5kcyB0aGUgc3RhbmRhcmQgQXVkaW9Db250ZXh0IGZvciBpbnRlZ3JhdGlvbiB3aXRoIEZVREdFLWdyYXBocy5cclxuICAgKiBDcmVhdGVzIGEgZGVmYXVsdCBvYmplY3QgYXQgc3RhcnR1cCB0byBiZSBhZGRyZXNzZWQgYXMgQXVkaW9NYW5hZ2VyIGRlZmF1bHQuXHJcbiAgICogT3RoZXIgb2JqZWN0cyBvZiB0aGlzIGNsYXNzIG1heSBiZSBjcmVhdGUgZm9yIHNwZWNpYWwgcHVycG9zZXMuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEF1ZGlvTWFuYWdlciBleHRlbmRzIEF1ZGlvQ29udGV4dCB7XHJcbiAgICAvKiogVGhlIGRlZmF1bHQgY29udGV4dCB0aGF0IG1heSBiZSB1c2VkIHRocm91Z2hvdXQgdGhlIHByb2plY3Qgd2l0aG91dCB0aGUgbmVlZCB0byBjcmVhdGUgb3RoZXJzICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGRlZmF1bHQ6IEF1ZGlvTWFuYWdlciA9IG5ldyBBdWRpb01hbmFnZXIoeyBsYXRlbmN5SGludDogXCJpbnRlcmFjdGl2ZVwiLCBzYW1wbGVSYXRlOiA0NDEwMCB9KTtcclxuICAgIHByaXZhdGUgc3RhdGljIGV2ZW50VXBkYXRlOiBFdmVudCA9IG5ldyBFdmVudChFVkVOVF9BVURJTy5VUERBVEUpO1xyXG4gICAgLyoqIFRoZSBtYXN0ZXIgdm9sdW1lIGFsbCBBdWRpb05vZGVzIGluIHRoZSBjb250ZXh0IHNob3VsZCBhdHRhY2ggdG8gKi9cclxuICAgIHB1YmxpYyByZWFkb25seSBnYWluOiBHYWluTm9kZTtcclxuICAgIHByaXZhdGUgZ3JhcGg6IE5vZGUgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBjbXBMaXN0ZW5lcjogQ29tcG9uZW50QXVkaW9MaXN0ZW5lciA9IG51bGw7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9jb250ZXh0T3B0aW9ucz86IEF1ZGlvQ29udGV4dE9wdGlvbnMpIHtcclxuICAgICAgc3VwZXIoX2NvbnRleHRPcHRpb25zKTtcclxuICAgICAgdGhpcy5nYWluID0gdGhpcy5jcmVhdGVHYWluKCk7XHJcbiAgICAgIHRoaXMuZ2Fpbi5jb25uZWN0KHRoaXMuZGVzdGluYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtYXN0ZXIgdm9sdW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgdm9sdW1lKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtYXN0ZXIgdm9sdW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgdm9sdW1lKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgRlVER0UtZ3JhcGggdG8gbGlzdGVuIHRvLiBFYWNoIHtAbGluayBDb21wb25lbnRBdWRpb30gaW4gdGhlIGdyYXBoIHdpbGwgY29ubmVjdCB0byB0aGlzIGNvbnRleHRzIG1hc3RlciBnYWluLCBhbGwgb3RoZXJzIGRpc2Nvbm5lY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsaXN0ZW5UbyA9IChfZ3JhcGg6IE5vZGUgfCBudWxsKTogdm9pZCA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmdyYXBoKVxyXG4gICAgICAgIHRoaXMuZ3JhcGguYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSkpO1xyXG4gICAgICBpZiAoIV9ncmFwaClcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIHRoaXMuZ3JhcGggPSBfZ3JhcGg7XHJcbiAgICAgIHRoaXMuZ3JhcGguYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLkNISUxEX0FQUEVORCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBGVURHRS1ncmFwaCBjdXJyZW50bHkgbGlzdGVuaW5nIHRvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRHcmFwaExpc3RlbmluZ1RvID0gKCk6IE5vZGUgPT4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5ncmFwaDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHtAbGluayBDb21wb25lbnRBdWRpb0xpc3RlbmVyfSB0aGF0IHNlcnZlcyB0aGUgc3BhdGlhbCBsb2NhdGlvbiBhbmQgb3JpZW50YXRpb24gZm9yIHRoaXMgY29udGV4dHMgbGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxpc3RlbldpdGggPSAoX2NtcExpc3RlbmVyOiBDb21wb25lbnRBdWRpb0xpc3RlbmVyIHwgbnVsbCk6IHZvaWQgPT4ge1xyXG4gICAgICB0aGlzLmNtcExpc3RlbmVyID0gX2NtcExpc3RlbmVyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHNwYXRpYWwgc2V0dGluZ3Mgb2YgdGhlIEF1ZGlvTm9kZXMgZWZmZWN0ZWQgaW4gdGhlIGN1cnJlbnQgRlVER0UtZ3JhcGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgaWYgKHRoaXMuc3RhdGUgIT0gXCJydW5uaW5nXCIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICAvLyB0aGlzLmdyYXBoLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVF9BVURJTy5VUERBVEUpKTtcclxuICAgICAgdGhpcy5ncmFwaC5icm9hZGNhc3RFdmVudChBdWRpb01hbmFnZXIuZXZlbnRVcGRhdGUpO1xyXG4gICAgICBpZiAodGhpcy5jbXBMaXN0ZW5lcilcclxuICAgICAgICB0aGlzLmNtcExpc3RlbmVyLnVwZGF0ZSh0aGlzLmxpc3RlbmVyKTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwiLy8gbmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgICBcclxuLy8gICAgIC8qKlxyXG4vLyAgICAgICogRW51bWVyYXRvciBmb3IgYWxsIHBvc3NpYmxlIE9zY2lsbGF0b3IgVHlwZXNcclxuLy8gICAgICAqL1xyXG4vLyAgICAgdHlwZSBPU0NJTExBVE9SX1RZUEUgPSBcInNpbmVcIiB8IFwic3F1YXJlXCIgfCBcInNhd3Rvb3RoXCIgfCBcInRyaWFuZ2xlXCIgfCBcImN1c3RvbVwiO1xyXG5cclxuLy8gICAgIC8qKlxyXG4vLyAgICAgICogSW50ZXJmYWNlIHRvIGNyZWF0ZSBDdXN0b20gT3NjaWxsYXRvciBUeXBlcy5cclxuLy8gICAgICAqIFN0YXJ0LS9FbmRwb2ludCBvZiBhIGN1c3R1bSBjdXJ2ZSBlLmcuIHNpbmUgY3VydmUuXHJcbi8vICAgICAgKiBCb3RoIHBhcmFtZXRlcnMgbmVlZCB0byBiZSBpbmJldHdlZW4gLTEgYW5kIDEuXHJcbi8vICAgICAgKiBAcGFyYW0gc3RhcnRwb2ludCBzdGFydHBvaW50IG9mIGEgY3VydmUgXHJcbi8vICAgICAgKiBAcGFyYW0gZW5kcG9pbnQgRW5kcG9pbnQgb2YgYSBjdXJ2ZSBcclxuLy8gICAgICAqL1xyXG4vLyAgICAgaW50ZXJmYWNlIE9zY2lsbGF0b3JXYXZlIHtcclxuLy8gICAgICAgICBzdGFydHBvaW50OiBudW1iZXI7XHJcbi8vICAgICAgICAgZW5kcG9pbnQ6IG51bWJlcjtcclxuLy8gICAgIH1cclxuLy8gICAgIC8qKlxyXG4vLyAgICAgICogQWRkIGFuIHtAbGluayBBdWRpb0ZpbHRlcn0gdG8gYW4ge0BsaW5rIEF1ZGlvXV1cclxuLy8gICAgICAqIEBhdXRob3JzIFRob21hcyBEb3JuZXIsIEhGVSwgMjAxOVxyXG4vLyAgICAgICovXHJcbi8vICAgICBleHBvcnQgY2xhc3MgQXVkaW9Pc2NpbGxhdG9yIHtcclxuXHJcbi8vICAgICAgICAgcHVibGljIGF1ZGlvT3NjaWxsYXRvcjogT3NjaWxsYXRvck5vZGU7IFxyXG5cclxuLy8gICAgICAgICBwcml2YXRlIGZyZXF1ZW5jeTogbnVtYmVyO1xyXG4vLyAgICAgICAgIHByaXZhdGUgb3NjaWxsYXRvclR5cGU6IE9TQ0lMTEFUT1JfVFlQRTtcclxuLy8gICAgICAgICBwcml2YXRlIG9zY2lsbGF0b3JXYXZlOiBQZXJpb2RpY1dhdmU7XHJcblxyXG4vLyAgICAgICAgIHByaXZhdGUgbG9jYWxHYWluOiBHYWluTm9kZTtcclxuLy8gICAgICAgICBwcml2YXRlIGxvY2FsR2FpblZhbHVlOiBudW1iZXI7XHJcblxyXG4vLyAgICAgICAgIGNvbnN0cnVjdG9yKF9hdWRpb1NldHRpbmdzOiBBdWRpb1NldHRpbmdzLCBfb3NjaWxsYXRvclR5cGU/OiBPU0NJTExBVE9SX1RZUEUpIHtcclxuLy8gICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3IgPSBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jcmVhdGVPc2NpbGxhdG9yKCk7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluID0gX2F1ZGlvU2V0dGluZ3MuZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlR2FpbigpO1xyXG4vLyAgICAgICAgICAgICB0aGlzLm9zY2lsbGF0b3JUeXBlID0gX29zY2lsbGF0b3JUeXBlO1xyXG4vLyAgICAgICAgICAgICBpZiAodGhpcy5vc2NpbGxhdG9yVHlwZSAhPSBcImN1c3RvbVwiKSB7XHJcbi8vICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvci50eXBlID0gdGhpcy5vc2NpbGxhdG9yVHlwZTtcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICBlbHNlIHtcclxuLy8gICAgICAgICAgICAgICAgIGlmICghdGhpcy5vc2NpbGxhdG9yV2F2ZSkge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLnNldFBlcmlvZGljV2F2ZSh0aGlzLm9zY2lsbGF0b3JXYXZlKTtcclxuLy8gICAgICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRlIGEgQ3VzdG9tIFBlcmlvZGljIFdhdmUgZmlyc3QgdG8gdXNlIEN1c3RvbSBUeXBlXCIpO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgc2V0T3NjaWxsYXRvclR5cGUoX29zY2lsbGF0b3JUeXBlOiBPU0NJTExBVE9SX1RZUEUpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgaWYgKHRoaXMub3NjaWxsYXRvclR5cGUgIT0gXCJjdXN0b21cIikge1xyXG4vLyAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3IudHlwZSA9IHRoaXMub3NjaWxsYXRvclR5cGU7XHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgZWxzZSB7XHJcbi8vICAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3NjaWxsYXRvcldhdmUpIHtcclxuLy8gICAgICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvci5zZXRQZXJpb2RpY1dhdmUodGhpcy5vc2NpbGxhdG9yV2F2ZSk7XHJcbi8vICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBnZXRPc2NpbGxhdG9yVHlwZSgpOiBPU0NJTExBVE9SX1RZUEUge1xyXG4vLyAgICAgICAgICAgICByZXR1cm4gdGhpcy5vc2NpbGxhdG9yVHlwZTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBjcmVhdGVQZXJpb2RpY1dhdmUoX2F1ZGlvU2V0dGluZ3M6IEF1ZGlvU2V0dGluZ3MsIF9yZWFsOiBPc2NpbGxhdG9yV2F2ZSwgX2ltYWc6IE9zY2lsbGF0b3JXYXZlKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIGxldCB3YXZlUmVhbDogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuLy8gICAgICAgICAgICAgd2F2ZVJlYWxbMF0gPSBfcmVhbC5zdGFydHBvaW50O1xyXG4vLyAgICAgICAgICAgICB3YXZlUmVhbFsxXSA9IF9yZWFsLmVuZHBvaW50O1xyXG5cclxuLy8gICAgICAgICAgICAgbGV0IHdhdmVJbWFnOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4vLyAgICAgICAgICAgICB3YXZlSW1hZ1swXSA9IF9pbWFnLnN0YXJ0cG9pbnQ7XHJcbi8vICAgICAgICAgICAgIHdhdmVJbWFnWzFdID0gX2ltYWcuZW5kcG9pbnQ7XHJcblxyXG4vLyAgICAgICAgICAgICB0aGlzLm9zY2lsbGF0b3JXYXZlID0gX2F1ZGlvU2V0dGluZ3MuZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlUGVyaW9kaWNXYXZlKHdhdmVSZWFsLCB3YXZlSW1hZyk7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgc2V0TG9jYWxHYWluKF9sb2NhbEdhaW46IEdhaW5Ob2RlKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluID0gX2xvY2FsR2FpbjtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBnZXRMb2NhbEdhaW4oKTogR2Fpbk5vZGUge1xyXG4vLyAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbEdhaW47XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgc2V0TG9jYWxHYWluVmFsdWUoX2xvY2FsR2FpblZhbHVlOiBudW1iZXIpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW5WYWx1ZSA9IF9sb2NhbEdhaW5WYWx1ZTtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW4uZ2Fpbi52YWx1ZSA9IHRoaXMubG9jYWxHYWluVmFsdWU7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgZ2V0TG9jYWxHYWluVmFsdWUoKTogbnVtYmVyIHtcclxuLy8gICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxHYWluVmFsdWU7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgc2V0RnJlcXVlbmN5KF9hdWRpb1NldHRpbmdzOiBBdWRpb1NldHRpbmdzLCBfZnJlcXVlbmN5OiBudW1iZXIpOiB2b2lkIHtcclxuLy8gICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBfZnJlcXVlbmN5O1xyXG4vLyAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvci5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUodGhpcy5mcmVxdWVuY3ksIF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmN1cnJlbnRUaW1lKTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBnZXRGcmVxdWVuY3koKTogbnVtYmVyIHtcclxuLy8gICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJlcXVlbmN5O1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGNyZWF0ZVNuYXJlKF9hdWRpb1NldHRpbmdzOiBBdWRpb1NldHRpbmdzKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIHRoaXMuc2V0T3NjaWxsYXRvclR5cGUoXCJ0cmlhbmdsZVwiKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5zZXRGcmVxdWVuY3koX2F1ZGlvU2V0dGluZ3MsIDEwMCk7XHJcbi8vICAgICAgICAgICAgIHRoaXMuc2V0TG9jYWxHYWluVmFsdWUoMCk7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgX2F1ZGlvU2V0dGluZ3MuZ2V0QXVkaW9Db250ZXh0KCkuY3VycmVudFRpbWUpO1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2Fpbi5nYWluLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUoMC4wMSwgX2F1ZGlvU2V0dGluZ3MuZ2V0QXVkaW9Db250ZXh0KCkuY3VycmVudFRpbWUgKyAuMSk7XHJcblxyXG4vLyAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvci5jb25uZWN0KHRoaXMubG9jYWxHYWluKTtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICB9XHJcbi8vIH0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBdHRhY2hlZCB0byBhIHtAbGluayBOb2RlfSB3aXRoIGFuIGF0dGFjaGVkIHtAbGluayBDb21wb25lbnRDYW1lcmF9IHRoaXMgY2F1c2VzIHRoZSByZW5kZXJlZCBpbWFnZSB0byByZWNlaXZlIGFuIGFtYmllbnQgb2NjbHVzaW9uIGVmZmVjdC5cclxuICAgKiBAYXV0aG9ycyBSb2xhbmQgSGVlciwgSEZVLCAyMDIzIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudEFtYmllbnRPY2NsdXNpb24gZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudEFtYmllbnRPY2NsdXNpb24pO1xyXG5cclxuICAgIHB1YmxpYyBzYW1wbGVSYWRpdXM6IG51bWJlcjtcclxuICAgIHB1YmxpYyBiaWFzOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYXR0ZW51YXRpb25Db25zdGFudDogbnVtYmVyO1xyXG4gICAgcHVibGljIGF0dGVudWF0aW9uTGluZWFyOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYXR0ZW51YXRpb25RdWFkcmF0aWM6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3NhbXBsZVJhZGl1czogbnVtYmVyID0gMTYsIF9iaWFzOiBudW1iZXIgPSAwLjA3LCBfYXR0ZW51YXRpb25Db25zdGFudDogbnVtYmVyID0gMi41LCBfYXR0ZW51YXRpb25MaW5lYXI6IG51bWJlciA9IDEsIF9hdHRlbnVhdGlvblF1YWRyYXRpYzogbnVtYmVyID0gMSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNhbXBsZVJhZGl1cyA9IF9zYW1wbGVSYWRpdXM7XHJcbiAgICAgIHRoaXMuYmlhcyA9IF9iaWFzO1xyXG4gICAgICB0aGlzLmF0dGVudWF0aW9uQ29uc3RhbnQgPSBfYXR0ZW51YXRpb25Db25zdGFudDtcclxuICAgICAgdGhpcy5hdHRlbnVhdGlvbkxpbmVhciA9IF9hdHRlbnVhdGlvbkxpbmVhcjtcclxuICAgICAgdGhpcy5hdHRlbnVhdGlvblF1YWRyYXRpYyA9IF9hdHRlbnVhdGlvblF1YWRyYXRpYztcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIHNhbXBsZVJhZGl1czogdGhpcy5zYW1wbGVSYWRpdXMsXHJcbiAgICAgICAgYmlhczogdGhpcy5iaWFzLFxyXG4gICAgICAgIGF0dGVudWF0aW9uQ29uc3RhbnQ6IHRoaXMuYXR0ZW51YXRpb25Db25zdGFudCxcclxuICAgICAgICBhdHRlbnVhdGlvbkxpbmVhcjogdGhpcy5hdHRlbnVhdGlvbkxpbmVhcixcclxuICAgICAgICBhdHRlbnVhdGlvblF1YWRyYXRpYzogdGhpcy5hdHRlbnVhdGlvblF1YWRyYXRpY1xyXG4gICAgICB9O1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuc2FtcGxlUmFkaXVzID0gX3NlcmlhbGl6YXRpb24uc2FtcGxlUmFkaXVzO1xyXG4gICAgICB0aGlzLmJpYXMgPSBfc2VyaWFsaXphdGlvbi5iaWFzO1xyXG4gICAgICB0aGlzLmF0dGVudWF0aW9uQ29uc3RhbnQgPSBfc2VyaWFsaXphdGlvbi5hdHRlbnVhdGlvbkNvbnN0YW50O1xyXG4gICAgICB0aGlzLmF0dGVudWF0aW9uTGluZWFyID0gX3NlcmlhbGl6YXRpb24uYXR0ZW51YXRpb25MaW5lYXI7XHJcbiAgICAgIHRoaXMuYXR0ZW51YXRpb25RdWFkcmF0aWMgPSBfc2VyaWFsaXphdGlvbi5hdHRlbnVhdGlvblF1YWRyYXRpYztcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL1RpbWUvTG9vcC50c1wiLz5cclxuLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9BbmltYXRpb24vQW5pbWF0aW9uLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEhvbGRzIGEgcmVmZXJlbmNlIHRvIGFuIHtAbGluayBBbmltYXRpb259IGFuZCBjb250cm9scyBpdC4gQ29udHJvbHMgcXVhbnRpemF0aW9uIGFuZCBwbGF5bW9kZSBhcyB3ZWxsIGFzIHNwZWVkLlxyXG4gICAqIEBhdXRob3JzIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50QW5pbWF0aW9uIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRBbmltYXRpb24pO1xyXG4gICAgQHR5cGUoQW5pbWF0aW9uKVxyXG4gICAgcHVibGljIGFuaW1hdGlvbjogQW5pbWF0aW9uO1xyXG4gICAgcHVibGljIHBsYXltb2RlOiBBTklNQVRJT05fUExBWU1PREU7XHJcbiAgICBwdWJsaWMgcXVhbnRpemF0aW9uOiBBTklNQVRJT05fUVVBTlRJWkFUSU9OO1xyXG4gICAgcHVibGljIHNjYWxlV2l0aEdhbWVUaW1lOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHB1YmxpYyBhbmltYXRlSW5FZGl0b3I6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAjc2NhbGU6IG51bWJlciA9IDE7XHJcbiAgICAjdGltZUxvY2FsOiBUaW1lO1xyXG4gICAgI3ByZXZpb3VzOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYW5pbWF0aW9uPzogQW5pbWF0aW9uLCBfcGxheW1vZGU6IEFOSU1BVElPTl9QTEFZTU9ERSA9IEFOSU1BVElPTl9QTEFZTU9ERS5MT09QLCBfcXVhbnRpemF0aW9uOiBBTklNQVRJT05fUVVBTlRJWkFUSU9OID0gQU5JTUFUSU9OX1FVQU5USVpBVElPTi5DT05USU5PVVMpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5wbGF5bW9kZSA9IF9wbGF5bW9kZTtcclxuICAgICAgdGhpcy5xdWFudGl6YXRpb24gPSBfcXVhbnRpemF0aW9uO1xyXG4gICAgICB0aGlzLmFuaW1hdGlvbiA9IF9hbmltYXRpb247XHJcblxyXG4gICAgICB0aGlzLiN0aW1lTG9jYWwgPSBuZXcgVGltZSgpO1xyXG5cclxuICAgICAgLy9UT0RPOiB1cGRhdGUgYW5pbWF0aW9uIHRvdGFsIHRpbWUgd2hlbiBsb2FkaW5nIGEgZGlmZmVyZW50IGFuaW1hdGlvbj9cclxuICAgICAgdGhpcy5hbmltYXRpb24/LmNhbGN1bGF0ZVRvdGFsVGltZSgpO1xyXG5cclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9SRU1PVkUsICgpID0+IHRoaXMuYWN0aXZhdGUoZmFsc2UpKTtcclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsICgpID0+IHtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DSElMRF9SRU1PVkUsICgpID0+IHRoaXMuYWN0aXZhdGUoZmFsc2UpKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlKHRydWUpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHNjYWxlKF9zY2FsZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NjYWxlID0gX3NjYWxlO1xyXG4gICAgICB0aGlzLnVwZGF0ZVNjYWxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBzY2FsZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IHJldHVybiB0aGUgY3VycmVudCBzYW1wbGUgdGltZSBvZiB0aGUgYW5pbWF0aW9uICBcclxuICAgICAqIC0gc2V0OiBqdW1wIHRvIGEgY2VydGFpbiBzYW1wbGUgdGltZSBpbiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgdGltZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jdGltZUxvY2FsLmdldCgpICUgdGhpcy5hbmltYXRpb24udG90YWxUaW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgdGltZShfdGltZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuanVtcFRvKF90aW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWN0aXZhdGUoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLmFjdGl2YXRlKF9vbik7XHJcbiAgICAgIGlmICghdGhpcy5ub2RlKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIHRoaXMuYWN0aXZhdGVMaXN0ZW5lcnMoX29uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEp1bXBzIHRvIGEgY2VydGFpbiB0aW1lIGluIHRoZSBhbmltYXRpb24gdG8gcGxheSBmcm9tIHRoZXJlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMganVtcFRvKF90aW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jdGltZUxvY2FsLnNldChfdGltZSk7XHJcbiAgICAgIHRoaXMuI3ByZXZpb3VzID0gX3RpbWU7XHJcbiAgICAgIF90aW1lID0gX3RpbWUgJSB0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWU7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gdGhpcy5hbmltYXRpb24uZ2V0U3RhdGUoX3RpbWUsIHRoaXMuYW5pbWF0aW9uLmNhbGN1bGF0ZURpcmVjdGlvbihfdGltZSwgdGhpcy5wbGF5bW9kZSksIHRoaXMucXVhbnRpemF0aW9uKTtcclxuICAgICAgdGhpcy5ub2RlLmFwcGx5QW5pbWF0aW9uKG11dGF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSnVtcHMgdG8gYSBjZXJ0YWluIGxhYmVsIGluIHRoZSBhbmltYXRpb24gaWYgZGVmaW5lZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMganVtcFRvTGFiZWwoX2xhYmVsOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgbGV0IHRpbWU6IG51bWJlciA9IHRoaXMuYW5pbWF0aW9uLmxhYmVsc1tfbGFiZWxdO1xyXG4gICAgICBpZiAodGltZSlcclxuICAgICAgICB0aGlzLmp1bXBUbyh0aW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvcmNlcyBhbiB1cGRhdGUgb2YgdGhlIGFuaW1hdGlvbiBmcm9tIG91dHNpZGUuIFVzZWQgaW4gdGhlIFZpZXdBbmltYXRpb24uIFNob3VsZG4ndCBiZSB1c2VkIGR1cmluZyB0aGUgZ2FtZS5cclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgKHVuc2NhbGVkKSB0aW1lIHRvIHVwZGF0ZSB0aGUgYW5pbWF0aW9uIHdpdGguXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgTXV0YXRvciBmb3IgQW5pbWF0aW9uLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZUFuaW1hdGlvbihfdGltZTogbnVtYmVyKTogTXV0YXRvciB7XHJcbiAgICAgIHRoaXMuI3ByZXZpb3VzID0gdW5kZWZpbmVkO1xyXG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVBbmltYXRpb25Mb29wKG51bGwsIF90aW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gdHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge307XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pZEFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uLmlkUmVzb3VyY2U7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24ucGxheW1vZGUgPSB0aGlzLnBsYXltb2RlO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnF1YW50aXphdGlvbiA9IHRoaXMucXVhbnRpemF0aW9uO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnNjYWxlID0gdGhpcy5zY2FsZTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5zY2FsZVdpdGhHYW1lVGltZSA9IHRoaXMuc2NhbGVXaXRoR2FtZVRpbWU7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uYW5pbWF0ZUluRWRpdG9yID0gdGhpcy5hbmltYXRlSW5FZGl0b3I7XHJcblxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHRoaXMuYW5pbWF0aW9uID0gPEFuaW1hdGlvbj5hd2FpdCBQcm9qZWN0LmdldFJlc291cmNlKF9zZXJpYWxpemF0aW9uLmlkQW5pbWF0aW9uKTtcclxuICAgICAgdGhpcy5wbGF5bW9kZSA9IF9zZXJpYWxpemF0aW9uLnBsYXltb2RlO1xyXG4gICAgICB0aGlzLnF1YW50aXphdGlvbiA9IF9zZXJpYWxpemF0aW9uLnF1YW50aXphdGlvbjtcclxuICAgICAgdGhpcy5zY2FsZSA9IF9zZXJpYWxpemF0aW9uLnNjYWxlO1xyXG4gICAgICB0aGlzLnNjYWxlV2l0aEdhbWVUaW1lID0gX3NlcmlhbGl6YXRpb24uc2NhbGVXaXRoR2FtZVRpbWU7XHJcbiAgICAgIHRoaXMuYW5pbWF0ZUluRWRpdG9yID0gX3NlcmlhbGl6YXRpb24uYW5pbWF0ZUluRWRpdG9yO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IuYW5pbWF0ZUluRWRpdG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uKDApO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGVMaXN0ZW5lcnModGhpcy5hY3RpdmUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gc3VwZXIuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKHR5cGVzLnBsYXltb2RlKVxyXG4gICAgICAgIHR5cGVzLnBsYXltb2RlID0gQU5JTUFUSU9OX1BMQVlNT0RFO1xyXG4gICAgICBpZiAodHlwZXMucXVhbnRpemF0aW9uKVxyXG4gICAgICAgIHR5cGVzLnF1YW50aXphdGlvbiA9IEFOSU1BVElPTl9RVUFOVElaQVRJT047XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByaXZhdGUgYWN0aXZhdGVMaXN0ZW5lcnMoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIGlmIChfb24gJiYgKFByb2plY3QubW9kZSAhPSBNT0RFLkVESVRPUiB8fCBQcm9qZWN0Lm1vZGUgPT0gTU9ERS5FRElUT1IgJiYgdGhpcy5hbmltYXRlSW5FZGl0b3IpKSB7XHJcbiAgICAgICAgVGltZS5nYW1lLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuVElNRV9TQ0FMRUQsIHRoaXMudXBkYXRlU2NhbGUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULlJFTkRFUl9QUkVQQVJFLCB0aGlzLnVwZGF0ZUFuaW1hdGlvbkxvb3ApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIFRpbWUuZ2FtZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULlRJTUVfU0NBTEVELCB0aGlzLnVwZGF0ZVNjYWxlKTtcclxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5SRU5ERVJfUFJFUEFSRSwgdGhpcy51cGRhdGVBbmltYXRpb25Mb29wKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiB1cGRhdGVBbmltYXRpb25cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgQW5pbWF0aW9uLlxyXG4gICAgICogVXNlcyB0aGUgYnVpbHQtaW4gdGltZSB1bmxlc3MgYSBkaWZmZXJlbnQgdGltZSBpcyBzcGVjaWZpZWQuXHJcbiAgICAgKiBNYXkgYWxzbyBiZSBjYWxsZWQgZnJvbSB1cGRhdGVBbmltYXRpb24oKS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB1cGRhdGVBbmltYXRpb25Mb29wID0gKF9lOiBFdmVudCwgX3RpbWU/OiBudW1iZXIpOiBNdXRhdG9yID0+IHtcclxuICAgICAgUGVyZm9ybWFuY2VNb25pdG9yLnN0YXJ0TWVhc3VyZShcInVwZGF0ZUFuaW1hdGlvbkxvb3BcIik7XHJcbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWUgPT0gMCkgXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICBsZXQgdGltZTogbnVtYmVyID0gX3RpbWUgfHwgX3RpbWUgPT09IDAgPyBfdGltZSA6IHRoaXMuI3RpbWVMb2NhbC5nZXQoKTtcclxuICAgICAgaWYgKHRoaXMucXVhbnRpemF0aW9uID09IEFOSU1BVElPTl9RVUFOVElaQVRJT04uRlJBTUVTKSB7XHJcbiAgICAgICAgdGltZSA9IHRoaXMuI3ByZXZpb3VzICsgKDEwMDAgLyB0aGlzLmFuaW1hdGlvbi5mcHMpO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBkaXJlY3Rpb246IG51bWJlciA9IHRoaXMuYW5pbWF0aW9uLmNhbGN1bGF0ZURpcmVjdGlvbih0aW1lLCB0aGlzLnBsYXltb2RlKTtcclxuICAgICAgdGltZSA9IHRoaXMuYW5pbWF0aW9uLmdldE1vZGFsVGltZSh0aW1lLCB0aGlzLnBsYXltb2RlLCB0aGlzLiN0aW1lTG9jYWwuZ2V0T2Zmc2V0KCkpO1xyXG4gICAgICB0aGlzLmV4ZWN1dGVFdmVudHModGhpcy5hbmltYXRpb24uZ2V0RXZlbnRzVG9GaXJlKHRoaXMuI3ByZXZpb3VzLCB0aW1lLCB0aGlzLnF1YW50aXphdGlvbiwgZGlyZWN0aW9uKSk7XHJcblxyXG4gICAgICBpZiAodGhpcy4jcHJldmlvdXMgIT0gdGltZSkge1xyXG4gICAgICAgIHRoaXMuI3ByZXZpb3VzID0gdGltZTtcclxuICAgICAgICB0aW1lID0gdGltZSAlIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZTtcclxuICAgICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHRoaXMuYW5pbWF0aW9uLmdldFN0YXRlKHRpbWUsIGRpcmVjdGlvbiwgdGhpcy5xdWFudGl6YXRpb24pO1xyXG4gICAgICAgIGlmICh0aGlzLm5vZGUpIHtcclxuICAgICAgICAgIHRoaXMubm9kZS5hcHBseUFuaW1hdGlvbihtdXRhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUGVyZm9ybWFuY2VNb25pdG9yLmVuZE1lYXN1cmUoXCJ1cGRhdGVBbmltYXRpb25Mb29wXCIpO1xyXG5cclxuICAgICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlcyBhbGwgY3VzdG9tIGV2ZW50cyB0aGUgQW5pbWF0aW9uIHNob3VsZCBoYXZlIGZpcmVkIGJldHdlZW4gdGhlIGxhc3QgZnJhbWUgYW5kIHRoZSBjdXJyZW50IGZyYW1lLlxyXG4gICAgICogQHBhcmFtIF9ldmVudHMgYSBsaXN0IG9mIG5hbWVzIG9mIGN1c3RvbSBldmVudHMgdG8gZmlyZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGV4ZWN1dGVFdmVudHMoX2V2ZW50czogc3RyaW5nW10pOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF9ldmVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KF9ldmVudHNbaV0pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgc2NhbGUgb2YgdGhlIGFuaW1hdGlvbiBpZiB0aGUgdXNlciBjaGFuZ2VzIGl0IG9yIGlmIHRoZSBnbG9iYWwgZ2FtZSB0aW1lciBjaGFuZ2VkIGl0cyBzY2FsZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB1cGRhdGVTY2FsZSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgbGV0IG5ld1NjYWxlOiBudW1iZXIgPSB0aGlzLiNzY2FsZTtcclxuICAgICAgaWYgKHRoaXMuc2NhbGVXaXRoR2FtZVRpbWUpXHJcbiAgICAgICAgbmV3U2NhbGUgKj0gVGltZS5nYW1lLmdldFNjYWxlKCk7XHJcbiAgICAgIHRoaXMuI3RpbWVMb2NhbC5zZXRTY2FsZShuZXdTY2FsZSk7XHJcbiAgICB9O1xyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgYW4ge0BsaW5rIEFuaW1hdGlvbk5vZGUgYW5pbWF0aW9uIGdyYXBofSB0byBhIHtAbGluayBOb2RlfSBhbmQgYW5pbWF0ZXMgaXQuXHJcbiAgICogQGF1dGhvciBKb25hcyBQbG90emt5LCBIRlUsIDIwMjQtMjAyNVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRBbmltYXRpb25HcmFwaCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50QW5pbWF0aW9uR3JhcGgpO1xyXG4gICAgcHVibGljIHJvb3Q6IEFuaW1hdGlvbk5vZGU7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9yb290PzogQW5pbWF0aW9uTm9kZSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnJvb3QgPSBfcm9vdDtcclxuXHJcbiAgICAgIGlmIChQcm9qZWN0Lm1vZGUgPT0gTU9ERS5FRElUT1IpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsICgpID0+IHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULlJFTkRFUl9QUkVQQVJFLCB0aGlzLnVwZGF0ZSkpO1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgKCkgPT4gdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuUkVOREVSX1BSRVBBUkUsIHRoaXMudXBkYXRlKSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByaXZhdGUgdXBkYXRlID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICBQZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNZWFzdXJlKFwiQ29tcG9uZW50QW5pbWF0aW9uR3JhcGgudXBkYXRlXCIpO1xyXG4gICAgICBpZiAoIXRoaXMucm9vdCB8fCAhdGhpcy5ub2RlIHx8ICF0aGlzLmFjdGl2ZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBQZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNZWFzdXJlKFwiQ29tcG9uZW50QW5pbWF0aW9uR3JhcGgudXBkYXRlIGNvbXB1dGVcIik7XHJcbiAgICAgIHRoaXMucm9vdC51cGRhdGUoTG9vcC50aW1lRnJhbWVHYW1lKTtcclxuICAgICAgdGhpcy5yb290LmV2ZW50cz8uZm9yRWFjaChfZXZlbnQgPT4gdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChfZXZlbnQpKSk7XHJcbiAgICAgIFBlcmZvcm1hbmNlTW9uaXRvci5lbmRNZWFzdXJlKFwiQ29tcG9uZW50QW5pbWF0aW9uR3JhcGgudXBkYXRlIGNvbXB1dGVcIik7XHJcblxyXG5cclxuICAgICAgUGVyZm9ybWFuY2VNb25pdG9yLnN0YXJ0TWVhc3VyZShcIkNvbXBvbmVudEFuaW1hdGlvbkdyYXBoLnVwZGF0ZSBhcHBseVwiKTtcclxuICAgICAgdGhpcy5ub2RlLmFwcGx5QW5pbWF0aW9uKHRoaXMucm9vdC5tdXRhdG9yKTtcclxuICAgICAgUGVyZm9ybWFuY2VNb25pdG9yLmVuZE1lYXN1cmUoXCJDb21wb25lbnRBbmltYXRpb25HcmFwaC51cGRhdGUgYXBwbHlcIik7XHJcblxyXG4gICAgICBQZXJmb3JtYW5jZU1vbml0b3IuZW5kTWVhc3VyZShcIkNvbXBvbmVudEFuaW1hdGlvbkdyYXBoLnVwZGF0ZVwiKTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIGV4cG9ydCBlbnVtIEFVRElPX1BBTk5FUiB7XHJcbiAgICBDT05FX0lOTkVSX0FOR0xFID0gXCJjb25lSW5uZXJBbmdsZVwiLFxyXG4gICAgQ09ORV9PVVRFUl9BTkdMRSA9IFwiY29uZU91dGVyQW5nbGVcIixcclxuICAgIENPTkVfT1VURVJfR0FJTiA9IFwiY29uZU91dGVyR2FpblwiLFxyXG4gICAgRElTVEFOQ0VfTU9ERUwgPSBcImRpc3RhbmNlTW9kZWxcIixcclxuICAgIE1BWF9ESVNUQU5DRSA9IFwibWF4RGlzdGFuY2VcIixcclxuICAgIFBBTk5JTkdfTU9ERUwgPSBcInBhbm5pbmdNb2RlbFwiLFxyXG4gICAgUkVGX0RJU1RBTkNFID0gXCJyZWZEaXN0YW5jZVwiLFxyXG4gICAgUk9MTE9GRl9GQUNUT1IgPSBcInJvbGxvZmZGYWN0b3JcIlxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gQVVESU9fTk9ERV9UWVBFIHtcclxuICAgIFNPVVJDRSwgUEFOTkVSLCBHQUlOXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCdWlsZHMgYSBtaW5pbWFsIGF1ZGlvIGdyYXBoIChieSBkZWZhdWx0IGluIHtAbGluayBBdWRpb01hbmFnZXJ9LmRlZmF1bHQpIGFuZCBzeW5jaHJvbml6ZXMgaXQgd2l0aCB0aGUgY29udGFpbmluZyB7QGxpbmsgTm9kZX1cclxuICAgKiBgYGB0ZXh0XHJcbiAgICog4pSMIEF1ZGlvTWFuYWdlciguZGVmYXVsdCkg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXHJcbiAgICog4pSCIOKUjCBDb21wb25lbnRBdWRpbyDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgICAgICAgICAg4pSCXHJcbiAgICog4pSCIOKUgiAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilJAg4pSCIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCDilIIgIFxyXG4gICAqIOKUgiDilIIgICAg4pSCc291cmNl4pSCIOKGkiDilIJwYW5uZXLilIIg4oaSIOKUgiBnYWluIOKUgiDihpIg4pSCIGdhaW4g4pSCIOKUglxyXG4gICAqIOKUgiDilIIgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYIOKUgiDilJTilIDilIDilIDilIDilIDilIDilJgg4pSCICBcclxuICAgKiDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgICAgIOKUglxyXG4gICAqIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIFRob21hcyBEb3JuZXIsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudEF1ZGlvIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRBdWRpbyk7XHJcbiAgICAvKiogcGxhY2VzIGFuZCBkaXJlY3RzIHRoZSBwYW5uZXIgcmVsYXRpdmUgdG8gdGhlIHdvcmxkIHRyYW5zZm9ybSBvZiB0aGUge0BsaW5rIE5vZGV9ICAqL1xyXG4gICAgcHVibGljIG10eFBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc2luZ2xldG9uOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgQHR5cGUoQXVkaW8pXHJcbiAgICBwcml2YXRlIGF1ZGlvOiBBdWRpbztcclxuICAgIHByaXZhdGUgZ2FpbjogR2Fpbk5vZGU7XHJcbiAgICBwcml2YXRlIHBhbm5lcjogUGFubmVyTm9kZTtcclxuICAgIHByaXZhdGUgc291cmNlOiBBdWRpb0J1ZmZlclNvdXJjZU5vZGU7XHJcbiAgICBwcml2YXRlIGF1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyO1xyXG4gICAgcHJpdmF0ZSBwbGF5aW5nOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIGxpc3RlbmVkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9hdWRpbzogQXVkaW8gPSBudWxsLCBfbG9vcDogYm9vbGVhbiA9IGZhbHNlLCBfc3RhcnQ6IGJvb2xlYW4gPSBmYWxzZSwgX2F1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyID0gQXVkaW9NYW5hZ2VyLmRlZmF1bHQpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5pbnN0YWxsKF9hdWRpb01hbmFnZXIpO1xyXG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZShfYXVkaW8sIF9sb29wKTtcclxuXHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCB0aGlzLmhhbmRsZUF0dGFjaCk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLmhhbmRsZUF0dGFjaCk7XHJcblxyXG4gICAgICBpZiAoX3N0YXJ0KVxyXG4gICAgICAgIHRoaXMucGxheShfc3RhcnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgdm9sdW1lKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdm9sdW1lKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGxvb3AoX29uOiBib29sZWFuKSB7XHJcbiAgICAgIHRoaXMuc291cmNlLmxvb3AgPSBfb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBsb29wKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2UubG9vcDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHBsYXliYWNrUmF0ZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBwbGF5YmFja1JhdGUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGdldCBpc1BsYXlpbmcoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBsYXlpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpc0F0dGFjaGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5ub2RlICE9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpc0xpc3RlbmVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGdpdmVuIHtAbGluayBBdWRpb30gYXMgdGhlIGF1ZGlvIHNvdXJjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0QXVkaW8oX2F1ZGlvOiBBdWRpbyk6IHZvaWQge1xyXG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZShfYXVkaW8sIHRoaXMuc291cmNlLmxvb3ApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIEF1ZGlvfSBjdXJyZW50bHkgdXNlZCBhcyBhdWRpbyBzb3VyY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEF1ZGlvKCk6IEF1ZGlvIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXVkaW87XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHByb3BlcnR5IG9mIHRoZSBwYW5uZXIgdG8gdGhlIGdpdmVuIHZhbHVlLiBVc2UgdG8gbWFuaXB1bGF0ZSByYW5nZSBhbmQgcm9sbG9mZiBldGMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRQYW5uZXIoX3Byb3BlcnR5OiBBVURJT19QQU5ORVIsIF92YWx1ZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIFJlZmxlY3Quc2V0KHRoaXMucGFubmVyLCBfcHJvcGVydHksIF92YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogbWF5IGJlIHVzZWQgZm9yIHNlcmlhbGl6YXRpb24gb2YgQXVkaW9Ob2Rlc1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtdXRhdG9yIGZvciB0aGUgc3BlY2lmaWVkIEF1ZGlvTm9kZSBvZiB0aGUgc3RhbmRhcmQgZ3JhcGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE11dGF0b3JPZk5vZGUoX3R5cGU6IEFVRElPX05PREVfVFlQRSk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbm9kZTogQXVkaW9Ob2RlID0gdGhpcy5nZXRBdWRpb05vZGUoX3R5cGUpO1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IGdldE11dGF0b3JPZkFyYml0cmFyeShub2RlKTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgQXVkaW9Ob2RlIG9mIHRoZSBzdGFuZGFyZCBncmFwaCBmb3IgZnVydGhlciBtYW5pcHVsYXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEF1ZGlvTm9kZShfdHlwZTogQVVESU9fTk9ERV9UWVBFKTogQXVkaW9Ob2RlIHtcclxuICAgICAgc3dpdGNoIChfdHlwZSkge1xyXG4gICAgICAgIGNhc2UgQVVESU9fTk9ERV9UWVBFLlNPVVJDRTogcmV0dXJuIHRoaXMuc291cmNlO1xyXG4gICAgICAgIGNhc2UgQVVESU9fTk9ERV9UWVBFLlBBTk5FUjogcmV0dXJuIHRoaXMucGFubmVyO1xyXG4gICAgICAgIGNhc2UgQVVESU9fTk9ERV9UWVBFLkdBSU46IHJldHVybiB0aGlzLmdhaW47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IG9yIHN0b3AgcGxheWluZyB0aGUgYXVkaW9cclxuICAgICAqL1xyXG4gICAgcHVibGljIHBsYXkoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIGlmIChfb24pIHtcclxuICAgICAgICBpZiAodGhpcy5hdWRpby5pc1JlYWR5KSB7XHJcbiAgICAgICAgICB0aGlzLmNyZWF0ZVNvdXJjZSh0aGlzLmF1ZGlvLCB0aGlzLnNvdXJjZS5sb29wLCB0aGlzLnBsYXliYWNrUmF0ZSk7XHJcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zdGFydCgwLCAwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5hdWRpby5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLlJFQURZLCB0aGlzLmhuZEF1ZGlvUmVhZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNvdXJjZS5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkVOREVELCB0aGlzLmhuZEF1ZGlvRW5kZWQpO1xyXG4gICAgICB9IGVsc2VcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdGhpcy5zb3VyY2Uuc3RvcCgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcjogdW5rbm93bikgeyAvKiBjYXRjaCBleGNlcHRpb24gd2hlbiBzb3VyY2UgaGFzbid0IGJlZW4gc3RhcnRlZC4uLiAqLyB9XHJcbiAgICAgIHRoaXMucGxheWluZyA9IF9vbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgQXVkaW9Ob2RlcyBiZXR3ZWVuIHRoZSBwYW5uZXIgYW5kIHRoZSBsb2NhbCBnYWluIG9mIHRoaXMge0BsaW5rIENvbXBvbmVudEF1ZGlvfVxyXG4gICAgICogX2lucHV0IGFuZCBfb3V0cHV0IG1heSBiZSB0aGUgc2FtZSBBdWRpb05vZGUsIGlmIHRoZXJlIGlzIG9ubHkgb25lIHRvIGluc2VydCxcclxuICAgICAqIG9yIG1heSBoYXZlIG11bHRpcGxlIEF1ZGlvTm9kZSBiZXR3ZWVuIHRoZW0gdG8gY3JlYXRlIGFuIGVmZmVjdC1ncmFwaC5cXFxyXG4gICAgICogTm90ZSB0aGF0IHtAbGluayBDb21wb25lbnRBdWRpb30gZG9lcyBub3Qga2VlcCB0cmFjayBvZiBpbnNlcnRlZCBBdWRpb05vZGVzIVxyXG4gICAgICogYGBgdGV4dFxyXG4gICAgICog4pSMIEF1ZGlvTWFuYWdlciguZGVmYXVsdCkg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXHJcbiAgICAgKiDilIIg4pSMIENvbXBvbmVudEF1ZGlvIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICDilIJcclxuICAgICAqIOKUgiDilIIgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAgICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCDilIIg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQIOKUgiAgXHJcbiAgICAgKiDilIIg4pSCICAgIOKUgnNvdXJjZeKUgiDihpIg4pSCcGFubmVy4pSCIOKGkiDilIJfaW5wdXTilIIg4oaSIC4uLiAg4oaSIOKUgl9vdXRwdXTilIIg4oaSIOKUgiBnYWluIOKUgiDihpIg4pSCIGdhaW4g4pSCIOKUglxyXG4gICAgICog4pSCIOKUgiAgICDilJTilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJggICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSYIOKUgiDilJTilIDilIDilIDilIDilIDilIDilJgg4pSCICBcclxuICAgICAqIOKUgiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggICAgICAgICAg4pSCXHJcbiAgICAgKiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW5zZXJ0QXVkaW9Ob2RlcyhfaW5wdXQ6IEF1ZGlvTm9kZSwgX291dHB1dDogQXVkaW9Ob2RlKTogdm9pZCB7XHJcbiAgICAgIHRoaXMucGFubmVyLmRpc2Nvbm5lY3QoMCk7XHJcbiAgICAgIGlmICghX2lucHV0ICYmICFfb3V0cHV0KSB7XHJcbiAgICAgICAgdGhpcy5wYW5uZXIuY29ubmVjdCh0aGlzLmdhaW4pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnBhbm5lci5jb25uZWN0KF9pbnB1dCk7XHJcbiAgICAgIF9vdXRwdXQuY29ubmVjdCh0aGlzLmdhaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWN0aXZhdGUgb3ZlcnJpZGUuIENvbm5lY3RzIG9yIGRpc2Nvbm5lY3RzIEF1ZGlvTm9kZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlKF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBzdXBlci5hY3RpdmF0ZShfb24pO1xyXG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbm5lY3RzIHRoaXMgY29tcG9uZW50cyBnYWluLW5vZGUgdG8gdGhlIGdhaW4gbm9kZSBvZiB0aGUgQXVkaW9NYW5hZ2VyIHRoaXMgY29tcG9uZW50IHJ1bnMgb24uXHJcbiAgICAgKiBPbmx5IGNhbGwgdGhpcyBtZXRob2QgaWYgdGhlIGNvbXBvbmVudCBpcyBub3QgYXR0YWNoZWQgdG8gYSB7QGxpbmsgTm9kZX0gYnV0IG5lZWRzIHRvIGJlIGhlYXJkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29ubmVjdChfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKF9vbilcclxuICAgICAgICB0aGlzLmdhaW4uY29ubmVjdCh0aGlzLmF1ZGlvTWFuYWdlci5nYWluKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMuZ2Fpbi5kaXNjb25uZWN0KHRoaXMuYXVkaW9NYW5hZ2VyLmdhaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkcmF3R2l6bW9zKCk6IHZvaWQge1xyXG4gICAgICBsZXQgbXR4U2hhcGU6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5QUk9EVUNUKHRoaXMubm9kZS5tdHhXb3JsZCwgdGhpcy5tdHhQaXZvdCk7XHJcbiAgICAgIG10eFNoYXBlLnNjYWxpbmcgPSBuZXcgVmVjdG9yMygwLjUsIDAuNSwgMC41KTtcclxuICAgICAgbGV0IGNvbG9yOiBDb2xvciA9IENvbG9yLkNTUyhcImNvcm5mbG93ZXJibHVlXCIpO1xyXG4gICAgICBHaXptb3MuZHJhd0ljb24oVGV4dHVyZURlZmF1bHQuaWNvbkF1ZGlvLCBtdHhTaGFwZSwgY29sb3IpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZU11bHRpcGxlKG10eFNoYXBlLCBjb2xvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pZFJlc291cmNlID0gdGhpcy5hdWRpbz8uaWRSZXNvdXJjZTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5wbGF5aW5nID0gdGhpcy5wbGF5aW5nO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmxvb3AgPSB0aGlzLmxvb3A7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24udm9sdW1lID0gdGhpcy52b2x1bWU7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuZ2V0TXV0YXRvck9mTm9kZShBVURJT19OT0RFX1RZUEUuUEFOTkVSKSk7XHJcbiAgICAgIC8vIFRPRE86IHNlcmlhbGl6ZSBwYW5uZXIgcGFyYW1ldGVyc1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgbGV0IGF1ZGlvOiBBdWRpbyA9IDxBdWRpbz5hd2FpdCBQcm9qZWN0LmdldFJlc291cmNlKF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UpO1xyXG4gICAgICB0aGlzLmNyZWF0ZVNvdXJjZShhdWRpbywgX3NlcmlhbGl6YXRpb24ubG9vcCk7XHJcbiAgICAgIHRoaXMudm9sdW1lID0gX3NlcmlhbGl6YXRpb24udm9sdW1lO1xyXG4gICAgICB0aGlzLnBsYXkoX3NlcmlhbGl6YXRpb24ucGxheWluZyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IodHJ1ZSk7XHJcbiAgICAgIGxldCBhdWRpbzogTXV0YXRvciA9IG11dGF0b3IuYXVkaW87XHJcbiAgICAgIGRlbGV0ZSBtdXRhdG9yLmF1ZGlvOyAvLyBqdXN0IHRvIHJlYXJyYW5nZSBpbiBpbnRlcmZhY2VzLi4uXHJcbiAgICAgIG11dGF0b3IubG9vcCA9IHRoaXMubG9vcDtcclxuICAgICAgbXV0YXRvci52b2x1bWUgPSB0aGlzLnZvbHVtZTtcclxuICAgICAgbXV0YXRvci5hdWRpbyA9IGF1ZGlvOyAvLy4uLiBzbyBhdWRpbyBjb21lcyBsYXN0XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIC8vICAgYXdhaXQgc3VwZXIubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgIC8vICAgLy8gdGhpcy52b2x1bWUgPSBfbXV0YXRvci52b2x1bWU7XHJcbiAgICAvLyAgIC8vIHRoaXMubG9vcCA9IF9tdXRhdG9yLmxvb3A7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5saXN0ZW5lZDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICBwcml2YXRlIGhuZEF1ZGlvUmVhZHk6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICBEZWJ1Zy5mdWRnZShcIkF1ZGlvIHN0YXJ0XCIsIFJlZmxlY3QuZ2V0KF9ldmVudC50YXJnZXQsIFwidXJsXCIpKTtcclxuICAgICAgaWYgKHRoaXMucGxheWluZylcclxuICAgICAgICB0aGlzLnBsYXkodHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgaG5kQXVkaW9FbmRlZDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgIC8vIERlYnVnLmZ1ZGdlKFwiQXVkaW8gZW5kZWRcIiwgUmVmbGVjdC5nZXQoX2V2ZW50LnRhcmdldCwgXCJ1cmxcIikpO1xyXG4gICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBpbnN0YWxsKF9hdWRpb01hbmFnZXI6IEF1ZGlvTWFuYWdlciA9IEF1ZGlvTWFuYWdlci5kZWZhdWx0KTogdm9pZCB7XHJcbiAgICAgIGxldCBhY3RpdmU6IGJvb2xlYW4gPSB0aGlzLmlzQWN0aXZlO1xyXG4gICAgICB0aGlzLmFjdGl2YXRlKGZhbHNlKTtcclxuICAgICAgdGhpcy5hdWRpb01hbmFnZXIgPSBfYXVkaW9NYW5hZ2VyO1xyXG4gICAgICB0aGlzLnBhbm5lciA9IF9hdWRpb01hbmFnZXIuY3JlYXRlUGFubmVyKCk7XHJcbiAgICAgIHRoaXMuZ2FpbiA9IF9hdWRpb01hbmFnZXIuY3JlYXRlR2FpbigpO1xyXG4gICAgICB0aGlzLnBhbm5lci5jb25uZWN0KHRoaXMuZ2Fpbik7XHJcbiAgICAgIHRoaXMuZ2Fpbi5jb25uZWN0KF9hdWRpb01hbmFnZXIuZ2Fpbik7XHJcbiAgICAgIHRoaXMuYWN0aXZhdGUoYWN0aXZlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNyZWF0ZVNvdXJjZShfYXVkaW86IEF1ZGlvLCBfbG9vcDogYm9vbGVhbiwgX3BsYXliYWNrUmF0ZTogbnVtYmVyID0gMS4wKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLnNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB0aGlzLnNvdXJjZS5idWZmZXIgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc291cmNlID0gdGhpcy5hdWRpb01hbmFnZXIuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgIHRoaXMuc291cmNlLmNvbm5lY3QodGhpcy5wYW5uZXIpO1xyXG5cclxuICAgICAgaWYgKF9hdWRpbykge1xyXG4gICAgICAgIHRoaXMuYXVkaW8gPSBfYXVkaW87XHJcbiAgICAgICAgdGhpcy5zb3VyY2UuYnVmZmVyID0gX2F1ZGlvLmJ1ZmZlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zb3VyY2UubG9vcCA9IF9sb29wO1xyXG4gICAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IF9wbGF5YmFja1JhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGVDb25uZWN0aW9uKCk6IHZvaWQge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuY29ubmVjdCh0aGlzLmlzQWN0aXZlICYmIHRoaXMuaXNBdHRhY2hlZCAmJiB0aGlzLmxpc3RlbmVkKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgLy8gbm9wXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBdXRvbWF0aWNhbGx5IGNvbm5lY3RzL2Rpc2Nvbm5lY3RzIEF1ZGlvTm9kZXMgd2hlbiBhZGRpbmcvcmVtb3ZpbmcgdGhpcyBjb21wb25lbnQgdG8vZnJvbSBhIG5vZGUuIFxyXG4gICAgICogVGhlcmVmb3JlIHVudXNlZCBBdWRpb05vZGVzIG1heSBiZSBnYXJiYWdlIGNvbGxlY3RlZCB3aGVuIGFuIHVudXNlZCBjb21wb25lbnQgaXMgY29sbGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaGFuZGxlQXR0YWNoID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgLy8gRGVidWcubG9nKF9ldmVudCk7XHJcbiAgICAgIGlmIChfZXZlbnQudHlwZSA9PSBFVkVOVC5DT01QT05FTlRfQUREKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5ELCB0aGlzLmhhbmRsZUdyYXBoLCB0cnVlKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5DSElMRF9SRU1PVkUsIHRoaXMuaGFuZGxlR3JhcGgsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLlVQREFURSwgdGhpcy51cGRhdGUsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZWQgPSB0aGlzLm5vZGUuaXNEZXNjZW5kYW50T2YoQXVkaW9NYW5hZ2VyLmRlZmF1bHQuZ2V0R3JhcGhMaXN0ZW5pbmdUbygpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5DSElMRF9BUFBFTkQsIHRoaXMuaGFuZGxlR3JhcGgsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSwgdGhpcy5oYW5kbGVHcmFwaCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uVVBEQVRFLCB0aGlzLnVwZGF0ZSwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvbigpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBdXRvbWF0aWNhbGx5IGNvbm5lY3RzL2Rpc2Nvbm5lY3RzIEF1ZGlvTm9kZXMgd2hlbiBhcHBlbmRpbmcvcmVtb3ZpbmcgdGhlIEZVREdFLWdyYXBoIHRoZSBjb21wb25lbnQgaXMgaW4uIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhhbmRsZUdyYXBoID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgLy8gRGVidWcubG9nKF9ldmVudCk7XHJcbiAgICAgIHRoaXMubGlzdGVuZWQgPSAoX2V2ZW50LnR5cGUgPT0gRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5EKTtcclxuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIFVwZGF0ZXMgdGhlIHBhbm5lciBub2RlLCBpdHMgcG9zaXRpb24gYW5kIGRpcmVjdGlvbiwgdXNpbmcgdGhlIHdvcmxkbWF0cml4IG9mIHRoZSBjb250YWluZXIgYW5kIHRoZSBwaXZvdCBvZiB0aGlzIGNvbXBvbmVudC4gXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdXBkYXRlID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgbGV0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gdGhpcy5tdHhQaXZvdDtcclxuICAgICAgaWYgKHRoaXMubm9kZSlcclxuICAgICAgICBtdHhSZXN1bHQgPSBNYXRyaXg0eDQuUFJPRFVDVCh0aGlzLm5vZGUubXR4V29ybGQsIHRoaXMubXR4UGl2b3QpO1xyXG5cclxuICAgICAgLy8gRGVidWcubG9nKG10eFJlc3VsdC50b1N0cmluZygpKTtcclxuICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IzID0gbXR4UmVzdWx0LnRyYW5zbGF0aW9uO1xyXG4gICAgICBsZXQgZm9yd2FyZDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oVmVjdG9yMy5aKDEpLCBtdHhSZXN1bHQsIGZhbHNlKTtcclxuXHJcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWC52YWx1ZSA9IHBvc2l0aW9uLng7XHJcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWS52YWx1ZSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgIHRoaXMucGFubmVyLnBvc2l0aW9uWi52YWx1ZSA9IHBvc2l0aW9uLno7XHJcblxyXG4gICAgICB0aGlzLnBhbm5lci5vcmllbnRhdGlvblgudmFsdWUgPSBmb3J3YXJkLng7XHJcbiAgICAgIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWS52YWx1ZSA9IGZvcndhcmQueTtcclxuICAgICAgdGhpcy5wYW5uZXIub3JpZW50YXRpb25aLnZhbHVlID0gZm9yd2FyZC56O1xyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmUoZm9yd2FyZCk7XHJcbiAgICAgIC8vIFRPRE86IGV4YW1pbmUgd2h5IHRoZSBmb2xsb3dpbmcgcHJvZHVjZXMgZXJyb25lb3VzIHJlc3VsdHMsIHNlZSB0ZXN0IFwiU3BhdGlhbCBBdWRpb1wiXHJcbiAgICAgIGlmICh0aGlzLm5vZGUpXHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogU2VydmVzIHRvIHNldCB0aGUgc3BhdGlhbCBsb2NhdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgQXVkaW9MaXN0ZW5lcnMgcmVsYXRpdmUgdG8gdGhlXHJcbiAgICogd29ybGQgdHJhbnNmb3JtIG9mIHRoZSB7QGxpbmsgTm9kZX0gaXQgaXMgYXR0YWNoZWQgdG8uXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50QXVkaW9MaXN0ZW5lciBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50QXVkaW9MaXN0ZW5lcik7XHJcbiAgICBwdWJsaWMgbXR4UGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIG9mIHRoZSBnaXZlbiBBdWRpb0xpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1cGRhdGUoX2xpc3RlbmVyOiBBdWRpb0xpc3RlbmVyKTogdm9pZCB7XHJcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IHRoaXMubXR4UGl2b3Q7XHJcbiAgICAgIGlmICh0aGlzLm5vZGUpXHJcbiAgICAgICAgbXR4UmVzdWx0ID0gTWF0cml4NHg0LlBST0RVQ1QodGhpcy5ub2RlLm10eFdvcmxkLCB0aGlzLm10eFBpdm90KTtcclxuXHJcbiAgICAgIC8vIERlYnVnLmxvZyhtdHhSZXN1bHQudG9TdHJpbmcoKSk7XHJcbiAgICAgIGxldCBwb3NpdGlvbjogVmVjdG9yMyA9IG10eFJlc3VsdC50cmFuc2xhdGlvbjtcclxuICAgICAgbGV0IGZvcndhcmQ6IFZlY3RvcjMgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKFZlY3RvcjMuWigxKSwgbXR4UmVzdWx0LCBmYWxzZSk7XHJcbiAgICAgIGxldCB1cDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oVmVjdG9yMy5ZKCksIG10eFJlc3VsdCwgZmFsc2UpO1xyXG4gICAgICBpZiAoX2xpc3RlbmVyLnBvc2l0aW9uWCAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICBfbGlzdGVuZXIucG9zaXRpb25YLnZhbHVlID0gcG9zaXRpb24ueDtcclxuICAgICAgICBfbGlzdGVuZXIucG9zaXRpb25ZLnZhbHVlID0gcG9zaXRpb24ueTtcclxuICAgICAgICBfbGlzdGVuZXIucG9zaXRpb25aLnZhbHVlID0gcG9zaXRpb24uejtcclxuXHJcbiAgICAgICAgX2xpc3RlbmVyLmZvcndhcmRYLnZhbHVlID0gZm9yd2FyZC54O1xyXG4gICAgICAgIF9saXN0ZW5lci5mb3J3YXJkWS52YWx1ZSA9IGZvcndhcmQueTtcclxuICAgICAgICBfbGlzdGVuZXIuZm9yd2FyZFoudmFsdWUgPSBmb3J3YXJkLno7XHJcblxyXG4gICAgICAgIF9saXN0ZW5lci51cFgudmFsdWUgPSB1cC54O1xyXG4gICAgICAgIF9saXN0ZW5lci51cFkudmFsdWUgPSB1cC55O1xyXG4gICAgICAgIF9saXN0ZW5lci51cFoudmFsdWUgPSB1cC56O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEZpcmVmb3ggc3RpbGwgdXNlcyBkZXByZWNhdGVkIG1ldGhvZHMuIFRPRE86IGRlbGV0ZSBhcyBzb29uIGFzIHBvc3NpYmxlIVxyXG4gICAgICAgIF9saXN0ZW5lci5zZXRQb3NpdGlvbihwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KTtcclxuICAgICAgICBfbGlzdGVuZXIuc2V0T3JpZW50YXRpb24oZm9yd2FyZC54LCBmb3J3YXJkLnksIGZvcndhcmQueiwgdXAueCwgdXAueSwgdXAueik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKGZvcndhcmQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh1cCk7XHJcbiAgICAgIGlmICh0aGlzLm5vZGUpXHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcclxuXHJcbiAgICAgIC8vIERlYnVnLmxvZyhtdHhSZXN1bHQudHJhbnNsYXRpb24udG9TdHJpbmcoKSwgZm9yd2FyZC50b1N0cmluZygpLCB1cC50b1N0cmluZygpKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZWQgdG8gYSB7QGxpbmsgTm9kZX0gd2l0aCBhbiBhdHRhY2hlZCB7QGxpbmsgQ29tcG9uZW50Q2FtZXJhfSB0aGlzIGNhdXNlcyB0aGUgcmVuZGVyZWQgaW1hZ2UgdG8gcmVjZWl2ZSBhIGJsb29tLWVmZmVjdC5cclxuICAgKiBAYXV0aG9ycyBSb2xhbmQgSGVlciwgSEZVLCAyMDIzXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudEJsb29tIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRCbG9vbSk7XHJcbiAgICBcclxuICAgICN0aHJlc2hvbGQ6IG51bWJlcjtcclxuICAgICNpbnRlbnNpdHk6IG51bWJlcjtcclxuICAgICNoaWdobGlnaHREZXNhdHVyYXRpb246IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3RocmVzaG9sZDogbnVtYmVyID0gMC45NSwgX2ludGVuc2l0eTogbnVtYmVyID0gMS4wLCBfZGVzYXR1cmF0ZUhpZ2hsaWdodHM6IG51bWJlciA9IDAuNSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLiN0aHJlc2hvbGQgPSBfdGhyZXNob2xkO1xyXG4gICAgICB0aGlzLiNpbnRlbnNpdHkgPSBfaW50ZW5zaXR5O1xyXG4gICAgICB0aGlzLiNoaWdobGlnaHREZXNhdHVyYXRpb24gPSBfZGVzYXR1cmF0ZUhpZ2hsaWdodHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB0aHJlc2hvbGQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3RocmVzaG9sZDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgdGhyZXNob2xkKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3RocmVzaG9sZCA9IENhbGMuY2xhbXAoX3ZhbHVlLCAwLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGludGVuc2l0eSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jaW50ZW5zaXR5O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBpbnRlbnNpdHkoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jaW50ZW5zaXR5ID0gTWF0aC5tYXgoMCwgX3ZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGhpZ2hsaWdodERlc2F0dXJhdGlvbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jaGlnaGxpZ2h0RGVzYXR1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBoaWdobGlnaHREZXNhdHVyYXRpb24oX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jaGlnaGxpZ2h0RGVzYXR1cmF0aW9uID0gQ2FsYy5jbGFtcChfdmFsdWUsIDAsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgdGhyZXNob2xkOiB0aGlzLiN0aHJlc2hvbGQsXHJcbiAgICAgICAgaW50ZW5zaXR5OiB0aGlzLiNpbnRlbnNpdHksXHJcbiAgICAgICAgZGVzYXR1cmF0ZUhpZ2hsaWdodHM6IHRoaXMuI2hpZ2hsaWdodERlc2F0dXJhdGlvbixcclxuICAgICAgfTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLiN0aHJlc2hvbGQgPSBfc2VyaWFsaXphdGlvbi50aHJlc2hvbGQ7XHJcbiAgICAgIHRoaXMuI2ludGVuc2l0eSA9IF9zZXJpYWxpemF0aW9uLmludGVuc2l0eTtcclxuICAgICAgdGhpcy4jaGlnaGxpZ2h0RGVzYXR1cmF0aW9uID0gX3NlcmlhbGl6YXRpb24uZGVzYXR1cmF0ZUhpZ2hsaWdodHM7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcih0cnVlKTtcclxuICAgICAgbXV0YXRvci50aHJlc2hvbGQgPSB0aGlzLnRocmVzaG9sZDtcclxuICAgICAgbXV0YXRvci5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcclxuICAgICAgbXV0YXRvci5oaWdobGlnaHREZXNhdHVyYXRpb24gPSB0aGlzLmhpZ2hsaWdodERlc2F0dXJhdGlvbjtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJDb21wb25lbnQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBlbnVtIEZJRUxEX09GX1ZJRVcge1xyXG4gICAgSE9SSVpPTlRBTCA9IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgVkVSVElDQUwgPSBcInZlcnRpY2FsXCIsXHJcbiAgICBESUFHT05BTCA9IFwiZGlhZ29uYWxcIlxyXG4gIH1cclxuICAvKipcclxuICAgKiBEZWZpbmVzIGlkZW50aWZpZXJzIGZvciB0aGUgdmFyaW91cyBwcm9qZWN0aW9ucyBhIGNhbWVyYSBjYW4gcHJvdmlkZS4gIFxyXG4gICAqIFRPRE86IGNoYW5nZSBiYWNrIHRvIG51bWJlciBlbnVtIGlmIHN0cmluZ3Mgbm90IG5lZWRlZFxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIFBST0pFQ1RJT04ge1xyXG4gICAgQ0VOVFJBTCA9IFwiY2VudHJhbFwiLFxyXG4gICAgT1JUSE9HUkFQSElDID0gXCJvcnRob2dyYXBoaWNcIixcclxuICAgIERJTUVUUklDID0gXCJkaW1ldHJpY1wiLFxyXG4gICAgU1RFUkVPID0gXCJzdGVyZW9cIlxyXG4gIH1cclxuICAvKipcclxuICAgKiBUaGUgY2FtZXJhIGNvbXBvbmVudCBob2xkcyB0aGUgcHJvamVjdGlvbi1tYXRyaXggYW5kIG90aGVyIGRhdGEgbmVlZGVkIHRvIHJlbmRlciBhIHNjZW5lIGZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIHRoZSBub2RlIGl0IGlzIGF0dGFjaGVkIHRvLlxyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50Q2FtZXJhIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRDYW1lcmEpO1xyXG5cclxuICAgIHB1YmxpYyBtdHhQaXZvdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgbXR4V29ybGQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG5cclxuICAgIHB1YmxpYyBjbHJCYWNrZ3JvdW5kOiBDb2xvciA9IG5ldyBDb2xvcigwLCAwLCAwLCAxKTsgLy8gVGhlIGNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIHRoZSBjYW1lcmEgd2lsbCByZW5kZXIuXHJcbiAgICAvL3ByaXZhdGUgb3J0aG9ncmFwaGljOiBib29sZWFuID0gZmFsc2U7IC8vIERldGVybWluZXMgd2hldGhlciB0aGUgaW1hZ2Ugd2lsbCBiZSByZW5kZXJlZCB3aXRoIHBlcnNwZWN0aXZlIG9yIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uLlxyXG4gICAgcHJpdmF0ZSBwcm9qZWN0aW9uOiBQUk9KRUNUSU9OID0gUFJPSkVDVElPTi5DRU5UUkFMO1xyXG4gICAgcHJpdmF0ZSBmaWVsZE9mVmlldzogbnVtYmVyID0gNDU7IC8vIFRoZSBjYW1lcmEncyBzZW5zb3JhbmdsZS5cclxuICAgIHByaXZhdGUgYXNwZWN0UmF0aW86IG51bWJlciA9IDEuMDtcclxuICAgIHByaXZhdGUgZGlyZWN0aW9uOiBGSUVMRF9PRl9WSUVXID0gRklFTERfT0ZfVklFVy5ESUFHT05BTDtcclxuICAgIHByaXZhdGUgbmVhcjogbnVtYmVyID0gMTtcclxuICAgIHByaXZhdGUgZmFyOiBudW1iZXIgPSAyMDAwO1xyXG4gICAgcHJpdmF0ZSBiYWNrZ3JvdW5kRW5hYmxlZDogYm9vbGVhbiA9IHRydWU7IC8vIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIGJhY2tncm91bmQgb2YgdGhpcyBjYW1lcmEgd2lsbCBiZSByZW5kZXJlZC5cclxuICAgIC8vIFRPRE86IGV4YW1pbmUsIGlmIGJhY2tncm91bmQgc2hvdWxkIGJlIGFuIGF0dHJpYnV0ZSBvZiBDYW1lcmEgb3IgVmlld3BvcnRcclxuXHJcbiAgICAjbXR4V29ybGRUb1ZpZXc6IE1hdHJpeDR4NDtcclxuICAgICNtdHhDYW1lcmFJbnZlcnNlOiBNYXRyaXg0eDQ7XHJcbiAgICAjbXR4UHJvamVjdGlvbjogTWF0cml4NHg0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB7QGxpbmsgbXR4UHJvamVjdGlvbn0gKiB7QGxpbmsgbXR4Q2FtZXJhSW52ZXJzZX1cclxuICAgICAqIHlpZWxkaW5nIHRoZSB3b3JsZHNwYWNlIHRvIHZpZXdzcGFjZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtdHhXb3JsZFRvVmlldygpOiBNYXRyaXg0eDQge1xyXG4gICAgICBpZiAodGhpcy4jbXR4V29ybGRUb1ZpZXcpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI210eFdvcmxkVG9WaWV3O1xyXG5cclxuICAgICAgLy9UT0RPOiBvcHRpbWl6ZSwgbm8gbmVlZCB0byByZWNhbGN1bGF0ZSBpZiBuZWl0aGVyIG10eFdvcmxkIG5vciBtdHhQcm9qZWN0aW9uIGhhdmUgY2hhbmdlZFxyXG4gICAgICB0aGlzLiNtdHhXb3JsZFRvVmlldyA9IE1hdHJpeDR4NC5QUk9EVUNUKHRoaXMuI210eFByb2plY3Rpb24sIHRoaXMubXR4Q2FtZXJhSW52ZXJzZSk7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtdHhXb3JsZFRvVmlldztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGludmVyc2lvbiBvZiB0aGlzIGNhbWVyYXMgd29ybGR0cmFuc2Zvcm1hdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG10eENhbWVyYUludmVyc2UoKTogTWF0cml4NHg0IHtcclxuICAgICAgaWYgKHRoaXMuI210eENhbWVyYUludmVyc2UpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI210eENhbWVyYUludmVyc2U7XHJcblxyXG4gICAgICAvL1RPRE86IG9wdGltaXplLCBubyBuZWVkIHRvIHJlY2FsY3VsYXRlIGlmIG10eFdvcmxkIGhhc24ndCBjaGFuZ2VkXHJcbiAgICAgIHRoaXMuI210eENhbWVyYUludmVyc2UgPSBNYXRyaXg0eDQuSU5WRVJTRSh0aGlzLm10eFdvcmxkKTtcclxuICAgICAgcmV0dXJuIHRoaXMuI210eENhbWVyYUludmVyc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9qZWN0aW9ubWF0cml4IG9mIHRoaXMgY2FtZXJhXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbXR4UHJvamVjdGlvbigpOiBNYXRyaXg0eDQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbXR4UHJvamVjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGlzIGNhbWVyYXMge0BsaW5rIG10eFdvcmxkVG9WaWV3fSBhbmQge0BsaW5rIG10eENhbWVyYUludmVyc2V9IG1hdHJpY2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXNldFdvcmxkVG9WaWV3KCk6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy4jbXR4V29ybGRUb1ZpZXcpIFJlY3ljbGVyLnN0b3JlKHRoaXMuI210eFdvcmxkVG9WaWV3KTtcclxuICAgICAgaWYgKHRoaXMuI210eENhbWVyYUludmVyc2UpIFJlY3ljbGVyLnN0b3JlKHRoaXMuI210eENhbWVyYUludmVyc2UpO1xyXG4gICAgICB0aGlzLiNtdHhXb3JsZFRvVmlldyA9IG51bGw7XHJcbiAgICAgIHRoaXMuI210eENhbWVyYUludmVyc2UgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2FtZXJhcyB7QGxpbmsgUFJPSkVDVElPTn0gbW9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UHJvamVjdGlvbigpOiBQUk9KRUNUSU9OIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYmFja2dyb3VuZCBvZiB0aGUgY2FtZXJhIHNob3VsZCBiZSByZW5kZXJlZCwgZmFsc2UgaWYgbm90XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRCYWNrZ3JvdW5kRW5hYmxlZCgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZEVuYWJsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjYW1lcmFzIGFzcGVjdCByYXRpb1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QXNwZWN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2FtZXJhcyBmaWVsZCBvZiB2aWV3IGluIGRlZ3JlZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEZpZWxkT2ZWaWV3KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpZWxkT2ZWaWV3O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2FtZXJhcyBkaXJlY3Rpb24gaS5lLiB0aGUgcGxhbmUgb24gd2hpY2ggdGhlIGZpZWxkT2ZWaWV3LUFuZ2xlIGlzIGdpdmVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXREaXJlY3Rpb24oKTogRklFTERfT0ZfVklFVyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNhbWVyYXMgbmVhciB2YWx1ZSBpLmUuIHRoZSBtaW5pbXVtIGRpc3RhbmNlIHRvIHJlbmRlciBvYmplY3RzIGF0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXROZWFyKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5lYXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjYW1lcmFzIGZhciB2YWx1ZSBpLmUuIHRoZSBtYXhpbXVtIGRpc3RhbmNlIHRvIHJlbmRlciBvYmplY3RzIGF0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRGYXIoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZmFyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjYW1lcmEgdG8gcGVyc3BlY3RpdmUgcHJvamVjdGlvbi4gVGhlIHdvcmxkIG9yaWdpbiBpcyBpbiB0aGUgY2VudGVyIG9mIHRoZSBjYW52YXNlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIF9hc3BlY3QgVGhlIGFzcGVjdCByYXRpbyBiZXR3ZWVuIHdpZHRoIGFuZCBoZWlnaHQgb2YgcHJvamVjdGlvbnNwYWNlLihEZWZhdWx0ID0gY2FudmFzLmNsaWVudFdpZHRoIC8gY2FudmFzLkNsaWVudEhlaWdodClcclxuICAgICAqIEBwYXJhbSBfZmllbGRPZlZpZXcgVGhlIGZpZWxkIG9mIHZpZXcgaW4gRGVncmVlcy4gKERlZmF1bHQgPSA0NSlcclxuICAgICAqIEBwYXJhbSBfZGlyZWN0aW9uIFRoZSBwbGFuZSBvbiB3aGljaCB0aGUgZmllbGRPZlZpZXctQW5nbGUgaXMgZ2l2ZW4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwcm9qZWN0Q2VudHJhbChfYXNwZWN0OiBudW1iZXIgPSB0aGlzLmFzcGVjdFJhdGlvLCBfZmllbGRPZlZpZXc6IG51bWJlciA9IHRoaXMuZmllbGRPZlZpZXcsIF9kaXJlY3Rpb246IEZJRUxEX09GX1ZJRVcgPSB0aGlzLmRpcmVjdGlvbiwgX25lYXI6IG51bWJlciA9IHRoaXMubmVhciwgX2ZhcjogbnVtYmVyID0gdGhpcy5mYXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IF9hc3BlY3Q7XHJcbiAgICAgIHRoaXMuZmllbGRPZlZpZXcgPSBfZmllbGRPZlZpZXc7XHJcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gX2RpcmVjdGlvbjtcclxuICAgICAgdGhpcy5wcm9qZWN0aW9uID0gUFJPSkVDVElPTi5DRU5UUkFMO1xyXG4gICAgICB0aGlzLm5lYXIgPSBfbmVhcjtcclxuICAgICAgdGhpcy5mYXIgPSBfZmFyO1xyXG4gICAgICB0aGlzLiNtdHhQcm9qZWN0aW9uID0gTWF0cml4NHg0LlBST0pFQ1RJT05fQ0VOVFJBTChfYXNwZWN0LCB0aGlzLmZpZWxkT2ZWaWV3LCBfbmVhciwgX2ZhciwgdGhpcy5kaXJlY3Rpb24pOyAvLyBUT0RPOiByZW1vdmUgbWFnaWMgbnVtYmVyc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjYW1lcmEgdG8gb3J0aG9ncmFwaGljIHByb2plY3Rpb24uIERlZmF1bHQgdmFsdWVzIGFyZSBkZXJpdmVkIHRoZSBjYW52YXMgY2xpZW50IGRpbWVuc2lvbnNcclxuICAgICAqIEBwYXJhbSBfbGVmdCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgbGVmdCBib3JkZXIuICAgIFxyXG4gICAgICogQHBhcmFtIF9yaWdodCBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgcmlnaHQgYm9yZGVyLiAgXHJcbiAgICAgKiBAcGFyYW0gX2JvdHRvbSBUaGUgcG9zaXRpb252YWx1ZSBvZiB0aGUgcHJvamVjdGlvbnNwYWNlJ3MgYm90dG9tIGJvcmRlci5cclxuICAgICAqIEBwYXJhbSBfdG9wIFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyB0b3AgYm9yZGVyLiAgICAgIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcHJvamVjdE9ydGhvZ3JhcGhpYyhfbGVmdDogbnVtYmVyID0gLVJlbmRlci5nZXRDYW52YXMoKS5jbGllbnRXaWR0aCAvIDIsIF9yaWdodDogbnVtYmVyID0gUmVuZGVyLmdldENhbnZhcygpLmNsaWVudFdpZHRoIC8gMiwgX2JvdHRvbTogbnVtYmVyID0gUmVuZGVyLmdldENhbnZhcygpLmNsaWVudEhlaWdodCAvIDIsIF90b3A6IG51bWJlciA9IC1SZW5kZXIuZ2V0Q2FudmFzKCkuY2xpZW50SGVpZ2h0IC8gMik6IHZvaWQge1xyXG4gICAgICB0aGlzLnByb2plY3Rpb24gPSBQUk9KRUNUSU9OLk9SVEhPR1JBUEhJQztcclxuICAgICAgdGhpcy4jbXR4UHJvamVjdGlvbiA9IE1hdHJpeDR4NC5QUk9KRUNUSU9OX09SVEhPR1JBUEhJQyhfbGVmdCwgX3JpZ2h0LCBfYm90dG9tLCBfdG9wLCA0MDAsIC00MDApOyAvLyBUT0RPOiBleGFtaW5lIG1hZ2ljIG51bWJlcnMhXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGNhbGN1bGF0ZWQgZGltZW5zaW9uIG9mIGEgcHJvamVjdGlvbiBzdXJmYWNlIGluIHRoZSBoeXBvdGhldGljYWwgZGlzdGFuY2Ugb2YgMSB0byB0aGUgY2FtZXJhXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQcm9qZWN0aW9uUmVjdGFuZ2xlKCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIGxldCB0YW5Gb3Y6IG51bWJlciA9IE1hdGgudGFuKE1hdGguUEkgKiB0aGlzLmZpZWxkT2ZWaWV3IC8gMzYwKTsgLy8gSGFsZiBvZiB0aGUgYW5nbGUsIHRvIGNhbGN1bGF0ZSBkaW1lbnNpb24gZnJvbSB0aGUgY2VudGVyIC0+IHJpZ2h0IGFuZ2xlXHJcbiAgICAgIGxldCB0YW5Ib3Jpem9udGFsOiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgdGFuVmVydGljYWw6IG51bWJlciA9IDA7XHJcblxyXG4gICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5ESUFHT05BTCkge1xyXG4gICAgICAgIGxldCBhc3BlY3Q6IG51bWJlciA9IE1hdGguc3FydCh0aGlzLmFzcGVjdFJhdGlvKTtcclxuICAgICAgICB0YW5Ib3Jpem9udGFsID0gdGFuRm92ICogYXNwZWN0O1xyXG4gICAgICAgIHRhblZlcnRpY2FsID0gdGFuRm92IC8gYXNwZWN0O1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09IEZJRUxEX09GX1ZJRVcuVkVSVElDQUwpIHtcclxuICAgICAgICB0YW5WZXJ0aWNhbCA9IHRhbkZvdjtcclxuICAgICAgICB0YW5Ib3Jpem9udGFsID0gdGFuVmVydGljYWwgKiB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICB9IGVsc2Ugey8vRk9WX0RJUkVDVElPTi5IT1JJWk9OVEFMXHJcbiAgICAgICAgdGFuSG9yaXpvbnRhbCA9IHRhbkZvdjtcclxuICAgICAgICB0YW5WZXJ0aWNhbCA9IHRhbkhvcml6b250YWwgLyB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCB0YW5Ib3Jpem9udGFsICogMiwgdGFuVmVydGljYWwgKiAyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGdpdmVuIHBvaW50IGZyb20gd29ybGQgc3BhY2UgdG8gY2xpcCBzcGFjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRXb3JsZFRvQ2xpcChfcG9pbnRJbldvcmxkU3BhY2U6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMztcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IHRoaXMubXR4V29ybGRUb1ZpZXcuZ2V0KCk7XHJcbiAgICAgIGxldCB3OiBudW1iZXIgPSBtWzNdICogX3BvaW50SW5Xb3JsZFNwYWNlLnggKyBtWzddICogX3BvaW50SW5Xb3JsZFNwYWNlLnkgKyBtWzExXSAqIF9wb2ludEluV29ybGRTcGFjZS56ICsgbVsxNV07XHJcblxyXG4gICAgICByZXN1bHQgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKF9wb2ludEluV29ybGRTcGFjZSwgdGhpcy5tdHhXb3JsZFRvVmlldyk7XHJcbiAgICAgIHJlc3VsdC5zY2FsZSgxIC8gdyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiBwb2ludCBmcm9tIGNsaXAgc3BhY2UgdG8gd29ybGQgc3BhY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvaW50Q2xpcFRvV29ybGQoX3BvaW50SW5DbGlwU3BhY2U6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IG10eFZpZXdUb1dvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSU5WRVJTRSh0aGlzLm10eFdvcmxkVG9WaWV3KTtcclxuICAgICAgbGV0IG06IEZsb2F0MzJBcnJheSA9IG10eFZpZXdUb1dvcmxkLmdldCgpO1xyXG4gICAgICBsZXQgcmF5V29ybGQ6IFZlY3RvcjMgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKF9wb2ludEluQ2xpcFNwYWNlLCBtdHhWaWV3VG9Xb3JsZCwgdHJ1ZSk7XHJcbiAgICAgIGxldCB3OiBudW1iZXIgPSBtWzNdICogX3BvaW50SW5DbGlwU3BhY2UueCArIG1bN10gKiBfcG9pbnRJbkNsaXBTcGFjZS55ICsgbVsxMV0gKiBfcG9pbnRJbkNsaXBTcGFjZS56ICsgbVsxNV07XHJcbiAgICAgIHJheVdvcmxkLnNjYWxlKDEgLyB3KTtcclxuXHJcbiAgICAgIHJldHVybiByYXlXb3JsZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzY2FsaW5nIGZhY3RvciB0aGF0LCBnaXZlbiBhIHBvc2l0aW9uIGluIHdvcmxkIHNwYWNlLCBcclxuICAgICAqIHNjYWxlcyBhbiBvYmplY3QgYXQgdGhhdCBwb3NpdGlvbiBzbyB0aGF0IG9uZSB1bml0IGVxdWFscyBvbmUgKGxvZ2ljYWwpIHBpeGVsIG9uIHRoZSBzY3JlZW4gXHJcbiAgICAgKiB3aGVuIHNlZW4gdGhyb3VnaCB0aGlzIGNhbWVyYS5cclxuICAgICAqIGUuZy4sIGFmdGVyIHNldHRpbmcgdGhlIHNjYWxpbmcsIDEgdW5pdCBpbiB0aGUgd29ybGQgZXF1YWxzIG9uZSAobG9naWNhbCkgcGl4ZWwgb24gdGhlIHNjcmVlbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFdvcmxkVG9QaXhlbFNjYWxlKF9wb3NXb3JsZDogVmVjdG9yMyk6IG51bWJlciB7XHJcbiAgICAgIGxldCBkaXN0YW5jZTogbnVtYmVyID0gdGhpcy5tdHhXb3JsZC50cmFuc2xhdGlvbi5nZXREaXN0YW5jZShfcG9zV29ybGQpO1xyXG4gICAgICBsZXQgc2NhbGU6IG51bWJlcjtcclxuICAgICAgbGV0IHJlY3Q6IFJlY3RhbmdsZSA9IFJlbmRlci5nZXRSZW5kZXJSZWN0YW5nbGUoKTtcclxuICAgICAgc3dpdGNoICh0aGlzLmdldERpcmVjdGlvbigpKSB7XHJcbiAgICAgICAgY2FzZSBGSUVMRF9PRl9WSUVXLlZFUlRJQ0FMOlxyXG4gICAgICAgICAgc2NhbGUgPSAxIC8gcmVjdC5oZWlnaHQgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRklFTERfT0ZfVklFVy5IT1JJWk9OVEFMOlxyXG4gICAgICAgICAgc2NhbGUgPSAxIC8gcmVjdC53aWR0aCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBGSUVMRF9PRl9WSUVXLkRJQUdPTkFMOlxyXG4gICAgICAgICAgc2NhbGUgPSAxIC8gTWF0aC5zcXJ0KChyZWN0LndpZHRoICogcmVjdC5oZWlnaHQpICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzY2FsZSAqIGRpc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmNsckJhY2tncm91bmQsXHJcbiAgICAgICAgYmFja2dyb3VuZEVuYWJsZWQ6IHRoaXMuYmFja2dyb3VuZEVuYWJsZWQsXHJcbiAgICAgICAgcHJvamVjdGlvbjogdGhpcy5wcm9qZWN0aW9uLFxyXG4gICAgICAgIGZpZWxkT2ZWaWV3OiB0aGlzLmZpZWxkT2ZWaWV3LFxyXG4gICAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sXHJcbiAgICAgICAgbmVhcjogdGhpcy5uZWFyLFxyXG4gICAgICAgIGZhcjogdGhpcy5mYXIsXHJcbiAgICAgICAgYXNwZWN0OiB0aGlzLmFzcGVjdFJhdGlvLFxyXG4gICAgICAgIHBpdm90OiB0aGlzLm10eFBpdm90LnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgdGhpcy5jbHJCYWNrZ3JvdW5kLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmJhY2tncm91bmRDb2xvcik7XHJcbiAgICAgIHRoaXMuYmFja2dyb3VuZEVuYWJsZWQgPSBfc2VyaWFsaXphdGlvbi5iYWNrZ3JvdW5kRW5hYmxlZDtcclxuICAgICAgdGhpcy5wcm9qZWN0aW9uID0gX3NlcmlhbGl6YXRpb24ucHJvamVjdGlvbjtcclxuICAgICAgdGhpcy5maWVsZE9mVmlldyA9IF9zZXJpYWxpemF0aW9uLmZpZWxkT2ZWaWV3O1xyXG4gICAgICB0aGlzLmFzcGVjdFJhdGlvID0gX3NlcmlhbGl6YXRpb24uYXNwZWN0O1xyXG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IF9zZXJpYWxpemF0aW9uLmRpcmVjdGlvbjtcclxuICAgICAgdGhpcy5uZWFyID0gX3NlcmlhbGl6YXRpb24ubmVhciA/PyB0aGlzLm5lYXI7XHJcbiAgICAgIHRoaXMuZmFyID0gX3NlcmlhbGl6YXRpb24uZmFyID8/IHRoaXMuZmFyO1xyXG4gICAgICBhd2FpdCB0aGlzLm10eFBpdm90LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnBpdm90KTtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICBzd2l0Y2ggKHRoaXMucHJvamVjdGlvbikge1xyXG4gICAgICAgIGNhc2UgUFJPSkVDVElPTi5PUlRIT0dSQVBISUM6XHJcbiAgICAgICAgICB0aGlzLnByb2plY3RPcnRob2dyYXBoaWMoKTsgLy8gVE9ETzogc2VyaWFsaXplIGFuZCBkZXNlcmlhbGl6ZSBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFBST0pFQ1RJT04uQ0VOVFJBTDpcclxuICAgICAgICAgIHRoaXMucHJvamVjdENlbnRyYWwoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHN1cGVyLmdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcik7XHJcbiAgICAgIGlmICh0eXBlcy5kaXJlY3Rpb24pXHJcbiAgICAgICAgdHlwZXMuZGlyZWN0aW9uID0gRklFTERfT0ZfVklFVztcclxuICAgICAgaWYgKHR5cGVzLnByb2plY3Rpb24pXHJcbiAgICAgICAgdHlwZXMucHJvamVjdGlvbiA9IFBST0pFQ1RJT047XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgYXdhaXQgc3VwZXIubXV0YXRlKF9tdXRhdG9yLCBfc2VsZWN0aW9uLCBfZGlzcGF0Y2hNdXRhdGUpO1xyXG5cclxuICAgICAgc3dpdGNoICh0aGlzLnByb2plY3Rpb24pIHtcclxuICAgICAgICBjYXNlIFBST0pFQ1RJT04uQ0VOVFJBTDpcclxuICAgICAgICAgIHRoaXMucHJvamVjdENlbnRyYWwodGhpcy5hc3BlY3RSYXRpbywgdGhpcy5maWVsZE9mVmlldywgdGhpcy5kaXJlY3Rpb24sIHRoaXMubmVhciwgdGhpcy5mYXIpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZHJhd0dpem1vcygpOiB2b2lkIHtcclxuICAgICAgbGV0IG10eFdvcmxkOiBNYXRyaXg0eDQgPSB0aGlzLm10eFdvcmxkLmNsb25lO1xyXG4gICAgICBtdHhXb3JsZC5zY2FsaW5nID0gbmV3IFZlY3RvcjMoMC41LCAwLjUsIDAuNSk7XHJcbiAgICAgIGxldCBjb2xvcjogQ29sb3IgPSBDb2xvci5DU1MoXCJsaWdodGdyZXlcIik7XHJcbiAgICAgIEdpem1vcy5kcmF3SWNvbihUZXh0dXJlRGVmYXVsdC5pY29uQ2FtZXJhLCBtdHhXb3JsZCwgY29sb3IpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZU11bHRpcGxlKG10eFdvcmxkLCBjb2xvcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRyYXdHaXptb3NTZWxlY3RlZCgpOiB2b2lkIHtcclxuICAgICAgR2l6bW9zLmRyYXdXaXJlRnJ1c3R1bSh0aGlzLmdldEFzcGVjdCgpLCB0aGlzLmdldEZpZWxkT2ZWaWV3KCksIHRoaXMuZ2V0TmVhcigpLCB0aGlzLmdldEZhcigpLCB0aGlzLmdldERpcmVjdGlvbigpLCB0aGlzLm10eFdvcmxkLCBDb2xvci5DU1MoXCJsaWdodGdyZXlcIikpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3IudHJhbnNmb3JtO1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIE1ha2VzIHRoZSBub2RlIGZhY2UgdGhlIGNhbWVyYSB3aGVuIHJlbmRlcmluZywgcmVzcGVjdGluZyByZXN0cmljdGlvbnMgZm9yIHJvdGF0aW9uIGFyb3VuZCBzcGVjaWZpYyBheGlzXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjJcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vaHMtZnVydHdhbmdlbi9GVURHRS93aWtpL0NvbXBvbmVudFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRGYWNlQ2FtZXJhIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRGYWNlQ2FtZXJhKTtcclxuXHJcbiAgICBwdWJsaWMgdXBMb2NhbDogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBwdWJsaWMgdXA6IFZlY3RvcjMgPSBWZWN0b3IzLlkoMSk7XHJcbiAgICBwdWJsaWMgcmVzdHJpY3Q6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2luZ2xldG9uID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBdHRhY2hlZCB0byBhIHtAbGluayBOb2RlfSB3aXRoIGFuIGF0dGFjaGVkIHtAbGluayBDb21wb25lbnRDYW1lcmF9IHRoaXMgY2F1c2VzIHRoZSByZW5kZXJlZCBpbWFnZSB0byByZWNlaXZlIGEgZm9nLWVmZmVjdC5cclxuICAgKiBAYXV0aG9ycyBSb2xhbmQgSGVlciwgSEZVLCAyMDIzXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudEZvZyBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50Rm9nKTtcclxuICAgIHB1YmxpYyBjb2xvcjogQ29sb3I7XHJcbiAgICBwdWJsaWMgbmVhcjogbnVtYmVyO1xyXG4gICAgcHVibGljIGZhcjogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKDEsIDEsIDEsIDEpLCBfbmVhcjogbnVtYmVyID0gMSwgX2ZhcjogbnVtYmVyID0gNTApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5jb2xvciA9IF9jb2xvcjtcclxuICAgICAgdGhpcy5uZWFyID0gX25lYXI7XHJcbiAgICAgIHRoaXMuZmFyID0gX2ZhcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIG5lYXI6IHRoaXMubmVhcixcclxuICAgICAgICBmYXI6IHRoaXMuZmFyXHJcbiAgICAgIH07XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgdGhpcy5jb2xvci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5jb2xvcik7XHJcbiAgICAgIHRoaXMubmVhciA9IF9zZXJpYWxpemF0aW9uLm5lYXIgPz8gdGhpcy5uZWFyO1xyXG4gICAgICB0aGlzLmZhciA9IF9zZXJpYWxpemF0aW9uLmZhciA/PyB0aGlzLmZhcjtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBGaWx0ZXJzIHN5bmNocm9uaXphdGlvbiBiZXR3ZWVuIGEgZ3JhcGggaW5zdGFuY2UgYW5kIHRoZSBncmFwaCBpdCBpcyBjb25uZWN0ZWQgdG8uIElmIGFjdGl2ZSwgbm8gc3luY2hyb25pemF0aW9uIG9jY3Vycy5cclxuICAgKiBNYXliZSBtb3JlIGZpbmVncmFpbmVkIGluIHRoZSBmdXR1cmUuLi5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMlxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ocy1mdXJ0d2FuZ2VuL0ZVREdFL3dpa2kvQ29tcG9uZW50XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudEdyYXBoRmlsdGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRHcmFwaEZpbHRlcik7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNpbmdsZXRvbiA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IHR5cGUgVHlwZU9mTGlnaHQgPSBuZXcgKCkgPT4gTGlnaHQ7XHJcbiAgLyoqXHJcbiAgICogQmFzZWNsYXNzIGZvciBkaWZmZXJlbnQga2luZHMgb2YgbGlnaHRzLiBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMaWdodCBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xyXG4gICAgcHVibGljIGNvbG9yOiBDb2xvcjtcclxuICAgIHB1YmxpYyBpbnRlbnNpdHk6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKSwgX2ludGVuc2l0eTogbnVtYmVyID0gMSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmNvbG9yID0gX2NvbG9yO1xyXG4gICAgICB0aGlzLmludGVuc2l0eSA9IF9pbnRlbnNpdHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgVHlwZU9mTGlnaHR9IG9mIHRoaXMgbGlnaHQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUeXBlKCk6IFR5cGVPZkxpZ2h0IHtcclxuICAgICAgcmV0dXJuIDxUeXBlT2ZMaWdodD50aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIGludGVuc2l0eTogdGhpcy5pbnRlbnNpdHlcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgdGhpcy5jb2xvci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5jb2xvcik7XHJcbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi5pbnRlbnNpdHkgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuaW50ZW5zaXR5ID0gX3NlcmlhbGl6YXRpb24uaW50ZW5zaXR5O1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcigpOiB2b2lkIHsvKiovIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFtYmllbnQgbGlnaHQsIGNvbWluZyBmcm9tIGFsbCBkaXJlY3Rpb25zLCBpbGx1bWluYXRpbmcgZXZlcnl0aGluZyB3aXRoIGl0cyBjb2xvciBpbmRlcGVuZGVudCBvZiBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gKGxpa2UgYSBmb2dneSBkYXkgb3IgaW4gdGhlIHNoYWRlcykgIFxyXG4gICAqIEF0dGFjaGVkIHRvIGEgbm9kZSBieSB7QGxpbmsgQ29tcG9uZW50TGlnaHR9LCB0aGUgcGl2b3QgbWF0cml4IGlzIGlnbm9yZWQuXHJcbiAgICogYGBgdGV4dFxyXG4gICAqIH4gfiB+ICBcclxuICAgKiAgfiB+IH4gIFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBMaWdodEFtYmllbnQgZXh0ZW5kcyBMaWdodCB7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIERpcmVjdGlvbmFsIGxpZ2h0LCBpbGx1bWluYXRpbmcgZXZlcnl0aGluZyBmcm9tIGEgc3BlY2lmaWVkIGRpcmVjdGlvbiB3aXRoIGl0cyBjb2xvciAobGlrZSBzdGFuZGluZyBpbiBicmlnaHQgc3VubGlnaHQpICBcclxuICAgKiBBdHRhY2hlZCB0byBhIG5vZGUgYnkge0BsaW5rIENvbXBvbmVudExpZ2h0fSwgdGhlIHBpdm90IG1hdHJpeCBzcGVjaWZpZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGlnaHQgb25seS5cclxuICAgKiBgYGB0ZXh0XHJcbiAgICogLS0tPiAgXHJcbiAgICogLS0tPiAgXHJcbiAgICogLS0tPiAgXHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIExpZ2h0RGlyZWN0aW9uYWwgZXh0ZW5kcyBMaWdodCB7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIE9tbmlkaXJlY3Rpb25hbCBsaWdodCBlbWl0dGluZyBmcm9tIGl0cyBwb3NpdGlvbiwgaWxsdW1pbmF0aW5nIG9iamVjdHMgZGVwZW5kaW5nIG9uIHRoZWlyIHBvc2l0aW9uIGFuZCBkaXN0YW5jZSB3aXRoIGl0cyBjb2xvciAobGlrZSBhIGNvbG9yZWQgbGlnaHQgYnVsYikgIFxyXG4gICAqIEF0dGFjaGVkIHRvIGEgbm9kZSBieSB7QGxpbmsgQ29tcG9uZW50TGlnaHR9LCB0aGUgcGl2b3QgbWF0cml4IHNwZWNpZmllcyB0aGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0LCBpdCdzIHNoYXBlIGFuZCByb3RhdGlvbi4gXHJcbiAgICogU28gd2l0aCB1bmV2ZW4gc2NhbGluZywgb3RoZXIgc2hhcGVzIHRoYW4gYSBwZXJmZWN0IHNwaGVyZSwgc3VjaCBhcyBhbiBvdmFsIG9yIGEgZGlzYywgYXJlIHBvc3NpYmxlLCB3aGljaCBjcmVhdGVzIGEgdmlzaWJsZSBlZmZlY3Qgb2YgdGhlIHJvdGF0aW9uIHRvby4gXHJcbiAgICogVGhlIGludGVuc2l0eSBvZiB0aGUgbGlnaHQgZHJvcHMgbGluZWFybHkgZnJvbSAxIGluIHRoZSBjZW50ZXIgdG8gMCBhdCB0aGUgcGVyaW1ldGVyIG9mIHRoZSBzaGFwZS5cclxuICAgKiBgYGB0ZXh0XHJcbiAgICogICAgICAgICAuXFx8Ly5cclxuICAgKiAgICAgICAgLS0gbyAtLVxyXG4gICAqICAgICAgICAgwrQvfFxcYFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBMaWdodFBvaW50IGV4dGVuZHMgTGlnaHQge1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTcG90IGxpZ2h0IGVtaXR0aW5nIHdpdGhpbiBhIHNwZWNpZmllZCBhbmdsZSBmcm9tIGl0cyBwb3NpdGlvbiwgaWxsdW1pbmF0aW5nIG9iamVjdHMgZGVwZW5kaW5nIG9uIHRoZWlyIHBvc2l0aW9uIGFuZCBkaXN0YW5jZSB3aXRoIGl0cyBjb2xvciAgXHJcbiAgICogQXR0YWNoZWQgdG8gYSBub2RlIGJ5IHtAbGluayBDb21wb25lbnRMaWdodH0sIHRoZSBwaXZvdCBtYXRyaXggc3BlY2lmaWVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGlnaHQsIHRoZSBkaXJlY3Rpb24gYW5kIHRoZSBzaXplIGFuZCBhbmdsZXMgb2YgdGhlIGNvbmUuXHJcbiAgICogVGhlIGludGVuc2l0eSBvZiB0aGUgbGlnaHQgZHJvcHMgbGluZWFybHkgZnJvbSAxIGluIHRoZSBjZW50ZXIgdG8gMCBhdCB0aGUgb3V0ZXIgbGltaXRzIG9mIHRoZSBjb25lLlxyXG4gICAqIGBgYHRleHRcclxuICAgKiAgICAgICAgICBvICBcclxuICAgKiAgICAgICAgIC98XFwgIFxyXG4gICAqICAgICAgICAvIHwgXFwgXHJcbiAgICogYGBgICAgXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIExpZ2h0U3BvdCBleHRlbmRzIExpZ2h0IHtcclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCIuLi9MaWdodC9MaWdodC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgaWRlbnRpZmllcnMgZm9yIHRoZSB2YXJpb3VzIHR5cGVzIG9mIGxpZ2h0IHRoaXMgY29tcG9uZW50IGNhbiBwcm92aWRlLiAgXHJcbiAgICovXHJcbiAgLy8gZXhwb3J0IGxldCBMSUdIVF9UWVBFOiB7IFt0eXBlOiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcclxuICBleHBvcnQgZW51bSBMSUdIVF9UWVBFIHtcclxuICAgIEFNQklFTlQgPSBcIkxpZ2h0QW1iaWVudFwiLFxyXG4gICAgRElSRUNUSU9OQUwgPSBcIkxpZ2h0RGlyZWN0aW9uYWxcIixcclxuICAgIFBPSU5UID0gXCJMaWdodFBvaW50XCIsXHJcbiAgICBTUE9UID0gXCJMaWdodFNwb3RcIlxyXG4gIH1cclxuICAvKipcclxuICAgICogQXR0YWNoZXMgYSB7QGxpbmsgTGlnaHR9IHRvIHRoZSBub2RlXHJcbiAgICAqIFRoZSBwaXZvdCBtYXRyaXggaGFzIGRpZmZlcmVudCBlZmZlY3RzIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiB0aGUge0BsaW5rIExpZ2h0fS4gU2VlIHRoZXJlIGZvciBkZXRhaWxzLlxyXG4gICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50TGlnaHQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudExpZ2h0KTtcclxuXHJcbiAgICAvLyBwcml2YXRlIHN0YXRpYyBjb25zdHJ1Y3RvcnM6IHsgW3R5cGU6IHN0cmluZ106IEdlbmVyYWwgfSA9IHsgW0xJR0hUX1RZUEUuQU1CSUVOVF06IExpZ2h0QW1iaWVudCwgW0xJR0hUX1RZUEUuRElSRUNUSU9OQUxdOiBMaWdodERpcmVjdGlvbmFsLCBbTElHSFRfVFlQRS5QT0lOVF06IExpZ2h0UG9pbnQsIFtMSUdIVF9UWVBFLlNQT1RdOiBMaWdodFNwb3QgfTtcclxuICAgIHB1YmxpYyBtdHhQaXZvdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICBwdWJsaWMgbGlnaHQ6IExpZ2h0ID0gbnVsbDtcclxuICAgIC8vVE9ETzogc2luY2UgdGhlcmUgaXMgYWxtb3N0IG5vIGZ1bmN0aW9uYWxpdHkgbGVmdCBpbiBMaWdodCwgZWxpbWluYXRlIGl0IGFuZCBwdXQgYWxsIGluIHRoZSBjb21wb25lbnQgYXMgd2l0aCB0aGUgY2FtZXJhLi4uXHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9saWdodDogTGlnaHQgPSBuZXcgTGlnaHRBbWJpZW50KCkpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zaW5nbGV0b24gPSBmYWxzZTtcclxuICAgICAgdGhpcy5saWdodCA9IF9saWdodDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiB1c2UgVHlwZU9mTGlnaHQgYXMgcmV0dXJuIHR5cGU/XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgdHlwZSBvZiB7QGxpbmsgTGlnaHR9IHVzZWQgYnkgdGhpcyBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRUeXBlPFQgZXh0ZW5kcyBMaWdodD4oX2NsYXNzOiBuZXcgKCkgPT4gVCk6IHZvaWQge1xyXG4gICAgICBsZXQgbXRyT2xkOiBNdXRhdG9yID0ge307XHJcbiAgICAgIGlmICh0aGlzLmxpZ2h0KVxyXG4gICAgICAgIG10ck9sZCA9IHRoaXMubGlnaHQuZ2V0TXV0YXRvcigpO1xyXG5cclxuICAgICAgdGhpcy5saWdodCA9IG5ldyBfY2xhc3MoKTtcclxuICAgICAgdGhpcy5saWdodC5tdXRhdGUobXRyT2xkKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBwaXZvdDogdGhpcy5tdHhQaXZvdC5zZXJpYWxpemUoKSxcclxuICAgICAgICBsaWdodDogU2VyaWFsaXplci5zZXJpYWxpemUodGhpcy5saWdodClcclxuICAgICAgfTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIGF3YWl0IHRoaXMubXR4UGl2b3QuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ucGl2b3QpO1xyXG4gICAgICB0aGlzLmxpZ2h0ID0gYXdhaXQgPFByb21pc2U8TGlnaHQ+PlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ubGlnaHQpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKHRydWUpO1xyXG4gICAgICBtdXRhdG9yLnR5cGUgPSB0aGlzLmxpZ2h0LmdldFR5cGUoKS5uYW1lO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSBzdXBlci5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xyXG4gICAgICBpZiAodHlwZXMudHlwZSlcclxuICAgICAgICB0eXBlcy50eXBlID0gTElHSFRfVFlQRTtcclxuICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBsZXQgdHlwZTogc3RyaW5nID0gX211dGF0b3IudHlwZTtcclxuICAgICAgaWYgKHR5cGVvZiAodHlwZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZSAhPSB0aGlzLmxpZ2h0LmNvbnN0cnVjdG9yLm5hbWUpXHJcbiAgICAgICAgdGhpcy5zZXRUeXBlKFNlcmlhbGl6ZXIuZ2V0Q29uc3RydWN0b3I8TGlnaHQ+KHR5cGUpKTtcclxuICAgICAgZGVsZXRlIChfbXV0YXRvci50eXBlKTsgLy8gZXhjbHVkZSBsaWdodCB0eXBlIGZyb20gZnVydGhlciBtdXRhdGlvblxyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IsIF9zZWxlY3Rpb24sIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICAgIF9tdXRhdG9yLnR5cGUgPSB0eXBlOyAvLyByZWNvbnN0cnVjdCBtdXRhdG9yXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRyYXdHaXptb3MoKTogdm9pZCB7XHJcbiAgICAgIGxldCBtdHhTaGFwZTogTWF0cml4NHg0ID0gTWF0cml4NHg0LlBST0RVQ1QodGhpcy5ub2RlLm10eFdvcmxkLCB0aGlzLm10eFBpdm90KTtcclxuICAgICAgbXR4U2hhcGUuc2NhbGluZyA9IG5ldyBWZWN0b3IzKDAuNSwgMC41LCAwLjUpO1xyXG4gICAgICBHaXptb3MuZHJhd0ljb24oVGV4dHVyZURlZmF1bHQuaWNvbkxpZ2h0LCBtdHhTaGFwZSwgdGhpcy5saWdodC5jb2xvcik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFNoYXBlKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGRyYXdHaXptb3NTZWxlY3RlZCgpOiB2b2lkIHtcclxuICAgICAgbGV0IG10eFNoYXBlOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUFJPRFVDVCh0aGlzLm5vZGUubXR4V29ybGQsIHRoaXMubXR4UGl2b3QpO1xyXG4gICAgICBsZXQgY29sb3I6IENvbG9yID0gQ29sb3IuQ1NTKFwieWVsbG93XCIpO1xyXG5cclxuICAgICAgc3dpdGNoICh0aGlzLmxpZ2h0LmdldFR5cGUoKSkge1xyXG4gICAgICAgIGNhc2UgTGlnaHREaXJlY3Rpb25hbDpcclxuICAgICAgICAgIGNvbnN0IHJhZGl1czogbnVtYmVyID0gMC41O1xyXG4gICAgICAgICAgR2l6bW9zLmRyYXdXaXJlQ2lyY2xlKG10eFNoYXBlLCBjb2xvcik7XHJcbiAgICAgICAgICBjb25zdCBsaW5lczogVmVjdG9yM1tdID0gbmV3IEFycmF5KDEwKS5maWxsKG51bGwpLm1hcCgoKSA9PiBSZWN5Y2xlci5nZXQoVmVjdG9yMykpO1xyXG4gICAgICAgICAgbGluZXNbMF0uc2V0KDAsIDAsIDApOyBsaW5lc1sxXS5zZXQoMCwgMCwgMSk7XHJcbiAgICAgICAgICBsaW5lc1syXS5zZXQoMCwgcmFkaXVzLCAwKTsgbGluZXNbM10uc2V0KDAsIHJhZGl1cywgMSk7XHJcbiAgICAgICAgICBsaW5lc1s2XS5zZXQoMCwgLXJhZGl1cywgMCk7IGxpbmVzWzddLnNldCgwLCAtcmFkaXVzLCAxKTtcclxuICAgICAgICAgIGxpbmVzWzRdLnNldChyYWRpdXMsIDAsIDApOyBsaW5lc1s1XS5zZXQocmFkaXVzLCAwLCAxKTtcclxuICAgICAgICAgIGxpbmVzWzhdLnNldCgtcmFkaXVzLCAwLCAwKTsgbGluZXNbOV0uc2V0KC1yYWRpdXMsIDAsIDEpO1xyXG4gICAgICAgICAgR2l6bW9zLmRyYXdMaW5lcyhsaW5lcywgbXR4U2hhcGUsIGNvbG9yKTtcclxuICAgICAgICAgIFJlY3ljbGVyLnN0b3JlTXVsdGlwbGUoLi4ubGluZXMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBMaWdodFBvaW50OlxyXG4gICAgICAgICAgbXR4U2hhcGUuc2NhbGUobmV3IFZlY3RvcjMoMiwgMiwgMikpO1xyXG4gICAgICAgICAgR2l6bW9zLmRyYXdXaXJlU3BoZXJlKG10eFNoYXBlLCBjb2xvcik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIExpZ2h0U3BvdDpcclxuICAgICAgICAgIEdpem1vcy5kcmF3V2lyZUNvbmUobXR4U2hhcGUsIGNvbG9yKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBSZWN5Y2xlci5zdG9yZU11bHRpcGxlKG10eFNoYXBlLCBjb2xvcik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgYSB7QGxpbmsgTWF0ZXJpYWx9IHRvIHRoZSBub2RlXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTkgLSAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudE1hdGVyaWFsIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRNYXRlcmlhbCk7XHJcbiAgICBwdWJsaWMgY2xyUHJpbWFyeTogQ29sb3IgPSBDb2xvci5DU1MoXCJ3aGl0ZVwiKTtcclxuICAgIHB1YmxpYyBjbHJTZWNvbmRhcnk6IENvbG9yID0gQ29sb3IuQ1NTKFwid2hpdGVcIik7XHJcbiAgICBwdWJsaWMgbXR4UGl2b3Q6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5JREVOVElUWSgpO1xyXG4gICAgQHR5cGUoTWF0ZXJpYWwpXHJcbiAgICBwdWJsaWMgbWF0ZXJpYWw6IE1hdGVyaWFsO1xyXG4gICAgLyoqIFN1cHBvcnQgc29ydGluZyBvZiBvYmplY3RzIHdpdGggdHJhbnNwYXJlbmN5IHdoZW4gcmVuZGVyaW5nLCByZW5kZXIgb2JqZWN0cyBpbiB0aGUgYmFjayBmaXJzdC4gV2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1c2VkIGFzIGEgcGFydCBvZiBhIHtAbGluayBQYXJ0aWNsZVN5c3RlbX0sIHRyeSBlbmFibGluZyB0aGlzIHdoZW4gZGlzYWJsaW5nIHtAbGluayBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbS5kZXB0aE1hc2t9ICovXHJcbiAgICBwdWJsaWMgc29ydEZvckFscGhhOiBib29sZWFuID0gZmFsc2U7IC8vIFRPRE86IG1heWJlIG1ha2UgdGhpcyBhIHByb3BlcnR5IG9mIHRoZSBtYXRlcmlhbD9cclxuICAgIC8vIHB1YmxpYyBtdXRhdG9yQ29hdDogTXV0YXRvckZvckNvbXBvbmVudDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX21hdGVyaWFsOiBNYXRlcmlhbCA9IG51bGwpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5tYXRlcmlhbCA9IF9tYXRlcmlhbDtcclxuICAgICAgLy8gdGhpcy5tdXRhdG9yQ29hdCA9IF9tYXRlcmlhbC5nZXRDb2F0KCkuZ2V0TXV0YXRvckZvckNvbXBvbmVudCgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIHNvcnRGb3JBbHBoYTogdGhpcy5zb3J0Rm9yQWxwaGEsXHJcbiAgICAgICAgY2xyUHJpbWFyeTogdGhpcy5jbHJQcmltYXJ5LnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIGNsclNlY29uZGFyeTogdGhpcy5jbHJTZWNvbmRhcnkuc2VyaWFsaXplKCksXHJcbiAgICAgICAgcGl2b3Q6IHRoaXMubXR4UGl2b3Quc2VyaWFsaXplKCksXHJcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKSxcclxuICAgICAgICBpZE1hdGVyaWFsOiB0aGlzLm1hdGVyaWFsLmlkUmVzb3VyY2VcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMubWF0ZXJpYWwgPSA8TWF0ZXJpYWw+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZE1hdGVyaWFsKTtcclxuICAgICAgYXdhaXQgdGhpcy5jbHJQcmltYXJ5LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmNsclByaW1hcnkpO1xyXG4gICAgICBhd2FpdCB0aGlzLmNsclNlY29uZGFyeS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5jbHJTZWNvbmRhcnkpO1xyXG4gICAgICB0aGlzLnNvcnRGb3JBbHBoYSA9IF9zZXJpYWxpemF0aW9uLnNvcnRGb3JBbHBoYTtcclxuICAgICAgYXdhaXQgdGhpcy5tdHhQaXZvdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5waXZvdCk7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBhIHtAbGluayBNZXNofSB0byB0aGUgbm9kZVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgQGVudW1lcmF0ZVxyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRNZXNoIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRNZXNoKTtcclxuICAgIHB1YmxpYyByZWFkb25seSBtdHhXb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcblxyXG4gICAgQHR5cGUoTWVzaClcclxuICAgIHB1YmxpYyBtZXNoOiBNZXNoO1xyXG4gICAgcHVibGljIHNrZWxldG9uOiBDb21wb25lbnRTa2VsZXRvbjtcclxuXHJcbiAgICAjbXR4UGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbWVzaD86IE1lc2gsIF9za2VsZXRvbj86IENvbXBvbmVudFNrZWxldG9uKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubWVzaCA9IF9tZXNoO1xyXG4gICAgICB0aGlzLnNrZWxldG9uID0gX3NrZWxldG9uO1xyXG4gICAgfVxyXG5cclxuICAgIEBlbnVtZXJhdGVcclxuICAgIHB1YmxpYyBnZXQgbXR4UGl2b3QoKTogTWF0cml4NHg0IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI210eFBpdm90O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgbXR4UGl2b3QoX210eDogTWF0cml4NHg0KSB7XHJcbiAgICAgIHRoaXMuI210eFBpdm90ID0gX210eDtcclxuICAgICAgdGhpcy4jbXR4UGl2b3QubW9kaWZpZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgcmFkaXVzKCk6IG51bWJlciB7XHJcbiAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gdGhpcy5tdHhXb3JsZC5zY2FsaW5nO1xyXG4gICAgICBsZXQgc2NhbGU6IG51bWJlciA9IE1hdGgubWF4KE1hdGguYWJzKHNjYWxpbmcueCksIE1hdGguYWJzKHNjYWxpbmcueSksIE1hdGguYWJzKHNjYWxpbmcueikpO1xyXG4gICAgICByZXR1cm4gdGhpcy5tZXNoLnJhZGl1cyAqIHNjYWxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIC8qKlxyXG4gICAgLy8gICogQ2FsY3VsYXRlcyB0aGUgcG9zaXRpb24gb2YgYSB2ZXJ0ZXggdHJhbnNmb3JtZWQgYnkgdGhlIHNrZWxldG9uXHJcbiAgICAvLyAgKiBAcGFyYW0gX2luZGV4IGluZGV4IG9mIHRoZSB2ZXJ0ZXhcclxuICAgIC8vICAqL1xyXG4gICAgLy8gcHVibGljIGdldFZlcnRleFBvc2l0aW9uKF9pbmRleDogbnVtYmVyKTogVmVjdG9yMyB7XHJcbiAgICAvLyAgIC8vIGV4dHJhY3QgdGhlIHZlcnRleCBkYXRhICh2ZXJ0aWNlczogM0QgdmVjdG9ycywgYm9uZSBpbmRpY2VzICYgd2VpZ2h0czogNEQgdmVjdG9ycylcclxuICAgIC8vICAgY29uc3QgaVZlcnRleDogbnVtYmVyID0gX2luZGV4ICogMztcclxuICAgIC8vICAgY29uc3QgaUJvbmVJbmZsdWVuY2U6IG51bWJlciA9IF9pbmRleCAqIDQ7XHJcblxyXG4gICAgLy8gICBjb25zdCB2ZXJ0ZXg6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMyguLi5SZWZsZWN0LmdldCh0aGlzLm1lc2gsIFwicmVuZGVyTWVzaFwiKS52ZXJ0aWNlcy5zbGljZShpVmVydGV4LCBpVmVydGV4ICsgMykpO1xyXG4gICAgLy8gICBpZiAoISh0aGlzLm1lc2ggaW5zdGFuY2VvZiBNZXNoU2tpbikpIHJldHVybiB2ZXJ0ZXg7XHJcblxyXG4gICAgLy8gICBjb25zdCBpQm9uZXM6IFVpbnQ4QXJyYXkgPSB0aGlzLm1lc2guaUJvbmVzLnNsaWNlKGlCb25lSW5mbHVlbmNlLCBpQm9uZUluZmx1ZW5jZSArIDQpO1xyXG4gICAgLy8gICBjb25zdCB3ZWlnaHRzOiBGbG9hdDMyQXJyYXkgPSB0aGlzLm1lc2gud2VpZ2h0cy5zbGljZShpQm9uZUluZmx1ZW5jZSwgaUJvbmVJbmZsdWVuY2UgKyA0KTtcclxuXHJcbiAgICAvLyAgIC8vIGdldCBib25lIG1hdHJpY2VzXHJcbiAgICAvLyAgIGNvbnN0IG10eEJvbmVzOiBBcnJheTxNYXRyaXg0eDQ+ID0gdGhpcy5za2VsZXRvbi5tdHhCb25lcztcclxuXHJcbiAgICAvLyAgIC8vIHNraW4gbWF0cml4IFMgPSBzdW1faT0xXm17d19pICogQl9pfVxyXG4gICAgLy8gICBjb25zdCBza2luTWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0KCk7XHJcbiAgICAvLyAgIHNraW5NYXRyaXguc2V0KEFycmF5XHJcbiAgICAvLyAgICAgLmZyb20oaUJvbmVzKVxyXG4gICAgLy8gICAgIC5tYXAoKGlCb25lLCBpV2VpZ2h0KSA9PiBtdHhCb25lc1tpQm9uZV0uZ2V0KCkubWFwKHZhbHVlID0+IHZhbHVlICogd2VpZ2h0c1tpV2VpZ2h0XSkpIC8vIGFwcGx5IHdlaWdodCBvbiBlYWNoIG1hdHJpeFxyXG4gICAgLy8gICAgIC5yZWR1Y2UoKG10eFN1bSwgbXR4Qm9uZSkgPT4gbXR4U3VtLm1hcCgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZSArIG10eEJvbmVbaW5kZXhdKSkgLy8gc3VtIHVwIHRoZSBtYXRyaWNlc1xyXG4gICAgLy8gICApO1xyXG5cclxuICAgIC8vICAgLy8gdHJhbnNmb3JtIHZlcnRleFxyXG4gICAgLy8gICB2ZXJ0ZXgudHJhbnNmb3JtKHNraW5NYXRyaXgpO1xyXG5cclxuICAgIC8vICAgcmV0dXJuIHZlcnRleDtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyBUT0RPOiByZW1vdmUgb3IgdGhpbmsgaWYgdGhlIHRyYW5zZm9ybWVkIGJvdW5kaW5nIGJveCBpcyBvZiB2YWx1ZSBvciBjYW4gYmUgbWFkZSB0byBiZVxyXG4gICAgLy8gcHVibGljIGdldCBib3VuZGluZ0JveCgpOiBCb3gge1xyXG4gICAgLy8gICBsZXQgYm94OiBCb3ggPSBSZWN5Y2xlci5nZXQoQm94KTtcclxuICAgIC8vICAgYm94LnNldChcclxuICAgIC8vICAgICBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKHRoaXMubWVzaC5ib3VuZGluZ0JveC5taW4sIHRoaXMubXR4V29ybGQsIHRydWUpLFxyXG4gICAgLy8gICAgIFZlY3RvcjMuVFJBTlNGT1JNQVRJT04odGhpcy5tZXNoLmJvdW5kaW5nQm94Lm1heCwgdGhpcy5tdHhXb3JsZCwgdHJ1ZSlcclxuICAgIC8vICAgKTtcclxuICAgIC8vICAgcmV0dXJuIGJveDtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uO1xyXG4gICAgICAvKiBhdCB0aGlzIHBvaW50IG9mIHRpbWUsIHNlcmlhbGl6YXRpb24gYXMgcmVzb3VyY2UgYW5kIGFzIGlubGluZSBvYmplY3QgaXMgcG9zc2libGUuIFRPRE86IGNoZWNrIGlmIGlubGluZSBiZWNvbWVzIG9ic29sZXRlICovXHJcbiAgICAgIGxldCBpZE1lc2g6IHN0cmluZyA9IHRoaXMubWVzaC5pZFJlc291cmNlO1xyXG4gICAgICBpZiAoaWRNZXNoKVxyXG4gICAgICAgIHNlcmlhbGl6YXRpb24gPSB7IGlkTWVzaDogaWRNZXNoIH07XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBzZXJpYWxpemF0aW9uID0geyBtZXNoOiBTZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLm1lc2gpIH07XHJcblxyXG4gICAgICBpZiAodGhpcy5za2VsZXRvbilcclxuICAgICAgICBzZXJpYWxpemF0aW9uLnNrZWxldG9uID0gTm9kZS5QQVRIX0ZST01fVE8odGhpcywgdGhpcy5za2VsZXRvbik7XHJcblxyXG4gICAgICBzZXJpYWxpemF0aW9uLnBpdm90ID0gdGhpcy5tdHhQaXZvdC5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBsZXQgbWVzaDogTWVzaDtcclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkTWVzaClcclxuICAgICAgICBtZXNoID0gPE1lc2g+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZE1lc2gpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgbWVzaCA9IDxNZXNoPmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ubWVzaCk7XHJcbiAgICAgIHRoaXMubWVzaCA9IG1lc2g7XHJcblxyXG4gICAgICBpZiAoX3NlcmlhbGl6YXRpb24uc2tlbGV0b24pIHtcclxuICAgICAgICBjb25zdCBobmROb2RlRGVzZXJpYWxpemVkOiBFdmVudExpc3RlbmVyVW5pZmllZCA9ICgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGhuZEdyYXBoRGVzZXJpYWxpemVkOiBFdmVudExpc3RlbmVyVW5pZmllZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5za2VsZXRvbiA9IE5vZGUuRklORCh0aGlzLCBfc2VyaWFsaXphdGlvbi5za2VsZXRvbik7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULkdSQVBIX0RFU0VSSUFMSVpFRCwgaG5kR3JhcGhEZXNlcmlhbGl6ZWQsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQsIGhuZE5vZGVEZXNlcmlhbGl6ZWQpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkdSQVBIX0RFU0VSSUFMSVpFRCwgaG5kR3JhcGhEZXNlcmlhbGl6ZWQsIHRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVTRVJJQUxJWkVELCBobmROb2RlRGVzZXJpYWxpemVkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYXdhaXQgdGhpcy5tdHhQaXZvdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5waXZvdCk7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgcHVibGljIGRyYXdHaXptb3NTZWxlY3RlZCgpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLm1lc2gpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBsZXQgY29sb3I6IENvbG9yID0gQ29sb3IuQ1NTKFwic2FsbW9uXCIpO1xyXG4gICAgICBHaXptb3MuZHJhd1dpcmVNZXNoKHRoaXMubWVzaCwgdGhpcy5tdHhXb3JsZCwgY29sb3IsIDAuMSk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKGNvbG9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVkIHRvIGEge0BsaW5rIE5vZGV9IHdpdGggYW4gYXR0YWNoZWQge0BsaW5rIENvbXBvbmVudENhbWVyYX0gdGhpcyBjYXVzZXMgYWxsIG5vZGVzIGluIHtAbGluayBzZWxlY3Rpb259IHRvIGJlIGRyYXduIHdpdGggYSAxcHggb3V0bGluZS5cclxuICAgKiBAYXV0aG9ycyBKb25hcyBQbG90emt5LCBIRlUsIDIwMjVcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50T3V0bGluZSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgY29sb3I6IENvbG9yO1xyXG4gICAgcHVibGljIGNvbG9yT2NjbHVkZWQ6IENvbG9yO1xyXG4gICAgcHVibGljIHNlbGVjdGlvbjogSXRlcmFibGU8Tm9kZT47XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9zZWxlY3Rpb246IE5vZGVbXSA9IFtdLCBfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDEpLCBfY29sb3JPY2NsdWRlZDogQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zZWxlY3Rpb24gPSBfc2VsZWN0aW9uO1xyXG4gICAgICB0aGlzLmNvbG9yID0gX2NvbG9yO1xyXG4gICAgICB0aGlzLmNvbG9yT2NjbHVkZWQgPSBfY29sb3JPY2NsdWRlZDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgZXhwb3J0IGVudW0gUEFSVElDTEVfU1lTVEVNX1BMQVlNT0RFIHtcclxuICAgIC8qKlBsYXlzIHBhcnRpY2xlIHN5c3RlbSBpbiBhIGxvb3A6IGl0IHJlc3RhcnRzIG9uY2UgaXQgaGl0IHRoZSBlbmQuKi9cclxuICAgIExPT1AsXHJcbiAgICAvKipQbGF5cyBwYXJ0aWNsZSBzeXN0ZW0gb25jZSBhbmQgc3RvcHMgYXQgdGhlIGxhc3QgcG9pbnQgaW4gdGltZS4qL1xyXG4gICAgUExBWV9PTkNFXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBhIHtAbGluayBQYXJ0aWNsZVN5c3RlbX0gdG8gdGhlIG5vZGUuIFxyXG4gICAqIFdvcmtzIGluIGNvbmp1bmN0aW9uIHdpdGgge0BsaW5rIENvbXBvbmVudE1lc2h9IGFuZCB7QGxpbmsgQ29tcG9uZW50TWF0ZXJpYWx9IHRvIGNyZWF0ZSBhIHNoYWRlciBwYXJ0aWNsZSBzeXN0ZW0uXHJcbiAgICogQWRkaXRpb25hbGx5IGEge0BsaW5rIENvbXBvbmVudEZhY2VDYW1lcmF9IGNhbiBiZSBhdHRhY2hlZCB0byBtYWtlIHRoZSBwYXJ0aWNsZXMgZmFjZSB0aGUgY2FtZXJhLlxyXG4gICAqIEBhdXRob3IgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIyXHJcbiAgICovXHJcbiAgQGVudW1lcmF0ZVxyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50UGFydGljbGVTeXN0ZW0pO1xyXG4gICAgQHR5cGUoUGFydGljbGVTeXN0ZW0pXHJcbiAgICBwdWJsaWMgcGFydGljbGVTeXN0ZW06IFBhcnRpY2xlU3lzdGVtO1xyXG4gICAgLyoqIFdoZW4gZGlzYWJsZWQgdHJ5IGVuYWJsaW5nIHtAbGluayBDb21wb25lbnRNYXRlcmlhbC5zb3J0Rm9yQWxwaGF9ICovXHJcbiAgICBwdWJsaWMgZGVwdGhNYXNrOiBib29sZWFuO1xyXG4gICAgcHVibGljIGJsZW5kTW9kZTogQkxFTkQ7XHJcbiAgICBwdWJsaWMgcGxheU1vZGU6IFBBUlRJQ0xFX1NZU1RFTV9QTEFZTU9ERTtcclxuICAgIHB1YmxpYyBkdXJhdGlvbjogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgQSB0ZXh0dXJlIGZpbGVkIHdpdGggcmFuZG9tIG51bWJlcnMuIFVzZWQgYnkgdGhlIHJlbmRlciBlbmdpbmUgKi9cclxuICAgIHByb3RlY3RlZCByZW5kZXJEYXRhOiB1bmtub3duO1xyXG5cclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHBhcnRpY2xlcyAqL1xyXG4gICAgI3NpemU6IG51bWJlcjtcclxuICAgICN0aW1lU2NhbGU6IG51bWJlciA9IDE7XHJcbiAgICByZWFkb25seSAjdGltZTogVGltZTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3BhcnRpY2xlU3lzdGVtOiBQYXJ0aWNsZVN5c3RlbSA9IG51bGwpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5wYXJ0aWNsZVN5c3RlbSA9IF9wYXJ0aWNsZVN5c3RlbTtcclxuICAgICAgdGhpcy5kZXB0aE1hc2sgPSB0cnVlO1xyXG4gICAgICB0aGlzLmJsZW5kTW9kZSA9IEJMRU5ELkFERElUSVZFO1xyXG4gICAgICB0aGlzLnBsYXlNb2RlID0gUEFSVElDTEVfU1lTVEVNX1BMQVlNT0RFLkxPT1A7XHJcbiAgICAgIHRoaXMuZHVyYXRpb24gPSAxMDAwO1xyXG4gICAgICB0aGlzLnNpemUgPSAxMDtcclxuICAgICAgdGhpcy4jdGltZSA9IG5ldyBUaW1lKCk7XHJcblxyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy5obmRFdmVudCk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLmhuZEV2ZW50KTtcclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVTRVJJQUxJWkVELCB0aGlzLmhuZEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIHBhcnRpY2xlc1xyXG4gICAgICovXHJcbiAgICBAZW51bWVyYXRlXHJcbiAgICBwdWJsaWMgZ2V0IHNpemUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG51bWJlciBvZiBwYXJ0aWNsZXMuIENhdXRpb246IFNldHRpbmcgdGhpcyB3aWxsIHJlaW5pdGlhbGl6ZSB0aGUgcmFuZG9tIG51bWJlcnMgYXJyYXkodGV4dHVyZSkgdXNlZCBpbiB0aGUgc2hhZGVyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IHNpemUoX3NpemU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzaXplID0gX3NpemU7XHJcbiAgICAgIHRoaXMuZGVsZXRlUmVuZGVyRGF0YSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdGltZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jdGltZS5nZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHRpbWUoX3RpbWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiN0aW1lLnNldChfdGltZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB0aW1lU2NhbGUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3RpbWVTY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHRpbWVTY2FsZShfc2NhbGU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiN0aW1lU2NhbGUgPSBfc2NhbGU7XHJcbiAgICAgIHRoaXMudXBkYXRlVGltZVNjYWxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogR2VuZXJhdGVzIGFuZCBiaW5kcyB0aGUgcmFuZG9tIG51bWJlcnMgdGV4dHVyZSBpbiBXZWJHTFxyXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yQ29tcG9uZW50UGFydGljbGVTeXN0ZW19LiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLlxyXG4gICAgICogQGludGVybmFsIFxyXG4gICAgICovXHJcbiAgICBAUmVuZGVySW5qZWN0b3JDb21wb25lbnRQYXJ0aWNsZVN5c3RlbS5kZWNvcmF0ZVxyXG4gICAgcHVibGljIHVzZVJlbmRlckRhdGEoKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogRGVsZXRlcyB0aGUgcmFuZG9tIG51bWJlcnMgdGV4dHVyZSBpbiBXZWJHTCBmcmVlaW5nIHRoZSBhbGxvY2F0ZWQgZ3B1IG1lbW9yeS5cclxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvckNvbXBvbmVudFBhcnRpY2xlU3lzdGVtfS4gXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgQFJlbmRlckluamVjdG9yQ29tcG9uZW50UGFydGljbGVTeXN0ZW0uZGVjb3JhdGVcclxuICAgIHB1YmxpYyBkZWxldGVSZW5kZXJEYXRhKCk6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxyXG5cclxuICAgIC8vI3JlZ2lvbiB0cmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKSxcclxuICAgICAgICBpZFBhcnRpY2xlU3lzdGVtOiB0aGlzLnBhcnRpY2xlU3lzdGVtPy5pZFJlc291cmNlLFxyXG4gICAgICAgIGRlcHRoTWFzazogdGhpcy5kZXB0aE1hc2ssXHJcbiAgICAgICAgYmxlbmRNb2RlOiB0aGlzLmJsZW5kTW9kZSxcclxuICAgICAgICBwbGF5TW9kZTogdGhpcy5wbGF5TW9kZSxcclxuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICBzaXplOiB0aGlzLnNpemVcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkUGFydGljbGVTeXN0ZW0pIHRoaXMucGFydGljbGVTeXN0ZW0gPSA8UGFydGljbGVTeXN0ZW0+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZFBhcnRpY2xlU3lzdGVtKTtcclxuICAgICAgdGhpcy5kZXB0aE1hc2sgPSBfc2VyaWFsaXphdGlvbi5kZXB0aE1hc2s7XHJcbiAgICAgIHRoaXMuYmxlbmRNb2RlID0gX3NlcmlhbGl6YXRpb24uYmxlbmRNb2RlO1xyXG4gICAgICB0aGlzLnBsYXlNb2RlID0gX3NlcmlhbGl6YXRpb24ucGxheU1vZGU7XHJcbiAgICAgIHRoaXMuZHVyYXRpb24gPSBfc2VyaWFsaXphdGlvbi5kdXJhdGlvbjtcclxuICAgICAgdGhpcy5zaXplID0gX3NlcmlhbGl6YXRpb24uc2l6ZTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yRm9yQW5pbWF0aW9uKCk6IE11dGF0b3JGb3JBbmltYXRpb24ge1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvckZvckFuaW1hdGlvbiA9IDxNdXRhdG9yRm9yQW5pbWF0aW9uPnRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBkZWxldGUgbXV0YXRvci5wYXJ0aWNsZVN5c3RlbTtcclxuICAgICAgZGVsZXRlIG11dGF0b3Iuc2l6ZTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gc3VwZXIuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKHR5cGVzLmJsZW5kTW9kZSlcclxuICAgICAgICB0eXBlcy5ibGVuZE1vZGUgPSBCTEVORDtcclxuICAgICAgaWYgKHR5cGVzLnBsYXlNb2RlKVxyXG4gICAgICAgIHR5cGVzLnBsYXlNb2RlID0gUEFSVElDTEVfU1lTVEVNX1BMQVlNT0RFO1xyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBwcml2YXRlIGhuZEV2ZW50ID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgc3dpdGNoIChfZXZlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgRVZFTlQuTk9ERV9ERVNFUklBTElaRUQ6XHJcbiAgICAgICAgY2FzZSBFVkVOVC5DT01QT05FTlRfQUREOlxyXG4gICAgICAgICAgVGltZS5nYW1lLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuVElNRV9TQ0FMRUQsIHRoaXMudXBkYXRlVGltZVNjYWxlKTtcclxuICAgICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULlJFTkRFUl9QUkVQQVJFLCB0aGlzLnVwZGF0ZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEVWRU5ULkNPTVBPTkVOVF9SRU1PVkU6XHJcbiAgICAgICAgICBUaW1lLmdhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5USU1FX1NDQUxFRCwgdGhpcy51cGRhdGVUaW1lU2NhbGUpO1xyXG4gICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuUkVOREVSX1BSRVBBUkUsIHRoaXMudXBkYXRlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgaWYgKHRoaXMudGltZSA+IHRoaXMuZHVyYXRpb24pXHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnBsYXlNb2RlKSB7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY2FzZSBQQVJUSUNMRV9TWVNURU1fUExBWU1PREUuTE9PUDpcclxuICAgICAgICAgICAgdGhpcy50aW1lID0gMDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFBBUlRJQ0xFX1NZU1RFTV9QTEFZTU9ERS5QTEFZX09OQ0U6XHJcbiAgICAgICAgICAgIHRoaXMudGltZSA9IHRoaXMuZHVyYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMudGltZVNjYWxlID0gMDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZVRpbWVTY2FsZSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgbGV0IHRpbWVTY2FsZTogbnVtYmVyID0gdGhpcy4jdGltZVNjYWxlICogVGltZS5nYW1lLmdldFNjYWxlKCk7XHJcbiAgICAgIHRoaXMuI3RpbWUuc2V0U2NhbGUodGltZVNjYWxlKTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGVudW0gUElDSyB7XHJcbiAgICBSQURJVVMgPSBcInJhZGl1c1wiLFxyXG4gICAgQ0FNRVJBID0gXCJjYW1lcmFcIixcclxuICAgIFBIWVNJQ1MgPSBcInBoeXNpY3NcIlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGlja2luZyBmdW5jdGlvbmFsaXR5IHRvIHRoZSBub2RlXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50UGljayBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50UGljayk7XHJcbiAgICBwdWJsaWMgcGljazogUElDSyA9IFBJQ0suUkFESVVTO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGlja3MgdGhlIG5vZGUgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB7QGxpbmsgUmF5fSBhbmQgaW52b2tlcyBldmVudHMgYWNjb3JkaW5nbHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBpY2tBbmREaXNwYXRjaChfcmF5OiBSYXksIF9ldmVudDogUG9pbnRlckV2ZW50KTogdm9pZCB7XHJcbiAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gdGhpcy5ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IzID0gY21wTWVzaCA/IGNtcE1lc2gubXR4V29ybGQudHJhbnNsYXRpb24gOiB0aGlzLm5vZGUubXR4V29ybGQudHJhbnNsYXRpb247XHJcblxyXG4gICAgICBzd2l0Y2ggKHRoaXMucGljaykge1xyXG4gICAgICAgIGNhc2UgUElDSy5SQURJVVM6XHJcbiAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgb25seSBiZSBub2RlLnJhZGl1cy4gQWRqdXN0bWVudCBuZWVkZWQsIGlmIG1lc2ggd2FzIHRyYW5zZm9ybWVkLi4uXHJcbiAgICAgICAgICBpZiAoX3JheS5nZXREaXN0YW5jZShwb3NpdGlvbikubWFnbml0dWRlIDwgdGhpcy5ub2RlLnJhZGl1cykge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUuZGlzcGF0Y2hFdmVudChfZXZlbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBQSUNLLlBIWVNJQ1M6XHJcbiAgICAgICAgICBsZXQgaGl0SW5mbzogUmF5SGl0SW5mbyA9IFBoeXNpY3MucmF5Y2FzdChfcmF5Lm9yaWdpbiwgX3JheS5kaXJlY3Rpb24sIFZlY3RvcjMuRElGRkVSRU5DRShwb3NpdGlvbiwgX3JheS5vcmlnaW4pLm1hZ25pdHVkZVNxdWFyZWQpO1xyXG4gICAgICAgICAgaWYgKGhpdEluZm8uaGl0KVxyXG4gICAgICAgICAgICB0aGlzLm5vZGUuZGlzcGF0Y2hFdmVudChfZXZlbnQpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy9UT0RPOiBQSUNLLkNBTUVSQVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gc3VwZXIuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKHR5cGVzLnBpY2spXHJcbiAgICAgICAgdHlwZXMucGljayA9IFBJQ0s7XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZHJhd0dpem1vc1NlbGVjdGVkKF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSk6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy5waWNrICE9IFBJQ0suUkFESVVTKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCB0cmFuc2xhdGlvbjogVmVjdG9yMyA9ICh0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpPy5tdHhXb3JsZCA/PyB0aGlzLm5vZGUubXR4V29ybGQpLnRyYW5zbGF0aW9uO1xyXG5cclxuICAgICAgbGV0IGNvbG9yOiBDb2xvciA9IENvbG9yLkNTUyhcIndoaXRlXCIsIDAuNSk7XHJcbiAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpLnNldCh0aGlzLm5vZGUucmFkaXVzICogMiwgdGhpcy5ub2RlLnJhZGl1cyAqIDIsIHRoaXMubm9kZS5yYWRpdXMgKiAyKTtcclxuICAgICAgbGV0IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuQ09NUE9TSVRJT04odHJhbnNsYXRpb24sIHVuZGVmaW5lZCwgc2NhbGluZyk7XHJcbiAgICAgIEdpem1vcy5kcmF3U3BoZXJlKG10eFdvcmxkLCBjb2xvcik7XHJcblxyXG4gICAgICBSZWN5Y2xlci5zdG9yZU11bHRpcGxlKG10eFdvcmxkLCBzY2FsaW5nLCBjb2xvcik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQmFzZSBjbGFzcyBmb3Igc2NyaXB0cyB0aGUgdXNlciB3cml0ZXNcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ocy1mdXJ0d2FuZ2VuL0ZVREdFL3dpa2kvQ29tcG9uZW50XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudFNjcmlwdCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICAvLyByZWdpc3RlcmluZyB0aGlzIGRvZXNuJ3QgbWFrZSBzZW5zZSwgb25seSBpdHMgc3ViY2xhc3Nlcy4gT3IgdGhpcyBjb21wb25lbnQgbXVzdCByZWZlciB0byBzY3JpcHRzIHRvIGJlIGF0dGFjaGVkIHRvIHRoaXMgY29tcG9uZW50XHJcbiAgICAvLyBUT0RPOiByZXRoaW5rICYgcmVmYWN0b3JcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRTY3JpcHQpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zaW5nbGV0b24gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRNdXRhdG9yKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgYSB7QGxpbmsgVGV4dHVyZVRleHR9IHRvIHRoZSBub2RlLiBcclxuICAgKiBXb3JrcyBpbiBjb25qdW5jdGlvbiB3aXRoIHtAbGluayBDb21wb25lbnRNZXNofSBhbmQge0BsaW5rIENvbXBvbmVudE1hdGVyaWFsfSB0byBjcmVhdGUgYSB0ZXh0IG5vZGUuXHJcbiAgICogQSAndGV4dHVyZWQnIHtAbGluayBNYXRlcmlhbH0gKGUuZy4ge0BsaW5rIFNoYWRlckxpdFRleHR1cmVkfSkgbXVzdCBiZSB1c2VkIHRvIGRpc3BsYXkgdGhlIHRleHQgcHJvcGVybHkuIElkZWFsbHkgYSB7QGxpbmsgTWVzaFF1YWR9IHNob3VsZCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgdGV4dCBvbnRvLlxyXG4gICAqIEFkZGl0aW9uYWxseSBhIHtAbGluayBDb21wb25lbnRGYWNlQ2FtZXJhfSBjYW4gYmUgYXR0YWNoZWQgdG8gbWFrZSB0aGUgdGV4dCBmYWNlIHRoZSBjYW1lcmEuXHJcbiAgICogQGF1dGhvcnMgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDI0XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudFRleHQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudFRleHQpO1xyXG5cclxuICAgIHB1YmxpYyByZWFkb25seSB0ZXh0dXJlOiBUZXh0dXJlVGV4dDtcclxuICAgIHB1YmxpYyByZWFkb25seSBtdHhXb3JsZDogTWF0cml4NHg0O1xyXG5cclxuICAgIC8qKiAtIG9uOiBUaGUgdGV4dHMgc2l6ZSBpcyBmaXhlZCB0byBtYXRjaCB0aGUgc2V0IGZvbnQgc2l6ZVxyXG4gICAgICogIC0gb2ZmOiBUaGUgZm9udCBzaXplIGlzIHN0cmV0Y2hlZCB0byBtYXRjaCB0aGUgYXR0YWNoZWQgbWVzaGVzIHNpemVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGZpeGVkU2l6ZTogYm9vbGVhbjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3RleHQ/OiBzdHJpbmcsIF9mb250Pzogc3RyaW5nKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMudGV4dHVyZSA9IG5ldyBUZXh0dXJlVGV4dChDb21wb25lbnRUZXh0Lm5hbWUsIF90ZXh0LCBfZm9udCk7XHJcbiAgICAgIHRoaXMubXR4V29ybGQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgICAgdGhpcy5maXhlZFNpemUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXNlUmVuZGVyRGF0YShfbXR4TWVzaFRvV29ybGQ6IE1hdHJpeDR4NCwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogTWF0cml4NHg0IHtcclxuICAgICAgdGhpcy50ZXh0dXJlLnVzZVJlbmRlckRhdGEoVEVYVFVSRV9MT0NBVElPTi5DT0xPUi5VTklUKTtcclxuICAgICAgdGhpcy5tdHhXb3JsZC5jb3B5KF9tdHhNZXNoVG9Xb3JsZCk7XHJcblxyXG4gICAgICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmZpeGVkU2l6ZSkge1xyXG4gICAgICAgIGxldCBzY2FsZTogbnVtYmVyID0gX2NtcENhbWVyYS5nZXRXb3JsZFRvUGl4ZWxTY2FsZShfbXR4TWVzaFRvV29ybGQudHJhbnNsYXRpb24pO1xyXG4gICAgICAgIHRoaXMubXR4V29ybGQuc2NhbGluZyA9IHNjYWxpbmcuc2V0KHRoaXMudGV4dHVyZS53aWR0aCAqIHNjYWxlLCB0aGlzLnRleHR1cmUuaGVpZ2h0ICogc2NhbGUsIDEpOztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgcGl4ZWxzVG9Vbml0czogbnVtYmVyID0gMSAvIHRoaXMudGV4dHVyZS5oZWlnaHQ7XHJcbiAgICAgICAgc2NhbGluZy5zZXQodGhpcy50ZXh0dXJlLndpZHRoICogcGl4ZWxzVG9Vbml0cywgdGhpcy50ZXh0dXJlLmhlaWdodCAqIHBpeGVsc1RvVW5pdHMsIDEpO1xyXG4gICAgICAgIHRoaXMubXR4V29ybGQuc2NhbGUoc2NhbGluZyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHNjYWxpbmcpO1xyXG4gICAgICByZXR1cm4gdGhpcy5tdHhXb3JsZDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZHJhd0dpem1vc1NlbGVjdGVkKCk6IHZvaWQge1xyXG4gICAgICBsZXQgbWVzaDogTWVzaCA9IHRoaXMubm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCk/Lm1lc2g7XHJcbiAgICAgIGxldCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwgPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1hdGVyaWFsKTtcclxuICAgICAgaWYgKG1lc2ggPT0gbnVsbCB8fCBjbXBNYXRlcmlhbCA9PSBudWxsKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIEdpem1vcy5kcmF3V2lyZU1lc2gobWVzaCwgdGhpcy5tdHhXb3JsZCwgY21wTWF0ZXJpYWwuY2xyUHJpbWFyeSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci50ZXh0dXJlLm5hbWU7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIGV4cG9ydCBlbnVtIEJBU0Uge1xyXG4gICAgU0VMRiwgUEFSRU5ULCBXT1JMRCwgTk9ERVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgYSB0cmFuc2Zvcm0te0BsaW5rIE1hdHJpeDR4NH0gdG8gdGhlIG5vZGUsIG1vdmluZywgc2NhbGluZyBhbmQgcm90YXRpbmcgaXQgaW4gc3BhY2UgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRUcmFuc2Zvcm0gZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudFRyYW5zZm9ybSk7XHJcbiAgICBwdWJsaWMgbXR4TG9jYWw6IE1hdHJpeDR4NDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX210eEluaXQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubXR4TG9jYWwgPSBfbXR4SW5pdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmb3JtYXRpb25zIHJlc3BlY3RpbmcgdGhlIGhpZXJhcmNoeVxyXG4gICAgLyoqXHJcbiAgICAgKiByZWNhbGN1bGF0ZXMgdGhpcyBsb2NhbCBtYXRyaXggdG8geWllbGQgdGhlIGlkZW50aWNhbCB3b3JsZCBtYXRyaXggYmFzZWQgb24gdGhlIGdpdmVuIG5vZGUuXHJcbiAgICAgKiBVc2UgcmViYXNlIGJlZm9yZSBhcHBlbmRpbmcgdGhlIGNvbnRhaW5lciBvZiB0aGlzIGNvbXBvbmVudCB0byBhbm90aGVyIG5vZGUgd2hpbGUgcHJlc2VydmluZyBpdHMgdHJhbnNmb3JtYXRpb24gaW4gdGhlIHdvcmxkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmViYXNlKF9ub2RlOiBOb2RlID0gbnVsbCk6IHZvaWQge1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSB0aGlzLm10eExvY2FsO1xyXG4gICAgICBsZXQgY29udGFpbmVyOiBOb2RlID0gdGhpcy5ub2RlO1xyXG4gICAgICBpZiAoY29udGFpbmVyKVxyXG4gICAgICAgIG10eFJlc3VsdCA9IGNvbnRhaW5lci5tdHhXb3JsZDtcclxuXHJcbiAgICAgIGlmIChfbm9kZSlcclxuICAgICAgICBtdHhSZXN1bHQgPSBNYXRyaXg0eDQuUkVMQVRJVkUobXR4UmVzdWx0LCBudWxsLCBfbm9kZS5tdHhXb3JsZEludmVyc2UpO1xyXG5cclxuICAgICAgdGhpcy5tdHhMb2NhbCA9IG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIHRyYW5zZm9ybWF0aW9uIHJlbGF0aXZlIHRvIHRoZSBzZWxlY3RlZCBiYXNlIChTRUxGLCBQQVJFTlQsIFdPUkxEKSBvciBhIHBhcnRpY3VsYXIgb3RoZXIgbm9kZSAoTk9ERSlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zZm9ybShfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQsIF9iYXNlOiBCQVNFID0gQkFTRS5TRUxGLCBfbm9kZTogTm9kZSA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgc3dpdGNoIChfYmFzZSkge1xyXG4gICAgICAgIGNhc2UgQkFTRS5TRUxGOlxyXG4gICAgICAgICAgdGhpcy5tdHhMb2NhbC5tdWx0aXBseShfbXR4VHJhbnNmb3JtKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQkFTRS5QQVJFTlQ6XHJcbiAgICAgICAgICB0aGlzLm10eExvY2FsLm11bHRpcGx5KF9tdHhUcmFuc2Zvcm0sIHRydWUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCQVNFLk5PREU6XHJcbiAgICAgICAgICBpZiAoIV9ub2RlKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCQVNFLk5PREUgcmVxdWlyZXMgYSBub2RlIGdpdmVuIGFzIGJhc2VcIik7XHJcbiAgICAgICAgY2FzZSBCQVNFLldPUkxEOlxyXG4gICAgICAgICAgdGhpcy5yZWJhc2UoX25vZGUpO1xyXG4gICAgICAgICAgdGhpcy5tdHhMb2NhbC5tdWx0aXBseShfbXR4VHJhbnNmb3JtLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICBsZXQgbm9kZTogTm9kZSA9IHRoaXMubm9kZTtcclxuICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgIGxldCBtdHhUZW1wOiBNYXRyaXg0eDQ7XHJcbiAgICAgICAgICAgIGlmIChfYmFzZSA9PSBCQVNFLk5PREUpIHtcclxuICAgICAgICAgICAgICAvLyBmaXggbXR4V29ybGQgb2YgY29udGFpbmVyIGZvciBzdWJzZXF1ZW50IHJlYmFzaW5nIFxyXG4gICAgICAgICAgICAgIG10eFRlbXAgPSBNYXRyaXg0eDQuUFJPRFVDVChfbm9kZS5tdHhXb3JsZCwgbm9kZS5tdHhMb2NhbCk7XHJcbiAgICAgICAgICAgICAgbm9kZS5tdHhXb3JsZC5jb3B5KG10eFRlbXApO1xyXG4gICAgICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFRlbXApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgcGFyZW50OiBOb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgIC8vIGZpeCBtdHhMb2NhbCBmb3IgY3VycmVudCBwYXJlbnRcclxuICAgICAgICAgICAgICB0aGlzLnJlYmFzZShub2RlLmdldFBhcmVudCgpKTtcclxuICAgICAgICAgICAgICBtdHhUZW1wID0gTWF0cml4NHg0LlBST0RVQ1Qobm9kZS5nZXRQYXJlbnQoKS5tdHhXb3JsZCwgbm9kZS5tdHhMb2NhbCk7XHJcbiAgICAgICAgICAgICAgbm9kZS5tdHhXb3JsZC5jb3B5KG10eFRlbXApO1xyXG4gICAgICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFRlbXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBsb2NhbDogdGhpcy5tdHhMb2NhbC5zZXJpYWxpemUoKSxcclxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICBhd2FpdCB0aGlzLm10eExvY2FsLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmxvY2FsKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHVibGljIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgLy8gICAgIHRoaXMubG9jYWwubXV0YXRlKF9tdXRhdG9yKTtcclxuICAgIC8vIH1cclxuICAgIC8vIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3IgeyBcclxuICAgIC8vICAgICByZXR1cm4gdGhpcy5sb2NhbC5nZXRNdXRhdG9yKCk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLy8gcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAvLyAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSB0aGlzLmxvY2FsLmdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcik7XHJcbiAgICAvLyAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci53b3JsZDtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc2NyaWJlcyBhIFZSIENvbnRyb2xsZXIgYW5kIGl0cyBjYXBhYmlsaXRpZXMuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFZSQ29udHJvbGxlciB7XHJcbiAgICBwdWJsaWMgY21wVHJhbnNmb3JtOiBDb21wb25lbnRUcmFuc2Zvcm0gPSBudWxsO1xyXG4gICAgcHVibGljIGdhbWVQYWQ6IEdhbWVwYWQgPSBudWxsO1xyXG4gICAgcHVibGljIHRodW1ic3RpY2tYOiBudW1iZXIgPSBudWxsO1xyXG4gICAgcHVibGljIHRodW1ic3RpY2tZOiBudW1iZXIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVlIgQ29tcG9uZW50IENsYXNzLCBmb3IgU2Vzc2lvbiBNYW5hZ2VtZW50LCBDb250cm9sbGVyIE1hbmFnZW1lbnQgYW5kIFJlZmVyZW5jZSBTcGFjZSBNYW5hZ2VtZW50LiBcclxuICAgKiBAYXV0aG9yIFZhbGVudGluIFNjaG1pZGJlcmdlciwgSEZVLCAyMDIyXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudFZSRGV2aWNlIGV4dGVuZHMgQ29tcG9uZW50Q2FtZXJhIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRWUkRldmljZSk7XHJcbiAgICBwdWJsaWMgcmlnaHRDbnRybDogVlJDb250cm9sbGVyID0gbmV3IFZSQ29udHJvbGxlcigpO1xyXG4gICAgcHVibGljIGxlZnRDbnRybDogVlJDb250cm9sbGVyID0gbmV3IFZSQ29udHJvbGxlcigpO1xyXG5cclxuICAgICNtdHhMb2NhbDogTWF0cml4NHg0O1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIHRoaXMuZ2V0TXR4TG9jYWxGcm9tQ21wVHJhbnNmb3JtKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGFjdHVhbCBtYXRyaXggb2YgdGhlIHZyIC0gZGV2aWNlLlxyXG4gICAgICogQ3JlYXRvcnMgc2hvdWxkIHVzZSB0aGlzIGZvciByZWFkb25seSBwdXJwb3Nlcy4gIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG10eExvY2FsKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtdHhMb2NhbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSBWZWN0b3IzIGFzIFBvc2l0aW9uIG9mIHRoZSByZWZlcmVuY2Ugc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgdHJhbnNsYXRpb24oX3RyYW5zbGF0aW9uOiBWZWN0b3IzKSB7XHJcbiAgICAgIGxldCB0cmFuc2xhdGlvbjogVmVjdG9yMyA9IF90cmFuc2xhdGlvbi5jbG9uZTtcclxuICAgICAgdHJhbnNsYXRpb24uc3VidHJhY3QodGhpcy4jbXR4TG9jYWwudHJhbnNsYXRpb24pO1xyXG4gICAgICB0cmFuc2xhdGlvbi5uZWdhdGUoKTtcclxuICAgICAgWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlID0gWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlLmdldE9mZnNldFJlZmVyZW5jZVNwYWNlKG5ldyBYUlJpZ2lkVHJhbnNmb3JtKHRyYW5zbGF0aW9uKSk7XHJcbiAgICAgIHRoaXMuI210eExvY2FsLnRyYW5zbGF0aW9uID0gX3RyYW5zbGF0aW9uO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh0cmFuc2xhdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIFZlY3RvcjMgUm90YXRpb24gb2YgdGhlIHJlZmVyZW5jZSBzcGFjZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCByb3RhdGlvbihfcm90YXRpb246IFZlY3RvcjMpIHtcclxuICAgICAgbGV0IHJvdGF0aW9uOiBWZWN0b3IzID0gX3JvdGF0aW9uLmNsb25lOyBcclxuICAgICAgcm90YXRpb24uc3VidHJhY3QodGhpcy4jbXR4TG9jYWwucm90YXRpb24pO1xyXG4gICAgICByb3RhdGlvbi5uZWdhdGUoKTtcclxuICAgICAgbGV0IG9yaWVudGF0aW9uOiBRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcclxuICAgICAgb3JpZW50YXRpb24uZXVsZXJBbmdsZXMgPSByb3RhdGlvbjtcclxuICAgICAgLy8gUm90YXRpb24gbmVlZHMgdG8gYmUgc2V0IGluIHRoZSBPcmlnaW4gKDAsMCwwKSwgb3RoZXJ3aXNlIHRoZSBYUi1SaWcgZ2V0cyByb3RhdGVkIGFyb3VuZCB0aGUgb3JpZ2luLiBcclxuICAgICAgLy8gc2V0IHhyIC0gcmlnIGJhY2sgdG8gb3JpZ2luXHJcbiAgICAgIFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZSA9IFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZS5nZXRPZmZzZXRSZWZlcmVuY2VTcGFjZShuZXcgWFJSaWdpZFRyYW5zZm9ybShWZWN0b3IzLkRJRkZFUkVOQ0UodGhpcy4jbXR4TG9jYWwudHJhbnNsYXRpb24sIFZlY3RvcjMuWkVSTygpKSkpO1xyXG4gICAgICAvLyByb3RhdGUgeHIgcmlnIGluIG9yaWdpblxyXG4gICAgICBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UgPSBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UuZ2V0T2Zmc2V0UmVmZXJlbmNlU3BhY2UobmV3IFhSUmlnaWRUcmFuc2Zvcm0oVmVjdG9yMy5aRVJPKCksIG9yaWVudGF0aW9uKSk7XHJcbiAgICAgIC8vIHNldCB4ciAtIHJpZyBiYWNrIHRvIGxhc3QgcG9zaXRpb24gXHJcbiAgICAgIFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZSA9IFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZS5nZXRPZmZzZXRSZWZlcmVuY2VTcGFjZShuZXcgWFJSaWdpZFRyYW5zZm9ybShWZWN0b3IzLkRJRkZFUkVOQ0UoVmVjdG9yMy5aRVJPKCksIHRoaXMuI210eExvY2FsLnRyYW5zbGF0aW9uKSkpO1xyXG4gICAgICB0aGlzLiNtdHhMb2NhbC5yb3RhdGlvbiA9IF9yb3RhdGlvbjtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUocm90YXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIFZlY3RvcjMgaW4gUG9zaXRpb24gb2YgdGhlIHJlZmVyZW5jZSBzcGFjZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZShfYnk6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgbGV0IHRyYW5zbGF0aW9uOiBWZWN0b3IzID0gX2J5LmNsb25lO1xyXG4gICAgICB0cmFuc2xhdGlvbi50cmFuc2Zvcm0odGhpcy4jbXR4TG9jYWwucXVhdGVybmlvbik7XHJcbiAgICAgIHRyYW5zbGF0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgICBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UgPSBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UuZ2V0T2Zmc2V0UmVmZXJlbmNlU3BhY2UobmV3IFhSUmlnaWRUcmFuc2Zvcm0odHJhbnNsYXRpb24pKTtcclxuICAgICAgdGhpcy4jbXR4TG9jYWwudHJhbnNsYXRlKF9ieSk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHRyYW5zbGF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBWZWN0b3IzIGluIFJvdGF0aW9uIG9mIHRoZSByZWZlcmVuY2Ugc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGUoX2J5OiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGxldCByb3RhdGlvbjogVmVjdG9yMyA9IF9ieS5jbG9uZS5uZWdhdGUoKTsgXHJcbiAgICAgIGxldCBvcmllbnRhdGlvbjogUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcbiAgICAgIG9yaWVudGF0aW9uLmV1bGVyQW5nbGVzID0gcm90YXRpb247XHJcbiAgICAgIC8vIFJvdGF0aW9uIG5lZWRzIHRvIGJlIGFkZGVkIGluIHRoZSBPcmlnaW4gKDAsMCwwKSwgb3RoZXJ3aXNlIHRoZSBYUi1SaWcgZ2V0cyByb3RhdGVkIGFyb3VuZCB0aGUgb3JpZ2luLiBcclxuICAgICAgLy8gc2V0IHhyIC0gcmlnIGJhY2sgdG8gb3JpZ2luXHJcbiAgICAgIFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZSA9IFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZS5nZXRPZmZzZXRSZWZlcmVuY2VTcGFjZShuZXcgWFJSaWdpZFRyYW5zZm9ybShWZWN0b3IzLkRJRkZFUkVOQ0UodGhpcy4jbXR4TG9jYWwudHJhbnNsYXRpb24sIFZlY3RvcjMuWkVSTygpKSkpO1xyXG4gICAgICAvLyByb3RhdGUgeHIgcmlnIGluIG9yaWdpblxyXG4gICAgICBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UgPSBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UuZ2V0T2Zmc2V0UmVmZXJlbmNlU3BhY2UobmV3IFhSUmlnaWRUcmFuc2Zvcm0oVmVjdG9yMy5aRVJPKCksIG9yaWVudGF0aW9uKSk7XHJcbiAgICAgIC8vIHNldCB4ciAtIHJpZyBiYWNrIHRvIGxhc3QgcG9zaXRpb24gXHJcbiAgICAgIFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZSA9IFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZS5nZXRPZmZzZXRSZWZlcmVuY2VTcGFjZShuZXcgWFJSaWdpZFRyYW5zZm9ybShWZWN0b3IzLkRJRkZFUkVOQ0UoVmVjdG9yMy5aRVJPKCksIHRoaXMuI210eExvY2FsLnRyYW5zbGF0aW9uKSkpO1xyXG4gICAgICB0aGlzLiNtdHhMb2NhbC5yb3RhdGUoX2J5KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUocm90YXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0TXR4TG9jYWxGcm9tQ21wVHJhbnNmb3JtKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNtdHhMb2NhbCA9IHRoaXMubm9kZS5tdHhMb2NhbDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICBleHBvcnQgY29uc3QgZW51bSBFVkVOVF9DT05UUk9MIHtcclxuICAgIElOUFVUID0gXCJpbnB1dFwiLFxyXG4gICAgT1VUUFVUID0gXCJvdXRwdXRcIlxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNvbnN0IGVudW0gQ09OVFJPTF9UWVBFIHtcclxuICAgIC8qKiBUaGUgb3V0cHV0IHNpbXBseSBmb2xsb3dzIHRoZSBzY2FsZWQgYW5kIGRlbGF5ZWQgaW5wdXQgKi9cclxuICAgIFBST1BPUlRJT05BTCxcclxuICAgIC8qKiBUaGUgb3V0cHV0IHZhbHVlIGNoYW5nZXMgb3ZlciB0aW1lIHdpdGggYSByYXRlIGdpdmVuIGJ5IHRoZSBzY2FsZWQgYW5kIGRlbGF5ZWQgaW5wdXQgKi9cclxuICAgIElOVEVHUkFMLFxyXG4gICAgLyoqIFRoZSBvdXRwdXQgdmFsdWUgcmVhY3RzIHRvIGNoYW5nZXMgb2YgdGhlIHNjYWxlZCBpbnB1dCBhbmQgZHJvcHMgdG8gMCB3aXRoIGdpdmVuIGRlbGF5LCBpZiBpbnB1dCByZW1haW5zIGNvbnN0YW50ICovXHJcbiAgICBESUZGRVJFTlRJQUxcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByb2Nlc3NlcyBpbnB1dCBzaWduYWxzIG9mIHR5cGUgbnVtYmVyIGFuZCBnZW5lcmF0ZXMgYW4gb3V0cHV0IHNpZ25hbCBvZiB0aGUgc2FtZSB0eXBlIHVzaW5nIFxyXG4gICAqIHByb3BvcnRpb25hbCwgaW50ZWdyYWwgb3IgZGlmZmVyZW50aWFsIG1hcHBpbmcsIGFuIGFtcGxpZmljYXRpb24gZmFjdG9yIGFuZCBhIGxpbmVhciBkYW1wZW5pbmcvZGVsYXlcclxuICAgKiBgYGB0ZXh0XHJcbiAgICogICAgICAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcclxuICAgKiAgICAgICAgIOKUgiAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgIHBhc3MgdGhyb3VnaCAoUHJvcG9ydGlvbmFsKSAgICAgIOKUglxyXG4gICAqIElucHV0IOKGkiDilIIg4oaSIOKUgmFtcGxpZnnilIIg4oaSIOKUgmRlbGF54pSCIOKGkiDimp8gc3VtIHVwIG92ZXIgdGltZSAoSW50ZWdyYWwpIOKaniDihpIg4pSCIOKGkiBPdXRwdXRcclxuICAgKiAgICAgICAgIOKUgiAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgIHBhc3MgY2hhbmdlICAoRGlmZmVyZW50aWFsKSAgICAgIOKUglxyXG4gICAqICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb250cm9sIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gICAgcHVibGljIHJlYWRvbmx5IHR5cGU6IENPTlRST0xfVFlQRTtcclxuICAgIHB1YmxpYyBhY3RpdmU6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG5cclxuICAgIHByb3RlY3RlZCByYXRlRGlzcGF0Y2hPdXRwdXQ6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgdmFsdWVQcmV2aW91czogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBvdXRwdXRCYXNlOiBudW1iZXIgPSAwO1xyXG4gICAgcHJvdGVjdGVkIG91dHB1dFRhcmdldDogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBvdXRwdXRQcmV2aW91czogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBvdXRwdXRUYXJnZXRQcmV2aW91czogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBmYWN0b3I6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHJvdGVjdGVkIHRpbWU6IFRpbWUgPSBUaW1lLmdhbWU7XHJcbiAgICBwcm90ZWN0ZWQgdGltZVZhbHVlRGVsYXk6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgdGltZU91dHB1dFRhcmdldFNldDogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBpZFRpbWVyOiBudW1iZXIgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcsIF9mYWN0b3I6IG51bWJlciA9IDEsIF90eXBlOiBDT05UUk9MX1RZUEUgPSBDT05UUk9MX1RZUEUuUFJPUE9SVElPTkFMLCBfZGVsYXk6IG51bWJlciA9IDApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5mYWN0b3IgPSBfZmFjdG9yO1xyXG4gICAgICB0aGlzLnR5cGUgPSBfdHlwZTtcclxuICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgICAgdGhpcy5zZXREZWxheShfZGVsYXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB0aW1lLW9iamVjdCB0byBiZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG91dHB1dCBpbiB7QGxpbmsgQ09OVFJPTF9UWVBFLklOVEVHUkFMfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0VGltZWJhc2UoX3RpbWU6IFRpbWUpOiB2b2lkIHtcclxuICAgICAgdGhpcy50aW1lID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlT3V0cHV0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGZWVkIGFuIGlucHV0IHZhbHVlIGludG8gdGhpcyBjb250cm9sIGFuZCBmaXJlIHRoZSBldmVudHMge0BsaW5rIEVWRU5UX0NPTlRST0wuSU5QVVR9IGFuZCB7QGxpbmsgRVZFTlRfQ09OVFJPTC5PVVRQVVR9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRJbnB1dChfaW5wdXQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMuYWN0aXZlKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIHRoaXMub3V0cHV0QmFzZSA9IHRoaXMuY2FsY3VsYXRlT3V0cHV0KCk7XHJcbiAgICAgIHRoaXMudmFsdWVQcmV2aW91cyA9IHRoaXMuZ2V0VmFsdWVEZWxheWVkKCk7XHJcbiAgICAgIHRoaXMub3V0cHV0VGFyZ2V0ID0gdGhpcy5mYWN0b3IgKiBfaW5wdXQ7XHJcbiAgICAgIHRoaXMudGltZU91dHB1dFRhcmdldFNldCA9IHRoaXMudGltZS5nZXQoKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnR5cGUgPT0gQ09OVFJPTF9UWVBFLkRJRkZFUkVOVElBTCkge1xyXG4gICAgICAgIHRoaXMudmFsdWVQcmV2aW91cyA9IHRoaXMub3V0cHV0VGFyZ2V0IC0gdGhpcy5vdXRwdXRUYXJnZXRQcmV2aW91cztcclxuICAgICAgICB0aGlzLm91dHB1dFRhcmdldFByZXZpb3VzID0gdGhpcy5vdXRwdXRUYXJnZXQ7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRUYXJnZXQgPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5UX0NPTlRST0wuSU5QVVQpKTtcclxuICAgICAgaWYgKHRoaXMudHlwZSA9PSBDT05UUk9MX1RZUEUuRElGRkVSRU5USUFMKVxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPdXRwdXQodGhpcy52YWx1ZVByZXZpb3VzKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hPdXRwdXQobnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPOiBkZXNjcmliZSFcclxuICAgICAqL1xyXG4gICAgcHVibGljIHB1bHNlKF9pbnB1dDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0SW5wdXQoX2lucHV0KTtcclxuICAgICAgdGhpcy5zZXRJbnB1dCgwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgdGltZSB0byB0YWtlIGZvciB0aGUgaW50ZXJuYWwgbGluZWFyIGRhbXBlbmluZyB1bnRpbCB0aGUgZmluYWwgb3VwdXQgdmFsdWUgaXMgcmVhY2hlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0RGVsYXkoX3RpbWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLnRpbWVWYWx1ZURlbGF5ID0gTWF0aC5tYXgoMCwgX3RpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBudW1iZXIgb2Ygb3V0cHV0LWV2ZW50cyB0byBkaXNwYXRjaCBwZXIgc2Vjb25kLiBcclxuICAgICAqIEF0IHRoZSBkZWZhdWx0IG9mIDAsIHRoZSBjb250cm9sIG91dHB1dCBtdXN0IGJlIHBvbGxlZCBhbmQgd2lsbCBvbmx5IGFjdGl2ZWx5IGRpc3BhdGNoZWQgb25jZSBlYWNoIHRpbWUgaW5wdXQgb2NjdXJzIGFuZCB0aGUgb3V0cHV0IGNoYW5nZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRSYXRlRGlzcGF0Y2hPdXRwdXQoX3JhdGVEaXNwYXRjaE91dHB1dDogbnVtYmVyID0gMCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnJhdGVEaXNwYXRjaE91dHB1dCA9IF9yYXRlRGlzcGF0Y2hPdXRwdXQ7XHJcbiAgICAgIHRoaXMudGltZS5kZWxldGVUaW1lcih0aGlzLmlkVGltZXIpO1xyXG4gICAgICB0aGlzLmlkVGltZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgIGlmICh0aGlzLnJhdGVEaXNwYXRjaE91dHB1dClcclxuICAgICAgICB0aGlzLmlkVGltZXIgPSB0aGlzLnRpbWUuc2V0VGltZXIoMTAwMCAvIHRoaXMucmF0ZURpc3BhdGNoT3V0cHV0LCAwLCB0aGlzLmRpc3BhdGNoT3V0cHV0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZmFjdG9yIHRvIG11bHRpcGx5IHRoZSBpbnB1dCB2YWx1ZSBnaXZlbiB3aXRoIHtAbGluayBzZXRJbnB1dH0gd2l0aFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0RmFjdG9yKF9mYWN0b3I6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmZhY3RvciA9IF9mYWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHZhbHVlIGZyb20gdGhlIG91dHB1dCBvZiB0aGlzIGNvbnRyb2xcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE91dHB1dCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVPdXRwdXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG91dHB1dCBvZiB0aGlzIGNvbnRyb2xcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNhbGN1bGF0ZU91dHB1dCgpOiBudW1iZXIge1xyXG4gICAgICBsZXQgb3V0cHV0OiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgdmFsdWU6IG51bWJlciA9IHRoaXMuZ2V0VmFsdWVEZWxheWVkKCk7XHJcblxyXG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgIGNhc2UgQ09OVFJPTF9UWVBFLklOVEVHUkFMOlxyXG4gICAgICAgICAgbGV0IHRpbWVDdXJyZW50OiBudW1iZXIgPSB0aGlzLnRpbWUuZ2V0KCk7XHJcbiAgICAgICAgICBsZXQgdGltZUVsYXBzZWRTaW5jZUlucHV0OiBudW1iZXIgPSB0aW1lQ3VycmVudCAtIHRoaXMudGltZU91dHB1dFRhcmdldFNldDtcclxuICAgICAgICAgIG91dHB1dCA9IHRoaXMub3V0cHV0QmFzZTtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy50aW1lVmFsdWVEZWxheSA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHRpbWVFbGFwc2VkU2luY2VJbnB1dCA8IHRoaXMudGltZVZhbHVlRGVsYXkpIHtcclxuICAgICAgICAgICAgICBvdXRwdXQgKz0gMC41ICogKHRoaXMudmFsdWVQcmV2aW91cyArIHZhbHVlKSAqIHRpbWVFbGFwc2VkU2luY2VJbnB1dDtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBvdXRwdXQgKz0gMC41ICogKHRoaXMudmFsdWVQcmV2aW91cyArIHZhbHVlKSAqIHRoaXMudGltZVZhbHVlRGVsYXk7XHJcbiAgICAgICAgICAgICAgdGltZUVsYXBzZWRTaW5jZUlucHV0IC09IHRoaXMudGltZVZhbHVlRGVsYXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG91dHB1dCArPSB2YWx1ZSAqIHRpbWVFbGFwc2VkU2luY2VJbnB1dDtcclxuICAgICAgICAgIC8vIHZhbHVlICs9IDAuNSAqICh0aGlzLmlucHV0UHJldmlvdXMgLSBpbnB1dCkgKiB0aGlzLnRpbWVJbnB1dERlbGF5ICsgaW5wdXQgKiB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIENPTlRST0xfVFlQRS5ESUZGRVJFTlRJQUw6XHJcbiAgICAgICAgY2FzZSBDT05UUk9MX1RZUEUuUFJPUE9SVElPTkFMOlxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBvdXRwdXQgPSB2YWx1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGNhbGN1bGF0ZXMgdGhlIG91dHB1dCBjb25zaWRlcmluZyB0aGUgdGltZSBvZiB0aGUgZGVsYXlcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRWYWx1ZURlbGF5ZWQoKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMudGltZVZhbHVlRGVsYXkgPiAwKSB7XHJcbiAgICAgICAgbGV0IHRpbWVFbGFwc2VkU2luY2VJbnB1dDogbnVtYmVyID0gdGhpcy50aW1lLmdldCgpIC0gdGhpcy50aW1lT3V0cHV0VGFyZ2V0U2V0O1xyXG4gICAgICAgIGlmICh0aW1lRWxhcHNlZFNpbmNlSW5wdXQgPCB0aGlzLnRpbWVWYWx1ZURlbGF5KVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVQcmV2aW91cyArICh0aGlzLm91dHB1dFRhcmdldCAtIHRoaXMudmFsdWVQcmV2aW91cykgKiB0aW1lRWxhcHNlZFNpbmNlSW5wdXQgLyB0aGlzLnRpbWVWYWx1ZURlbGF5O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLm91dHB1dFRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGRpc3BhdGNoT3V0cHV0ID0gKF9ldmVudE9yVmFsdWU6IEV2ZW50VGltZXIgfCBudW1iZXIpOiB2b2lkID0+IHtcclxuICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBsZXQgdGltZXI6IFRpbWVyID0gdGhpcy50aW1lLmdldFRpbWVyKHRoaXMuaWRUaW1lcik7XHJcbiAgICAgIGxldCBvdXRwdXQ6IG51bWJlcjtcclxuICAgICAgaWYgKHR5cGVvZiAoX2V2ZW50T3JWYWx1ZSkgPT0gXCJudW1iZXJcIilcclxuICAgICAgICBvdXRwdXQgPSBfZXZlbnRPclZhbHVlO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgb3V0cHV0ID0gdGhpcy5jYWxjdWxhdGVPdXRwdXQoKTtcclxuICAgICAgbGV0IG91dHB1dENoYW5nZWQ6IGJvb2xlYW4gPSAob3V0cHV0ICE9IHRoaXMub3V0cHV0UHJldmlvdXMpO1xyXG5cclxuICAgICAgaWYgKHRpbWVyKSB7XHJcbiAgICAgICAgdGltZXIuYWN0aXZlID0gb3V0cHV0Q2hhbmdlZDtcclxuICAgICAgICBpZiAoIW91dHB1dENoYW5nZWQpXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMub3V0cHV0UHJldmlvdXMgPSBvdXRwdXQ7XHJcblxyXG4gICAgICBsZXQgZXZlbnQ6IEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEVWRU5UX0NPTlRST0wuT1VUUFVULCB7XHJcbiAgICAgICAgZGV0YWlsOiB7XHJcbiAgICAgICAgICBvdXRwdXQ6IG91dHB1dFxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfTtcclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCJDb250cm9sLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBIYW5kbGVzIG11bHRpcGxlIGNvbnRyb2xzIGFzIGlucHV0cyBhbmQgY3JlYXRlcyBhbiBvdXRwdXQgZnJvbSB0aGF0LlxyXG4gICAqIEFzIGEgc3ViY2xhc3Mgb2Yge0BsaW5rIENvbnRyb2x9LCBheGlzIGNhbGN1bGF0ZXMgdGhlIG91cHV0IHN1bW1pbmcgdXAgdGhlIGlucHV0cyBhbmQgcHJvY2Vzc2luZyB0aGUgcmVzdWx0IHVzaW5nIGl0cyBvd24gc2V0dGluZ3MuICBcclxuICAgKiBEaXNwYXRjaGVzIHtAbGluayBFVkVOVF9DT05UUk9MLk9VVFBVVH0gYW5kIHtAbGluayBFVkVOVF9DT05UUk9MLklOUFVUfSB3aGVuIG9uZSBvZiB0aGUgY29udHJvbHMgZGlzcGF0Y2hlcyB0aGVtLlxyXG4gICAqIGBgYHRleHRcclxuICAgKiAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXHJcbiAgICogICAgICAgICAgIOKUgiDilIzilIDilIDilIDilIDilIDilIDilIDilJAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcclxuICAgKiAgIElucHV0IOKGkiDilIIg4pSCY29udHJvbOKUglxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcclxuICAgKiAgICAgICAgICAg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcclxuICAgKiAgICAgICAgICAg4pSCIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgXFzilIzilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgICDilIJcclxuICAgKiAgIElucHV0IOKGkiDilIIg4pSCY29udHJvbOKUgi0tLeKUgnN1beKUgiDihpIg4pSCaW50ZXJuYWwgY29udHJvbCDilIIg4oaSIOKUgiDihpIgT3V0cHV0XHJcbiAgICogICAgICAgICAgIOKUgiDilJTilIDilIDilIDilIDilIDilIDilIDilJggIC/ilJTilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggICDilIJcclxuICAgKiAgICAgICAgICAg4pSCIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAvICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgSW5wdXQg4oaSIOKUgiDilIJjb250cm9s4pSCLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXHJcbiAgICogICAgICAgICAgIOKUgiDilJTilIDilIDilIDilIDilIDilIDilIDilJggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcclxuICAgKiAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICBcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQXhpcyBleHRlbmRzIENvbnRyb2wge1xyXG4gICAgcHJpdmF0ZSBjb250cm9sczogTWFwPHN0cmluZywgQ29udHJvbD4gPSBuZXcgTWFwKCk7XHJcbiAgICBwcml2YXRlIHN1bVByZXZpb3VzOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHRoZSBjb250cm9sIGdpdmVuIHRvIHRoZSBsaXN0IG9mIGNvbnRyb2xzIGZlZWRpbmcgaW50byB0aGlzIGF4aXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZENvbnRyb2woX2NvbnRyb2w6IENvbnRyb2wpOiB2b2lkIHtcclxuICAgICAgdGhpcy5jb250cm9scy5zZXQoX2NvbnRyb2wubmFtZSwgX2NvbnRyb2wpO1xyXG4gICAgICBfY29udHJvbC5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0NPTlRST0wuSU5QVVQsIHRoaXMuaG5kSW5wdXRFdmVudCk7XHJcbiAgICAgIF9jb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfQ09OVFJPTC5PVVRQVVQsIHRoaXMuaG5kT3V0cHV0RXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBuYW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb250cm9sKF9uYW1lOiBzdHJpbmcpOiBDb250cm9sIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHMuZ2V0KF9uYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlQ29udHJvbChfbmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIGxldCBjb250cm9sOiBDb250cm9sID0gdGhpcy5nZXRDb250cm9sKF9uYW1lKTtcclxuICAgICAgaWYgKGNvbnRyb2wpIHtcclxuICAgICAgICBjb250cm9sLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRfQ09OVFJPTC5JTlBVVCwgdGhpcy5obmRJbnB1dEV2ZW50KTtcclxuICAgICAgICBjb250cm9sLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRfQ09OVFJPTC5PVVRQVVQsIHRoaXMuaG5kT3V0cHV0RXZlbnQpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbHMuZGVsZXRlKF9uYW1lKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhpcyBheGlzIGFmdGVyIHN1bW1pbmcgdXAgYWxsIGlucHV0cyBhbmQgcHJvY2Vzc2luZyB0aGUgc3VtIGFjY29yZGluZyB0byB0aGUgYXhpcycgc2V0dGluZ3NcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE91dHB1dCgpOiBudW1iZXIge1xyXG4gICAgICBsZXQgc3VtSW5wdXQ6IG51bWJlciA9IDA7XHJcbiAgICAgIGZvciAobGV0IGNvbnRyb2wgb2YgdGhpcy5jb250cm9scykge1xyXG5cclxuICAgICAgICBpZiAoY29udHJvbFsxXS5hY3RpdmUpXHJcbiAgICAgICAgICBzdW1JbnB1dCArPSBjb250cm9sWzFdLmdldE91dHB1dCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3VtSW5wdXQgIT0gdGhpcy5zdW1QcmV2aW91cylcclxuICAgICAgICBzdXBlci5zZXRJbnB1dChzdW1JbnB1dCk7XHJcblxyXG4gICAgICB0aGlzLnN1bVByZXZpb3VzID0gc3VtSW5wdXQ7XHJcblxyXG4gICAgICByZXR1cm4gc3VwZXIuZ2V0T3V0cHV0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBobmRPdXRwdXRFdmVudDogRXZlbnRMaXN0ZW5lciA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5hY3RpdmUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGNvbnRyb2w6IENvbnRyb2wgPSAoPENvbnRyb2w+X2V2ZW50LnRhcmdldCk7XHJcbiAgICAgIGxldCBldmVudDogQ3VzdG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoRVZFTlRfQ09OVFJPTC5PVVRQVVQsIHtcclxuICAgICAgICBkZXRhaWw6IHtcclxuICAgICAgICAgIGNvbnRyb2w6IGNvbnRyb2wsXHJcbiAgICAgICAgICBpbnB1dDogKDxDdXN0b21FdmVudD5fZXZlbnQpLmRldGFpbC5vdXRwdXQsXHJcbiAgICAgICAgICBvdXRwdXQ6IHRoaXMuZ2V0T3V0cHV0KClcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGhuZElucHV0RXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuYWN0aXZlKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBldmVudDogRXZlbnQgPSBuZXcgRXZlbnQoRVZFTlRfQ09OVFJPTC5JTlBVVCwgX2V2ZW50KTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgaW50ZXJmYWNlIEtleVByZXNzZWQge1xyXG4gICAgW2NvZGU6IHN0cmluZ106IGJvb2xlYW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb2xsZWN0cyB0aGUga2V5cyBwcmVzc2VkIG9uIHRoZSBrZXlib2FyZCBhbmQgc3RvcmVzIHRoZWlyIHN0YXR1cy4gXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIEtleWJvYXJkIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGtleXNQcmVzc2VkOiBLZXlQcmVzc2VkID0gS2V5Ym9hcmQuaW5pdGlhbGl6ZSgpO1xyXG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgY29kZV9lbjogT2JqZWN0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9uZSBvZiB0aGUgZ2l2ZW4ga2V5cyBpcyBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpc1ByZXNzZWRPbmUoX2tleXM6IEtFWUJPQVJEX0NPREVbXSk6IGJvb2xlYW4ge1xyXG4gICAgICBmb3IgKGxldCBjb2RlIG9mIF9rZXlzKSB7XHJcbiAgICAgICAgaWYgKEtleWJvYXJkLmtleXNQcmVzc2VkW2NvZGVdKVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFsbCBvZiB0aGUgZ2l2ZW4ga2V5cyBhcmUgY3VycmVudGx5IGJlaW5nIHByZXNzZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpc1ByZXNzZWRDb21ibyhfa2V5czogS0VZQk9BUkRfQ09ERVtdKTogYm9vbGVhbiB7XHJcbiAgICAgIGZvciAobGV0IGNvZGUgb2YgX2tleXMpIHtcclxuICAgICAgICBpZiAoIUtleWJvYXJkLmtleXNQcmVzc2VkW2NvZGVdKVxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgZ2l2ZW4gYXMgX2FjdGl2ZSBpZiBvbmUgb3IsIHdoZW4gX2NvbWJvIGlzIHRydWUsIGFsbCBvZiB0aGUgZ2l2ZW4ga2V5cyBhcmUgcHJlc3NlZC5cclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGdpdmVuIGFzIF9pbmFjdGl2ZSBpZiBub3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgbWFwVG9WYWx1ZTxUPihfYWN0aXZlOiBULCBfaW5hY3RpdmU6IFQsIF9rZXlzOiBLRVlCT0FSRF9DT0RFW10sIF9jb21ibzogYm9vbGVhbiA9IGZhbHNlKTogVCB7XHJcbiAgICAgIGlmICghX2NvbWJvICYmIEtleWJvYXJkLmlzUHJlc3NlZE9uZShfa2V5cykpXHJcbiAgICAgICAgcmV0dXJuIF9hY3RpdmU7XHJcbiAgICAgIGlmIChLZXlib2FyZC5pc1ByZXNzZWRDb21ibyhfa2V5cykpXHJcbiAgICAgICAgcmV0dXJuIF9hY3RpdmU7XHJcbiAgICAgIHJldHVybiBfaW5hY3RpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgYmFsYW5jZWQgdGVybmFyeSB2YWx1ZSAoZWl0aGVyIC0xLCAwIG9yIDEpIFxyXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBtYXRjaCBvZiB0aGUga2V5cyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZCBhbmQgdGhlIGxpc3RzIG9mIGtleXMgZ2l2ZW4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgbWFwVG9Ucml0KF9wb3NpdGl2ZTogS0VZQk9BUkRfQ09ERVtdLCBfbmVnYXRpdmU6IEtFWUJPQVJEX0NPREVbXSk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBLZXlib2FyZC5tYXBUb1ZhbHVlKC0xLCAwLCBfbmVnYXRpdmUpICsgS2V5Ym9hcmQubWFwVG9WYWx1ZSgxLCAwLCBfcG9zaXRpdmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgbG9jYWxlKF9rZXlib2FyZDogT2JqZWN0KTogdm9pZCB7XHJcbiAgICAvLyAgIGlmICghS2V5Ym9hcmQuY29kZV9lbikge1xyXG4gICAgLy8gICAgIC8vIHNhdmUgb3JpZ2luYWwga2V5Ym9hcmQgY29kZXMgdG8gYmUgYWJsZSB0byBzd2l0Y2ggYmFjayBsYXRlclxyXG4gICAgLy8gICAgIEtleWJvYXJkLmNvZGVfZW4gPSB7fTtcclxuICAgIC8vICAgICBPYmplY3QuYXNzaWduKEtleWJvYXJkLmNvZGVfZW4sIEtFWUJPQVJEX0NPREUpO1xyXG4gICAgLy8gICB9XHJcblxyXG4gICAgLy8gICBmb3IgKGxldCBrZXkgaW4gX2tleWJvYXJkKSB7XHJcbiAgICAvLyAgICAgbGV0IHZhbHVlOiBzdHJpbmcgPSBSZWZsZWN0LmdldChfa2V5Ym9hcmQsIGtleSk7XHJcbiAgICAvLyAgICAgZm9yIChsZXQgb3JpZ2luYWwgaW4gS0VZQk9BUkRfQ09ERSlcclxuICAgIC8vICAgICAgIGlmIChSZWZsZWN0LmdldChLRVlCT0FSRF9DT0RFLCBvcmlnaW5hbCkgPT0gdmFsdWUpXHJcbiAgICAvLyAgICAgICAgIC8vIHJlbW92ZSBvcmlnaW5hbCBrZXkgdGhlIHlpZWxkcyB0aGUgdmFsdWVcclxuICAgIC8vICAgICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShLRVlCT0FSRF9DT0RFLCBvcmlnaW5hbCk7XHJcbiAgICAvLyAgICAgLy8gYWRkIG5ldyBrZXkgdG8geWllbGQgdGhhdCB2YWx1ZVxyXG4gICAgLy8gICAgIFJlZmxlY3Quc2V0KEtFWUJPQVJEX0NPREUsIGtleSwgdmFsdWUpO1xyXG4gICAgLy8gICB9XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5pdGlhbGl6ZSgpOiBLZXlQcmVzc2VkIHtcclxuICAgICAgbGV0IHN0b3JlOiBLZXlQcmVzc2VkID0ge307XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIEtleWJvYXJkLmhuZEtleUludGVyYWN0aW9uKTtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIEtleWJvYXJkLmhuZEtleUludGVyYWN0aW9uKTtcclxuICAgICAgcmV0dXJuIHN0b3JlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGhuZEtleUludGVyYWN0aW9uKF9ldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgICBLZXlib2FyZC5rZXlzUHJlc3NlZFtfZXZlbnQuY29kZV0gPSAoX2V2ZW50LnR5cGUgPT0gXCJrZXlkb3duXCIpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdUYXJnZXQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFJvdXRpbmcgdG8gdGhlIGFsZXJ0IGJveFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBEZWJ1Z0FsZXJ0IGV4dGVuZHMgRGVidWdUYXJnZXQge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWxlZ2F0ZXM6IE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZSA9IHtcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5JTkZPXTogRGVidWdBbGVydC5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLklORk9dKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuTE9HXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuV0FSTl06IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5XQVJOXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuRVJST1JdOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuRVJST1JdKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5GVURHRV0pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLlNPVVJDRV06IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdKVxyXG4gICAgfTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBSZXR1cm5zIGEgZGVsZWdhdGUtZnVuY3Rpb24gZXhwZWN0aW5nIGEgbWVzc2FnZSB0byBsb2cuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlRGVsZWdhdGUoX2hlYWRsaW5lOiBzdHJpbmcpOiBGdW5jdGlvbiB7XHJcbiAgICAgIGxldCBkZWxlZ2F0ZTogRnVuY3Rpb24gPSBmdW5jdGlvbiAoX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGFyZ3M6IHN0cmluZ1tdID0gX2FyZ3MubWFwKF9hcmcgPT4gX2FyZy50b1N0cmluZygpKTtcclxuICAgICAgICBsZXQgb3V0OiBzdHJpbmcgPSBfaGVhZGxpbmUgKyBcIiBcIiArIERlYnVnVGFyZ2V0Lm1lcmdlQXJndW1lbnRzKF9tZXNzYWdlLCBhcmdzKTtcclxuICAgICAgICBhbGVydChvdXQpO1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gZGVsZWdhdGU7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z1RhcmdldC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogUm91dGluZyB0byBhIEhUTUxEaWFsb2dFbGVtZW50XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIERlYnVnRGlhbG9nIGV4dGVuZHMgRGVidWdUYXJnZXQge1xyXG4gICAgLy8gVE9ETzogY2hlY2tvdXQgSFRNTERpYWxvZ0VsZW1lbnQ7ICEhIVxyXG4gIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdUYXJnZXQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFJvdXRlIHRvIGFuIEhUTUxUZXh0QXJlYSwgbWF5IGJlIG9ic29sZXRlIHdoZW4gdXNpbmcgSFRNTERpYWxvZ0VsZW1lbnRcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRGVidWdUZXh0QXJlYSBleHRlbmRzIERlYnVnVGFyZ2V0IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgdGV4dEFyZWE6IEhUTUxUZXh0QXJlYUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XHJcbiAgICBwdWJsaWMgc3RhdGljIGF1dG9TY3JvbGw6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZWdhdGVzOiBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGUgPSB7XHJcbiAgICAgIFtERUJVR19GSUxURVIuSU5GT106IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5JTkZPXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuTE9HXTogRGVidWdUZXh0QXJlYS5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkxPR10pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLldBUk5dOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuV0FSTl0pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkVSUk9SXTogRGVidWdUZXh0QXJlYS5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkVSUk9SXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuRlVER0VdOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuRlVER0VdKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5DTEVBUl06IERlYnVnVGV4dEFyZWEuY2xlYXIsXHJcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBdOiBEZWJ1Z1RleHRBcmVhLmdyb3VwLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQQ09MTEFQU0VEXTogRGVidWdUZXh0QXJlYS5ncm91cCxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUEVORF06IERlYnVnVGV4dEFyZWEuZ3JvdXBFbmQsXHJcbiAgICAgIFtERUJVR19GSUxURVIuU09VUkNFXTogRGVidWdUZXh0QXJlYS5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLlNPVVJDRV0pXHJcbiAgICB9O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSB0ZXh0IGFyZWEgYW5kIHRoZSBncm91cHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGVhcigpOiB2b2lkIHtcclxuICAgICAgRGVidWdUZXh0QXJlYS50ZXh0QXJlYS50ZXh0Q29udGVudCA9IFwiXCI7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEuZ3JvdXBzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCZWdpbnMgYSBuZXcgZ3JvdXAgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdyb3VwKF9uYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgRGVidWdUZXh0QXJlYS5wcmludChcIuKWvCBcIiArIF9uYW1lKTtcclxuICAgICAgRGVidWdUZXh0QXJlYS5ncm91cHMucHVzaChfbmFtZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuZHMgdGhlIGxhc3QgZ3JvdXBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBncm91cEVuZCgpOiB2b2lkIHtcclxuICAgICAgRGVidWdUZXh0QXJlYS5ncm91cHMucG9wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZGVsZWdhdGUtZnVuY3Rpb24gZXhwZWN0aW5nIGEgbWVzc2FnZSB0byBsb2cuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlRGVsZWdhdGUoX2hlYWRsaW5lOiBzdHJpbmcpOiBGdW5jdGlvbiB7XHJcbiAgICAgIGxldCBkZWxlZ2F0ZTogRnVuY3Rpb24gPSBmdW5jdGlvbiAoX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogdm9pZCB7XHJcbiAgICAgICAgRGVidWdUZXh0QXJlYS5wcmludChfaGVhZGxpbmUgKyBcIiBcIiArIERlYnVnVGFyZ2V0Lm1lcmdlQXJndW1lbnRzKF9tZXNzYWdlLCBfYXJncykpO1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gZGVsZWdhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0SW5kZW50YXRpb24oX2xldmVsOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICBsZXQgcmVzdWx0OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgX2xldmVsOyBpKyspXHJcbiAgICAgICAgcmVzdWx0ICs9IFwifCBcIjtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBwcmludChfdGV4dDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEudGV4dEFyZWEudGV4dENvbnRlbnQgKz0gRGVidWdUZXh0QXJlYS5nZXRJbmRlbnRhdGlvbihEZWJ1Z1RleHRBcmVhLmdyb3Vwcy5sZW5ndGgpICsgX3RleHQgKyBcIlxcblwiO1xyXG4gICAgICBpZiAoRGVidWdUZXh0QXJlYS5hdXRvU2Nyb2xsKVxyXG4gICAgICAgIERlYnVnVGV4dEFyZWEudGV4dEFyZWEuc2Nyb2xsVG9wID0gRGVidWdUZXh0QXJlYS50ZXh0QXJlYS5zY3JvbGxIZWlnaHQ7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogVGhlIGNvZGVzIHNlbnQgZnJvbSBhIHN0YW5kYXJkIGVuZ2xpc2gga2V5Ym9hcmQgbGF5b3V0XHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gS0VZQk9BUkRfQ09ERSB7XHJcbiAgICBBID0gXCJLZXlBXCIsXHJcbiAgICBCID0gXCJLZXlCXCIsXHJcbiAgICBDID0gXCJLZXlDXCIsXHJcbiAgICBEID0gXCJLZXlEXCIsXHJcbiAgICBFID0gXCJLZXlFXCIsXHJcbiAgICBGID0gXCJLZXlGXCIsXHJcbiAgICBHID0gXCJLZXlHXCIsXHJcbiAgICBIID0gXCJLZXlIXCIsXHJcbiAgICBJID0gXCJLZXlJXCIsXHJcbiAgICBKID0gXCJLZXlKXCIsXHJcbiAgICBLID0gXCJLZXlLXCIsXHJcbiAgICBMID0gXCJLZXlMXCIsXHJcbiAgICBNID0gXCJLZXlNXCIsXHJcbiAgICBOID0gXCJLZXlOXCIsXHJcbiAgICBPID0gXCJLZXlPXCIsXHJcbiAgICBQID0gXCJLZXlQXCIsXHJcbiAgICBRID0gXCJLZXlRXCIsXHJcbiAgICBSID0gXCJLZXlSXCIsXHJcbiAgICBTID0gXCJLZXlTXCIsXHJcbiAgICBUID0gXCJLZXlUXCIsXHJcbiAgICBVID0gXCJLZXlVXCIsXHJcbiAgICBWID0gXCJLZXlWXCIsXHJcbiAgICBXID0gXCJLZXlXXCIsXHJcbiAgICBYID0gXCJLZXlYXCIsXHJcbiAgICBZID0gXCJLZXlZXCIsXHJcbiAgICBaID0gXCJLZXlaXCIsXHJcbiAgICBFU0MgPSBcIkVzY2FwZVwiLFxyXG4gICAgWkVSTyA9IFwiRGlnaXQwXCIsXHJcbiAgICBPTkUgPSBcIkRpZ2l0MVwiLFxyXG4gICAgVFdPID0gXCJEaWdpdDJcIixcclxuICAgIFRIUkVFID0gXCJEaWdpdDNcIixcclxuICAgIEZPVVIgPSBcIkRpZ2l0NFwiLFxyXG4gICAgRklWRSA9IFwiRGlnaXQ1XCIsXHJcbiAgICBTSVggPSBcIkRpZ2l0NlwiLFxyXG4gICAgU0VWRU4gPSBcIkRpZ2l0N1wiLFxyXG4gICAgRUlHSFQgPSBcIkRpZ2l0OFwiLFxyXG4gICAgTklORSA9IFwiRGlnaXQ5XCIsXHJcbiAgICBNSU5VUyA9IFwiTWludXNcIixcclxuICAgIEVRVUFMID0gXCJFcXVhbFwiLFxyXG4gICAgQkFDS1NQQUNFID0gXCJCYWNrc3BhY2VcIixcclxuICAgIFRBQlVMQVRPUiA9IFwiVGFiXCIsXHJcbiAgICBCUkFDS0VUX0xFRlQgPSBcIkJyYWNrZXRMZWZ0XCIsXHJcbiAgICBCUkFDS0VUX1JJR0hUID0gXCJCcmFja2V0UmlnaHRcIixcclxuICAgIEVOVEVSID0gXCJFbnRlclwiLFxyXG4gICAgQ1RSTF9MRUZUID0gXCJDb250cm9sTGVmdFwiLFxyXG4gICAgU0VNSUNPTE9OID0gXCJTZW1pY29sb25cIixcclxuICAgIFFVT1RFID0gXCJRdW90ZVwiLFxyXG4gICAgQkFDS19RVU9URSA9IFwiQmFja3F1b3RlXCIsXHJcbiAgICBTSElGVF9MRUZUID0gXCJTaGlmdExlZnRcIixcclxuICAgIEJBQ0tTTEFTSCA9IFwiQmFja3NsYXNoXCIsXHJcbiAgICBDT01NQSA9IFwiQ29tbWFcIixcclxuICAgIFBFUklPRCA9IFwiUGVyaW9kXCIsXHJcbiAgICBTTEFTSCA9IFwiU2xhc2hcIixcclxuICAgIFNISUZUX1JJR0hUID0gXCJTaGlmdFJpZ2h0XCIsXHJcbiAgICBOVU1QQURfTVVMVElQTFkgPSBcIk51bXBhZE11bHRpcGx5XCIsXHJcbiAgICBBTFRfTEVGVCA9IFwiQWx0TGVmdFwiLFxyXG4gICAgU1BBQ0UgPSBcIlNwYWNlXCIsXHJcbiAgICBDQVBTX0xPQ0sgPSBcIkNhcHNMb2NrXCIsXHJcbiAgICBGMSA9IFwiRjFcIixcclxuICAgIEYyID0gXCJGMlwiLFxyXG4gICAgRjMgPSBcIkYzXCIsXHJcbiAgICBGNCA9IFwiRjRcIixcclxuICAgIEY1ID0gXCJGNVwiLFxyXG4gICAgRjYgPSBcIkY2XCIsXHJcbiAgICBGNyA9IFwiRjdcIixcclxuICAgIEY4ID0gXCJGOFwiLFxyXG4gICAgRjkgPSBcIkY5XCIsXHJcbiAgICBGMTAgPSBcIkYxMFwiLFxyXG4gICAgUEFVU0UgPSBcIlBhdXNlXCIsXHJcbiAgICBTQ1JPTExfTE9DSyA9IFwiU2Nyb2xsTG9ja1wiLFxyXG4gICAgTlVNUEFENyA9IFwiTnVtcGFkN1wiLFxyXG4gICAgTlVNUEFEOCA9IFwiTnVtcGFkOFwiLFxyXG4gICAgTlVNUEFEOSA9IFwiTnVtcGFkOVwiLFxyXG4gICAgTlVNUEFEX1NVQlRSQUNUID0gXCJOdW1wYWRTdWJ0cmFjdFwiLFxyXG4gICAgTlVNUEFENCA9IFwiTnVtcGFkNFwiLFxyXG4gICAgTlVNUEFENSA9IFwiTnVtcGFkNVwiLFxyXG4gICAgTlVNUEFENiA9IFwiTnVtcGFkNlwiLFxyXG4gICAgTlVNUEFEX0FERCA9IFwiTnVtcGFkQWRkXCIsXHJcbiAgICBOVU1QQUQxID0gXCJOdW1wYWQxXCIsXHJcbiAgICBOVU1QQUQyID0gXCJOdW1wYWQyXCIsXHJcbiAgICBOVU1QQUQzID0gXCJOdW1wYWQzXCIsXHJcbiAgICBOVU1QQUQwID0gXCJOdW1wYWQwXCIsXHJcbiAgICBOVU1QQURfREVDSU1BTCA9IFwiTnVtcGFkRGVjaW1hbFwiLFxyXG4gICAgUFJJTlRfU0NSRUVOID0gXCJQcmludFNjcmVlblwiLFxyXG4gICAgSU5UTF9CQUNLX1NMQVNIID0gXCJJbnRsQmFja1NsYXNoXCIsXHJcbiAgICBGMTEgPSBcIkYxMVwiLFxyXG4gICAgRjEyID0gXCJGMTJcIixcclxuICAgIE5VTVBBRF9FUVVBTCA9IFwiTnVtcGFkRXF1YWxcIixcclxuICAgIEYxMyA9IFwiRjEzXCIsXHJcbiAgICBGMTQgPSBcIkYxNFwiLFxyXG4gICAgRjE1ID0gXCJGMTVcIixcclxuICAgIEYxNiA9IFwiRjE2XCIsXHJcbiAgICBGMTcgPSBcIkYxN1wiLFxyXG4gICAgRjE4ID0gXCJGMThcIixcclxuICAgIEYxOSA9IFwiRjE5XCIsXHJcbiAgICBGMjAgPSBcIkYyMFwiLFxyXG4gICAgRjIxID0gXCJGMjFcIixcclxuICAgIEYyMiA9IFwiRjIyXCIsXHJcbiAgICBGMjMgPSBcIkYyM1wiLFxyXG4gICAgRjI0ID0gXCJGMjRcIixcclxuICAgIEtBTkFfTU9ERSA9IFwiS2FuYU1vZGVcIixcclxuICAgIExBTkcyID0gXCJMYW5nMlwiLFxyXG4gICAgTEFORzEgPSBcIkxhbmcxXCIsXHJcbiAgICBJTlRMX1JPID0gXCJJbnRsUm9cIixcclxuICAgIENPTlZFUlQgPSBcIkNvbnZlcnRcIixcclxuICAgIE5PTl9DT05WRVJUID0gXCJOb25Db252ZXJ0XCIsXHJcbiAgICBJTlRMX1lFTiA9IFwiSW50bFllblwiLFxyXG4gICAgTlVNUEFEX0NPTU1BID0gXCJOdW1wYWRDb21tYVwiLFxyXG4gICAgVU5ETyA9IFwiVW5kb1wiLFxyXG4gICAgUEFTVEUgPSBcIlBhc3RlXCIsXHJcbiAgICBNRURJQV9UUkFDS19QUkVWSU9VUyA9IFwiTWVkaWFUcmFja1ByZXZpb3VzXCIsXHJcbiAgICBDVVQgPSBcIkN1dFwiLFxyXG4gICAgQ09QWSA9IFwiQ29weVwiLFxyXG4gICAgTUVESUFfVFJBQ0tfTkVYVCA9IFwiTWVkaWFUcmFja05leHRcIixcclxuICAgIE5VTVBBRF9FTlRFUiA9IFwiTnVtcGFkRW50ZXJcIixcclxuICAgIENUUkxfUklHSFQgPSBcIkNvbnRyb2xSaWdodFwiLFxyXG4gICAgQVVESU9fVk9MVU1FX01VVEUgPSBcIkF1ZGlvVm9sdW1lTXV0ZVwiLFxyXG4gICAgTEFVTkNIX0FQUDIgPSBcIkxhdW5jaEFwcDJcIixcclxuICAgIE1FRElBX1BMQVlfUEFVU0UgPSBcIk1lZGlhUGxheVBhdXNlXCIsXHJcbiAgICBNRURJQV9TVE9QID0gXCJNZWRpYVN0b3BcIixcclxuICAgIEVKRUNUID0gXCJFamVjdFwiLFxyXG4gICAgQVVESU9fVk9MVU1FX0RPV04gPSBcIkF1ZGlvVm9sdW1lRG93blwiLFxyXG4gICAgVk9MVU1FX0RPV04gPSBcIlZvbHVtZURvd25cIixcclxuICAgIEFVRElPX1ZPTFVNRV9VUCA9IFwiQXVkaW9Wb2x1bWVVcFwiLFxyXG4gICAgVk9MVU1FX1VQID0gXCJWb2x1bWVVcFwiLFxyXG4gICAgQlJPV1NFUl9IT01FID0gXCJCcm93c2VySG9tZVwiLFxyXG4gICAgTlVNUEFEX0RJVklERSA9IFwiTnVtcGFkRGl2aWRlXCIsXHJcbiAgICBBTFRfUklHSFQgPSBcIkFsdFJpZ2h0XCIsXHJcbiAgICBIRUxQID0gXCJIZWxwXCIsXHJcbiAgICBOVU1fTE9DSyA9IFwiTnVtTG9ja1wiLFxyXG4gICAgSE9NRSA9IFwiSG9tZVwiLFxyXG4gICAgQVJST1dfVVAgPSBcIkFycm93VXBcIixcclxuICAgIEFSUk9XX1JJR0hUID0gXCJBcnJvd1JpZ2h0XCIsXHJcbiAgICBBUlJPV19ET1dOID0gXCJBcnJvd0Rvd25cIixcclxuICAgIEFSUk9XX0xFRlQgPSBcIkFycm93TGVmdFwiLFxyXG4gICAgRU5EID0gXCJFbmRcIixcclxuICAgIFBBR0VfVVAgPSBcIlBhZ2VVcFwiLFxyXG4gICAgUEFHRV9ET1dOID0gXCJQYWdlRG93blwiLFxyXG4gICAgSU5TRVJUID0gXCJJbnNlcnRcIixcclxuICAgIERFTEVURSA9IFwiRGVsZXRlXCIsXHJcbiAgICBNRVRBX0xFRlQgPSBcIk1ldGFfTGVmdFwiLFxyXG4gICAgT1NfTEVGVCA9IFwiT1NMZWZ0XCIsXHJcbiAgICBNRVRBX1JJR0hUID0gXCJNZXRhUmlnaHRcIixcclxuICAgIE9TX1JJR0hUID0gXCJPU1JpZ2h0XCIsXHJcbiAgICBDT05URVhUX01FTlUgPSBcIkNvbnRleHRNZW51XCIsXHJcbiAgICBQT1dFUiA9IFwiUG93ZXJcIixcclxuICAgIEJST1dTRVJfU0VBUkNIID0gXCJCcm93c2VyU2VhcmNoXCIsXHJcbiAgICBCUk9XU0VSX0ZBVk9SSVRFUyA9IFwiQnJvd3NlckZhdm9yaXRlc1wiLFxyXG4gICAgQlJPV1NFUl9SRUZSRVNIID0gXCJCcm93c2VyUmVmcmVzaFwiLFxyXG4gICAgQlJPV1NFUl9TVE9QID0gXCJCcm93c2VyU3RvcFwiLFxyXG4gICAgQlJPV1NFUl9GT1JXQVJEID0gXCJCcm93c2VyRm9yd2FyZFwiLFxyXG4gICAgQlJPV1NFUl9CQUNLID0gXCJCcm93c2VyQmFja1wiLFxyXG4gICAgTEFVTkNIX0FQUDEgPSBcIkxhdW5jaEFwcDFcIixcclxuICAgIExBVU5DSF9NQUlMID0gXCJMYXVuY2hNYWlsXCIsXHJcbiAgICBMQVVOQ0hfTUVESUFfUExBWUVSID0gXCJMYXVuY2hNZWRpYVBsYXllclwiLFxyXG5cclxuICAgIC8vbWFjIGJyaW5ncyB0aGlzIGJ1dHR0b25cclxuICAgIEZOID0gXCJGblwiLCAvL25vIGV2ZW50IGZpcmVkIGFjdHVhbGx5XHJcblxyXG4gICAgLy9MaW51eCBicmluZ3MgdGhlc2VcclxuICAgIEFHQUlOID0gXCJBZ2FpblwiLFxyXG4gICAgUFJPUFMgPSBcIlByb3BzXCIsXHJcbiAgICBTRUxFQ1QgPSBcIlNlbGVjdFwiLFxyXG4gICAgT1BFTiA9IFwiT3BlblwiLFxyXG4gICAgRklORCA9IFwiRmluZFwiLFxyXG4gICAgV0FLRV9VUCA9IFwiV2FrZVVwXCIsXHJcbiAgICBOVU1QQURfUEFSRU5UX0xFRlQgPSBcIk51bXBhZFBhcmVudExlZnRcIixcclxuICAgIE5VTVBBRF9QQVJFTlRfUklHSFQgPSBcIk51bXBhZFBhcmVudFJpZ2h0XCIsXHJcblxyXG4gICAgLy9hbmRyb2lkXHJcbiAgICBTTEVFUCA9IFwiU2xlZXBcIlxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gS0VZQk9BUkRfQ09ERV9ERSB7XHJcbiAgICBaID0gS0VZQk9BUkRfQ09ERS5ZLFxyXG4gICAgWSA9IEtFWUJPQVJEX0NPREUuWixcclxuICAgIMOWID0gS0VZQk9BUkRfQ09ERS5TRU1JQ09MT04sXHJcbiAgICDDhCA9IEtFWUJPQVJEX0NPREUuUVVPVEUsXHJcbiAgICDDnCA9IEtFWUJPQVJEX0NPREUuQlJBQ0tFVF9MRUZULFxyXG4gICAgSEFTSCA9IEtFWUJPQVJEX0NPREUuQkFDS1NMQVNILFxyXG4gICAgUExVUyA9IEtFWUJPQVJEX0NPREUuQlJBQ0tFVF9SSUdIVCxcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBcclxuICAgIMOfID0gS0VZQk9BUkRfQ09ERS5NSU5VUyxcclxuICAgIEFDVVRFID0gS0VZQk9BUkRfQ09ERS5FUVVBTCxcclxuICAgIExFU1NfVEhBTiA9IEtFWUJPQVJEX0NPREUuSU5UTF9CQUNLX1NMQVNILFxyXG4gICAgTUlOVVMgPSBLRVlCT0FSRF9DT0RFLlNMQVNIXHJcbiAgfVxyXG5cclxuICAvKiBcclxuICBGaXJlZm94IGNhbid0IG1ha2UgdXNlIG9mIHRob3NlIGJ1dHRvbnMgYW5kIENvbWJpbmF0aW9uczpcclxuICBTSU5HRUxFX0JVVFRPTlM6XHJcbiAgIERydWNrLFxyXG4gIENPTUJJTkFUSU9OUzpcclxuICAgU2hpZnQgKyBGMTAsIFNoaWZ0ICsgTnVtcGFkNSxcclxuICAgQ1RSTCArIHEsIENUUkwgKyBGNCxcclxuICAgQUxUICsgRjEsIEFMVCArIEYyLCBBTFQgKyBGMywgQUxUICsgRjcsIEFMVCArIEY4LCBBTFQgKyBGMTBcclxuICBPcGVyYSB3b24ndCBkbyBnb29kIHdpdGggdGhlc2UgQnV0dG9ucyBhbmQgY29tYmluYXRpb25zOlxyXG4gIFNJTkdMRV9CVVRUT05TOlxyXG4gICBGbG9hdDMyQXJyYXksIEYxMSwgQUxULFxyXG4gIENPTUJJTkFUSU9OUzpcclxuICAgQ1RSTCArIHEsIENUUkwgKyB0LCBDVFJMICsgaCwgQ1RSTCArIGcsIENUUkwgKyBuLCBDVFJMICsgZiBcclxuICAgQUxUICsgRjEsIEFMVCArIEYyLCBBTFQgKyBGNCwgQUxUICsgRjUsIEFMVCArIEY2LCBBTFQgKyBGNywgQUxUICsgRjgsIEFMVCArIEYxMFxyXG4gICAqL1xyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfVElNRVIge1xyXG4gICAgQ0FMTCA9IFwixpJsYXBzZVwiXHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEFuIGV2ZW50IHRoYXQgcmVwcmVzZW50cyBhIGNhbGwgZnJvbSBhIHtAbGluayBUaW1lcn1cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRXZlbnRUaW1lciB7XHJcbiAgICBwdWJsaWMgdHlwZTogRVZFTlRfVElNRVIgPSBFVkVOVF9USU1FUi5DQUxMO1xyXG4gICAgcHVibGljIHRhcmdldDogVGltZXI7XHJcbiAgICBwdWJsaWMgYXJndW1lbnRzOiBPYmplY3RbXTtcclxuICAgIHB1YmxpYyBmaXJzdENhbGw6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgcHVibGljIGxhc3RDYWxsOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwdWJsaWMgY291bnQ6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3RpbWVyOiBUaW1lciwgLi4uX2FyZ3VtZW50czogT2JqZWN0W10pIHtcclxuICAgICAgdGhpcy50YXJnZXQgPSBfdGltZXI7XHJcbiAgICAgIHRoaXMuYXJndW1lbnRzID0gX2FyZ3VtZW50cztcclxuICAgICAgdGhpcy5maXJzdENhbGwgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEN1c3RvbSB0b3VjaCBldmVudHNcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBFVkVOVF9UT1VDSCB7XHJcbiAgICAvKiogY3VzdG9tIGV2ZW50IGZpcmVkIGluIGFkZGl0aW9uIHRvIHRoZSBzdGFuZGFyZCB0b3VjaG1vdmUsIGRldGFpbHMgb2Zmc2V0IHRvIHN0YXJ0aW5nIHRvdWNoICovXHJcbiAgICBNT1ZFID0gXCJ0b3VjaE1vdmVcIixcclxuICAgIC8qKiBjdXN0b20gZXZlbnQgZmlyZWQgd2hlbiB0aGUgdG91Y2hlcyBoYXZlbid0IG1vdmVkIG91dHNpZGUgb2YgdGhlIHRhcCByYWRpdXMgKi9cclxuICAgIFRBUCA9IFwidG91Y2hUYXBcIixcclxuICAgIC8qKiBjdXN0b20gZXZlbnQgZmlyZWQgd2hlbiB0aGUgdG91Y2hlcyBoYXZlIG1vdmVkIG91dHNpZGUgb2YgdGhlIG5vdGNoIHJhZGl1cywgZGV0YWlscyBvZmZzZXQgYW5kIGNhcmRpbmFsIGRpcmVjdGlvbiAqL1xyXG4gICAgTk9UQ0ggPSBcInRvdWNoTm90Y2hcIixcclxuICAgIC8qKiBjdXN0b20gZXZlbnQgZmlyZWQgd2hlbiB0aGUgdG91Y2hlcyBoYXZlbid0IG1vdmVkIG91dHNpZGUgb2YgdGhlIHRhcCByYWRpdXMgZm9yIHNvbWUgdGltZSAqL1xyXG4gICAgTE9ORyA9IFwidG91Y2hMb25nXCIsXHJcbiAgICAvKiogY3VzdG9tIGV2ZW50IGZpcmVkIHdoZW4gdHdvIHRhcHMgd2VyZSBkZXRlY3RlZCBpbiBzaG9ydCBzdWNjZXNzaW9uICovXHJcbiAgICBET1VCTEUgPSBcInRvdWNoRG91YmxlXCIsXHJcbiAgICAvKiogY3VzdG9tIGV2ZW50IGZpcmVkIHdoZW4gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG9ubHkgdHdvIHRvdWNoZXMgY2hhbmdlcyBiZXlvbmQgYSB0b2xlcmFuY2UgKi9cclxuICAgIFBJTkNIID0gXCJ0b3VjaFBpbmNoXCIsXHJcbiAgICAvKiogY3VzdG9tIGV2ZW50IG5vdCBpbXBsZW1lbnRlZCB5ZXQgKi9cclxuICAgIFJPVEFURSA9IFwidG91Y2hSb3RhdGVcIlxyXG4gIH1cclxuXHJcbiAgLyoqIERldGFpbHMgZm9yIEN1c3RvbVRvdWNoRXZlbnRzLCB1c2UgYXMgZ2VuZXJpYyBDdXN0b21FdmVudDxFdmVudFRvdWNoRGV0YWlsPiAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXZlbnRUb3VjaERldGFpbCB7XHJcbiAgICBwb3NpdGlvbjogVmVjdG9yMjtcclxuICAgIHRvdWNoZXM6IFRvdWNoTGlzdDtcclxuICAgIG9mZnNldD86IFZlY3RvcjI7XHJcbiAgICBtb3ZlbWVudD86IFZlY3RvcjI7XHJcbiAgICBjYXJkaW5hbD86IFZlY3RvcjI7XHJcbiAgICBwaW5jaD86IFZlY3RvcjI7XHJcbiAgICBwaW5jaERlbHRhPzogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcGF0Y2hlcyBDdXN0b21Ub3VjaEV2ZW50cyB0byB0aGUgRXZlbnRUYXJnZXQgZ2l2ZW4gd2l0aCB0aGUgY29uc3RydWN0b3IuXHJcbiAgICogV2hlbiB1c2luZyB0b3VjaCBldmVudHMsIG1ha2Ugc3VyZSB0byBzZXQgYHRvdWNoLWFjdGlvbjogbm9uZWAgaW4gQ1NTIFxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVG91Y2hFdmVudERpc3BhdGNoZXIge1xyXG4gICAgcHVibGljIHBvc1N0YXJ0OiBWZWN0b3IyID0gVmVjdG9yMi5aRVJPKCk7XHJcbiAgICBwdWJsaWMgcG9zTm90Y2g6IFZlY3RvcjIgPSBWZWN0b3IyLlpFUk8oKTtcclxuICAgIHB1YmxpYyByYWRpdXNUYXA6IG51bWJlcjtcclxuICAgIHB1YmxpYyByYWRpdXNOb3RjaDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSB0YXJnZXQ6IEV2ZW50VGFyZ2V0O1xyXG4gICAgcHJpdmF0ZSBwb3NQcmV2OiBWZWN0b3IyID0gVmVjdG9yMi5aRVJPKCk7XHJcbiAgICBwcml2YXRlIG1vdmVkOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIHRpbWVyRG91YmxlOiBUaW1lcjtcclxuICAgIHByaXZhdGUgdGltZXJMb25nOiBUaW1lcjtcclxuICAgIHByaXZhdGUgdGltZURvdWJsZTogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSB0aW1lTG9uZzogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSB0aW1lOiBUaW1lID0gbmV3IFRpbWUoKTtcclxuICAgIHByaXZhdGUgcGluY2hEaXN0YW5jZTogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgcGluY2hUb2xlcmFuY2U6IG51bWJlciA9IDE7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF90YXJnZXQ6IEV2ZW50VGFyZ2V0LCBfcmFkaXVzVGFwOiBudW1iZXIgPSA1LCBfcmFkaXVzTm90Y2g6IG51bWJlciA9IDUwLCBfdGltZURvdWJsZTogbnVtYmVyID0gMjAwLCBfdGltZXJMb25nOiBudW1iZXIgPSAxMDAwKSB7XHJcbiAgICAgIHRoaXMudGFyZ2V0ID0gX3RhcmdldDtcclxuICAgICAgdGhpcy5yYWRpdXNUYXAgPSBfcmFkaXVzVGFwO1xyXG4gICAgICB0aGlzLnJhZGl1c05vdGNoID0gX3JhZGl1c05vdGNoO1xyXG4gICAgICB0aGlzLnRpbWVEb3VibGUgPSBfdGltZURvdWJsZTtcclxuICAgICAgdGhpcy50aW1lTG9uZyA9IF90aW1lckxvbmc7XHJcbiAgICAgIHRoaXMuYWN0aXZhdGUodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZS0vQWN0aXZhdGVzIHRoZSBkaXNwYXRjaCBvZiBDdXN0b21Ub3VjaEV2ZW50c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWN0aXZhdGUoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIGlmIChfb24pIHtcclxuICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCA8RXZlbnRMaXN0ZW5lcj50aGlzLmhuZEV2ZW50KTtcclxuICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgPEV2ZW50TGlzdGVuZXI+dGhpcy5obmRFdmVudCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCA8RXZlbnRMaXN0ZW5lcj50aGlzLmhuZEV2ZW50KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIDxFdmVudExpc3RlbmVyPnRoaXMuaG5kRXZlbnQpO1xyXG4gICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgPEV2ZW50TGlzdGVuZXI+dGhpcy5obmRFdmVudCk7XHJcbiAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgPEV2ZW50TGlzdGVuZXI+dGhpcy5obmRFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBobmRFdmVudCA9IChfZXZlbnQ6IFRvdWNoRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgX2V2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGxldCB0b3VjaEZpcnN0OiBUb3VjaCA9IF9ldmVudC50b3VjaGVzWzBdO1xyXG4gICAgICBsZXQgcG9zaXRpb246IFZlY3RvcjIgPSB0aGlzLmNhbGNBdmVyYWdlUG9zaXRpb24oX2V2ZW50LnRvdWNoZXMpOyAvL25ldyBWZWN0b3IyKHRvdWNoRmlyc3Q/LmNsaWVudFgsIHRvdWNoRmlyc3Q/LmNsaWVudFkpO1xyXG4gICAgICBsZXQgb2Zmc2V0OiBWZWN0b3IyO1xyXG5cclxuICAgICAgc3dpdGNoIChfZXZlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgXCJ0b3VjaHN0YXJ0XCI6XHJcbiAgICAgICAgICB0aGlzLm1vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICB0aGlzLnN0YXJ0R2VzdHVyZShwb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgaWYgKF9ldmVudC50b3VjaGVzLmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHBpbmNoXHJcbiAgICAgICAgICAgIGxldCBwaW5jaDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKF9ldmVudC50b3VjaGVzWzFdLmNsaWVudFggLSB0b3VjaEZpcnN0LmNsaWVudFgsIF9ldmVudC50b3VjaGVzWzFdLmNsaWVudFkgLSB0b3VjaEZpcnN0LmNsaWVudFkpO1xyXG4gICAgICAgICAgICB0aGlzLnBpbmNoRGlzdGFuY2UgPSBwaW5jaC5tYWduaXR1ZGU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbGV0IGRpc3BhdGNoTG9uZzogVGltZXJIYW5kbGVyID0gKF9ldmVudFRpbWVyOiBFdmVudFRpbWVyKTogdm9pZCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5kaXNwYXRjaEV2ZW50KFxyXG4gICAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudDxFdmVudFRvdWNoRGV0YWlsPihFVkVOVF9UT1VDSC5MT05HLCB7XHJcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHsgcG9zaXRpb246IHBvc2l0aW9uLCB0b3VjaGVzOiBfZXZlbnQudG91Y2hlcyB9XHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgdGhpcy50aW1lckxvbmc/LmNsZWFyKCk7XHJcbiAgICAgICAgICB0aGlzLnRpbWVyTG9uZyA9IG5ldyBUaW1lcih0aGlzLnRpbWUsIHRoaXMudGltZUxvbmcsIDEsIGRpc3BhdGNoTG9uZyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwidG91Y2hlbmRcIjpcclxuICAgICAgICAgIHRoaXMudGltZXJMb25nPy5jbGVhcigpO1xyXG5cclxuICAgICAgICAgIGlmIChfZXZlbnQudG91Y2hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIHN0aWxsIHRvdWNoZXMgYWN0aXZlXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRHZXN0dXJlKHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbGV0IGRpc3BhdGNoVGFwOiBUaW1lckhhbmRsZXIgPSAoX2V2ZW50VGltZXI6IEV2ZW50VGltZXIpOiB2b2lkID0+IHtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQuZGlzcGF0Y2hFdmVudChcclxuICAgICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQ8RXZlbnRUb3VjaERldGFpbD4oRVZFTlRfVE9VQ0guVEFQLCB7XHJcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHsgcG9zaXRpb246IHBvc2l0aW9uLCB0b3VjaGVzOiBfZXZlbnQudG91Y2hlcyB9XHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgd2FzIGEgdGFwIGJlZm9yZSBhbmQgdGltZXIgaXMgc3RpbGwgcnVubmluZyAtPiBkb3VibGUgdGFwXHJcbiAgICAgICAgICBpZiAodGhpcy50aW1lckRvdWJsZT8uYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXJEb3VibGUuY2xlYXIoKTtcclxuICAgICAgICAgICAgLy8gdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQuZGlzcGF0Y2hFdmVudChcclxuICAgICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQ8RXZlbnRUb3VjaERldGFpbD4oRVZFTlRfVE9VQ0guRE9VQkxFLCB7XHJcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHsgcG9zaXRpb246IHBvc2l0aW9uLCB0b3VjaGVzOiBfZXZlbnQudG91Y2hlcyB9XHJcbiAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5tb3ZlZClcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgd2FzIG1vdmVtZW50LCBvdGhlcndpc2Ugc2V0IHRpbWVyIHRvIGZpcmUgdGFwXHJcbiAgICAgICAgICAgIHRoaXMudGltZXJEb3VibGUgPSBuZXcgVGltZXIodGhpcy50aW1lLCB0aGlzLnRpbWVEb3VibGUsIDEsIGRpc3BhdGNoVGFwKTtcclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwidG91Y2htb3ZlXCI6XHJcbiAgICAgICAgICB0aGlzLmRldGVjdFBpbmNoKF9ldmVudCwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgb2Zmc2V0ID0gVmVjdG9yMi5ESUZGRVJFTkNFKHRoaXMucG9zUHJldiwgdGhpcy5wb3NTdGFydCk7XHJcbiAgICAgICAgICB0aGlzLm1vdmVkIHx8PSAob2Zmc2V0Lm1hZ25pdHVkZSA8IHRoaXMucmFkaXVzVGFwKTsgLy8gcmVtZW1iZXIgdGhhdCB0b3VjaCBtb3ZlZCBvdmVyIHRhcCByYWRpdXNcclxuICAgICAgICAgIGxldCBtb3ZlbWVudDogVmVjdG9yMiA9IFZlY3RvcjIuRElGRkVSRU5DRShwb3NpdGlvbiwgdGhpcy5wb3NQcmV2KTtcclxuICAgICAgICAgIHRoaXMudGFyZ2V0LmRpc3BhdGNoRXZlbnQoXHJcbiAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudDxFdmVudFRvdWNoRGV0YWlsPihFVkVOVF9UT1VDSC5NT1ZFLCB7XHJcbiAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgdG91Y2hlczogX2V2ZW50LnRvdWNoZXMsIG9mZnNldDogb2Zmc2V0LCBtb3ZlbWVudDogbW92ZW1lbnQgfVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAvLyBmaXJlIG5vdGNoIHdoZW4gdG91Y2hlcyBtb3ZlZCBvdXQgb2Ygbm90Y2ggcmFkaXVzIGFuZCByZXNldCBub3RjaFxyXG4gICAgICAgICAgb2Zmc2V0ID0gVmVjdG9yMi5ESUZGRVJFTkNFKHBvc2l0aW9uLCB0aGlzLnBvc05vdGNoKTtcclxuICAgICAgICAgIGlmIChvZmZzZXQubWFnbml0dWRlID4gdGhpcy5yYWRpdXNOb3RjaCkge1xyXG4gICAgICAgICAgICBsZXQgY2FyZGluYWw6IFZlY3RvcjIgPSBNYXRoLmFicyhvZmZzZXQueCkgPiBNYXRoLmFicyhvZmZzZXQueSkgP1xyXG4gICAgICAgICAgICAgIFZlY3RvcjIuWChvZmZzZXQueCA8IDAgPyAtMSA6IDEpIDpcclxuICAgICAgICAgICAgICBWZWN0b3IyLlkob2Zmc2V0LnkgPCAwID8gLTEgOiAxKTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQuZGlzcGF0Y2hFdmVudChcclxuICAgICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQ8RXZlbnRUb3VjaERldGFpbD4oRVZFTlRfVE9VQ0guTk9UQ0gsIHtcclxuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsIGRldGFpbDogeyBwb3NpdGlvbjogcG9zaXRpb24sIHRvdWNoZXM6IF9ldmVudC50b3VjaGVzLCBvZmZzZXQ6IG9mZnNldCwgY2FyZGluYWw6IGNhcmRpbmFsLCBtb3ZlbWVudDogbW92ZW1lbnQgfVxyXG4gICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5wb3NOb3RjaCA9IHBvc2l0aW9uO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy9UT0RPOiBwaW5jaCwgcm90YXRlLi4uXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucG9zUHJldi5zZXQocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgZGV0ZWN0UGluY2ggPSAoX2V2ZW50OiBUb3VjaEV2ZW50LCBfcG9zaXRpb246IFZlY3RvcjIpOiB2b2lkID0+IHtcclxuICAgICAgaWYgKF9ldmVudC50b3VjaGVzLmxlbmd0aCAhPSAyKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCB0OiBUb3VjaExpc3QgPSBfZXZlbnQudG91Y2hlcztcclxuICAgICAgbGV0IHBpbmNoOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIodFsxXS5jbGllbnRYIC0gdFswXS5jbGllbnRYLCB0WzFdLmNsaWVudFkgLSB0WzBdLmNsaWVudFkpO1xyXG4gICAgICBsZXQgcGluY2hEaXN0YW5jZTogbnVtYmVyID0gcGluY2gubWFnbml0dWRlO1xyXG4gICAgICBsZXQgcGluY2hEZWx0YTogbnVtYmVyID0gcGluY2hEaXN0YW5jZSAtIHRoaXMucGluY2hEaXN0YW5jZTtcclxuICAgICAgaWYgKE1hdGguYWJzKHBpbmNoRGVsdGEpID4gdGhpcy5waW5jaFRvbGVyYW5jZSlcclxuICAgICAgICB0aGlzLnRhcmdldC5kaXNwYXRjaEV2ZW50KFxyXG4gICAgICAgICAgbmV3IEN1c3RvbUV2ZW50PEV2ZW50VG91Y2hEZXRhaWw+KEVWRU5UX1RPVUNILlBJTkNILCB7XHJcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsIGRldGFpbDogeyBwb3NpdGlvbjogX3Bvc2l0aW9uLCB0b3VjaGVzOiBfZXZlbnQudG91Y2hlcywgcGluY2g6IHBpbmNoLCBwaW5jaERlbHRhOiBwaW5jaERlbHRhIH1cclxuICAgICAgICAgIH0pKTtcclxuICAgICAgdGhpcy5waW5jaERpc3RhbmNlID0gcGluY2hEaXN0YW5jZTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBzdGFydEdlc3R1cmUoX3Bvc2l0aW9uOiBWZWN0b3IyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMucG9zTm90Y2guc2V0KF9wb3NpdGlvbi54LCBfcG9zaXRpb24ueSk7XHJcbiAgICAgIHRoaXMucG9zU3RhcnQuc2V0KF9wb3NpdGlvbi54LCBfcG9zaXRpb24ueSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjYWxjQXZlcmFnZVBvc2l0aW9uKF90b3VjaGVzOiBUb3VjaExpc3QpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IGF2ZXJhZ2U6IFZlY3RvcjIgPSBWZWN0b3IyLlpFUk8oKTtcclxuICAgICAgZm9yIChsZXQgdG91Y2ggb2YgX3RvdWNoZXMpIHtcclxuICAgICAgICBhdmVyYWdlLnggKz0gdG91Y2guY2xpZW50WDtcclxuICAgICAgICBhdmVyYWdlLnkgKz0gdG91Y2guY2xpZW50WTtcclxuICAgICAgfVxyXG4gICAgICBhdmVyYWdlLnNjYWxlKDEgLyBfdG91Y2hlcy5sZW5ndGgpO1xyXG4gICAgICByZXR1cm4gYXZlcmFnZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEEgbm9kZSBtYW5hZ2VkIGJ5IHtAbGluayBQcm9qZWN0fSB0aGF0IGZ1bmN0aW9ucyBhcyBhIHRlbXBsYXRlIGZvciB7QGxpbmsgR3JhcGhJbnN0YW5jZX1zIFxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vaHMtZnVydHdhbmdlbi9GVURHRS93aWtpL1Jlc291cmNlXHJcbiAgICovXHJcbiAgQFNlcmlhbGl6YWJsZVJlc291cmNlLnJlZ2lzdGVyXHJcbiAgZXhwb3J0IGNsYXNzIEdyYXBoIGV4dGVuZHMgTm9kZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcclxuICAgIHB1YmxpYyBpZFJlc291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAvLyAjc3luY2luZzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJHcmFwaFwiKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk1VVEFURSwgdGhpcy5obmRNdXRhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdHlwZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSA9IHRoaXMuaWRSZXNvdXJjZTtcclxuICAgICAgc2VyaWFsaXphdGlvbi50eXBlID0gdGhpcy50eXBlO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcywgX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XHJcbiAgICAgIGF3YWl0IFByb2plY3QucmVzeW5jR3JhcGhJbnN0YW5jZXModGhpcyk7XHJcbiAgICAgIHRoaXMuYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5ULkdSQVBIX0RFU0VSSUFMSVpFRCkpO1xyXG4gICAgICBEZWJ1Zy5sb2coXCJEZXNlcmlhbGl6ZWRcIiwgdGhpcy5uYW1lKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBobmRNdXRhdGUgPSBhc3luYyAoX2V2ZW50OiBDdXN0b21FdmVudCk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG5cclxuICAgICAgLy8gVE9ETzogaWYgcGF0aCBjb250YWlucyBhIGdyYXBoIGluc3RhbmNlIGJlbG93IHRoaXMsIGRvbid0IGRpc3BhdGNoIVxyXG4gICAgICAvLyBsZXQgcGF0aDogTm9kZVtdID0gUmVmbGVjdC5nZXQoX2V2ZW50LCBcInBhdGhcIik7XHJcbiAgICAgIC8vIGZvciAobGV0IG5vZGUgb2YgcGF0aClcclxuICAgICAgLy8gICBpZiAobm9kZSBpbnN0YW5jZW9mIEdyYXBoSW5zdGFuY2UgJiYgbm9kZS5pZFNvdXJjZSAhPSB0aGlzLmlkUmVzb3VyY2UpXHJcbiAgICAgIC8vICAgICByZXR1cm47XHJcblxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIkdyYXBoIG11dGF0ZXNcIiwgdGhpcy5uYW1lKTtcclxuICAgICAgLy8gdGhpcy4jc3luY2luZyA9IHRydWU7XHJcbiAgICAgIF9ldmVudC5kZXRhaWwucGF0aCA9IFJlZmxlY3QuZ2V0KF9ldmVudCwgXCJwYXRoXCIpOyAvLyBzYXZlIHBhdGggdG8gdGFyZ2V0IGluIGRldGFpbFxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KEVWRU5ULk1VVEFURV9HUkFQSCwgeyBkZXRhaWw6IF9ldmVudC5kZXRhaWwgfSkpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KEVWRU5ULkdSQVBIX01VVEFURUQsIHsgZGV0YWlsOiBfZXZlbnQuZGV0YWlsIH0pKTtcclxuICAgICAgLy8gdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5NVVRBVEVfSU5TVEFOQ0UpKTtcclxuICAgICAgLy8gdGhpcy4jc3luY2luZyA9IGZhbHNlO1xyXG4gICAgfTtcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQSB7QGxpbmsgR3JhcGh9IGxvYWRlZCBmcm9tIGEgZ2xURi1GaWxlLlxyXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBHcmFwaEdMVEYgZXh0ZW5kcyBtaXhpblNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWwoR3JhcGgpIHtcclxuICAgIHB1YmxpYyBhc3luYyBsb2FkKF91cmw6IFJlcXVlc3RJbmZvID0gdGhpcy51cmwsIF9uYW1lOiBzdHJpbmcgPSB0aGlzLm5hbWUpOiBQcm9taXNlPEdyYXBoR0xURj4ge1xyXG4gICAgICB0aGlzLnVybCA9IF91cmw7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICByZXR1cm4gR0xURkxvYWRlci5sb2FkUmVzb3VyY2UodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgY29uc3Qgc2VyaWFsaXphdGlvbkV4dGVybmFsOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIGNvbnN0IHNlcmlhbGl6YXRpb25Ob2RlOiBTZXJpYWxpemF0aW9uID0gTm9kZS5wcm90b3R5cGUuc2VyaWFsaXplLmNhbGwodGhpcyk7IC8vIHRoaXMgaXMgd2FzdGVmdWwgYXMgd2Ugb25seSBuZWVkIHRoZSBjb21wb25lbnRzIGRlc2VyaWFsaXplZFxyXG4gICAgICBkZWxldGUgc2VyaWFsaXphdGlvbk5vZGUuY29tcG9uZW50c1tDb21wb25lbnRTa2VsZXRvbi5uYW1lXTtcclxuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb25Ob2RlLmNoaWxkcmVuO1xyXG4gICAgICByZXR1cm4geyAuLi5zZXJpYWxpemF0aW9uTm9kZSwgLi4uc2VyaWFsaXphdGlvbkV4dGVybmFsIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBhd2FpdCBHcmFwaC5wcm90b3R5cGUuZGVzZXJpYWxpemUuY2FsbCh0aGlzLCBfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvLyBlbnVtIFNZTkMge1xyXG4gIC8vICAgUkVBRFksIEdSQVBIX1NZTkNFRCwgR1JBUEhfRE9ORSwgSU5TVEFOQ0VcclxuICAvLyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuIGluc3RhbmNlIG9mIGEge0BsaW5rIEdyYXBofS4gIFxyXG4gICAqIFRoaXMgbm9kZSBrZWVwcyBhIHJlZmVyZW5jZSB0byBpdHMgcmVzb3VyY2UgYW4gY2FuIHRodXMgb3B0aW1pemUgc2VyaWFsaXphdGlvblxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vaHMtZnVydHdhbmdlbi9GVURHRS93aWtpL1Jlc291cmNlXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEdyYXBoSW5zdGFuY2UgZXh0ZW5kcyBOb2RlIHtcclxuICAgIC8qKiBpZCBvZiB0aGUgcmVzb3VyY2UgdGhhdCBpbnN0YW5jZSB3YXMgY3JlYXRlZCBmcm9tICovXHJcbiAgICAvLyBUT0RPOiBleGFtaW5lLCBpZiB0aGlzIHNob3VsZCBiZSBhIGRpcmVjdCByZWZlcmVuY2UgdG8gdGhlIEdyYXBoLCBpbnN0ZWFkIG9mIHRoZSBpZFxyXG4gICAgcHVibGljIHN0YXRpYyBjb3VudDogbnVtYmVyID0gMDtcclxuICAgICNpZFNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgLy8gI3N5bmM6IFNZTkMgPSBTWU5DLlJFQURZO1xyXG4gICAgI2Rlc2VyaWFsaXplRnJvbVNvdXJjZTogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGNvbnN0cnVjdG9yIGFsb25lIHdpbGwgbm90IGNyZWF0ZSBhIHJlY29uc3RydWN0aW9uLCBidXQgb25seSBzYXZlIHRoZSBpZC5cclxuICAgICAqIFRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgZ3JhcGgsIGNhbGwgcmVzZXQgb24gdGhpcyBvciBzZXQgd2l0aCBhIGdyYXBoIGFzIHBhcmFtZXRlci5cclxuICAgICAqIFByZWZlciBQcm9qZWN0LmNyZWF0ZUdyYXBoSW5zdGFuY2UoX2dyYXBoKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9ncmFwaD86IEdyYXBoKSB7XHJcbiAgICAgIHN1cGVyKFwiR3JhcGhJbnN0YW5jZVwiKTtcclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk1VVEFURSwgdGhpcy5obmRNdXRhdGlvbkluc3RhbmNlKTtcclxuXHJcbiAgICAgIGlmICghX2dyYXBoKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgdGhpcy4jaWRTb3VyY2UgPSBfZ3JhcGguaWRSZXNvdXJjZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlkU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNpZFNvdXJjZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3JlYXRlIHRoaXMgbm9kZSBmcm9tIHRoZSB7QGxpbmsgR3JhcGh9IHJlZmVyZW5jZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIHJlc2V0KCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBsZXQgcmVzb3VyY2U6IEdyYXBoID0gPEdyYXBoPmF3YWl0IFByb2plY3QuZ2V0UmVzb3VyY2UodGhpcy4jaWRTb3VyY2UpO1xyXG4gICAgICBhd2FpdCB0aGlzLnNldChyZXNvdXJjZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9UT0RPOiBvcHRpbWl6ZSB1c2luZyB0aGUgcmVmZXJlbmNlZCBHcmFwaCwgc2VyaWFsaXplL2Rlc2VyaWFsaXplIG9ubHkgdGhlIGRpZmZlcmVuY2VzXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgZmlsdGVyOiBDb21wb25lbnRHcmFwaEZpbHRlciA9IHRoaXMuZ2V0Q29tcG9uZW50KENvbXBvbmVudEdyYXBoRmlsdGVyKTtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuXHJcbiAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLmlzQWN0aXZlKSB7IC8vIGlmIGdyYXBoIHN5bmNocm9uaXNhdGlvbiBpcyB1bmZpbHRlcmVkLCBrbm93aW5nIHRoZSBzb3VyY2UgaXMgc3VmZmljaWVudCBmb3Igc2VyaWFsaXphdGlvblxyXG4gICAgICAgIHNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgICBsZXQgZ3JhcGg6IEdyYXBoID0gdGhpcy5nZXQoKTtcclxuICAgICAgICBpZiAoZ3JhcGggaW5zdGFuY2VvZiBHcmFwaEdMVEYpIHsgLy8gbGlrZSBmb3IgdGhlIEdyYXBoR0xURjogY2hpbGRyZW4gYW5kIGNvbXBvbmVudHMgbG9hZGVkIGZyb20gZ2x0ZiBtdXN0IG5ldmVyIGJlIHNlcmlhbGl6ZWRcclxuICAgICAgICAgIGRlbGV0ZSBzZXJpYWxpemF0aW9uLmNvbXBvbmVudHNbQ29tcG9uZW50U2tlbGV0b24ubmFtZV07XHJcbiAgICAgICAgICBkZWxldGUgc2VyaWFsaXphdGlvbi5jaGlsZHJlbjtcclxuICAgICAgICAgIHNlcmlhbGl6YXRpb24udXJsID0gZ3JhcGgudXJsO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXJpYWxpemF0aW9uLmRlc2VyaWFsaXplRnJvbVNvdXJjZSA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgc2VyaWFsaXphdGlvbi5pZFNvdXJjZSA9IHRoaXMuI2lkU291cmNlO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLiNpZFNvdXJjZSA9IF9zZXJpYWxpemF0aW9uLmlkU291cmNlID8/IF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2U7XHJcbiAgICAgIGlmICghX3NlcmlhbGl6YXRpb24uZGVzZXJpYWxpemVGcm9tU291cmNlKSB7XHJcbiAgICAgICAgbGV0IGdyYXBoOiBHcmFwaCA9IDxHcmFwaD48dW5rbm93bj5hd2FpdCBQcm9qZWN0LmdldFJlc291cmNlKHRoaXMuI2lkU291cmNlKTtcclxuICAgICAgICBpZiAoZ3JhcGggaW5zdGFuY2VvZiBHcmFwaEdMVEYpXHJcbiAgICAgICAgICBhd2FpdCBHTFRGTG9hZGVyLmxvYWRSZXNvdXJjZSh0aGlzLCBfc2VyaWFsaXphdGlvbi51cmwpO1xyXG5cclxuICAgICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7IC8vIGluc3RhbmNlIGlzIGRlc2VyaWFsaXplZCBmcm9tIGluZGl2aWR1YWwgZGF0YVxyXG5cclxuICAgICAgICB0aGlzLiNkZXNlcmlhbGl6ZUZyb21Tb3VyY2UgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGdyYXBoOiBHcmFwaCA9IHRoaXMuZ2V0KCk7XHJcbiAgICAgIGlmIChncmFwaClcclxuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3RUb0dyYXBoKCk7IC8vIG90aGVyd2lzZSBqdXN0IGNvbm5lY3RcclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgRGVidWcubG9nKFwiUmVnaXN0ZXIgZm9yIHJlc3luY1wiLCBfc2VyaWFsaXphdGlvbi5uYW1lLCB0aGlzLm5hbWUpO1xyXG4gICAgICAgIFByb2plY3QucmVnaXN0ZXJHcmFwaEluc3RhbmNlRm9yUmVzeW5jKHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdHMgdGhpcyBncmFwaCBpbnN0YW5jZSB0byB0aGUgZ3JhcGggcmVmZXJlbmNlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGNvbm5lY3RUb0dyYXBoKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBsZXQgZ3JhcGg6IEdyYXBoID0gdGhpcy5nZXQoKTtcclxuICAgICAgaWYgKHRoaXMuI2Rlc2VyaWFsaXplRnJvbVNvdXJjZSlcclxuICAgICAgICBhd2FpdCB0aGlzLnNldChncmFwaCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhpcyBub2RlIHRvIGJlIGEgcmVjcmVhdGlvbiBvZiB0aGUge0BsaW5rIEdyYXBofSBnaXZlblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgc2V0KF9ncmFwaDogR3JhcGgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgdGhpcy4jaWRTb3VyY2UgPSBfZ3JhcGguaWRSZXNvdXJjZTtcclxuXHJcbiAgICAgIGxldCBjdXJyZW50R3JhcGg6IEdyYXBoID0gdGhpcy5nZXQoKTtcclxuICAgICAgaWYgKGN1cnJlbnRHcmFwaCkge1xyXG4gICAgICAgIGN1cnJlbnRHcmFwaC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULk1VVEFURV9HUkFQSCwgdGhpcy5obmRNdXRhdGlvbkdyYXBoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVE9ETzogZXhhbWluZSwgaWYgdGhlIHNlcmlhbGl6YXRpb24gc2hvdWxkIGJlIHN0b3JlZCBpbiB0aGUgR3JhcGggZm9yIG9wdGltaXphdGlvbiA8LSBhbHNvIHVzZWZ1bCBmb3Igc3luYyB3aXRoIGluc3RhbmNlc1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplKF9ncmFwaCk7XHJcbiAgICAgIGZvciAobGV0IHBhdGggaW4gc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZGVzZXJpYWxpemUoc2VyaWFsaXphdGlvbltwYXRoXSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIERlYnVnLmZ1ZGdlKFwiR3JhcGhJbnN0YW5jZSBzZXQgdG8gXCIgKyB0aGlzLm5hbWUgKyBcIiB8IFwiICsgXCJJbnN0YW5jZSBjb3VudDogXCIgKyBHcmFwaEluc3RhbmNlLmNvdW50KyspO1xyXG4gICAgICBfZ3JhcGguYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5NVVRBVEVfR1JBUEgsIHRoaXMuaG5kTXV0YXRpb25HcmFwaCk7XHJcbiAgICAgIHRoaXMuYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5ULkdSQVBIX0lOU1RBTlRJQVRFRCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIGdyYXBoIHRoaXMgaW5zdGFuY2VzIHJlZmVycyB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0KCk6IEdyYXBoIHtcclxuICAgICAgcmV0dXJuIDxHcmFwaD5Qcm9qZWN0LnJlc291cmNlc1t0aGlzLiNpZFNvdXJjZV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3VyY2UgZ3JhcGggbXV0YXRlZCwgcmVmbGVjdCBtdXRhdGlvbiBpbiB0aGlzIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaG5kTXV0YXRpb25HcmFwaCA9IGFzeW5jIChfZXZlbnQ6IEN1c3RvbUV2ZW50KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmlzRmlsdGVyZWQoKSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBhd2FpdCB0aGlzLnJlZmxlY3RNdXRhdGlvbihfZXZlbnQsIDxHcmFwaD5fZXZlbnQuY3VycmVudFRhcmdldCwgdGhpcywgX2V2ZW50LmRldGFpbC5wYXRoKTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5NVVRBVEVfSU5TVEFOQ0UsIHsgYnViYmxlczogdHJ1ZSB9KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpbnN0YW5jZSBtdXRhdGVkLCByZWZsZWN0IG11dGF0aW9uIGluIHNvdXJjZSBncmFwaFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhuZE11dGF0aW9uSW5zdGFuY2UgPSBhc3luYyAoX2V2ZW50OiBDdXN0b21FdmVudCk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgICBpZiAodGhpcy5pc0ZpbHRlcmVkKCkpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgYXdhaXQgdGhpcy5yZWZsZWN0TXV0YXRpb24oX2V2ZW50LCB0aGlzLCB0aGlzLmdldCgpLCBSZWZsZWN0LmdldChfZXZlbnQsIFwicGF0aFwiKSk7XHJcbiAgICAgIHRoaXMuZ2V0KCkuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuTVVUQVRFLCB7IGRldGFpbDogX2V2ZW50LmRldGFpbCB9KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHJlZmxlY3QgbXV0YXRpb24gZnJvbSBhIHNvdXJjZSBncmFwaCBvciBpbnN0YW5jZSB0byBhIGRlc3RpbmF0aW9uIGluc3RhbmNlIG9yIGdyYXBoXHJcbiAgICBwcml2YXRlIGFzeW5jIHJlZmxlY3RNdXRhdGlvbihfZXZlbnQ6IEN1c3RvbUV2ZW50LCBfc291cmNlOiBOb2RlLCBfZGVzdGluYXRpb246IE5vZGUsIF9wYXRoOiBOb2RlW10pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBfcGF0aCkgLy8gaXRlcmF0ZSB1cCB0aGUgZXZlbnQgcGF0aCwgd2hpY2ggbWF5IGNvbnRhaW4gcmVndWxhciBOb2RlcyBvciBHcmFwaEluc3RhbmNlc1xyXG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgR3JhcGhJbnN0YW5jZSkgLy8gdW50aWwgdGhpcyBHcmFwaEluc3RhbmNlIGlzIGZvdW5kIChvciBubyBHcmFwaEluc3RhbmNlLi4uKVxyXG4gICAgICAgICAgaWYgKG5vZGUgPT0gdGhpcylcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJTeW5jIGFib3J0ZWQsIHRhcmdldCBhbHJlYWR5IHN5bmNlZFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgLy8gZmluZCB0aGUgY29ycmVzcG9uZGluZyBub2RlIGluIHRoZSBkZXN0aW5hdGlvbiBoaWVyYXJjaHlcclxuICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSBfcGF0aC5pbmRleE9mKF9zb3VyY2UpO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSBpbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgbGV0IGNoaWxkSW5kZXg6IG51bWJlciA9IF9wYXRoW2ldLmdldFBhcmVudCgpLmZpbmRDaGlsZChfcGF0aFtpXSk7IC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIGNoaWxkbm9kZSBpbiB0aGUgb3JpZ2luYWwgcGF0aFxyXG4gICAgICAgIF9kZXN0aW5hdGlvbiA9IF9kZXN0aW5hdGlvbi5nZXRDaGlsZChjaGlsZEluZGV4KTsgLy8gZ2V0IHRoZSBjb3JyZXNwb25kaW5nIGNoaWxkIGluIHRoaXMgcGF0aFxyXG4gICAgICAgIC8vIFRPRE86IHJlc3BlY3QgaW5kZXggZm9yIG5vbi1zaW5nbGV0b24gY29tcG9uZW50cy4uLlxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBtdXRhdGUgdGhlIGNvcnJlc3BvbmRpbmcgY29tcG9uZW50IGluIHRoZSBkZXN0aW5hdGlvblxyXG4gICAgICBsZXQgY21wTXV0YXRlOiBDb21wb25lbnQgPSBfZGVzdGluYXRpb24uZ2V0Q29tcG9uZW50KF9ldmVudC5kZXRhaWwuY29tcG9uZW50LmNvbnN0cnVjdG9yKTtcclxuICAgICAgaWYgKGNtcE11dGF0ZSlcclxuICAgICAgICBhd2FpdCBjbXBNdXRhdGUubXV0YXRlKF9ldmVudC5kZXRhaWwubXV0YXRvciwgbnVsbCwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaXNGaWx0ZXJlZCgpOiBib29sZWFuIHtcclxuICAgICAgbGV0IGNtcEZpbHRlcjogQ29tcG9uZW50R3JhcGhGaWx0ZXIgPSB0aGlzLmdldENvbXBvbmVudChDb21wb25lbnRHcmFwaEZpbHRlcik7XHJcbiAgICAgIHJldHVybiAoY21wRmlsdGVyICYmIGNtcEZpbHRlci5pc0FjdGl2ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogSG9sZHMgZGF0YSB0byBmZWVkIGludG8gYSB7QGxpbmsgU2hhZGVyfSB0byBkZXNjcmliZSB0aGUgc3VyZmFjZSBvZiB7QGxpbmsgTWVzaH0uICBcclxuICAgKiB7QGxpbmsgTWF0ZXJpYWx9cyByZWZlcmVuY2Uge0BsaW5rIENvYXR9IGFuZCB7QGxpbmsgU2hhZGVyfS4gICBcclxuICAgKiBUaGUgbWV0aG9kIHVzZVJlbmRlckRhdGEgd2lsbCBiZSBpbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3J9IGF0IHJ1bnRpbWUsIGV4dGVuZGluZyB0aGUgZnVuY3Rpb25hbGl0eSBvZiB0aGlzIGNsYXNzIHRvIGRlYWwgd2l0aCB0aGUgcmVuZGVyZXIuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvYXQgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlIHsgLy8gVE9ETzogcmVmYWN0b3IgaW50byBjb21wb3NpdGlvbiBiYXNlZCBzdHJ1Y3R1cmVcclxuICAgIC8vIHB1YmxpYyBuYW1lOiBzdHJpbmcgPSBcIkNvYXRcIjtcclxuICAgIC8qKlxyXG4gICAgICogQ2xpcHBpbmcgdGhyZXNob2xkIGZvciBhbHBoYSB2YWx1ZXMsIGV2ZXJ5IHBpeGVsIHdpdGggYWxwaGEgPCBhbHBoYUNsaXAgd2lsbCBiZSBkaXNjYXJkZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhbHBoYUNsaXA6IG51bWJlciA9IDAuMDE7XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCByZXJvdXRlIHRvIHtAbGluayBSZW5kZXJNYW5hZ2VyQ29hdC5yZXNldFJlbmRlckRhdGF9ICovXHJcbiAgICBAUmVuZGVyTWFuYWdlckNvYXQuZGVjb3JhdGVcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVzZXRSZW5kZXJEYXRhKCk6IHZvaWQgeyAvKiBpbmplY3RlZCAqLyB9O1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgcmVyb3V0ZSB0byB7QGxpbmsgUmVuZGVyTWFuYWdlckNvYXQudXBkYXRlUmVuZGVyYnVmZmVyfSAqL1xyXG4gICAgQFJlbmRlck1hbmFnZXJDb2F0LmRlY29yYXRlXHJcbiAgICBwdWJsaWMgc3RhdGljIHVwZGF0ZVJlbmRlcmJ1ZmZlcigpOiB2b2lkIHsgLyogaW5qZWN0ZWQgKi8gfTtcclxuXHJcbiAgICAvKiogQGludGVybmFsIHJlcm91dGUgdG8ge0BsaW5rIFJlbmRlck1hbmFnZXJDb2F0LnVwZGF0ZVJlbmRlckRhdGF9ICovXHJcbiAgICBAUmVuZGVyTWFuYWdlckNvYXQuZGVjb3JhdGVcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgdXBkYXRlUmVuZGVyRGF0YShfY29hdDogQ29hdCk6IHZvaWQgeyAvKiBpbmplY3RlZCAqLyB9O1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgcmVyb3V0ZSB0byB7QGxpbmsgUmVuZGVyTWFuYWdlckNvYXQudXNlUmVuZGVyRGF0YX0gKi9cclxuICAgIEBSZW5kZXJNYW5hZ2VyQ29hdC5kZWNvcmF0ZVxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyB1c2VSZW5kZXJEYXRhKF9jb2F0OiBDb2F0KTogdm9pZCB7IC8qIGluamVjdGVkICovIH07XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCByZXJvdXRlIHRvIHtAbGluayBSZW5kZXJNYW5hZ2VyQ29hdC51cGRhdGVSZW5kZXJEYXRhfSAqL1xyXG4gICAgcHVibGljIHVwZGF0ZVJlbmRlckRhdGEoKTogdm9pZCB7IENvYXQudXBkYXRlUmVuZGVyRGF0YSh0aGlzKTsgfTtcclxuXHJcbiAgICAvKiogQGludGVybmFsIHJlcm91dGUgdG8ge0BsaW5rIFJlbmRlck1hbmFnZXJDb2F0LnVzZVJlbmRlckRhdGF9ICovXHJcbiAgICBwdWJsaWMgdXNlUmVuZGVyRGF0YSgpOiB2b2lkIHsgQ29hdC51c2VSZW5kZXJEYXRhKHRoaXMpOyB9O1xyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBhbHBoYUNsaXA6IHRoaXMuYWxwaGFDbGlwXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBpZiAoX3NlcmlhbGl6YXRpb24uYWxwaGFDbGlwICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy5hbHBoYUNsaXAgPSBfc2VyaWFsaXphdGlvbi5hbHBoYUNsaXA7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5yZW5kZXJEYXRhO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogVGhlIHNpbXBsZXN0IHtAbGluayBDb2F0fSBwcm92aWRpbmcganVzdCBhIGNvbG9yXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvYXRDb2xvcmVkIGV4dGVuZHMgQ29hdCB7XHJcbiAgICBwdWJsaWMgY29sb3I6IENvbG9yO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKCkpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5jb2xvciA9IF9jb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uY29sb3IgPSB0aGlzLmNvbG9yLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgYXdhaXQgdGhpcy5jb2xvci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5jb2xvcik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQSB7QGxpbmsgQ29hdH0gcHJvdmlkaW5nIGEgY29sb3IgYW5kIHBhcmFtZXRlcnMgZm9yIHRoZSBwaG9uZyBzaGFkaW5nIG1vZGVsLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb2F0UmVtaXNzaXZlIGV4dGVuZHMgQ29hdENvbG9yZWQge1xyXG4gICAgcHVibGljIGRpZmZ1c2U6IG51bWJlcjtcclxuICAgIHB1YmxpYyBzcGVjdWxhcjogbnVtYmVyO1xyXG4gICAgcHVibGljIGludGVuc2l0eTogbnVtYmVyO1xyXG5cclxuICAgICNtZXRhbGxpYzogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKCksIF9kaWZmdXNlOiBudW1iZXIgPSAxLCBfc3BlY3VsYXI6IG51bWJlciA9IDAuNSwgX2ludGVuc2l0eTogbnVtYmVyID0gMC43LCBfbWV0YWxsaWM6IG51bWJlciA9IDAuMCkge1xyXG4gICAgICBzdXBlcihfY29sb3IpO1xyXG4gICAgICB0aGlzLmRpZmZ1c2UgPSBfZGlmZnVzZTtcclxuICAgICAgdGhpcy5zcGVjdWxhciA9IF9zcGVjdWxhcjtcclxuICAgICAgdGhpcy5pbnRlbnNpdHkgPSBfaW50ZW5zaXR5O1xyXG4gICAgICB0aGlzLm1ldGFsbGljID0gX21ldGFsbGljO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgbWV0YWxsaWMoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21ldGFsbGljO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBtZXRhbGxpYyhfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtZXRhbGxpYyA9IENhbGMuY2xhbXAoX3ZhbHVlLCAwLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uZGlmZnVzZSA9IHRoaXMuZGlmZnVzZTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXI7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24ubWV0YWxsaWMgPSB0aGlzLm1ldGFsbGljO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHRoaXMuZGlmZnVzZSA9IF9zZXJpYWxpemF0aW9uLmRpZmZ1c2U7XHJcbiAgICAgIHRoaXMuc3BlY3VsYXIgPSBfc2VyaWFsaXphdGlvbi5zcGVjdWxhcjtcclxuICAgICAgdGhpcy5pbnRlbnNpdHkgPSBfc2VyaWFsaXphdGlvbi5pbnRlbnNpdHkgPz8gdGhpcy5pbnRlbnNpdHk7XHJcbiAgICAgIHRoaXMubWV0YWxsaWMgPSBfc2VyaWFsaXphdGlvbi5tZXRhbGxpYyA/PyB0aGlzLm1ldGFsbGljO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKHRydWUpO1xyXG4gICAgICBkZWxldGUgbXV0YXRvci5kaWZmdXNlO1xyXG4gICAgICBkZWxldGUgbXV0YXRvci5zcGVjdWxhcjtcclxuICAgICAgZGVsZXRlIG11dGF0b3IuaW50ZW5zaXR5O1xyXG4gICAgICBtdXRhdG9yLmRpZmZ1c2UgPSB0aGlzLmRpZmZ1c2U7XHJcbiAgICAgIG11dGF0b3Iuc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyO1xyXG4gICAgICBtdXRhdG9yLmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xyXG4gICAgICBtdXRhdG9yLm1ldGFsbGljID0gdGhpcy5tZXRhbGxpYztcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIHtAbGluayBDb2F0fSBwcm92aWRpbmcgYSB0ZXh0dXJlIGFuZCBhZGRpdGlvbmFsIGRhdGEgZm9yIHRleHR1cmluZ1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb2F0VGV4dHVyZWQgZXh0ZW5kcyBDb2F0Q29sb3JlZCB7XHJcblxyXG4gICAgQHR5cGUoVGV4dHVyZSlcclxuICAgIHB1YmxpYyB0ZXh0dXJlOiBUZXh0dXJlO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKCksIF90ZXh0dXJlOiBUZXh0dXJlID0gVGV4dHVyZURlZmF1bHQuY29sb3IpIHtcclxuICAgICAgc3VwZXIoX2NvbG9yKTtcclxuICAgICAgdGhpcy50ZXh0dXJlID0gX3RleHR1cmU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmlkVGV4dHVyZSA9IHRoaXMudGV4dHVyZS5pZFJlc291cmNlO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkVGV4dHVyZSlcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSA8VGV4dHVyZT5hd2FpdCBQcm9qZWN0LmdldFJlc291cmNlKF9zZXJpYWxpemF0aW9uLmlkVGV4dHVyZSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiQ29hdFRleHR1cmVkLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQSB7QGxpbmsgQ29hdH0gcHJvdmlkaW5nIGEgdGV4dHVyZSBhbmQgYWRkaXRpb25hbCBkYXRhIGZvciB0ZXh0dXJpbmdcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29hdFJlbWlzc2l2ZVRleHR1cmVkIGV4dGVuZHMgQ29hdFRleHR1cmVkIHtcclxuICAgIHB1YmxpYyBkaWZmdXNlOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgc3BlY3VsYXI6IG51bWJlcjtcclxuICAgIHB1YmxpYyBpbnRlbnNpdHk6IG51bWJlcjtcclxuXHJcbiAgICAjbWV0YWxsaWM6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigpLCBfdGV4dHVyZTogVGV4dHVyZSA9IFRleHR1cmVEZWZhdWx0LmNvbG9yLCBfZGlmZnVzZTogbnVtYmVyID0gMSwgX3NwZWN1bGFyOiBudW1iZXIgPSAwLjUsIF9pbnRlbnNpdHk6IG51bWJlciA9IDAuNywgX21ldGFsbGljOiBudW1iZXIgPSAwLjApIHtcclxuICAgICAgc3VwZXIoX2NvbG9yLCBfdGV4dHVyZSk7XHJcbiAgICAgIHRoaXMuZGlmZnVzZSA9IF9kaWZmdXNlO1xyXG4gICAgICB0aGlzLnNwZWN1bGFyID0gX3NwZWN1bGFyO1xyXG4gICAgICB0aGlzLmludGVuc2l0eSA9IF9pbnRlbnNpdHk7XHJcbiAgICAgIHRoaXMubWV0YWxsaWMgPSBfbWV0YWxsaWM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBtZXRhbGxpYygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWV0YWxsaWM7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1ldGFsbGljKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21ldGFsbGljID0gQ2FsYy5jbGFtcChfdmFsdWUsIDAsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5kaWZmdXNlID0gdGhpcy5kaWZmdXNlO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnNwZWN1bGFyID0gdGhpcy5zcGVjdWxhcjtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5tZXRhbGxpYyA9IHRoaXMubWV0YWxsaWM7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB0aGlzLmRpZmZ1c2UgPSBfc2VyaWFsaXphdGlvbi5kaWZmdXNlO1xyXG4gICAgICB0aGlzLnNwZWN1bGFyID0gX3NlcmlhbGl6YXRpb24uc3BlY3VsYXI7XHJcbiAgICAgIHRoaXMuaW50ZW5zaXR5ID0gX3NlcmlhbGl6YXRpb24uaW50ZW5zaXR5ID8/IHRoaXMuaW50ZW5zaXR5O1xyXG4gICAgICB0aGlzLm1ldGFsbGljID0gX3NlcmlhbGl6YXRpb24ubWV0YWxsaWMgPz8gdGhpcy5tZXRhbGxpYztcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcih0cnVlKTtcclxuICAgICAgZGVsZXRlIG11dGF0b3IuZGlmZnVzZTtcclxuICAgICAgZGVsZXRlIG11dGF0b3Iuc3BlY3VsYXI7XHJcbiAgICAgIGRlbGV0ZSBtdXRhdG9yLmludGVuc2l0eTtcclxuICAgICAgbXV0YXRvci5kaWZmdXNlID0gdGhpcy5kaWZmdXNlO1xyXG4gICAgICBtdXRhdG9yLnNwZWN1bGFyID0gdGhpcy5zcGVjdWxhcjtcclxuICAgICAgbXV0YXRvci5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcclxuICAgICAgbXV0YXRvci5tZXRhbGxpYyA9IHRoaXMubWV0YWxsaWM7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiQ29hdFRleHR1cmVkLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQSB7QGxpbmsgQ29hdH0gcHJvdmlkaW5nIGEgdGV4dHVyZSBhbmQgYWRkaXRpb25hbCBkYXRhIGZvciB0ZXh0dXJpbmdcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29hdFJlbWlzc2l2ZVRleHR1cmVkTm9ybWFscyBleHRlbmRzIENvYXRSZW1pc3NpdmVUZXh0dXJlZCB7XHJcblxyXG4gICAgQHR5cGUoVGV4dHVyZSlcclxuICAgIHB1YmxpYyBub3JtYWxNYXA6IFRleHR1cmU7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoKSwgX3RleHR1cmU6IFRleHR1cmUgPSBUZXh0dXJlRGVmYXVsdC5jb2xvciwgX25vcm1hbE1hcDogVGV4dHVyZSA9IFRleHR1cmVEZWZhdWx0Lm5vcm1hbCwgX2RpZmZ1c2U/OiBudW1iZXIsIF9zcGVjdWxhcjogbnVtYmVyID0gdW5kZWZpbmVkLCBfaW50ZW5zaXR5OiBudW1iZXIgPSB1bmRlZmluZWQsIF9tZXRhbGxpYzogbnVtYmVyID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHN1cGVyKF9jb2xvciwgX3RleHR1cmUsIF9kaWZmdXNlLCBfc3BlY3VsYXIsIF9pbnRlbnNpdHksIF9tZXRhbGxpYyk7XHJcbiAgICAgIHRoaXMubm9ybWFsTWFwID0gX25vcm1hbE1hcDtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaWROb3JtYWxNYXAgPSB0aGlzLm5vcm1hbE1hcC5pZFJlc291cmNlO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkTm9ybWFsTWFwKVxyXG4gICAgICAgIHRoaXMubm9ybWFsTWFwID0gPFRleHR1cmU+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZE5vcm1hbE1hcCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEEge0BsaW5rIENvYXR9IHByb3ZpZGluZyBhIGNvbG9yIGFuZCBwYXJhbWV0ZXJzIGZvciB0aGUgdG9vbiBzaGFkaW5nIG1vZGVsLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb2F0VG9vbiBleHRlbmRzIG1peGluQ29hdFRvb24oQ29hdFJlbWlzc2l2ZSkge1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoKSwgX3RleFRvb246IFRleHR1cmUgPSBUZXh0dXJlRGVmYXVsdC50b29uLCBfZGlmZnVzZT86IG51bWJlciwgX3NwZWN1bGFyOiBudW1iZXIgPSAxLjIsIF9pbnRlbnNpdHk/OiBudW1iZXIsIF9tZXRhbGxpYz86IG51bWJlcikge1xyXG4gICAgICBzdXBlcihfY29sb3IsIF9kaWZmdXNlLCBfc3BlY3VsYXIsIF9pbnRlbnNpdHksIF9tZXRhbGxpYyk7XHJcbiAgICAgIHRoaXMudGV4VG9vbiA9IF90ZXhUb29uO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSB7QGxpbmsgQ29hdH0gcHJvdmlkaW5nIGEgdGV4dHVyZSwgYSBjb2xvciBhbmQgcGFyYW1ldGVycyBmb3IgdGhlIHRvb24gc2hhZGluZyBtb2RlbC5cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29hdFRvb25UZXh0dXJlZCBleHRlbmRzIG1peGluQ29hdFRvb24oQ29hdFJlbWlzc2l2ZVRleHR1cmVkKSB7XHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigpLCBfdGV4dHVyZTogVGV4dHVyZSA9IFRleHR1cmVEZWZhdWx0LmNvbG9yLCBfdGV4VG9vbjogVGV4dHVyZSA9IFRleHR1cmVEZWZhdWx0LnRvb24sIF9kaWZmdXNlPzogbnVtYmVyLCBfc3BlY3VsYXI6IG51bWJlciA9IDEuMiwgX2ludGVuc2l0eT86IG51bWJlciwgX21ldGFsbGljPzogbnVtYmVyKSB7XHJcbiAgICAgIHN1cGVyKF9jb2xvciwgX3RleHR1cmUsIF9kaWZmdXNlLCBfc3BlY3VsYXIsIF9pbnRlbnNpdHksIF9tZXRhbGxpYyk7XHJcbiAgICAgIHRoaXMudGV4VG9vbiA9IF90ZXhUb29uO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWl4aW5Db2F0VG9vbjxUQmFzZSBleHRlbmRzIG5ldyAoLi4uYXJnczogR2VuZXJhbFtdKSA9PiBTZXJpYWxpemFibGUgJiBNdXRhYmxlPihfYmFzZTogVEJhc2UpOiAoYWJzdHJhY3QgbmV3ICguLi5hcmdzOiBHZW5lcmFsW10pID0+IHsgdGV4VG9vbjogVGV4dHVyZSB9KSAmIFRCYXNlIHtcclxuICAgIGFic3RyYWN0IGNsYXNzIENvYXRUb29uIGV4dGVuZHMgX2Jhc2Uge1xyXG5cclxuICAgICAgQHR5cGUoVGV4dHVyZSlcclxuICAgICAgcHVibGljIHRleFRvb246IFRleHR1cmU7XHJcblxyXG4gICAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgICAgc2VyaWFsaXphdGlvbi5pZFRleFRvb24gPSB0aGlzLnRleFRvb24uaWRSZXNvdXJjZTtcclxuICAgICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkVGV4VG9vbilcclxuICAgICAgICAgIHRoaXMudGV4VG9vbiA9IDxUZXh0dXJlPmF3YWl0IFByb2plY3QuZ2V0UmVzb3VyY2UoX3NlcmlhbGl6YXRpb24uaWRUZXhUb29uKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBDb2F0VG9vbjtcclxuICB9XHJcbn1cclxuXHJcblxyXG5cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyBhIGNvbG9yIGFzIHZhbHVlcyBpbiB0aGUgcmFuZ2Ugb2YgMCB0byAxIGZvciB0aGUgZm91ciBjaGFubmVscyByZWQsIGdyZWVuLCBibHVlIGFuZCBhbHBoYSAoZm9yIG9wYWNpdHkpXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbG9yIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSwgUmVjeWNhYmxlIHtcclxuICAgIC8vIGNyYzIgb25seSB1c2VkIGZvciBjb252ZXJ0aW5nIGNvbG9ycyBmcm9tIHN0cmluZ3MgcHJlZGVmaW5lZCBieSBDU1NcclxuICAgIHByaXZhdGUgc3RhdGljIGNyYzI6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9ICgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNyYzI6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIsIHsgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlIH0pO1xyXG4gICAgICBjcmMyLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiY29weVwiO1xyXG4gICAgICByZXR1cm4gY3JjMjtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgcHVibGljIHI6IG51bWJlcjtcclxuICAgIHB1YmxpYyBnOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYjogbnVtYmVyO1xyXG4gICAgcHVibGljIGE6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3I6IG51bWJlciA9IDEsIF9nOiBudW1iZXIgPSAxLCBfYjogbnVtYmVyID0gMSwgX2E6IG51bWJlciA9IDEpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zZXRDbGFtcGVkKF9yLCBfZywgX2IsIF9hKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgVWludDhDbGFtcGVkQXJyYXl9IHdpdGggdGhlIDgtYml0IGNvbG9yIGNoYW5uZWxzIGluIHRoZSBvcmRlciBSR0JBLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEJ5dGVzRnJvbUNTUyhfa2V5d29yZDogc3RyaW5nKTogVWludDhDbGFtcGVkQXJyYXkge1xyXG4gICAgICBDb2xvci5jcmMyLmZpbGxTdHlsZSA9IF9rZXl3b3JkO1xyXG4gICAgICBDb2xvci5jcmMyLmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xyXG4gICAgICByZXR1cm4gQ29sb3IuY3JjMi5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcge0BsaW5rIENvbG9yfSBvYmplY3QgY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBjc3MgY29sb3Iga2V5d29yZC4gXHJcbiAgICAgKiBQYXNzaW5nIGFuIF9hbHBoYSB2YWx1ZSB3aWxsIG92ZXJyaWRlIHRoZSBhbHBoYSB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhlIGtleXdvcmQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQ1NTKF9rZXl3b3JkOiBzdHJpbmcsIF9hbHBoYT86IG51bWJlcik6IENvbG9yIHtcclxuICAgICAgcmV0dXJuIFJlY3ljbGVyLmdldChDb2xvcikuc2V0Q1NTKF9rZXl3b3JkLCBfYWxwaGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHJ1bnMgdGhlIHByb2R1Y3Qgb2YgdHdvIGNvbG9ycy4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUFJPRFVDVChfY2xyQTogQ29sb3IsIF9jbHJCOiBDb2xvcik6IENvbG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0cnVucyB0aGUgcHJvZHVjdCBvZiBhIGNvbG9yIHdpdGggYSBzY2FsYXIgdmFsdWUuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFBST0RVQ1QoX2NvbG9yOiBDb2xvciwgX3NjYWxhcjogbnVtYmVyKTogQ29sb3I7XHJcbiAgICBwdWJsaWMgc3RhdGljIFBST0RVQ1QoX211bHRpcGxpY2FudDogQ29sb3IsIF9tdWx0aXBsaWVyOiBDb2xvciB8IG51bWJlcik6IENvbG9yIHtcclxuICAgICAgcmV0dXJuIF9tdWx0aXBsaWNhbnQuY2xvbmUubXVsdGlwbHkoPEdlbmVyYWw+X211bHRpcGxpZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGNsb25lIG9mIHRoaXMgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY2xvbmUoKTogQ29sb3Ige1xyXG4gICAgICByZXR1cm4gUmVjeWNsZXIucmV1c2UoQ29sb3IpLmNvcHkodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIHRoZSBnaXZlbiBjb2xvciBpbnRvIHRoaXMgY29sb3IgYW5kIHJldHVybnMgaXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb3B5KF9jb2xvcjogQ29sb3IpOiBDb2xvciB7XHJcbiAgICAgIHRoaXMuciA9IF9jb2xvci5yO1xyXG4gICAgICB0aGlzLmcgPSBfY29sb3IuZztcclxuICAgICAgdGhpcy5iID0gX2NvbG9yLmI7XHJcbiAgICAgIHRoaXMuYSA9IF9jb2xvci5hO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5yID0gMTsgdGhpcy5nID0gMTsgdGhpcy5iID0gMTsgdGhpcy5hID0gMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhpcyBjb2xvciBmcm9tIHRoZSBnaXZlbiBjc3MgY29sb3Iga2V5d29yZC4gT3B0aW5hbGx5IHNldHMgdGhlIGFscGhhIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldENTUyhfa2V5d29yZDogc3RyaW5nLCBfYWxwaGE/OiBudW1iZXIpOiBDb2xvciB7XHJcbiAgICAgIGNvbnN0IGJ5dGVzUkdCQTogVWludDhDbGFtcGVkQXJyYXkgPSBDb2xvci5nZXRCeXRlc0Zyb21DU1MoX2tleXdvcmQpO1xyXG4gICAgICB0aGlzLnNldEJ5dGVzKGJ5dGVzUkdCQVswXSwgYnl0ZXNSR0JBWzFdLCBieXRlc1JHQkFbMl0sIGJ5dGVzUkdCQVszXSk7XHJcbiAgICAgIHRoaXMuYSA9IF9hbHBoYSA/PyB0aGlzLmE7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGlzIGNvbG9yIGZyb20gdGhlIGdpdmVuIDgtYml0IHZhbHVlcyBmb3IgdGhlIGNvbG9yIGNoYW5uZWxzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0Qnl0ZXMoX3I6IG51bWJlciwgX2c6IG51bWJlciwgX2I6IG51bWJlciwgX2E6IG51bWJlcik6IENvbG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoaXMgY29sb3IgZnJvbSB0aGUgZ2l2ZW4ge0BsaW5rIFVpbnQ4Q2xhbXBlZEFycmF5fS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEJ5dGVzKF9yZ2JhOiBVaW50OENsYW1wZWRBcnJheSk6IENvbG9yO1xyXG4gICAgcHVibGljIHNldEJ5dGVzKF9yOiBudW1iZXIgfCBVaW50OENsYW1wZWRBcnJheSwgX2c/OiBudW1iZXIsIF9iPzogbnVtYmVyLCBfYT86IG51bWJlcik6IENvbG9yIHtcclxuICAgICAgaWYgKF9yIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpXHJcbiAgICAgICAgdGhpcy5zZXRCeXRlcyhfclswXSwgX3JbMV0sIF9yWzJdLCBfclszXSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLnNldENsYW1wZWQoX3IgLyAyNTUsIF9nIC8gMjU1LCBfYiAvIDI1NSwgX2EgLyAyNTUpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIHRoaXMgY29sb3IgYW5kIGNsYW1wcyB0aGVtIGJldHdlZW4gMCBhbmQgMS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldENsYW1wZWQoX3I6IG51bWJlciwgX2c6IG51bWJlciwgX2I6IG51bWJlciwgX2E6IG51bWJlcik6IENvbG9yO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoaXMgY29sb3IgZnJvbSB0aGUgZ2l2ZW4ge0BsaW5rIEZsb2F0MzJBcnJheX0gd2hpbGUgY2xhbXBpbmcgdGhlIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRDbGFtcGVkKF9yZ2JhOiBGbG9hdDMyQXJyYXkpOiBDb2xvcjtcclxuICAgIHB1YmxpYyBzZXRDbGFtcGVkKF9yOiBudW1iZXIgfCBGbG9hdDMyQXJyYXksIF9nPzogbnVtYmVyLCBfYj86IG51bWJlciwgX2E/OiBudW1iZXIpOiBDb2xvciB7XHJcbiAgICAgIGlmIChfciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSlcclxuICAgICAgICB0aGlzLnNldENsYW1wZWQoX3JbMF0sIF9yWzFdLCBfclsyXSwgX3JbM10pO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5zZXQoXHJcbiAgICAgICAgICBDYWxjLmNsYW1wKF9yLCAwLCAxKSxcclxuICAgICAgICAgIENhbGMuY2xhbXAoX2csIDAsIDEpLFxyXG4gICAgICAgICAgQ2FsYy5jbGFtcChfYiwgMCwgMSksXHJcbiAgICAgICAgICBDYWxjLmNsYW1wKF9hLCAwLCAxKVxyXG4gICAgICAgICk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgdGhpcyBjb2xvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldChfcjogbnVtYmVyLCBfZzogbnVtYmVyLCBfYjogbnVtYmVyLCBfYTogbnVtYmVyKTogQ29sb3Ige1xyXG4gICAgICB0aGlzLnIgPSBfcjsgdGhpcy5nID0gX2c7IHRoaXMuYiA9IF9iOyB0aGlzLmEgPSBfYTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjb2xvciBjaGFubmVscyBvZiB0aGlzIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0KCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFt0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmFdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgVWludDhDbGFtcGVkQXJyYXl9IG9mIHRoZSBjb2xvciBjaGFubmVscyBvZiB0aGlzIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Qnl0ZXMoKTogVWludDhDbGFtcGVkQXJyYXkge1xyXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KFt0aGlzLnIgKiAyNTUsIHRoaXMuZyAqIDI1NSwgdGhpcy5iICogMjU1LCB0aGlzLmEgKiAyNTVdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNzcyBjb2xvciBrZXl3b3JkIHJlcHJlc2VudGluZyB0aGlzIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q1NTKCk6IHN0cmluZyB7XHJcbiAgICAgIGxldCBieXRlczogVWludDhDbGFtcGVkQXJyYXkgPSB0aGlzLmdldEJ5dGVzKCk7XHJcbiAgICAgIHJldHVybiBgUkdCQSgke2J5dGVzWzBdfSwgJHtieXRlc1sxXX0sICR7Ynl0ZXNbMl19LCAke3RoaXMuYX0pYDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGhleCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb2xvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEhleCgpOiBzdHJpbmcge1xyXG4gICAgICBsZXQgYnl0ZXM6IFVpbnQ4Q2xhbXBlZEFycmF5ID0gdGhpcy5nZXRCeXRlcygpO1xyXG4gICAgICBsZXQgaGV4OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICBmb3IgKGxldCBieXRlIG9mIGJ5dGVzKVxyXG4gICAgICAgIGhleCArPSBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XHJcbiAgICAgIHJldHVybiBoZXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoaXMgY29sb3IgZnJvbSB0aGUgZ2l2ZW4gaGV4IHN0cmluZyBjb2xvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEhleChfaGV4OiBzdHJpbmcpOiBDb2xvciB7XHJcbiAgICAgIGxldCBieXRlczogVWludDhDbGFtcGVkQXJyYXkgPSB0aGlzLmdldEJ5dGVzKCk7XHJcbiAgICAgIGxldCBjaGFubmVsOiBudW1iZXIgPSAwO1xyXG4gICAgICBmb3IgKGxldCBieXRlIGluIGJ5dGVzKVxyXG4gICAgICAgIGJ5dGVzW2J5dGVdID0gcGFyc2VJbnQoX2hleC5zdWJzdHIoY2hhbm5lbCsrICogMiwgMiksIDE2KTtcclxuICAgICAgcmV0dXJuIHRoaXMuc2V0Qnl0ZXMoYnl0ZXMpOztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGdpdmVuIGNvbG9yIHRvIHRoaXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGQoX2NvbG9yOiBDb2xvcik6IENvbG9yIHtcclxuICAgICAgdGhpcy5yICs9IF9jb2xvci5yO1xyXG4gICAgICB0aGlzLmcgKz0gX2NvbG9yLmc7XHJcbiAgICAgIHRoaXMuYiArPSBfY29sb3IuYjtcclxuICAgICAgdGhpcy5hICs9IF9jb2xvci5hO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGxpZXMgdGhpcyB3aXRoIHRoZSBnaXZlbiBjb2xvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG11bHRpcGx5KF9jb2xvcjogQ29sb3IpOiBDb2xvcjtcclxuICAgIC8qKlxyXG4gICAgICogTXVsdGlwbGllcyB0aGlzIHdpdGggdGhlIGdpdmVuIHNjYWxhci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG11bHRpcGx5KF9zY2FsYXI6IG51bWJlcik6IENvbG9yO1xyXG4gICAgcHVibGljIG11bHRpcGx5KF9tdWx0aXBsaWVyOiBDb2xvciB8IG51bWJlcik6IENvbG9yIHtcclxuICAgICAgaWYgKF9tdWx0aXBsaWVyIGluc3RhbmNlb2YgQ29sb3IpIHtcclxuICAgICAgICB0aGlzLnIgKj0gX211bHRpcGxpZXIucjtcclxuICAgICAgICB0aGlzLmcgKj0gX211bHRpcGxpZXIuZztcclxuICAgICAgICB0aGlzLmIgKj0gX211bHRpcGxpZXIuYjtcclxuICAgICAgICB0aGlzLmEgKj0gX211bHRpcGxpZXIuYTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnIgKj0gX211bHRpcGxpZXI7XHJcbiAgICAgICAgdGhpcy5nICo9IF9tdWx0aXBsaWVyO1xyXG4gICAgICAgIHRoaXMuYiAqPSBfbXVsdGlwbGllcjtcclxuICAgICAgICB0aGlzLmEgKj0gX211bHRpcGxpZXI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNoYW5uZWxzIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBjb2xvciBhcmUgdG8gYmUgY29uc2lkZXJlZCBpZGVudGljYWwgd2l0aGluIHRoZSBnaXZlbiB0b2xlcmFuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGVxdWFscyhfY29tcGFyZTogQ29sb3IsIF90b2xlcmFuY2U6IG51bWJlciA9IE51bWJlci5FUFNJTE9OKTogYm9vbGVhbiB7XHJcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnIgLSBfY29tcGFyZS5yKSA+IF90b2xlcmFuY2UpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMuZyAtIF9jb21wYXJlLmcpID4gX3RvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy5iIC0gX2NvbXBhcmUuYikgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLmEgLSBfY29tcGFyZS5hKSA+IF90b2xlcmFuY2UpIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYChyOiAke3RoaXMuci50b0ZpeGVkKDMpfSwgZzogJHt0aGlzLmcudG9GaXhlZCgzKX0sIGI6ICR7dGhpcy5iLnRvRml4ZWQoMyl9LCBhOiAke3RoaXMuYS50b0ZpeGVkKDMpfSlgO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB0aGlzLmdldE11dGF0b3IodHJ1ZSk7XHJcbiAgICAgIC8vIHNlcmlhbGl6YXRpb24udG9KU09OID0gKCkgPT4geyByZXR1cm4gYHsgXCJyXCI6ICR7dGhpcy5yfSwgXCJnXCI6ICR7dGhpcy5nfSwgXCJiXCI6ICR7dGhpcy5ifSwgXCJhXCI6ICR7dGhpcy5hfX1gOyB9O1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnRvSlNPTiA9ICgpID0+IHsgcmV0dXJuIGBbJHt0aGlzLnJ9LCAke3RoaXMuZ30sICR7dGhpcy5ifSwgJHt0aGlzLmF9XWA7IH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9zZXJpYWxpemF0aW9uKSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgW3RoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYV0gPSBKU09OLnBhcnNlKDxzdHJpbmc+PHVua25vd24+X3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB9IGVsc2VcclxuICAgICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQSB7QGxpbmsgTWF0ZXJpYWx9IGxvYWRlZCBmcm9tIGEgZ2xURi1GaWxlLlxyXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNYXRlcmlhbEdMVEYgZXh0ZW5kcyBtaXhpblNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWwoTWF0ZXJpYWwpIHtcclxuICAgIHB1YmxpYyBhc3luYyBsb2FkKF91cmw6IFJlcXVlc3RJbmZvID0gdGhpcy51cmwsIF9uYW1lOiBzdHJpbmcgPSB0aGlzLm5hbWUpOiBQcm9taXNlPE1hdGVyaWFsR0xURj4ge1xyXG4gICAgICB0aGlzLnVybCA9IF91cmw7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICByZXR1cm4gR0xURkxvYWRlci5sb2FkUmVzb3VyY2UodGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3QgY2xhc3Mgc3VwcG9ydGluZyB2YXJpb3VzIGFyaXRobWV0aWNhbCBoZWxwZXIgZnVuY3Rpb25zXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIENhbGMge1xyXG4gICAgLyoqIGZhY3RvciBtdWx0aXBsaWVkIHdpdGggYW5nbGUgaW4gZGVncmVlcyB5aWVsZHMgdGhlIGFuZ2xlIGluIHJhZGlhbiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBkZWcycmFkOiBudW1iZXIgPSBNYXRoLlBJIC8gMTgwO1xyXG4gICAgLyoqIGZhY3RvciBtdWx0aXBsaWVkIHdpdGggYW5nbGUgaW4gcmFkaWFuIHlpZWxkcyB0aGUgYW5nbGUgaW4gZGVncmVlcyAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSByYWQyZGVnOiBudW1iZXIgPSAxIC8gQ2FsYy5kZWcycmFkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBvbmUgb2YgdGhlIHZhbHVlcyBwYXNzZWQgaW4sIGVpdGhlciBfdmFsdWUgaWYgd2l0aGluIF9taW4gYW5kIF9tYXggb3IgdGhlIGJvdW5kYXJ5IGJlaW5nIGV4Y2VlZGVkIGJ5IF92YWx1ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYW1wPFQ+KF92YWx1ZTogVCwgX21pbjogVCwgX21heDogVCwgX2lzU21hbGxlcjogKF92YWx1ZTE6IFQsIF92YWx1ZTI6IFQpID0+IGJvb2xlYW4gPSAoX3ZhbHVlMTogVCwgX3ZhbHVlMjogVCkgPT4geyByZXR1cm4gX3ZhbHVlMSA8IF92YWx1ZTI7IH0pOiBUIHtcclxuICAgICAgaWYgKF9pc1NtYWxsZXIoX3ZhbHVlLCBfbWluKSkgcmV0dXJuIF9taW47XHJcbiAgICAgIGlmIChfaXNTbWFsbGVyKF9tYXgsIF92YWx1ZSkpIHJldHVybiBfbWF4O1xyXG4gICAgICByZXR1cm4gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmFsdWVzIChfYSwgX2IpIGZvciB0aGUgZ2l2ZW4gaW50ZXJwb2xhdGlvbiBmYWN0b3IgKF9mKS4gZiBpcyBjbGFtcGVkIGJldHdlZW4gMCBhbmQgMS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBsZXJwKF9hOiBudW1iZXIsIF9iOiBudW1iZXIsIF9mOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gX2EgKyAoX2IgLSBfYSkgKiBDYWxjLmNsYW1wKF9mLCAwLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdW5kcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIG5lYXJlc3QgbXVsdGlwbGUgb2YgdGhlIGdpdmVuIGluY3JlbWVudCB1c2luZyB0aGUgZ2l2ZW4gcm91bmRpbmcgZnVuY3Rpb24uIFxyXG4gICAgICogRGVmYXVsdCByb3VuZGluZyBmdW5jdGlvbiBpcyB7QGxpbmsgTWF0aC5yb3VuZH0sIHVzZSB7QGxpbmsgTWF0aC5mbG9vcn0gb3Ige0BsaW5rIE1hdGguY2VpbH0gdG8gcm91bmQgZG93biBvciB1cC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzbmFwKF92YWx1ZTogbnVtYmVyLCBfaW5jcmVtZW50OiBudW1iZXIsIF9yb3VuZDogKF92YWx1ZTogbnVtYmVyKSA9PiBudW1iZXIgPSBNYXRoLnJvdW5kKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIF9yb3VuZChfdmFsdWUgLyBfaW5jcmVtZW50KSAqIF9pbmNyZW1lbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBCb3JkZXIge1xyXG4gICAgbGVmdDogbnVtYmVyO1xyXG4gICAgdG9wOiBudW1iZXI7XHJcbiAgICByaWdodDogbnVtYmVyO1xyXG4gICAgYm90dG9tOiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGcmFtaW5nIGRlc2NyaWJlcyBob3cgdG8gbWFwIGEgcmVjdGFuZ2xlIGludG8gYSBnaXZlbiBmcmFtZVxyXG4gICAqIGFuZCBob3cgcG9pbnRzIGluIHRoZSBmcmFtZSBjb3JyZXNwb25kIHRvIHBvaW50cyBpbiB0aGUgcmVzdWx0aW5nIHJlY3RhbmdsZSBhbmQgdmljZSB2ZXJzYVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5ICBcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vaHMtZnVydHdhbmdlbi9GVURHRS93aWtpL0ZyYW1pbmdcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgRnJhbWluZyBleHRlbmRzIE11dGFibGUge1xyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhIHBvaW50IGluIHRoZSBnaXZlbiBmcmFtZSBhY2NvcmRpbmcgdG8gdGhpcyBmcmFtaW5nXHJcbiAgICAgKiBAcGFyYW0gX3BvaW50SW5GcmFtZSBUaGUgcG9pbnQgaW4gdGhlIGZyYW1lIGdpdmVuXHJcbiAgICAgKiBAcGFyYW0gX3JlY3RGcmFtZSBUaGUgZnJhbWUgdGhlIHBvaW50IGlzIHJlbGF0aXZlIHRvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRQb2ludChfcG9pbnRJbkZyYW1lOiBWZWN0b3IyLCBfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBWZWN0b3IyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhIHBvaW50IGluIGEgZ2l2ZW4gcmVjdGFuZ2xlIGJhY2sgdG8gYSBjYWxjdWxhdGVkIGZyYW1lIG9mIG9yaWdpblxyXG4gICAgICogQHBhcmFtIF9wb2ludCBUaGUgcG9pbnQgaW4gdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIF9yZWN0IFRoZSByZWN0YW5nbGUgdGhlIHBvaW50IGlzIHJlbGF0aXZlIHRvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRQb2ludEludmVyc2UoX3BvaW50OiBWZWN0b3IyLCBfcmVjdDogUmVjdGFuZ2xlKTogVmVjdG9yMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGEgcmVjdGFuZ2xlIGFzIHRoZSBmcmFtZSBhbmQgY3JlYXRlcyBhIG5ldyByZWN0YW5nbGUgYWNjb3JkaW5nIHRvIHRoZSBmcmFtaW5nXHJcbiAgICAgKiBAcGFyYW0gX3JlY3RGcmFtZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0UmVjdChfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBSZWN0YW5nbGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgcmVzdWx0aW5nIHJlY3RhbmdsZSBoYXMgYSBmaXhlZCB3aWR0aCBhbmQgaGVpZ2h0IGFuZCBkaXNwbGF5IHNob3VsZCBzY2FsZSB0byBmaXQgdGhlIGZyYW1lXHJcbiAgICogUG9pbnRzIGFyZSBzY2FsZWQgaW4gdGhlIHNhbWUgcmF0aW9cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRnJhbWluZ0ZpeGVkIGV4dGVuZHMgRnJhbWluZyB7XHJcbiAgICBwdWJsaWMgd2lkdGg6IG51bWJlciA9IDMwMDtcclxuICAgIHB1YmxpYyBoZWlnaHQ6IG51bWJlciA9IDE1MDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3dpZHRoOiBudW1iZXIgPSAzMDAsIF9oZWlnaHQ6IG51bWJlciA9IDE1MCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNldFNpemUoX3dpZHRoLCBfaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhpcyBmcmFtaW5nIHRvIHRoZSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRTaXplKF93aWR0aDogbnVtYmVyLCBfaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy53aWR0aCA9IF93aWR0aDtcclxuICAgICAgdGhpcy5oZWlnaHQgPSBfaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQb2ludChfcG9pbnRJbkZyYW1lOiBWZWN0b3IyLCBfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIHRoaXMud2lkdGggKiAoX3BvaW50SW5GcmFtZS54IC0gX3JlY3RGcmFtZS54KSAvIF9yZWN0RnJhbWUud2lkdGgsXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgKiAoX3BvaW50SW5GcmFtZS55IC0gX3JlY3RGcmFtZS55KSAvIF9yZWN0RnJhbWUuaGVpZ2h0XHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBvaW50SW52ZXJzZShfcG9pbnQ6IFZlY3RvcjIsIF9yZWN0OiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIF9wb2ludC54ICogX3JlY3Qud2lkdGggLyB0aGlzLndpZHRoICsgX3JlY3QueCxcclxuICAgICAgICBfcG9pbnQueSAqIF9yZWN0LmhlaWdodCAvIHRoaXMuaGVpZ2h0ICsgX3JlY3QueVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRSZWN0KF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogV2lkdGggYW5kIGhlaWdodCBvZiB0aGUgcmVzdWx0aW5nIHJlY3RhbmdsZSBhcmUgZnJhY3Rpb25zIG9mIHRob3NlIG9mIHRoZSBmcmFtZSwgc2NhbGVkIGJ5IG5vcm1lZCB2YWx1ZXMgbm9ybVdpZHRoIGFuZCBub3JtSGVpZ2h0LlxyXG4gICAqIERpc3BsYXkgc2hvdWxkIHNjYWxlIHRvIGZpdCB0aGUgZnJhbWUgYW5kIHBvaW50cyBhcmUgc2NhbGVkIGluIHRoZSBzYW1lIHJhdGlvXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEZyYW1pbmdTY2FsZWQgZXh0ZW5kcyBGcmFtaW5nIHtcclxuICAgIHB1YmxpYyBub3JtV2lkdGg6IG51bWJlciA9IDEuMDtcclxuICAgIHB1YmxpYyBub3JtSGVpZ2h0OiBudW1iZXIgPSAxLjA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoaXMgZnJhbWluZyB0byB0aGUgZ2l2ZW4gbm9ybWVkIHdpZHRoIGFuZCBoZWlnaHRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNjYWxlKF9ub3JtV2lkdGg6IG51bWJlciwgX25vcm1IZWlnaHQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLm5vcm1XaWR0aCA9IF9ub3JtV2lkdGg7XHJcbiAgICAgIHRoaXMubm9ybUhlaWdodCA9IF9ub3JtSGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQb2ludChfcG9pbnRJbkZyYW1lOiBWZWN0b3IyLCBfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIHRoaXMubm9ybVdpZHRoICogKF9wb2ludEluRnJhbWUueCAtIF9yZWN0RnJhbWUueCksXHJcbiAgICAgICAgdGhpcy5ub3JtSGVpZ2h0ICogKF9wb2ludEluRnJhbWUueSAtIF9yZWN0RnJhbWUueSlcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UG9pbnRJbnZlcnNlKF9wb2ludDogVmVjdG9yMiwgX3JlY3Q6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgX3BvaW50LnggLyB0aGlzLm5vcm1XaWR0aCArIF9yZWN0LngsXHJcbiAgICAgICAgX3BvaW50LnkgLyB0aGlzLm5vcm1IZWlnaHQgKyBfcmVjdC55XHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFJlY3QoX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGhpcy5ub3JtV2lkdGggKiBfcmVjdEZyYW1lLndpZHRoLCB0aGlzLm5vcm1IZWlnaHQgKiBfcmVjdEZyYW1lLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgcmVzdWx0aW5nIHJlY3RhbmdsZSBmaXRzIGludG8gYSBtYXJnaW4gZ2l2ZW4gYXMgZnJhY3Rpb25zIG9mIHRoZSBzaXplIG9mIHRoZSBmcmFtZSBnaXZlbiBieSBub3JtQW5jaG9yXHJcbiAgICogcGx1cyBhbiBhYnNvbHV0ZSBwYWRkaW5nIGdpdmVuIGJ5IHBpeGVsQm9yZGVyLiBEaXNwbGF5IHNob3VsZCBmaXQgaW50byB0aGlzLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBGcmFtaW5nQ29tcGxleCBleHRlbmRzIEZyYW1pbmcge1xyXG4gICAgcHVibGljIG1hcmdpbjogQm9yZGVyID0geyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAgfTtcclxuICAgIHB1YmxpYyBwYWRkaW5nOiBCb3JkZXIgPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXRQb2ludChfcG9pbnRJbkZyYW1lOiBWZWN0b3IyLCBfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIF9wb2ludEluRnJhbWUueCAtIHRoaXMucGFkZGluZy5sZWZ0IC0gdGhpcy5tYXJnaW4ubGVmdCAqIF9yZWN0RnJhbWUud2lkdGgsXHJcbiAgICAgICAgX3BvaW50SW5GcmFtZS55IC0gdGhpcy5wYWRkaW5nLnRvcCAtIHRoaXMubWFyZ2luLnRvcCAqIF9yZWN0RnJhbWUuaGVpZ2h0XHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0UG9pbnRJbnZlcnNlKF9wb2ludDogVmVjdG9yMiwgX3JlY3Q6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgX3BvaW50LnggKyB0aGlzLnBhZGRpbmcubGVmdCArIHRoaXMubWFyZ2luLmxlZnQgKiBfcmVjdC53aWR0aCxcclxuICAgICAgICBfcG9pbnQueSArIHRoaXMucGFkZGluZy50b3AgKyB0aGlzLm1hcmdpbi50b3AgKiBfcmVjdC5oZWlnaHRcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UmVjdChfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBSZWN0YW5nbGUge1xyXG4gICAgICBpZiAoIV9yZWN0RnJhbWUpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICBsZXQgbWluWDogbnVtYmVyID0gX3JlY3RGcmFtZS54ICsgdGhpcy5tYXJnaW4ubGVmdCAqIF9yZWN0RnJhbWUud2lkdGggKyB0aGlzLnBhZGRpbmcubGVmdDtcclxuICAgICAgbGV0IG1pblk6IG51bWJlciA9IF9yZWN0RnJhbWUueSArIHRoaXMubWFyZ2luLnRvcCAqIF9yZWN0RnJhbWUuaGVpZ2h0ICsgdGhpcy5wYWRkaW5nLnRvcDtcclxuICAgICAgbGV0IG1heFg6IG51bWJlciA9IF9yZWN0RnJhbWUueCArICgxIC0gdGhpcy5tYXJnaW4ucmlnaHQpICogX3JlY3RGcmFtZS53aWR0aCAtIHRoaXMucGFkZGluZy5yaWdodDtcclxuICAgICAgbGV0IG1heFk6IG51bWJlciA9IF9yZWN0RnJhbWUueSArICgxIC0gdGhpcy5tYXJnaW4uYm90dG9tKSAqIF9yZWN0RnJhbWUuaGVpZ2h0IC0gdGhpcy5wYWRkaW5nLmJvdHRvbTtcclxuXHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKG1pblgsIG1pblksIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIHJldHVybiB7IG1hcmdpbjogdGhpcy5tYXJnaW4sIHBhZGRpbmc6IHRoaXMucGFkZGluZyB9O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yMiBhcyBwb2xhciBjb29yZGluYXRlcyBcclxuICAgKiBgYGB0ZXh0XHJcbiAgICogIOKGlS0gYW5nbGUgKEFuZ2xlIHRvIHRoZSB4LWF4aXMpXHJcbiAgICogIC3ihpIgTWFnbml0dWRlIChEaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIpICBcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgR2VvMiBpbXBsZW1lbnRzIFJlY3ljYWJsZSB7XHJcbiAgICBwdWJsaWMgbWFnbml0dWRlOiBudW1iZXIgPSAwO1xyXG4gICAgcHVibGljIGFuZ2xlOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYW5nbGU6IG51bWJlciA9IDAsIF9tYWduaXR1ZGU6IG51bWJlciA9IDEpIHtcclxuICAgICAgdGhpcy5zZXQoX2FuZ2xlLCBfbWFnbml0dWRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcHJvcGVydGllcyBvZiB0aGlzIGluc3RhbmNlIGF0IG9uY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldChfYW5nbGU6IG51bWJlciA9IDAsIF9tYWduaXR1ZGU6IG51bWJlciA9IDEpOiB2b2lkIHtcclxuICAgICAgdGhpcy5tYWduaXR1ZGUgPSBfbWFnbml0dWRlO1xyXG4gICAgICB0aGlzLmFuZ2xlID0gX2FuZ2xlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByZXR0eSBzdHJpbmcgcmVwcmVzZW50YXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgYW5nbGU6ICR7dGhpcy5hbmdsZS50b1ByZWNpc2lvbig1KX0sICBtYWduaXR1ZGU6ICR7dGhpcy5tYWduaXR1ZGUudG9QcmVjaXNpb24oNSl9YDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBSZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvcjMgYXMgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcyBhcyBzZWVuIG9uIGEgZ2xvYmVcclxuICAgKiBgYGB0ZXh0XHJcbiAgICog4oaQfOKGkiBMb25naXR1ZGUgKEFuZ2xlIHRvIHRoZSB6LWF4aXMpIFxyXG4gICAqICDihpUtIExhdGl0dWRlIChBbmdsZSB0byB0aGUgZXF1YXRvcilcclxuICAgKiAgLeKGkiBNYWduaXR1ZGUgKERpc3RhbmNlIGZyb20gdGhlIGNlbnRlcikgIFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBHZW8zIGltcGxlbWVudHMgUmVjeWNhYmxlIHtcclxuICAgIHB1YmxpYyBtYWduaXR1ZGU6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgbGF0aXR1ZGU6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgbG9uZ2l0dWRlOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbG9uZ2l0dWRlOiBudW1iZXIgPSAwLCBfbGF0aXR1ZGU6IG51bWJlciA9IDAsIF9tYWduaXR1ZGU6IG51bWJlciA9IDEpIHtcclxuICAgICAgdGhpcy5zZXQoX2xvbmdpdHVkZSwgX2xhdGl0dWRlLCBfbWFnbml0dWRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcHJvcGVydGllcyBvZiB0aGlzIGluc3RhbmNlIGF0IG9uY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldChfbG9uZ2l0dWRlOiBudW1iZXIgPSAwLCBfbGF0aXR1ZGU6IG51bWJlciA9IDAsIF9tYWduaXR1ZGU6IG51bWJlciA9IDEpOiB2b2lkIHtcclxuICAgICAgdGhpcy5tYWduaXR1ZGUgPSBfbWFnbml0dWRlO1xyXG4gICAgICB0aGlzLmxhdGl0dWRlID0gX2xhdGl0dWRlO1xyXG4gICAgICB0aGlzLmxvbmdpdHVkZSA9IF9sb25naXR1ZGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcHJldHR5IHN0cmluZyByZXByZXNlbnRhdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGBsb25naXR1ZGU6ICR7dGhpcy5sb25naXR1ZGUudG9QcmVjaXNpb24oNSl9LCBsYXRpdHVkZTogJHt0aGlzLmxhdGl0dWRlLnRvUHJlY2lzaW9uKDUpfSwgbWFnbml0dWRlOiAke3RoaXMubWFnbml0dWRlLnRvUHJlY2lzaW9uKDUpfWA7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLy8gRnJvbSBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXHJcbiAgLy8gSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5jb20+LCAyMDEwXHJcbiAgZXhwb3J0IGZ1bmN0aW9uIE1hc2goKTogRnVuY3Rpb24ge1xyXG4gICAgbGV0IG46IG51bWJlciA9IDB4ZWZjODI0OWQ7XHJcblxyXG4gICAgbGV0IG1hc2g6IEZ1bmN0aW9uID0gZnVuY3Rpb24gKF9kYXRhOiBzdHJpbmcgfCBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICBfZGF0YSA9IF9kYXRhLnRvU3RyaW5nKCk7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBfZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG4gKz0gX2RhdGEuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBsZXQgaDogbnVtYmVyID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XHJcbiAgICAgICAgbiA9IGggPj4+IDA7XHJcbiAgICAgICAgaCAtPSBuO1xyXG4gICAgICAgIGggKj0gbjtcclxuICAgICAgICBuID0gaCA+Pj4gMDtcclxuICAgICAgICBoIC09IG47XHJcbiAgICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7IC8vIDJeMzJcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcclxuICAgIH07XHJcblxyXG4gICAgLy8gbWFzaC52ZXJzaW9uID0gJ01hc2ggMC45JztcclxuICAgIHJldHVybiBtYXNoO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEZyb20gaHR0cDovL2JhYWdvZS5jb20vZW4vUmFuZG9tTXVzaW5ncy9qYXZhc2NyaXB0L1xyXG4gIGV4cG9ydCBmdW5jdGlvbiBMRklCNCgpOiBGdW5jdGlvbiB7XHJcbiAgICAvLyBHZW9yZ2UgTWFyc2FnbGlhJ3MgTEZJQjQsXHJcbiAgICAvL2h0dHA6Ly9ncm91cHMuZ29vZ2xlLmNvbS9ncm91cC9zY2kuY3J5cHQvbXNnL2ViNGRkZGU3ODJiMTcwNTFcclxuICAgIGxldCBhcmdzOiBudW1iZXJbXSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICBsZXQgazA6IG51bWJlciA9IDAsXHJcbiAgICAgIGsxOiBudW1iZXIgPSA1OCxcclxuICAgICAgazI6IG51bWJlciA9IDExOSxcclxuICAgICAgazM6IG51bWJlciA9IDE3ODtcclxuXHJcbiAgICBsZXQgczogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICBsZXQgbWFzaDogRnVuY3Rpb24gPSBNYXNoKCk7XHJcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgYXJncyA9IFsrbmV3IERhdGUoKV07XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgMjU2OyBqKyspIHtcclxuICAgICAgc1tqXSA9IG1hc2goXCIgXCIpO1xyXG4gICAgICBzW2pdIC09IG1hc2goXCIgXCIpICogNC43NjgzNzE1ODIwMzEyNWUtNzsgLy8gMl4tMjFcclxuICAgICAgaWYgKHNbal0gPCAwKSB7XHJcbiAgICAgICAgc1tqXSArPSAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgMjU2OyBqKyspIHtcclxuICAgICAgICBzW2pdIC09IG1hc2goYXJnc1tpXSk7XHJcbiAgICAgICAgc1tqXSAtPSBtYXNoKGFyZ3NbaV0pICogNC43NjgzNzE1ODIwMzEyNWUtNzsgLy8gMl4tMjFcclxuICAgICAgICBpZiAoc1tqXSA8IDApIHtcclxuICAgICAgICAgIHNbal0gKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG1hc2ggPSBudWxsO1xyXG5cclxuICAgIGxldCByYW5kb206IEZ1bmN0aW9uID0gZnVuY3Rpb24gKCk6IG51bWJlciB7XHJcbiAgICAgIGxldCB4OiBudW1iZXI7XHJcblxyXG4gICAgICBrMCA9IChrMCArIDEpICYgMjU1O1xyXG4gICAgICBrMSA9IChrMSArIDEpICYgMjU1O1xyXG4gICAgICBrMiA9IChrMiArIDEpICYgMjU1O1xyXG4gICAgICBrMyA9IChrMyArIDEpICYgMjU1O1xyXG5cclxuICAgICAgeCA9IHNbazBdIC0gc1trMV07XHJcbiAgICAgIGlmICh4IDwgMCkge1xyXG4gICAgICAgIHggKz0gMTtcclxuICAgICAgfVxyXG4gICAgICB4IC09IHNbazJdO1xyXG4gICAgICBpZiAoeCA8IDApIHtcclxuICAgICAgICB4ICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgeCAtPSBzW2szXTtcclxuICAgICAgaWYgKHggPCAwKSB7XHJcbiAgICAgICAgeCArPSAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc1trMF0gPSB4O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyByYW5kb20udWludDMyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gICByZXR1cm4gcmFuZG9tKCkgKiAweDEwMDAwMDAwMCA+Pj4gMDsgLy8gMl4zMlxyXG4gICAgLy8gfTtcclxuICAgIC8vIHJhbmRvbS5mcmFjdDUzID0gcmFuZG9tO1xyXG4gICAgLy8gcmFuZG9tLnZlcnNpb24gPSBcIkxGSUI0IDAuOVwiO1xyXG4gICAgLy8gcmFuZG9tLmFyZ3MgPSBhcmdzO1xyXG5cclxuICAgIHJldHVybiByYW5kb207XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgdGhlIG1hdHJpeCBhcyB0cmFuc2xhdGlvbiwgcm90YXRpb24gYW5kIHNjYWxpbmcge0BsaW5rIFZlY3RvcjJ9LCBiZWluZyBjYWxjdWxhdGVkIGZyb20gdGhlIG1hdHJpeFxyXG4gICAqL1xyXG4gIGludGVyZmFjZSBWZWN0b3JSZXByZXNlbnRhdGlvbiB7XHJcbiAgICB0cmFuc2xhdGlvbjogVmVjdG9yMjtcclxuICAgIHJvdGF0aW9uOiBudW1iZXI7XHJcbiAgICBzY2FsaW5nOiBWZWN0b3IyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2ltcGxlIGNsYXNzIGZvciAzeDMgbWF0cml4IG9wZXJhdGlvbnNcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1hdHJpeDN4MyBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUsIFJlY3ljYWJsZSB7XHJcbiAgICBwcml2YXRlIGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7IC8vIFRoZSBkYXRhIG9mIHRoZSBtYXRyaXguXHJcbiAgICBwcml2YXRlIG11dGF0b3I6IE11dGF0b3IgPSBudWxsOyAvLyBwcmVwYXJlZCBmb3Igb3B0aW1pemF0aW9uLCBrZWVwIG11dGF0b3IgdG8gcmVkdWNlIHJlZHVuZGFudCBjYWxjdWxhdGlvbiBhbmQgZm9yIGNvbXBhcmlzb24uIFNldCB0byBudWxsIHdoZW4gZGF0YSBjaGFuZ2VzIVxyXG4gICAgcHJpdmF0ZSB2ZWN0b3JzOiBWZWN0b3JSZXByZXNlbnRhdGlvbjsgLy8gdmVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbWF0cml4XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnJlY3ljbGUoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy9UT0RPOiBmaWd1cmUgb3V0IHdoYXQgdGhpcyBpcyB1c2VkIGZvclxyXG4gICAgLyoqIFRPRE86IGRlc2NyaWJlISAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBQUk9KRUNUSU9OKF93aWR0aDogbnVtYmVyLCBfaGVpZ2h0OiBudW1iZXIpOiBNYXRyaXgzeDMge1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXgzeDMgPSBuZXcgTWF0cml4M3gzO1xyXG4gICAgICBtdHhSZXN1bHQuZGF0YS5zZXQoW1xyXG4gICAgICAgIDIgLyBfd2lkdGgsIDAsIDAsXHJcbiAgICAgICAgMCwgLTIgLyBfaGVpZ2h0LCAwLFxyXG4gICAgICAgIC0xLCAxLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgYSBuZXcgaWRlbnRpdHkgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIElERU5USVRZKCk6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4M3gzID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDN4Myk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgdHJhbnNsYXRlcyBjb29yZGluYXRlcyBhbG9uZyB0aGUgeC0gYW5kIHktYXhpcyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHtAbGluayBWZWN0b3IyfS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUUkFOU0xBVElPTihfdHJhbnNsYXRlOiBWZWN0b3IyKTogTWF0cml4M3gzIHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXgzeDMgPSBSZWN5Y2xlci5yZXVzZShNYXRyaXgzeDMpO1xyXG4gICAgICBtdHhSZXN1bHQuc2V0KFtcclxuICAgICAgICAxLCAwLCAwLFxyXG4gICAgICAgIDAsIDEsIDAsXHJcbiAgICAgICAgX3RyYW5zbGF0ZS54LCBfdHJhbnNsYXRlLnksIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyBvbiB0aGUgei1heGlzIHdoZW4gbXVsdGlwbGllZCBieS5cclxuICAgICAqIEBwYXJhbSBfYW5nbGVJbkRlZ3JlZXMgVGhlIHZhbHVlIG9mIHRoZSByb3RhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTihfYW5nbGVJbkRlZ3JlZXM6IG51bWJlcik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4M3gzID0gUmVjeWNsZXIucmV1c2UoTWF0cml4M3gzKTtcclxuICAgICAgbGV0IGFuZ2xlSW5SYWRpYW5zOiBudW1iZXIgPSBfYW5nbGVJbkRlZ3JlZXMgKiBDYWxjLmRlZzJyYWQ7XHJcbiAgICAgIGxldCBzaW46IG51bWJlciA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgbGV0IGNvczogbnVtYmVyID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBtdHhSZXN1bHQuc2V0KFtcclxuICAgICAgICBjb3MsIHNpbiwgMCxcclxuICAgICAgICAtc2luLCBjb3MsIDAsXHJcbiAgICAgICAgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCBzY2FsZXMgY29vcmRpbmF0ZXMgYWxvbmcgdGhlIHgtIGFuZCB5LWF4aXMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB7QGxpbmsgVmVjdG9yMn1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTQ0FMSU5HKF9zY2FsYXI6IFZlY3RvcjIpOiBNYXRyaXgzeDMge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDN4Myk7XHJcbiAgICAgIG10eFJlc3VsdC5zZXQoW1xyXG4gICAgICAgIF9zY2FsYXIueCwgMCwgMCxcclxuICAgICAgICAwLCBfc2NhbGFyLnksIDAsXHJcbiAgICAgICAgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdHdvIHBhc3NlZCBtYXRyaWNlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBQUk9EVUNUKF9tdHhMZWZ0OiBNYXRyaXgzeDMsIF9tdHhSaWdodDogTWF0cml4M3gzKTogTWF0cml4M3gzIHtcclxuICAgICAgbGV0IGEwMDogbnVtYmVyID0gX210eExlZnQuZGF0YVswICogMyArIDBdO1xyXG4gICAgICBsZXQgYTAxOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzAgKiAzICsgMV07XHJcbiAgICAgIGxldCBhMDI6IG51bWJlciA9IF9tdHhMZWZ0LmRhdGFbMCAqIDMgKyAyXTtcclxuICAgICAgbGV0IGExMDogbnVtYmVyID0gX210eExlZnQuZGF0YVsxICogMyArIDBdO1xyXG4gICAgICBsZXQgYTExOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzEgKiAzICsgMV07XHJcbiAgICAgIGxldCBhMTI6IG51bWJlciA9IF9tdHhMZWZ0LmRhdGFbMSAqIDMgKyAyXTtcclxuICAgICAgbGV0IGEyMDogbnVtYmVyID0gX210eExlZnQuZGF0YVsyICogMyArIDBdO1xyXG4gICAgICBsZXQgYTIxOiBudW1iZXIgPSBfbXR4TGVmdC5kYXRhWzIgKiAzICsgMV07XHJcbiAgICAgIGxldCBhMjI6IG51bWJlciA9IF9tdHhMZWZ0LmRhdGFbMiAqIDMgKyAyXTtcclxuICAgICAgbGV0IGIwMDogbnVtYmVyID0gX210eFJpZ2h0LmRhdGFbMCAqIDMgKyAwXTtcclxuICAgICAgbGV0IGIwMTogbnVtYmVyID0gX210eFJpZ2h0LmRhdGFbMCAqIDMgKyAxXTtcclxuICAgICAgbGV0IGIwMjogbnVtYmVyID0gX210eFJpZ2h0LmRhdGFbMCAqIDMgKyAyXTtcclxuICAgICAgbGV0IGIxMDogbnVtYmVyID0gX210eFJpZ2h0LmRhdGFbMSAqIDMgKyAwXTtcclxuICAgICAgbGV0IGIxMTogbnVtYmVyID0gX210eFJpZ2h0LmRhdGFbMSAqIDMgKyAxXTtcclxuICAgICAgbGV0IGIxMjogbnVtYmVyID0gX210eFJpZ2h0LmRhdGFbMSAqIDMgKyAyXTtcclxuICAgICAgbGV0IGIyMDogbnVtYmVyID0gX210eFJpZ2h0LmRhdGFbMiAqIDMgKyAwXTtcclxuICAgICAgbGV0IGIyMTogbnVtYmVyID0gX210eFJpZ2h0LmRhdGFbMiAqIDMgKyAxXTtcclxuICAgICAgbGV0IGIyMjogbnVtYmVyID0gX210eFJpZ2h0LmRhdGFbMiAqIDMgKyAyXTtcclxuICAgICAgbGV0IG10eFJlc3VsdDogTWF0cml4M3gzID0gUmVjeWNsZXIucmV1c2UoTWF0cml4M3gzKTtcclxuICAgICAgbXR4UmVzdWx0LnNldChbXHJcbiAgICAgICAgYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwLFxyXG4gICAgICAgIGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMSxcclxuICAgICAgICBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjIsXHJcbiAgICAgICAgYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwLFxyXG4gICAgICAgIGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMSxcclxuICAgICAgICBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjIsXHJcbiAgICAgICAgYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwLFxyXG4gICAgICAgIGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMSxcclxuICAgICAgICBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjJcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgaW52ZXJzZSBvZiBhIHBhc3NlZCBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0gX210eCBUaGUgbWF0cml4IHRvIGNvbXB1dGUgdGhlIGludmVyc2Ugb2YuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgSU5WRVJTRShfbXR4OiBNYXRyaXgzeDMpOiBNYXRyaXgzeDMge1xyXG4gICAgICBsZXQgbTogRmxvYXQzMkFycmF5ID0gX210eC5kYXRhO1xyXG4gICAgICBsZXQgbTAwOiBudW1iZXIgPSBtWzAgKiAzICsgMF07XHJcbiAgICAgIGxldCBtMDE6IG51bWJlciA9IG1bMCAqIDMgKyAxXTtcclxuICAgICAgbGV0IG0wMjogbnVtYmVyID0gbVswICogMyArIDJdO1xyXG4gICAgICBsZXQgbTEwOiBudW1iZXIgPSBtWzEgKiAzICsgMF07XHJcbiAgICAgIGxldCBtMTE6IG51bWJlciA9IG1bMSAqIDMgKyAxXTtcclxuICAgICAgbGV0IG0xMjogbnVtYmVyID0gbVsxICogMyArIDJdO1xyXG4gICAgICBsZXQgbTIwOiBudW1iZXIgPSBtWzIgKiAzICsgMF07XHJcbiAgICAgIGxldCBtMjE6IG51bWJlciA9IG1bMiAqIDMgKyAxXTtcclxuICAgICAgbGV0IG0yMjogbnVtYmVyID0gbVsyICogMyArIDJdO1xyXG5cclxuICAgICAgbGV0IGQ6IG51bWJlciA9IDEgL1xyXG4gICAgICAgIChtMDAgKiAobTExICogbTIyIC0gbTIxICogbTEyKSAtXHJcbiAgICAgICAgICBtMDEgKiAobTEwICogbTIyIC0gbTEyICogbTIwKSArXHJcbiAgICAgICAgICBtMDIgKiAobTEwICogbTIxIC0gbTExICogbTIwKSk7XHJcblxyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDN4Myk7XHJcbiAgICAgIG10eFJlc3VsdC5zZXQoW1xyXG4gICAgICAgIGQgKiAobTExICogbTIyIC0gbTIxICogbTEyKSwgLy8gWzBdXHJcbiAgICAgICAgZCAqIChtMDIgKiBtMjEgLSBtMDEgKiBtMjIpLCAvLyBbMV1cclxuICAgICAgICBkICogKG0wMSAqIG0xMiAtIG0wMiAqIG0xMSksIC8vIFsyXVxyXG4gICAgICAgIGQgKiAobTEyICogbTIwIC0gbTEwICogbTIyKSwgLy8gWzNdXHJcbiAgICAgICAgZCAqIChtMDAgKiBtMjIgLSBtMDIgKiBtMjApLCAvLyBbNF1cclxuICAgICAgICBkICogKG0xMCAqIG0wMiAtIG0wMCAqIG0xMiksIC8vIFs1XVxyXG4gICAgICAgIGQgKiAobTEwICogbTIxIC0gbTIwICogbTExKSwgLy8gWzZdXHJcbiAgICAgICAgZCAqIChtMjAgKiBtMDEgLSBtMDAgKiBtMjEpLCAvLyBbN11cclxuICAgICAgICBkICogKG0wMCAqIG0xMSAtIG0xMCAqIG0wMSkgLy8gWzhdXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIC0gZ2V0OiByZXR1cm4gYSB2ZWN0b3IgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zbGF0aW9uIHtAbGluayBWZWN0b3IyfS4gIFxyXG4gICAgICogKipDYXV0aW9uISoqIFVzZSBpbW1lZGlhdGVseSwgc2luY2UgdGhlIHZlY3RvciBpcyBnb2luZyB0byBiZSByZXVzZWQgYnkgUmVjeWNsZXIuIENyZWF0ZSBhIGNsb25lIHRvIGtlZXAgbG9uZ2VyIGFuZCBtYW5pcHVsYXRlLiBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeCBpZ25vcmluZyBpdHMgcm90YXRpb24gYW5kIHNjYWxpbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB0cmFuc2xhdGlvbigpOiBWZWN0b3IyIHtcclxuICAgICAgaWYgKCF0aGlzLnZlY3RvcnMudHJhbnNsYXRpb24pXHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gbmV3IFZlY3RvcjIodGhpcy5kYXRhWzZdLCB0aGlzLmRhdGFbN10pO1xyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uOyAvLyAuY2xvbmU7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHRyYW5zbGF0aW9uKF90cmFuc2xhdGlvbjogVmVjdG9yMikge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KF90cmFuc2xhdGlvbi5nZXQoKSwgNik7XHJcbiAgICAgIC8vIG5vIGZ1bGwgY2FjaGUgcmVzZXQgcmVxdWlyZWRcclxuICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gX3RyYW5zbGF0aW9uO1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIC0gZ2V0OiBhIGNvcHkgb2YgdGhlIGNhbGN1bGF0ZWQgcm90YXRpb24ge0BsaW5rIFZlY3RvcjJ9ICAgXHJcbiAgICAgKiAtIHNldDogZWZmZWN0IHRoZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCByb3RhdGlvbigpOiBudW1iZXIge1xyXG4gICAgICBpZiAoIXRoaXMudmVjdG9ycy5yb3RhdGlvbilcclxuICAgICAgICB0aGlzLnZlY3RvcnMucm90YXRpb24gPSB0aGlzLmdldEV1bGVyQW5nbGUoKTtcclxuICAgICAgcmV0dXJuIHRoaXMudmVjdG9ycy5yb3RhdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgcm90YXRpb24oX3JvdGF0aW9uOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5tdXRhdGUoeyBcInJvdGF0aW9uXCI6IF9yb3RhdGlvbiB9KTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IHJldHVybiBhIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2NhbGUge0BsaW5rIFZlY3RvcjN9LiAgXHJcbiAgICAgKiAqKkNhdXRpb24hKiogRG8gbm90IG1hbmlwdWxhdGUgcmVzdWx0LCBpbnN0ZWFkIGNyZWF0ZSBhIGNsb25lISAgICBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNjYWxpbmcoKTogVmVjdG9yMiB7XHJcbiAgICAgIGlmICghdGhpcy52ZWN0b3JzLnNjYWxpbmcpXHJcbiAgICAgICAgdGhpcy52ZWN0b3JzLnNjYWxpbmcgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICAgIE1hdGguaHlwb3QodGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0pICogKHRoaXMuZGF0YVswXSA8IDAgPyAtMSA6IDEpLFxyXG4gICAgICAgICAgTWF0aC5oeXBvdCh0aGlzLmRhdGFbM10sIHRoaXMuZGF0YVs0XSkgKiAodGhpcy5kYXRhWzRdIDwgMCA/IC0xIDogMSlcclxuICAgICAgICApO1xyXG4gICAgICByZXR1cm4gdGhpcy52ZWN0b3JzLnNjYWxpbmc7IC8vIC5jbG9uZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc2NhbGluZyhfc2NhbGluZzogVmVjdG9yMikge1xyXG4gICAgICB0aGlzLm11dGF0ZSh7IFwic2NhbGluZ1wiOiBfc2NhbGluZyB9KTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY2xvbmUoKTogTWF0cml4M3gzIHtcclxuICAgICAgcmV0dXJuIFJlY3ljbGVyLnJldXNlKE1hdHJpeDN4MykuY29weSh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgbWF0cml4IHRvIHRoZSBpZGVudGl0eS1tYXRyaXggYW5kIGNsZWFycyBjYWNoZS4gVXNlZCBieSB0aGUgcmVjeWNsZXIgdG8gcmVzZXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIG1hdHJpeCB0byB0aGUgaWRlbnRpdHktbWF0cml4IGFuZCBjbGVhcnMgY2FjaGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5yZWN5Y2xlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zbGF0aW9uXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSB0cmFuc2xhdGlvbiBieSB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjJ9IHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlKF9ieTogVmVjdG9yMik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4M3gzID0gTWF0cml4M3gzLlBST0RVQ1QodGhpcywgTWF0cml4M3gzLlRSQU5TTEFUSU9OKF9ieSkpO1xyXG4gICAgICAvLyBUT0RPOiBwb3NzaWJsZSBvcHRpbWl6YXRpb24sIHRyYW5zbGF0aW9uIG1heSBhbHRlciBtdXRhdG9yIGluc3RlYWQgb2YgZGVsZXRpbmcgaXQuXHJcbiAgICAgIHRoaXMuc2V0KG10eFJlc3VsdC5kYXRhKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHgtYXhpcyB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZVgoX3g6IG51bWJlcik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIHRoaXMuZGF0YVs2XSArPSBfeDtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gbnVsbDtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHktYXhpcyB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZVkoX3k6IG51bWJlcik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIHRoaXMuZGF0YVs3XSArPSBfeTtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgICAgdGhpcy52ZWN0b3JzLnRyYW5zbGF0aW9uID0gbnVsbDtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gUm90YXRpb25cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgei1BeGlzIHRvIHRoaXMgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGUoX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIpOiBNYXRyaXgzeDMge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5QUk9EVUNUKHRoaXMsIE1hdHJpeDN4My5ST1RBVElPTihfYW5nbGVJbkRlZ3JlZXMpKTtcclxuICAgICAgdGhpcy5zZXQobXR4UmVzdWx0LmRhdGEpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSZXN1bHQpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTY2FsaW5nXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzY2FsaW5nIGJ5IHRoZSBnaXZlbiB7QGxpbmsgVmVjdG9yMn0gdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZShfYnk6IFZlY3RvcjIpOiBNYXRyaXgzeDMge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5QUk9EVUNUKHRoaXMsIE1hdHJpeDN4My5TQ0FMSU5HKF9ieSkpO1xyXG4gICAgICB0aGlzLnNldChtdHhSZXN1bHQuZGF0YSk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJlc3VsdCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHNjYWxpbmcgYWxvbmcgdGhlIHgtQXhpcyB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlWChfYnk6IG51bWJlcik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICAgIHZlY3Rvci5zZXQoX2J5LCAxKTtcclxuICAgICAgdGhpcy5zY2FsZSh2ZWN0b3IpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh2ZWN0b3IpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzY2FsaW5nIGFsb25nIHRoZSB5LUF4aXMgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVkoX2J5OiBudW1iZXIpOiBNYXRyaXgzeDMge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KDEsIF9ieSk7XHJcbiAgICAgIHRoaXMuc2NhbGUodmVjdG9yKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodmVjdG9yKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmb3JtYXRpb25cclxuICAgIC8qKlxyXG4gICAgICogTXVsdGlwbHkgdGhpcyBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtdWx0aXBseShfbXR4UmlnaHQ6IE1hdHJpeDN4Myk6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5QUk9EVUNUKHRoaXMsIF9tdHhSaWdodCk7XHJcbiAgICAgIHRoaXMuc2V0KG10eFJlc3VsdC5kYXRhKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4UmVzdWx0KTtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgZXVsZXItYW5nbGVzIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCByb3RhdGlvbiBvZiB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RXVsZXJBbmdsZSgpOiBudW1iZXIge1xyXG4gICAgICBsZXQgc2NhbGluZzogVmVjdG9yMiA9IHRoaXMuc2NhbGluZztcclxuXHJcbiAgICAgIGxldCBzMDogbnVtYmVyID0gdGhpcy5kYXRhWzBdIC8gc2NhbGluZy54O1xyXG4gICAgICBsZXQgczE6IG51bWJlciA9IHRoaXMuZGF0YVsxXSAvIHNjYWxpbmcueDtcclxuICAgICAgbGV0IHMzOiBudW1iZXIgPSB0aGlzLmRhdGFbM10gLyBzY2FsaW5nLnk7XHJcbiAgICAgIGxldCBzNDogbnVtYmVyID0gdGhpcy5kYXRhWzRdIC8gc2NhbGluZy55O1xyXG5cclxuICAgICAgbGV0IHhTa2V3OiBudW1iZXIgPSBNYXRoLmF0YW4yKC1zMywgczQpO1xyXG4gICAgICBsZXQgeVNrZXc6IG51bWJlciA9IE1hdGguYXRhbjIoczAsIHMxKTtcclxuXHJcbiAgICAgIGxldCBzeTogbnVtYmVyID0gTWF0aC5oeXBvdChzMCwgczEpOyAvLyBwcm9iYWJseSAyLiBwYXJhbSBzaG91bGQgYmUgdGhpcy5kYXRhWzRdIC8gc2NhbGluZy55XHJcbiAgICAgIGxldCByb3RhdGlvbjogbnVtYmVyO1xyXG5cclxuICAgICAgaWYgKCEoc3kgPiAxZS02KSlcclxuICAgICAgICByb3RhdGlvbiA9IHlTa2V3O1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcm90YXRpb24gPSB4U2tldztcclxuXHJcbiAgICAgIHJvdGF0aW9uICo9IENhbGMucmFkMmRlZztcclxuXHJcbiAgICAgIHJldHVybiByb3RhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IHRvIHRoZSBnaXZlbiBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldChfYXJyYXk6IEFycmF5TGlrZTxudW1iZXI+KTogTWF0cml4M3gzIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChfYXJyYXkpO1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBtYXRyaXggaW50byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvcHkoX29yaWdpbmFsOiBNYXRyaXgzeDMpOiBNYXRyaXgzeDMge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KF9vcmlnaW5hbC5kYXRhKTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7IC8vIFRPRE86IGZvciBub3cgcmVzZXQgdGhlIGNhY2hlLCBhcyBpIGhhdmUgbm8gaWRlYSBob3cgdGhlIGNhY2hpbmcgd29ya3MgZm9yIG1hdHJpeDN4My5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGDGki5NYXRyaXgzeDModHJhbnNsYXRpb246ICR7dGhpcy50cmFuc2xhdGlvbi50b1N0cmluZygpfSwgcm90YXRpb246ICR7dGhpcy5yb3RhdGlvbi50b1N0cmluZygpfSwgc2NhbGluZzogJHt0aGlzLnNjYWxpbmcudG9TdHJpbmcoKX1gO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5kYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIGFycmF5IG9mIHRoZSBlbGVtZW50cyBvZiB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldERhdGEoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICAvLyB0aGlzLmdldE11dGF0b3IoKTtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgdHJhbnNsYXRpb246IHRoaXMudHJhbnNsYXRpb24uc2VyaWFsaXplKCksXHJcbiAgICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXHJcbiAgICAgICAgc2NhbGluZzogdGhpcy5zY2FsaW5nLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XHJcbiAgICAgICAgdHJhbnNsYXRpb246IGF3YWl0IHRoaXMudHJhbnNsYXRpb24uZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24udHJhbnNsYXRpb24pLFxyXG4gICAgICAgIHJvdGF0aW9uOiBfc2VyaWFsaXphdGlvbi5yb3RhdGlvbixcclxuICAgICAgICBzY2FsaW5nOiBhd2FpdCB0aGlzLnNjYWxpbmcuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uc2NhbGluZylcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5tdXRhdGUobXV0YXRvcik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBpZiAodGhpcy5tdXRhdG9yKVxyXG4gICAgICAgIHJldHVybiB0aGlzLm11dGF0b3I7XHJcblxyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB0cmFuc2xhdGlvbjogdGhpcy50cmFuc2xhdGlvbi5nZXRNdXRhdG9yKCksXHJcbiAgICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXHJcbiAgICAgICAgc2NhbGluZzogdGhpcy5zY2FsaW5nLmdldE11dGF0b3IoKVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gY2FjaGUgbXV0YXRvclxyXG4gICAgICB0aGlzLm11dGF0b3IgPSBtdXRhdG9yO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGxldCBvbGRUcmFuc2xhdGlvbjogVmVjdG9yMiA9IHRoaXMudHJhbnNsYXRpb247XHJcbiAgICAgIGxldCBvbGRSb3RhdGlvbjogbnVtYmVyID0gdGhpcy5yb3RhdGlvbjtcclxuICAgICAgbGV0IG9sZFNjYWxpbmc6IFZlY3RvcjIgPSB0aGlzLnNjYWxpbmc7XHJcbiAgICAgIGxldCBuZXdUcmFuc2xhdGlvbjogVmVjdG9yMiA9IDxWZWN0b3IyPl9tdXRhdG9yW1widHJhbnNsYXRpb25cIl07XHJcbiAgICAgIGxldCBuZXdSb3RhdGlvbjogbnVtYmVyID0gPG51bWJlcj5fbXV0YXRvcltcInJvdGF0aW9uXCJdO1xyXG4gICAgICBsZXQgbmV3U2NhbGluZzogVmVjdG9yMiA9IDxWZWN0b3IyPl9tdXRhdG9yW1wic2NhbGluZ1wiXTtcclxuICAgICAgbGV0IHZlY3RvcnM6IFZlY3RvclJlcHJlc2VudGF0aW9uID0geyB0cmFuc2xhdGlvbjogb2xkVHJhbnNsYXRpb24sIHJvdGF0aW9uOiBvbGRSb3RhdGlvbiwgc2NhbGluZzogb2xkU2NhbGluZyB9O1xyXG4gICAgICBpZiAobmV3VHJhbnNsYXRpb24pIHtcclxuICAgICAgICB2ZWN0b3JzLnRyYW5zbGF0aW9uID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgICBuZXdUcmFuc2xhdGlvbi54ICE9IHVuZGVmaW5lZCA/IG5ld1RyYW5zbGF0aW9uLnggOiBvbGRUcmFuc2xhdGlvbi54LFxyXG4gICAgICAgICAgbmV3VHJhbnNsYXRpb24ueSAhPSB1bmRlZmluZWQgPyBuZXdUcmFuc2xhdGlvbi55IDogb2xkVHJhbnNsYXRpb24ueVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZlY3RvcnMucm90YXRpb24gPSAobmV3Um90YXRpb24gPT0gdW5kZWZpbmVkKSA/IG9sZFJvdGF0aW9uIDogbmV3Um90YXRpb247XHJcblxyXG4gICAgICBpZiAobmV3U2NhbGluZykge1xyXG4gICAgICAgIHZlY3RvcnMuc2NhbGluZyA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgICAgbmV3U2NhbGluZy54ICE9IHVuZGVmaW5lZCA/IG5ld1NjYWxpbmcueCA6IG9sZFNjYWxpbmcueCxcclxuICAgICAgICAgIG5ld1NjYWxpbmcueSAhPSB1bmRlZmluZWQgPyBuZXdTY2FsaW5nLnkgOiBvbGRTY2FsaW5nLnlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUT0RPOiBwb3NzaWJsZSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gd2hlbiBvbmx5IG9uZSBvciB0d28gY29tcG9uZW50cyBjaGFuZ2UsIHRoZW4gdXNlIG9sZCBtYXRyaXggaW5zdGVhZCBvZiBJREVOVElUWSBhbmQgdHJhbnNmb3JtIGJ5IGRpZmZlcmVuY2VzL3F1b3RpZW50c1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXgzeDMgPSBNYXRyaXgzeDMuSURFTlRJVFkoKTtcclxuICAgICAgaWYgKHZlY3RvcnMudHJhbnNsYXRpb24pXHJcbiAgICAgICAgbXR4UmVzdWx0LnRyYW5zbGF0ZSh2ZWN0b3JzLnRyYW5zbGF0aW9uKTtcclxuICAgICAgaWYgKHZlY3RvcnMucm90YXRpb24pIHtcclxuICAgICAgICBtdHhSZXN1bHQucm90YXRlKHZlY3RvcnMucm90YXRpb24pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2ZWN0b3JzLnNjYWxpbmcpXHJcbiAgICAgICAgbXR4UmVzdWx0LnNjYWxlKHZlY3RvcnMuc2NhbGluZyk7XHJcbiAgICAgIHRoaXMuc2V0KG10eFJlc3VsdC5kYXRhKTtcclxuXHJcbiAgICAgIHRoaXMudmVjdG9ycyA9IHZlY3RvcnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0ge307XHJcbiAgICAgIGlmIChfbXV0YXRvci50cmFuc2xhdGlvbikgdHlwZXMudHJhbnNsYXRpb24gPSBcIlZlY3RvcjJcIjtcclxuICAgICAgaWYgKF9tdXRhdG9yLnJvdGF0aW9uICE9IHVuZGVmaW5lZCkgdHlwZXMucm90YXRpb24gPSBcIm51bWJlclwiO1xyXG4gICAgICBpZiAoX211dGF0b3Iuc2NhbGluZykgdHlwZXMuc2NhbGluZyA9IFwiVmVjdG9yMlwiO1xyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcblxyXG4gICAgcHJpdmF0ZSByZXNldENhY2hlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnZlY3RvcnMgPSB7IHRyYW5zbGF0aW9uOiBudWxsLCByb3RhdGlvbjogbnVsbCwgc2NhbGluZzogbnVsbCB9O1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyNlbmRyZWdpb25cclxuXHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3JlcyBhIDR4NCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggYW5kIHByb3ZpZGVzIG9wZXJhdGlvbnMgZm9yIGl0LlxyXG4gICAqIGBgYHRleHRcclxuICAgKiBbIDAsIDEsIDIsIDMgXSDihpAgcm93IHZlY3RvciB4XHJcbiAgICogWyA0LCA1LCA2LCA3IF0g4oaQIHJvdyB2ZWN0b3IgeVxyXG4gICAqIFsgOCwgOSwxMCwxMSBdIOKGkCByb3cgdmVjdG9yIHpcclxuICAgKiBbMTIsMTMsMTQsMTUgXSDihpAgdHJhbnNsYXRpb25cclxuICAgKiAgICAgICAgICAgIOKGkSAgaG9tb2dlbmVvdXMgY29sdW1uXHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOSB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNYXRyaXg0eDQgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlLCBSZWN5Y2FibGUge1xyXG4gICAgLyoqIEBpbnRlcm5hbCBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIG1hdHJpeCB3YXMgbW9kaWZpZWQgc2luY2UgdGhlIGxhc3QgY2FsbCB0byB7QGxpbmsgUmVuZGVyLnByZXBhcmV9LiAqL1xyXG4gICAgcHVibGljIG1vZGlmaWVkOiBib29sZWFuO1xyXG5cclxuICAgIHByaXZhdGUgZGF0YTogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7IC8vIFRoZSBkYXRhIG9mIHRoZSBtYXRyaXguXHJcbiAgICBwcml2YXRlIG11dGF0b3I6IE11dGF0b3IgPSBudWxsOyAvLyBwcmVwYXJlZCBmb3Igb3B0aW1pemF0aW9uLCBrZWVwIG11dGF0b3IgdG8gcmVkdWNlIHJlZHVuZGFudCBjYWxjdWxhdGlvbiBhbmQgZm9yIGNvbXBhcmlzb24uIFNldCB0byBudWxsIHdoZW4gZGF0YSBjaGFuZ2VzIVxyXG5cclxuICAgIHJlYWRvbmx5ICN0cmFuc2xhdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpO1xyXG4gICAgcmVhZG9ubHkgI3NjYWxpbmc6IFZlY3RvcjMgPSBWZWN0b3IzLlpFUk8oKTtcclxuICAgIHJlYWRvbmx5ICNyb3RhdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuT05FKCk7XHJcbiAgICByZWFkb25seSAjcXVhdGVybmlvbjogUXVhdGVybmlvbiA9IFF1YXRlcm5pb24uSURFTlRJVFkoKTtcclxuXHJcbiAgICAjdHJhbnNsYXRpb25EaXJ0eTogYm9vbGVhbjtcclxuICAgICNzY2FsaW5nRGlydHk6IGJvb2xlYW47XHJcbiAgICAjcm90YXRpb25EaXJ0eTogYm9vbGVhbjtcclxuICAgICNxdWF0ZXJuaW9uRGlydHk6IGJvb2xlYW47XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnJlY3ljbGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gU1RBVElDU1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBhIG5ldyBpZGVudGl0eSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBJREVOVElUWSgpOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcG9zZXMgYSBuZXcgbWF0cml4IGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gdHJhbnNsYXRpb24sIHJvdGF0aW9uIGFuZCBzY2FsaW5nLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENPTVBPU0lUSU9OKF90cmFuc2xhdGlvbj86IFZlY3RvcjMsIF9yb3RhdGlvbj86IFZlY3RvcjMgfCBRdWF0ZXJuaW9uLCBfc2NhbGluZz86IFZlY3RvcjMpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgcmVzdWx0OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgICAgcmVzdWx0Lm11dGF0ZSh7IFwidHJhbnNsYXRpb25cIjogX3RyYW5zbGF0aW9uLCBcInJvdGF0aW9uXCI6IF9yb3RhdGlvbiwgXCJzY2FsaW5nXCI6IF9zY2FsaW5nIH0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdHdvIHBhc3NlZCBtYXRyaWNlcy5cclxuICAgICAqL1xyXG4gICAgLy8gQFBlcmZvcm1hbmNlTW9uaXRvci5tZWFzdXJlKFwiTWF0cml4NHg0LlBST0RVQ1RcIilcclxuICAgIHB1YmxpYyBzdGF0aWMgUFJPRFVDVChfbXR4TGVmdDogTWF0cml4NHg0LCBfbXR4UmlnaHQ6IE1hdHJpeDR4NCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCBhOiBGbG9hdDMyQXJyYXkgPSBfbXR4TGVmdC5kYXRhO1xyXG4gICAgICBsZXQgYjogRmxvYXQzMkFycmF5ID0gX210eFJpZ2h0LmRhdGE7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIucmV1c2UoTWF0cml4NHg0KTtcclxuICAgICAgbGV0IGEwMDogbnVtYmVyID0gYVswICogNCArIDBdO1xyXG4gICAgICBsZXQgYTAxOiBudW1iZXIgPSBhWzAgKiA0ICsgMV07XHJcbiAgICAgIGxldCBhMDI6IG51bWJlciA9IGFbMCAqIDQgKyAyXTtcclxuICAgICAgbGV0IGEwMzogbnVtYmVyID0gYVswICogNCArIDNdO1xyXG4gICAgICBsZXQgYTEwOiBudW1iZXIgPSBhWzEgKiA0ICsgMF07XHJcbiAgICAgIGxldCBhMTE6IG51bWJlciA9IGFbMSAqIDQgKyAxXTtcclxuICAgICAgbGV0IGExMjogbnVtYmVyID0gYVsxICogNCArIDJdO1xyXG4gICAgICBsZXQgYTEzOiBudW1iZXIgPSBhWzEgKiA0ICsgM107XHJcbiAgICAgIGxldCBhMjA6IG51bWJlciA9IGFbMiAqIDQgKyAwXTtcclxuICAgICAgbGV0IGEyMTogbnVtYmVyID0gYVsyICogNCArIDFdO1xyXG4gICAgICBsZXQgYTIyOiBudW1iZXIgPSBhWzIgKiA0ICsgMl07XHJcbiAgICAgIGxldCBhMjM6IG51bWJlciA9IGFbMiAqIDQgKyAzXTtcclxuICAgICAgbGV0IGEzMDogbnVtYmVyID0gYVszICogNCArIDBdO1xyXG4gICAgICBsZXQgYTMxOiBudW1iZXIgPSBhWzMgKiA0ICsgMV07XHJcbiAgICAgIGxldCBhMzI6IG51bWJlciA9IGFbMyAqIDQgKyAyXTtcclxuICAgICAgbGV0IGEzMzogbnVtYmVyID0gYVszICogNCArIDNdO1xyXG4gICAgICBsZXQgYjAwOiBudW1iZXIgPSBiWzAgKiA0ICsgMF07XHJcbiAgICAgIGxldCBiMDE6IG51bWJlciA9IGJbMCAqIDQgKyAxXTtcclxuICAgICAgbGV0IGIwMjogbnVtYmVyID0gYlswICogNCArIDJdO1xyXG4gICAgICBsZXQgYjAzOiBudW1iZXIgPSBiWzAgKiA0ICsgM107XHJcbiAgICAgIGxldCBiMTA6IG51bWJlciA9IGJbMSAqIDQgKyAwXTtcclxuICAgICAgbGV0IGIxMTogbnVtYmVyID0gYlsxICogNCArIDFdO1xyXG4gICAgICBsZXQgYjEyOiBudW1iZXIgPSBiWzEgKiA0ICsgMl07XHJcbiAgICAgIGxldCBiMTM6IG51bWJlciA9IGJbMSAqIDQgKyAzXTtcclxuICAgICAgbGV0IGIyMDogbnVtYmVyID0gYlsyICogNCArIDBdO1xyXG4gICAgICBsZXQgYjIxOiBudW1iZXIgPSBiWzIgKiA0ICsgMV07XHJcbiAgICAgIGxldCBiMjI6IG51bWJlciA9IGJbMiAqIDQgKyAyXTtcclxuICAgICAgbGV0IGIyMzogbnVtYmVyID0gYlsyICogNCArIDNdO1xyXG4gICAgICBsZXQgYjMwOiBudW1iZXIgPSBiWzMgKiA0ICsgMF07XHJcbiAgICAgIGxldCBiMzE6IG51bWJlciA9IGJbMyAqIDQgKyAxXTtcclxuICAgICAgbGV0IGIzMjogbnVtYmVyID0gYlszICogNCArIDJdO1xyXG4gICAgICBsZXQgYjMzOiBudW1iZXIgPSBiWzMgKiA0ICsgM107XHJcbiAgICAgIG10eFJlc3VsdC5zZXQoW1xyXG4gICAgICAgIGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMCArIGIwMyAqIGEzMCxcclxuICAgICAgICBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjEgKyBiMDMgKiBhMzEsXHJcbiAgICAgICAgYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyICsgYjAzICogYTMyLFxyXG4gICAgICAgIGIwMCAqIGEwMyArIGIwMSAqIGExMyArIGIwMiAqIGEyMyArIGIwMyAqIGEzMyxcclxuICAgICAgICBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjAgKyBiMTMgKiBhMzAsXHJcbiAgICAgICAgYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxICsgYjEzICogYTMxLFxyXG4gICAgICAgIGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMiArIGIxMyAqIGEzMixcclxuICAgICAgICBiMTAgKiBhMDMgKyBiMTEgKiBhMTMgKyBiMTIgKiBhMjMgKyBiMTMgKiBhMzMsXHJcbiAgICAgICAgYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwICsgYjIzICogYTMwLFxyXG4gICAgICAgIGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMSArIGIyMyAqIGEzMSxcclxuICAgICAgICBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjIgKyBiMjMgKiBhMzIsXHJcbiAgICAgICAgYjIwICogYTAzICsgYjIxICogYTEzICsgYjIyICogYTIzICsgYjIzICogYTMzLFxyXG4gICAgICAgIGIzMCAqIGEwMCArIGIzMSAqIGExMCArIGIzMiAqIGEyMCArIGIzMyAqIGEzMCxcclxuICAgICAgICBiMzAgKiBhMDEgKyBiMzEgKiBhMTEgKyBiMzIgKiBhMjEgKyBiMzMgKiBhMzEsXHJcbiAgICAgICAgYjMwICogYTAyICsgYjMxICogYTEyICsgYjMyICogYTIyICsgYjMzICogYTMyLFxyXG4gICAgICAgIGIzMCAqIGEwMyArIGIzMSAqIGExMyArIGIzMiAqIGEyMyArIGIzMyAqIGEzM1xyXG4gICAgICBdKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSB0cmFuc3Bvc2Ugb2YgYSBwYXNzZWQgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRSQU5TUE9TRShfbXR4OiBNYXRyaXg0eDQpOiBNYXRyaXg0eDQge1xyXG4gICAgICByZXR1cm4gX210eC5jbG9uZS50cmFuc3Bvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBpbnZlcnNlIG9mIGEgcGFzc2VkIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSBfbXR4IFRoZSBtYXRyaXggdG8gY29tcHV0ZSB0aGUgaW52ZXJzZSBvZi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBJTlZFUlNFKF9tdHg6IE1hdHJpeDR4NCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiBfbXR4LmNsb25lLmludmVydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gdHJhbnNsYXRpb24sIGl0cyB6LWF4aXMgcG9pbnRpbmcgZGlyZWN0bHkgYXQgdGhlIGdpdmVuIHRhcmdldCxcclxuICAgICAqIGFuZCBhIG1pbmltYWwgYW5nbGUgYmV0d2VlbiBpdHMgeS1heGlzIGFuZCB0aGUgZ2l2ZW4gdXAte0BsaW5rIFZlY3RvcjN9LCByZXNwZXRpdmVseSBjYWxjdWxhdGluZyB5YXcgYW5kIHBpdGNoLlxyXG4gICAgICogVGhlIHBpdGNoIG1heSBiZSByZXN0cmljdGVkIHRvIHRoZSB1cC12ZWN0b3IgdG8gb25seSBjYWxjdWxhdGUgeWF3LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIExPT0tfQVQoX3RyYW5zbGF0aW9uOiBWZWN0b3IzLCBfdGFyZ2V0OiBWZWN0b3IzLCBfdXA6IFZlY3RvcjMgPSBWZWN0b3IzLlkoKSwgX3Jlc3RyaWN0OiBib29sZWFuID0gZmFsc2UpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgekF4aXM6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3RhcmdldCwgX3RyYW5zbGF0aW9uKTtcclxuICAgICAgekF4aXMubm9ybWFsaXplKCk7XHJcbiAgICAgIGxldCB2Y3RDcm9zczogVmVjdG9yMyA9IFZlY3RvcjMuQ1JPU1MoX3VwLCB6QXhpcyk7XHJcbiAgICAgIGlmICh2Y3RDcm9zcy5tYWduaXR1ZGVTcXVhcmVkID09IDApIC8vIGV4cGVyaW1lbnRhbCB3b3JrYXJvdW5kOiBpZiB6IGFuZCB1cCBpcyBwYXJhbGxlbCwgdGhlcmUgaXMgbm8gdXAgdG8gcmVtYWluLi4uXHJcbiAgICAgICAgdmN0Q3Jvc3MueCA9IDAuMDAxOyAvLyBzbyB0aWx0IGEgbGl0dGxlXHJcbiAgICAgIGxldCB4QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuTk9STUFMSVpBVElPTih2Y3RDcm9zcyk7XHJcbiAgICAgIGxldCB5QXhpczogVmVjdG9yMyA9IF9yZXN0cmljdCA/IF91cCA6IFZlY3RvcjMuTk9STUFMSVpBVElPTihWZWN0b3IzLkNST1NTKHpBeGlzLCB4QXhpcykpO1xyXG4gICAgICB6QXhpcyA9IF9yZXN0cmljdCA/IFZlY3RvcjMuTk9STUFMSVpBVElPTihWZWN0b3IzLkNST1NTKHhBeGlzLCBfdXApKSA6IHpBeGlzO1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDR4NCk7XHJcbiAgICAgIG10eFJlc3VsdC5zZXQoW1xyXG4gICAgICAgIHhBeGlzLngsIHhBeGlzLnksIHhBeGlzLnosIDAsXHJcbiAgICAgICAgeUF4aXMueCwgeUF4aXMueSwgeUF4aXMueiwgMCxcclxuICAgICAgICB6QXhpcy54LCB6QXhpcy55LCB6QXhpcy56LCAwLFxyXG4gICAgICAgIF90cmFuc2xhdGlvbi54LFxyXG4gICAgICAgIF90cmFuc2xhdGlvbi55LFxyXG4gICAgICAgIF90cmFuc2xhdGlvbi56LFxyXG4gICAgICAgIDFcclxuICAgICAgXSk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlTXVsdGlwbGUoekF4aXMsIHhBeGlzLCB2Y3RDcm9zcyk7IC8vIGRvbid0IHN0b3JlIHlBeGlzLCBpdCBtaWdodCBiZSBfdXBcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIGEgbWF0cml4IHdpdGggdGhlIGdpdmVuIHRyYW5zbGF0aW9uLCBpdHMgei1heGlzIHBvaW50aW5nIGRpcmVjdGx5IGluIHRoZSBnaXZlbiBkaXJlY3Rpb24sXHJcbiAgICAgKiBhbmQgYSBtaW5pbWFsIGFuZ2xlIGJldHdlZW4gaXRzIHktYXhpcyBhbmQgdGhlIGdpdmVuIHVwLXtAbGluayBWZWN0b3IzfS4gSWRlYWxseSB1cCBzaG91bGQgYmUgcGVycGVuZGljdWxhciB0byB0aGUgZ2l2ZW4gZGlyZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIExPT0tfSU4oX3RyYW5zbGF0aW9uOiBWZWN0b3IzLCBfZGlyZWN0aW9uOiBWZWN0b3IzLCBfdXA6IFZlY3RvcjMgPSBWZWN0b3IzLlkoKSwgX3Jlc3RyaWN0OiBib29sZWFuID0gZmFsc2UpOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5DT01QT1NJVElPTihfdHJhbnNsYXRpb24pO1xyXG4gICAgICBtdHhSZXN1bHQubG9va0luKF9kaXJlY3Rpb24sIF91cCwgX3Jlc3RyaWN0KTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIGEgbWF0cml4IHdpdGggdGhlIGdpdmVuIHRyYW5zbGF0aW9uLCBpdHMgeS1heGlzIG1hdGNoaW5nIHRoZSBnaXZlbiB1cC17QGxpbmsgVmVjdG9yM31cclxuICAgICAqIGFuZCBpdHMgei1heGlzIGZhY2luZyB0b3dhcmRzIHRoZSBnaXZlbiB0YXJnZXQgYXQgYSBtaW5pbWFsIGFuZ2xlLCByZXNwZXRpdmVseSBjYWxjdWxhdGluZyB5YXcgb25seS5cclxuICAgICAqL1xyXG4gICAgLy8gcHVibGljIHN0YXRpYyBTSE9XX1RPKF90cmFuc2xhdGlvbjogVmVjdG9yMywgX3RhcmdldDogVmVjdG9yMywgX3VwOiBWZWN0b3IzID0gVmVjdG9yMy5ZKCkpOiBNYXRyaXg0eDQge1xyXG4gICAgLy8gICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpO1xyXG4gICAgLy8gICBsZXQgekF4aXM6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3RhcmdldCwgX3RyYW5zbGF0aW9uKTtcclxuICAgIC8vICAgekF4aXMubm9ybWFsaXplKCk7XHJcbiAgICAvLyAgIGxldCB4QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuTk9STUFMSVpBVElPTihWZWN0b3IzLkNST1NTKF91cCwgekF4aXMpKTtcclxuICAgIC8vICAgLy8gbGV0IHlBeGlzOiBWZWN0b3IzID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoekF4aXMsIHhBeGlzKSk7XHJcbiAgICAvLyAgIHpBeGlzID0gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoeEF4aXMsIF91cCkpO1xyXG4gICAgLy8gICBtdHhSZXN1bHQuZGF0YS5zZXQoXHJcbiAgICAvLyAgICAgW1xyXG4gICAgLy8gICAgICAgeEF4aXMueCwgeEF4aXMueSwgeEF4aXMueiwgMCxcclxuICAgIC8vICAgICAgIF91cC54LCBfdXAueSwgX3VwLnosIDAsXHJcbiAgICAvLyAgICAgICB6QXhpcy54LCB6QXhpcy55LCB6QXhpcy56LCAwLFxyXG4gICAgLy8gICAgICAgX3RyYW5zbGF0aW9uLngsXHJcbiAgICAvLyAgICAgICBfdHJhbnNsYXRpb24ueSxcclxuICAgIC8vICAgICAgIF90cmFuc2xhdGlvbi56LFxyXG4gICAgLy8gICAgICAgMVxyXG4gICAgLy8gICAgIF0pO1xyXG4gICAgLy8gICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHRyYW5zbGF0ZXMgY29vcmRpbmF0ZXMgYWxvbmcgdGhlIHgtLCB5LSBhbmQgei1heGlzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjN9LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRSQU5TTEFUSU9OKF90cmFuc2xhdGU6IFZlY3RvcjMpOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDR4NCk7XHJcbiAgICAgIG10eFJlc3VsdC5zZXQoW1xyXG4gICAgICAgIDEsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgMSwgMCwgMCxcclxuICAgICAgICAwLCAwLCAxLCAwLFxyXG4gICAgICAgIF90cmFuc2xhdGUueCwgX3RyYW5zbGF0ZS55LCBfdHJhbnNsYXRlLnosIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyBvbiB0aGUgeC1heGlzIHdoZW4gbXVsdGlwbGllZCBieS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTl9YKF9hbmdsZUluRGVncmVlczogbnVtYmVyKTogTWF0cml4NHg0IHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5yZXVzZShNYXRyaXg0eDQpO1xyXG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIENhbGMuZGVnMnJhZDtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIG10eFJlc3VsdC5zZXQoW1xyXG4gICAgICAgIDEsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgY29zLCBzaW4sIDAsXHJcbiAgICAgICAgMCwgLXNpbiwgY29zLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyBvbiB0aGUgeS1heGlzIHdoZW4gbXVsdGlwbGllZCBieS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTl9ZKF9hbmdsZUluRGVncmVlczogbnVtYmVyKTogTWF0cml4NHg0IHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5yZXVzZShNYXRyaXg0eDQpO1xyXG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIENhbGMuZGVnMnJhZDtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIG10eFJlc3VsdC5zZXQoW1xyXG4gICAgICAgIGNvcywgMCwgLXNpbiwgMCxcclxuICAgICAgICAwLCAxLCAwLCAwLFxyXG4gICAgICAgIHNpbiwgMCwgY29zLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyBvbiB0aGUgei1heGlzIHdoZW4gbXVsdGlwbGllZCBieS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTl9aKF9hbmdsZUluRGVncmVlczogbnVtYmVyKTogTWF0cml4NHg0IHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5yZXVzZShNYXRyaXg0eDQpO1xyXG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIENhbGMuZGVnMnJhZDtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIG10eFJlc3VsdC5zZXQoW1xyXG4gICAgICAgIGNvcywgc2luLCAwLCAwLFxyXG4gICAgICAgIC1zaW4sIGNvcywgMCwgMCxcclxuICAgICAgICAwLCAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyB3aGVuIG11bHRpcGxpZWQgYnksIHVzaW5nIHRoZSByb3RhdGlvbiBldWxlciBhbmdsZXMgb3IgdW5pdCBxdWF0ZXJuaW9uIGdpdmVuLlxyXG4gICAgICogUm90YXRpb24gb2NjdXJzIGFyb3VuZCB0aGUgYXhpcyBpbiB0aGUgb3JkZXIgWi1ZLVguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT04oX3JvdGF0aW9uOiBWZWN0b3IzIHwgUXVhdGVybmlvbik6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAgIE1hdHJpeDR4NC5zZXRSb3RhdGlvbihtdHhSZXN1bHQuZGF0YSwgX3JvdGF0aW9uKTtcclxuICAgICAgcmV0dXJuIG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCBzY2FsZXMgY29vcmRpbmF0ZXMgYWxvbmcgdGhlIHgtLCB5LSBhbmQgei1heGlzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjN9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0NBTElORyhfc2NhbGFyOiBWZWN0b3IzKTogTWF0cml4NHg0IHtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5yZXVzZShNYXRyaXg0eDQpO1xyXG4gICAgICBtdHhSZXN1bHQuc2V0KFtcclxuICAgICAgICBfc2NhbGFyLngsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgX3NjYWxhci55LCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIF9zY2FsYXIueiwgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBtYXRyaXggcmVsYXRpdmUgdG8gdGhlIGdpdmVuIGJhc2UuXHJcbiAgICAgKiBJZiBrbm93biwgcGFzcyB0aGUgaW52ZXJzZSBvZiB0aGUgYmFzZSB0byBhdm9pZCB1bm5lY2Nlc2FyeSBjYWxjdWxhdGlvbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBSRUxBVElWRShfbXR4OiBNYXRyaXg0eDQsIF9tdHhCYXNlOiBNYXRyaXg0eDQsIF9tdHhJbnZlcnNlPzogTWF0cml4NHg0KTogTWF0cml4NHg0IHtcclxuICAgICAgaWYgKF9tdHhJbnZlcnNlKVxyXG4gICAgICAgIHJldHVybiBNYXRyaXg0eDQuUFJPRFVDVChfbXR4SW52ZXJzZSwgX210eCk7XHJcblxyXG4gICAgICBsZXQgbXR4SW52ZXJzZTogTWF0cml4NHg0ID0gTWF0cml4NHg0LklOVkVSU0UoX210eEJhc2UpO1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUFJPRFVDVChtdHhJbnZlcnNlLCBfbXR4KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4SW52ZXJzZSk7XHJcbiAgICAgIHJldHVybiBtdHhSZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gUFJPSkVDVElPTlNcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSBtYXRyaXggdGhhdCBhcHBsaWVzIHBlcnNwZWN0aXZlIHRvIGFuIG9iamVjdCwgaWYgaXRzIHRyYW5zZm9ybSBpcyBtdWx0aXBsaWVkIGJ5IGl0LlxyXG4gICAgICogQHBhcmFtIF9hc3BlY3QgVGhlIGFzcGVjdCByYXRpbyBiZXR3ZWVuIHdpZHRoIGFuZCBoZWlnaHQgb2YgcHJvamVjdGlvbnNwYWNlLihEZWZhdWx0ID0gY2FudmFzLmNsaWVudFdpZHRoIC8gY2FudmFzLkNsaWVudEhlaWdodClcclxuICAgICAqIEBwYXJhbSBfZmllbGRPZlZpZXdJbkRlZ3JlZXMgVGhlIGZpZWxkIG9mIHZpZXcgaW4gRGVncmVlcy4gKERlZmF1bHQgPSA0NSlcclxuICAgICAqIEBwYXJhbSBfbmVhciBUaGUgbmVhciBjbGlwc3BhY2UgYm9yZGVyIG9uIHRoZSB6LWF4aXMuXHJcbiAgICAgKiBAcGFyYW0gX2ZhciBUaGUgZmFyIGNsaXBzcGFjZSBib3JkZXIgb24gdGhlIHotYXhpcy5cclxuICAgICAqIEBwYXJhbSBfZGlyZWN0aW9uIFRoZSBwbGFuZSBvbiB3aGljaCB0aGUgZmllbGRPZlZpZXctQW5nbGUgaXMgZ2l2ZW4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUFJPSkVDVElPTl9DRU5UUkFMKF9hc3BlY3Q6IG51bWJlciwgX2ZpZWxkT2ZWaWV3SW5EZWdyZWVzOiBudW1iZXIsIF9uZWFyOiBudW1iZXIsIF9mYXI6IG51bWJlciwgX2RpcmVjdGlvbjogRklFTERfT0ZfVklFVyk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIC8vVE9ETzogY2FtZXJhIGxvb2tzIGRvd24gbmVnYXRpdmUgei1kaXJlY3Rpb24sIHNob3VsZCBiZSBwb3NpdGl2ZVxyXG4gICAgICBsZXQgZmllbGRPZlZpZXdJblJhZGlhbnM6IG51bWJlciA9IF9maWVsZE9mVmlld0luRGVncmVlcyAqIENhbGMuZGVnMnJhZDtcclxuICAgICAgbGV0IGY6IG51bWJlciA9IE1hdGgudGFuKDAuNSAqIChNYXRoLlBJIC0gZmllbGRPZlZpZXdJblJhZGlhbnMpKTtcclxuICAgICAgbGV0IHJhbmdlSW52OiBudW1iZXIgPSAxLjAgLyAoX25lYXIgLSBfZmFyKTtcclxuICAgICAgY29uc3QgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5yZXVzZShNYXRyaXg0eDQpO1xyXG4gICAgICBtdHhSZXN1bHQuc2V0KFtcclxuICAgICAgICBmLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIGYsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgKF9uZWFyICsgX2ZhcikgKiByYW5nZUludiwgLTEsXHJcbiAgICAgICAgMCwgMCwgX25lYXIgKiBfZmFyICogcmFuZ2VJbnYgKiAyLCAwXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgaWYgKF9kaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5ESUFHT05BTCkge1xyXG4gICAgICAgIF9hc3BlY3QgPSBNYXRoLnNxcnQoX2FzcGVjdCk7XHJcbiAgICAgICAgbXR4UmVzdWx0LmRhdGFbMF0gPSBmIC8gX2FzcGVjdDtcclxuICAgICAgICBtdHhSZXN1bHQuZGF0YVs1XSA9IGYgKiBfYXNwZWN0O1xyXG4gICAgICB9IGVsc2UgaWYgKF9kaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5WRVJUSUNBTClcclxuICAgICAgICBtdHhSZXN1bHQuZGF0YVswXSA9IGYgLyBfYXNwZWN0O1xyXG4gICAgICBlbHNlIC8vRk9WX0RJUkVDVElPTi5IT1JJWk9OVEFMXHJcbiAgICAgICAgbXR4UmVzdWx0LmRhdGFbNV0gPSBmICogX2FzcGVjdDtcclxuXHJcbiAgICAgIC8vIEhBQ0s6IG1hdHJpeCBzaG91bGQgbG9vayBpbiBwb3NpdGl2ZSB6LWRpcmVjdGlvbiwgcHJlZmVyYWJseSB0aGUgbWF0cml4IHNob3VsZCBiZSBjYWxjdWxhdGVkIGxpa2UgdGhhdCByaWdodCBhd2F5XHJcbiAgICAgIG10eFJlc3VsdC5yb3RhdGVZKDE4MCk7XHJcblxyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSBtYXRyaXggdGhhdCBhcHBsaWVzIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIHRvIGFuIG9iamVjdCwgaWYgaXRzIHRyYW5zZm9ybSBpcyBtdWx0aXBsaWVkIGJ5IGl0LlxyXG4gICAgICogQHBhcmFtIF9sZWZ0IFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyBsZWZ0IGJvcmRlci5cclxuICAgICAqIEBwYXJhbSBfcmlnaHQgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIHJpZ2h0IGJvcmRlci5cclxuICAgICAqIEBwYXJhbSBfYm90dG9tIFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyBib3R0b20gYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF90b3AgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIHRvcCBib3JkZXIuXHJcbiAgICAgKiBAcGFyYW0gX25lYXIgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIG5lYXIgYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF9mYXIgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGZhciBib3JkZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBQUk9KRUNUSU9OX09SVEhPR1JBUEhJQyhfbGVmdDogbnVtYmVyLCBfcmlnaHQ6IG51bWJlciwgX2JvdHRvbTogbnVtYmVyLCBfdG9wOiBudW1iZXIsIF9uZWFyOiBudW1iZXIgPSAtNDAwLCBfZmFyOiBudW1iZXIgPSA0MDApOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDR4NCk7XHJcbiAgICAgIG10eFJlc3VsdC5zZXQoW1xyXG4gICAgICAgIDIgLyAoX3JpZ2h0IC0gX2xlZnQpLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIC0yIC8gKF90b3AgLSBfYm90dG9tKSwgMCwgMCxcclxuICAgICAgICAwLCAwLCAyIC8gKF9mYXIgLSBfbmVhciksIDAsXHJcbiAgICAgICAgKF9sZWZ0ICsgX3JpZ2h0KSAvIChfbGVmdCAtIF9yaWdodCksXHJcbiAgICAgICAgKF9ib3R0b20gKyBfdG9wKSAvIChfYm90dG9tIC0gX3RvcCksXHJcbiAgICAgICAgKF9uZWFyICsgX2ZhcikgLyAoX25lYXIgLSBfZmFyKSxcclxuICAgICAgICAxXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gbXR4UmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSByb3RhdGlvbiBwYXJ0IG9mIHRoZSBnaXZlbiBtYXRyaXhlcyBkYXRhIGFycmF5IHRvIHRoZSBnaXZlbiByb3RhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgc2V0Um90YXRpb24oX206IEZsb2F0MzJBcnJheSwgX3JvdGF0aW9uOiBWZWN0b3IzIHwgUXVhdGVybmlvbik6IHZvaWQge1xyXG4gICAgICBpZiAoX3JvdGF0aW9uIGluc3RhbmNlb2YgVmVjdG9yMykge1xyXG4gICAgICAgIGNvbnN0IGFuZ2xlc1JhZDogVmVjdG9yMyA9IFZlY3RvcjMuU0NBTEUoX3JvdGF0aW9uLCBDYWxjLmRlZzJyYWQpO1xyXG4gICAgICAgIGNvbnN0IHNpblg6IG51bWJlciA9IE1hdGguc2luKGFuZ2xlc1JhZC54KTtcclxuICAgICAgICBjb25zdCBjb3NYOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZXNSYWQueCk7XHJcbiAgICAgICAgY29uc3Qgc2luWTogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVzUmFkLnkpO1xyXG4gICAgICAgIGNvbnN0IGNvc1k6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlc1JhZC55KTtcclxuICAgICAgICBjb25zdCBzaW5aOiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZXNSYWQueik7XHJcbiAgICAgICAgY29uc3QgY29zWjogbnVtYmVyID0gTWF0aC5jb3MoYW5nbGVzUmFkLnopO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKGFuZ2xlc1JhZCk7XHJcblxyXG4gICAgICAgIF9tWzBdID0gY29zWiAqIGNvc1k7IC8qKi8gICAgICAgICAgICAgICAgIF9tWzFdID0gc2luWiAqIGNvc1k7IC8qKi8gICAgICAgICAgICAgICAgIF9tWzJdID0gLXNpblk7XHJcbiAgICAgICAgX21bNF0gPSBjb3NaICogc2luWSAqIHNpblggLSBzaW5aICogY29zWDsgX21bNV0gPSBzaW5aICogc2luWSAqIHNpblggKyBjb3NaICogY29zWDsgX21bNl0gPSBjb3NZICogc2luWDtcclxuICAgICAgICBfbVs4XSA9IGNvc1ogKiBzaW5ZICogY29zWCArIHNpblogKiBzaW5YOyBfbVs5XSA9IHNpblogKiBzaW5ZICogY29zWCAtIGNvc1ogKiBzaW5YOyBfbVsxMF0gPSBjb3NZICogY29zWDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBjb25zdCByb3RhdGlvbk5vcm1hbGl6ZWQ6IFF1YXRlcm5pb24gPSBRdWF0ZXJuaW9uLk5PUk1BTElaQVRJT04oX3JvdGF0aW9uKTtcclxuICAgICAgICBjb25zdCB4OiBudW1iZXIgPSBfcm90YXRpb24ueCwgeTogbnVtYmVyID0gX3JvdGF0aW9uLnksIHo6IG51bWJlciA9IF9yb3RhdGlvbi56LCB3OiBudW1iZXIgPSBfcm90YXRpb24udztcclxuICAgICAgICBjb25zdCB4eDogbnVtYmVyID0geCAqIHgsIHh5OiBudW1iZXIgPSB4ICogeSwgeHo6IG51bWJlciA9IHggKiB6LCB4dzogbnVtYmVyID0geCAqIHc7XHJcbiAgICAgICAgY29uc3QgeXk6IG51bWJlciA9IHkgKiB5LCB5ejogbnVtYmVyID0geSAqIHosIHl3OiBudW1iZXIgPSB5ICogdztcclxuICAgICAgICBjb25zdCB6ejogbnVtYmVyID0geiAqIHosIHp3OiBudW1iZXIgPSB6ICogdztcclxuICAgICAgICBjb25zdCB3dzogbnVtYmVyID0gdyAqIHc7XHJcblxyXG4gICAgICAgIF9tWzBdID0gd3cgKyB4eCAtIHl5IC0geno7IF9tWzFdID0gMiAqICh4eSArIHp3KTsvKiovIF9tWzJdID0gMiAqICh4eiAtIHl3KTtcclxuICAgICAgICBfbVs0XSA9IDIgKiAoeHkgLSB6dyk7LyoqLyBfbVs1XSA9IHd3IC0geHggKyB5eSAtIHp6OyBfbVs2XSA9IDIgKiAoeXogKyB4dyk7XHJcbiAgICAgICAgX21bOF0gPSAyICogKHh6ICsgeXcpOy8qKi8gX21bOV0gPSAyICogKHl6IC0geHcpOy8qKi8gX21bMTBdID0gd3cgLSB4eCAtIHl5ICsgeno7XHJcblxyXG4gICAgICAgIC8vIF9tWzBdID0gMSAtIDIgKiAoeXkgKyB6eik7IF9tWzFdID0gMiAqICh4eSArIHp3KTsvKiovIF9tWzJdID0gMiAqICh4eiAtIHl3KTtcclxuICAgICAgICAvLyBfbVs0XSA9IDIgKiAoeHkgLSB6dyk7LyoqLyBfbVs1XSA9IDEgLSAyICogKHh4ICsgenopOyBfbVs2XSA9IDIgKiAoeXogKyB4dyk7XHJcbiAgICAgICAgLy8gX21bOF0gPSAyICogKHh6ICsgeXcpOy8qKi8gX21bOV0gPSAyICogKHl6IC0geHcpOy8qKi8gX21bMTBdID0gMSAtIDIgKiAoeHggKyB5eSk7XHJcbiAgICAgICAgLy8gUmVjeWNsZXIuc3RvcmUocm90YXRpb25Ob3JtYWxpemVkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uICBBY2Nlc3NvcnNcclxuICAgIC8qKiBcclxuICAgICAqIC0gZ2V0OiByZXR1cm4gYSB2ZWN0b3IgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zbGF0aW9uIHtAbGluayBWZWN0b3IzfS4gIFxyXG4gICAgICogKipDYXV0aW9uISoqIFVzZSBpbW1lZGlhdGVseSBhbmQgcmVhZG9ubHksIHNpbmNlIHRoZSB2ZWN0b3IgaXMgZ29pbmcgdG8gYmUgcmV1c2VkIGludGVybmFsbHkuIENyZWF0ZSBhIGNsb25lIHRvIGtlZXAgbG9uZ2VyIGFuZCBtYW5pcHVsYXRlLiBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeCBpZ25vcmluZyBpdHMgcm90YXRpb24gYW5kIHNjYWxpbmdcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB0cmFuc2xhdGlvbigpOiBWZWN0b3IzIHtcclxuICAgICAgaWYgKHRoaXMuI3RyYW5zbGF0aW9uRGlydHkpIHtcclxuICAgICAgICB0aGlzLiN0cmFuc2xhdGlvbi5zZXQodGhpcy5kYXRhWzEyXSwgdGhpcy5kYXRhWzEzXSwgdGhpcy5kYXRhWzE0XSk7XHJcbiAgICAgICAgdGhpcy4jdHJhbnNsYXRpb25EaXJ0eSA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLiN0cmFuc2xhdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgdHJhbnNsYXRpb24oX3RyYW5zbGF0aW9uOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMubXV0YXRlKHsgXCJ0cmFuc2xhdGlvblwiOiBfdHJhbnNsYXRpb24gfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IHJldHVybiBhIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGUgcm90YXRpb24ge0BsaW5rIFZlY3RvcjN9LiAgXHJcbiAgICAgKiAqKkNhdXRpb24hKiogVXNlIGltbWVkaWF0ZWx5IGFuZCByZWFkb25seSwgc2luY2UgdGhlIHZlY3RvciBpcyBnb2luZyB0byBiZSByZXVzZWQgaW50ZXJuYWxseS4gQ3JlYXRlIGEgY2xvbmUgdG8ga2VlcCBsb25nZXIgYW5kIG1hbmlwdWxhdGUuIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcm90YXRpb24oKTogVmVjdG9yMyB7XHJcbiAgICAgIGlmICh0aGlzLiNyb3RhdGlvbkRpcnR5KSB7XHJcbiAgICAgICAgbGV0IHNjYWxpbmc6IFZlY3RvcjMgPSB0aGlzLnNjYWxpbmc7XHJcblxyXG4gICAgICAgIGxldCBzMDogbnVtYmVyID0gdGhpcy5kYXRhWzBdIC8gc2NhbGluZy54O1xyXG4gICAgICAgIGxldCBzMTogbnVtYmVyID0gdGhpcy5kYXRhWzFdIC8gc2NhbGluZy54O1xyXG4gICAgICAgIGxldCBzMjogbnVtYmVyID0gdGhpcy5kYXRhWzJdIC8gc2NhbGluZy54O1xyXG4gICAgICAgIGxldCBzNjogbnVtYmVyID0gdGhpcy5kYXRhWzZdIC8gc2NhbGluZy55O1xyXG4gICAgICAgIGxldCBzMTA6IG51bWJlciA9IHRoaXMuZGF0YVsxMF0gLyBzY2FsaW5nLno7XHJcblxyXG4gICAgICAgIGxldCBzeTogbnVtYmVyID0gTWF0aC5oeXBvdChzMCwgczEpOyAvLyBwcm9iYWJseSAyLiBwYXJhbSBzaG91bGQgYmUgdGhpcy5kYXRhWzRdIC8gc2NhbGluZy55XHJcblxyXG4gICAgICAgIGxldCBzaW5ndWxhcjogYm9vbGVhbiA9IHN5IDwgMWUtNjsgLy8gSWZcclxuXHJcbiAgICAgICAgbGV0IHgxOiBudW1iZXIsIHkxOiBudW1iZXIsIHoxOiBudW1iZXI7XHJcbiAgICAgICAgbGV0IHgyOiBudW1iZXIsIHkyOiBudW1iZXIsIHoyOiBudW1iZXI7XHJcblxyXG4gICAgICAgIGlmICghc2luZ3VsYXIpIHtcclxuICAgICAgICAgIHgxID0gTWF0aC5hdGFuMihzNiwgczEwKTtcclxuICAgICAgICAgIHkxID0gTWF0aC5hdGFuMigtczIsIHN5KTtcclxuICAgICAgICAgIHoxID0gTWF0aC5hdGFuMihzMSwgczApO1xyXG5cclxuICAgICAgICAgIHgyID0gTWF0aC5hdGFuMigtczYsIC1zMTApO1xyXG4gICAgICAgICAgeTIgPSBNYXRoLmF0YW4yKC1zMiwgLXN5KTtcclxuICAgICAgICAgIHoyID0gTWF0aC5hdGFuMigtczEsIC1zMCk7XHJcblxyXG4gICAgICAgICAgaWYgKE1hdGguYWJzKHgyKSArIE1hdGguYWJzKHkyKSArIE1hdGguYWJzKHoyKSA8IE1hdGguYWJzKHgxKSArIE1hdGguYWJzKHkxKSArIE1hdGguYWJzKHoxKSkge1xyXG4gICAgICAgICAgICB4MSA9IHgyO1xyXG4gICAgICAgICAgICB5MSA9IHkyO1xyXG4gICAgICAgICAgICB6MSA9IHoyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4MSA9IE1hdGguYXRhbjIoLXRoaXMuZGF0YVs5XSAvIHNjYWxpbmcueiwgdGhpcy5kYXRhWzVdIC8gc2NhbGluZy55KTtcclxuICAgICAgICAgIHkxID0gTWF0aC5hdGFuMigtdGhpcy5kYXRhWzJdIC8gc2NhbGluZy54LCBzeSk7XHJcbiAgICAgICAgICB6MSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLiNyb3RhdGlvbi5zZXQoeDEsIHkxLCB6MSk7XHJcbiAgICAgICAgdGhpcy4jcm90YXRpb24uc2NhbGUoQ2FsYy5yYWQyZGVnKTtcclxuICAgICAgICB0aGlzLiNyb3RhdGlvbkRpcnR5ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLiNyb3RhdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgcm90YXRpb24oX3JvdGF0aW9uOiBRdWF0ZXJuaW9uIHwgVmVjdG9yMykge1xyXG4gICAgICB0aGlzLm11dGF0ZSh7IFwicm90YXRpb25cIjogX3JvdGF0aW9uIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIC0gZ2V0OiByZXR1cm4gYSB2ZWN0b3IgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNjYWxpbmcge0BsaW5rIFZlY3RvcjN9LiAgXHJcbiAgICAgKiAqKkNhdXRpb24hKiogVXNlIGltbWVkaWF0ZWx5IGFuZCByZWFkb25seSwgc2luY2UgdGhlIHZlY3RvciBpcyBnb2luZyB0byBiZSByZXVzZWQgaW50ZXJuYWxseS4gQ3JlYXRlIGEgY2xvbmUgdG8ga2VlcCBsb25nZXIgYW5kIG1hbmlwdWxhdGUuIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc2NhbGluZygpOiBWZWN0b3IzIHtcclxuICAgICAgaWYgKHRoaXMuI3NjYWxpbmdEaXJ0eSkge1xyXG4gICAgICAgIHRoaXMuI3NjYWxpbmcuc2V0KFxyXG4gICAgICAgICAgTWF0aC5oeXBvdCh0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdKSwgLy8qICh0aGlzLmRhdGFbMF0gPCAwID8gLTEgOiAxKSxcclxuICAgICAgICAgIE1hdGguaHlwb3QodGhpcy5kYXRhWzRdLCB0aGlzLmRhdGFbNV0sIHRoaXMuZGF0YVs2XSksIC8vKiAodGhpcy5kYXRhWzVdIDwgMCA/IC0xIDogMSksXHJcbiAgICAgICAgICBNYXRoLmh5cG90KHRoaXMuZGF0YVs4XSwgdGhpcy5kYXRhWzldLCB0aGlzLmRhdGFbMTBdKSAvLyAqICh0aGlzLmRhdGFbMTBdIDwgMCA/IC0xIDogMSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBpZiAodGhpcy5kZXRlcm1pbmFudCA8IDApIC8vIOKaoO+4j0VYUEVSTUlORVRBTCBmcm9tIHRocmVlIGpzOiBpZiBkZXRlcm1pbmFudCBpcyBuZWdhdGl2ZSwgaW52ZXJ0IG9uZSBzY2FsZVxyXG4gICAgICAgIC8vICAgdGhpcy4jc2NhbGluZy54ID0gLXRoaXMuI3NjYWxpbmcueDtcclxuXHJcbiAgICAgICAgdGhpcy4jc2NhbGluZ0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuI3NjYWxpbmc7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNjYWxpbmcoX3NjYWxpbmc6IFZlY3RvcjMpIHtcclxuICAgICAgdGhpcy5tdXRhdGUoeyBcInNjYWxpbmdcIjogX3NjYWxpbmcgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IHJldHVybiBhIHVuaXQgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICogKipDYXV0aW9uISoqIFVzZSBpbW1lZGlhdGVseSBhbmQgcmVhZG9ubHksIHNpbmNlIHRoZSBxdWF0ZXJuaW9uIGlzIGdvaW5nIHRvIGJlIHJldXNlZCBpbnRlcm5hbGx5LiBDcmVhdGUgYSBjbG9uZSB0byBrZWVwIGxvbmdlciBhbmQgbWFuaXB1bGF0ZS4gXHJcbiAgICAgKiAtIHNldDogZWZmZWN0IHRoZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBxdWF0ZXJuaW9uKCk6IFF1YXRlcm5pb24ge1xyXG4gICAgICBpZiAodGhpcy4jcXVhdGVybmlvbkRpcnR5KSB7XHJcbiAgICAgICAgdGhpcy4jcXVhdGVybmlvbi5ldWxlckFuZ2xlcyA9IHRoaXMucm90YXRpb247XHJcbiAgICAgICAgdGhpcy4jcXVhdGVybmlvbkRpcnR5ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLiNxdWF0ZXJuaW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBxdWF0ZXJuaW9uKF9xdWF0ZXJuaW9uOiBRdWF0ZXJuaW9uKSB7XHJcbiAgICAgIHRoaXMubXV0YXRlKHsgXCJyb3RhdGlvblwiOiBfcXVhdGVybmlvbiB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRldGVybWluYW50IG9mIHRoaXMgbWF0cml4LiBDb21wdXRhdGlvbmFsIGhlYXZ5IG9wZXJhdGlvbiwgbm90IGNhY2hlZCBzbyB1c2Ugd2l0aCBjYXJlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGRldGVybWluYW50KCk6IG51bWJlciB7XHJcbiAgICAgIGNvbnN0IG06IEZsb2F0MzJBcnJheSA9IHRoaXMuZGF0YTtcclxuXHJcbiAgICAgIGNvbnN0IGRldDAwOiBudW1iZXIgPSBtWzEwXSAqIG1bMTVdIC0gbVsxMV0gKiBtWzE0XTtcclxuICAgICAgY29uc3QgZGV0MDE6IG51bWJlciA9IG1bOV0gKiBtWzE1XSAtIG1bMTFdICogbVsxM107XHJcbiAgICAgIGNvbnN0IGRldDAyOiBudW1iZXIgPSBtWzldICogbVsxNF0gLSBtWzEwXSAqIG1bMTNdO1xyXG4gICAgICBjb25zdCBkZXQwMzogbnVtYmVyID0gbVs4XSAqIG1bMTVdIC0gbVsxMV0gKiBtWzEyXTtcclxuICAgICAgY29uc3QgZGV0MDQ6IG51bWJlciA9IG1bOF0gKiBtWzE0XSAtIG1bMTBdICogbVsxMl07XHJcbiAgICAgIGNvbnN0IGRldDA1OiBudW1iZXIgPSBtWzhdICogbVsxM10gLSBtWzldICogbVsxMl07XHJcblxyXG4gICAgICBjb25zdCBkZXQ6IG51bWJlciA9XHJcbiAgICAgICAgbVswXSAqIChtWzVdICogZGV0MDAgLSBtWzZdICogZGV0MDEgKyBtWzddICogZGV0MDIpIC1cclxuICAgICAgICBtWzFdICogKG1bNF0gKiBkZXQwMCAtIG1bNl0gKiBkZXQwMyArIG1bN10gKiBkZXQwNCkgK1xyXG4gICAgICAgIG1bMl0gKiAobVs0XSAqIGRldDAxIC0gbVs1XSAqIGRldDAzICsgbVs3XSAqIGRldDA1KSAtXHJcbiAgICAgICAgbVszXSAqIChtWzRdICogZGV0MDIgLSBtWzVdICogZGV0MDQgKyBtWzZdICogZGV0MDUpO1xyXG5cclxuICAgICAgcmV0dXJuIGRldDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgY2FyZGluYWwgeC1heGlzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHJpZ2h0KCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgcmlnaHQ6IFZlY3RvcjMgPSB0aGlzLmdldFgoKTtcclxuICAgICAgcmlnaHQubm9ybWFsaXplKCk7XHJcbiAgICAgIHJldHVybiByaWdodDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgY2FyZGluYWwgeS1heGlzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHVwKCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdXA6IFZlY3RvcjMgPSB0aGlzLmdldFkoKTtcclxuICAgICAgdXAubm9ybWFsaXplKCk7XHJcbiAgICAgIHJldHVybiB1cDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgY2FyZGluYWwgei1heGlzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGZvcndhcmQoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBmb3J3YXJkOiBWZWN0b3IzID0gdGhpcy5nZXRaKCk7XHJcbiAgICAgIGZvcndhcmQubm9ybWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBmb3J3YXJkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGNsb25lIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNsb25lKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiBSZWN5Y2xlci5yZXVzZShNYXRyaXg0eDQpLmNvcHkodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgbWF0cml4IHRvIHRoZSBpZGVudGl0eS1tYXRyaXggYW5kIGNsZWFycyBjYWNoZS4gVXNlZCBieSB0aGUgcmVjeWNsZXIgdG8gcmVzZXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldChbXHJcbiAgICAgICAgMSwgMCwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIDEsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICBdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgbWF0cml4IHRvIHRoZSBpZGVudGl0eS1tYXRyaXggYW5kIGNsZWFycyBjYWNoZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnJlY3ljbGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zcG9zZSB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNwb3NlKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCBtOiBGbG9hdDMyQXJyYXkgPSB0aGlzLmRhdGE7XHJcbiAgICAgIHRoaXMuc2V0KFtcclxuICAgICAgICBtWzBdLCBtWzRdLCBtWzhdLCBtWzEyXSxcclxuICAgICAgICBtWzFdLCBtWzVdLCBtWzldLCBtWzEzXSxcclxuICAgICAgICBtWzJdLCBtWzZdLCBtWzEwXSwgbVsxNF0sXHJcbiAgICAgICAgbVszXSwgbVs3XSwgbVsxMV0sIG1bMTVdXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludmVydCB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW52ZXJ0KCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCBtOiBGbG9hdDMyQXJyYXkgPSB0aGlzLmRhdGE7XHJcbiAgICAgIGxldCBtMDA6IG51bWJlciA9IG1bMCAqIDQgKyAwXTtcclxuICAgICAgbGV0IG0wMTogbnVtYmVyID0gbVswICogNCArIDFdO1xyXG4gICAgICBsZXQgbTAyOiBudW1iZXIgPSBtWzAgKiA0ICsgMl07XHJcbiAgICAgIGxldCBtMDM6IG51bWJlciA9IG1bMCAqIDQgKyAzXTtcclxuICAgICAgbGV0IG0xMDogbnVtYmVyID0gbVsxICogNCArIDBdO1xyXG4gICAgICBsZXQgbTExOiBudW1iZXIgPSBtWzEgKiA0ICsgMV07XHJcbiAgICAgIGxldCBtMTI6IG51bWJlciA9IG1bMSAqIDQgKyAyXTtcclxuICAgICAgbGV0IG0xMzogbnVtYmVyID0gbVsxICogNCArIDNdO1xyXG4gICAgICBsZXQgbTIwOiBudW1iZXIgPSBtWzIgKiA0ICsgMF07XHJcbiAgICAgIGxldCBtMjE6IG51bWJlciA9IG1bMiAqIDQgKyAxXTtcclxuICAgICAgbGV0IG0yMjogbnVtYmVyID0gbVsyICogNCArIDJdO1xyXG4gICAgICBsZXQgbTIzOiBudW1iZXIgPSBtWzIgKiA0ICsgM107XHJcbiAgICAgIGxldCBtMzA6IG51bWJlciA9IG1bMyAqIDQgKyAwXTtcclxuICAgICAgbGV0IG0zMTogbnVtYmVyID0gbVszICogNCArIDFdO1xyXG4gICAgICBsZXQgbTMyOiBudW1iZXIgPSBtWzMgKiA0ICsgMl07XHJcbiAgICAgIGxldCBtMzM6IG51bWJlciA9IG1bMyAqIDQgKyAzXTtcclxuICAgICAgbGV0IHRtcDA6IG51bWJlciA9IG0yMiAqIG0zMztcclxuICAgICAgbGV0IHRtcDE6IG51bWJlciA9IG0zMiAqIG0yMztcclxuICAgICAgbGV0IHRtcDI6IG51bWJlciA9IG0xMiAqIG0zMztcclxuICAgICAgbGV0IHRtcDM6IG51bWJlciA9IG0zMiAqIG0xMztcclxuICAgICAgbGV0IHRtcDQ6IG51bWJlciA9IG0xMiAqIG0yMztcclxuICAgICAgbGV0IHRtcDU6IG51bWJlciA9IG0yMiAqIG0xMztcclxuICAgICAgbGV0IHRtcDY6IG51bWJlciA9IG0wMiAqIG0zMztcclxuICAgICAgbGV0IHRtcDc6IG51bWJlciA9IG0zMiAqIG0wMztcclxuICAgICAgbGV0IHRtcDg6IG51bWJlciA9IG0wMiAqIG0yMztcclxuICAgICAgbGV0IHRtcDk6IG51bWJlciA9IG0yMiAqIG0wMztcclxuICAgICAgbGV0IHRtcDEwOiBudW1iZXIgPSBtMDIgKiBtMTM7XHJcbiAgICAgIGxldCB0bXAxMTogbnVtYmVyID0gbTEyICogbTAzO1xyXG4gICAgICBsZXQgdG1wMTI6IG51bWJlciA9IG0yMCAqIG0zMTtcclxuICAgICAgbGV0IHRtcDEzOiBudW1iZXIgPSBtMzAgKiBtMjE7XHJcbiAgICAgIGxldCB0bXAxNDogbnVtYmVyID0gbTEwICogbTMxO1xyXG4gICAgICBsZXQgdG1wMTU6IG51bWJlciA9IG0zMCAqIG0xMTtcclxuICAgICAgbGV0IHRtcDE2OiBudW1iZXIgPSBtMTAgKiBtMjE7XHJcbiAgICAgIGxldCB0bXAxNzogbnVtYmVyID0gbTIwICogbTExO1xyXG4gICAgICBsZXQgdG1wMTg6IG51bWJlciA9IG0wMCAqIG0zMTtcclxuICAgICAgbGV0IHRtcDE5OiBudW1iZXIgPSBtMzAgKiBtMDE7XHJcbiAgICAgIGxldCB0bXAyMDogbnVtYmVyID0gbTAwICogbTIxO1xyXG4gICAgICBsZXQgdG1wMjE6IG51bWJlciA9IG0yMCAqIG0wMTtcclxuICAgICAgbGV0IHRtcDIyOiBudW1iZXIgPSBtMDAgKiBtMTE7XHJcbiAgICAgIGxldCB0bXAyMzogbnVtYmVyID0gbTEwICogbTAxO1xyXG5cclxuICAgICAgbGV0IHQwOiBudW1iZXIgPSAodG1wMCAqIG0xMSArIHRtcDMgKiBtMjEgKyB0bXA0ICogbTMxKSAtXHJcbiAgICAgICAgKHRtcDEgKiBtMTEgKyB0bXAyICogbTIxICsgdG1wNSAqIG0zMSk7XHJcblxyXG4gICAgICBsZXQgdDE6IG51bWJlciA9ICh0bXAxICogbTAxICsgdG1wNiAqIG0yMSArIHRtcDkgKiBtMzEpIC1cclxuICAgICAgICAodG1wMCAqIG0wMSArIHRtcDcgKiBtMjEgKyB0bXA4ICogbTMxKTtcclxuICAgICAgbGV0IHQyOiBudW1iZXIgPSAodG1wMiAqIG0wMSArIHRtcDcgKiBtMTEgKyB0bXAxMCAqIG0zMSkgLVxyXG4gICAgICAgICh0bXAzICogbTAxICsgdG1wNiAqIG0xMSArIHRtcDExICogbTMxKTtcclxuICAgICAgbGV0IHQzOiBudW1iZXIgPSAodG1wNSAqIG0wMSArIHRtcDggKiBtMTEgKyB0bXAxMSAqIG0yMSkgLVxyXG4gICAgICAgICh0bXA0ICogbTAxICsgdG1wOSAqIG0xMSArIHRtcDEwICogbTIxKTtcclxuXHJcbiAgICAgIGxldCBkOiBudW1iZXIgPSAxLjAgLyAobTAwICogdDAgKyBtMTAgKiB0MSArIG0yMCAqIHQyICsgbTMwICogdDMpO1xyXG5cclxuICAgICAgdGhpcy5zZXQoW1xyXG4gICAgICAgIGQgKiB0MCwgLy8gWzBdXHJcbiAgICAgICAgZCAqIHQxLCAvLyBbMV1cclxuICAgICAgICBkICogdDIsIC8vIFsyXVxyXG4gICAgICAgIGQgKiB0MywgLy8gWzNdXHJcbiAgICAgICAgZCAqICgodG1wMSAqIG0xMCArIHRtcDIgKiBtMjAgKyB0bXA1ICogbTMwKSAtICh0bXAwICogbTEwICsgdG1wMyAqIG0yMCArIHRtcDQgKiBtMzApKSwgICAgICAgIC8vIFs0XVxyXG4gICAgICAgIGQgKiAoKHRtcDAgKiBtMDAgKyB0bXA3ICogbTIwICsgdG1wOCAqIG0zMCkgLSAodG1wMSAqIG0wMCArIHRtcDYgKiBtMjAgKyB0bXA5ICogbTMwKSksICAgICAgICAvLyBbNV1cclxuICAgICAgICBkICogKCh0bXAzICogbTAwICsgdG1wNiAqIG0xMCArIHRtcDExICogbTMwKSAtICh0bXAyICogbTAwICsgdG1wNyAqIG0xMCArIHRtcDEwICogbTMwKSksICAgICAgLy8gWzZdXHJcbiAgICAgICAgZCAqICgodG1wNCAqIG0wMCArIHRtcDkgKiBtMTAgKyB0bXAxMCAqIG0yMCkgLSAodG1wNSAqIG0wMCArIHRtcDggKiBtMTAgKyB0bXAxMSAqIG0yMCkpLCAgICAgIC8vIFs3XVxyXG4gICAgICAgIGQgKiAoKHRtcDEyICogbTEzICsgdG1wMTUgKiBtMjMgKyB0bXAxNiAqIG0zMykgLSAodG1wMTMgKiBtMTMgKyB0bXAxNCAqIG0yMyArIHRtcDE3ICogbTMzKSksICAvLyBbOF1cclxuICAgICAgICBkICogKCh0bXAxMyAqIG0wMyArIHRtcDE4ICogbTIzICsgdG1wMjEgKiBtMzMpIC0gKHRtcDEyICogbTAzICsgdG1wMTkgKiBtMjMgKyB0bXAyMCAqIG0zMykpLCAgLy8gWzldXHJcbiAgICAgICAgZCAqICgodG1wMTQgKiBtMDMgKyB0bXAxOSAqIG0xMyArIHRtcDIyICogbTMzKSAtICh0bXAxNSAqIG0wMyArIHRtcDE4ICogbTEzICsgdG1wMjMgKiBtMzMpKSwgIC8vIFsxMF1cclxuICAgICAgICBkICogKCh0bXAxNyAqIG0wMyArIHRtcDIwICogbTEzICsgdG1wMjMgKiBtMjMpIC0gKHRtcDE2ICogbTAzICsgdG1wMjEgKiBtMTMgKyB0bXAyMiAqIG0yMykpLCAgLy8gWzExXVxyXG4gICAgICAgIGQgKiAoKHRtcDE0ICogbTIyICsgdG1wMTcgKiBtMzIgKyB0bXAxMyAqIG0xMikgLSAodG1wMTYgKiBtMzIgKyB0bXAxMiAqIG0xMiArIHRtcDE1ICogbTIyKSksICAvLyBbMTJdXHJcbiAgICAgICAgZCAqICgodG1wMjAgKiBtMzIgKyB0bXAxMiAqIG0wMiArIHRtcDE5ICogbTIyKSAtICh0bXAxOCAqIG0yMiArIHRtcDIxICogbTMyICsgdG1wMTMgKiBtMDIpKSwgIC8vIFsxM11cclxuICAgICAgICBkICogKCh0bXAxOCAqIG0xMiArIHRtcDIzICogbTMyICsgdG1wMTUgKiBtMDIpIC0gKHRtcDIyICogbTMyICsgdG1wMTQgKiBtMDIgKyB0bXAxOSAqIG0xMikpLCAgLy8gWzE0XVxyXG4gICAgICAgIGQgKiAoKHRtcDIyICogbTIyICsgdG1wMTYgKiBtMDIgKyB0bXAyMSAqIG0xMikgLSAodG1wMjAgKiBtMTIgKyB0bXAyMyAqIG0yMiArIHRtcDE3ICogbTAyKSkgIC8vIFsxNV1cclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2xhdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgdHJhbnNsYXRpb24gYnkgdGhlIGdpdmVuIHtAbGluayBWZWN0b3IzfSB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqIElmIF9sb2NhbCBpcyB0cnVlLCB0aGUgdHJhbnNsYXRpb24gb2NjdXJzIGFjY29yZGluZyB0byB0aGUgY3VycmVudCByb3RhdGlvbiBhbmQgc2NhbGluZyBvZiB0aGlzIG1hdHJpeCxcclxuICAgICAqIG90aGVyd2lzZSwgaXQgb2NjdXJzIGFjY29yZGluZyB0byB0aGUgcGFyZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlKF9ieTogVmVjdG9yMywgX2xvY2FsOiBib29sZWFuID0gdHJ1ZSk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGlmIChfbG9jYWwpIHtcclxuICAgICAgICBsZXQgbXR4VHJhbnNsYXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5UUkFOU0xBVElPTihfYnkpO1xyXG4gICAgICAgIGxldCByb3RhdGlvbkRpcnR5OiBib29sZWFuID0gdGhpcy4jcm90YXRpb25EaXJ0eTsgLy8gcHJlc2VydmUgZGlydHkgZmxhZ3MgZm9yIHJvdGF0aW9uIGFuZCBzY2FsaW5nIGFzIHRoZXkgYXJlIG5vdCBhZmZlY3RlZCBieSB0cmFuc2xhdGlvblxyXG4gICAgICAgIGxldCBzY2FsaW5nRGlydHk6IGJvb2xlYW4gPSB0aGlzLiNzY2FsaW5nRGlydHk7XHJcbiAgICAgICAgdGhpcy5tdWx0aXBseShtdHhUcmFuc2xhdGlvbik7XHJcbiAgICAgICAgdGhpcy4jcm90YXRpb25EaXJ0eSA9IHJvdGF0aW9uRGlydHk7XHJcbiAgICAgICAgdGhpcy4jc2NhbGluZ0RpcnR5ID0gc2NhbGluZ0RpcnR5O1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFRyYW5zbGF0aW9uKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRhdGFbMTJdICs9IF9ieS54O1xyXG4gICAgICAgIHRoaXMuZGF0YVsxM10gKz0gX2J5Lnk7XHJcbiAgICAgICAgdGhpcy5kYXRhWzE0XSArPSBfYnkuejtcclxuICAgICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuI3RyYW5zbGF0aW9uRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5NVUxUSVBMSUNBVElPTih0aGlzLCBNYXRyaXg0eDQuVFJBTlNMQVRJT04oX2J5KSk7XHJcbiAgICAgIC8vIC8vIFRPRE86IHBvc3NpYmxlIG9wdGltaXphdGlvbiwgdHJhbnNsYXRpb24gbWF5IGFsdGVyIG11dGF0b3IgaW5zdGVhZCBvZiBkZWxldGluZyBpdC5cclxuICAgICAgLy8gdGhpcy5zZXQobWF0cml4KTtcclxuICAgICAgLy8gUmVjeWNsZXIuc3RvcmUobWF0cml4KTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHgtYXhpcyB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZVgoX3g6IG51bWJlciwgX2xvY2FsOiBib29sZWFuID0gdHJ1ZSk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCB0cmFuc2xhdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuWChfeCk7XHJcbiAgICAgIHRoaXMudHJhbnNsYXRlKHRyYW5zbGF0aW9uLCBfbG9jYWwpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh0cmFuc2xhdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHRyYW5zbGF0aW9uIGFsb25nIHRoZSB5LWF4aXMgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVZKF95OiBudW1iZXIsIF9sb2NhbDogYm9vbGVhbiA9IHRydWUpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgdHJhbnNsYXRpb246IFZlY3RvcjMgPSBWZWN0b3IzLlkoX3kpO1xyXG4gICAgICB0aGlzLnRyYW5zbGF0ZSh0cmFuc2xhdGlvbiwgX2xvY2FsKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgei1heGlzIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlWihfejogbnVtYmVyLCBfbG9jYWw6IGJvb2xlYW4gPSB0cnVlKTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IHRyYW5zbGF0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5aKF96KTtcclxuICAgICAgdGhpcy50cmFuc2xhdGUodHJhbnNsYXRpb24sIF9sb2NhbCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHRyYW5zbGF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gUm90YXRpb25cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlcyB0aGlzIG1hdHJpeCBieSBnaXZlbiB7QGxpbmsgVmVjdG9yM30gaW4gdGhlIG9yZGVyIFosIFksIFguIFJpZ2h0IGhhbmQgcm90YXRpb24gaXMgdXNlZCwgdGh1bWIgcG9pbnRzIGluIGF4aXMgZGlyZWN0aW9uLCBmaW5nZXJzIGN1cmxpbmcgaW5kaWNhdGUgcm90YXRpb25cclxuICAgICAqIFRoZSByb3RhdGlvbiBpcyBhcHBlbmRlZCB0byBhbHJlYWR5IGFwcGxpZWQgdHJhbnNmb3JtcywgdGh1cyBtdWx0aXBsaWVkIGZyb20gdGhlIHJpZ2h0LiBTZXQgX2Zyb21MZWZ0IHRvIHRydWUgdG8gc3dpdGNoIGFuZCBwdXQgaXQgaW4gZnJvbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGUoX2J5OiBWZWN0b3IzIHwgUXVhdGVybmlvbiwgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgbXR4Um90YXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTihfYnkpO1xyXG4gICAgICB0aGlzLm11bHRpcGx5KG10eFJvdGF0aW9uLCBfZnJvbUxlZnQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSb3RhdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgeC1heGlzIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcm90YXRlWChfYW5nbGVJbkRlZ3JlZXM6IG51bWJlciwgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgbXR4Um90YXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTl9YKF9hbmdsZUluRGVncmVlcyk7XHJcbiAgICAgIHRoaXMubXVsdGlwbHkobXR4Um90YXRpb24sIF9mcm9tTGVmdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJvdGF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcm90YXRpb24gYXJvdW5kIHRoZSB5LWF4aXMgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGVZKF9hbmdsZUluRGVncmVlczogbnVtYmVyLCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCBtdHhSb3RhdGlvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJPVEFUSU9OX1koX2FuZ2xlSW5EZWdyZWVzKTtcclxuICAgICAgdGhpcy5tdWx0aXBseShtdHhSb3RhdGlvbiwgX2Zyb21MZWZ0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4Um90YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSByb3RhdGlvbiBhcm91bmQgdGhlIHotYXhpcyB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJvdGF0ZVooX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIsIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IG10eFJvdGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT05fWihfYW5nbGVJbkRlZ3JlZXMpO1xyXG4gICAgICB0aGlzLm11bHRpcGx5KG10eFJvdGF0aW9uLCBfZnJvbUxlZnQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSb3RhdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0cyB0aGUgcm90YXRpb24gb2YgdGhpcyBtYXRyaXggdG8gcG9pbnQgdGhlIHotYXhpcyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gdGFyZ2V0IGFuZCB0aWx0cyBpdCB0byBhY2NvcmQgd2l0aCB0aGUgZ2l2ZW4gdXAte0BsaW5rIFZlY3RvcjN9LFxyXG4gICAgICogcmVzcGVjdGl2ZWx5IGNhbGN1bGF0aW5nIHlhdyBhbmQgcGl0Y2guIElmIG5vIHVwLXtAbGluayBWZWN0b3IzfSBpcyBnaXZlbiwgdGhlIHByZXZpb3VzIHVwLXtAbGluayBWZWN0b3IzfSBpcyB1c2VkLiBcclxuICAgICAqIFRoZSBwaXRjaCBtYXkgYmUgcmVzdHJpY3RlZCB0byB0aGUgdXAtdmVjdG9yIHRvIG9ubHkgY2FsY3VsYXRlIHlhdy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvb2tBdChfdGFyZ2V0OiBWZWN0b3IzLCBfdXA/OiBWZWN0b3IzLCBfcmVzdHJpY3Q6IGJvb2xlYW4gPSBmYWxzZSk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIF91cCA9IF91cCA/IFZlY3RvcjMuTk9STUFMSVpBVElPTihfdXApIDogdGhpcy51cDtcclxuXHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LkxPT0tfQVQodGhpcy50cmFuc2xhdGlvbiwgX3RhcmdldCwgX3VwLCBfcmVzdHJpY3QpO1xyXG4gICAgICBtdHhSZXN1bHQuc2NhbGUodGhpcy5zY2FsaW5nKTtcclxuICAgICAgdGhpcy5zZXQobXR4UmVzdWx0LmRhdGEpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSZXN1bHQpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdHMgdGhlIHJvdGF0aW9uIG9mIHRoaXMgbWF0cml4IHRvIGFsaWduIHRoZSB6LWF4aXMgd2l0aCB0aGUgZ2l2ZW4gZGlyZWN0aW9uIGFuZCB0aWx0cyBpdCB0byBhY2NvcmQgd2l0aCB0aGUgZ2l2ZW4gdXAte0BsaW5rIFZlY3RvcjN9LlxyXG4gICAgICogVXAgc2hvdWxkIGJlIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGdpdmVuIGRpcmVjdGlvbi4gSWYgbm8gdXAtdmVjdG9yIGlzIHByb3ZpZGVkLCB7QGxpbmsgdXB9IGlzIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsb29rSW4oX2RpcmVjdGlvbjogVmVjdG9yMywgX3VwOiBWZWN0b3IzID0gdGhpcy51cCwgX3Jlc3RyaWN0OiBib29sZWFuID0gZmFsc2UpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgekF4aXM6IFZlY3RvcjMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04oX2RpcmVjdGlvbik7XHJcbiAgICAgIGxldCB4QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuTk9STUFMSVpBVElPTihWZWN0b3IzLkNST1NTKF91cCwgekF4aXMpKTtcclxuICAgICAgbGV0IHlBeGlzOiBWZWN0b3IzID0gX3Jlc3RyaWN0ID8gX3VwIDogVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoekF4aXMsIHhBeGlzKSk7XHJcbiAgICAgIHpBeGlzID0gX3Jlc3RyaWN0ID8gVmVjdG9yMy5OT1JNQUxJWkFUSU9OKFZlY3RvcjMuQ1JPU1MoeEF4aXMsIF91cCkpIDogekF4aXM7XHJcblxyXG4gICAgICB4QXhpcy5zY2FsZSh0aGlzLnNjYWxpbmcueCk7XHJcbiAgICAgIHlBeGlzLnNjYWxlKHRoaXMuc2NhbGluZy55KTtcclxuICAgICAgekF4aXMuc2NhbGUodGhpcy5zY2FsaW5nLnopO1xyXG5cclxuICAgICAgdGhpcy5zZXQoW1xyXG4gICAgICAgIHhBeGlzLngsIHhBeGlzLnksIHhBeGlzLnosIDAsXHJcbiAgICAgICAgeUF4aXMueCwgeUF4aXMueSwgeUF4aXMueiwgMCxcclxuICAgICAgICB6QXhpcy54LCB6QXhpcy55LCB6QXhpcy56LCAwLFxyXG4gICAgICAgIHRoaXMudHJhbnNsYXRpb24ueCwgdGhpcy50cmFuc2xhdGlvbi55LCB0aGlzLnRyYW5zbGF0aW9uLnosIDFcclxuICAgICAgXSk7XHJcblxyXG4gICAgICBSZWN5Y2xlci5zdG9yZU11bHRpcGxlKHhBeGlzLCB6QXhpcyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2FtZSBhcyB7QGxpbmsgTWF0cml4NHg0Lmxvb2tBdH0sIGJ1dCBvcHRpbWl6ZWQgYW5kIG5lZWRzIHRlc3RpbmdcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogdGVzdGluZyBsb29rYXQgdGhhdCByZWFsbHkganVzdCByb3RhdGVzIHRoZSBtYXRyaXggcmF0aGVyIHRoYW4gY3JlYXRpbmcgYSBuZXcgb25lXHJcbiAgICAvLyBwdWJsaWMgbG9va0F0Um90YXRlKF90YXJnZXQ6IFZlY3RvcjMsIF91cD86IFZlY3RvcjMsIF9wcmVzZXJ2ZVNjYWxpbmc6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAvLyAgIGlmICghX3VwKVxyXG4gICAgLy8gICAgIF91cCA9IHRoaXMuZ2V0WSgpO1xyXG5cclxuICAgIC8vICAgbGV0IHNjYWxpbmc6IFZlY3RvcjMgPSB0aGlzLnNjYWxpbmc7XHJcbiAgICAvLyAgIGxldCBkaWZmZXJlbmNlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF90YXJnZXQsIHRoaXMudHJhbnNsYXRpb24pO1xyXG4gICAgLy8gICBkaWZmZXJlbmNlLm5vcm1hbGl6ZSgpO1xyXG4gICAgLy8gICBsZXQgY29zOiBudW1iZXIgPSBWZWN0b3IzLkRPVChWZWN0b3IzLk5PUk1BTElaQVRJT04odGhpcy5nZXRaKCkpLCBkaWZmZXJlbmNlKTtcclxuICAgIC8vICAgbGV0IHNpbjogbnVtYmVyID0gVmVjdG9yMy5ET1QoVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMuZ2V0WCgpKSwgZGlmZmVyZW5jZSk7XHJcbiAgICAvLyAgIC8vIGNvbnNvbGUubG9nKHNpbiwgY29zKTtcclxuICAgIC8vICAgbGV0IG10eFJvdGF0aW9uOiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgIC8vICAgbXR4Um90YXRpb24uZGF0YS5zZXQoW1xyXG4gICAgLy8gICAgIGNvcywgMCwgLXNpbiwgMCxcclxuICAgIC8vICAgICAwLCAxLCAwLCAwLFxyXG4gICAgLy8gICAgIHNpbiwgMCwgY29zLCAwLFxyXG4gICAgLy8gICAgIDAsIDAsIDAsIDFcclxuICAgIC8vICAgXSk7XHJcbiAgICAvLyAgIHRoaXMubXVsdGlwbHkobXR4Um90YXRpb24sIGZhbHNlKTtcclxuXHJcbiAgICAvLyAgIGNvcyA9IFZlY3RvcjMuRE9UKFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLmdldFooKSksIGRpZmZlcmVuY2UpO1xyXG4gICAgLy8gICBzaW4gPSAtVmVjdG9yMy5ET1QoVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMuZ2V0WSgpKSwgZGlmZmVyZW5jZSk7XHJcbiAgICAvLyAgIC8vIGNvbnNvbGUubG9nKHNpbiwgY29zKTtcclxuICAgIC8vICAgbXR4Um90YXRpb24uZGF0YS5zZXQoW1xyXG4gICAgLy8gICAgIDEsIDAsIDAsIDAsXHJcbiAgICAvLyAgICAgMCwgY29zLCBzaW4sIDAsXHJcbiAgICAvLyAgICAgMCwgLXNpbiwgY29zLCAwLFxyXG4gICAgLy8gICAgIDAsIDAsIDAsIDFcclxuICAgIC8vICAgXSk7XHJcbiAgICAvLyAgIHRoaXMubXVsdGlwbHkobXR4Um90YXRpb24sIGZhbHNlKTtcclxuICAgIC8vICAgdGhpcy5zY2FsaW5nID0gc2NhbGluZztcclxuICAgIC8vICAgUmVjeWNsZXIuc3RvcmUobXR4Um90YXRpb24pO1xyXG4gICAgLy8gfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNjYWxpbmdcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHNjYWxpbmcgYnkgdGhlIGdpdmVuIHtAbGluayBWZWN0b3IzfSB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlKF9ieTogVmVjdG9yMywgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBtdHhTY2FsaW5nOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuU0NBTElORyhfYnkpO1xyXG4gICAgICB0aGlzLm11bHRpcGx5KG10eFNjYWxpbmcsIF9mcm9tTGVmdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFNjYWxpbmcpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzY2FsaW5nIGFsb25nIHRoZSB4LWF4aXMgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVgoX2J5OiBudW1iZXIpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoX2J5LCAxLCAxKTtcclxuICAgICAgdGhpcy5zY2FsZSh2ZWN0b3IpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh2ZWN0b3IpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzY2FsaW5nIGFsb25nIHRoZSB5LWF4aXMgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVkoX2J5OiBudW1iZXIpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoMSwgX2J5LCAxKTtcclxuICAgICAgdGhpcy5zY2FsZSh2ZWN0b3IpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh2ZWN0b3IpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzY2FsaW5nIGFsb25nIHRoZSB6LWF4aXMgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVooX2J5OiBudW1iZXIpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoMSwgMSwgX2J5KTtcclxuICAgICAgdGhpcy5zY2FsZSh2ZWN0b3IpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh2ZWN0b3IpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2Zvcm1hdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBseSB0aGlzIG1hdHJpeCBieSB0aGUgZ2l2ZW4gbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbXVsdGlwbHkoX21hdHJpeDogTWF0cml4NHg0LCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGNvbnN0IG10eFJlc3VsdDogTWF0cml4NHg0ID0gX2Zyb21MZWZ0ID8gTWF0cml4NHg0LlBST0RVQ1QoX21hdHJpeCwgdGhpcykgOiBNYXRyaXg0eDQuUFJPRFVDVCh0aGlzLCBfbWF0cml4KTtcclxuICAgICAgdGhpcy5zZXQobXR4UmVzdWx0LmRhdGEpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSZXN1bHQpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgLy8gcHVibGljIGdldEV1bGVyQW5nbGVzTmV3KCk6IFZlY3RvcjMge1xyXG4gICAgLy8gICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IHRoaXMuc2NhbGluZztcclxuXHJcbiAgICAvLyAgIGxldCB0aGV0YVg6IG51bWJlciwgdGhldGFZOiBudW1iZXIsIHRoZXRhWjogbnVtYmVyO1xyXG4gICAgLy8gICBsZXQgcjAyOiBudW1iZXIgPSB0aGlzLmRhdGFbMl0gLyBzY2FsaW5nLno7XHJcbiAgICAvLyAgIGxldCByMTE6IG51bWJlciA9IHRoaXMuZGF0YVs1XSAvIHNjYWxpbmcueTtcclxuXHJcbiAgICAvLyAgIGlmIChyMDIgPCAxKSB7XHJcbiAgICAvLyAgICAgaWYgKHIwMiA+IC0xKSB7XHJcbiAgICAvLyAgICAgICB0aGV0YVkgPSBNYXRoLmFzaW4oLXIwMik7XHJcbiAgICAvLyAgICAgICB0aGV0YVogPSBNYXRoLmF0YW4yKHRoaXMuZGF0YVsxXSAvIHNjYWxpbmcueSwgdGhpcy5kYXRhWzBdIC8gc2NhbGluZy54KTtcclxuICAgIC8vICAgICAgIHRoZXRhWCA9IE1hdGguYXRhbjIodGhpcy5kYXRhWzldIC8gc2NhbGluZy56LCB0aGlzLmRhdGFbMTBdIC8gc2NhbGluZy56KTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyAgICAgZWxzZSB7XHJcbiAgICAvLyAgICAgICB0aGV0YVkgPSBNYXRoLlBJIC8gMjtcclxuICAgIC8vICAgICAgIHRoZXRhWiA9IC1NYXRoLmF0YW4yKHRoaXMuZGF0YVs2XSAvIHNjYWxpbmcueSwgcjExKTtcclxuICAgIC8vICAgICAgIHRoZXRhWCA9IDA7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICB9XHJcbiAgICAvLyAgIGVsc2Uge1xyXG4gICAgLy8gICAgIHRoZXRhWSA9IC1NYXRoLlBJIC8gMjtcclxuICAgIC8vICAgICB0aGV0YVogPSBNYXRoLmF0YW4yKC10aGlzLmRhdGFbNl0gLyBzY2FsaW5nLnksIHIxMSk7XHJcbiAgICAvLyAgICAgdGhldGFYID0gMDtcclxuICAgIC8vICAgfVxyXG4gICAgLy8gICB0aGlzLiNldWxlckFuZ2xlcy5zZXQoLXRoZXRhWCwgdGhldGFZLCB0aGV0YVopO1xyXG4gICAgLy8gICB0aGlzLiNldWxlckFuZ2xlcy5zY2FsZShNYXRoZW1hdGljLnJhZDJkZWcpO1xyXG5cclxuICAgIC8vICAgcmV0dXJuIHRoaXMuI2V1bGVyQW5nbGVzO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggdG8gdGhlIGdpdmVuIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF9hcnJheTogQXJyYXlMaWtlPG51bWJlcj4pOiBNYXRyaXg0eDQge1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KF9hcnJheSk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyB0aGUgc3RhdGUgb2YgdGhlIGdpdmVuIG1hdHJpeCBpbnRvIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29weShfb3JpZ2luYWw6IE1hdHJpeDR4NCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoX29yaWdpbmFsLmRhdGEpO1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgICB0aGlzLm1vZGlmaWVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy4jdHJhbnNsYXRpb25EaXJ0eSA9IF9vcmlnaW5hbC4jdHJhbnNsYXRpb25EaXJ0eTtcclxuICAgICAgdGhpcy4jcm90YXRpb25EaXJ0eSA9IF9vcmlnaW5hbC4jcm90YXRpb25EaXJ0eTtcclxuICAgICAgdGhpcy4jc2NhbGluZ0RpcnR5ID0gX29yaWdpbmFsLiNzY2FsaW5nRGlydHk7XHJcbiAgICAgIHRoaXMuI3F1YXRlcm5pb25EaXJ0eSA9IF9vcmlnaW5hbC4jcXVhdGVybmlvbkRpcnR5O1xyXG4gICAgICBpZiAoIXRoaXMuI3RyYW5zbGF0aW9uRGlydHkpXHJcbiAgICAgICAgdGhpcy4jdHJhbnNsYXRpb24uY29weShfb3JpZ2luYWwuI3RyYW5zbGF0aW9uKTtcclxuICAgICAgaWYgKCF0aGlzLiNyb3RhdGlvbkRpcnR5KVxyXG4gICAgICAgIHRoaXMuI3JvdGF0aW9uLmNvcHkoX29yaWdpbmFsLiNyb3RhdGlvbik7XHJcbiAgICAgIGlmICghdGhpcy4jc2NhbGluZ0RpcnR5KVxyXG4gICAgICAgIHRoaXMuI3NjYWxpbmcuY29weShfb3JpZ2luYWwuI3NjYWxpbmcpO1xyXG4gICAgICBpZiAoIXRoaXMuI3F1YXRlcm5pb25EaXJ0eSlcclxuICAgICAgICB0aGlzLiNxdWF0ZXJuaW9uLmNvcHkoX29yaWdpbmFsLiNxdWF0ZXJuaW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGDGki5NYXRyaXg0eDQodHJhbnNsYXRpb246ICR7dGhpcy50cmFuc2xhdGlvbi50b1N0cmluZygpfSwgcm90YXRpb246ICR7dGhpcy5yb3RhdGlvbi50b1N0cmluZygpfSwgc2NhbGluZzogJHt0aGlzLnNjYWxpbmcudG9TdHJpbmcoKX1gO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgLy8gVE9ETzogb3B0aW1pemF0aW9uLCBpdCBzaG91bGRuJ3QgYWx3YXlzIHJldHVybiBhIGNvcHksIHNpbmNlIHRoaXMgYmxvYXRzIG1lbW9yeVxyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RGF0YSgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHgtYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0WCgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgcmVzdWx0LnNldCh0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHktYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0WSgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgcmVzdWx0LnNldCh0aGlzLmRhdGFbNF0sIHRoaXMuZGF0YVs1XSwgdGhpcy5kYXRhWzZdKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHotYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0WigpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgcmVzdWx0LnNldCh0aGlzLmRhdGFbOF0sIHRoaXMuZGF0YVs5XSwgdGhpcy5kYXRhWzEwXSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTd2FwcyB0aGUgdHdvIGNhcmRpbmFsIGF4aXMgYW5kIHJldmVyc2VzIHRoZSB0aGlyZCwgZWZmZWN0aXZlbHkgcm90YXRpbmcgdGhlIHRyYW5zZm9ybSAxODAgZGVncmVlcyBhcm91bmQgb25lIGFuZCA5MCBkZWdyZWVzIGFyb3VuZCBhIHNlY29uZCBheGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzd2FwWFkoKTogdm9pZCB7XHJcbiAgICAgIGxldCB0ZW1wOiBudW1iZXJbXSA9IFt0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzJdXTsgLy8gc3RvcmUgeC1heGlzXHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoW3RoaXMuZGF0YVs0XSwgdGhpcy5kYXRhWzVdLCB0aGlzLmRhdGFbNl1dLCAwKTsgLy8gb3ZlcndyaXRlIHgtYXhpcyB3aXRoIHktYXhpc1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KHRlbXAsIDQpOyAvLyBvdmVyd3JpdGUgWSB3aXRoIHRlbXBcclxuICAgICAgdGhpcy5kYXRhLnNldChbLXRoaXMuZGF0YVs4XSwgLXRoaXMuZGF0YVs5XSwgLXRoaXMuZGF0YVsxMF1dLCA4KTsgLy8gcmV2ZXJzZSB6LWF4aXNcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN3YXBzIHRoZSB0d28gY2FyZGluYWwgYXhpcyBhbmQgcmV2ZXJzZXMgdGhlIHRoaXJkLCBlZmZlY3RpdmVseSByb3RhdGluZyB0aGUgdHJhbnNmb3JtIDE4MCBkZWdyZWVzIGFyb3VuZCBvbmUgYW5kIDkwIGRlZ3JlZXMgYXJvdW5kIGEgc2Vjb25kIGF4aXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN3YXBYWigpOiB2b2lkIHtcclxuICAgICAgbGV0IHRlbXA6IG51bWJlcltdID0gW3RoaXMuZGF0YVswXSwgdGhpcy5kYXRhWzFdLCB0aGlzLmRhdGFbMl1dOyAvLyBzdG9yZSB4LWF4aXNcclxuICAgICAgdGhpcy5kYXRhLnNldChbdGhpcy5kYXRhWzhdLCB0aGlzLmRhdGFbOV0sIHRoaXMuZGF0YVsxMF1dLCAwKTsgLy8gb3ZlcndyaXRlIHgtYXhpcyB3aXRoIHotYXhpc1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KHRlbXAsIDgpOyAvLyBvdmVyd3JpdGUgWiB3aXRoIHRlbXBcclxuICAgICAgdGhpcy5kYXRhLnNldChbLXRoaXMuZGF0YVs0XSwgLXRoaXMuZGF0YVs1XSwgLXRoaXMuZGF0YVs2XV0sIDQpOyAvLyByZXZlcnNlIHktYXhpc1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3dhcHMgdGhlIHR3byBjYXJkaW5hbCBheGlzIGFuZCByZXZlcnNlcyB0aGUgdGhpcmQsIGVmZmVjdGl2ZWx5IHJvdGF0aW5nIHRoZSB0cmFuc2Zvcm0gMTgwIGRlZ3JlZXMgYXJvdW5kIG9uZSBhbmQgOTAgZGVncmVlcyBhcm91bmQgYSBzZWNvbmQgYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3dhcFlaKCk6IHZvaWQge1xyXG4gICAgICBsZXQgdGVtcDogbnVtYmVyW10gPSBbdGhpcy5kYXRhWzRdLCB0aGlzLmRhdGFbNV0sIHRoaXMuZGF0YVs2XV07IC8vIHN0b3JlIHktYXhpc1xyXG4gICAgICB0aGlzLmRhdGEuc2V0KFt0aGlzLmRhdGFbOF0sIHRoaXMuZGF0YVs5XSwgdGhpcy5kYXRhWzEwXV0sIDQpOyAvLyBvdmVyd3JpdGUgeS1heGlzIHdpdGggei1heGlzXHJcbiAgICAgIHRoaXMuZGF0YS5zZXQodGVtcCwgOCk7IC8vIG92ZXJ3cml0ZSBaIHdpdGggdGVtcFxyXG4gICAgICB0aGlzLmRhdGEuc2V0KFstdGhpcy5kYXRhWzBdLCAtdGhpcy5kYXRhWzFdLCAtdGhpcy5kYXRhWzJdXSwgMCk7IC8vIHJldmVyc2UgeC1heGlzXHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdHJhbmxhdGlvbiBmcm9tIHRoaXMgbWF0cml4IHRvIHRoZSB0YXJnZXQgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUcmFuc2xhdGlvblRvKF9tdHhUYXJnZXQ6IE1hdHJpeDR4NCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgZGlmZmVyZW5jZTogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgZGlmZmVyZW5jZS5zZXQoX210eFRhcmdldC5kYXRhWzEyXSAtIHRoaXMuZGF0YVsxMl0sIF9tdHhUYXJnZXQuZGF0YVsxM10gLSB0aGlzLmRhdGFbMTNdLCBfbXR4VGFyZ2V0LmRhdGFbMTRdIC0gdGhpcy5kYXRhWzE0XSk7XHJcbiAgICAgIHJldHVybiBkaWZmZXJlbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIC8vIHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICB0cmFuc2xhdGlvbjogdGhpcy50cmFuc2xhdGlvbi5zZXJpYWxpemUoKSxcclxuICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbi5zZXJpYWxpemUoKSxcclxuICAgICAgICBzY2FsaW5nOiB0aGlzLnNjYWxpbmcuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB0cmFuc2xhdGlvbjogYXdhaXQgdGhpcy50cmFuc2xhdGlvbi5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi50cmFuc2xhdGlvbiksXHJcbiAgICAgICAgcm90YXRpb246IGF3YWl0IHRoaXMucm90YXRpb24uZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ucm90YXRpb24pLFxyXG4gICAgICAgIHNjYWxpbmc6IGF3YWl0IHRoaXMuc2NhbGluZy5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5zY2FsaW5nKVxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLm11dGF0ZShtdXRhdG9yKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGlmICh0aGlzLm11dGF0b3IpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0YXRvcjtcclxuXHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHRyYW5zbGF0aW9uOiB0aGlzLnRyYW5zbGF0aW9uLmdldE11dGF0b3IoKSxcclxuICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbi5nZXRNdXRhdG9yKCksXHJcbiAgICAgICAgc2NhbGluZzogdGhpcy5zY2FsaW5nLmdldE11dGF0b3IoKVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gY2FjaGUgbXV0YXRvclxyXG4gICAgICB0aGlzLm11dGF0b3IgPSBtdXRhdG9yO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGNvbnN0IG06IEZsb2F0MzJBcnJheSA9IHRoaXMuZGF0YTtcclxuXHJcbiAgICAgIGlmIChfbXV0YXRvci50cmFuc2xhdGlvbikge1xyXG4gICAgICAgIGxldCB0cmFuc2xhdGlvbjogVmVjdG9yMyA9IHRoaXMudHJhbnNsYXRpb247XHJcbiAgICAgICAgdHJhbnNsYXRpb24ubXV0YXRlKF9tdXRhdG9yLnRyYW5zbGF0aW9uKTtcclxuICAgICAgICBtWzEyXSA9IHRyYW5zbGF0aW9uLng7IG1bMTNdID0gdHJhbnNsYXRpb24ueTsgbVsxNF0gPSB0cmFuc2xhdGlvbi56O1xyXG4gICAgICAgIHRoaXMuI3RyYW5zbGF0aW9uRGlydHkgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKF9tdXRhdG9yLnJvdGF0aW9uIHx8IF9tdXRhdG9yLnNjYWxpbmcpIHtcclxuICAgICAgICAvLyBUT0RPOiBtYWtlIGZ1bGwgdmVjdG9yIGFuZCBxdWF0ZXJuaW9uIG11dGF0b3JzIG1hbmRhdG9yeT9cclxuXHJcbiAgICAgICAgbGV0IHJvdGF0aW9uOiBWZWN0b3IzIHwgUXVhdGVybmlvbiA9IF9tdXRhdG9yLnJvdGF0aW9uPy53ICE9IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICB0aGlzLiNxdWF0ZXJuaW9uIDogLy8gdXNpbmcgdGhpcy4jcXVhdGVybmlvbiBhc3N1bWVzIHdlIGdldCBhIGZ1bGwgcXVhdGVybmlvbiBtdXRhdG9yIHdpdGggeCwgeSwgeiBhbmQgdyBzZXQgc28gd2UgbmV2ZXIgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgcXVhdGVybmlvbiBoZXJlLiBUaGlzIG1pZ2h0IGNhdXNlIHRyb3VibGUgaWYgd2UgZXZlciB3YW50IHRvIG11dGF0ZSBvbmx5IGEgcGFydCBvZiBhIHF1YXRlcm5pb24uLi5cclxuICAgICAgICAgIGlzRnVsbFZlY3Rvck11dGF0b3IoX211dGF0b3Iucm90YXRpb24pID8gdGhpcy4jcm90YXRpb24gOiB0aGlzLnJvdGF0aW9uOyAvLyBoYWNrIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb24gb2Ygcm90YXRpb24gYW5kIHNjYWxpbmcuIFRoaXMgcmVjYWxjdWxhdGlvbiBpcyB1bm5lY2Vzc2FyeSB3aGVuIHdlIGdldCBhIGZ1bGwgbXV0YXRvciBpLmUuIHdpdGggeCwgeSBhbmQgeiBzZXRcclxuXHJcbiAgICAgICAgbGV0IHNjYWxpbmc6IFZlY3RvcjMgPSBpc0Z1bGxWZWN0b3JNdXRhdG9yKF9tdXRhdG9yLnNjYWxpbmcpID8gdGhpcy4jc2NhbGluZyA6IHRoaXMuc2NhbGluZztcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBpc1F1YXRlcm5pb246IGJvb2xlYW4gPSByb3RhdGlvbiBpbnN0YW5jZW9mIFF1YXRlcm5pb247XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKF9tdXRhdG9yLnJvdGF0aW9uKSB7XHJcbiAgICAgICAgICByb3RhdGlvbi5tdXRhdGUoX211dGF0b3Iucm90YXRpb24pO1xyXG4gICAgICAgICAgaWYgKGlzUXVhdGVybmlvbilcclxuICAgICAgICAgICAgcm90YXRpb24ubm9ybWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoX211dGF0b3Iuc2NhbGluZylcclxuICAgICAgICAgIHNjYWxpbmcubXV0YXRlKF9tdXRhdG9yLnNjYWxpbmcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIE1hdHJpeDR4NC5zZXRSb3RhdGlvbihtLCByb3RhdGlvbik7XHJcbiAgICAgICAgdGhpcy4jcm90YXRpb25EaXJ0eSA9IGlzUXVhdGVybmlvbjtcclxuICAgICAgICB0aGlzLiNxdWF0ZXJuaW9uRGlydHkgPSAhaXNRdWF0ZXJuaW9uO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHN4OiBudW1iZXIgPSBzY2FsaW5nLngsIHN5OiBudW1iZXIgPSBzY2FsaW5nLnksIHN6OiBudW1iZXIgPSBzY2FsaW5nLno7XHJcbiAgICAgICAgbVswXSAqPSBzeDsgbVsxXSAqPSBzeDsgbVsyXSAqPSBzeDtcclxuICAgICAgICBtWzRdICo9IHN5OyBtWzVdICo9IHN5OyBtWzZdICo9IHN5O1xyXG4gICAgICAgIG1bOF0gKj0gc3o7IG1bOV0gKj0gc3o7IG1bMTBdICo9IHN6O1xyXG4gICAgICAgIHRoaXMuI3NjYWxpbmdEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgICB0aGlzLm1vZGlmaWVkID0gdHJ1ZTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGlzRnVsbFZlY3Rvck11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gX211dGF0b3IgJiYgX211dGF0b3IueCAhPSB1bmRlZmluZWQgJiYgX211dGF0b3IueSAhPSB1bmRlZmluZWQgJiYgX211dGF0b3IueiAhPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSB7fTtcclxuICAgICAgaWYgKF9tdXRhdG9yLnRyYW5zbGF0aW9uKSB0eXBlcy50cmFuc2xhdGlvbiA9IFwiVmVjdG9yM1wiO1xyXG4gICAgICBpZiAoX211dGF0b3Iucm90YXRpb24pIHR5cGVzLnJvdGF0aW9uID0gXCJWZWN0b3IzXCI7XHJcbiAgICAgIGlmIChfbXV0YXRvci5zY2FsaW5nKSB0eXBlcy5zY2FsaW5nID0gXCJWZWN0b3IzXCI7XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuXHJcbiAgICBwcml2YXRlIHJlc2V0Q2FjaGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uRGlydHkgPSB0cnVlO1xyXG4gICAgICB0aGlzLiNyb3RhdGlvbkRpcnR5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy4jcXVhdGVybmlvbkRpcnR5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy4jc2NhbGluZ0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5tb2RpZmllZCA9IHRydWU7XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vI2VuZHJlZ2lvblxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBCYXNlY2xhc3MgZm9yIE5vaXNlMiwgTm9pc2UzIGFuZCBOb2lzZTRcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqIFRoaXMgaXMgYW4gYWRhcHRpb24gb2YgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmFzdC1zaW1wbGV4LW5vaXNlXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIE5vaXNlIHtcclxuICAgIHByb3RlY3RlZCBwZXJtOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoNTEyKTtcclxuICAgIHByb3RlY3RlZCBwZXJtTW9kMTI6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSg1MTIpO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb20gdmFsdWUgYmV0d2VlbiAtMSBhbmQgMSBiYXNlZCBvbiB0aGUgZ2l2ZW4gcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IHNhbXBsZTogKC4uLl9hcmdzOiBudW1iZXJbXSkgPT4gbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfcmFuZG9tOiBGdW5jdGlvbiA9IE1hdGgucmFuZG9tKSB7XHJcbiAgICAgIGNvbnN0IHA6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSgyNTYpO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgMjU2OyBpKyspXHJcbiAgICAgICAgcFtpXSA9IGk7XHJcblxyXG4gICAgICBsZXQgbjogbnVtYmVyO1xyXG4gICAgICBsZXQgcTogbnVtYmVyO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAyNTU7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICBuID0gTWF0aC5mbG9vcigoaSArIDEpICogX3JhbmRvbSgpKTtcclxuICAgICAgICBxID0gcFtpXTtcclxuICAgICAgICBwW2ldID0gcFtuXTtcclxuICAgICAgICBwW25dID0gcTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IDUxMjsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5wZXJtW2ldID0gcFtpICYgMjU1XTtcclxuICAgICAgICB0aGlzLnBlcm1Nb2QxMltpXSA9IHRoaXMucGVybVtpXSAlIDEyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCIuL05vaXNlLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgaXMgYW4gYWRhcHRpb24gb2YgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmFzdC1zaW1wbGV4LW5vaXNlXHJcbiAgICogZG9uZSBieSBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqXHJcbiAgICogQmFzZWQgb24gZXhhbXBsZSBjb2RlIGJ5IFN0ZWZhbiBHdXN0YXZzb24gKHN0ZWd1QGl0bi5saXUuc2UpLlxyXG4gICAqIE9wdGltaXNhdGlvbnMgYnkgUGV0ZXIgRWFzdG1hbiAocGVhc3RtYW5AZHJpenpsZS5zdGFuZm9yZC5lZHUpLlxyXG4gICAqIEJldHRlciByYW5rIG9yZGVyaW5nIG1ldGhvZCBieSBTdGVmYW4gR3VzdGF2c29uIGluIDIwMTIuXHJcbiAgICpcclxuICAgKiBUaGlzIGNvZGUgd2FzIHBsYWNlZCBpbiB0aGUgcHVibGljIGRvbWFpbiBieSBpdHMgb3JpZ2luYWwgYXV0aG9yLFxyXG4gICAqIFN0ZWZhbiBHdXN0YXZzb24uIFlvdSBtYXkgdXNlIGl0IGFzIHlvdSBzZWUgZml0LCBidXRcclxuICAgKiBhdHRyaWJ1dGlvbiBpcyBhcHByZWNpYXRlZC5cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTm9pc2UyIGV4dGVuZHMgTm9pc2Uge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgb2Zmc2V0OiBudW1iZXIgPSAoMy4wIC0gTWF0aC5zcXJ0KDMuMCkpIC8gNi4wO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JhZGllbnQ6IG51bWJlcltdW10gPSBbWzEsIDFdLCBbLTEsIDFdLCBbMSwgLTFdLCBbLTEsIC0xXSwgWzEsIDBdLCBbLTEsIDBdLCBbMSwgMF0sIFstMSwgMF0sIFswLCAxXSwgWzAsIC0xXSwgWzAsIDFdLCBbMCwgLTFdXTtcclxuICAgICNzYW1wbGU6IChfeDogbnVtYmVyLCBfeTogbnVtYmVyKSA9PiBudW1iZXIgPSBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfcmFuZG9tOiBGdW5jdGlvbiA9IE1hdGgucmFuZG9tKSB7XHJcbiAgICAgIHN1cGVyKF9yYW5kb20pO1xyXG5cclxuICAgICAgdGhpcy4jc2FtcGxlID0gKF94OiBudW1iZXIsIF95OiBudW1iZXIpID0+IHtcclxuICAgICAgICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXHJcbiAgICAgICAgY29uc3QgczogbnVtYmVyID0gKF94ICsgX3kpICogMC41ICogKE1hdGguc3FydCgzLjApIC0gMS4wKTsgLy8gSGFpcnkgZmFjdG9yIGZvciAyRFxyXG4gICAgICAgIGNvbnN0IGk6IG51bWJlciA9IE1hdGguZmxvb3IoX3ggKyBzKTtcclxuICAgICAgICBjb25zdCBqOiBudW1iZXIgPSBNYXRoLmZsb29yKF95ICsgcyk7XHJcbiAgICAgICAgY29uc3QgdDogbnVtYmVyID0gKGkgKyBqKSAqIE5vaXNlMi5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgWDA6IG51bWJlciA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSkgc3BhY2VcclxuICAgICAgICBjb25zdCBZMDogbnVtYmVyID0gaiAtIHQ7XHJcbiAgICAgICAgY29uc3QgeDA6IG51bWJlciA9IF94IC0gWDA7IC8vIFRoZSB4LHkgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXHJcbiAgICAgICAgY29uc3QgeTA6IG51bWJlciA9IF95IC0gWTA7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCBzaW1wbGV4IHdlIGFyZSBpbi5cclxuICAgICAgICBjb25zdCBpMTogbnVtYmVyID0geDAgPiB5MCA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGoxOiBudW1iZXIgPSB4MCA+IHkwID8gMCA6IDE7XHJcblxyXG4gICAgICAgIC8vIE9mZnNldDpudW1iZXJzIGZvciBjb3JuZXJzXHJcbiAgICAgICAgY29uc3QgeDE6IG51bWJlciA9IHgwIC0gaTEgKyBOb2lzZTIub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHkxOiBudW1iZXIgPSB5MCAtIGoxICsgTm9pc2UyLm9mZnNldDtcclxuICAgICAgICBjb25zdCB4MjogbnVtYmVyID0geDAgLSAxLjAgKyAyLjAgKiBOb2lzZTIub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHkyOiBudW1iZXIgPSB5MCAtIDEuMCArIDIuMCAqIE5vaXNlMi5vZmZzZXQ7XHJcblxyXG4gICAgICAgIC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgdGhyZWUgc2ltcGxleCBjb3JuZXJzXHJcbiAgICAgICAgY29uc3QgaWk6IG51bWJlciA9IGkgJiAyNTU7XHJcbiAgICAgICAgY29uc3Qgamo6IG51bWJlciA9IGogJiAyNTU7XHJcbiAgICAgICAgY29uc3QgZzA6IG51bWJlcltdID0gTm9pc2UyLmdyYWRpZW50W3RoaXMucGVybU1vZDEyW2lpICsgdGhpcy5wZXJtW2pqXV1dO1xyXG4gICAgICAgIGNvbnN0IGcxOiBudW1iZXJbXSA9IE5vaXNlMi5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIGkxICsgdGhpcy5wZXJtW2pqICsgajFdXV07XHJcbiAgICAgICAgY29uc3QgZzI6IG51bWJlcltdID0gTm9pc2UyLmdyYWRpZW50W3RoaXMucGVybU1vZDEyW2lpICsgMSArIHRoaXMucGVybVtqaiArIDFdXV07XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20gdGhlIHRocmVlIGNvcm5lcnNcclxuICAgICAgICBjb25zdCB0MDogbnVtYmVyID0gMC41IC0geDAgKiB4MCAtIHkwICogeTA7XHJcbiAgICAgICAgY29uc3QgbjA6IG51bWJlciA9IHQwIDwgMCA/IDAuMCA6IE1hdGgucG93KHQwLCA0KSAqIChnMFswXSAqIHgwICsgZzBbMV0gKiB5MCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHQxOiBudW1iZXIgPSAwLjUgLSB4MSAqIHgxIC0geTEgKiB5MTtcclxuICAgICAgICBjb25zdCBuMTogbnVtYmVyID0gdDEgPCAwID8gMC4wIDogTWF0aC5wb3codDEsIDQpICogKGcxWzBdICogeDEgKyBnMVsxXSAqIHkxKTtcclxuXHJcbiAgICAgICAgY29uc3QgdDI6IG51bWJlciA9IDAuNSAtIHgyICogeDIgLSB5MiAqIHkyO1xyXG4gICAgICAgIGNvbnN0IG4yOiBudW1iZXIgPSB0MiA8IDAgPyAwLjAgOiBNYXRoLnBvdyh0MiwgNCkgKiAoZzJbMF0gKiB4MiArIGcyWzFdICogeTIpO1xyXG5cclxuICAgICAgICAvLyBBZGQgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggY29ybmVyIHRvIGdldCB0aGUgZmluYWwgbm9pc2UgdmFsdWUuXHJcbiAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gcmV0dXJuIHZhbHVlcyBpbiB0aGUgaW50ZXJ2YWwgWy0xLCAxXVxyXG4gICAgICAgIHJldHVybiA3MC4xNDgwNTc3MDY1Mzk1MiAqIChuMCArIG4xICsgbjIpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzYW1wbGUgPSAoX3g6IG51bWJlciwgX3k6IG51bWJlcik6IG51bWJlciA9PiB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzYW1wbGUoX3gsIF95KTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogVGhpcyBpcyBhbiBhZGFwdGlvbiBvZiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9mYXN0LXNpbXBsZXgtbm9pc2VcclxuICAgKiBkb25lIGJ5IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICpcclxuICAgKiBCYXNlZCBvbiBleGFtcGxlIGNvZGUgYnkgU3RlZmFuIEd1c3RhdnNvbiAoc3RlZ3VAaXRuLmxpdS5zZSkuXHJcbiAgICogT3B0aW1pc2F0aW9ucyBieSBQZXRlciBFYXN0bWFuIChwZWFzdG1hbkBkcml6emxlLnN0YW5mb3JkLmVkdSkuXHJcbiAgICogQmV0dGVyIHJhbmsgb3JkZXJpbmcgbWV0aG9kIGJ5IFN0ZWZhbiBHdXN0YXZzb24gaW4gMjAxMi5cclxuICAgKlxyXG4gICAqIFRoaXMgY29kZSB3YXMgcGxhY2VkIGluIHRoZSBwdWJsaWMgZG9tYWluIGJ5IGl0cyBvcmlnaW5hbCBhdXRob3IsXHJcbiAgICogU3RlZmFuIEd1c3RhdnNvbi4gWW91IG1heSB1c2UgaXQgYXMgeW91IHNlZSBmaXQsIGJ1dFxyXG4gICAqIGF0dHJpYnV0aW9uIGlzIGFwcHJlY2lhdGVkLlxyXG4gICAqL1xyXG4gIC8vIFRPRE86IFRlc3RcclxuICBleHBvcnQgY2xhc3MgTm9pc2UzIGV4dGVuZHMgTm9pc2Uge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgb2Zmc2V0OiBudW1iZXIgPSAxLjAgLyA2LjA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBncmFkaWVudDogbnVtYmVyW11bXSA9IFtbMSwgMSwgMF0sIFstMSwgMSwgMF0sIFsxLCAtMSwgMF0sIFstMSwgLTEsIDBdLCBbMSwgMCwgMV0sIFstMSwgMCwgMV0sIFsxLCAwLCAtMV0sIFstMSwgMCwgLTFdLCBbMCwgMSwgMV0sIFswLCAtMSwgLTFdLCBbMCwgMSwgLTFdLCBbMCwgLTEsIC0xXVxyXG4gICAgXTtcclxuICAgICNzYW1wbGU6IChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfejogbnVtYmVyKSA9PiBudW1iZXIgPSBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfcmFuZG9tOiBGdW5jdGlvbiA9IE1hdGgucmFuZG9tKSB7XHJcbiAgICAgIHN1cGVyKF9yYW5kb20pO1xyXG5cclxuICAgICAgdGhpcy4jc2FtcGxlID0gKF94OiBudW1iZXIsIF95OiBudW1iZXIsIF96OiBudW1iZXIpID0+IHtcclxuICAgICAgICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXHJcbiAgICAgICAgY29uc3QgczogbnVtYmVyID0gKF94ICsgX3kgKyBfeikgLyAzLjA7IC8vIFZlcnkgbmljZSBhbmQgc2ltcGxlIHNrZXcgZmFjdG9yIGZvciAzRFxyXG4gICAgICAgIGNvbnN0IGk6IG51bWJlciA9IE1hdGguZmxvb3IoX3ggKyBzKTtcclxuICAgICAgICBjb25zdCBqOiBudW1iZXIgPSBNYXRoLmZsb29yKF95ICsgcyk7XHJcbiAgICAgICAgY29uc3QgazogbnVtYmVyID0gTWF0aC5mbG9vcihfeiArIHMpO1xyXG4gICAgICAgIGNvbnN0IHQ6IG51bWJlciA9IChpICsgaiArIGspICogTm9pc2UzLm9mZnNldDtcclxuICAgICAgICBjb25zdCBYMDogbnVtYmVyID0gaSAtIHQ7IC8vIFVuc2tldyB0aGUgY2VsbCBvcmlnaW4gYmFjayB0byAoeCx5LHopIHNwYWNlXHJcbiAgICAgICAgY29uc3QgWTA6IG51bWJlciA9IGogLSB0O1xyXG4gICAgICAgIGNvbnN0IFowOiBudW1iZXIgPSBrIC0gdDtcclxuICAgICAgICBjb25zdCB4MDogbnVtYmVyID0gX3ggLSBYMDsgLy8gVGhlIHgseSx6IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxyXG4gICAgICAgIGNvbnN0IHkwOiBudW1iZXIgPSBfeSAtIFkwO1xyXG4gICAgICAgIGNvbnN0IHowOiBudW1iZXIgPSBfeiAtIFowO1xyXG5cclxuICAgICAgICAvLyBEZXRlcmluZSB3aGljaCBzaW1wbGV4IHdlIGFyZSBpblxyXG4gICAgICAgIGxldCBpMTogbnVtYmVyLCBqMTogbnVtYmVyLCBrMTogbnVtYmVyIC8vIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3Jkc1xyXG4gICAgICAgICAgO1xyXG4gICAgICAgIGxldCBpMjogbnVtYmVyLCBqMjogbnVtYmVyLCBrMjogbnVtYmVyIC8vIE9mZnNldHMgZm9yIHRoaXJkIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGosaykgY29vcmRzXHJcbiAgICAgICAgICA7XHJcbiAgICAgICAgaWYgKHgwID49IHkwKSB7XHJcbiAgICAgICAgICBpZiAoeTAgPj0gejApIHtcclxuICAgICAgICAgICAgaTEgPSBpMiA9IGoyID0gMTtcclxuICAgICAgICAgICAgajEgPSBrMSA9IGsyID0gMDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoeDAgPj0gejApIHtcclxuICAgICAgICAgICAgaTEgPSBpMiA9IGsyID0gMTtcclxuICAgICAgICAgICAgajEgPSBrMSA9IGoyID0gMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGsxID0gaTIgPSBrMiA9IDE7XHJcbiAgICAgICAgICAgIGkxID0gajEgPSBqMiA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICh5MCA8IHowKSB7XHJcbiAgICAgICAgICAgIGsxID0gajIgPSBrMiA9IDE7XHJcbiAgICAgICAgICAgIGkxID0gajEgPSBpMiA9IDA7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHgwIDwgejApIHtcclxuICAgICAgICAgICAgajEgPSBqMiA9IGsyID0gMTtcclxuICAgICAgICAgICAgaTEgPSBrMSA9IGkyID0gMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGoxID0gaTIgPSBqMiA9IDE7XHJcbiAgICAgICAgICAgIGkxID0gazEgPSBrMiA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB4MTogbnVtYmVyID0geDAgLSBpMSArIE5vaXNlMy5vZmZzZXQ7IC8vIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHNcclxuICAgICAgICBjb25zdCB5MTogbnVtYmVyID0geTAgLSBqMSArIE5vaXNlMy5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgejE6IG51bWJlciA9IHowIC0gazEgKyBOb2lzZTMub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHgyOiBudW1iZXIgPSB4MCAtIGkyICsgMi4wICogTm9pc2UzLm9mZnNldDsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIGluICh4LHkseikgY29vcmRzXHJcbiAgICAgICAgY29uc3QgeTI6IG51bWJlciA9IHkwIC0gajIgKyAyLjAgKiBOb2lzZTMub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHoyOiBudW1iZXIgPSB6MCAtIGsyICsgMi4wICogTm9pc2UzLm9mZnNldDtcclxuICAgICAgICBjb25zdCB4MzogbnVtYmVyID0geDAgLSAxLjAgKyAzLjAgKiBOb2lzZTMub2Zmc2V0OyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5LHopIGNvb3Jkc1xyXG4gICAgICAgIGNvbnN0IHkzOiBudW1iZXIgPSB5MCAtIDEuMCArIDMuMCAqIE5vaXNlMy5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgejM6IG51bWJlciA9IHowIC0gMS4wICsgMy4wICogTm9pc2UzLm9mZnNldDtcclxuXHJcbiAgICAgICAgLy8gV29yayA6bnVtYmVydXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmb3VyIHNpbXBsZXggY29ybmVyc1xyXG4gICAgICAgIGNvbnN0IGlpOiBudW1iZXIgPSBpICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGpqOiBudW1iZXIgPSBqICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGtrOiBudW1iZXIgPSBrICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGcwOiBudW1iZXJbXSA9IE5vaXNlMy5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIHRoaXMucGVybVtqaiArIHRoaXMucGVybVtra11dXV07XHJcbiAgICAgICAgY29uc3QgZzE6IG51bWJlcltdID0gTm9pc2UzLmdyYWRpZW50W3RoaXMucGVybU1vZDEyW2lpICsgaTEgKyB0aGlzLnBlcm1bamogKyBqMSArIHRoaXMucGVybVtrayArIGsxXV1dXTtcclxuICAgICAgICBjb25zdCBnMjogbnVtYmVyW10gPSBOb2lzZTMuZ3JhZGllbnRbdGhpcy5wZXJtTW9kMTJbaWkgKyBpMiArIHRoaXMucGVybVtqaiArIGoyICsgdGhpcy5wZXJtW2trICsgazJdXV1dO1xyXG4gICAgICAgIGNvbnN0IGczOiBudW1iZXJbXSA9IE5vaXNlMy5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIDEgKyB0aGlzLnBlcm1bamogKyAxICsgdGhpcy5wZXJtW2trICsgMV1dXV07XHJcblxyXG4gICAgICAgIC8vIENhbGN1Om51bWJlcmF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20gdGhlIGZvdXIgY29ybmVyc1xyXG4gICAgICAgIGNvbnN0IHQwOiBudW1iZXIgPSAwLjUgLSB4MCAqIHgwIC0geTAgKiB5MCAtIHowICogejA7XHJcbiAgICAgICAgY29uc3QgbjA6IG51bWJlciA9IHQwIDwgMFxyXG4gICAgICAgICAgPyAwLjBcclxuICAgICAgICAgIDogTWF0aC5wb3codDAsIDQpICogKGcwWzBdICogeDAgKyBnMFsxXSAqIHkwICsgZzBbMl0gKiB6MCk7XHJcbiAgICAgICAgY29uc3QgdDE6IG51bWJlciA9IDAuNSAtIHgxICogeDEgLSB5MSAqIHkxIC0gejEgKiB6MTtcclxuICAgICAgICBjb25zdCBuMTogbnVtYmVyID0gdDEgPCAwXHJcbiAgICAgICAgICA/IDAuMFxyXG4gICAgICAgICAgOiBNYXRoLnBvdyh0MSwgNCkgKiAoZzFbMF0gKiB4MSArIGcxWzFdICogeTEgKyBnMVsyXSAqIHoxKTtcclxuICAgICAgICBjb25zdCB0MjogbnVtYmVyID0gMC41IC0geDIgKiB4MiAtIHkyICogeTIgLSB6MiAqIHoyO1xyXG4gICAgICAgIGNvbnN0IG4yOiBudW1iZXIgPSB0MiA8IDBcclxuICAgICAgICAgID8gMC4wXHJcbiAgICAgICAgICA6IE1hdGgucG93KHQyLCA0KSAqIChnMlswXSAqIHgyICsgZzJbMV0gKiB5MiArIGcyWzJdICogejIpO1xyXG4gICAgICAgIGNvbnN0IHQzOiBudW1iZXIgPSAwLjUgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejM7XHJcbiAgICAgICAgY29uc3QgbjM6IG51bWJlciA9IHQzIDwgMFxyXG4gICAgICAgICAgPyAwLjBcclxuICAgICAgICAgIDogTWF0aC5wb3codDMsIDQpICogKGczWzBdICogeDMgKyBnM1sxXSAqIHkzICsgZzNbMl0gKiB6Myk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cclxuICAgICAgICAvLyBUaGUgcmVzdWx0IGlzIHNjYWxlZCB0byBzdGF5IGp1c3QgaW5zaWRlIFstMSwxXVxyXG4gICAgICAgIHJldHVybiA5NC42ODQ5MzE1MDY4MTk3MiAqIChuMCArIG4xICsgbjIgKyBuMyk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNhbXBsZSA9IChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfejogbnVtYmVyKTogbnVtYmVyID0+IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NhbXBsZShfeCwgX3ksIF96KTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLy8gVE9ETzogVGVzdFxyXG4gIC8qKlxyXG4gICAqIFRoaXMgaXMgYW4gYWRhcHRpb24gb2YgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmFzdC1zaW1wbGV4LW5vaXNlXHJcbiAgICogZG9uZSBieSBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqXHJcbiAgICogQmFzZWQgb24gZXhhbXBsZSBjb2RlIGJ5IFN0ZWZhbiBHdXN0YXZzb24gKHN0ZWd1QGl0bi5saXUuc2UpLlxyXG4gICAqIE9wdGltaXNhdGlvbnMgYnkgUGV0ZXIgRWFzdG1hbiAocGVhc3RtYW5AZHJpenpsZS5zdGFuZm9yZC5lZHUpLlxyXG4gICAqIEJldHRlciByYW5rIG9yZGVyaW5nIG1ldGhvZCBieSBTdGVmYW4gR3VzdGF2c29uIGluIDIwMTIuXHJcbiAgICpcclxuICAgKiBUaGlzIGNvZGUgd2FzIHBsYWNlZCBpbiB0aGUgcHVibGljIGRvbWFpbiBieSBpdHMgb3JpZ2luYWwgYXV0aG9yLFxyXG4gICAqIFN0ZWZhbiBHdXN0YXZzb24uIFlvdSBtYXkgdXNlIGl0IGFzIHlvdSBzZWUgZml0LCBidXRcclxuICAgKiBhdHRyaWJ1dGlvbiBpcyBhcHByZWNpYXRlZC5cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTm9pc2U0IGV4dGVuZHMgTm9pc2Uge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgb2Zmc2V0OiBudW1iZXIgPSAoNS4wIC0gTWF0aC5zcXJ0KDUuMCkpIC8gMjAuMDtcclxuICAgIHByaXZhdGUgc3RhdGljIGdyYWRpZW50OiBudW1iZXJbXVtdID0gW1swLCAxLCAxLCAxXSwgWzAsIDEsIDEsIC0xXSwgWzAsIDEsIC0xLCAxXSwgWzAsIDEsIC0xLCAtMV0sIFswLCAtMSwgMSwgMV0sIFswLCAtMSwgMSwgLTFdLCBbMCwgLTEsIC0xLCAxXSwgWzAsIC0xLCAtMSwgLTFdLCBbMSwgMCwgMSwgMV0sIFsxLCAwLCAxLCAtMV0sIFsxLCAwLCAtMSwgMV0sIFsxLCAwLCAtMSwgLTFdLCBbLTEsIDAsIDEsIDFdLCBbLTEsIDAsIDEsIC0xXSwgWy0xLCAwLCAtMSwgMV0sIFstMSwgMCwgLTEsIC0xXSwgWzEsIDEsIDAsIDFdLCBbMSwgMSwgMCwgLTFdLCBbMSwgLTEsIDAsIDFdLCBbMSwgLTEsIDAsIC0xXSwgWy0xLCAxLCAwLCAxXSwgWy0xLCAxLCAwLCAtMV0sIFstMSwgLTEsIDAsIDFdLCBbLTEsIC0xLCAwLCAtMV0sIFsxLCAxLCAxLCAwXSwgWzEsIDEsIC0xLCAwXSwgWzEsIC0xLCAxLCAwXSwgWzEsIC0xLCAtMSwgMF0sIFstMSwgMSwgMSwgMF0sIFstMSwgMSwgLTEsIDBdLCBbLTEsIC0xLCAxLCAwXSwgWy0xLCAtMSwgLTEsIDBdXTtcclxuICAgICNzYW1wbGU6IChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfejogbnVtYmVyLCBfdzogbnVtYmVyKSA9PiBudW1iZXIgPSBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfcmFuZG9tOiBGdW5jdGlvbiA9IE1hdGgucmFuZG9tKSB7XHJcbiAgICAgIHN1cGVyKF9yYW5kb20pO1xyXG5cclxuICAgICAgdGhpcy4jc2FtcGxlID0gKF94OiBudW1iZXIsIF95OiBudW1iZXIsIF96OiBudW1iZXIsIF93OiBudW1iZXIpOiBudW1iZXIgPT4ge1xyXG4gICAgICAgIC8vIFNrZXcgdGhlICh4LHkseix3KSBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggY2VsbCBvZiAyNCBzaW1wbGljZXMgd2UncmUgaW5cclxuICAgICAgICBjb25zdCBzOiBudW1iZXIgPSAoX3ggKyBfeSArIF96ICsgX3cpICogKE1hdGguc3FydCg1LjApIC0gMS4wKSAvIDQuMDsgLy8gRmFjdG9yIGZvciA0RCBza2V3aW5nXHJcbiAgICAgICAgY29uc3QgaTogbnVtYmVyID0gTWF0aC5mbG9vcihfeCArIHMpO1xyXG4gICAgICAgIGNvbnN0IGo6IG51bWJlciA9IE1hdGguZmxvb3IoX3kgKyBzKTtcclxuICAgICAgICBjb25zdCBrOiBudW1iZXIgPSBNYXRoLmZsb29yKF96ICsgcyk7XHJcbiAgICAgICAgY29uc3QgbDogbnVtYmVyID0gTWF0aC5mbG9vcihfdyArIHMpO1xyXG4gICAgICAgIGNvbnN0IHQ6IG51bWJlciA9IChpICsgaiArIGsgKyBsKSAqIE5vaXNlNC5vZmZzZXQ7IC8vIEZhY3RvciBmb3IgNEQgdW5za2V3aW5nXHJcbiAgICAgICAgY29uc3QgWDA6IG51bWJlciA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSx6LHcpIHNwYWNlXHJcbiAgICAgICAgY29uc3QgWTA6IG51bWJlciA9IGogLSB0O1xyXG4gICAgICAgIGNvbnN0IFowOiBudW1iZXIgPSBrIC0gdDtcclxuICAgICAgICBjb25zdCBXMDogbnVtYmVyID0gbCAtIHQ7XHJcbiAgICAgICAgY29uc3QgeDA6IG51bWJlciA9IF94IC0gWDA7IC8vIFRoZSB4LHkseix3IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxyXG4gICAgICAgIGNvbnN0IHkwOiBudW1iZXIgPSBfeSAtIFkwO1xyXG4gICAgICAgIGNvbnN0IHowOiBudW1iZXIgPSBfeiAtIFowO1xyXG4gICAgICAgIGNvbnN0IHcwOiBudW1iZXIgPSBfdyAtIFcwO1xyXG5cclxuICAgICAgICAvLyBUbyBmaW5kIG91dCB3aGljaCBvZiB0aGUgMjQgcG9zc2libGUgc2ltcGxpY2VzIHdlJ3JlIGluLCB3ZSBuZWVkIHRvIGRldGVybWluZSB0aGVcclxuICAgICAgICAvLyBtYWduaXR1ZGUgb3JkZXJpbmcgb2YgeDAsIHkwLCB6MCBhbmQgdzAuIFNpeCBwYWlyLXdpc2UgY29tcGFyaXNvbnMgYXJlIHBlcmZvcm1lZCBiZXR3ZWVuXHJcbiAgICAgICAgLy8gZWFjaCBwb3NzaWJsZSBwYWlyIG9mIHRoZSBmb3VyIGNvb3JkaW5hdGVzLCBhbmQgdGhlIHJlc3VsdHMgYXJlIHVzZWQgdG8gcmFuayB0aGUgbnVtYmVycy5cclxuICAgICAgICBsZXQgcmFua3g6IG51bWJlciA9IDA7XHJcbiAgICAgICAgbGV0IHJhbmt5OiBudW1iZXIgPSAwO1xyXG4gICAgICAgIGxldCByYW5rejogbnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgcmFua3c6IG51bWJlciA9IDA7XHJcbiAgICAgICAgaWYgKHgwID4geTApIHJhbmt4Kys7XHJcbiAgICAgICAgZWxzZSByYW5reSsrO1xyXG4gICAgICAgIGlmICh4MCA+IHowKSByYW5reCsrO1xyXG4gICAgICAgIGVsc2UgcmFua3orKztcclxuICAgICAgICBpZiAoeDAgPiB3MCkgcmFua3grKztcclxuICAgICAgICBlbHNlIHJhbmt3Kys7XHJcbiAgICAgICAgaWYgKHkwID4gejApIHJhbmt5Kys7XHJcbiAgICAgICAgZWxzZSByYW5reisrO1xyXG4gICAgICAgIGlmICh5MCA+IHcwKSByYW5reSsrO1xyXG4gICAgICAgIGVsc2UgcmFua3crKztcclxuICAgICAgICBpZiAoejAgPiB3MCkgcmFua3orKztcclxuICAgICAgICBlbHNlIHJhbmt3Kys7XHJcblxyXG4gICAgICAgIC8vIHNpbXBsZXhbY10gaXMgYSA0LXZlY3RvciB3aXRoIHRoZSBudW1iZXJzIDAsIDEsIDIgYW5kIDMgaW4gc29tZSBvcmRlci5cclxuICAgICAgICAvLyBNYW55IHZhbHVlcyBvZiBjIHdpbGwgbmV2ZXIgb2NjdXIsIHNpbmNlIGUuZy4geD55Pno+dyBtYWtlcyB4PHosIHk8dyBhbmQgeDx3XHJcbiAgICAgICAgLy8gaW1wb3NzaWJsZS4gT25seSB0aGUgMjQgaW5kaWNlcyB3aGljaCBoYXZlIG5vbi16ZXJvIGVudHJpZXMgbWFrZSBhbnkgc2Vuc2UuXHJcbiAgICAgICAgLy8gV2UgdXNlIGEgdGhyZXNob2xkaW5nIHRvIHNldCB0aGUgY29vcmRpbmF0ZXMgaW4gdHVybiBmcm9tIHRoZSBsYXJnZXN0IG1hZ25pdHVkZS5cclxuICAgICAgICAvLyBSYW5rIDMgZGVub3RlcyB0aGUgbGFyZ2VzdCBjb29yZGluYXRlLlxyXG4gICAgICAgIGNvbnN0IGkxOiBudW1iZXIgPSByYW5reCA+PSAzID8gMSA6IDA7XHJcbiAgICAgICAgY29uc3QgajE6IG51bWJlciA9IHJhbmt5ID49IDMgPyAxIDogMDtcclxuICAgICAgICBjb25zdCBrMTogbnVtYmVyID0gcmFua3ogPj0gMyA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGwxOiBudW1iZXIgPSByYW5rdyA+PSAzID8gMSA6IDA7XHJcbiAgICAgICAgLy8gUmFuayA6IDIgZGVub3RlcyB0aGUgc2Vjb25kIGxhcmdlc3QgY29vcmRpbmF0ZS5cclxuICAgICAgICBjb25zdCBpMjogbnVtYmVyID0gcmFua3ggPj0gMiA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGoyOiBudW1iZXIgPSByYW5reSA+PSAyID8gMSA6IDA7XHJcbiAgICAgICAgY29uc3QgazI6IG51bWJlciA9IHJhbmt6ID49IDIgPyAxIDogMDtcclxuICAgICAgICBjb25zdCBsMjogbnVtYmVyID0gcmFua3cgPj0gMiA/IDEgOiAwO1xyXG4gICAgICAgIC8vIFJhbmsgOiAxIGRlbm90ZXMgdGhlIHNlY29uZCBzbWFsbGVzdCBjb29yZGluYXRlLlxyXG4gICAgICAgIGNvbnN0IGkzOiBudW1iZXIgPSByYW5reCA+PSAxID8gMSA6IDA7XHJcbiAgICAgICAgY29uc3QgajM6IG51bWJlciA9IHJhbmt5ID49IDEgPyAxIDogMDtcclxuICAgICAgICBjb25zdCBrMzogbnVtYmVyID0gcmFua3ogPj0gMSA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGwzOiBudW1iZXIgPSByYW5rdyA+PSAxID8gMSA6IDA7XHJcblxyXG4gICAgICAgIC8vIFRoZSBmaWZ0aCBjb3JuZXIgaGFzIGFsbCBjb29yZGluYXRlIG9mZnNldHMgPSAxLCBzbyBubyBuZWVkIHRvIGNvbXB1dGUgdGhhdC5cclxuICAgICAgICBjb25zdCB4MTogbnVtYmVyID0geDAgLSBpMSArIE5vaXNlNC5vZmZzZXQ7IC8vIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xyXG4gICAgICAgIGNvbnN0IHkxOiBudW1iZXIgPSB5MCAtIGoxICsgTm9pc2U0Lm9mZnNldDtcclxuICAgICAgICBjb25zdCB6MTogbnVtYmVyID0gejAgLSBrMSArIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgdzE6IG51bWJlciA9IHcwIC0gbDEgKyBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHgyOiBudW1iZXIgPSB4MCAtIGkyICsgMi4wICogTm9pc2U0Lm9mZnNldDsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcclxuICAgICAgICBjb25zdCB5MjogbnVtYmVyID0geTAgLSBqMiArIDIuMCAqIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgejI6IG51bWJlciA9IHowIC0gazIgKyAyLjAgKiBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHcyOiBudW1iZXIgPSB3MCAtIGwyICsgMi4wICogTm9pc2U0Lm9mZnNldDtcclxuICAgICAgICBjb25zdCB4MzogbnVtYmVyID0geDAgLSBpMyArIDMuMCAqIE5vaXNlNC5vZmZzZXQ7IC8vIE9mZnNldHMgZm9yIGZvdXJ0aCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xyXG4gICAgICAgIGNvbnN0IHkzOiBudW1iZXIgPSB5MCAtIGozICsgMy4wICogTm9pc2U0Lm9mZnNldDtcclxuICAgICAgICBjb25zdCB6MzogbnVtYmVyID0gejAgLSBrMyArIDMuMCAqIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgdzM6IG51bWJlciA9IHcwIC0gbDMgKyAzLjAgKiBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHg0OiBudW1iZXIgPSB4MCAtIDEuMCArIDQuMCAqIE5vaXNlNC5vZmZzZXQ7IC8vIE9mZnNldHMgZm9yIGxhc3QgY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcclxuICAgICAgICBjb25zdCB5NDogbnVtYmVyID0geTAgLSAxLjAgKyA0LjAgKiBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHo0OiBudW1iZXIgPSB6MCAtIDEuMCArIDQuMCAqIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgdzQ6IG51bWJlciA9IHcwIC0gMS4wICsgNC4wICogTm9pc2U0Lm9mZnNldDtcclxuXHJcbiAgICAgICAgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmaXZlIHNpbXBsZXggY29ybmVyc1xyXG4gICAgICAgIGNvbnN0IGlpOiBudW1iZXIgPSBpICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGpqOiBudW1iZXIgPSBqICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGtrOiBudW1iZXIgPSBrICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGxsOiBudW1iZXIgPSBsICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGcwOiBudW1iZXJbXSA9IE5vaXNlNC5ncmFkaWVudFtcclxuICAgICAgICAgIHRoaXMucGVybVtpaSArIHRoaXMucGVybVtqaiArIHRoaXMucGVybVtrayArIHRoaXMucGVybVtsbF1dXV0gJVxyXG4gICAgICAgICAgMzJcclxuICAgICAgICBdO1xyXG4gICAgICAgIGNvbnN0IGcxOiBudW1iZXJbXSA9IE5vaXNlNC5ncmFkaWVudFtcclxuICAgICAgICAgIHRoaXMucGVybVtcclxuICAgICAgICAgICAgaWkgKyBpMSArIHRoaXMucGVybVtqaiArIGoxICsgdGhpcy5wZXJtW2trICsgazEgKyB0aGlzLnBlcm1bbGwgKyBsMV1dXVxyXG4gICAgICAgICAgXSAlIDMyXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCBnMjogbnVtYmVyW10gPSBOb2lzZTQuZ3JhZGllbnRbXHJcbiAgICAgICAgICB0aGlzLnBlcm1bXHJcbiAgICAgICAgICAgIGlpICsgaTIgKyB0aGlzLnBlcm1bamogKyBqMiArIHRoaXMucGVybVtrayArIGsyICsgdGhpcy5wZXJtW2xsICsgbDJdXV1cclxuICAgICAgICAgIF0gJSAzMlxyXG4gICAgICAgIF07XHJcbiAgICAgICAgY29uc3QgZzM6IG51bWJlcltdID0gTm9pc2U0LmdyYWRpZW50W1xyXG4gICAgICAgICAgdGhpcy5wZXJtW1xyXG4gICAgICAgICAgICBpaSArIGkzICsgdGhpcy5wZXJtW2pqICsgajMgKyB0aGlzLnBlcm1ba2sgKyBrMyArIHRoaXMucGVybVtsbCArIGwzXV1dXHJcbiAgICAgICAgICBdICUgMzJcclxuICAgICAgICBdO1xyXG4gICAgICAgIGNvbnN0IGc0OiBudW1iZXJbXSA9IE5vaXNlNC5ncmFkaWVudFtcclxuICAgICAgICAgIHRoaXMucGVybVtcclxuICAgICAgICAgICAgaWkgKyAxICsgdGhpcy5wZXJtW2pqICsgMSArIHRoaXMucGVybVtrayArIDEgKyB0aGlzLnBlcm1bbGwgKyAxXV1dXHJcbiAgICAgICAgICBdICUgMzJcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSBmaXZlIGNvcm5lcnNcclxuICAgICAgICBjb25zdCB0MDogbnVtYmVyID0gMC41IC0geDAgKiB4MCAtIHkwICogeTAgLSB6MCAqIHowIC0gdzAgKiB3MDtcclxuICAgICAgICBjb25zdCBuMDogbnVtYmVyID0gdDAgPCAwXHJcbiAgICAgICAgICA/IDAuMFxyXG4gICAgICAgICAgOiBNYXRoLnBvdyh0MCwgNCkgKiAoZzBbMF0gKiB4MCArIGcwWzFdICogeTAgKyBnMFsyXSAqIHowICsgZzBbM10gKiB3MCk7XHJcbiAgICAgICAgY29uc3QgdDE6IG51bWJlciA9IDAuNSAtIHgxICogeDEgLSB5MSAqIHkxIC0gejEgKiB6MSAtIHcxICogdzE7XHJcbiAgICAgICAgY29uc3QgbjE6IG51bWJlciA9IHQxIDwgMFxyXG4gICAgICAgICAgPyAwLjBcclxuICAgICAgICAgIDogTWF0aC5wb3codDEsIDQpICogKGcxWzBdICogeDEgKyBnMVsxXSAqIHkxICsgZzFbMl0gKiB6MSArIGcxWzNdICogdzEpO1xyXG4gICAgICAgIGNvbnN0IHQyOiBudW1iZXIgPSAwLjUgLSB4MiAqIHgyIC0geTIgKiB5MiAtIHoyICogejIgLSB3MiAqIHcyO1xyXG4gICAgICAgIGNvbnN0IG4yOiBudW1iZXIgPSB0MiA8IDBcclxuICAgICAgICAgID8gMC4wXHJcbiAgICAgICAgICA6IE1hdGgucG93KHQyLCA0KSAqIChnMlswXSAqIHgyICsgZzJbMV0gKiB5MiArIGcyWzJdICogejIgKyBnMlszXSAqIHcyKTtcclxuICAgICAgICBjb25zdCB0MzogbnVtYmVyID0gMC41IC0geDMgKiB4MyAtIHkzICogeTMgLSB6MyAqIHozIC0gdzMgKiB3MztcclxuICAgICAgICBjb25zdCBuMzogbnVtYmVyID0gdDMgPCAwXHJcbiAgICAgICAgICA/IDAuMFxyXG4gICAgICAgICAgOiBNYXRoLnBvdyh0MywgNCkgKiAoZzNbMF0gKiB4MyArIGczWzFdICogeTMgKyBnM1syXSAqIHozICsgZzNbM10gKiB3Myk7XHJcbiAgICAgICAgY29uc3QgdDQ6IG51bWJlciA9IDAuNSAtIHg0ICogeDQgLSB5NCAqIHk0IC0gejQgKiB6NCAtIHc0ICogdzQ7XHJcbiAgICAgICAgY29uc3QgbjQ6IG51bWJlciA9IHQ0IDwgMFxyXG4gICAgICAgICAgPyAwLjBcclxuICAgICAgICAgIDogTWF0aC5wb3codDQsIDQpICogKGc0WzBdICogeDQgKyBnNFsxXSAqIHk0ICsgZzRbMl0gKiB6NCArIGc0WzNdICogdzQpO1xyXG5cclxuICAgICAgICAvLyBTdW0gdXAgYW5kIHNjYWxlIHRoZSByZXN1bHQgdG8gY292ZXIgdGhlIHJhbmdlIFstMSwxXVxyXG4gICAgICAgIHJldHVybiA3Mi4zNzg1NTc2NTE1MzY2NSAqIChuMCArIG4xICsgbjIgKyBuMyArIG40KTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2FtcGxlID0gKF94OiBudW1iZXIsIF95OiBudW1iZXIsIF96OiBudW1iZXIsIF93OiBudW1iZXIpOiBudW1iZXIgPT4ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc2FtcGxlKF94LCBfeSwgX3osIF93KTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAqIFN0b3JpbmcgYW5kIG1hbmlwdWxhdGluZyByb3RhdGlvbnMgaW4gdGhlIGZvcm0gb2YgcXVhdGVybmlvbnMuXHJcbiAgICAqIENvbnN0cnVjdGVkIG91dCBvZiB0aGUgNCBjb21wb25lbnRzOiAoeCwgeSwgeiwgdykuIE1hdGhlbWF0aWNhbCBub3RhdGlvbjogdyArIHhpICsgeWogKyB6ay5cclxuICAgICogQSBRdWF0ZXJuaW9uIGNhbiBiZSBkZXNjcmliZWQgd2l0aCBhbiBheGlzIGFuZCBhbmdsZTogKHgsIHksIHopID0gc2luKGFuZ2xlLzIpKmF4aXM7IHcgPSBjb3MoYW5nbGUvMikuXHJcbiAgICAqIHJvbGw6IHgsIHBpdGNoOiB5LCB5YXc6IHouIE5vdGUgdGhhdCBvcGVyYXRpb25zIGFyZSBhZGFwdGVkIHRvIHdvcmsgd2l0aCB2ZWN0b3JzIHdoZXJlIHkgaXMgdXAgYW5kIHogaXMgZm9yd2FyZC5cclxuICAgICogQGF1dGhvcnMgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjMgfCBNYXJrbyBGZWhyZW5iYWNoLCBIRlUsIDIwMjAgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjNcclxuICAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFF1YXRlcm5pb24gZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlLCBSZWN5Y2FibGUge1xyXG4gICAgcHVibGljIHg6IG51bWJlcjtcclxuICAgIHB1YmxpYyB5OiBudW1iZXI7XHJcbiAgICBwdWJsaWMgejogbnVtYmVyO1xyXG4gICAgcHVibGljIHc6IG51bWJlcjtcclxuICAgIHByaXZhdGUgbXV0YXRvcjogTXV0YXRvciA9IG51bGw7IC8vIHByZXBhcmVkIGZvciBvcHRpbWl6YXRpb24sIGtlZXAgbXV0YXRvciB0byByZWR1Y2UgcmVkdW5kYW50IGNhbGN1bGF0aW9uIGFuZCBmb3IgY29tcGFyaXNvbi4gU2V0IHRvIG51bGwgd2hlbiBkYXRhIGNoYW5nZXMhXHJcblxyXG4gICAgcmVhZG9ubHkgI2V1bGVyQW5nbGVzOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7IC8vIGV1bGVyIGFuZ2xlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcXVhdGVybmlvbiBpbiBkZWdyZWVzLlxyXG4gICAgI2V1bGVyQW5nbGVzRGlydHk6IGJvb2xlYW47XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCwgX3o6IG51bWJlciA9IDAsIF93OiBudW1iZXIgPSAxKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2V0KF94LCBfeSwgX3osIF93KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIGEgbmV3IGlkZW50aXR5IHF1YXRlcm5pb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBJREVOVElUWSgpOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgY29uc3QgcmVzdWx0OiBRdWF0ZXJuaW9uID0gUmVjeWNsZXIuZ2V0KFF1YXRlcm5pb24pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHF1YXRlcm5pb24gd2hpY2ggaXMgYSBjb3B5IG9mIHRoZSBnaXZlbiBxdWF0ZXJuaW9uIHNjYWxlZCB0byBsZW5ndGggMS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBOT1JNQUxJWkFUSU9OKF9xOiBRdWF0ZXJuaW9uKTogUXVhdGVybmlvbiB7XHJcbiAgICAgIHJldHVybiBfcS5jbG9uZS5ub3JtYWxpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyB3aGVuIG11bHRpcGxpZWQgYnksIHVzaW5nIHRoZSBhbmdsZXMgZ2l2ZW4uXHJcbiAgICAgKiBSb3RhdGlvbiBvY2N1cnMgYXJvdW5kIHRoZSBheGlzIGluIHRoZSBvcmRlciBaLVktWC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTihfZXVsZXJBbmdsZXM6IFZlY3RvcjMpOiBRdWF0ZXJuaW9uO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcXVhdGVybmlvbiB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgd2hlbiBtdWx0aXBsaWVkIGJ5LCB1c2luZyB0aGUgYXhpcyBhbmQgYW5nbGUgZ2l2ZW4uXHJcbiAgICAgKiBBeGlzIG11c3QgYmUgbm9ybWFsaXplZC4gQW5nbGUgaXMgaW4gZGVncmVlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTihfYXhpczogVmVjdG9yMywgX2FuZ2xlOiBudW1iZXIpOiBRdWF0ZXJuaW9uO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcXVhdGVybmlvbiB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgd2hlbiBtdWx0aXBsaWVkIGJ5LCB1c2luZyB0aGUgZm9yd2FyZCBhbmQgdXAgZGlyZWN0aW9uIGdpdmVuLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OKF9mb3J3YXJkOiBWZWN0b3IzLCBfdXA6IFZlY3RvcjMpOiBRdWF0ZXJuaW9uO1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTihfdmVjdG9yOiBWZWN0b3IzLCBfYW5nbGVPclVwPzogbnVtYmVyIHwgVmVjdG9yMyk6IFF1YXRlcm5pb24ge1xyXG4gICAgICBjb25zdCByZXN1bHQ6IFF1YXRlcm5pb24gPSBSZWN5Y2xlci5nZXQoUXVhdGVybmlvbik7XHJcbiAgICAgIGlmIChfYW5nbGVPclVwID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJlc3VsdC5ldWxlckFuZ2xlcyA9IF92ZWN0b3I7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF9hbmdsZU9yVXAgPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIGxldCBoYWxmQW5nbGU6IG51bWJlciA9IF9hbmdsZU9yVXAgKiBDYWxjLmRlZzJyYWQgLyAyO1xyXG4gICAgICAgIGxldCBzaW5IYWxmQW5nbGU6IG51bWJlciA9IE1hdGguc2luKGhhbGZBbmdsZSk7XHJcblxyXG4gICAgICAgIHJlc3VsdC5zZXQoXHJcbiAgICAgICAgICBfdmVjdG9yLnggKiBzaW5IYWxmQW5nbGUsXHJcbiAgICAgICAgICBfdmVjdG9yLnkgKiBzaW5IYWxmQW5nbGUsXHJcbiAgICAgICAgICBfdmVjdG9yLnogKiBzaW5IYWxmQW5nbGUsXHJcbiAgICAgICAgICBNYXRoLmNvcyhoYWxmQW5nbGUpXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCByaWdodDogVmVjdG9yMyA9IFZlY3RvcjMuQ1JPU1MoX2FuZ2xlT3JVcCwgX3ZlY3Rvcik7XHJcbiAgICAgICAgY29uc3QgbWF0cml4OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5yZXVzZShNYXRyaXg0eDQpO1xyXG4gICAgICAgIG1hdHJpeC5zZXQoW1xyXG4gICAgICAgICAgcmlnaHQueCwgcmlnaHQueSwgcmlnaHQueiwgMCxcclxuICAgICAgICAgIF9hbmdsZU9yVXAueCwgX2FuZ2xlT3JVcC55LCBfYW5nbGVPclVwLnosIDAsXHJcbiAgICAgICAgICBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56LCAwLFxyXG4gICAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICAgIF0pO1xyXG5cclxuICAgICAgICByZXN1bHQuY29weShtYXRyaXgucXVhdGVybmlvbik7XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmVNdWx0aXBsZShyaWdodCwgbWF0cml4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHR3byBwYXNzZWQgcXVhdGVybmlvbnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUFJPRFVDVChfcUxlZnQ6IFF1YXRlcm5pb24sIF9xUmlnaHQ6IFF1YXRlcm5pb24pOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgcmV0dXJuIF9xTGVmdC5jbG9uZS5tdWx0aXBseShfcVJpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBpbnZlcnNlIG9mIGEgcGFzc2VkIHF1YXRlcm5pb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgSU5WRVJTRShfcTogUXVhdGVybmlvbik6IFF1YXRlcm5pb24ge1xyXG4gICAgICByZXR1cm4gX3EuY2xvbmUuaW52ZXJ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgY29uanVnYXRlIG9mIGEgcGFzc2VkIHF1YXRlcm5pb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQ09OSlVHQVRJT04oX3E6IFF1YXRlcm5pb24pOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgcmV0dXJuIF9xLmNsb25lLmNvbmp1Z2F0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXRlcm5pb25zLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERPVChfcTE6IFF1YXRlcm5pb24sIF9xMjogUXVhdGVybmlvbik6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBfcTEueCAqIF9xMi54ICsgX3ExLnkgKiBfcTIueSArIF9xMS56ICogX3EyLnogKyBfcTEudyAqIF9xMi53O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbm9ybWFsaXplZCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0ZXJuaW9ucyBiYXNlZCBvbiB0aGUgZ2l2ZW4gX2ZhY3Rvci4gV2hlbiBfZmFjdG9yIGlzIDAgdGhlIHJlc3VsdCBpcyBfZnJvbSwgd2hlbiBfZmFjdG9yIGlzIDEgdGhlIHJlc3VsdCBpcyBfdG8uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTEVSUChfZnJvbTogUXVhdGVybmlvbiwgX3RvOiBRdWF0ZXJuaW9uLCBfZmFjdG9yOiBudW1iZXIpOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgbGV0IHJlc3VsdDogUXVhdGVybmlvbiA9IFJlY3ljbGVyLmdldChRdWF0ZXJuaW9uKTtcclxuICAgICAgcmVzdWx0LnNldChcclxuICAgICAgICAoX2Zyb20ueCAqICgxIC0gX2ZhY3RvcikgKyBfdG8ueCAqIF9mYWN0b3IpLFxyXG4gICAgICAgIChfZnJvbS55ICogKDEgLSBfZmFjdG9yKSArIF90by55ICogX2ZhY3RvciksXHJcbiAgICAgICAgKF9mcm9tLnogKiAoMSAtIF9mYWN0b3IpICsgX3RvLnogKiBfZmFjdG9yKSxcclxuICAgICAgICAoX2Zyb20udyAqICgxIC0gX2ZhY3RvcikgKyBfdG8udyAqIF9mYWN0b3IpXHJcbiAgICAgICk7XHJcbiAgICAgIHJlc3VsdC5ub3JtYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0ZXJuaW9ucyBiYXNlZCBvbiB0aGUgZ2l2ZW4gX2ZhY3Rvci4gV2hlbiBfZmFjdG9yIGlzIDAgdGhlIHJlc3VsdCBpcyBfZnJvbSwgd2hlbiBfZmFjdG9yIGlzIDEgdGhlIHJlc3VsdCBpcyBfdG8uIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNMRVJQKF9mcm9tOiBRdWF0ZXJuaW9uLCBfdG86IFF1YXRlcm5pb24sIF9mYWN0b3I6IG51bWJlcik6IFF1YXRlcm5pb24ge1xyXG4gICAgICAvLyBGcm9tOiBodHRwczovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cclxuICAgICAgY29uc3QgcmVzdWx0OiBRdWF0ZXJuaW9uID0gUmVjeWNsZXIucmV1c2UoUXVhdGVybmlvbik7XHJcbiAgICAgIGxldCBjb3NIYWxmVGhldGE6IG51bWJlciA9IF9mcm9tLncgKiBfdG8udyArIF9mcm9tLnggKiBfdG8ueCArIF9mcm9tLnkgKiBfdG8ueSArIF9mcm9tLnogKiBfdG8uejtcclxuICAgICAgaWYgKE1hdGguYWJzKGNvc0hhbGZUaGV0YSkgPj0gMSkgXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KF9mcm9tKTtcclxuICAgICAgXHJcbiAgICAgIGxldCBoYWxmVGhldGE6IG51bWJlciA9IE1hdGguYWNvcyhjb3NIYWxmVGhldGEpO1xyXG4gICAgICBsZXQgc2luSGFsZlRoZXRhOiBudW1iZXIgPSBNYXRoLnNxcnQoMSAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YSk7XHJcbiAgICAgIGlmIChNYXRoLmFicyhzaW5IYWxmVGhldGEpIDwgMC4wMDEpIHtcclxuICAgICAgICByZXN1bHQuc2V0KFxyXG4gICAgICAgICAgKF9mcm9tLnggKiAwLjUgKyBfdG8ueCAqIDAuNSksXHJcbiAgICAgICAgICAoX2Zyb20ueSAqIDAuNSArIF90by55ICogMC41KSxcclxuICAgICAgICAgIChfZnJvbS56ICogMC41ICsgX3RvLnogKiAwLjUpLFxyXG4gICAgICAgICAgKF9mcm9tLncgKiAwLjUgKyBfdG8udyAqIDAuNSlcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGxldCByYXRpb0E6IG51bWJlciA9IE1hdGguc2luKCgxIC0gX2ZhY3RvcikgKiBoYWxmVGhldGEpIC8gc2luSGFsZlRoZXRhO1xyXG4gICAgICBsZXQgcmF0aW9COiBudW1iZXIgPSBNYXRoLnNpbihfZmFjdG9yICogaGFsZlRoZXRhKSAvIHNpbkhhbGZUaGV0YTtcclxuICAgICAgcmVzdWx0LnNldChcclxuICAgICAgICAoX2Zyb20ueCAqIHJhdGlvQSArIF90by54ICogcmF0aW9CKSxcclxuICAgICAgICAoX2Zyb20ueSAqIHJhdGlvQSArIF90by55ICogcmF0aW9CKSxcclxuICAgICAgICAoX2Zyb20ueiAqIHJhdGlvQSArIF90by56ICogcmF0aW9CKSxcclxuICAgICAgICAoX2Zyb20udyAqIHJhdGlvQSArIF90by53ICogcmF0aW9CKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE5lZ2F0ZXMgdGhlIGdpdmVuIHF1YXRlcm5pb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgbmVnYXRlKF9xOiBRdWF0ZXJuaW9uKTogdm9pZCB7XHJcbiAgICAgIF9xLnggPSAtX3EueDtcclxuICAgICAgX3EueSA9IC1fcS55O1xyXG4gICAgICBfcS56ID0gLV9xLno7XHJcbiAgICAgIF9xLncgPSAtX3EudztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBjbG9uZSBvZiB0aGlzIHF1YXRlcm5pb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY2xvbmUoKTogUXVhdGVybmlvbiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFF1YXRlcm5pb24gPSBSZWN5Y2xlci5yZXVzZShRdWF0ZXJuaW9uKTtcclxuICAgICAgcmVzdWx0LmNvcHkodGhpcyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAtIGdldDogcmV0dXJuIHRoZSBldWxlciBhbmdsZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcm90YXRpb24gaW4gZGVncmVlcy4gXHJcbiAgICAgKiAqKkNhdXRpb24hKiogVXNlIGltbWVkaWF0ZWx5IGFuZCByZWFkb25seSwgc2luY2UgdGhlIHZlY3RvciBpcyBnb2luZyB0byBiZSByZXVzZWQgaW50ZXJuYWxseS4gQ3JlYXRlIGEgY2xvbmUgdG8ga2VlcCBsb25nZXIgYW5kIG1hbmlwdWxhdGUuIFxyXG4gICAgICogLSBzZXQ6IHNldCB0aGUgZXVsZXIgYW5nbGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJvdGF0aW9uIGluIGRlZ3JlZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgZXVsZXJBbmdsZXMoKTogVmVjdG9yMyB7XHJcbiAgICAgIGlmICh0aGlzLiNldWxlckFuZ2xlc0RpcnR5KSB7XHJcbiAgICAgICAgdGhpcy4jZXVsZXJBbmdsZXNEaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy54ID09IDAgJiYgdGhpcy55ID09IDAgJiYgdGhpcy56ID09IDAgJiYgdGhpcy53ID09IDEpIHtcclxuICAgICAgICAgIHRoaXMuI2V1bGVyQW5nbGVzLnNldCgwLCAwLCAwKTtcclxuICAgICAgICAgIHJldHVybiB0aGlzLiNldWxlckFuZ2xlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJvbGwgKHgtYXhpcyByb3RhdGlvbilcclxuICAgICAgICBsZXQgc2lucmNvc3A6IG51bWJlciA9IDIgKiAodGhpcy53ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy56KTtcclxuICAgICAgICBsZXQgY29zcmNvc3A6IG51bWJlciA9IDEgLSAyICogKHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XHJcbiAgICAgICAgdGhpcy4jZXVsZXJBbmdsZXMueCA9IE1hdGguYXRhbjIoc2lucmNvc3AsIGNvc3Jjb3NwKTtcclxuXHJcbiAgICAgICAgLy8gcGl0Y2ggKHktYXhpcyByb3RhdGlvbilcclxuICAgICAgICBsZXQgc2lucDogbnVtYmVyID0gMiAqICh0aGlzLncgKiB0aGlzLnkgLSB0aGlzLnogKiB0aGlzLngpO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhzaW5wKSA+PSAxKVxyXG4gICAgICAgICAgdGhpcy4jZXVsZXJBbmdsZXMueSA9IHNpbnAgPCAwID8gLU1hdGguYWJzKE1hdGguUEkgLyAyKSA6IE1hdGguYWJzKE1hdGguUEkgLyAyKTsgLy8gdXNlIDkwIGRlZ3JlZXMgaWYgb3V0IG9mIHJhbmdlXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhpcy4jZXVsZXJBbmdsZXMueSA9IE1hdGguYXNpbihzaW5wKTtcclxuXHJcbiAgICAgICAgLy8geWF3ICh6LWF4aXMgcm90YXRpb24pXHJcbiAgICAgICAgbGV0IHNpbnljb3NwOiBudW1iZXIgPSAyICogKHRoaXMudyAqIHRoaXMueiArIHRoaXMueCAqIHRoaXMueSk7XHJcbiAgICAgICAgbGV0IGNvc3ljb3NwOiBudW1iZXIgPSAxIC0gMiAqICh0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnopO1xyXG4gICAgICAgIHRoaXMuI2V1bGVyQW5nbGVzLnogPSBNYXRoLmF0YW4yKHNpbnljb3NwLCBjb3N5Y29zcCk7XHJcblxyXG4gICAgICAgIHRoaXMuI2V1bGVyQW5nbGVzLnNjYWxlKENhbGMucmFkMmRlZyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLiNldWxlckFuZ2xlcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGV1bGVyQW5nbGVzKF9ldWxlckFuZ2xlczogVmVjdG9yMykge1xyXG4gICAgICBjb25zdCBoYWxmQW5nbGVzSW5SYWRpYW5zOiBWZWN0b3IzID0gVmVjdG9yMy5TQ0FMRShfZXVsZXJBbmdsZXMsIENhbGMuZGVnMnJhZCAvIDIpO1xyXG4gICAgICBjb25zdCBjb3NYOiBudW1iZXIgPSBNYXRoLmNvcyhoYWxmQW5nbGVzSW5SYWRpYW5zLngpO1xyXG4gICAgICBjb25zdCBjb3NZOiBudW1iZXIgPSBNYXRoLmNvcyhoYWxmQW5nbGVzSW5SYWRpYW5zLnkpO1xyXG4gICAgICBjb25zdCBjb3NaOiBudW1iZXIgPSBNYXRoLmNvcyhoYWxmQW5nbGVzSW5SYWRpYW5zLnopO1xyXG4gICAgICBjb25zdCBzaW5YOiBudW1iZXIgPSBNYXRoLnNpbihoYWxmQW5nbGVzSW5SYWRpYW5zLngpO1xyXG4gICAgICBjb25zdCBzaW5ZOiBudW1iZXIgPSBNYXRoLnNpbihoYWxmQW5nbGVzSW5SYWRpYW5zLnkpO1xyXG4gICAgICBjb25zdCBzaW5aOiBudW1iZXIgPSBNYXRoLnNpbihoYWxmQW5nbGVzSW5SYWRpYW5zLnopO1xyXG5cclxuICAgICAgdGhpcy5zZXQoXHJcbiAgICAgICAgc2luWCAqIGNvc1kgKiBjb3NaIC0gY29zWCAqIHNpblkgKiBzaW5aLFxyXG4gICAgICAgIGNvc1ggKiBzaW5ZICogY29zWiArIHNpblggKiBjb3NZICogc2luWixcclxuICAgICAgICBjb3NYICogY29zWSAqIHNpblogLSBzaW5YICogc2luWSAqIGNvc1osXHJcbiAgICAgICAgY29zWCAqIGNvc1kgKiBjb3NaICsgc2luWCAqIHNpblkgKiBzaW5aXHJcbiAgICAgICk7XHJcblxyXG4gICAgICB0aGlzLiNldWxlckFuZ2xlcy5jb3B5KF9ldWxlckFuZ2xlcyk7XHJcbiAgICAgIHRoaXMuI2V1bGVyQW5nbGVzRGlydHkgPSBmYWxzZTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoaGFsZkFuZ2xlc0luUmFkaWFucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemVzIHRoaXMgcXVhdGVybmlvbiB0byBhIGxlbmd0aCBvZiAxIChhIHVuaXQgcXVhdGVybmlvbikgbWFraW5nIGl0IGEgdmFsaWQgcm90YXRpb24gcmVwcmVzZW50YXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vcm1hbGl6ZSgpOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgbGV0IGxlbmd0aDogbnVtYmVyID0gTWF0aC5zcXJ0KHRoaXMueCAqKiAyICsgdGhpcy55ICoqIDIgKyB0aGlzLnogKiogMiArIHRoaXMudyAqKiAyKTtcclxuICAgICAgdGhpcy54IC89IGxlbmd0aDtcclxuICAgICAgdGhpcy55IC89IGxlbmd0aDtcclxuICAgICAgdGhpcy56IC89IGxlbmd0aDtcclxuICAgICAgdGhpcy53IC89IGxlbmd0aDtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTmVnYXRlIHRoaXMgcXVhdGVybmlvbiBhbmQgcmV0dXJucyBpdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmVnYXRlKCk6IFF1YXRlcm5pb24ge1xyXG4gICAgICB0aGlzLnggKj0gLTE7XHJcbiAgICAgIHRoaXMueSAqPSAtMTtcclxuICAgICAgdGhpcy56ICo9IC0xO1xyXG4gICAgICB0aGlzLncgKj0gLTE7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgcXVhdGVybmlvbiB0byB0aGUgaWRlbnRpdHktcXVhdGVybmlvbiBhbmQgY2xlYXJzIGNhY2hlLiBVc2VkIGJ5IHRoZSByZWN5Y2xlciB0byByZXNldC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW52ZXJ0IHRoaXMgcXVhdGVybmlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGludmVydCgpOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgLy8gcXVhdGVybmlvbiBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcclxuICAgICAgcmV0dXJuIHRoaXMuY29uanVnYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25qdWdhdGVzIHRoaXMgcXVhdGVybmlvbiBhbmQgcmV0dXJucyBpdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbmp1Z2F0ZSgpOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgdGhpcy54ICo9IC0xO1xyXG4gICAgICB0aGlzLnkgKj0gLTE7XHJcbiAgICAgIHRoaXMueiAqPSAtMTtcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlcyB0aGlzIHF1YXRlcm5pb24gYXJvdW5kIHRoZSBnaXZlbiBheGlzIGJ5IHRoZSBnaXZlbiBhbmdsZS5cclxuICAgICAqIFRoZSByb3RhdGlvbiBpcyBhcHBlbmRlZCB0byBhbHJlYWR5IGFwcGxpZWQgcm90YXRpb25zLCB0aHVzIG11bHRpcGxpZWQgZnJvbSB0aGUgcmlnaHQuIFNldCBfZnJvbUxlZnQgdG8gdHJ1ZSB0byBzd2l0Y2ggYW5kIHB1dCBpdCBpbiBmcm9udC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJvdGF0ZShfYXhpczogVmVjdG9yMywgX2FuZ2xlOiBudW1iZXIsIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogUXVhdGVybmlvbiB7XHJcbiAgICAgIGNvbnN0IHJvdGF0aW9uOiBRdWF0ZXJuaW9uID0gUXVhdGVybmlvbi5ST1RBVElPTihfYXhpcywgX2FuZ2xlKTtcclxuICAgICAgdGhpcy5tdWx0aXBseShyb3RhdGlvbiwgX2Zyb21MZWZ0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUocm90YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGx5IHRoaXMgcXVhdGVybmlvbiB3aXRoIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtdWx0aXBseShfb3RoZXI6IFF1YXRlcm5pb24sIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogUXVhdGVybmlvbiB7XHJcbiAgICAgIGNvbnN0IGE6IFF1YXRlcm5pb24gPSBfZnJvbUxlZnQgPyBfb3RoZXIgOiB0aGlzO1xyXG4gICAgICBjb25zdCBiOiBRdWF0ZXJuaW9uID0gX2Zyb21MZWZ0ID8gdGhpcyA6IF9vdGhlcjtcclxuICAgICAgLy8gZnJvbTogaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxyXG4gICAgICBjb25zdCBheDogbnVtYmVyID0gYS54O1xyXG4gICAgICBjb25zdCBheTogbnVtYmVyID0gYS55O1xyXG4gICAgICBjb25zdCBhejogbnVtYmVyID0gYS56O1xyXG4gICAgICBjb25zdCBhdzogbnVtYmVyID0gYS53O1xyXG4gICAgICBjb25zdCBieDogbnVtYmVyID0gYi54O1xyXG4gICAgICBjb25zdCBieTogbnVtYmVyID0gYi55O1xyXG4gICAgICBjb25zdCBiejogbnVtYmVyID0gYi56O1xyXG4gICAgICBjb25zdCBidzogbnVtYmVyID0gYi53O1xyXG5cclxuICAgICAgdGhpcy5zZXQoXHJcbiAgICAgICAgYXggKiBidyArIGF5ICogYnogLSBheiAqIGJ5ICsgYXcgKiBieCxcclxuICAgICAgICAtYXggKiBieiArIGF5ICogYncgKyBheiAqIGJ4ICsgYXcgKiBieSxcclxuICAgICAgICBheCAqIGJ5IC0gYXkgKiBieCArIGF6ICogYncgKyBhdyAqIGJ6LFxyXG4gICAgICAgIC1heCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYnogKyBhdyAqIGJ3XHJcbiAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyBxdWF0ZXJuaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF94OiBudW1iZXIsIF95OiBudW1iZXIsIF96OiBudW1iZXIsIF93OiBudW1iZXIpOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgdGhpcy54ID0gX3g7IHRoaXMueSA9IF95OyB0aGlzLnogPSBfejsgdGhpcy53ID0gX3c7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyB0aGUgc3RhdGUgb2YgdGhlIGdpdmVuIHF1YXRlcm5pb24gaW50byB0aGlzIHF1YXRlcm5pb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb3B5KF9vcmlnaW5hbDogUXVhdGVybmlvbik6IFF1YXRlcm5pb24ge1xyXG4gICAgICB0aGlzLnggPSBfb3JpZ2luYWwueDsgdGhpcy55ID0gX29yaWdpbmFsLnk7IHRoaXMueiA9IF9vcmlnaW5hbC56OyB0aGlzLncgPSBfb3JpZ2luYWwudztcclxuICAgICAgdGhpcy4jZXVsZXJBbmdsZXNEaXJ0eSA9IF9vcmlnaW5hbC4jZXVsZXJBbmdsZXNEaXJ0eTtcclxuICAgICAgaWYgKCF0aGlzLiNldWxlckFuZ2xlc0RpcnR5KVxyXG4gICAgICAgIHRoaXMuI2V1bGVyQW5nbGVzLmNvcHkoX29yaWdpbmFsLiNldWxlckFuZ2xlcyk7XHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBxdWF0ZXJuaW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYMaSLlF1YXRlcm5pb24oeDogJHt0aGlzLnh9LCB5OiAke3RoaXMueX0sIHo6ICR7dGhpcy56fSwgdzogJHt0aGlzLnd9KWA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY3VycmVudGx5IHF1YXRlcm5pb25zIGFyZSBuZXZlciBzZXJpYWxpemVkLCBzbyB0aGlzIGlzIG5vdCBuZWVkZWQuIEJ1dCBtYXliZSBpdCB3aWxsIGJlIGluIHRoZSBmdXR1cmUuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnRvSlNPTiA9ICgpID0+IHsgcmV0dXJuIGBbJHt0aGlzLnh9LCAke3RoaXMueX0sICR7dGhpcy56fSwgJHt0aGlzLnd9XWA7IH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8UXVhdGVybmlvbj4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfc2VyaWFsaXphdGlvbikgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIFt0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLnddID0gSlNPTi5wYXJzZSg8c3RyaW5nPjx1bmtub3duPl9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgfSBlbHNlXHJcbiAgICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgaWYgKCF0aGlzLm11dGF0b3IpXHJcbiAgICAgICAgdGhpcy5tdXRhdG9yID0geyB4OiB0aGlzLngsIHk6IHRoaXMueSwgejogdGhpcy56LCB3OiB0aGlzLncgfTtcclxuICAgICAgcmV0dXJuIHRoaXMubXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIHRoaXMueCA9IF9tdXRhdG9yLnggPz8gdGhpcy54O1xyXG4gICAgICB0aGlzLnkgPSBfbXV0YXRvci55ID8/IHRoaXMueTtcclxuICAgICAgdGhpcy56ID0gX211dGF0b3IueiA/PyB0aGlzLno7XHJcbiAgICAgIHRoaXMudyA9IF9tdXRhdG9yLncgPz8gdGhpcy53O1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcblxyXG4gICAgcHJpdmF0ZSByZXNldENhY2hlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNldWxlckFuZ2xlc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBDbGFzcyBmb3IgY3JlYXRpbmcgcmFuZG9tIHZhbHVlcywgc3VwcG9ydGluZyBKYXZhc2NyaXB0J3MgTWF0aC5yYW5kb20gYW5kIGEgZGV0ZXJtaW5pc3RpZyBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgKFBSTkcpIFxyXG4gICAqIHRoYXQgY2FuIGJlIGZlZCB3aXRoIGEgc2VlZCBhbmQgdGhlbiByZXR1cm5zIGEgcmVwcm9kdWNhYmxlIHNldCBvZiByYW5kb20gbnVtYmVycyAoaWYgdGhlIHByZWNpc2lvbiBvZiBKYXZhc2NyaXB0IGFsbG93cykgXHJcbiAgICogXHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSYW5kb20ge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWZhdWx0OiBSYW5kb20gPSBuZXcgUmFuZG9tKCk7XHJcbiAgICBwcml2YXRlIGdlbmVyYXRlOiBGdW5jdGlvbiA9IE1hdGgucmFuZG9tO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHtAbGluayBSYW5kb219LiBcclxuICAgICAqIElmIGEgc2VlZCBpcyBnaXZlbiwgTEZJQjQgaXMgdXNlZCBhcyBnZW5lcmF0b3IsIHJlcHJvZHVjaW5nIGEgc2VyaWVzIG9mIG51bWJlcnMgZnJvbSB0aGF0IHNlZWQuXHJcbiAgICAgKiBJZiBhIGZ1bmN0aW9uIHByb2R1Y2luZyB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxIGlzIGdpdmVuLCBpdCB3aWxsIGJlIHVzZWQgYXMgZ2VuZXJhdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3NlZWRPckZ1bmN0aW9uPzogbnVtYmVyIHwgRnVuY3Rpb24pIHtcclxuICAgICAgaWYgKF9zZWVkT3JGdW5jdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxyXG4gICAgICAgIHRoaXMuZ2VuZXJhdGUgPSBfc2VlZE9yRnVuY3Rpb247XHJcbiAgICAgIGVsc2UgaWYgKF9zZWVkT3JGdW5jdGlvbiA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy5nZW5lcmF0ZSA9IE1hdGgucmFuZG9tO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgdGhpcy5nZW5lcmF0ZSA9IG5ldyBMRklCNChfc2VlZE9yRnVuY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5vcm1lZCByYW5kb20gbnVtYmVyLCB0aHVzIGluIHRoZSByYW5nZSBvZiBbMCwgMVtcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE5vcm0oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb20gbnVtYmVyIGluIHRoZSByYW5nZSBvZiBnaXZlbiBbX21pbiwgX21heFtcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFJhbmdlKF9taW46IG51bWJlciwgX21heDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIF9taW4gKyB0aGlzLmdlbmVyYXRlKCkgKiAoX21heCAtIF9taW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIG51bWJlciBpbiB0aGUgcmFuZ2Ugb2YgZ2l2ZW4gZmxvb3JlZCBbX21pbiwgX21heFtcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFJhbmdlRmxvb3JlZChfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuZ2V0UmFuZ2UoX21pbiwgX21heCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIHJhbmRvbWx5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRCb29sZWFuKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZSgpIDwgMC41O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyAtMSBvciAxIHJhbmRvbWx5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTaWduKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldEJvb2xlYW4oKSA/IDEgOiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBpbmRleCBpbnRvIHRoZSBnaXZlbiBhcnJheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0SW5kZXg8VD4oX2FycmF5OiBBcnJheTxUPik6IG51bWJlciB7XHJcbiAgICAgIGlmIChfYXJyYXkubGVuZ3RoID4gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRSYW5nZUZsb29yZWQoMCwgX2FycmF5Lmxlbmd0aCk7XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBlbGVtZW50IG9mIHRoZSBnaXZlbiBhcnJheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RWxlbWVudDxUPihfYXJyYXk6IEFycmF5PFQ+KTogVCB7XHJcbiAgICAgIGlmIChfYXJyYXkubGVuZ3RoID4gMClcclxuICAgICAgICByZXR1cm4gX2FycmF5W3RoaXMuZ2V0SW5kZXgoX2FycmF5KV07XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIHJhbmRvbWx5IHNlbGVjdGVkIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgYW5kIHJldHVybnMgaXRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNwbGljZTxUPihfYXJyYXk6IEFycmF5PFQ+KTogVCB7XHJcbiAgICAgIHJldHVybiBfYXJyYXkuc3BsaWNlKHRoaXMuZ2V0SW5kZXgoX2FycmF5KSwgMSlbMF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tbHkgc2VsZWN0ZWQga2V5IGZyb20gdGhlIGdpdmVuIE1hcC1pbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0S2V5PFQsIFU+KF9tYXA6IE1hcDxULCBVPik6IFQge1xyXG4gICAgICBsZXQga2V5czogR2VuZXJhbCA9IEFycmF5LmZyb20oX21hcC5rZXlzKCkpO1xyXG4gICAgICByZXR1cm4ga2V5c1t0aGlzLmdldEluZGV4KGtleXMpXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBwcm9wZXJ0eSBuYW1lIGZyb20gdGhlIGdpdmVuIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UHJvcGVydHlOYW1lPFQ+KF9vYmplY3Q6IFQpOiBrZXlvZiBUIHtcclxuICAgICAgbGV0IGtleXM6IHN0cmluZ1tdID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoX29iamVjdCk7XHJcbiAgICAgIHJldHVybiA8a2V5b2YgVD5rZXlzW3RoaXMuZ2V0SW5kZXgoa2V5cyldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbWx5IHNlbGVjdGVkIHN5bWJvbCBmcm9tIHRoZSBnaXZlbiBvYmplY3QsIGlmIHN5bWJvbHMgYXJlIHVzZWQgYXMga2V5c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UHJvcGVydHlTeW1ib2w8VD4oX29iamVjdDogVCk6IHN5bWJvbCB7XHJcbiAgICAgIGxldCBrZXlzOiBzeW1ib2xbXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoX29iamVjdCk7XHJcbiAgICAgIHJldHVybiBrZXlzW3RoaXMuZ2V0SW5kZXgoa2V5cyldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSB0aHJlZS1kaW1lbnNpb25hbCB2ZWN0b3IgaW4gdGhlIGxpbWl0cyBvZiB0aGUgYm94IGRlZmluZWQgYnkgdGhlIHZlY3RvcnMgZ2l2ZW4gYXMgW19jb3JuZXIwLCBfY29ybmVyMVtcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFZlY3RvcjMoX2Nvcm5lcjA6IFZlY3RvcjMsIF9jb3JuZXIxOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLmdldFJhbmdlKF9jb3JuZXIwLngsIF9jb3JuZXIxLngpLCB0aGlzLmdldFJhbmdlKF9jb3JuZXIwLnksIF9jb3JuZXIxLnkpLCB0aGlzLmdldFJhbmdlKF9jb3JuZXIwLnosIF9jb3JuZXIxLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb20gdHdvLWRpbWVuc2lvbmFsIHZlY3RvciBpbiB0aGUgbGltaXRzIG9mIHRoZSByZWN0YW5nbGUgZGVmaW5lZCBieSB0aGUgdmVjdG9ycyBnaXZlbiBhcyBbX2Nvcm5lcjAsIF9jb3JuZXIxW1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VmVjdG9yMihfY29ybmVyMDogVmVjdG9yMiwgX2Nvcm5lcjE6IFZlY3RvcjIpOiBWZWN0b3IyIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMuZ2V0UmFuZ2UoX2Nvcm5lcjAueCwgX2Nvcm5lcjEueCksIHRoaXMuZ2V0UmFuZ2UoX2Nvcm5lcjAueSwgX2Nvcm5lcjEueSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvbG9yIHdpdGggaXRzIHIsIGcsIGIgdmFsdWVzIHNldCB0byByYW5kb20gbnVtYmVycyBpbiB0aGUgcmFuZ2Ugb2YgWzAsIDFbLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29sb3IoKTogQ29sb3Ige1xyXG4gICAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMuZ2V0Tm9ybSgpLCB0aGlzLmdldE5vcm0oKSwgdGhpcy5nZXROb3JtKCksIDEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhbmRhcmQge0BsaW5rIFJhbmRvbX0taW5zdGFuY2UgdXNpbmcgTWF0aC5yYW5kb20oKS5cclxuICAgKi9cclxuICBleHBvcnQgY29uc3QgcmFuZG9tOiBSYW5kb20gPSBuZXcgUmFuZG9tKCk7XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBTdG9yZXMgYW5kIG1hbmlwdWxhdGVzIGEgdGhyZWVkaW1lbnNpb25hbCB2ZWN0b3IgY29tcHJpc2VkIG9mIHRoZSBjb21wb25lbnRzIHgsIHkgYW5kIHpcclxuICAgKiBgYGB0ZXh0XHJcbiAgICogICAgICAgICAgICAreVxyXG4gICAqICAgICAgICAgICAgIHxfXyAreFxyXG4gICAqICAgICAgICAgICAgL1xyXG4gICAqICAgICAgICAgICt6ICAgXHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOS0yMDIyIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFZlY3RvcjMgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlLCBSZWN5Y2FibGUge1xyXG4gICAgcHVibGljIHg6IG51bWJlcjtcclxuICAgIHB1YmxpYyB5OiBudW1iZXI7XHJcbiAgICBwdWJsaWMgejogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF96OiBudW1iZXIgPSAwKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2V0KF94LCBfeSwgX3opO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBTdGF0aWNcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBsZW5ndGggcG9pbnRpbmcgaW4geC1kaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBYKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldChfc2NhbGUsIDAsIDApO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBsZW5ndGggcG9pbnRpbmcgaW4geS1kaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBZKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldCgwLCBfc2NhbGUsIDApO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBsZW5ndGggcG9pbnRpbmcgaW4gei1kaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBaKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldCgwLCAwLCBfc2NhbGUpO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSB2YWx1ZSAwIG9uIGVhY2ggYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFpFUk8oKTogVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KDAsIDAsIDApOyAvLyBzaG91bGQgYmUgc2V0IHRvIDAgYnkgcmVjeWNsZXIgYWxyZWFkeT9cclxuICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3Igb2YgdGhlIGdpdmVuIHNpemUgb24gZWFjaCBvZiB0aGUgdGhyZWUgYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE9ORShfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IzIHtcclxuICAgICAgY29uc3QgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoX3NjYWxlLCBfc2NhbGUsIF9zY2FsZSk7XHJcbiAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIHRocm91Z2ggdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHZlY3RvciBieSB0aGUgZ2l2ZW4gbWF0cml4IG9yIHJvdGF0aW9uIHF1YXRlcm5pb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVFJBTlNGT1JNQVRJT04oX3ZlY3RvcjogVmVjdG9yMywgX3RyYW5zZm9ybTogTWF0cml4NHg0IHwgUXVhdGVybmlvbiwgX2luY2x1ZGVUcmFuc2xhdGlvbjogYm9vbGVhbiA9IHRydWUpOiBWZWN0b3IzIHtcclxuICAgICAgY29uc3QgcmVzdWx0OiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMyk7XHJcblxyXG4gICAgICBpZiAoX3RyYW5zZm9ybSBpbnN0YW5jZW9mIE1hdHJpeDR4NCkge1xyXG4gICAgICAgIGxldCBtOiBGbG9hdDMyQXJyYXkgPSBfdHJhbnNmb3JtLmdldCgpO1xyXG5cclxuICAgICAgICByZXN1bHQuc2V0KFxyXG4gICAgICAgICAgbVswXSAqIF92ZWN0b3IueCArIG1bNF0gKiBfdmVjdG9yLnkgKyBtWzhdICogX3ZlY3Rvci56LFxyXG4gICAgICAgICAgbVsxXSAqIF92ZWN0b3IueCArIG1bNV0gKiBfdmVjdG9yLnkgKyBtWzldICogX3ZlY3Rvci56LFxyXG4gICAgICAgICAgbVsyXSAqIF92ZWN0b3IueCArIG1bNl0gKiBfdmVjdG9yLnkgKyBtWzEwXSAqIF92ZWN0b3IuelxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmIChfaW5jbHVkZVRyYW5zbGF0aW9uKVxyXG4gICAgICAgICAgcmVzdWx0LmFkZChfdHJhbnNmb3JtLnRyYW5zbGF0aW9uKTtcclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRnJvbTogaHR0cHM6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvdHJhbnNmb3Jtcy9pbmRleC5odG1cclxuICAgICAgICAvLyByZXN1bHQgPSBxICogcXVhdGVybmlvbih2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56LCAwKSAqIGNvbmoocSlcclxuXHJcbiAgICAgICAgLy8gcSAqIHF1YXRlcm5pb24odmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiwgMCkgLi4uXHJcbiAgICAgICAgY29uc3QgcXg6IG51bWJlciA9IF90cmFuc2Zvcm0udyAqIF92ZWN0b3IueCArIF90cmFuc2Zvcm0ueSAqIF92ZWN0b3IueiAtIF90cmFuc2Zvcm0ueiAqIF92ZWN0b3IueTtcclxuICAgICAgICBjb25zdCBxeTogbnVtYmVyID0gX3RyYW5zZm9ybS53ICogX3ZlY3Rvci55ICsgX3RyYW5zZm9ybS56ICogX3ZlY3Rvci54IC0gX3RyYW5zZm9ybS54ICogX3ZlY3Rvci56O1xyXG4gICAgICAgIGNvbnN0IHF6OiBudW1iZXIgPSBfdHJhbnNmb3JtLncgKiBfdmVjdG9yLnogKyBfdHJhbnNmb3JtLnggKiBfdmVjdG9yLnkgLSBfdHJhbnNmb3JtLnkgKiBfdmVjdG9yLng7XHJcbiAgICAgICAgY29uc3QgcXc6IG51bWJlciA9IC1fdHJhbnNmb3JtLnggKiBfdmVjdG9yLnggLSBfdHJhbnNmb3JtLnkgKiBfdmVjdG9yLnkgLSBfdHJhbnNmb3JtLnogKiBfdmVjdG9yLno7XHJcblxyXG4gICAgICAgIC8vIC4uLiAqIGNvbmoocSlcclxuICAgICAgICByZXN1bHQuc2V0KFxyXG4gICAgICAgICAgcXggKiBfdHJhbnNmb3JtLncgKyBxdyAqIC0gX3RyYW5zZm9ybS54ICsgcXkgKiAtIF90cmFuc2Zvcm0ueiAtIHF6ICogLSBfdHJhbnNmb3JtLnksXHJcbiAgICAgICAgICBxeSAqIF90cmFuc2Zvcm0udyArIHF3ICogLSBfdHJhbnNmb3JtLnkgKyBxeiAqIC0gX3RyYW5zZm9ybS54IC0gcXggKiAtIF90cmFuc2Zvcm0ueixcclxuICAgICAgICAgIHF6ICogX3RyYW5zZm9ybS53ICsgcXcgKiAtIF90cmFuc2Zvcm0ueiArIHF4ICogLSBfdHJhbnNmb3JtLnkgLSBxeSAqIC0gX3RyYW5zZm9ybS54XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3Igd2hpY2ggaXMgYSBjb3B5IG9mIHRoZSBnaXZlbiB2ZWN0b3Igc2NhbGVkIHRvIHRoZSBnaXZlbiBsZW5ndGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBOT1JNQUxJWkFUSU9OKF92ZWN0b3I6IFZlY3RvcjMsIF9sZW5ndGg6IG51bWJlciA9IDEpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IG1hZ25pdHVkZVNxdWFyZWQ6IG51bWJlciA9IF92ZWN0b3IubWFnbml0dWRlU3F1YXJlZDtcclxuICAgICAgaWYgKG1hZ25pdHVkZVNxdWFyZWQgPT0gMClcclxuICAgICAgICB0aHJvdyAobmV3IFJhbmdlRXJyb3IoXCJJbXBvc3NpYmxlIG5vcm1hbGl6YXRpb25cIikpO1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gX3ZlY3Rvci5jbG9uZTtcclxuICAgICAgdmVjdG9yLnNjYWxlKF9sZW5ndGggLyBNYXRoLnNxcnQobWFnbml0dWRlU3F1YXJlZCkpO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0aW5nIHZlY3RvciBhdHRhaW5lZCBieSBhZGRpdGlvbiBvZiBhbGwgZ2l2ZW4gdmVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTVU0oLi4uX3ZlY3RvcnM6IFZlY3RvcjNbXSk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICBmb3IgKGxldCB2ZWN0b3Igb2YgX3ZlY3RvcnMpXHJcbiAgICAgICAgcmVzdWx0LnNldChyZXN1bHQueCArIHZlY3Rvci54LCByZXN1bHQueSArIHZlY3Rvci55LCByZXN1bHQueiArIHZlY3Rvci56KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24gb2YgdHdvIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRElGRkVSRU5DRShfbWludWVuZDogVmVjdG9yMywgX3N1YnRyYWhlbmQ6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KF9taW51ZW5kLnggLSBfc3VidHJhaGVuZC54LCBfbWludWVuZC55IC0gX3N1YnRyYWhlbmQueSwgX21pbnVlbmQueiAtIF9zdWJ0cmFoZW5kLnopO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2ZWN0b3Igc2NhbGVkIGJ5IHRoZSBnaXZlbiBzY2FsaW5nIGZhY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNDQUxFKF92ZWN0b3I6IFZlY3RvcjMsIF9zY2FsaW5nOiBudW1iZXIpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHNjYWxlZDogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpO1xyXG4gICAgICBzY2FsZWQuc2V0KF92ZWN0b3IueCAqIF9zY2FsaW5nLCBfdmVjdG9yLnkgKiBfc2NhbGluZywgX3ZlY3Rvci56ICogX3NjYWxpbmcpO1xyXG4gICAgICByZXR1cm4gc2NhbGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIGNyb3NzcHJvZHVjdCBvZiAyIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQ1JPU1MoX2E6IFZlY3RvcjMsIF9iOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldChcclxuICAgICAgICBfYS55ICogX2IueiAtIF9hLnogKiBfYi55LFxyXG4gICAgICAgIF9hLnogKiBfYi54IC0gX2EueCAqIF9iLnosXHJcbiAgICAgICAgX2EueCAqIF9iLnkgLSBfYS55ICogX2IueFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyB0aGUgZG90cHJvZHVjdCBvZiAyIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRE9UKF9hOiBWZWN0b3IzLCBfYjogVmVjdG9yMyk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBfYS54ICogX2IueCArIF9hLnkgKiBfYi55ICsgX2EueiAqIF9iLno7O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgaW5jb21pbmcgdmVjdG9yIGF0IHRoZSBnaXZlbiBub3JtYWwgdmVjdG9yLiBUaGUgbGVuZ3RoIG9mIG5vcm1hbCBzaG91bGQgYmUgMS5cclxuICAgICAqICAgICBfX19fX19fX19fX19fX19fX19cclxuICAgICAqICAgICAgICAgICAvfFxcXHJcbiAgICAgKiBpbmNvbWluZyAvIHwgXFwgcmVmbGVjdGlvblxyXG4gICAgICogICAgICAgICAvICB8ICBcXCAgIFxyXG4gICAgICogICAgICAgICAgbm9ybWFsXHJcbiAgICAgKiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBSRUZMRUNUSU9OKF9pbmNvbWluZzogVmVjdG9yMywgX25vcm1hbDogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgZG90OiBudW1iZXIgPSAtVmVjdG9yMy5ET1QoX2luY29taW5nLCBfbm9ybWFsKTtcclxuICAgICAgbGV0IHJlZmxlY3Rpb246IFZlY3RvcjMgPSBWZWN0b3IzLlNVTShfaW5jb21pbmcsIFZlY3RvcjMuU0NBTEUoX25vcm1hbCwgMiAqIGRvdCkpO1xyXG4gICAgICByZXR1cm4gcmVmbGVjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpdmlkZXMgdGhlIGRpdmlkZW5kIGJ5IHRoZSBkaXZpc29yIGNvbXBvbmVudCBieSBjb21wb25lbnQgYW5kIHJldHVybnMgdGhlIHJlc3VsdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJBVElPKF9kaXZpZGVuZDogVmVjdG9yMywgX2Rpdmlzb3I6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KF9kaXZpZGVuZC54IC8gX2Rpdmlzb3IueCwgX2RpdmlkZW5kLnkgLyBfZGl2aXNvci55LCBfZGl2aWRlbmQueiAvIF9kaXZpc29yLnopO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNhcnRlc2lhbiB2ZWN0b3IgZnJvbSBnZW9ncmFwaGljIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgR0VPKF9sb25naXR1ZGU6IG51bWJlciA9IDAsIF9sYXRpdHVkZTogbnVtYmVyID0gMCwgX21hZ25pdHVkZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMyk7XHJcbiAgICAgIGxldCBnZW86IEdlbzMgPSBSZWN5Y2xlci5yZXVzZShHZW8zKTtcclxuICAgICAgZ2VvLnNldChfbG9uZ2l0dWRlLCBfbGF0aXR1ZGUsIF9tYWduaXR1ZGUpO1xyXG4gICAgICB2ZWN0b3IuZ2VvID0gZ2VvO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShnZW8pO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBhbmdsZSBpbiBkZWdyZWVzIGJldHdlZW4gdGhlIHR3byBnaXZlbiB2ZWN0b3JzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQU5HTEUoX2Zyb206IFZlY3RvcjMsIF90bzogVmVjdG9yMyk6IG51bWJlciB7XHJcbiAgICAgIGxldCBhbmdsZTogbnVtYmVyID0gTWF0aC5hY29zKENhbGMuY2xhbXAoVmVjdG9yMy5ET1QoX2Zyb20sIF90bykgLyAoX2Zyb20ubWFnbml0dWRlICogX3RvLm1hZ25pdHVkZSksIC0xLCAxKSk7IC8vIGNsYW1wIGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIHdoZW4gZnJvbSA9PSB0b1xyXG4gICAgICByZXR1cm4gYW5nbGUgKiBDYWxjLnJhZDJkZWc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHByb2plY3Rpb24gb2YgYSBvbnRvIGJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBQUk9KRUNUSU9OKF9hOiBWZWN0b3IzLCBfYjogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gX2EuY2xvbmUucHJvamVjdChfYik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBvZiB0d28gdmVjdG9ycy4gQ2xhbXBzIHRoZSBmYWN0b3IgYmV0d2VlbiAwIGFuZCAxLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIExFUlAoX2E6IFZlY3RvcjMsIF9iOiBWZWN0b3IzLCBfZmFjdG9yOiBudW1iZXIpOiBWZWN0b3IzIHtcclxuICAgICAgX2ZhY3RvciA9IENhbGMuY2xhbXAoX2ZhY3RvciwgMCwgMSk7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldChcclxuICAgICAgICBfYS54ICsgKF9iLnggLSBfYS54KSAqIF9mYWN0b3IsXHJcbiAgICAgICAgX2EueSArIChfYi55IC0gX2EueSkgKiBfZmFjdG9yLFxyXG4gICAgICAgIF9hLnogKyAoX2IueiAtIF9hLnopICogX2ZhY3RvclxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU21vb3RobHkgaW50ZXJwb2xhdGVzIGJldHdlZW4gdHdvIHZlY3RvcnMgYmFzZWQgb24gYSBjcml0aWNhbGx5IGRhbXBlZCBzcHJpbmcgbW9kZWwuIFxyXG4gICAgICogQWxsb3dzIHRvIHNtb290aCB0b3dhcmQgYSBtb3ZpbmcgdGFyZ2V0IHdpdGggYW4gZWFzZS1pbi9lYXNlLW91dCBtb3Rpb24gbWFpbnRhaW5pbmcgYSBjb250aW51b3VzIHZlbG9jaXR5LlxyXG4gICAgICogRG9lcyBub3Qgb3ZlcnNob290LlxyXG4gICAgICogQHBhcmFtIF9jdXJyZW50IC0gVGhlIGN1cnJlbnQgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gX3RhcmdldCAtIFRoZSB0YXJnZXQgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gX3ZlbG9jaXR5IC0gVGhlIHZlbG9jaXR5IGF0IHdoaWNoIHRoZSB2YWx1ZSBpcyBtb3ZpbmcuIFRoaXMgdmFsdWUgaXMgKiptb2RpZmllZCoqIGJ5IHRoZSBmdW5jdGlvbiBhbmQgbXVzdCBiZSBtYWludGFpbmVkIGluIHRoZSBvdXRzaWRlIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gX3Ntb290aFRpbWUgLSBUaGUgdGltZSBpdCB3b3VsZCB0YWtlIGZvciB0aGUgdmFsdWUgdG8gcmVhY2ggdGhlIHRhcmdldCBpZiBpdCB3ZXJlIG1vdmluZyBhdCBtYXhpbXVtIHZlbG9jaXR5IGZvciB0aGUgZW50aXJlIGR1cmF0aW9uLiBXaGVuIGZvbGxvd2luZyBhIG1vdmluZyB0YXJnZXQgdGhlIHNtb290aCB0aW1lIGVxdWFscyB0aGUgbGFnIHRpbWUgYWxsb3dpbmcgdG8gY2FsY3VsYXRlIHRoZSBgbGFnIGRpc3RhbmNlID0gdGFyZ2V0IHZlbG9jaXR5ICogc21vb3RoIHRpbWVgLlxyXG4gICAgICogQHBhcmFtIF90aW1lRnJhbWUgLSBUaGUgZWxhcHNlZCB0aW1lIHNpbmNlIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIF9tYXhTcGVlZCAtIEFuIG9wdGlvbmFsIG1heGltdW0gc3BlZWQgdGhhdCBsaW1pdHMgdGhlIHZlbG9jaXR5IG9mIHRoZSB2YWx1ZS4gRGVmYXVsdHMgdG8gSW5maW5pdHkuXHJcbiAgICAgKiBAc291cmNlIGZyb20gQW5kcmV3IEtpcm1zZSwgR2FtZSBQcm9ncmFtbWluZyBHZW1zIDQsIENoYXB0ZXIgMS4xMFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNNT09USERBTVAoX2N1cnJlbnQ6IFZlY3RvcjMsIF90YXJnZXQ6IFZlY3RvcjMsIF92ZWxvY2l0eTogVmVjdG9yMywgX3Ntb290aFRpbWU6IG51bWJlciwgX3RpbWVGcmFtZTogbnVtYmVyLCBfbWF4U3BlZWQ6IG51bWJlciA9IEluZmluaXR5KTogVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IG9tZWdhOiBudW1iZXIgPSAyIC8gX3Ntb290aFRpbWU7XHJcbiAgICAgIGNvbnN0IHg6IG51bWJlciA9IG9tZWdhICogX3RpbWVGcmFtZTtcclxuICAgICAgY29uc3QgZXhwOiBudW1iZXIgPSAxIC8gKDEgKyB4ICsgMC40OCAqIHggKiB4ICsgMC4yMzUgKiB4ICogeCAqIHgpOyAvLyBhcHByb3hpbWF0aW9uIG9mIGUgXiAtb21lZ2EgKiB0aW1lRnJhbWVcclxuICAgICAgY29uc3QgY2hhbmdlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF9jdXJyZW50LCBfdGFyZ2V0KTsgLy8gYyA9IGZyb20gLSB0byAgfCB0byA9IGZyb20gLSBjXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBtYXhDaGFuZ2U6IG51bWJlciA9IF9tYXhTcGVlZCAqIF9zbW9vdGhUaW1lO1xyXG4gICAgICBjb25zdCBtYWduaXR1ZGVTcXVhcmVkOiBudW1iZXIgPSBjaGFuZ2UubWFnbml0dWRlU3F1YXJlZDtcclxuICAgICAgaWYgKG1hZ25pdHVkZVNxdWFyZWQgPiBtYXhDaGFuZ2UgKiBtYXhDaGFuZ2UpIHtcclxuICAgICAgICBjaGFuZ2Uuc2NhbGUobWF4Q2hhbmdlIC8gTWF0aC5zcXJ0KG1hZ25pdHVkZVNxdWFyZWQpKTtcclxuICAgICAgICBfdGFyZ2V0ID0gVmVjdG9yMy5ESUZGRVJFTkNFKF9jdXJyZW50LCBjaGFuZ2UpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBUT0RPOiBtYXliZSBvcHRpbWl6ZSB0aGlzLi4uXHJcbiAgICAgIGNvbnN0IHNjYWxlQ2hhbmdlOiBWZWN0b3IzID0gVmVjdG9yMy5TQ0FMRShjaGFuZ2UsIG9tZWdhKTtcclxuICAgICAgY29uc3Qgc3VtVmVsb2NpdHlTY2FsZUNoYW5nZTogVmVjdG9yMyA9IFZlY3RvcjMuU1VNKF92ZWxvY2l0eSwgc2NhbGVDaGFuZ2UpO1xyXG4gICAgICBjb25zdCB0ZW1wOiBWZWN0b3IzID0gVmVjdG9yMy5TQ0FMRShzdW1WZWxvY2l0eVNjYWxlQ2hhbmdlLCBfdGltZUZyYW1lKTtcclxuXHJcbiAgICAgIGNvbnN0IHNjYWxlVGVtcDogVmVjdG9yMyA9IFZlY3RvcjMuU0NBTEUodGVtcCwgb21lZ2EpO1xyXG4gICAgICBjb25zdCBkaWZmZXJlbmNlVmVsb2NpdHlTY2FsZVRlbXA6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3ZlbG9jaXR5LCBzY2FsZVRlbXApO1xyXG4gICAgICBjb25zdCBzY2FsZURpZmZlcmVuY2VWZWxvY2l0eVNjYWxlVGVtcDogVmVjdG9yMyA9IFZlY3RvcjMuU0NBTEUoZGlmZmVyZW5jZVZlbG9jaXR5U2NhbGVUZW1wLCBleHApO1xyXG4gICAgICBfdmVsb2NpdHkuY29weShzY2FsZURpZmZlcmVuY2VWZWxvY2l0eVNjYWxlVGVtcCk7XHJcblxyXG4gICAgICBjb25zdCBzdW1DaGFuZ2VUZW1wOiBWZWN0b3IzID0gVmVjdG9yMy5TVU0oY2hhbmdlLCB0ZW1wKTtcclxuICAgICAgY29uc3Qgc2NhbGVTdW1DaGFuZ2VUZW1wRXhwOiBWZWN0b3IzID0gVmVjdG9yMy5TQ0FMRShzdW1DaGFuZ2VUZW1wLCBleHApO1xyXG4gICAgICBjb25zdCByZXN1bHQ6IFZlY3RvcjMgPSBWZWN0b3IzLlNVTShfdGFyZ2V0LCBzY2FsZVN1bUNoYW5nZVRlbXBFeHApO1xyXG5cclxuICAgICAgLy8gd2l0aG91dCByZWN5Y2xpbmcuLi5cclxuICAgICAgLy8gY29uc3QgdGVtcDogVmVjdG9yMyA9IFZlY3RvcjMuU0NBTEUoVmVjdG9yMy5TVU0oX3ZlbG9jaXR5LCBWZWN0b3IzLlNDQUxFKGNoYW5nZSwgb21lZ2EpKSwgX3RpbWVGcmFtZSk7XHJcbiAgICAgIC8vIF92ZWxvY2l0eS5jb3B5KFZlY3RvcjMuU0NBTEUoVmVjdG9yMy5ESUZGRVJFTkNFKF92ZWxvY2l0eSwgVmVjdG9yMy5TQ0FMRSh0ZW1wLCBvbWVnYSkpLCBleHApKTtcclxuICAgICAgLy8gY29uc3QgcmVzdWx0OiBWZWN0b3IzID0gVmVjdG9yMy5TVU0oX3RhcmdldCwgVmVjdG9yMy5TQ0FMRShWZWN0b3IzLlNVTShjaGFuZ2UsIHRlbXApLCBleHApKTtcclxuICAgICAgXHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlTXVsdGlwbGUoc2NhbGVDaGFuZ2UsIHN1bVZlbG9jaXR5U2NhbGVDaGFuZ2UsIHRlbXAsIHNjYWxlVGVtcCwgZGlmZmVyZW5jZVZlbG9jaXR5U2NhbGVUZW1wLCBzY2FsZURpZmZlcmVuY2VWZWxvY2l0eVNjYWxlVGVtcCwgc3VtQ2hhbmdlVGVtcCwgc2NhbGVTdW1DaGFuZ2VUZW1wRXhwKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBBY2Nlc3NvcnNcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtYWduaXR1ZGUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIE1hdGguaHlwb3QodGhpcy54LCB0aGlzLnksIHRoaXMueik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzcXVhcmUgb2YgdGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yIHdpdGhvdXQgY2FsY3VsYXRpbmcgYSBzcXVhcmUgcm9vdC4gRmFzdGVyIGZvciBzaW1wbGUgcHJveGltaXR5IGV2YWx1YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWFnbml0dWRlU3F1YXJlZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gVmVjdG9yMy5ET1QodGhpcywgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAtIGdldDogcmV0dXJucyBhIGdlb2dyYXBoaWMgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3IgIFxyXG4gICAgICogLSBzZXQ6IGFkanVzdCB0aGUgY2FydGVzaWFuIHZhbHVlcyBvZiB0aGlzIHZlY3RvciB0byByZXByZXNlbnQgdGhlIGdpdmVuIGFzIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBnZW8oX2dlbzogR2VvMykge1xyXG4gICAgICB0aGlzLnNldCgwLCAwLCBfZ2VvLm1hZ25pdHVkZSk7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtKE1hdHJpeDR4NC5ST1RBVElPTl9YKC1fZ2VvLmxhdGl0dWRlKSk7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtKE1hdHJpeDR4NC5ST1RBVElPTl9ZKF9nZW8ubG9uZ2l0dWRlKSk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IGdlbygpOiBHZW8zIHtcclxuICAgICAgbGV0IGdlbzogR2VvMyA9IFJlY3ljbGVyLmdldChHZW8zKTtcclxuICAgICAgZ2VvLm1hZ25pdHVkZSA9IHRoaXMubWFnbml0dWRlO1xyXG5cclxuICAgICAgaWYgKGdlby5tYWduaXR1ZGUgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIGdlbztcclxuXHJcbiAgICAgIGdlby5sb25naXR1ZGUgPSAxODAgKiBNYXRoLmF0YW4yKHRoaXMueCAvIGdlby5tYWduaXR1ZGUsIHRoaXMueiAvIGdlby5tYWduaXR1ZGUpIC8gTWF0aC5QSTtcclxuICAgICAgZ2VvLmxhdGl0dWRlID0gMTgwICogTWF0aC5hc2luKHRoaXMueSAvIGdlby5tYWduaXR1ZGUpIC8gTWF0aC5QSTtcclxuICAgICAgcmV0dXJuIGdlbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBjbG9uZSBvZiB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBjbG9uZSgpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpLmNvcHkodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyB0aGUgY29tcG9uZW50cyBvZiB0aGUgZ2l2ZW4gdmVjdG9yIGludG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb3B5KF9vcmlnaW5hbDogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gdGhpcy5zZXQoX29yaWdpbmFsLngsIF9vcmlnaW5hbC55LCBfb3JpZ2luYWwueik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0KDAsIDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb29yZGluYXRlcyBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yIGFyZSB0byBiZSBjb25zaWRlcmVkIGlkZW50aWNhbCB3aXRoaW4gdGhlIGdpdmVuIHRvbGVyYW5jZVxyXG4gICAgICogVE9ETzogZXhhbWluZSwgaWYgdG9sZXJhbmNlIGFzIGNyaXRlcml1bSBmb3IgdGhlIGRpZmZlcmVuY2UgaXMgYXBwcm9wcmlhdGUgd2l0aCB2ZXJ5IGxhcmdlIGNvb3JkaW5hdGUgdmFsdWVzIG9yIGlmIF90b2xlcmFuY2Ugc2hvdWxkIGJlIG11bHRpcGxpZWQgYnkgY29vcmRpbmF0ZSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZXF1YWxzKF9jb21wYXJlOiBWZWN0b3IzLCBfdG9sZXJhbmNlOiBudW1iZXIgPSBOdW1iZXIuRVBTSUxPTik6IGJvb2xlYW4ge1xyXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy54IC0gX2NvbXBhcmUueCkgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnkgLSBfY29tcGFyZS55KSA+IF90b2xlcmFuY2UpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMueiAtIF9jb21wYXJlLnopID4gX3RvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZGVzY3JpYmVkIGJ5IHRoaXMgaXMgd2l0aGluIGEgY3ViZSB3aXRoIHRoZSBvcHBvc2l0ZSBjb3JuZXJzIDEgYW5kIDJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzSW5zaWRlQ3ViZShfY29ybmVyMTogVmVjdG9yMywgX2Nvcm5lcjI6IFZlY3RvcjMpOiBib29sZWFuIHtcclxuICAgICAgbGV0IGRpYWdvbmFsOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF9jb3JuZXIyLCBfY29ybmVyMSk7XHJcbiAgICAgIGxldCByZWxhdGl2ZTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh0aGlzLCBfY29ybmVyMSk7XHJcbiAgICAgIGxldCByYXRpbzogVmVjdG9yMyA9IFZlY3RvcjMuUkFUSU8ocmVsYXRpdmUsIGRpYWdvbmFsKTtcclxuICAgICAgaWYgKHJhdGlvLnggPiAxIHx8IHJhdGlvLnggPCAwKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHJhdGlvLnkgPiAxIHx8IHJhdGlvLnkgPCAwKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHJhdGlvLnogPiAxIHx8IHJhdGlvLnogPCAwKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGRlc2NyaWJlZCBieSB0aGlzIGlzIHdpdGhpbiBhIHNwaGVyZSB3aXRoIHRoZSBnaXZlbiBjZW50ZXIgYW5kIHJhZGl1c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNJbnNpZGVTcGhlcmUoX2NlbnRlcjogVmVjdG9yMywgX3JhZGl1czogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBkaWZmZXJlbmNlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKHRoaXMsIF9jZW50ZXIpO1xyXG4gICAgICByZXR1cm4gZGlmZmVyZW5jZS5tYWduaXR1ZGVTcXVhcmVkIDwgKF9yYWRpdXMgKiBfcmFkaXVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHZlY3RvciB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZChfYWRkZW5kOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIHRoaXMueCArPSBfYWRkZW5kLng7XHJcbiAgICAgIHRoaXMueSArPSBfYWRkZW5kLnk7XHJcbiAgICAgIHRoaXMueiArPSBfYWRkZW5kLno7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIHRoZSBnaXZlbiB2ZWN0b3IgZnJvbSB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN1YnRyYWN0KF9zdWJ0cmFoZW5kOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIHRoaXMueCAtPSBfc3VidHJhaGVuZC54O1xyXG4gICAgICB0aGlzLnkgLT0gX3N1YnRyYWhlbmQueTtcclxuICAgICAgdGhpcy56IC09IF9zdWJ0cmFoZW5kLno7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIHRoaXMgdmVjdG9yIGJ5IHRoZSBnaXZlbiBzY2FsYXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZShfc2NhbGFyOiBudW1iZXIpOiBWZWN0b3IzIHtcclxuICAgICAgdGhpcy54ICo9IF9zY2FsYXI7XHJcbiAgICAgIHRoaXMueSAqPSBfc2NhbGFyO1xyXG4gICAgICB0aGlzLnogKj0gX3NjYWxhcjtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemVzIHRoaXMgdG8gdGhlIGdpdmVuIGxlbmd0aCwgMSBieSBkZWZhdWx0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBub3JtYWxpemUoX2xlbmd0aDogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb3B5KFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLCBfbGVuZ3RoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOZWdhdGVzIHRoaXMgdmVjdG9yIGJ5IGZsaXBwaW5nIHRoZSBzaWducyBvZiBpdHMgY29tcG9uZW50c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmVnYXRlKCk6IFZlY3RvcjMge1xyXG4gICAgICB0aGlzLnggPSAtdGhpcy54O1xyXG4gICAgICB0aGlzLnkgPSAtdGhpcy55O1xyXG4gICAgICB0aGlzLnogPSAtdGhpcy56O1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2plY3RzIHRoaXMgdmVjdG9yIG9udG8gdGhlIGdpdmVuIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcHJvamVjdChfb246IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHNjYWxhcjogbnVtYmVyID0gVmVjdG9yMy5ET1QodGhpcywgX29uKSAvIF9vbi5tYWduaXR1ZGVTcXVhcmVkO1xyXG4gICAgICB0aGlzLnggPSBfb24ueCAqIHNjYWxhcjtcclxuICAgICAgdGhpcy55ID0gX29uLnkgKiBzY2FsYXI7XHJcbiAgICAgIHRoaXMueiA9IF9vbi56ICogc2NhbGFyO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IgYW5kIHJldHVybnMgaXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfejogbnVtYmVyID0gMCk6IFZlY3RvcjMge1xyXG4gICAgICB0aGlzLnggPSBfeDtcclxuICAgICAgdGhpcy55ID0gX3k7XHJcbiAgICAgIHRoaXMueiA9IF96O1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW3RoaXMueCwgdGhpcy55LCB0aGlzLnpdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybXMgdGhpcyB2ZWN0b3IgYnkgdGhlIGdpdmVuIG1hdHJpeCBvciByb3RhdGlvbiBxdWF0ZXJuaW9uLiBcclxuICAgICAqIEluY2x1ZGluZyBvciBleGx1ZGluZyB0aGUgdHJhbnNsYXRpb24gaWYgYSBtYXRyaXggaXMgcGFzc2VkLlxyXG4gICAgICogSW5jbHVkaW5nIGlzIHRoZSBkZWZhdWx0LCBleGNsdWRpbmcgd2lsbCBvbmx5IHJvdGF0ZSBhbmQgc2NhbGUgdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oX3RyYW5zZm9ybTogTWF0cml4NHg0IHwgUXVhdGVybmlvbiwgX2luY2x1ZGVUcmFuc2xhdGlvbjogYm9vbGVhbiA9IHRydWUpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHRyYW5zZm9ybWVkOiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTih0aGlzLCBfdHJhbnNmb3JtLCBfaW5jbHVkZVRyYW5zbGF0aW9uKTtcclxuICAgICAgdGhpcy5jb3B5KHRyYW5zZm9ybWVkKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNmb3JtZWQpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyb3BzIHRoZSB6LWNvbXBvbmVudCBhbmQgcmV0dXJucyBhIFZlY3RvcjIgY29uc2lzdGluZyBvZiB0aGUgeC0gYW5kIHktY29tcG9uZW50c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9WZWN0b3IyKCk6IFZlY3RvcjIge1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmbGVjdHMgdGhpcyB2ZWN0b3IgYXQgYSBnaXZlbiBub3JtYWwuIFNlZSB7QGxpbmsgVmVjdG9yMy5SRUZMRUNUSU9OfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVmbGVjdChfbm9ybWFsOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IHJlZmxlY3RlZDogVmVjdG9yMyA9IFZlY3RvcjMuUkVGTEVDVElPTih0aGlzLCBfbm9ybWFsKTtcclxuICAgICAgdGhpcy5zZXQocmVmbGVjdGVkLngsIHJlZmxlY3RlZC55LCByZWZsZWN0ZWQueik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJlZmxlY3RlZCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2h1ZmZsZXMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNodWZmbGUoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBhOiBudW1iZXJbXSA9IFt0aGlzLngsIHRoaXMueSwgdGhpcy56XTtcclxuICAgICAgdGhpcy5zZXQoUmFuZG9tLmRlZmF1bHQuc3BsaWNlKGEpLCBSYW5kb20uZGVmYXVsdC5zcGxpY2UoYSksIGFbMF0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGJld3R3ZWVuIHRoaXMgdmVjdG9yIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXREaXN0YW5jZShfdG86IFZlY3RvcjMpOiBudW1iZXIge1xyXG4gICAgICBsZXQgZGlmZmVyZW5jZTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh0aGlzLCBfdG8pO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShkaWZmZXJlbmNlKTtcclxuICAgICAgcmV0dXJuIGRpZmZlcmVuY2UubWFnbml0dWRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yIGVhY2ggZGltZW5zaW9uLCBtb3ZlcyB0aGUgY29tcG9uZW50IHRvIHRoZSBtaW5pbXVtIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIG1pbihfY29tcGFyZTogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICB0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIF9jb21wYXJlLngpO1xyXG4gICAgICB0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIF9jb21wYXJlLnkpO1xyXG4gICAgICB0aGlzLnogPSBNYXRoLm1pbih0aGlzLnosIF9jb21wYXJlLnopO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvciBlYWNoIGRpbWVuc2lvbiwgbW92ZXMgdGhlIGNvbXBvbmVudCB0byB0aGUgbWF4aW11bSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtYXgoX2NvbXBhcmU6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgdGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCBfY29tcGFyZS54KTtcclxuICAgICAgdGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCBfY29tcGFyZS55KTtcclxuICAgICAgdGhpcy56ID0gTWF0aC5tYXgodGhpcy56LCBfY29tcGFyZS56KTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VzIHRoZSBzdGFuZGFyZCBhcnJheS5tYXAgZnVuY3Rpb25hbGl0eSB0byBwZXJmb3JtIHRoZSBnaXZlbiBmdW5jdGlvbiBvbiBhbGwgY29tcG9uZW50cyBvZiB0aGlzIHZlY3RvclxyXG4gICAgICogYW5kIHJldHVybiBhIG5ldyB2ZWN0b3Igd2l0aCB0aGUgcmVzdWx0c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbWFwKF9mdW5jdGlvbjogKF92YWx1ZTogbnVtYmVyLCBfaW5kZXg6IG51bWJlciwgX2FycmF5OiBBcnJheUxpa2U8bnVtYmVyPikgPT4gbnVtYmVyKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBjb3B5OiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICBjb3B5LnNldCguLi5bdGhpcy54LCB0aGlzLnksIHRoaXMuel0ubWFwKF9mdW5jdGlvbikpO1xyXG4gICAgICByZXR1cm4gY29weTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIGZ1bmN0aW9uIHRvIGFsbCBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yIChtb2RpZnlpbmcgaXQpIGFuZCByZXR1cm5zIGl0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXBwbHkoX2Z1bmN0aW9uOiAoX3ZhbHVlOiBudW1iZXIsIF9pbmRleDogbnVtYmVyLCBfY29tcG9uZW50OiBcInhcIiB8IFwieVwiIHwgXCJ6XCIpID0+IG51bWJlcik6IFZlY3RvcjMge1xyXG4gICAgICB0aGlzLnggPSBfZnVuY3Rpb24odGhpcy54LCAwLCBcInhcIik7XHJcbiAgICAgIHRoaXMueSA9IF9mdW5jdGlvbih0aGlzLnksIDEsIFwieVwiKTtcclxuICAgICAgdGhpcy56ID0gX2Z1bmN0aW9uKHRoaXMueiwgMiwgXCJ6XCIpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBmb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICBsZXQgcmVzdWx0OiBzdHJpbmcgPSBgKCR7dGhpcy54LnRvUHJlY2lzaW9uKDUpfSwgJHt0aGlzLnkudG9QcmVjaXNpb24oNSl9LCAke3RoaXMuei50b1ByZWNpc2lvbig1KX0pYDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIC8vIHNlcmlhbGl6YXRpb24udG9KU09OID0gKCkgPT4geyByZXR1cm4gYHsgXCJyXCI6ICR7dGhpcy5yfSwgXCJnXCI6ICR7dGhpcy5nfSwgXCJiXCI6ICR7dGhpcy5ifSwgXCJhXCI6ICR7dGhpcy5hfX1gOyB9O1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnRvSlNPTiA9ICgpID0+IHsgcmV0dXJuIGBbJHt0aGlzLnh9LCAke3RoaXMueX0sICR7dGhpcy56fV1gOyB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFZlY3RvcjM+IHtcclxuICAgICAgaWYgKHR5cGVvZiAoX3NlcmlhbGl6YXRpb24pID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBbdGhpcy54LCB0aGlzLnksIHRoaXMuel0gPSBKU09OLnBhcnNlKDxzdHJpbmc+PHVua25vd24+X3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB9IGVsc2VcclxuICAgICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgaWYgKF9tdXRhdG9yLnggIT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLnggPSBfbXV0YXRvci54O1xyXG4gICAgICBpZiAoX211dGF0b3IueSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMueSA9IF9tdXRhdG9yLnk7XHJcbiAgICAgIGlmIChfbXV0YXRvci56ICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy56ID0gX211dGF0b3IuejtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7IHg6IHRoaXMueCwgeTogdGhpcy55LCB6OiB0aGlzLnogfTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcbiAgICAvLyNlbmRyZWdpb24gVHJhbnNmZXJcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBTdG9yZXMgYW5kIG1hbmlwdWxhdGVzIGEgZm91cmRpbWVuc2lvbmFsIHZlY3RvciBjb21wcmlzZWQgb2YgdGhlIGNvbXBvbmVudHMgeCwgeSwgeiBhbmQgdy5cclxuICAgKiBAYXV0aG9ycyBKb25hcyBQbG90emt5LCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVmVjdG9yNCBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUsIFJlY3ljYWJsZSB7XHJcbiAgICBwdWJsaWMgeDogbnVtYmVyO1xyXG4gICAgcHVibGljIHk6IG51bWJlcjtcclxuICAgIHB1YmxpYyB6OiBudW1iZXI7XHJcbiAgICBwdWJsaWMgdzogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF96OiBudW1iZXIgPSAwLCBfdzogbnVtYmVyID0gMCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNldChfeCwgX3ksIF96LCBfdyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWFnbml0dWRlIChsZW5ndGgpIG9mIHRoZSB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWFnbml0dWRlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBNYXRoLmh5cG90KHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3F1YXJlZCBtYWduaXR1ZGUgKGxlbmd0aCkgb2YgdGhlIHZlY3Rvci4gRmFzdGVyIGZvciBzaW1wbGUgcHJveGltaXR5IGV2YWx1YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWFnbml0dWRlU3F1YXJlZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5kb3QodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY2xvbmUoKTogVmVjdG9yNCB7XHJcbiAgICAgIHJldHVybiBSZWN5Y2xlci5yZXVzZShWZWN0b3I0KS5jb3B5KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29waWVzIHRoZSBjb21wb25lbnRzIG9mIHRoZSBnaXZlbiB2ZWN0b3IgaW50byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvcHkoX29yaWdpbmFsOiBWZWN0b3I0KTogVmVjdG9yNCB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNldChfb3JpZ2luYWwueCwgX29yaWdpbmFsLnksIF9vcmlnaW5hbC56LCBfb3JpZ2luYWwudyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yIGFuZCByZXR1cm5zIGl0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF94OiBudW1iZXIsIF95OiBudW1iZXIsIF96OiBudW1iZXIsIF93OiBudW1iZXIpOiBWZWN0b3I0IHtcclxuICAgICAgdGhpcy54ID0gX3g7IHRoaXMueSA9IF95OyB0aGlzLnogPSBfejsgdGhpcy53ID0gX3c7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgY29tcG9uZW50cyBvZiB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XHJcbiAgICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53XTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHZlY3RvciB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZChfYWRkZW5kOiBWZWN0b3I0KTogVmVjdG9yNCB7XHJcbiAgICAgIHRoaXMueCArPSBfYWRkZW5kLng7IHRoaXMueSArPSBfYWRkZW5kLnk7IHRoaXMueiArPSBfYWRkZW5kLno7IHRoaXMudyArPSBfYWRkZW5kLnc7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIHRoZSBnaXZlbiB2ZWN0b3IgZnJvbSB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN1YnRyYWN0KF9zdWJ0cmFoZW5kOiBWZWN0b3I0KTogVmVjdG9yNCB7XHJcbiAgICAgIHRoaXMueCAtPSBfc3VidHJhaGVuZC54OyB0aGlzLnkgLT0gX3N1YnRyYWhlbmQueTsgdGhpcy56IC09IF9zdWJ0cmFoZW5kLno7IHRoaXMudyAtPSBfc3VidHJhaGVuZC53O1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlcyB0aGlzIHZlY3RvciBieSB0aGUgZ2l2ZW4gc2NhbGFyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGUoX3NjYWxhcjogbnVtYmVyKTogVmVjdG9yNCB7XHJcbiAgICAgIHRoaXMueCAqPSBfc2NhbGFyOyB0aGlzLnkgKj0gX3NjYWxhcjsgdGhpcy56ICo9IF9zY2FsYXI7IHRoaXMudyAqPSBfc2NhbGFyO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgdGhpcyB2ZWN0b3IgdG8gdGhlIGdpdmVuIGxlbmd0aCwgMSBieSBkZWZhdWx0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbm9ybWFsaXplKF9sZW5ndGg6IG51bWJlciA9IDEpOiBWZWN0b3I0IHtcclxuICAgICAgbGV0IG1hZ25pdHVkZVNxdWFyZWQ6IG51bWJlciA9IHRoaXMubWFnbml0dWRlU3F1YXJlZDtcclxuICAgICAgaWYgKG1hZ25pdHVkZVNxdWFyZWQgPT0gMClcclxuICAgICAgICB0aHJvdyAobmV3IFJhbmdlRXJyb3IoXCJJbXBvc3NpYmxlIG5vcm1hbGl6YXRpb25cIikpO1xyXG4gICAgICB0aGlzLnNjYWxlKF9sZW5ndGggLyBNYXRoLnNxcnQobWFnbml0dWRlU3F1YXJlZCkpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgaW5zdGFuY2UgYW5kIGFub3RoZXIgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZG90KF9vdGhlcjogVmVjdG9yNCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnggKiBfb3RoZXIueCArIHRoaXMueSAqIF9vdGhlci55ICsgdGhpcy56ICogX290aGVyLnogKyB0aGlzLncgKiBfb3RoZXIudztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgcmV0dXJuIHsgdG9KU09OOiAoKSA9PiBgWyR7dGhpcy54fSwgJHt0aGlzLnl9LCAke3RoaXMuen0sICR7dGhpcy53fV1gIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxWZWN0b3I0PiB7XHJcbiAgICAgIFt0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLnddID0gSlNPTi5wYXJzZSg8c3RyaW5nPjx1bmtub3duPl9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsgLyoqICovIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGVzY3JpYmVzIGEgZmFjZSBvZiBhIHtAbGluayBNZXNofSBieSByZWZlcmVuY2luZyB0aHJlZSB7QGxpbmsgVmVydGljZXN9IHdpdGggdGhlaXIgaW5kaXplc1xyXG4gICAqIGFuZCBjYWxjdWxhdGVzIGZhY2Ugbm9ybWFscy5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBGYWNlIHtcclxuICAgIHB1YmxpYyBpbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgcHVibGljIGFuZ2xlczogbnVtYmVyW10gPSBbXTtcclxuICAgIHB1YmxpYyBub3JtYWxVbnNjYWxlZDogVmVjdG9yMztcclxuICAgIHB1YmxpYyBub3JtYWw6IFZlY3RvcjM7XHJcbiAgICBwcml2YXRlIHZlcnRpY2VzOiBWZXJ0aWNlcztcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3ZlcnRpY2VzOiBWZXJ0aWNlcywgX2luZGV4MDogbnVtYmVyLCBfaW5kZXgxOiBudW1iZXIsIF9pbmRleDI6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmluZGljZXMgPSBbX2luZGV4MCwgX2luZGV4MSwgX2luZGV4Ml07XHJcbiAgICAgIHRoaXMudmVydGljZXMgPSBfdmVydGljZXM7XHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlTm9ybWFscygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIHZlcnRleCByZWZlcmVuY2VkIGJ5IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UG9zaXRpb24oX2luZGV4OiBudW1iZXIpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIHRoaXMudmVydGljZXMucG9zaXRpb24odGhpcy5pbmRpY2VzW19pbmRleF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogbXVzdCBiZSBjb3BsYW5hclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNJbnNpZGUoX3BvaW50OiBWZWN0b3IzKTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBkaWZmczogVmVjdG9yM1tdID0gW107XHJcbiAgICAgIGZvciAobGV0IGluZGV4IG9mIHRoaXMuaW5kaWNlcykge1xyXG4gICAgICAgIGxldCBkaWZmOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKHRoaXMudmVydGljZXMucG9zaXRpb24oaW5kZXgpLCBfcG9pbnQpO1xyXG4gICAgICAgIGRpZmZzLnB1c2goZGlmZik7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IG4wOiBWZWN0b3IzID0gVmVjdG9yMy5DUk9TUyhkaWZmc1sxXSwgZGlmZnNbMF0pO1xyXG4gICAgICBsZXQgbjE6IFZlY3RvcjMgPSBWZWN0b3IzLkNST1NTKGRpZmZzWzJdLCBkaWZmc1sxXSk7XHJcbiAgICAgIGxldCBuMjogVmVjdG9yMyA9IFZlY3RvcjMuQ1JPU1MoZGlmZnNbMF0sIGRpZmZzWzJdKTtcclxuXHJcbiAgICAgIGxldCBkb3QxOiBudW1iZXIgPSBWZWN0b3IzLkRPVChuMCwgbjEpO1xyXG4gICAgICBsZXQgZG90MjogbnVtYmVyID0gVmVjdG9yMy5ET1QobjAsIG4yKTtcclxuXHJcbiAgICAgIHJldHVybiAhKGRvdDEgPCAwIHx8IGRvdDIgPCAwKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZU5vcm1hbHMoKTogdm9pZCB7XHJcbiAgICAgIGxldCB0cmlnb246IFZlY3RvcjNbXSA9IHRoaXMuaW5kaWNlcy5tYXAoKF9pbmRleDogbnVtYmVyKSA9PiB0aGlzLnZlcnRpY2VzLnBvc2l0aW9uKF9pbmRleCkpO1xyXG4gICAgICBsZXQgdjE6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodHJpZ29uWzFdLCB0cmlnb25bMF0pO1xyXG4gICAgICBsZXQgdjI6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodHJpZ29uWzJdLCB0cmlnb25bMF0pO1xyXG4gICAgICB0aGlzLm5vcm1hbFVuc2NhbGVkID0gVmVjdG9yMy5DUk9TUyh2MSwgdjIpO1xyXG4gICAgICB0aGlzLm5vcm1hbCA9IFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLm5vcm1hbFVuc2NhbGVkKTtcclxuICAgICAgdGhpcy5hbmdsZXMucHVzaChcclxuICAgICAgICBWZWN0b3IzLkFOR0xFKHYxLCB2MiksXHJcbiAgICAgICAgVmVjdG9yMy5BTkdMRShWZWN0b3IzLkRJRkZFUkVOQ0UodHJpZ29uWzJdLCB0cmlnb25bMV0pLCBWZWN0b3IzLkRJRkZFUkVOQ0UodHJpZ29uWzBdLCB0cmlnb25bMV0pKSxcclxuICAgICAgICBWZWN0b3IzLkFOR0xFKFZlY3RvcjMuRElGRkVSRU5DRSh0cmlnb25bMF0sIHRyaWdvblsyXSksIFZlY3RvcjMuRElGRkVSRU5DRSh0cmlnb25bMV0sIHRyaWdvblsyXSkpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSBzaW1wbGUgY3ViZSB3aXRoIGVkZ2VzIG9mIGxlbmd0aCAxLCBlYWNoIGZhY2UgY29uc2lzdGluZyBvZiB0d28gdHJpZ29uc1xyXG4gICAqIGBgYHRleHRcclxuICAgKiAgICAgICAoMTIpIDRfX19fNyAgKDExKVxyXG4gICAqICAgICAgICg4KSAwL19fMy98ICgxMClcclxuICAgKiAgICAgICAoMTUpIHx8NV98fDYgKDE0KVxyXG4gICAqICAgICAgICg5KSAxfC9fMnwvICgxMylcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoQ3ViZSBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoQ3ViZSk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hDdWJlXCIpIHtcclxuICAgICAgc3VwZXIoX25hbWUpO1xyXG5cclxuICAgICAgLy8gbm8gc2hhcmVkIHZlcnRpY2VzLCBjb3JuZXJzIG5lZWQgdGhyZWUgbm9ybWFscyBmb3IgUGhvbmcgYW5kIEdvdXJhdWRcclxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcyhcclxuICAgICAgICAvLyBmcm9udCB2ZXJ0aWNlc1xyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoLTAuNSwgMC41LCAwLjUpLCBuZXcgVmVjdG9yMigwLCAwKSksIC8vIDBcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKC0wLjUsIC0wLjUsIDAuNSksIG5ldyBWZWN0b3IyKDAsIDEpKSwgLy8gMVxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoMC41LCAtMC41LCAwLjUpLCBuZXcgVmVjdG9yMigxLCAxKSksIC8vIDJcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKDAuNSwgMC41LCAwLjUpLCBuZXcgVmVjdG9yMigxLCAwKSkgLy8zXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBnZW5lcmF0ZSB2ZXJ0aWNlcyBvbiBzaWRlc1xyXG4gICAgICBmb3IgKGxldCBhbmdsZTogbnVtYmVyID0gOTA7IGFuZ2xlIDwgMzYwOyBhbmdsZSArPSA5MCkge1xyXG4gICAgICAgIGxldCB0cmFuc2Zvcm06IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTihWZWN0b3IzLlkoYW5nbGUpKTtcclxuICAgICAgICBsZXQgc2lkZTogVmVydGV4W10gPSB0aGlzLnZlcnRpY2VzLnNsaWNlKDAsIDQpLm1hcCgoX3Y6IFZlcnRleCkgPT5cclxuICAgICAgICAgIG5ldyBWZXJ0ZXgoVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfdi5wb3NpdGlvbiwgdHJhbnNmb3JtKSwgX3YudXYpKTtcclxuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goLi4uc2lkZSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gZ2VuZXJhdGUgdmVydGljZXMgZm9yIHRvcCBhbmQgYm90dG9tXHJcbiAgICAgIGZvciAobGV0IGFuZ2xlOiBudW1iZXIgPSA5MDsgYW5nbGUgPCAzNjA7IGFuZ2xlICs9IDE4MCkge1xyXG4gICAgICAgIGxldCB0cmFuc2Zvcm06IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTihWZWN0b3IzLlgoYW5nbGUpKTtcclxuICAgICAgICBsZXQgc2lkZTogVmVydGV4W10gPSB0aGlzLnZlcnRpY2VzLnNsaWNlKDAsIDQpLm1hcCgoX3Y6IFZlcnRleCkgPT5cclxuICAgICAgICAgIG5ldyBWZXJ0ZXgoVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfdi5wb3NpdGlvbiwgdHJhbnNmb3JtKSwgX3YudXYpKTtcclxuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goLi4uc2lkZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZmFjZXMgPSBbXTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IDI0OyBpICs9IDQpXHJcbiAgICAgICAgLy8gZ2VuZXJhdGUgZmFjZXNcclxuICAgICAgICB0aGlzLmZhY2VzLnB1c2goLi4ubmV3IFF1YWQodGhpcy52ZXJ0aWNlcywgaSArIDAsIGkgKyAxLCBpICsgMiwgaSArIDMpLmZhY2VzKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIGZsYXQgcG9seWdvbi4gQWxsIHRyaWdvbnMgc2hhcmUgdmVydGV4IDAsIHNvIGNhcmVmdWwgZGVzaWduIGlzIHJlcXVpcmVkIHRvIGNyZWF0ZSBjb25jYXZlIHBvbHlnb25zLiBcclxuICAgKiBWZXJ0ZXggMCBpcyBhbHNvIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmFjZSBub3JtYWwuXHJcbiAgICogYGBgdGV4dFxyXG4gICAqICAgICAgICAgICAgIDAgXHJcbiAgICogICAgICAgICAgIDHilbF84pWyICA0IC4uLlxyXG4gICAqICAgICAgICAgICAg4pWyfF/ilbLilbEgXHJcbiAgICogICAgICAgICAgICAyICAgM1xyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxLTIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaFBvbHlnb24gZXh0ZW5kcyBNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFBvbHlnb24pO1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBzaGFwZURlZmF1bHQ6IFZlY3RvcjJbXSA9IFsgLy8gdHJpZ29uIGlzIHRoZSBtaW5pbWFsIHNoYXBlXHJcbiAgICAgIG5ldyBWZWN0b3IyKC0xLCAtMSksXHJcbiAgICAgIG5ldyBWZWN0b3IyKDEsIC0xKSxcclxuICAgICAgbmV3IFZlY3RvcjIoMCwgMSlcclxuICAgIF07XHJcbiAgICBwcm90ZWN0ZWQgc2hhcGU6IE11dGFibGVBcnJheTxWZWN0b3IyPiA9IG5ldyBNdXRhYmxlQXJyYXk8VmVjdG9yMj4oVmVjdG9yMik7XHJcbiAgICBwcm90ZWN0ZWQgZml0VGV4dHVyZTogYm9vbGVhbjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFBvbHlnb25cIiwgX3NoYXBlOiBWZWN0b3IyW10gPSBNZXNoUG9seWdvbi5zaGFwZURlZmF1bHQsIF9maXRUZXh0dXJlOiBib29sZWFuID0gdHJ1ZSkge1xyXG4gICAgICBzdXBlcihfbmFtZSk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKF9zaGFwZSwgX2ZpdFRleHR1cmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBnZXQgbWluVmVydGljZXMoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIDM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgdGhpcyBtZXNoIGZyb20gdGhlIGdpdmVuIHZlcnRpY2VzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlKF9zaGFwZTogVmVjdG9yMltdID0gW10sIF9maXRUZXh0dXJlOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNoYXBlID0gPE11dGFibGVBcnJheTxWZWN0b3IyPj5NdXRhYmxlQXJyYXkuZnJvbShfc2hhcGUubWFwKF92ZXJ0ZXggPT4gX3ZlcnRleC5jbG9uZSkpO1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMuZml0VGV4dHVyZSA9IF9maXRUZXh0dXJlO1xyXG5cclxuICAgICAgaWYgKF9zaGFwZS5sZW5ndGggPCB0aGlzLm1pblZlcnRpY2VzKSB7XHJcbiAgICAgICAgRGVidWcud2FybihgQXQgbGVhc3QgJHt0aGlzLm1pblZlcnRpY2VzfSB2ZXJ0aWNlcyBuZWVkZWQgdG8gY29uc3RydWN0IE1lc2hQb2x5Z29uLCBkZWZhdWx0IHRyaWdvbiB1c2VkYCk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGUoTWVzaFBvbHlnb24uc2hhcGVEZWZhdWx0LCB0cnVlKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBzaGFwZTogVmVjdG9yMltdID0gX3NoYXBlO1xyXG5cclxuICAgICAgbGV0IG1pbjogVmVjdG9yMiA9IFZlY3RvcjIuWkVSTygpO1xyXG4gICAgICBsZXQgbWF4OiBWZWN0b3IyID0gVmVjdG9yMi5aRVJPKCk7XHJcbiAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgZm9yIChsZXQgdmVydGV4IG9mIHNoYXBlKSB7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBWZXJ0ZXgodmVydGV4LnRvVmVjdG9yMygpKSk7XHJcblxyXG4gICAgICAgIG1pbi54ID0gTWF0aC5taW4obWluLngsIHZlcnRleC54KTtcclxuICAgICAgICBtYXgueCA9IE1hdGgubWF4KG1heC54LCB2ZXJ0ZXgueCk7XHJcbiAgICAgICAgbWluLnkgPSBNYXRoLm1pbihtaW4ueSwgdmVydGV4LnkpO1xyXG4gICAgICAgIG1heC55ID0gTWF0aC5tYXgobWF4LnksIHZlcnRleC55KTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgc2l6ZTogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKG1heC54IC0gbWluLngsIG1heC55IC0gbWluLnkpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuZml0VGV4dHVyZSkge1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbGV0IHRleHR1cmVVVjogVmVjdG9yMiA9IFZlY3RvcjIuRElGRkVSRU5DRShzaGFwZVtpXSwgbWluKTtcclxuICAgICAgICAgIHRoaXMudmVydGljZXNbaV0udXYgPSBuZXcgVmVjdG9yMih0ZXh0dXJlVVYueCAvIHNpemUueCwgMSAtIHRleHR1cmVVVi55IC8gc2l6ZS55KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX3NoYXBlLmZvckVhY2goKF92ZXJ0ZXgsIF9pKSA9PiB0aGlzLnZlcnRpY2VzW19pXS51diA9IG5ldyBWZWN0b3IyKF92ZXJ0ZXgueCwgLV92ZXJ0ZXgueSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmZhY2VzID0gW107XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDI7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHRoaXMuZmFjZXMucHVzaChuZXcgRmFjZSh0aGlzLnZlcnRpY2VzLCBpIC0gMSwgaSwgMCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5zaGFwZSA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplQXJyYXkoVmVjdG9yMiwgdGhpcy5zaGFwZSk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uZml0VGV4dHVyZSA9IHRoaXMuZml0VGV4dHVyZTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIGxldCB2ZWN0b3JzOiBWZWN0b3IyW10gPSA8VmVjdG9yMltdPmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemVBcnJheShfc2VyaWFsaXphdGlvbi5zaGFwZSk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKHZlY3RvcnMsIF9zZXJpYWxpemF0aW9uLmZpdFRleHR1cmUpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgYXdhaXQgc3VwZXIubXV0YXRlKF9tdXRhdG9yLCBfc2VsZWN0aW9uLCBfZGlzcGF0Y2hNdXRhdGUpO1xyXG4gICAgICB0aGlzLmNyZWF0ZSh0aGlzLnNoYXBlLCB0aGlzLmZpdFRleHR1cmUpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk1VVEFURSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiTWVzaFBvbHlnb24udHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhbiBleHRydXNpb24gb2YgYSBwb2x5Z29uIGJ5IGEgc2VyaWVzIG9mIHRyYW5zZm9ybWF0aW9uc1xyXG4gICAqIGBgYHRleHQgIFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgIF9fX19cclxuICAgKiBQb2x5Z29uICAgICAgICAgX19fX+KVseKVsiAgIOKVsiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeVxyXG4gICAqIFRyYW5zZm9ybSAwICDihpIg4pWxIOKVsl9f4pWyX+KVsl9fX+KVsiDihpAgVHJhbnNmb3JtIDIgICAgICAgICAgeiBfX+KUglxyXG4gICAqIChiYXNlKSAgICAgICAgIOKVsl/ilbFfX+KVsSDilbEgICDilbEgICAobGlkKSAgICAgICAgICAgICAgICAgICAgIOKVsiAgICAgICBcclxuICAgKiAgICAgVHJhbnNmb3JtIDEgIOKGkiAg4pWy4pWxX19f4pWxICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMS0yMDIyXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hFeHRydXNpb24gZXh0ZW5kcyBNZXNoUG9seWdvbiB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hFeHRydXNpb24pO1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBtdHhEZWZhdWx0czogTWF0cml4NHg0W10gPSBbIC8vIG9mZnNldCBvZiArMC41eiBhbmQgLTAuNXogYXMgZGVmYXVsdFxyXG4gICAgICBNYXRyaXg0eDQuVFJBTlNMQVRJT04oVmVjdG9yMy5aKDAuNSkpLFxyXG4gICAgICBNYXRyaXg0eDQuVFJBTlNMQVRJT04oVmVjdG9yMy5aKC0wLjUpKVxyXG4gICAgXTtcclxuICAgIHByaXZhdGUgbXR4VHJhbnNmb3JtczogTXV0YWJsZUFycmF5PE1hdHJpeDR4ND4gPSBuZXcgTXV0YWJsZUFycmF5KE1hdHJpeDR4NCk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hFeHRydXNpb25cIiwgX3ZlcnRpY2VzOiBWZWN0b3IyW10gPSBNZXNoUG9seWdvbi5zaGFwZURlZmF1bHQsIF9tdHhUcmFuc2Zvcm1zOiBNYXRyaXg0eDRbXSA9IE1lc2hFeHRydXNpb24ubXR4RGVmYXVsdHMsIF9maXRUZXh0dXJlOiBib29sZWFuID0gdHJ1ZSkge1xyXG4gICAgICBzdXBlcihfbmFtZSwgX3ZlcnRpY2VzLCBfZml0VGV4dHVyZSk7XHJcbiAgICAgIHRoaXMuZXh0cnVkZShfbXR4VHJhbnNmb3Jtcyk7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiTXV0YXRvclwiLCB0aGlzLmdldE11dGF0b3IoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnRyYW5zZm9ybXMgPSBTZXJpYWxpemVyLnNlcmlhbGl6ZUFycmF5KE1hdHJpeDR4NCwgdGhpcy5tdHhUcmFuc2Zvcm1zKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBsZXQgbXR4VHJhbnNmb3JtczogTWF0cml4NHg0W107XHJcbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi50cmFuc2Zvcm1zKVxyXG4gICAgICAgIG10eFRyYW5zZm9ybXMgPSA8TWF0cml4NHg0W10+YXdhaXQgU2VyaWFsaXplci5kZXNlcmlhbGl6ZUFycmF5KF9zZXJpYWxpemF0aW9uLnRyYW5zZm9ybXMpO1xyXG4gICAgICB0aGlzLmV4dHJ1ZGUobXR4VHJhbnNmb3Jtcyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IsIF9zZWxlY3Rpb24sIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICAgIHRoaXMuZXh0cnVkZSh0aGlzLm10eFRyYW5zZm9ybXMpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk1VVEFURSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgcHJpdmF0ZSBleHRydWRlKF9tdHhUcmFuc2Zvcm1zOiBNYXRyaXg0eDRbXSA9IE1lc2hFeHRydXNpb24ubXR4RGVmYXVsdHMpOiB2b2lkIHtcclxuICAgICAgdGhpcy5tdHhUcmFuc2Zvcm1zID0gPE11dGFibGVBcnJheTxNYXRyaXg0eDQ+Pk11dGFibGVBcnJheS5mcm9tKDxNdXRhYmxlQXJyYXk8TWF0cml4NHg0Pj5fbXR4VHJhbnNmb3Jtcyk7XHJcbiAgICAgIGxldCBuVHJhbnNmb3JtczogbnVtYmVyID0gX210eFRyYW5zZm9ybXMubGVuZ3RoO1xyXG4gICAgICBsZXQgblZlcnRpY2VzU2hhcGU6IG51bWJlciA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gY3JlYXRlIG5ldyB2ZXJ0ZXggY2xvdWQsIGN1cnJlbnQgY2xvdWQgaG9sZHMgTWVzaFBvbHlnb25cclxuICAgICAgbGV0IHZlcnRpY2VzOiBWZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygpO1xyXG5cclxuICAgICAgLy8gY3JlYXRlIGJhc2UgYnkgdHJhbnNmb3JtYXRpb24gb2YgcG9seWdvbiB3aXRoIGZpcnN0IHRyYW5zZm9ybVxyXG4gICAgICBsZXQgYmFzZTogVmVydGV4W10gPSB0aGlzLnZlcnRpY2VzLm1hcCgoX3Y6IFZlcnRleCkgPT4gbmV3IFZlcnRleChWZWN0b3IzLlRSQU5TRk9STUFUSU9OKF92LnBvc2l0aW9uLCBfbXR4VHJhbnNmb3Jtc1swXSwgdHJ1ZSksIF92LnV2KSk7XHJcbiAgICAgIHZlcnRpY2VzLnB1c2goLi4uYmFzZSk7XHJcbiAgICAgIC8vIGNyZWF0ZSBsaWQgYnkgdHJhbnNmb3JtYXRpb24gb2YgcG9seWdvbiB3aXRoIGxhc3QgdHJhbnNmb3JtXHJcbiAgICAgIGxldCBsaWQ6IFZlcnRleFtdID0gdGhpcy52ZXJ0aWNlcy5tYXAoKF92OiBWZXJ0ZXgpID0+IG5ldyBWZXJ0ZXgoVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfdi5wb3NpdGlvbiwgX210eFRyYW5zZm9ybXNbblRyYW5zZm9ybXMgLSAxXSwgdHJ1ZSksIF92LnV2KSk7XHJcbiAgICAgIHZlcnRpY2VzLnB1c2goLi4ubGlkKTtcclxuXHJcbiAgICAgIC8vIHJlY3JlYXRlIGJhc2UgZmFjZXMgdG8gcmVjYWxjdWxhdGUgbm9ybWFsc1xyXG4gICAgICB0aGlzLmZhY2VzID0gdGhpcy5mYWNlcy5tYXAoKF9mYWNlOiBGYWNlKSA9PiBuZXcgRmFjZSh2ZXJ0aWNlcywgX2ZhY2UuaW5kaWNlc1swXSwgX2ZhY2UuaW5kaWNlc1sxXSwgX2ZhY2UuaW5kaWNlc1syXSkpO1xyXG4gICAgICAvLyBjcmVhdGUgdGhlIGxpZCBmYWNlcyB1c2luZyB0aGUgaW5kaWNlcyBvZiB0aGUgYmFzZSBmYWNlcywgYnV0IHdpdGggYW4gaW5kZXggb2Zmc2V0IGFuZCByZXZlcnNlIG9yZGVyIG9mIGluZGljZXNcclxuICAgICAgdGhpcy5mYWNlcy5wdXNoKC4uLnRoaXMuZmFjZXMubWFwKF9mYWNlID0+XHJcbiAgICAgICAgbmV3IEZhY2UodmVydGljZXMsIF9mYWNlLmluZGljZXNbMl0gKyBuVmVydGljZXNTaGFwZSwgX2ZhY2UuaW5kaWNlc1sxXSArIG5WZXJ0aWNlc1NoYXBlLCBfZmFjZS5pbmRpY2VzWzBdICsgblZlcnRpY2VzU2hhcGUpXHJcbiAgICAgICkpO1xyXG5cclxuICAgICAgZm9yIChsZXQgdDogbnVtYmVyID0gMDsgdCA8IG5UcmFuc2Zvcm1zOyB0KyspIHtcclxuICAgICAgICBsZXQgbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQgPSBfbXR4VHJhbnNmb3Jtc1t0XTtcclxuICAgICAgICBsZXQgcmVmZXJUb0Nsb3NlOiBudW1iZXIgPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IHdyYXA6IFZlcnRleFtdID0gdGhpcy52ZXJ0aWNlcy5tYXAoKF92OiBWZXJ0ZXgsIF9pOiBudW1iZXIpID0+XHJcbiAgICAgICAgICBuZXcgVmVydGV4KFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3YucG9zaXRpb24sIG10eFRyYW5zZm9ybSwgdHJ1ZSksIG5ldyBWZWN0b3IyKF9pIC8gblZlcnRpY2VzU2hhcGUsIHQgLyBuVHJhbnNmb3JtcykpXHJcbiAgICAgICAgKTtcclxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKC4uLndyYXApO1xyXG4gICAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlcnRleChyZWZlclRvQ2xvc2UsIG5ldyBWZWN0b3IyKDEsIHQgLyBuVHJhbnNmb3JtcykpKTtcclxuICAgICAgICAvLyBpZiAoaSA+IDAgJiYgaSA8IG5UcmFuc2Zvcm1zIC0gMSlcclxuICAgICAgICAvLyAgIHZlcnRpY2VzLnB1c2goLi4ud3JhcC5tYXAoKF92ZWN0b3I6IFZlY3RvcjMpID0+IF92ZWN0b3IuY2xvbmUpKTsgPC0gbm8gc2xpY2luZyBmb3IgZmxhdCBzaGFkaW5nIHlldC4uLlxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjcmVhdGUgaW5kaXplcyBmb3Igd3JhcHBlclxyXG4gICAgICBmb3IgKGxldCB0OiBudW1iZXIgPSAwOyB0IDwgblRyYW5zZm9ybXMgLSAxOyB0KyspXHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IG5WZXJ0aWNlc1NoYXBlOyBpKyspIHtcclxuICAgICAgICAgIGxldCBpbmRleDogbnVtYmVyID1cclxuICAgICAgICAgICAgKyAyICogblZlcnRpY2VzU2hhcGUgLy8gYmFzZSAmIGxpZCBhcmUgb2Zmc2V0cyBcclxuICAgICAgICAgICAgKyB0ICogKG5WZXJ0aWNlc1NoYXBlICsgMSkgLy8gb2Zmc2V0IGZvciBlYWNoIHRyYW5zZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICsgaTtcclxuICAgICAgICAgIGxldCBxdWFkOiBRdWFkID0gbmV3IFF1YWQodmVydGljZXMsIGluZGV4LCBpbmRleCArIG5WZXJ0aWNlc1NoYXBlICsgMSwgaW5kZXggKyBuVmVydGljZXNTaGFwZSArIDIsIGluZGV4ICsgMSwgUVVBRFNQTElULkFUXzApO1xyXG4gICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKC4uLnF1YWQuZmFjZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlcztcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBwcml2YXRlIGNhbGN1bGF0ZVBvbHlnb25MZW5ndGhzKCk6IG51bWJlcltdIHtcclxuICAgIC8vICAgbGV0IHJlc3VsdDogbnVtYmVyW10gPSBbXTtcclxuICAgIC8vICAgbGV0IGZpcnN0OiBWZWN0b3IzO1xyXG4gICAgLy8gICBsZXQgcHJldjogVmVjdG9yMztcclxuICAgIC8vICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgIC8vICAgICBsZXQgY3VycmVudDogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKHRoaXMudmVydGljZXNbaV0sIHRoaXMudmVydGljZXNbaSArIDFdLCB0aGlzLnZlcnRpY2VzW2kgKyAyXSk7XHJcbiAgICAvLyAgICAgaWYgKHByZXYpXHJcbiAgICAvLyAgICAgICByZXN1bHQucHVzaChWZWN0b3IzLkRJRkZFUkVOQ0UoY3VycmVudCwgcHJldikubWFnbml0dWRlKTtcclxuICAgIC8vICAgICBlbHNlXHJcbiAgICAvLyAgICAgICBmaXJzdCA9IGN1cnJlbnQ7XHJcbiAgICAvLyAgICAgcHJldiA9IGN1cnJlbnQ7XHJcbiAgICAvLyAgIH1cclxuICAgIC8vICAgcmVzdWx0LnB1c2goVmVjdG9yMy5ESUZGRVJFTkNFKGZpcnN0LCBwcmV2KS5tYWduaXR1ZGUpO1xyXG4gICAgLy8gICByZXR1cm4gcmVzdWx0O1xyXG4gICAgLy8gfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBBIG1lc2ggbG9hZGVkIGZyb20gYW4gRkJYLUZpbGUuXHJcbiAgICogQGF1dGhvcnMgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjMgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaEZCWCBleHRlbmRzIG1peGluU2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbChNZXNoKSB7XHJcbiAgICAvLyBwdWJsaWMgdXJsOiBSZXF1ZXN0SW5mbztcclxuICAgIHB1YmxpYyBpTWVzaDogbnVtYmVyO1xyXG4gICAgcHVibGljIGFzeW5jIGxvYWQoX3VybDogUmVxdWVzdEluZm8gPSB0aGlzLnVybCwgX2lNZXNoOiBudW1iZXIgPSB0aGlzLmlNZXNoKTogUHJvbWlzZTxNZXNoRkJYPiB7XHJcbiAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgdGhpcy51cmwgPSBfdXJsO1xyXG4gICAgICB0aGlzLmlNZXNoID0gX2lNZXNoO1xyXG4gICAgICBjb25zdCBsb2FkZXI6IEZCWExvYWRlciA9IGF3YWl0IEZCWExvYWRlci5MT0FEKHRoaXMudXJsLnRvU3RyaW5nKCkpO1xyXG4gICAgICBjb25zdCBnZW9tZXRyeUZCWDogRkJYLkdlb21ldHJ5ID0gKFxyXG4gICAgICAgIGxvYWRlci5mYngub2JqZWN0cy5nZW9tZXRyaWVzW19pTWVzaF0gfHxcclxuICAgICAgICBsb2FkZXIuZmJ4Lm9iamVjdHMuZ2VvbWV0cmllcy5maW5kKF9vYmplY3QgPT4gX29iamVjdC5uYW1lID09IHRoaXMubmFtZSkgfHxcclxuICAgICAgICBsb2FkZXIuZmJ4Lm9iamVjdHMubW9kZWxzLmZpbmQoX29iamVjdCA9PiBfb2JqZWN0Lm5hbWUgPT0gdGhpcy5uYW1lICYmIF9vYmplY3Quc3VidHlwZSA9PSBcIk1lc2hcIikuY2hpbGRyZW5bMF1cclxuICAgICAgKS5sb2FkKCk7XHJcbiAgICAgIGlmIChnZW9tZXRyeUZCWClcclxuICAgICAgICB0aGlzLm5hbWUgPSBnZW9tZXRyeUZCWC5uYW1lLmxlbmd0aCA+IDAgPyBnZW9tZXRyeUZCWC5uYW1lIDogZ2VvbWV0cnlGQlgucGFyZW50c1swXS5uYW1lO1xyXG5cclxuICAgICAgbGV0IHBvc2l0aW9uczogVmVjdG9yM1tdID0gW107XHJcbiAgICAgIGxldCB2ZXJ0ZXhCdWZmZXI6IEZsb2F0MzJBcnJheSA9IGdlb21ldHJ5RkJYLlZlcnRpY2VzO1xyXG4gICAgICBmb3IgKGxldCBpVmVydGV4OiBudW1iZXIgPSAwOyBpVmVydGV4IDwgdmVydGV4QnVmZmVyLmxlbmd0aDsgaVZlcnRleCArPSAzKSB7XHJcbiAgICAgICAgcG9zaXRpb25zLnB1c2gobmV3IFZlY3RvcjModmVydGV4QnVmZmVyW2lWZXJ0ZXggKyAwXSwgdmVydGV4QnVmZmVyW2lWZXJ0ZXggKyAxXSwgdmVydGV4QnVmZmVyW2lWZXJ0ZXggKyAyXSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgdXZzOiBWZWN0b3IyW10gPSBbXTtcclxuICAgICAgaWYgKGdlb21ldHJ5RkJYLkxheWVyRWxlbWVudFVWKSB7XHJcbiAgICAgICAgbGV0IHV2QnVmZmVyOiBGbG9hdDMyQXJyYXkgPSBnZW9tZXRyeUZCWC5MYXllckVsZW1lbnRVVi5VVjtcclxuICAgICAgICBmb3IgKGxldCBpdXY6IG51bWJlciA9IDA7IGl1diA8IHV2QnVmZmVyLmxlbmd0aDsgaXV2ICs9IDIpIHtcclxuICAgICAgICAgIHV2cy5wdXNoKG5ldyBWZWN0b3IyKHV2QnVmZmVyW2l1dl0sIDEgLSB1dkJ1ZmZlcltpdXYgKyAxXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IG5vcm1hbHM6IFZlY3RvcjNbXSA9IFtdO1xyXG4gICAgICBpZiAoZ2VvbWV0cnlGQlguTGF5ZXJFbGVtZW50Tm9ybWFsKSB7XHJcbiAgICAgICAgbGV0IG5vcm1hbEJ1ZmZlcjogRmxvYXQzMkFycmF5ID0gZ2VvbWV0cnlGQlguTGF5ZXJFbGVtZW50Tm9ybWFsLk5vcm1hbHM7XHJcbiAgICAgICAgZm9yIChsZXQgaU5vcm1hbDogbnVtYmVyID0gMDsgaU5vcm1hbCA8IG5vcm1hbEJ1ZmZlci5sZW5ndGg7IGlOb3JtYWwgKz0gMykge1xyXG4gICAgICAgICAgbm9ybWFscy5wdXNoKG5ldyBWZWN0b3IzKG5vcm1hbEJ1ZmZlcltpTm9ybWFsXSwgbm9ybWFsQnVmZmVyW2lOb3JtYWwgKyAxXSwgbm9ybWFsQnVmZmVyW2lOb3JtYWwgKyAyXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IG1hcFZlcnRleFRvSW5kZXg6IE1hcDxzdHJpbmcsIG51bWJlcj4gPSBuZXcgTWFwKCk7XHJcbiAgICAgIGxldCBuZXdWZXJ0ZXhJbmRpY2VzOiBudW1iZXJbXVtdID0gW107XHJcbiAgICAgIGxldCBpUG9seWdvbjogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IGlzRW5kT2ZQb2x5Z29uOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgIGxldCBwb2x5Z29uOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuICAgICAgZ2VvbWV0cnlGQlguUG9seWdvblZlcnRleEluZGV4LmZvckVhY2goKF9pVmVydGV4LCBfaVBvbHlnb25WZXJ0ZXgpID0+IHtcclxuICAgICAgICBpZiAoX2lWZXJ0ZXggPCAwKSB7XHJcbiAgICAgICAgICBfaVZlcnRleCA9IF9pVmVydGV4IF4gLSAxO1xyXG4gICAgICAgICAgaXNFbmRPZlBvbHlnb24gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IzID0gcG9zaXRpb25zW19pVmVydGV4XTtcclxuICAgICAgICBsZXQgdXY6IFZlY3RvcjIgPSB1dnNbdGhpcy5nZXREYXRhSW5kZXgoZ2VvbWV0cnlGQlguTGF5ZXJFbGVtZW50VVYsIF9pVmVydGV4LCBpUG9seWdvbiwgX2lQb2x5Z29uVmVydGV4KV07XHJcblxyXG4gICAgICAgIGxldCB2ZXJ0ZXhLZXk6IHN0cmluZyA9IHBvc2l0aW9uLnRvU3RyaW5nKCkgKyB1di50b1N0cmluZygpO1xyXG4gICAgICAgIGlmICghbWFwVmVydGV4VG9JbmRleC5oYXModmVydGV4S2V5KSkge1xyXG4gICAgICAgICAgbGV0IG5vcm1hbDogVmVjdG9yMyA9IG5vcm1hbHNbdGhpcy5nZXREYXRhSW5kZXgoZ2VvbWV0cnlGQlguTGF5ZXJFbGVtZW50Tm9ybWFsLCBfaVZlcnRleCwgaVBvbHlnb24sIF9pUG9seWdvblZlcnRleCldO1xyXG5cclxuICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaChuZXcgVmVydGV4KHBvc2l0aW9uLCB1diwgbm9ybWFsKSk7XHJcbiAgICAgICAgICBtYXBWZXJ0ZXhUb0luZGV4LnNldCh2ZXJ0ZXhLZXksIHRoaXMudmVydGljZXMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICBpZiAoIW5ld1ZlcnRleEluZGljZXNbX2lWZXJ0ZXhdKVxyXG4gICAgICAgICAgICBuZXdWZXJ0ZXhJbmRpY2VzW19pVmVydGV4XSA9IFtdO1xyXG4gICAgICAgICAgbmV3VmVydGV4SW5kaWNlc1tfaVZlcnRleF0ucHVzaCh0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb2x5Z29uLnB1c2gobWFwVmVydGV4VG9JbmRleC5nZXQodmVydGV4S2V5KSk7XHJcblxyXG4gICAgICAgIGlmIChpc0VuZE9mUG9seWdvbikge1xyXG4gICAgICAgICAgaWYgKHBvbHlnb24ubGVuZ3RoID09IDMpIHtcclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKG5ldyBGYWNlKHRoaXMudmVydGljZXMsIHBvbHlnb25bMF0sIHBvbHlnb25bMV0sIHBvbHlnb25bMl0pKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAocG9seWdvbi5sZW5ndGggPT0gNCkge1xyXG4gICAgICAgICAgICBsZXQgcXVhZDogUXVhZCA9IG5ldyBRdWFkKHRoaXMudmVydGljZXMsIHBvbHlnb25bMF0sIHBvbHlnb25bMV0sIHBvbHlnb25bMl0sIHBvbHlnb25bM10pO1xyXG4gICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2goLi4ucXVhZC5mYWNlcyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAyOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2gobmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgcG9seWdvblswXSwgcG9seWdvbltpIC0gMV0sIHBvbHlnb25baSAtIDBdKSk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihgJHtNZXNoTG9hZGVyRkJYLm5hbWV9OiBQb2x5Z29ucyB3aXRoIG1vcmUgdGhhbiA0IHZlcnRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkLmApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcG9seWdvbiA9IFtdO1xyXG4gICAgICAgICAgaXNFbmRPZlBvbHlnb24gPSBmYWxzZTtcclxuICAgICAgICAgIGlQb2x5Z29uKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChnZW9tZXRyeUZCWC5jaGlsZHJlbj8uWzBdLnR5cGUgPT0gXCJEZWZvcm1lclwiKSB7XHJcbiAgICAgICAgY29uc3QgZmJ4RGVmb3JtZXI6IEZCWC5EZWZvcm1lciA9IGdlb21ldHJ5RkJYLmNoaWxkcmVuWzBdO1xyXG4gICAgICAgIGNvbnN0IHNrZWxldG9uOiBDb21wb25lbnRTa2VsZXRvbiA9IGF3YWl0IGxvYWRlci5nZXRTa2VsZXRvbihmYnhEZWZvcm1lci5jaGlsZHJlblswXS5jaGlsZHJlblswXSk7IC8vIERlZm9ybWVyLlN1YkRlZm9ybWVyLkxpbWJOb2RlXHJcbiAgICAgICAgdGhpcy5jcmVhdGVCb25lcyhmYnhEZWZvcm1lciwgc2tlbGV0b24sIHRoaXMudmVydGljZXMsIG5ld1ZlcnRleEluZGljZXMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGNvbnN0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pTWVzaCA9IHRoaXMuaU1lc2g7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuaU1lc2ggPSBfc2VyaWFsaXphdGlvbi5pTWVzaDtcclxuICAgICAgcmV0dXJuIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldERhdGFJbmRleChfbGF5ZXJFbGVtZW50OiBGQlguTGF5ZXJFbGVtZW50VVYgfCBGQlguTGF5ZXJFbGVtZW50Tm9ybWFsLCBfaVZlcnRleDogbnVtYmVyLCBfaVBvbHlnb246IG51bWJlciwgX2lQb2x5Z29uVmVydGV4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICBsZXQgaW5kZXg6IG51bWJlciA9XHJcbiAgICAgICAgX2xheWVyRWxlbWVudC5NYXBwaW5nSW5mb3JtYXRpb25UeXBlID09IFwiQnlWZXJ0ZXhcIiA/XHJcbiAgICAgICAgICBfaVZlcnRleCA6XHJcbiAgICAgICAgICBfbGF5ZXJFbGVtZW50Lk1hcHBpbmdJbmZvcm1hdGlvblR5cGUgPT0gXCJCeVBvbHlnb25cIiA/XHJcbiAgICAgICAgICAgIF9pUG9seWdvbiA6XHJcbiAgICAgICAgICAgIF9pUG9seWdvblZlcnRleDtcclxuXHJcbiAgICAgIGlmIChfbGF5ZXJFbGVtZW50LlJlZmVyZW5jZUluZm9ybWF0aW9uVHlwZSA9PT0gJ0luZGV4VG9EaXJlY3QnKSB7XHJcbiAgICAgICAgbGV0IGluZGljZXM6IFVpbnQxNkFycmF5ID0gKF9sYXllckVsZW1lbnQgYXMgRkJYLkxheWVyRWxlbWVudFVWKS5VVkluZGV4IHx8IChfbGF5ZXJFbGVtZW50IGFzIEZCWC5MYXllckVsZW1lbnROb3JtYWwpLk5vcm1hbHNJbmRleDtcclxuICAgICAgICBpbmRleCA9IGluZGljZXNbaW5kZXhdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjcmVhdGVCb25lcyhfZGVmb3JtZXJGQlg6IEZCWC5EZWZvcm1lciwgX3NrZWxldG9uOiBDb21wb25lbnRTa2VsZXRvbiwgX3ZlcnRpY2VzOiBWZXJ0aWNlcywgX25ld1ZlcnRleEluZGljZXM/OiBudW1iZXJbXVtdKTogdm9pZCB7XHJcbiAgICAgIGZvciAoY29uc3QgZmJ4U3ViRGVmb3JtZXIgb2YgX2RlZm9ybWVyRkJYLmNoaWxkcmVuIGFzIEZCWC5TdWJEZWZvcm1lcltdKSB7XHJcbiAgICAgICAgZmJ4U3ViRGVmb3JtZXIubG9hZCgpO1xyXG4gICAgICAgIGlmIChmYnhTdWJEZWZvcm1lci5JbmRleGVzKVxyXG4gICAgICAgICAgZm9yIChsZXQgaUJvbmVJbmZsdWVuY2U6IG51bWJlciA9IDA7IGlCb25lSW5mbHVlbmNlIDwgZmJ4U3ViRGVmb3JtZXIuSW5kZXhlcy5sZW5ndGg7IGlCb25lSW5mbHVlbmNlKyspIHtcclxuICAgICAgICAgICAgY29uc3QgaVZlcnRleDogbnVtYmVyID0gZmJ4U3ViRGVmb3JtZXIuSW5kZXhlc1tpQm9uZUluZmx1ZW5jZV07XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaVZlcnRleE5ldyBvZiBfbmV3VmVydGV4SW5kaWNlcyA/IF9uZXdWZXJ0ZXhJbmRpY2VzW2lWZXJ0ZXhdIDogW2lWZXJ0ZXhdKSB7XHJcbiAgICAgICAgICAgICAgKF92ZXJ0aWNlc1tpVmVydGV4TmV3XS5ib25lcyB8fCAoX3ZlcnRpY2VzW2lWZXJ0ZXhOZXddLmJvbmVzID0gW10pKS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGluZGV4OiBfc2tlbGV0b24uaW5kZXhPZihmYnhTdWJEZWZvcm1lci5jaGlsZHJlblswXS5uYW1lKSxcclxuICAgICAgICAgICAgICAgIHdlaWdodDogZmJ4U3ViRGVmb3JtZXIuV2VpZ2h0c1tpQm9uZUluZmx1ZW5jZV0gfHwgMVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKiogQWxsb3dzIHRvIGNyZWF0ZSBjdXN0b20gbWVzaGVzIGZyb20gZ2l2ZW4gRGF0YSAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoRnJvbURhdGEgZXh0ZW5kcyBNZXNoIHtcclxuICAgIHByb3RlY3RlZCB2ZXJ0aWNlc1RvU2V0OiBGbG9hdDMyQXJyYXk7XHJcbiAgICBwcm90ZWN0ZWQgdGV4dHVyZVVWc1RvU2V0OiBGbG9hdDMyQXJyYXk7XHJcbiAgICBwcm90ZWN0ZWQgaW5kaWNlc1RvU2V0OiBVaW50MTZBcnJheTtcclxuICAgIHByb3RlY3RlZCBmYWNlTm9ybWFsc1RvU2V0OiBGbG9hdDMyQXJyYXk7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF92ZXJ0aWNlczogRmxvYXQzMkFycmF5LCBfdGV4dHVyZVVWczogRmxvYXQzMkFycmF5LCBfaW5kaWNlczogVWludDE2QXJyYXksIF9mYWNlTm9ybWFsczogRmxvYXQzMkFycmF5KSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMudmVydGljZXNUb1NldCA9IF92ZXJ0aWNlcztcclxuICAgICAgdGhpcy50ZXh0dXJlVVZzVG9TZXQgPSBfdGV4dHVyZVVWcztcclxuICAgICAgdGhpcy5pbmRpY2VzVG9TZXQgPSBfaW5kaWNlcztcclxuICAgICAgdGhpcy5mYWNlTm9ybWFsc1RvU2V0ID0gX2ZhY2VOb3JtYWxzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVWZXJ0aWNlcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy52ZXJ0aWNlc1RvU2V0O1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjcmVhdGVUZXh0dXJlVVZzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRleHR1cmVVVnNUb1NldDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5kaWNlcygpOiBVaW50MTZBcnJheSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluZGljZXNUb1NldDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlRmxhdE5vcm1hbHMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuZmFjZU5vcm1hbHNUb1NldDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEEge0BsaW5rIE1lc2h9IGxvYWRlZCBmcm9tIGEgZ2xURi1GaWxlLlxyXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoR0xURiBleHRlbmRzIG1peGluU2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbChNZXNoKSB7XHJcbiAgICBwdWJsaWMgaVByaW1pdGl2ZTogbnVtYmVyOyAvLyBtb3N0IGxpa2VseSB3aWxsIG5vdCBzdGF5IGNvbnNpc3RlbnQgd2l0aCB0aGUgZ2xURiBmaWxlLi4uXHJcblxyXG4gICAgcHVibGljIGFzeW5jIGxvYWQoX3VybDogUmVxdWVzdEluZm8gPSB0aGlzLnVybCwgX25hbWU6IHN0cmluZyA9IHRoaXMubmFtZSwgX2lQcmltaXRpdmU6IG51bWJlciA9IHRoaXMuaVByaW1pdGl2ZSk6IFByb21pc2U8TWVzaEdMVEY+IHtcclxuICAgICAgdGhpcy51cmwgPSBfdXJsO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgICAgdGhpcy5pUHJpbWl0aXZlID0gX2lQcmltaXRpdmU7XHJcbiAgICAgIHJldHVybiBHTFRGTG9hZGVyLmxvYWRSZXNvdXJjZSh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBjb25zdCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaVByaW1pdGl2ZSA9IHRoaXMuaVByaW1pdGl2ZTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5pUHJpbWl0aXZlID0gX3NlcmlhbGl6YXRpb24uaVByaW1pdGl2ZTtcclxuICAgICAgcmV0dXJuIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIG1lc2ggbG9hZGVkIGZyb20gYW4gT0JKLWZpbGUuXHJcbiAgICogU2ltcGxlIFdhdmVmcm9udCBPQkogaW1wb3J0LiBUYWtlcyBhIHdhdmVmcm9udCBvYmogc3RyaW5nLiBUbyBMb2FkIGZyb20gYSBmaWxlIHVybCwgdXNlIHRoZVxyXG4gICAqIHN0YXRpYyBMT0FEIE1ldGhvZC4gQ3VycmVudGx5IG9ubHkgd29ya3Mgd2l0aCB0cmlhbmd1bGF0ZWQgTWVzaGVzXHJcbiAgICogKGFjdGl2YXRlICdHZW9tZW50cnkg4oaSIFRyaWFuZ3VsYXRlIEZhY2VzJyBpbiBCbGVuZGVycyBvYmogZXhwb3J0ZXIpXHJcbiAgICogQHRvZG8gTG9hZCBNYXRlcmlhbHMsIFN1cHBvcnQgUXVhZHNcclxuICAgKiBAYXV0aG9ycyBTaW1vbiBTdG9ybC1TY2h1bGtlIDIwMjEgfCBMdWlzIEtlY2ssIEhGVSwgMjAyMSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxLTIwMjIgfCBNYXR0aGlhcyBSb21pbmcsIEhGVSwgMjAyMyB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoT0JKIGV4dGVuZHMgbWl4aW5TZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsKE1lc2gpIHtcclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZChfdXJsOiBSZXF1ZXN0SW5mbyA9IHRoaXMudXJsKTogUHJvbWlzZTxNZXNoT0JKPiB7XHJcbiAgICAgIGNvbnN0IHVybDogc3RyaW5nID0gbmV3IFVSTChfdXJsLnRvU3RyaW5nKCksIFByb2plY3QuYmFzZVVSTCkudG9TdHJpbmcoKTtcclxuICAgICAgY29uc3QgZGF0YTogc3RyaW5nID0gYXdhaXQgKGF3YWl0IGZldGNoKHVybCkpLnRleHQoKTtcclxuICAgICAgdGhpcy5uYW1lID0gdXJsLnNwbGl0KFwiL1wiKS5wb3AoKTtcclxuICAgICAgdGhpcy51cmwgPSBfdXJsO1xyXG5cclxuICAgICAgY29uc3QgbGluZXM6IHN0cmluZ1tdID0gZGF0YS5zcGxpdChcIlxcblwiKTtcclxuXHJcbiAgICAgIGNvbnN0IGluZGljZXM6IG51bWJlcltdID0gW107XHJcbiAgICAgIGNvbnN0IHBvc2l0aW9uczogVmVjdG9yM1tdID0gW107XHJcbiAgICAgIGNvbnN0IHV2czogVmVjdG9yMltdID0gW107XHJcbiAgICAgIGNvbnN0IG5vcm1hbHM6IFZlY3RvcjNbXSA9IFtdO1xyXG4gICAgICBjb25zdCBub3JtczogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICAgIGNvbnN0IHZlcnRpY2VzOiBWZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICBjb25zdCBmYWNlczogRmFjZVtdID0gW107XHJcbiAgICAgIGNvbnN0IG1hcFBvc2l0aW9uVVZOb3JtYWxUb0luZGV4OiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge307XHJcbiAgICAgIGNvbnN0IG1hcFBvc2l0aW9uTm9ybWFsVG9JbmRleDogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xyXG5cclxuICAgICAgLy8gVE9ETzogdGhpbmsgYWJvdXQgY3JlYXRpbmcgdGhlIG5lZWRlZCBidWZmZXJzIGZvciByZW5kZXJtZXNoIGhlcmUgYWxyZWFkeS4uLlxyXG4gICAgICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICAgICAgY29uc3QgcGFydHM6IHN0cmluZ1tdID0gbGluZS50cmltKCkuc3BsaXQoXCIgXCIpO1xyXG4gICAgICAgIHN3aXRjaCAocGFydHMuc2hpZnQoKSkge1xyXG4gICAgICAgICAgY2FzZSBcInZcIjogLy9WZXJ0ZXggLSBleGFtcGxlOiB2IDAuNzAgLTAuNDUgLTAuNTIgICAgICAgICBcclxuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gobmV3IFZlY3RvcjMoLi4ucGFydHMubWFwKF92YWx1ZSA9PiArX3ZhbHVlKSkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgXCJ2blwiOiAvL05vcm1hbCAtIGV4YW1wbGU6IHZuIDAuMDAgMC4wMCAxLjAwXHJcbiAgICAgICAgICAgIG5vcm1hbHMucHVzaChuZXcgVmVjdG9yMyguLi5wYXJ0cy5tYXAoX3ZhbHVlID0+ICtfdmFsdWUpKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcInZ0XCI6IC8vVGV4Y29vcmQgLSBleGFtcGxlOiB2dCAwLjU0NTQ1NCAwLjQ3MjM4MlxyXG4gICAgICAgICAgICB1dnMucHVzaChuZXcgVmVjdG9yMiguLi5wYXJ0cy5tYXAoKF92YWx1ZSwgX2luZGV4KSA9PiArX3ZhbHVlICogKF9pbmRleCA9PSAxID8gLTEgOiAxKSkpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwiZlwiOiAvKkZhY2UgSW5kaWNlcyAtIGV4YW1wbGU6IGYgMS8xLzEgMi8yLzEgMy8zLzEgLS0+IHZlcnRleDEvdGV4Y29vcmQxL25vcm1hbDEgdmVydGV4Mi90ZXhjb29yZDIvbm9ybWFsMiB2ZXJ0ZXgzL3RleGNvb3JkMy9ub3JtYWwzKi9cclxuICAgICAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IDM7IGkrKykge1xyXG4gICAgICAgICAgICAgIGxldCBrZXk6IHN0cmluZyA9IHBhcnRzW2ldO1xyXG4gICAgICAgICAgICAgIGxldCBpbmRleDogbnVtYmVyIHwgdW5kZWZpbmVkID0gbWFwUG9zaXRpb25VVk5vcm1hbFRvSW5kZXhba2V5XTtcclxuICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJ0ZXhJbmZvOiBzdHJpbmdbXSA9IHBhcnRzW2ldLnNwbGl0KFwiL1wiKTtcclxuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbjogVmVjdG9yMyA9IHBvc2l0aW9uc1srdmVydGV4SW5mb1swXSAtIDFdOyAvLyBvYmogdXNlcyAxLWJhc2VkIGluZGljZXNcclxuICAgICAgICAgICAgICAgIGxldCB1djogVmVjdG9yMiA9IHV2c1srdmVydGV4SW5mb1sxXSAtIDFdID8/IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGxldCBub3JtYWw6IFZlY3RvcjMgPSBub3JtYWxzWyt2ZXJ0ZXhJbmZvWzJdIC0gMV0gPz8gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChub3JtYWwpXHJcbiAgICAgICAgICAgICAgICAgIG5vcm1zLnB1c2gobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGtleVBvc05vcm06IHN0cmluZyA9IGAke3ZlcnRleEluZm9bMF19LyR7dmVydGV4SW5mb1syXX1gO1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXMucHVzaChuZXcgVmVydGV4KG1hcFBvc2l0aW9uTm9ybWFsVG9JbmRleFtrZXlQb3NOb3JtXSA/PyBwb3NpdGlvbiwgdXYsIG5vcm1hbCkpO1xyXG4gICAgICAgICAgICAgICAgbWFwUG9zaXRpb25VVk5vcm1hbFRvSW5kZXhba2V5XSA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcFBvc2l0aW9uTm9ybWFsVG9JbmRleFtrZXlQb3NOb3JtXSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgIG1hcFBvc2l0aW9uTm9ybWFsVG9JbmRleFtrZXlQb3NOb3JtXSA9IGluZGV4O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgZmFjZXMucHVzaChuZXcgRmFjZSh2ZXJ0aWNlcywgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDJdLCBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0sIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAzXSkpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChfZTogdW5rbm93bikge1xyXG4gICAgICAgICAgICAgIERlYnVnLmZ1ZGdlKFwiRmFjZSBleGNsdWRlZFwiLCAoPEVycm9yPl9lKS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG4gICAgICB0aGlzLmZhY2VzID0gZmFjZXM7XHJcbiAgICAgIGlmIChub3Jtcy5sZW5ndGggPiAwKSAvLyBUT0RPOiByZW5kZXJtZXNoIHNob3VsZCBiZSBhYmxlIHRvIGhhbmRsZSB1bmRlZmluZWQgbm9ybWFscyBjb3JyZWN0bHksIGkuZS4gY2FsY3VsYXRlIHRoZW0gb25seSBpZiB0aGV5IGFyZSBub3QgcHJlc2VudCBpbiB0aGUgdmVydGljZXNcclxuICAgICAgICB0aGlzLnJlbmRlck1lc2gubm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybXMpO1xyXG4gICAgICAvLyBfbWVzaC5yZW5kZXJNZXNoLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoaW5kaWNlcyk7IC8vIGRvZW5zJ3Qgc2VlbSB0byBhZmZlY3Qgc2NlbmUgbG9hZGluZyB0aW1lLi4uXHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIHNpbXBsZSBweXJhbWlkIHdpdGggZWRnZXMgYXQgdGhlIGJhc2Ugb2YgbGVuZ3RoIDEgYW5kIGEgaGVpZ2h0IG9mIDEuIFRoZSBzaWRlcyBjb25zaXN0aW5nIG9mIG9uZSwgdGhlIGJhc2Ugb2YgdHdvIHRyaWdvbnNcclxuICAgKiBgYGB0ZXh0XHJcbiAgICogICAgICAgICAgICAgICA0XHJcbiAgICogICAgICAgICAgICAgIC9cXGAuXHJcbiAgICogICAgICAgICAgICAzL19fXFxfXFwgMlxyXG4gICAqICAgICAgICAgICAwL19fX19cXC8xXHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaFB5cmFtaWQgZXh0ZW5kcyBNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFB5cmFtaWQpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoUHlyYW1pZFwiKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgLy8gdGhpcy5jcmVhdGUoKTtcclxuXHJcbiAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgVmVydGljZXMoXHJcbiAgICAgICAgLy8gZ3JvdW5kIHZlcnRpY2VzXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygtMC41LCAwLjAsIDAuNSksIG5ldyBWZWN0b3IyKDAsIDEpKSxcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKDAuNSwgMC4wLCAwLjUpLCBuZXcgVmVjdG9yMigxLCAxKSksXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjUsIDAuMCwgLTAuNSksIG5ldyBWZWN0b3IyKDEsIDApKSxcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKC0wLjUsIDAuMCwgLTAuNSksIG5ldyBWZWN0b3IyKDAsIDApKSxcclxuICAgICAgICAvLyB0aXAgKHZlcnRleCAjNClcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKDAuMCwgMS4wLCAwLjApLCBuZXcgVmVjdG9yMigwLjUsIDAuNSkpLFxyXG4gICAgICAgIC8vIGZsb29yIGFnYWluIGZvciBkb3duc2lkZSB0ZXh0dXJlXHJcbiAgICAgICAgbmV3IFZlcnRleCgwLCBuZXcgVmVjdG9yMigwLCAwKSksXHJcbiAgICAgICAgbmV3IFZlcnRleCgxLCBuZXcgVmVjdG9yMigxLCAwKSksXHJcbiAgICAgICAgbmV3IFZlcnRleCgyLCBuZXcgVmVjdG9yMigxLCAxKSksXHJcbiAgICAgICAgbmV3IFZlcnRleCgzLCBuZXcgVmVjdG9yMigwLCAxKSlcclxuICAgICAgKTtcclxuICAgICAgdGhpcy5mYWNlcyA9IFtcclxuICAgICAgICBuZXcgRmFjZSh0aGlzLnZlcnRpY2VzLCA0LCAwLCAxKSxcclxuICAgICAgICBuZXcgRmFjZSh0aGlzLnZlcnRpY2VzLCA0LCAxLCAyKSxcclxuICAgICAgICBuZXcgRmFjZSh0aGlzLnZlcnRpY2VzLCA0LCAyLCAzKSxcclxuICAgICAgICBuZXcgRmFjZSh0aGlzLnZlcnRpY2VzLCA0LCAzLCAwKSxcclxuICAgICAgICBuZXcgRmFjZSh0aGlzLnZlcnRpY2VzLCA1ICsgMCwgNSArIDIsIDUgKyAxKSxcclxuICAgICAgICBuZXcgRmFjZSh0aGlzLnZlcnRpY2VzLCA1ICsgMCwgNSArIDMsIDUgKyAyKVxyXG4gICAgICBdO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgc2ltcGxlIHF1YWQgd2l0aCBlZGdlcyBvZiBsZW5ndGggMSwgdGhlIGZhY2UgY29uc2lzdGluZyBvZiB0d28gdHJpZ29uc1xyXG4gICAqIGBgYHRleHRcclxuICAgKiAgICAgICAgMCBfXyAzXHJcbiAgICogICAgICAgICB8X1xcfFxyXG4gICAqICAgICAgICAxICAgIDIgICAgICAgICAgICAgXHJcbiAgICogYGBgIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5LTIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaFF1YWQgZXh0ZW5kcyBNZXNoUG9seWdvbiB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hRdWFkKTtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgc2hhcGU6IFZlY3RvcjJbXSA9IFtcclxuICAgICAgbmV3IFZlY3RvcjIoLTAuNSwgMC41KSwgbmV3IFZlY3RvcjIoLTAuNSwgLTAuNSksIG5ldyBWZWN0b3IyKDAuNSwgLTAuNSksIG5ldyBWZWN0b3IyKDAuNSwgMC41KVxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFF1YWRcIikge1xyXG4gICAgICBzdXBlcihfbmFtZSwgTWVzaFF1YWQuc2hhcGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIC8vIGZsYXQgZXF1YWxzIHNtb290aFxyXG4gICAgLy8gcHVibGljIGdldCB2ZXJ0aWNlc0ZsYXQoKTogRmxvYXQzMkFycmF5IHsgcmV0dXJuIHRoaXMudmVydGljZXM7IH1cclxuICAgIC8vIHB1YmxpYyBnZXQgaW5kaWNlc0ZsYXQoKTogVWludDE2QXJyYXkgeyByZXR1cm4gdGhpcy5pbmRpY2VzOyB9XHJcbiAgICAvLyBwdWJsaWMgZ2V0IG5vcm1hbHNGbGF0KCk6IEZsb2F0MzJBcnJheSB7IHJldHVybiB0aGlzLm5vcm1hbHNWZXJ0ZXg7IH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNnZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB0aGlzLmNyZWF0ZShNZXNoUXVhZC5zaGFwZSwgdHJ1ZSk7IC8vIHRoaXMgc2VlbXMgdG8gYmUgZGlzcGF0Y2hlZCBkb3VibGVkIHdoaWxlIGRlc2VyaWFsaXppbmcgdGhlIHJlc291cmNlc1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iuc2hhcGU7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5maXRUZXh0dXJlO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKiogXHJcbiAgICogVGhpcyBmdW5jdGlvbiB0eXBlIHRha2VzIHggYW5kIHogYXMgUGFyYW1ldGVycyBhbmQgcmV0dXJucyBhIG51bWJlciBiZXR3ZWVuIC0xIGFuZCAxIHRvIGJlIHVzZWQgYXMgYSBoZWlnaHRtYXAuIFxyXG4gICAqIHggKiB6ICogMiByZXByZXNlbnQgdGhlIGFtb3V0IG9mIGZhY2VzIHdoaWNoIGFyZSBjcmVhdGVkLiBBcyBhIHJlc3VsdCB5b3UgZ2V0IDEgdmVydGV4IG1vcmUgaW4gZWFjaCBkaXJlY3Rpb24gKHggYW5kIHogYXhpcylcclxuICAgKiBUaGUgeS1jb21wb25lbnQgb2YgdGhlIHJlc3VsdGluZyBtZXNoIG1heSBiZSBtb3ZlZCB0byB2YWx1ZXMgYmV0d2VlbiAwIGFuZCBhIG1heGltdW0gaGVpZ2h0LlxyXG4gICAqIEBhdXRob3JzIFNpbW9uIFN0b3JsLVNjaHVsa2UsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxLTIwMjJcclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBIZWlnaHRNYXBGdW5jdGlvbiA9ICh4OiBudW1iZXIsIHo6IG51bWJlcikgPT4gbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgdmVydGljYWwgcHJvamVjdGlvbiBvZiBhIGdpdmVuIHBvc2l0aW9uIG9udG8gdGhlIHRlcnJhaW5cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVGVycmFpbkluZm8ge1xyXG4gICAgLyoqIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgdmVydGljYWxseSBwcm9qZWN0ZWQgb24gdGhlIHRlcnJhaW4gaW4gd29ybGQgY29vcmRpbmF0ZXMgKi9cclxuICAgIHB1YmxpYyBwb3NpdGlvbjogVmVjdG9yMztcclxuICAgIC8qKiB0aGUgbm9ybWFsIG9mIHRoZSBmYWNlIG9mIHRoZSB0ZXJyYWluIHVuZGVyIHRoZSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcyAqL1xyXG4gICAgcHVibGljIG5vcm1hbDogVmVjdG9yMztcclxuICAgIC8qKiB2ZXJ0aWNhbCBkaXN0YW5jZSBvZiB0aGUgcG9pbnQgdG8gdGhlIHRlcnJhaW4sIG5lZ2F0aXZlIGlmIGJlbG93ICovXHJcbiAgICBwdWJsaWMgZGlzdGFuY2U6IG51bWJlcjtcclxuICAgIC8qKiB0aGUgcG9zaXRpb24gaW4gZmFjZSBjb29yZGluYXRlcyAqL1xyXG4gICAgcHVibGljIHBvc2l0aW9uRmFjZTogVmVjdG9yMztcclxuICAgIC8qKiB0aGUgaW5kZXggb2YgdGhlIGZhY2UgdGhlIHBvc2l0aW9uIGlzIGluc2lkZSAqL1xyXG4gICAgcHVibGljIGluZGV4OiBudW1iZXI7XHJcbiAgICAvKiogdGhlIGdyaWQgY29vcmRpbmF0ZXMgb2YgdGhlIHF1YWQgdGhlIGZhY2UgYmVsb25ncyB0byAqL1xyXG4gICAgcHVibGljIGdyaWQ6IFZlY3RvcjI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHRlcnJhaW4gc3ByZWFkcyBvdXQgaW4gdGhlIHgtei1wbGFuZSwgeSBpcyB0aGUgaGVpZ2h0IGRlcml2ZWQgZnJvbSB0aGUgaGVpZ2h0bWFwIGZ1bmN0aW9uLiBcclxuICAgKiBUaGUgdGVycmFpbiBpcyBhbHdheXMgMSBpbiBzaXplIGluIGFsbCBkaW1lbnNpb25zLCBmaXR0aW5nIGludG8gdGhlIHVuaXQtY3ViZS4gXHJcbiAgICogUmVzb2x1dGlvbiBkZXRlcm1pbmVzIHRoZSBudW1iZXIgb2YgcXVhZHMgaW4geCBhbmQgeiBkaW1lbnNpb24sIHNjYWxlIHRoZSBmYWN0b3IgYXBwbGllZCB0byB0aGUgeCx6LWNvb3JkaW5hdGVzIHBhc3NlZCB0byB0aGUgaGVpZ2h0bWFwIGZ1bmN0aW9uLlxyXG4gICAqIFN0YW5kYXJkIGZ1bmN0aW9uIGlzIHRoZSBzaW1wbGV4IG5vaXNlIGltcGxlbWVudGVkIHdpdGggRlVER0UsIGJ1dCBhbm90aGVyIGZ1bmN0aW9uIGNhbiBiZSBnaXZlbi5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMS0yMDIyIHwgU2ltb24gU3RvcmwtU2NodWxrZSwgSEZVLCAyMDIwIHwgTW9yaXR6IEJlYXVncmFuZCwgSEZVLCAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hUZXJyYWluIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hUZXJyYWluKTtcclxuICAgIHByb3RlY3RlZCByZXNvbHV0aW9uOiBWZWN0b3IyO1xyXG4gICAgcHJvdGVjdGVkIHNjYWxlOiBWZWN0b3IyO1xyXG4gICAgcHJvdGVjdGVkIHNlZWQ6IG51bWJlcjtcclxuICAgIHByb3RlY3RlZCBoZWlnaHRNYXBGdW5jdGlvbjogSGVpZ2h0TWFwRnVuY3Rpb24gPSBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoVGVycmFpblwiLCBfcmVzb2x1dGlvbjogVmVjdG9yMiA9IFZlY3RvcjIuT05FKDIpLCBfc2NhbGVJbnB1dDogVmVjdG9yMiA9IFZlY3RvcjIuT05FKCksIF9mdW5jdGlvbk9yU2VlZDogSGVpZ2h0TWFwRnVuY3Rpb24gfCBudW1iZXIgPSAwKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgdGhpcy5jcmVhdGUoX3Jlc29sdXRpb24sIF9zY2FsZUlucHV0LCBfZnVuY3Rpb25PclNlZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRoaXMgbWVzaCBmcm9tIHRoZSBnaXZlbiBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcmVhdGUoX3Jlc29sdXRpb246IFZlY3RvcjIgPSBWZWN0b3IyLk9ORSgyKSwgX3NjYWxlSW5wdXQ6IFZlY3RvcjIgPSBWZWN0b3IyLk9ORSgpLCBfZnVuY3Rpb25PclNlZWQ6IEhlaWdodE1hcEZ1bmN0aW9uIHwgbnVtYmVyID0gMCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMuc2VlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5yZXNvbHV0aW9uID0gbmV3IFZlY3RvcjIoTWF0aC5yb3VuZChfcmVzb2x1dGlvbi54KSwgTWF0aC5yb3VuZChfcmVzb2x1dGlvbi55KSk7XHJcbiAgICAgIHRoaXMuc2NhbGUgPSBfc2NhbGVJbnB1dC5jbG9uZTtcclxuXHJcbiAgICAgIGlmIChfZnVuY3Rpb25PclNlZWQgaW5zdGFuY2VvZiBGdW5jdGlvbilcclxuICAgICAgICB0aGlzLmhlaWdodE1hcEZ1bmN0aW9uID0gX2Z1bmN0aW9uT3JTZWVkO1xyXG4gICAgICBlbHNlIGlmICh0eXBlb2YgKF9mdW5jdGlvbk9yU2VlZCkgPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIHRoaXMuc2VlZCA9IF9mdW5jdGlvbk9yU2VlZDtcclxuICAgICAgICBsZXQgcHJuZzogUmFuZG9tID0gbmV3IFJhbmRvbSh0aGlzLnNlZWQpO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwRnVuY3Rpb24gPSBuZXcgTm9pc2UyKCgpID0+IHBybmcuZ2V0Tm9ybSgpKS5zYW1wbGU7IC8vIFRPRE8gY2FsbCBQUk5HXHJcbiAgICAgIH0gZWxzZVxyXG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwRnVuY3Rpb24gPSBuZXcgTm9pc2UyKCkuc2FtcGxlO1xyXG5cclxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICAvL0l0ZXJhdGUgb3ZlciBlYWNoIGNlbGwgdG8gZ2VuZXJhdGUgZ3JpZCBvZiB2ZXJ0aWNlc1xyXG4gICAgICBmb3IgKGxldCB6OiBudW1iZXIgPSAwOyB6IDw9IHRoaXMucmVzb2x1dGlvbi55OyB6KyspIHtcclxuICAgICAgICBmb3IgKGxldCB4OiBudW1iZXIgPSAwOyB4IDw9IHRoaXMucmVzb2x1dGlvbi54OyB4KyspIHtcclxuICAgICAgICAgIGxldCB4Tm9ybTogbnVtYmVyID0geCAvIHRoaXMucmVzb2x1dGlvbi54O1xyXG4gICAgICAgICAgbGV0IHpOb3JtOiBudW1iZXIgPSB6IC8gdGhpcy5yZXNvbHV0aW9uLnk7XHJcbiAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2gobmV3IFZlcnRleChcclxuICAgICAgICAgICAgbmV3IFZlY3RvcjMoeE5vcm0gLSAwLjUsIHRoaXMuaGVpZ2h0TWFwRnVuY3Rpb24oeE5vcm0gKiB0aGlzLnNjYWxlLngsIHpOb3JtICogdGhpcy5zY2FsZS55KSwgek5vcm0gLSAwLjUpLFxyXG4gICAgICAgICAgICBuZXcgVmVjdG9yMih4Tm9ybSwgek5vcm0pXHJcbiAgICAgICAgICApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBxdWFkczogUXVhZFtdID0gW107XHJcbiAgICAgIGxldCBzcGxpdDogUVVBRFNQTElUID0gUVVBRFNQTElULkFUXzA7XHJcbiAgICAgIGZvciAobGV0IHo6IG51bWJlciA9IDA7IHogPCB0aGlzLnJlc29sdXRpb24ueTsgeisrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeDogbnVtYmVyID0gMDsgeCA8IHRoaXMucmVzb2x1dGlvbi54OyB4KyspIHtcclxuICAgICAgICAgIHF1YWRzLnB1c2gobmV3IFF1YWQoXHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMsXHJcbiAgICAgICAgICAgICh4ICsgMCkgKyAoeiArIDApICogKHRoaXMucmVzb2x1dGlvbi54ICsgMSksXHJcbiAgICAgICAgICAgICh4ICsgMCkgKyAoeiArIDEpICogKHRoaXMucmVzb2x1dGlvbi54ICsgMSksXHJcbiAgICAgICAgICAgICh4ICsgMSkgKyAoeiArIDEpICogKHRoaXMucmVzb2x1dGlvbi54ICsgMSksXHJcbiAgICAgICAgICAgICh4ICsgMSkgKyAoeiArIDApICogKHRoaXMucmVzb2x1dGlvbi54ICsgMSksXHJcbiAgICAgICAgICAgIHNwbGl0XHJcbiAgICAgICAgICApKTtcclxuICAgICAgICAgIHNwbGl0ID0gKHNwbGl0ID09IFFVQURTUExJVC5BVF8wKSA/IFFVQURTUExJVC5BVF8xIDogUVVBRFNQTElULkFUXzA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnJlc29sdXRpb24ueCAlIDIgPT0gMCkgLy8gcmV2ZXJzZSBsYXN0IHNwbGl0IGNoYW5nZSBpZiB4LXJlc29sdXRpb24gaXMgZXZlblxyXG4gICAgICAgICAgc3BsaXQgPSAoc3BsaXQgPT0gUVVBRFNQTElULkFUXzApID8gUVVBRFNQTElULkFUXzEgOiBRVUFEU1BMSVQuQVRfMDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmZhY2VzID0gcXVhZHMuZmxhdE1hcCgoX3F1YWQ6IFF1YWQpID0+IF9xdWFkLmZhY2VzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZlcnRpY2FsIHByb2plY3Rpb24gb2YgdGhlIGdpdmVuIHBvc2l0aW9uIG9udG8gdGhlIHRlcnJhaW4uXHJcbiAgICAgKiBQYXNzIHRoZSBvdmVyYWxsIHdvcmxkIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSB0ZXJyYWluIGlmIHRoZSBwb3NpdGlvbiBpcyBnaXZlbiBpbiB3b3JsZCBjb29yZGluYXRlcy5cclxuICAgICAqIElmIGF0IGhhbmQsIHBhc3MgdGhlIGludmVyc2UgdG9vIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNhbGN1bGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VGVycmFpbkluZm8oX3Bvc2l0aW9uOiBWZWN0b3IzLCBfbXR4V29ybGQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpLCBfbXR4SW52ZXJzZT86IE1hdHJpeDR4NCk6IFRlcnJhaW5JbmZvIHtcclxuICAgICAgaWYgKCFfbXR4SW52ZXJzZSlcclxuICAgICAgICBfbXR4SW52ZXJzZSA9IE1hdHJpeDR4NC5JTlZFUlNFKF9tdHhXb3JsZCk7XHJcblxyXG4gICAgICBsZXQgdGVycmFpbkluZm86IFRlcnJhaW5JbmZvID0gbmV3IFRlcnJhaW5JbmZvO1xyXG5cclxuICAgICAgbGV0IHBvc0xvY2FsOiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfcG9zaXRpb24sIF9tdHhJbnZlcnNlLCB0cnVlKTtcclxuXHJcblxyXG4gICAgICBsZXQgejogbnVtYmVyID0gTWF0aC5mbG9vcigocG9zTG9jYWwueiArIDAuNSkgKiB0aGlzLnJlc29sdXRpb24ueSk7XHJcbiAgICAgIGxldCB4OiBudW1iZXIgPSBNYXRoLmZsb29yKChwb3NMb2NhbC54ICsgMC41KSAqIHRoaXMucmVzb2x1dGlvbi54KTtcclxuICAgICAgaWYgKHogPCAwIHx8IHogPiB0aGlzLnJlc29sdXRpb24ueSAtIDEgfHwgeCA8IDAgfHwgeCA+IHRoaXMucmVzb2x1dGlvbi54IC0gMSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIGxldCBpbmRleDogbnVtYmVyID0gKHogKiB0aGlzLnJlc29sdXRpb24ueCArIHgpICogMjtcclxuICAgICAgbGV0IGZhY2U6IEZhY2UgPSB0aGlzLmZhY2VzW2luZGV4XTtcclxuXHJcbiAgICAgIGxldCByYXk6IFJheSA9IG5ldyBSYXkoVmVjdG9yMy5ZKCksIHBvc0xvY2FsKTtcclxuICAgICAgbGV0IHBvaW50OiBWZWN0b3IzID0gcmF5LmludGVyc2VjdEZhY2VQbGFuZShmYWNlKTtcclxuICAgICAgaWYgKCFmYWNlLmlzSW5zaWRlKHBvaW50KSkge1xyXG4gICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbaW5kZXhdO1xyXG4gICAgICAgIHBvaW50ID0gcmF5LmludGVyc2VjdEZhY2VQbGFuZShmYWNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGVycmFpbkluZm8uaW5kZXggPSBpbmRleDtcclxuICAgICAgdGVycmFpbkluZm8ucG9zaXRpb25GYWNlID0gcG9pbnQ7XHJcbiAgICAgIHRlcnJhaW5JbmZvLnBvc2l0aW9uID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihwb2ludCwgX210eFdvcmxkLCB0cnVlKTtcclxuICAgICAgdGVycmFpbkluZm8ubm9ybWFsID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihmYWNlLm5vcm1hbCwgTWF0cml4NHg0LlRSQU5TUE9TRShfbXR4SW52ZXJzZSksIGZhbHNlKTtcclxuICAgICAgdGVycmFpbkluZm8uZGlzdGFuY2UgPSBfcG9zaXRpb24ueSAtIHRlcnJhaW5JbmZvLnBvc2l0aW9uLnk7XHJcbiAgICAgIHRlcnJhaW5JbmZvLmdyaWQgPSB0aGlzLmdldEdyaWRGcm9tRmFjZUluZGV4KGluZGV4KTtcclxuICAgICAgcmV0dXJuIHRlcnJhaW5JbmZvO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZ3JpZCBjb29yZGluYXRlcyBvZiB0aGUgcXVhZCB0aGUgZ2l2ZW4gZmFjZSBiZWxvbmdzIHRvLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0R3JpZEZyb21GYWNlSW5kZXgoX2luZGV4OiBudW1iZXIpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcclxuICAgICAgbGV0IGlRdWFkOiBudW1iZXIgPSBNYXRoLmZsb29yKF9pbmRleCAvIDIpO1xyXG4gICAgICByZXN1bHQuc2V0KGlRdWFkICUgdGhpcy5yZXNvbHV0aW9uLnksIE1hdGguZmxvb3IoaVF1YWQgLyB0aGlzLnJlc29sdXRpb24ueCkpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kaWNlcyBvZiB0aGUgdHdvIGZhY2VzIGZvcm1pbmcgdGhlIHF1YWQgdGhlIGdpdmVuIGdyaWQgcG9zaXRpb24gYmVsb25ncyB0by5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEZhY2VJbmRpY2VzRnJvbUdyaWQoX2dyaWQ6IFZlY3RvcjIpOiBudW1iZXJbXSB7XHJcbiAgICAgIGxldCBpUXVhZDogbnVtYmVyID0gX2dyaWQueSAqIDIgKiB0aGlzLnJlc29sdXRpb24ueCArIF9ncmlkLnggKiAyO1xyXG4gICAgICByZXR1cm4gW2lRdWFkLCBpUXVhZCArIDFdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5zZWVkID0gdGhpcy5zZWVkO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnNjYWxlID0gdGhpcy5zY2FsZS5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5yZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgYXdhaXQgdGhpcy5yZXNvbHV0aW9uLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnJlc29sdXRpb24pO1xyXG4gICAgICBhd2FpdCB0aGlzLnNjYWxlLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnNjYWxlKTtcclxuICAgICAgdGhpcy5zZWVkID0gX3NlcmlhbGl6YXRpb24uc2VlZDtcclxuICAgICAgdGhpcy5jcmVhdGUodGhpcy5yZXNvbHV0aW9uLCB0aGlzLnNjYWxlLCB0aGlzLnNlZWQpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yLCBfc2VsZWN0aW9uLCBfZGlzcGF0Y2hNdXRhdGUpO1xyXG4gICAgICB0aGlzLmNyZWF0ZSh0aGlzLnJlc29sdXRpb24sIHRoaXMuc2NhbGUsIHRoaXMuc2VlZCk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCJNZXNoVGVycmFpbi50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGVzIGEgcGxhbmFyIEdyaWQgYW5kIGFwcGxpZXMgYSBIZWlnaHRtYXAtRnVuY3Rpb24gdG8gaXQuXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEgfCBNb3JpdHogQmVhdWdyYW5kLCBIRlUsIDIwMjBcclxuICAgKi9cclxuICBAZW51bWVyYXRlXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hSZWxpZWYgZXh0ZW5kcyBNZXNoVGVycmFpbiB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hSZWxpZWYpO1xyXG5cclxuICAgICN0ZXh0dXJlOiBUZXh0dXJlSW1hZ2U7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hSZWxpZWZcIiwgX3RleHR1cmU/OiBUZXh0dXJlSW1hZ2UpIHtcclxuICAgICAgc3VwZXIoX25hbWUsIFZlY3RvcjIuT05FKDIpLCB1bmRlZmluZWQsIChfeDogbnVtYmVyLCBfejogbnVtYmVyKSA9PiAwKTtcclxuICAgICAgdGhpcy50ZXh0dXJlID0gX3RleHR1cmU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlSGVpZ2h0TWFwRnVuY3Rpb24oX3RleHR1cmU6IFRleHR1cmVJbWFnZSk6IEhlaWdodE1hcEZ1bmN0aW9uIHtcclxuICAgICAgbGV0IGFycmF5OiBVaW50OENsYW1wZWRBcnJheSA9IE1lc2hSZWxpZWYudGV4dHVyZVRvQ2xhbXBlZEFycmF5KF90ZXh0dXJlKTtcclxuICAgICAgbGV0IGhlaWdodE1hcEZ1bmN0aW9uOiBIZWlnaHRNYXBGdW5jdGlvbiA9IChfeDogbnVtYmVyLCBfejogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgbGV0IHBpeGVsOiBudW1iZXIgPSBNYXRoLnJvdW5kKF96ICogX3RleHR1cmUuaW1hZ2Uud2lkdGggKyBfeCk7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5W3BpeGVsICogNF0gLyAyNTU7XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBoZWlnaHRNYXBGdW5jdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyB0ZXh0dXJlVG9DbGFtcGVkQXJyYXkoX3RleHR1cmU6IFRleHR1cmVJbWFnZSk6IFVpbnQ4Q2xhbXBlZEFycmF5IHtcclxuICAgICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICBjYW52YXMud2lkdGggPSBfdGV4dHVyZS5pbWFnZS53aWR0aDtcclxuICAgICAgY2FudmFzLmhlaWdodCA9IF90ZXh0dXJlLmltYWdlLmhlaWdodDtcclxuXHJcbiAgICAgIGxldCBjcmM6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgIGNyYy5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgY3JjLmRyYXdJbWFnZShfdGV4dHVyZS5pbWFnZSwgMCwgMCk7XHJcblxyXG4gICAgICByZXR1cm4gY3JjLmdldEltYWdlRGF0YSgwLCAwLCBfdGV4dHVyZS5pbWFnZS53aWR0aCwgX3RleHR1cmUuaW1hZ2UuaGVpZ2h0KS5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIFRoZSB0ZXh0dXJlIHRvIGJlIHVzZWQgYXMgdGhlIGhlaWdodG1hcC5cclxuICAgICAqICoqQ2F1dGlvbiEqKiBTZXR0aW5nIHRoaXMgY2F1c2VzIHRoZSBtZXNoIHRvIGJlIHJlY3JlYXRlZCB3aGljaCBjYW4gYmUgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbi5cclxuICAgICAqL1xyXG4gICAgQGVudW1lcmF0ZVxyXG4gICAgQHR5cGUoVGV4dHVyZUltYWdlKVxyXG4gICAgcHVibGljIGdldCB0ZXh0dXJlKCk6IFRleHR1cmVJbWFnZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiN0ZXh0dXJlO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCB0ZXh0dXJlKF90ZXh0dXJlOiBUZXh0dXJlSW1hZ2UpIHtcclxuICAgICAgdGhpcy4jdGV4dHVyZSA9IF90ZXh0dXJlO1xyXG4gICAgICBpZiAoIV90ZXh0dXJlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgbGV0IHJlc29sdXRpb246IFZlY3RvcjIgPSBfdGV4dHVyZSA/IG5ldyBWZWN0b3IyKF90ZXh0dXJlLmltYWdlLndpZHRoIC0gMSwgX3RleHR1cmUuaW1hZ2UuaGVpZ2h0IC0gMSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgIHN1cGVyLmNyZWF0ZShyZXNvbHV0aW9uLCByZXNvbHV0aW9uLCBNZXNoUmVsaWVmLmNyZWF0ZUhlaWdodE1hcEZ1bmN0aW9uKF90ZXh0dXJlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBkZWxldGUgc2VyaWFsaXphdGlvbi5zZWVkO1xyXG4gICAgICBkZWxldGUgc2VyaWFsaXphdGlvbi5zY2FsZTtcclxuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb24ucmVzb2x1dGlvbjtcclxuXHJcbiAgICAgIGlmICh0aGlzLiN0ZXh0dXJlKVxyXG4gICAgICAgIHNlcmlhbGl6YXRpb24uaWRUZXh0dXJlID0gdGhpcy50ZXh0dXJlLmlkUmVzb3VyY2U7XHJcblxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkVGV4dHVyZSkgXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gPFRleHR1cmVJbWFnZT5hd2FpdCBQcm9qZWN0LmdldFJlc291cmNlKF9zZXJpYWxpemF0aW9uLmlkVGV4dHVyZSk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNlZWQ7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zY2FsZTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnJlc29sdXRpb247XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCIvLyAvPHJlZmVyZW5jZSBwYXRoPVwiTWVzaFBvbHlnb24udHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIHJvdGF0aW9uIG9mIGEgcG9seWdvbiBhcm91bmQgdGhlIHktYXhpc1xyXG4gICAqIGBgYHRleHQgICAgICAgXHJcbiAgICogICAgICAgICAgICAgICAgICAgICB5XHJcbiAgICogICAgICAgICAgICAgICAgICBfICDihpEgMF8xXHJcbiAgICogICAgICAgICAgICAgICAgIOKUgiAgIOKUguKGkngg4pSCMiAgICAgICAgIFxyXG4gICAqICAgICAgICAgICAgICAgICAg4pWyICDilIIgIOKVsTMgICAgICAgICBcclxuICAgKiAgICAgICAgICAgICAgICAgIOKVsSAg4pSCICDilbIgICBcclxuICAgKiAgICAgICAgICAgICAgICAg4pWxX19f4pSCX19f4pWyNCBcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICA1XHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoUm90YXRpb24gZXh0ZW5kcyBNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFJvdGF0aW9uKTtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgdmVydGljZXNEZWZhdWx0OiBWZWN0b3IyW10gPSBbIC8vIGxpbmUgaXMgdGhlIG1pbmltYWwgc2hhcGVcclxuICAgICAgbmV3IFZlY3RvcjIoMC41LCAwLjUpLFxyXG4gICAgICBuZXcgVmVjdG9yMigwLjUsIC0wLjUpXHJcbiAgICBdO1xyXG4gICAgcHJvdGVjdGVkIHNoYXBlOiBNdXRhYmxlQXJyYXk8VmVjdG9yMj4gPSBuZXcgTXV0YWJsZUFycmF5PFZlY3RvcjI+KFZlY3RvcjIpO1xyXG4gICAgcHJvdGVjdGVkIGxvbmdpdHVkZXM6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFJvdGF0aW9uXCIsIF9zaGFwZTogVmVjdG9yMltdID0gTWVzaFJvdGF0aW9uLnZlcnRpY2VzRGVmYXVsdCwgX2xvbmdpdHVkZXM6IG51bWJlciA9IDMpIHtcclxuICAgICAgc3VwZXIoX25hbWUpO1xyXG4gICAgICB0aGlzLnJvdGF0ZShfc2hhcGUsIF9sb25naXR1ZGVzKTtcclxuICAgICAgLy8gY29uc29sZS5sb2coXCJNdXRhdG9yXCIsIHRoaXMuZ2V0TXV0YXRvcigpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2V0IG1pblZlcnRpY2VzKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiAyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5zaGFwZSA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplQXJyYXkoVmVjdG9yMiwgdGhpcy5zaGFwZSk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24ubG9uZ2l0dWRlcyA9IHRoaXMubG9uZ2l0dWRlcztcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBsZXQgc2hhcGU6IFZlY3RvcjJbXSA9IDxWZWN0b3IyW10+YXdhaXQgU2VyaWFsaXplci5kZXNlcmlhbGl6ZUFycmF5KF9zZXJpYWxpemF0aW9uLnNoYXBlKTtcclxuICAgICAgdGhpcy5sb25naXR1ZGVzID0gX3NlcmlhbGl6YXRpb24ubG9uZ2l0dWRlcztcclxuICAgICAgdGhpcy5yb3RhdGUoc2hhcGUsIHRoaXMubG9uZ2l0dWRlcyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IsIF9zZWxlY3Rpb24sIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICAgIHRoaXMucm90YXRlKHRoaXMuc2hhcGUsIHRoaXMubG9uZ2l0dWRlcyk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTVVUQVRFKSk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBwcm90ZWN0ZWQgcm90YXRlKF9zaGFwZTogVmVjdG9yMltdLCBfbG9uZ2l0dWRlczogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgdGhpcy5zaGFwZSA9IDxNdXRhYmxlQXJyYXk8VmVjdG9yMj4+TXV0YWJsZUFycmF5LmZyb20oX3NoYXBlLm1hcChfdmVydGV4ID0+IF92ZXJ0ZXguY2xvbmUpKTtcclxuICAgICAgdGhpcy5sb25naXR1ZGVzID0gTWF0aC5yb3VuZChfbG9uZ2l0dWRlcyk7XHJcbiAgICAgIGxldCBhbmdsZTogbnVtYmVyID0gMzYwIC8gdGhpcy5sb25naXR1ZGVzO1xyXG4gICAgICBsZXQgbXR4Um90YXRlOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT05fWShhbmdsZSk7XHJcbiAgICAgIC8vIGNvcHkgb3JpZ2luYWwgcG9seWdvbiBhcyBWZWN0b3IzIGFycmF5XHJcbiAgICAgIGxldCBwb2x5Z29uOiBWZWN0b3IzW10gPSBbXTtcclxuICAgICAgbGV0IGRpc3RhbmNlczogbnVtYmVyW10gPSBbMF07XHJcbiAgICAgIGxldCB0b3RhbDogbnVtYmVyID0gMDtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuc2hhcGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBwb2x5Z29uLnB1c2godGhpcy5zaGFwZVtpXS50b1ZlY3RvcjMoKSk7XHJcbiAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICBsZXQgZGlzdGFuY2U6IG51bWJlciA9IFZlY3RvcjIuRElGRkVSRU5DRSh0aGlzLnNoYXBlW2ldLCB0aGlzLnNoYXBlW2kgLSAxXSkubWFnbml0dWRlO1xyXG4gICAgICAgICAgdG90YWwgKz0gZGlzdGFuY2U7XHJcbiAgICAgICAgICBkaXN0YW5jZXMucHVzaCh0b3RhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGRpc3RhbmNlcy5mb3JFYWNoKChfZW50cnksIF9pbmRleCkgPT4geyBkaXN0YW5jZXNbX2luZGV4XSA9IF9lbnRyeSAvIHRvdGFsOyB9KTtcclxuXHJcbiAgICAgIGxldCBuVmVydGljZXNQb2x5Z29uOiBudW1iZXIgPSBwb2x5Z29uLmxlbmd0aDtcclxuXHJcbiAgICAgIGxldCBjbG91ZDogVmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgZm9yIChsZXQgbG9uZ2l0dWRlOiBudW1iZXIgPSAwOyBsb25naXR1ZGUgPD0gdGhpcy5sb25naXR1ZGVzOyBsb25naXR1ZGUrKykge1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBuVmVydGljZXNQb2x5Z29uOyBpKyspIHtcclxuICAgICAgICAgIGxldCB1djogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKGxvbmdpdHVkZSAvIHRoaXMubG9uZ2l0dWRlcywgZGlzdGFuY2VzW2ldKTtcclxuICAgICAgICAgIC8vIFRPRE86IGxhc3Qgc2VjdG9yIHNob3VsZCBvbmx5IGJlIHJlZmVyZW5jZXMgdG8gdGhlIGZpcnN0IG1lcmlkaWFuXHJcbiAgICAgICAgICBpZiAobG9uZ2l0dWRlID09IHRoaXMubG9uZ2l0dWRlcylcclxuICAgICAgICAgICAgY2xvdWQucHVzaChuZXcgVmVydGV4KGksIHV2KSk7XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGxvbmdpdHVkZSA+IDAgJiYgdGhpcy5zaGFwZVtpXS54ID09IDApIC8vIHVzZSBhIHNpbmdsZSB2ZXJ0ZXggd2hlbiBpdCdzIG9uIHRoZSByb3RhdGlvbiBheGlzXHJcbiAgICAgICAgICAgICAgY2xvdWQucHVzaChuZXcgVmVydGV4KGksIHV2KSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICBjbG91ZC5wdXNoKG5ldyBWZXJ0ZXgocG9seWdvbltpXS5jbG9uZSwgdXYpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcG9seWdvbi5mb3JFYWNoKChfdmVjdG9yOiBWZWN0b3IzKSA9PiBfdmVjdG9yLnRyYW5zZm9ybShtdHhSb3RhdGUpKTtcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIC8vIGNvcHkgaW5kaWNlcyB0byBuZXcgaW5kZXggYXJyYXlcclxuICAgICAgbGV0IGZhY2VzOiBGYWNlW10gPSBbXTtcclxuXHJcbiAgICAgIGZvciAobGV0IGxvbmdpdHVkZTogbnVtYmVyID0gMDsgbG9uZ2l0dWRlIDwgdGhpcy5sb25naXR1ZGVzOyBsb25naXR1ZGUrKykge1xyXG4gICAgICAgIGZvciAobGV0IGxhdGl0dWRlOiBudW1iZXIgPSAwOyBsYXRpdHVkZSA8IG5WZXJ0aWNlc1BvbHlnb24gLSAxOyBsYXRpdHVkZSsrKSB7XHJcbiAgICAgICAgICBsZXQgc3RhcnQ6IG51bWJlciA9IGxvbmdpdHVkZSAqIG5WZXJ0aWNlc1BvbHlnb24gKyBsYXRpdHVkZTtcclxuICAgICAgICAgIGxldCBxdWFkOiBRdWFkID0gbmV3IFF1YWQoY2xvdWQsIHN0YXJ0ICsgMSwgc3RhcnQgKyAxICsgblZlcnRpY2VzUG9seWdvbiwgc3RhcnQgKyBuVmVydGljZXNQb2x5Z29uLCBzdGFydCk7XHJcbiAgICAgICAgICBmYWNlcy5wdXNoKC4uLnF1YWQuZmFjZXMpO1xyXG4gICAgICAgICAgLy8gVE9ETzogY2F0Y2ggaW52YWxpZCBmYWNlcyByaWdodCBoZXJlLi4uXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gY2xvdWQ7XHJcbiAgICAgIHRoaXMuZmFjZXMgPSBmYWNlcztcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIFVWIFNwaGVyZSB3aXRoIGEgZ2l2ZW4gbnVtYmVyIG9mIHNlY3RvcnMgYW5kIHN0YWNrcyAoY2xhbXBlZCBhdCAxMjgqMTI4KVxyXG4gICAqIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHA6Ly93d3cuc29uZ2hvLmNhL29wZW5nbC9nbF9zcGhlcmUuaHRtbFxyXG4gICAqIEBhdXRob3JzIFNpbW9uIFN0b3JsLVNjaHVsa2UsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hTcGhlcmUgZXh0ZW5kcyBNZXNoUm90YXRpb24ge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoU3BoZXJlKTtcclxuICAgIHByaXZhdGUgbGF0aXR1ZGVzOiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hTcGhlcmVcIiwgX2xvbmdpdHVkZXM6IG51bWJlciA9IDgsIF9sYXRpdHVkZXM6IG51bWJlciA9IDgpIHtcclxuICAgICAgc3VwZXIoX25hbWUpO1xyXG4gICAgICB0aGlzLmNyZWF0ZShfbG9uZ2l0dWRlcywgX2xhdGl0dWRlcyk7IC8vIFRPRE86IHdoZW4gZGVzZXJpYWxpemVkIHRoaXMgY2F1c2VzIHRoaXMgY2F1c2VzIHRoZSBtZXNoIHRvIGJlIGNyZWF0ZWQgdHdpY2VcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0aGlzIHNwaGVyZSB3aXRoIGEgZ2l2ZW4gbnVtYmVyIG9mIGxvbmdpdHVkZXMgYW5kIGxhdGl0dWRlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlKF9sb25naXR1ZGVzOiBudW1iZXIgPSAzLCBfbGF0aXR1ZGVzOiBudW1iZXIgPSAyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgLy9DbGFtcCByZXNvbHV0aW9uIHRvIHByZXZlbnQgcGVyZm9ybWFuY2UgaXNzdWVzXHJcbiAgICAgIHRoaXMubG9uZ2l0dWRlcyA9IE1hdGgubWluKE1hdGgucm91bmQoX2xvbmdpdHVkZXMpLCAxMjgpO1xyXG4gICAgICB0aGlzLmxhdGl0dWRlcyA9IE1hdGgubWluKE1hdGgucm91bmQoX2xhdGl0dWRlcyksIDEyOCk7XHJcblxyXG4gICAgICBpZiAoX2xvbmdpdHVkZXMgPCAzIHx8IF9sYXRpdHVkZXMgPCAyKSB7XHJcbiAgICAgICAgRGVidWcud2FybihcIlVWIFNwaGVyZSBtdXN0IGhhdmUgYXQgbGVhc3QgMyBsb25naXR1ZGVzIGFuZCAyIGxhdGl0dWRlcyB0byBmb3JtIGEgMy1kaW1lbnNpb25hbCBzaGFwZS5cIik7XHJcbiAgICAgICAgdGhpcy5sb25naXR1ZGVzID0gTWF0aC5tYXgoMywgX2xvbmdpdHVkZXMpO1xyXG4gICAgICAgIHRoaXMubGF0aXR1ZGVzID0gTWF0aC5tYXgoMiwgX2xhdGl0dWRlcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBzaGFwZTogVmVjdG9yMltdID0gW107XHJcbiAgICAgIGxldCBzdGVwOiBudW1iZXIgPSBNYXRoLlBJIC8gdGhpcy5sYXRpdHVkZXM7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPD0gdGhpcy5sYXRpdHVkZXM7ICsraSkge1xyXG4gICAgICAgIGxldCBhbmdsZTogbnVtYmVyID0gTWF0aC5QSSAvIDIgLSBpICogc3RlcDtcclxuICAgICAgICBsZXQgeDogbnVtYmVyID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIGxldCB5OiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZSk7XHJcblxyXG4gICAgICAgIHNoYXBlLnB1c2gobmV3IFZlY3RvcjIoeCAvIDIsIHkgLyAyKSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gcGxhY2UgZmlyc3QgYW5kIGxhc3QgdmVydGV4IGV4YWN0bHkgb24gcm90YXRpb24gYXhpc1xyXG4gICAgICBzaGFwZVswXS54ID0gMDtcclxuICAgICAgc2hhcGVbc2hhcGUubGVuZ3RoIC0gMV0ueCA9IDA7XHJcblxyXG4gICAgICBzdXBlci5yb3RhdGUoc2hhcGUsIF9sb25naXR1ZGVzKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBkZWxldGUgc2VyaWFsaXphdGlvbi5zaGFwZTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5sYXRpdHVkZXMgPSB0aGlzLmxhdGl0dWRlcztcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB0aGlzLmNyZWF0ZShfc2VyaWFsaXphdGlvbi5sb25naXR1ZGVzLCBfc2VyaWFsaXphdGlvbi5sYXRpdHVkZXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yLCBfc2VsZWN0aW9uLCBfZGlzcGF0Y2hNdXRhdGUpO1xyXG4gICAgICB0aGlzLmNyZWF0ZSh0aGlzLmxvbmdpdHVkZXMsIHRoaXMubGF0aXR1ZGVzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNoYXBlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgdHdvIHF1YWRzIHBsYWNlZCBiYWNrIHRvIGJhY2ssIHRoZSBvbmUgZmFjaW5nIGluIG5lZ2F0aXZlIFotZGlyZWN0aW9uIGlzIHRleHR1cmVkIHJldmVyc2VkXHJcbiAgICogYGBgdGV4dFxyXG4gICAqICAgICAgICAwIF9fIDNcclxuICAgKiAgICAgICAgIHxfX3xcclxuICAgKiAgICAgICAgMSAgICAyICAgICAgICAgICAgIFxyXG4gICAqIGBgYCBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoU3ByaXRlIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hTcHJpdGUpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoU3ByaXRlXCIpIHtcclxuICAgICAgc3VwZXIoX25hbWUpO1xyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoLTAuNSwgMC41LCAwKSwgbmV3IFZlY3RvcjIoMCwgMCkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoLTAuNSwgLTAuNSwgMCksIG5ldyBWZWN0b3IyKDAsIDEpKSxcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKDAuNSwgLTAuNSwgMCksIG5ldyBWZWN0b3IyKDEsIDEpKSxcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKDAuNSwgMC41LCAwKSwgbmV3IFZlY3RvcjIoMSwgMCkpXHJcbiAgICAgICk7XHJcbiAgICAgIHRoaXMuZmFjZXMgPSBbXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgMSwgMiwgMCksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgMiwgMywgMCksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgMCwgMywgMSksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgMywgMiwgMSlcclxuICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmbGF0IGlzIHN0YW5kYXJkIGhlcmUgLy8gVE9ETzogaXMgdGhpcyBzdGlsbCBuZWVkZWQ/XHJcbiAgICBwdWJsaWMgZ2V0IHZlcnRpY2VzRmxhdCgpOiBGbG9hdDMyQXJyYXkgeyByZXR1cm4gdGhpcy5yZW5kZXJNZXNoLnBvc2l0aW9uczsgfVxyXG4gICAgcHVibGljIGdldCBpbmRpY2VzRmxhdCgpOiBVaW50MTZBcnJheSB7IHJldHVybiB0aGlzLnJlbmRlck1lc2guaW5kaWNlczsgfVxyXG5cclxuICAgIC8vIGluc3RlYWQsIHNtb290aCBzaGFkaW5nIHdvdWxkIG5lZWQgZXh0cmEgYXR0ZW50aW9uIGJ1dCBpcyBub3QgcmVsZXZhbnQuLi5cclxuXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSB0b3J1cyB3aXRoIGEgZ2l2ZW4gcmluZyByYWRpdXMsIHR1YmUgcmFkaXVzIGFuZCB0aGUgbnVtYmVyIG9mIG1ham9yLSBhbmQgbWlub3Igc2VnbWVudHNcclxuICAgKiBAYXV0aG9ycyBTaW1vbiBTdG9ybC1TY2h1bGtlLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoVG9ydXMgZXh0ZW5kcyBNZXNoUm90YXRpb24ge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoVG9ydXMpO1xyXG4gICAgcHJpdmF0ZSBsYXRpdHVkZXM6IG51bWJlciA9IDEyO1xyXG4gICAgcHJpdmF0ZSByYWRpdXNSaW5nOiBudW1iZXIgPSAwLjUgLSAwLjEyNTtcclxuICAgIHByaXZhdGUgcmFkaXVzVHViZTogbnVtYmVyID0gMC4xMjU7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hUb3J1c1wiLCBfcmFkaXVzUmluZzogbnVtYmVyID0gMC41IC0gMC4xMjUsIF9yYWRpdXNUdWJlOiBudW1iZXIgPSAwLjEyNSAsIF9sb25naXR1ZGVzOiBudW1iZXIgPSA4LCBfbGF0aXR1ZGVzOiBudW1iZXIgPSA2KSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lLCBNZXNoVG9ydXMuZ2V0U2hhcGUoX3JhZGl1c1JpbmcsIF9yYWRpdXNUdWJlLCBNYXRoLm1heCgzLCBfbGF0aXR1ZGVzKSksIF9sb25naXR1ZGVzKTtcclxuICAgICAgdGhpcy5yYWRpdXNUdWJlID0gX3JhZGl1c1R1YmU7XHJcbiAgICAgIHRoaXMucmFkaXVzUmluZyA9IF9yYWRpdXNSaW5nO1xyXG4gICAgICB0aGlzLmxvbmdpdHVkZXMgPSBfbG9uZ2l0dWRlcztcclxuICAgICAgdGhpcy5sYXRpdHVkZXMgPSBNYXRoLm1heCgzLCBfbGF0aXR1ZGVzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRTaGFwZShfcmFkaXVzUmluZzogbnVtYmVyLCBfcmFkaXVzVHViZTogbnVtYmVyLCBfbGF0aXR1ZGVzOiBudW1iZXIpOiBWZWN0b3IyW10ge1xyXG4gICAgICBsZXQgc2hhcGU6IFZlY3RvcjJbXSA9IFtdO1xyXG4gICAgICBsZXQgY2VudGVyOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoX3JhZGl1c1JpbmcsIDApO1xyXG4gICAgICBmb3IgKGxldCBsYXRpdHVkZTogbnVtYmVyID0gMDsgbGF0aXR1ZGUgPD0gX2xhdGl0dWRlczsgbGF0aXR1ZGUrKykge1xyXG4gICAgICAgIGxldCBhbmdsZTogbnVtYmVyID0gMiAqIE1hdGguUEkgKiBsYXRpdHVkZSAvIF9sYXRpdHVkZXM7XHJcbiAgICAgICAgc2hhcGUucHVzaChWZWN0b3IyLlNVTShjZW50ZXIsIG5ldyBWZWN0b3IyKF9yYWRpdXNUdWJlICogLU1hdGguY29zKGFuZ2xlKSwgX3JhZGl1c1R1YmUgKiBNYXRoLnNpbihhbmdsZSkpKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNoYXBlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRoaXMgdG9ydXMgZnJvbSB0aGUgZ2l2ZW4gcGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlKF9yYWRpdXNSaW5nOiBudW1iZXIgPSAwLjUgLSAwLjEyNSwgX3JhZGl1c1R1YmU6IG51bWJlciA9IDAuMTI1LCAgX2xvbmdpdHVkZXM6IG51bWJlciA9IDgsIF9sYXRpdHVkZXM6IG51bWJlciA9IDYpOiB2b2lkIHtcclxuICAgICAgdGhpcy5yYWRpdXNUdWJlID0gX3JhZGl1c1R1YmU7XHJcbiAgICAgIHRoaXMubGF0aXR1ZGVzID0gTWF0aC5tYXgoMywgX2xhdGl0dWRlcyk7XHJcbiAgICAgIHRoaXMucmFkaXVzUmluZyA9IF9yYWRpdXNSaW5nO1xyXG4gICAgICBzdXBlci5yb3RhdGUoTWVzaFRvcnVzLmdldFNoYXBlKF9yYWRpdXNSaW5nLCBfcmFkaXVzVHViZSwgX2xhdGl0dWRlcyksIF9sb25naXR1ZGVzKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmxhdGl0dWRlcyA9IHRoaXMubGF0aXR1ZGVzO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnJhZGl1c1JpbmcgPSB0aGlzLnJhZGl1c1Jpbmc7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24ucmFkaXVzVHViZSA9IHRoaXMucmFkaXVzVHViZTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB0aGlzLmNyZWF0ZShfc2VyaWFsaXphdGlvbi5yYWRpdXNSaW5nLCBfc2VyaWFsaXphdGlvbi5yYWRpdXNUdWJlLCBfc2VyaWFsaXphdGlvbi5sb25naXR1ZGVzLCBfc2VyaWFsaXphdGlvbi5sYXRpdHVkZXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgc3VwZXIubXV0YXRlKF9tdXRhdG9yLCBfc2VsZWN0aW9uLCBfZGlzcGF0Y2hNdXRhdGUpO1xyXG4gICAgICB0aGlzLmNyZWF0ZSh0aGlzLnJhZGl1c1JpbmcsIHRoaXMucmFkaXVzVHViZSwgdGhpcy5sb25naXR1ZGVzLCB0aGlzLmxhdGl0dWRlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zaGFwZTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBlbnVtIFFVQURTUExJVCB7XHJcbiAgICBQTEFOQVIsIEFUXzAsIEFUXzFcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc3VyZmFjZSBjcmVhdGVkIHdpdGggZm91ciB2ZXJ0aWNlcyB3aGljaCBpbW1lZGlhdGVseSBjcmVhdGVzIG5vbmUsIG9uZSBvciB0d28ge0BsaW5rIEZhY2V9cyBkZXBlbmRpbmcgb24gdmVydGljZXMgYXQgaWRlbnRpY2FsIHBvc2l0aW9ucy5cclxuICAgKiBgYGB0ZXh0XHJcbiAgICogUVVBRFNQTElUOiAgUExBTkFSICAgICAgICAgICAgICAgICAgQVRfMCAgICAgICAgICAgICAgICAgICAgIEFUXzFcclxuICAgKiAgICAgICAgICAgICAwIF8gMyAgICAgICAgICAgICAgICAgICAwIF8gMyAgICAgICAgICAgICAgICAgICAgMCBfIDMgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICogICAgICAgICAgICAgIHxcXHwgICAgICAgICAgICAgICAgICAgICB8XFx8ICAgICAgICAgICAgICAgICAgICAgIHwvfCAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgKiAgICAgICAgICAgICAxIOKAviAyICAgICAgICAgICAgICAgICAgIDEg4oC+IDIgICAgICAgICAgICAgICAgICAgIDEg4oC+IDIgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgKiAgc2hhcmVkIGxhc3QgdmVydGV4IDIgICAgICBsYXN0IHZlcnRpY2VzIDIgKyAzICAgICAgbGFzdCB2ZXJ0aWNlcyAzICsgMCBcclxuICAgKiAgICAgIFxyXG4gICAqIGBgYCBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBRdWFkIHtcclxuICAgIHB1YmxpYyBmYWNlczogRmFjZVtdO1xyXG4gICAgI3NwbGl0OiBRVUFEU1BMSVQ7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF92ZXJ0aWNlczogVmVydGljZXMsIF9pbmRleDA6IG51bWJlciwgX2luZGV4MTogbnVtYmVyLCBfaW5kZXgyOiBudW1iZXIsIF9pbmRleDM6IG51bWJlciwgX3NwbGl0OiBRVUFEU1BMSVQgPSBRVUFEU1BMSVQuUExBTkFSKSB7XHJcbiAgICAgIHRoaXMuZmFjZXMgPSBbXTtcclxuICAgICAgdGhpcy4jc3BsaXQgPSBfc3BsaXQ7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKF9zcGxpdCAhPSBRVUFEU1BMSVQuQVRfMSlcclxuICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChuZXcgRmFjZShfdmVydGljZXMsIF9pbmRleDAsIF9pbmRleDEsIF9pbmRleDIpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICB0aGlzLmZhY2VzLnB1c2gobmV3IEZhY2UoX3ZlcnRpY2VzLCBfaW5kZXgxLCBfaW5kZXgyLCBfaW5kZXgzKSk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lOiB1bmtub3duKSB7XHJcbiAgICAgICAgRGVidWcuZnVkZ2UoXCJGYWNlIGV4Y2x1ZGVkXCIsICg8RXJyb3I+X2UpLm1lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKF9zcGxpdCA9PSBRVUFEU1BMSVQuUExBTkFSKVxyXG4gICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKG5ldyBGYWNlKF92ZXJ0aWNlcywgX2luZGV4MywgX2luZGV4MCwgX2luZGV4MikpO1xyXG4gICAgICAgIGVsc2UgaWYgKF9zcGxpdCA9PSBRVUFEU1BMSVQuQVRfMClcclxuICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChuZXcgRmFjZShfdmVydGljZXMsIF9pbmRleDAsIF9pbmRleDIsIF9pbmRleDMpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICB0aGlzLmZhY2VzLnB1c2gobmV3IEZhY2UoX3ZlcnRpY2VzLCBfaW5kZXgxLCBfaW5kZXgzLCBfaW5kZXgwKSk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lOiB1bmtub3duKSB7XHJcbiAgICAgICAgRGVidWcuZnVkZ2UoXCJGYWNlIGV4Y2x1ZGVkXCIsICg8RXJyb3I+X2UpLm1lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBzcGxpdCgpOiBRVUFEU1BMSVQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3BsaXQ7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQm9uZSB7XHJcbiAgICBpbmRleDogbnVtYmVyO1xyXG4gICAgd2VpZ2h0OiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiB0aGUgcmVmZXIgdG8gIGRlc2NyaXB0aW9uIGlzIG5vIGxvbmdlciBjb3JyZWN0IGFzIHJlZmVyIHRvIGFsc28gd29ya3MgZm9yIGJvbmUgaW5kaWNlc1xyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgYSB2ZXJ0ZXggb2YgYSBtZXNoIHdpdGggZXh0ZW5kZWQgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgdXYgY29vcmRpbmF0ZXMgYW5kIHRoZSB2ZXJ0ZXggbm9ybWFsLlxyXG4gICAqIEl0IG1heSByZWZlciB0byBhbm90aGVyIHZlcnRleCB2aWEgYW4gaW5kZXggaW50byBzb21lIGFycmF5LCBpbiB3aGljaCBjYXNlIHRoZSBwb3NpdGlvbiBhbmQgdGhlIG5vcm1hbCBhcmUgc3RvcmVkIHRoZXJlLlxyXG4gICAqIFRoaXMgd2F5LCB2ZXJ0ZXggcG9zaXRpb24gYW5kIG5vcm1hbCBpcyBhIDE6MSBhc3NvY2lhdGlvbiwgdmVydGV4IHRvIHRleHR1cmUgY29vcmRpbmF0ZXMgYSAxOm4gYXNzb2NpYXRpb24uXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVmVydGV4IHtcclxuICAgIHB1YmxpYyBwb3NpdGlvbjogVmVjdG9yMztcclxuICAgIHB1YmxpYyB1djogVmVjdG9yMiB8IG51bGw7XHJcbiAgICBwdWJsaWMgbm9ybWFsOiBWZWN0b3IzO1xyXG4gICAgcHVibGljIGNvbG9yOiBDb2xvcjtcclxuICAgIHB1YmxpYyB0YW5nZW50OiBWZWN0b3I0IHwgbnVsbDtcclxuICAgIHB1YmxpYyByZWZlclRvOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYm9uZXM6IEJvbmVbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcHJlc2VudHMgYSB2ZXJ0ZXggb2YgYSBtZXNoIHdpdGggZXh0ZW5kZWQgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgdXYgY29vcmRpbmF0ZXMgdGhlIHZlcnRleCBub3JtYWwgYW5kIGl0cyB0YW5nZW50cy5cclxuICAgICAqIEl0IG1heSByZWZlciB0byBhbm90aGVyIHZlcnRleCB2aWEgYW4gaW5kZXggaW50byBzb21lIGFycmF5LCBpbiB3aGljaCBjYXNlIHRoZSBwb3NpdGlvbiBhbmQgdGhlIG5vcm1hbCBhcmUgc3RvcmVkIHRoZXJlLlxyXG4gICAgICogVGhpcyB3YXksIHZlcnRleCBwb3NpdGlvbiBhbmQgbm9ybWFsIGlzIGEgMToxIGFzc29jaWF0aW9uLCB2ZXJ0ZXggdG8gdGV4dHVyZSBjb29yZGluYXRlcyBhIDE6biBhc3NvY2lhdGlvbi5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3Bvc2l0aW9uT3JJbmRleDogVmVjdG9yMyB8IG51bWJlciwgX3V2OiBWZWN0b3IyID0gbnVsbCwgX25vcm1hbDogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpLCBfdGFuZ2VudDogVmVjdG9yNCA9IG51bGwsIF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSksIF9ib25lczogQm9uZVtdID0gbnVsbCkge1xyXG4gICAgICBpZiAoX3Bvc2l0aW9uT3JJbmRleCBpbnN0YW5jZW9mIFZlY3RvcjMpXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IF9wb3NpdGlvbk9ySW5kZXg7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLnJlZmVyVG8gPSBfcG9zaXRpb25PckluZGV4O1xyXG5cclxuICAgICAgdGhpcy51diA9IF91djtcclxuICAgICAgdGhpcy5ub3JtYWwgPSBfbm9ybWFsO1xyXG4gICAgICB0aGlzLnRhbmdlbnQgPSBfdGFuZ2VudDtcclxuICAgICAgdGhpcy5jb2xvciA9IF9jb2xvcjtcclxuICAgICAgdGhpcy5ib25lcyA9IF9ib25lcztcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBcnJheSB3aXRoIGV4dGVuZGVkIGZ1bmN0aW9uYWxpdHkgdG8gc2VydmUgYXMgYSB7QGxpbmsgVmVydGV4fS1jbG91ZC4gXHJcbiAgICogQWNjZXNzb3JzIHlpZWxkIHBvc2l0aW9uIG9yIG5vcm1hbCBhbHNvIGZvciB2ZXJ0aWNlcyByZWZlcmVuY2luZyBvdGhlciB2ZXJ0aWNlc1xyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIyXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFZlcnRpY2VzIGV4dGVuZHMgQXJyYXk8VmVydGV4PiB7XHJcbiAgICAvLyBUT0RPOiB0aGlzIGNsYXNzIG1heSBiZWNvbWUgbW9yZSBwb3dlcmZ1bCBieSBoaWRpbmcgdGhlIGFycmF5IGFuZCBhZGQgbW9yZSBzZXJ2aWNlIG1ldGhvZHMgbGlrZSBjYWxjdWxhdGluZyBib3VuZGluZyBib3gsIHJhZGl1cyBldGMuXHJcbiAgICAvLyBzZWUgaWYgYSBwcm94eSBvZiB0aGUgYXJyYXkgaW50ZXJmYWNpbmcgW10gd291bGQgZG8gYSBnb29kIGpvYiAtPiB0ZXN0ZWQ6IHByb3h5IGlzIGFib3V0IDIwIHRpbWVzIHNsb3dlciFcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHN1YnNldCBvZiB2ZXJ0aWNlcyB0aGF0IGRvIG5vdCByZWZlciB0byBvdGhlciB2ZXJ0aWNlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG9yaWdpbmFscygpOiBBcnJheTxWZXJ0ZXg+IHtcclxuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKF92ZXJ0ZXggPT4gX3ZlcnRleC5yZWZlclRvID09IHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSBwb3NpdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHZlcnRleCBhZGRyZXNzZWQsIHJlc29sdmluZyByZWZlcmVuY2VzIGJldHdlZW4gdmVydGljZXMgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb3NpdGlvbihfaW5kZXg6IG51bWJlcik6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdmVydGV4OiBWZXJ0ZXggPSB0aGlzW19pbmRleF07XHJcbiAgICAgIHJldHVybiAodmVydGV4LnJlZmVyVG8gPT0gdW5kZWZpbmVkKSA/IHZlcnRleC5wb3NpdGlvbiA6IHRoaXNbdmVydGV4LnJlZmVyVG9dLnBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB0aGUgbm9ybWFsIGFzc29jaWF0ZWQgd2l0aCB0aGUgdmVydGV4IGFkZHJlc3NlZCwgcmVzb2x2aW5nIHJlZmVyZW5jZXMgYmV0d2VlbiB2ZXJ0aWNlcyBcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vcm1hbChfaW5kZXg6IG51bWJlcik6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdmVydGV4OiBWZXJ0ZXggPSB0aGlzW19pbmRleF07XHJcbiAgICAgIHJldHVybiAodmVydGV4LnJlZmVyVG8gPT0gdW5kZWZpbmVkKSA/IHZlcnRleC5ub3JtYWwgOiB0aGlzW3ZlcnRleC5yZWZlclRvXS5ub3JtYWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSB0YW5nZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgdmVydGV4IGFkZHJlc3NlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdGFuZ2VudChfaW5kZXg6IG51bWJlcik6IFZlY3RvcjQge1xyXG4gICAgICByZXR1cm4gdGhpc1tfaW5kZXhdLnRhbmdlbnQ7IC8vIHRhbmdlbnRzIGNhbiBub3QgYmUgc2hhcmVkIGFzIHRoZXkgYXJlIGRlcGVuZGVudCBvbiB0aGUgdXYtY29vcmRpbmF0ZXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgdGhlIHV2LWNvb3JkaW5hdGVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdmVydGV4IGFkZHJlc3NlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXYoX2luZGV4OiBudW1iZXIpOiBWZWN0b3IyIHtcclxuICAgICAgcmV0dXJuIHRoaXNbX2luZGV4XS51djtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgdGhlIGNvbG9yIGFzc29jaWF0ZWQgd2l0aCB0aGUgdmVydGV4IGFkZHJlc3NlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29sb3IoX2luZGV4OiBudW1iZXIpOiBDb2xvciB7XHJcbiAgICAgIHJldHVybiB0aGlzW19pbmRleF0uY29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSBib25lcyBhc3NvY2lhdGVkIHdpdGggdGhlIHZlcnRleCBhZGRyZXNzZWQsIHJlc29sdmluZyByZWZlcmVuY2VzIGJldHdlZW4gdmVydGljZXMgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBib25lcyhfaW5kZXg6IG51bWJlcik6IEJvbmVbXSB7XHJcbiAgICAgIGxldCB2ZXJ0ZXg6IFZlcnRleCA9IHRoaXNbX2luZGV4XTtcclxuICAgICAgcmV0dXJuICh2ZXJ0ZXgucmVmZXJUbyA9PSB1bmRlZmluZWQpID8gdmVydGV4LmJvbmVzIDogdGhpc1t2ZXJ0ZXgucmVmZXJUb10uYm9uZXM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgV2ViR0wgc2hhZGVycHJvZ3JhbSBmb3IgYSBwYXJ0aWNsZSBzeXN0ZW0uIE1hbmFnZWQgYnkgYSB7QGxpbmsgUGFydGljbGVTeXN0ZW19LiBJdCB1c2VzIHtAbGluayBQYXJ0aWNsZVN5c3RlbS5kYXRhfSB0byBnZW5lcmF0ZSBhbmQgaW5qZWN0IGNvZGUgaW50byBhIHNoYWRlciB1bml2ZXJzYWwgZGVyaXZhdGUgKEdMU0wpIHRodXMgY3JlYXRpbmcgYSBzaGFkZXIgcGFydGljbGUgc3lzdGVtIGZyb20gYSBzdXBwbGllZCB7QGxpbmsgU2hhZGVyfXMgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXIgc291cmNlIGNvZGUuXHJcbiAgICogQGF1dGhvciBKb25hcyBQbG90emt5LCBIRlUsIDIwMjJcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBAUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5kZWNvcmF0ZVxyXG4gIGV4cG9ydCBjbGFzcyBTaGFkZXJQYXJ0aWNsZVN5c3RlbSBpbXBsZW1lbnRzIFNoYWRlckludGVyZmFjZSB7XHJcbiAgICBwdWJsaWMgZGF0YTogUGFydGljbGVEYXRhLlN5c3RlbTtcclxuICAgIHB1YmxpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1wiUEFSVElDTEVcIl07XHJcbiAgICBwdWJsaWMgdmVydGV4U2hhZGVyU291cmNlOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgZnJhZ21lbnRTaGFkZXJTb3VyY2U6IHN0cmluZztcclxuXHJcbiAgICBwdWJsaWMgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xyXG4gICAgcHVibGljIGF0dHJpYnV0ZXM6IHsgW25hbWU6IHN0cmluZ106IG51bWJlciB9O1xyXG4gICAgcHVibGljIHVuaWZvcm1zOiB7IFtuYW1lOiBzdHJpbmddOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW19LiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHsgcmV0dXJuIFwiXCI7IC8qIGluamVjdGVkIGJ5IGRlY29yYXRvciAqLyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbX0uIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IHJldHVybiBcIlwiOyAvKiBpbmplY3RlZCBieSBkZWNvcmF0b3IgKi8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW19LiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWxldGVQcm9ncmFtKCk6IHZvaWQgey8qIGluamVjdGVkIGJ5IGRlY29yYXRvciAqLyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbX0uIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVzZVByb2dyYW0oKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtfS4gVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlUHJvZ3JhbSgpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBkZWNvcmF0b3IgKi8gfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEVuYWJsZXMgdGhpcyBub2RlIHRvIGFjY2VzcyB0aGUgd2F5cG9pbnQgZ3JpZCBlc3RhYmxpc2hlZCB0aHJvdWdoIHtAbGluayBDb21wb25lbnRXYXlwb2ludH1zIGFuZCB0aGVpciB7QGxpbmsgQ29ubmVjdGlvbn1zLFxyXG4gICAqIGZpbmQgYSBwYXRoIHRocm91Z2ggdGhlbSBhbmQgZXZlbiB3YWxrIGRvd24gdGhlIHBhdGguXHJcbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAyNFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRXYWxrZXIgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudFdhbGtlcik7XHJcbiAgICAvKiogVGhlIHNwZWVkIHRoZSB3YWxrZXIgc2hvdWxkIG1vdmUgd2l0aC4gQ29ycmVzcG9uZHMgdG8gdW5pdHMvcy4gKi9cclxuICAgIHB1YmxpYyBzcGVlZDogbnVtYmVyID0gMTtcclxuICAgIC8qKiBJZiB0cnVlLCBtb3ZlIHRoZSBub2RlIHRoaXMgY29tcG9uZW50IGlzIGF0dGFjaGVkIHRvIHRocm91Z2ggZm9yY2VzIGluc3RlYWQgb2YgZGlyZWN0bHkgdGhyb3VnaCB0aGUgdHJhbnNmb3JtLiBSZXF1aXJlcyBhIFtbQ29tcG9uZW50UmlnaWRib2R5XV0gaWYgdHJ1ZS4gKi9cclxuICAgIC8vIHB1YmxpYyBtb3ZlVGhyb3VnaFBoeXNpY3M6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKioga2VlcHMgdGhlIGRhdGEgbmVlZGVkIGZvciB0aGUgY3VycmVudCB3YWxrICovXHJcbiAgICAjd2Fsa0RhdGE6IFdhbGtEYXRhID0geyBwYXRoOiBbXSwgdG90YWxQcm9ncmVzczogLTEgfTtcclxuICAgIC8qKiBrZWVwcyB0aGUgcHJvbWlzZSB0byByZXNvbHZlIHdoZW4gdGhlIHdhbGtlciBoYXMgcmVhY2hlZCB0aGUgZ29hbCAqL1xyXG4gICAgI3Byb21pc2VSZXNvbHZlck9uV2Fsa0ZpbmlzaGVkOiAoKSA9PiB2b2lkO1xyXG4gICAgLyoqIHN0YXR1cyBvZiB3aGV0aGVyIGl0IHNob3VsZCByb3RhdGUgdGhlIHdhbGtlciB0byB0aGUgd2Fsa2luZyBkaXJlY3Rpb24gKi9cclxuICAgICNyb3RhdGVJbldhbGtEaXJlY3Rpb246IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgaWYgKFByb2plY3QubW9kZSA9PSBNT0RFLkVESVRPUilcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCB0aGlzLiNoYW5kbGVBdHRhY2guYmluZCh0aGlzKSk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLiNoYW5kbGVEZXRhY2guYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKSxcclxuICAgICAgICBzcGVlZDogdGhpcy5zcGVlZFxyXG4gICAgICAgIC8vIG1vdmVUaHJvdWdoUGh5c2ljczogdGhpcy5tb3ZlVGhyb3VnaFBoeXNpY3MsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLnNwZWVkID0gX3NlcmlhbGl6YXRpb24uc3BlZWQ7XHJcbiAgICAgIC8vIHRoaXMubW92ZVRocm91Z2hQaHlzaWNzID0gX3NlcmlhbGl6YXRpb24ubW92ZVRocm91Z2hQaHlzaWNzO1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsZXBvcnRzIChtb3ZlcyBpbnN0YW50bHkpIHRvIHRoZSBfdGFyZ2V0IFdheXBvaW50LlxyXG4gICAgICogQHBhcmFtIF90YXJnZXRcclxuICAgICAqIEByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIGltbWVkaWF0ZWx5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgbW92ZVRvKF90YXJnZXQ6IFdheXBvaW50KTogUHJvbWlzZTx2b2lkPjtcclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgdGhlIHdhbGtlciBmcm9tIHRoZSBfc3RhcnQgdG8gdGhlIF9lbmQgV2F5cG9pbnQuXHJcbiAgICAgKiBUZWxlcG9ydHMgKG1vdmVzIGluc3RhbnRseSkgdG8gdGhlIF9zdGFydCBwb2ludCwgdGhlbiBtb3ZlcyB0aHJvdWdoIHRoZSB3YXlwb2ludCBjb25uZWN0aW9ucyB0byB0aGUgX2VuZCBwb2ludC5cclxuICAgICAqIEBwYXJhbSBfc3RhcnQgXHJcbiAgICAgKiBAcGFyYW0gX2VuZFxyXG4gICAgICogQHBhcmFtIF9yb3RhdGUgUm90YXRlcyB0aGUgd2Fsa2VyIHRvIGxvb2sgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgd2F5cG9pbnRcclxuICAgICAqIEByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIF9lbmQgcG9pbnQgaXMgcmVhY2hlZC4gUmVqZWN0cyBpZiBfZW5kIGNhbid0IGJlIHJlYWNoZWQgKG5vIHBhdGggZm91bmQpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgbW92ZVRvKF9zdGFydDogV2F5cG9pbnQsIF9lbmQ6IFdheXBvaW50LCBfcm90YXRlPzogYm9vbGVhbik6IFByb21pc2U8dm9pZD47XHJcbiAgICBwdWJsaWMgYXN5bmMgbW92ZVRvKF9zdGFydDogV2F5cG9pbnQsIF9lbmQ/OiBXYXlwb2ludCwgX3JvdGF0ZTogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGlmICghX3N0YXJ0KSByZXR1cm47XHJcbiAgICAgIGxldCB0cmFuc2xhdGU6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3N0YXJ0Lm10eFdvcmxkLnRyYW5zbGF0aW9uLCB0aGlzLm5vZGUubXR4V29ybGQudHJhbnNsYXRpb24pO1xyXG4gICAgICB0aGlzLm5vZGUubXR4TG9jYWwudHJhbnNsYXRlKHRyYW5zbGF0ZSk7XHJcbiAgICAgIGlmICghX2VuZCB8fCBfc3RhcnQgPT09IF9lbmQpIHtcclxuICAgICAgICB0aGlzLiN3YWxrRGF0YSA9IHsgcGF0aDogW10sIHRvdGFsUHJvZ3Jlc3M6IC0xIH07XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuI3JvdGF0ZUluV2Fsa0RpcmVjdGlvbiA9IF9yb3RhdGU7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKF9yZXNvbHZlLCBfcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgbGV0IHBhdGg6IFBhdGhpbmdOb2RlW10gfCBudWxsID0gdGhpcy5nZXRQYXRoKF9zdGFydCwgX2VuZCk7XHJcbiAgICAgICAgaWYgKCFwYXRoIHx8IHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICBfcmVqZWN0KCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuI3dhbGtEYXRhID0geyBwYXRoLCB0b3RhbFByb2dyZXNzOiAwIH07XHJcbiAgICAgICAgdGhpcy4jcHJvbWlzZVJlc29sdmVyT25XYWxrRmluaXNoZWQgPSBfcmVzb2x2ZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuI3JvdGF0ZUluV2Fsa0RpcmVjdGlvbiAmJiB0aGlzLiN3YWxrRGF0YS5wYXRoLmxlbmd0aCA+PSAxKSB7XHJcbiAgICAgICAgICB0aGlzLnJvdGF0ZVRvd2FyZHModGhpcy4jd2Fsa0RhdGEucGF0aFswXS53YXlwb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGFrZXMgY2FyZSBvZiB0aGUgbW92aW5nIGFsZ29yaXRobSBieSBjYWxjdWxhdGluZyB0aGUgbmV4dCBzdGVwIGFuZCBtb3ZpbmcgYWxvbmcgdGhpcyBzdGVwICovXHJcbiAgICBwcm90ZWN0ZWQgbW92aW5nKCk6IHZvaWQge1xyXG4gICAgICAvLyBhcmUgd2UgY3VycmVudGx5IG1vdmluZz9cclxuICAgICAgaWYgKHRoaXMuI3dhbGtEYXRhLnRvdGFsUHJvZ3Jlc3MgPCAwIHx8IHRoaXMuI3dhbGtEYXRhLnBhdGgubGVuZ3RoID09IDApIHJldHVybjtcclxuICAgICAgLy8gZG8gd2UgaGF2ZSBhIGN1cnJlbnQgcGF0aCB3ZSBjYW4gZm9sbG93XHJcbiAgICAgIGxldCBjdXJyZW50UGF0aDogUGF0aGluZ05vZGUgPSB0aGlzLiN3YWxrRGF0YS5wYXRoW3RoaXMuI3dhbGtEYXRhLnRvdGFsUHJvZ3Jlc3NdO1xyXG4gICAgICBpZiAoIWN1cnJlbnRQYXRoKSByZXR1cm47XHJcblxyXG4gICAgICAvLyBob3cgYmlnIG9mIGEgc3RlcCBhcmUgd2UgdGFraW5nIHRoaXMgZnJhbWU/XHJcbiAgICAgIGxldCBkZWx0YTogbnVtYmVyID0gdGhpcy5zcGVlZCAqIGN1cnJlbnRQYXRoLnByZXZpb3VzQ29ubmVjdGlvbi5zcGVlZE1vZGlmaWVyICogTG9vcC50aW1lRnJhbWVHYW1lIC8gMTAwMDtcclxuICAgICAgLy8gaG93IGZhciBhd2F5IGFyZSB3ZSBmcm9tIHRoZSBuZXh0IHdheXBvaW50P1xyXG4gICAgICBsZXQgc3RlcDogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShcclxuICAgICAgICBjdXJyZW50UGF0aC53YXlwb2ludC5tdHhXb3JsZC50cmFuc2xhdGlvbixcclxuICAgICAgICB0aGlzLm5vZGUubXR4V29ybGQudHJhbnNsYXRpb25cclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIGxldCBzdGVwUm90YXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5DT05TVFJVQ1RJT04oc3RlcCk7XHJcbiAgICAgIC8vIHN0ZXBSb3RhdGlvbi5yb3RhdGUodGhpcy5ub2RlLm10eFdvcmxkLnJvdGF0aW9uKTtcclxuICAgICAgLy8gc3RlcCA9IHN0ZXBSb3RhdGlvbi50cmFuc2xhdGlvbjtcclxuXHJcbiAgICAgIGxldCBzY2FsZTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShcclxuICAgICAgICBjdXJyZW50UGF0aC53YXlwb2ludC5tdHhXb3JsZC5zY2FsaW5nLFxyXG4gICAgICAgIHRoaXMubm9kZS5tdHhXb3JsZC5zY2FsaW5nXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAoZGVsdGEgKiBkZWx0YSA8IHN0ZXAubWFnbml0dWRlU3F1YXJlZCkgeyAvLyB3b24ndCByZWFjaCBuZXh0IHdheXBvaW50IHlldC4gVXNpbmcgc3F1YXJlcyBiZWNhdXNlIHRoYXQncyBmYXN0ZXIgdG8gY29tcHV0ZSB0aGFuIHNxcnRcclxuICAgICAgICBzdGVwLm5vcm1hbGl6ZShkZWx0YSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLm10eExvY2FsLnRyYW5zbGF0ZShzdGVwLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKHNjYWxlLm1hZ25pdHVkZVNxdWFyZWQgPiAwKSB7XHJcbiAgICAgICAgICBzY2FsZS5ub3JtYWxpemUoZGVsdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5vZGUubXR4TG9jYWwuc2NhbGluZyA9IFZlY3RvcjMuU1VNKHNjYWxlLCB0aGlzLm5vZGUubXR4TG9jYWwuc2NhbGluZyk7XHJcbiAgICAgICAgLy8gdGhpcy5ub2RlLm10eExvY2FsLnNjYWxlKFZlY3RvcjMuU1VNKHNjYWxlLCB0aGlzLm5vZGUubXR4TG9jYWwuc2NhbGluZykpO1xyXG4gICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IG1vdmVtZW50IHRocm91Z2ggcGh5c2ljc1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICAvLyByZWFjaGVkIG5leHQgcG9pbnRcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChFVkVOVC5XQVlQT0lOVF9SRUFDSEVELCB7IGJ1YmJsZXM6IHRydWUsIGRldGFpbDogY3VycmVudFBhdGgud2F5cG9pbnQgfSkpO1xyXG4gICAgICAoPENvbXBvbmVudFdheXBvaW50PmN1cnJlbnRQYXRoLndheXBvaW50KS5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChFVkVOVC5XQVlQT0lOVF9SRUFDSEVELCB7IGJ1YmJsZXM6IHRydWUsIGRldGFpbDogdGhpcyB9KSk7XHJcbiAgICAgIFxyXG4gICAgICBsZXQgdHJhbnNsYXRlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKGN1cnJlbnRQYXRoLndheXBvaW50Lm10eFdvcmxkLnRyYW5zbGF0aW9uLCB0aGlzLm5vZGUubXR4V29ybGQudHJhbnNsYXRpb24pO1xyXG4gICAgICB0aGlzLm5vZGUubXR4TG9jYWwudHJhbnNsYXRlKHRyYW5zbGF0ZSwgZmFsc2UpO1xyXG4gICAgICB0aGlzLm5vZGUubXR4TG9jYWwuc2NhbGluZyA9IGN1cnJlbnRQYXRoLndheXBvaW50Lm10eFdvcmxkLnNjYWxpbmc7XHJcbiAgICAgIHRoaXMuI3dhbGtEYXRhLnRvdGFsUHJvZ3Jlc3MrKztcclxuXHJcbiAgICAgIC8vIHJlYWNoZWQgZmluYWwgcG9pbnQsIGZpbmlzaGVkIHdhbGtpbmdcclxuICAgICAgaWYgKHRoaXMuI3dhbGtEYXRhLnRvdGFsUHJvZ3Jlc3MgPj0gdGhpcy4jd2Fsa0RhdGEucGF0aC5sZW5ndGgpIHtcclxuICAgICAgICBpZiAodGhpcy4jcHJvbWlzZVJlc29sdmVyT25XYWxrRmluaXNoZWQpIHRoaXMuI3Byb21pc2VSZXNvbHZlck9uV2Fsa0ZpbmlzaGVkKCk7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChFVkVOVC5QQVRISU5HX0NPTkNMVURFRCwgeyBidWJibGVzOiB0cnVlLCBkZXRhaWw6IGN1cnJlbnRQYXRoLndheXBvaW50IH0pKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHNob3VsZCB3ZSByb3RhdGUgd2Fsa2VyP1xyXG4gICAgICBpZiAodGhpcy4jcm90YXRlSW5XYWxrRGlyZWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5yb3RhdGVUb3dhcmRzKHRoaXMuI3dhbGtEYXRhLnBhdGhbdGhpcy4jd2Fsa0RhdGEudG90YWxQcm9ncmVzc10ud2F5cG9pbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIGZpbmQgdGhlIHBhdGggYmV0d2VlbiB0d28gZ2l2ZW4gd2F5cG9pbnRzICovXHJcbiAgICBwcm90ZWN0ZWQgZ2V0UGF0aChfc3RhcnQ6IFdheXBvaW50LCBfZW5kOiBXYXlwb2ludCk6IFBhdGhpbmdOb2RlW10ge1xyXG4gICAgICAvLyBUT0RPOiB1c2UgYSBtb3JlIGVmZmljaWVudCBhbGdvcml0aG0gbGlrZSBBKiBpbnN0ZWFkIG9mIERpamtzdHJhXHJcbiAgICAgIC8vIHNldHVwIHRoZSBncmFwaCBvZiBwYXRocyBiYXNlZCBvbiB0aGUgc3RhcnQgbm9kZVxyXG4gICAgICBsZXQgdW52aXNpdGVkTm9kZXM6IFBhdGhpbmdOb2RlW10gPSBbXTtcclxuICAgICAgbGV0IHByb2Nlc3NlZFdheXBvaW50czogV2F5cG9pbnRbXSA9IFtfc3RhcnRdO1xyXG4gICAgICBsZXQgd2F5cG9pbnRzVG9TZWFyY2hUaHJvdWdoOiBXYXlwb2ludFtdID0gW19zdGFydF07XHJcbiAgICAgIGRvIHtcclxuICAgICAgICBsZXQgd2F5cG9pbnQ6IFdheXBvaW50ID0gd2F5cG9pbnRzVG9TZWFyY2hUaHJvdWdoLnBvcCgpO1xyXG4gICAgICAgIGZvciAobGV0IGNvbm5lY3Rpb24gb2Ygd2F5cG9pbnQuY29ubmVjdGlvbnMpIHtcclxuICAgICAgICAgIGlmICghcHJvY2Vzc2VkV2F5cG9pbnRzLmluY2x1ZGVzKGNvbm5lY3Rpb24uZW5kKSAmJiBjb25uZWN0aW9uLnN0YXJ0LmlzQWN0aXZlICYmIGNvbm5lY3Rpb24uZW5kLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHdheXBvaW50c1RvU2VhcmNoVGhyb3VnaC5wdXNoKGNvbm5lY3Rpb24uZW5kKTtcclxuICAgICAgICAgICAgcHJvY2Vzc2VkV2F5cG9pbnRzLnB1c2goY29ubmVjdGlvbi5lbmQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB1bnZpc2l0ZWROb2Rlcy5wdXNoKHsgd2F5cG9pbnQsIGRpc3RhbmNlOiB3YXlwb2ludCA9PT0gX3N0YXJ0ID8gMCA6IEluZmluaXR5LCBwcmV2aW91czogbnVsbCwgcHJldmlvdXNDb25uZWN0aW9uOiBudWxsIH0pO1xyXG4gICAgICB9IHdoaWxlICh3YXlwb2ludHNUb1NlYXJjaFRocm91Z2gubGVuZ3RoID4gMCk7XHJcblxyXG4gICAgICAvLyBkbyB0aGUgZGlqa3N0cmFcclxuICAgICAgd2hpbGUgKHVudmlzaXRlZE5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB1bnZpc2l0ZWROb2Rlcy5zb3J0KChfYTogUGF0aGluZ05vZGUsIF9iOiBQYXRoaW5nTm9kZSkgPT4gX2EuZGlzdGFuY2UgLSBfYi5kaXN0YW5jZSk7XHJcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlOiBQYXRoaW5nTm9kZSA9IHVudmlzaXRlZE5vZGVzLnNoaWZ0KCk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLndheXBvaW50ID09PSBfZW5kKSByZXR1cm4gdGhpcy5wYXRoaW5nTm9kZVRvUGF0aChjdXJyZW50Tm9kZSk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGNvbiBvZiBjdXJyZW50Tm9kZS53YXlwb2ludC5jb25uZWN0aW9ucykge1xyXG4gICAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGlvblVzYWJsZShjb24pKSBjb250aW51ZTtcclxuICAgICAgICAgIGxldCBlbmROb2RlOiBQYXRoaW5nTm9kZSA9IHVudmlzaXRlZE5vZGVzLmZpbmQoX24gPT4gX24ud2F5cG9pbnQgPT09IGNvbi5lbmQpO1xyXG4gICAgICAgICAgaWYgKCFlbmROb2RlKSBjb250aW51ZTtcclxuICAgICAgICAgIGxldCBuZXdEaXN0YW5jZTogbnVtYmVyID0gY3VycmVudE5vZGUuZGlzdGFuY2UgKyB0aGlzLmNhbGN1bGF0ZUNvbm5lY3Rpb25Db3N0KGNvbik7XHJcbiAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgPj0gZW5kTm9kZS5kaXN0YW5jZSkgY29udGludWU7XHJcbiAgICAgICAgICBlbmROb2RlLmRpc3RhbmNlID0gbmV3RGlzdGFuY2U7XHJcbiAgICAgICAgICBlbmROb2RlLnByZXZpb3VzID0gY3VycmVudE5vZGU7XHJcbiAgICAgICAgICBlbmROb2RlLnByZXZpb3VzQ29ubmVjdGlvbiA9IGNvbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSBjb25uZWN0aW9uIGlzIHVzYWJsZSBieSB0aGlzIHNwZWNpZmljIHdhbGtlci5cclxuICAgICAqICoqQWx3YXlzIHJldHVybnMgdHJ1ZSwgdW5sZXNzIG92ZXJ3cml0dGVuIGluIGEgY3VzdG9tIFdhbGtlciBzdWJjbGFzcy4qKlxyXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gaW5mbHVlbmNlIHRoZSBwYXRoZmluZGluZyBhbGdvcml0aG0gZm9yIGN1c3RvbSB3YXlwb2ludCAvIGNvbm5lY3Rpb24gc3lzdGVtcy5cclxuICAgICAqIEBwYXJhbSBfY29ubmVjdGlvbiBBIGNvbm5lY3Rpb24gdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGNvbm5lY3Rpb24gaXMgdXNhYmxlIGJ5IHRoaXMgd2Fsa2VyLCBmYWxzZSBpZiBub3RcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGlzQ29ubmVjdGlvblVzYWJsZShfY29ubmVjdGlvbjogQ29ubmVjdGlvbik6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG5ldyBkaXN0YW5jZSBiYXNlZCBvbiBhIGNvbm5lY3Rpb24uXHJcbiAgICAgKiAqKkFsd2F5cyByZXR1cm5zIHRoZSBwbGFpbiBjb25uZWN0aW9ucyBjb3N0IHVubGVzcyBvdmVyd3JpdHRlbiBpbiBhIGN1c3RvbSB3YWxrZXIgc3ViY2xhc3MuKipcclxuICAgICAqIENhbiBiZSB1c2VkIHRvIGluZmx1ZW5jZSB0aGUgcGF0aGZpbmRpbmcgYWxnb3JpdGhtIGZvciBjdXN0b20gd2F5cG9pbnQgLyBjb25uZWN0aW9uIHN5c3RlbXMuXHJcbiAgICAgKiBAcGFyYW0gX2Nvbm5lY3Rpb24gQSBjb25uZWN0aW9uIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgYW1vdW50IG9mIGNvc3QgYSBjb25uZWN0aW9uIGVuY3VycyB0byB0aGUgY3VycmVudCB3YWxrZXIgb3IgMCBpZiBjb3N0IGlzIG5lZ2F0aXZlLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY2FsY3VsYXRlQ29ubmVjdGlvbkNvc3QoX2Nvbm5lY3Rpb246IENvbm5lY3Rpb24pOiBudW1iZXIge1xyXG4gICAgICBpZiAoX2Nvbm5lY3Rpb24uY29zdCA+PSAwKVxyXG4gICAgICAgIHJldHVybiBfY29ubmVjdGlvbi5jb3N0O1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHBhdGhpbmdOb2RlVG9QYXRoKF9ub2RlOiBQYXRoaW5nTm9kZSk6IFBhdGhpbmdOb2RlW10ge1xyXG4gICAgICBsZXQgcGF0aDogUGF0aGluZ05vZGVbXSA9IFtdO1xyXG4gICAgICBpZiAoIV9ub2RlKSByZXR1cm4gcGF0aDtcclxuICAgICAgZG8ge1xyXG4gICAgICAgIHBhdGgucHVzaChfbm9kZSk7XHJcbiAgICAgICAgX25vZGUgPSBfbm9kZS5wcmV2aW91cztcclxuICAgICAgfSB3aGlsZSAoX25vZGU/LnByZXZpb3VzKTtcclxuICAgICAgcmV0dXJuIHBhdGgucmV2ZXJzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcm90YXRlVG93YXJkcyhfd2F5cG9pbnQ6IFdheXBvaW50KTogdm9pZCB7XHJcbiAgICAgIGxldCBtdHhMb29rOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTE9PS19BVCh0aGlzLm5vZGUubXR4V29ybGQudHJhbnNsYXRpb24sIF93YXlwb2ludC5tdHhXb3JsZC50cmFuc2xhdGlvbik7XHJcbiAgICAgIHRoaXMubm9kZS5tdHhMb2NhbC5yb3RhdGlvbiA9IG10eExvb2sucm90YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgI2hhbmRsZUF0dGFjaCgpOiB2b2lkIHtcclxuICAgICAgTG9vcC5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkxPT1BfRlJBTUUsIHRoaXMubW92aW5nLmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgICNoYW5kbGVEZXRhY2goKTogdm9pZCB7XHJcbiAgICAgIExvb3AucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5MT09QX0ZSQU1FLCB0aGlzLm1vdmluZy5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbiBpbnRlcm5hbCBpbnRlcmZhY2UgdG8gbWFuYWdlIHBhdGhpbmcgZGF0YSBpbnNpZGUgdGhlIFdhbGtlclxyXG4gICAqL1xyXG4gIGludGVyZmFjZSBQYXRoaW5nTm9kZSB7XHJcbiAgICB3YXlwb2ludDogV2F5cG9pbnQ7XHJcbiAgICBkaXN0YW5jZTogbnVtYmVyO1xyXG4gICAgcHJldmlvdXM6IFBhdGhpbmdOb2RlO1xyXG4gICAgcHJldmlvdXNDb25uZWN0aW9uOiBDb25uZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW4gaW50ZXJuYWwgaW50ZXJmYWNlIHRvIG1hbmFnZSB0aGUgZGF0YSBvZiB0aGUgY3VycmVudGx5IHdhbGtlZCBwYXRoXHJcbiAgICovXHJcbiAgaW50ZXJmYWNlIFdhbGtEYXRhIHtcclxuICAgIHBhdGg6IFBhdGhpbmdOb2RlW107XHJcbiAgICB0b3RhbFByb2dyZXNzOiBudW1iZXI7XHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFVuaWZpZXMgV2F5cG9pbnRzIG9mIHRoZSBwYXRoaW5nIGFsZ29yaXRobXNcclxuICAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDI0XHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBXYXlwb2ludCB7XHJcbiAgICBjb25uZWN0aW9uczogQ29ubmVjdGlvbltdO1xyXG4gICAgbXR4TG9jYWw6IE1hdHJpeDR4NDtcclxuICAgIG10eFdvcmxkOiBNYXRyaXg0eDQ7XHJcbiAgICBpc0FjdGl2ZTogYm9vbGVhbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgYSBwb3NpdGlvbiB0aGF0IGEge0BsaW5rIENvbXBvbmVudFdhbGtlcn0gY2FuIHVzZSBhcyBhIHRhcmdldCBwb2ludC5cclxuICAgKiBJbXBsZW1lbnRzIHtAbGluayBXYXlwb2ludH0uXHJcbiAgICogUmVnaXN0ZXJzIGl0c2VsZiB0byBhIHN0YXRpYyBsaXN0IG9mIGFsbCBhdmFpbGFibGUgd2F5cG9pbnRzXHJcbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAyNFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRXYXlwb2ludCBleHRlbmRzIENvbXBvbmVudCBpbXBsZW1lbnRzIFdheXBvaW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyh0aGlzKTtcclxuICAgIHN0YXRpYyByZWFkb25seSAjd2F5cG9pbnRzOiBDb21wb25lbnRXYXlwb2ludFtdID0gW107XHJcblxyXG4gICAgcHVibGljIG10eExvY2FsOiBNYXRyaXg0eDQ7XHJcblxyXG4gICAgI2Nvbm5lY3Rpb25zOiBDb25uZWN0aW9uW107XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9tdHhJbml0OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKSwgX2Nvbm5lY3Rpb25zOiBDb25uZWN0aW9uW10gPSBbXSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLiNjb25uZWN0aW9ucyA9IF9jb25uZWN0aW9ucztcclxuICAgICAgdGhpcy5tdHhMb2NhbCA9IF9tdHhJbml0O1xyXG4gICAgICB0aGlzLnNpbmdsZXRvbiA9IGZhbHNlO1xyXG5cclxuICAgICAgaWYgKFByb2plY3QubW9kZSA9PSBNT0RFLkVESVRPUilcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy4jaGFuZGxlQXR0YWNoLmJpbmQodGhpcykpO1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgdGhpcy4jaGFuZGxlRGV0YWNoLmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBBbGwgdGhlIHdheXBvaW50cyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGluIHRoZSBzY2VuZS4gKipEbyBub3QgZWRpdCwgdHJlYXQgYXMgcmVhZG9ubHkhKiogKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IHdheXBvaW50cygpOiBDb21wb25lbnRXYXlwb2ludFtdIHtcclxuICAgICAgcmV0dXJuIENvbXBvbmVudFdheXBvaW50LiN3YXlwb2ludHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNob3J0aGFuZCB0byBjcmVhdGUgYSBjb25uZWN0aW9uIGJldHdlZW4gdHdvIHtAbGluayBDb21wb25lbnRXYXlwb2ludH1zXHJcbiAgICAgKiBAcGFyYW0gX3N0YXJ0IFRoZSB7QGxpbmsgQ29tcG9uZW50V2F5cG9pbnR9IGZyb20gd2hpY2ggdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gX2VuZCBUaGUge0BsaW5rIENvbXBvbmVudFdheXBvaW50fSB0byB3aGljaCB0aGUgY29ubmVjdGlvbiBsZWFkcy5cclxuICAgICAqIEBwYXJhbSBfY29zdCBUaGUgY29zdCBvZiB0aGUgY29ubmVjdGlvbi4gVGhlIGhpZ2hlciB0aGUgdmFsdWUsIHRoZSBsZXNzIGxpa2VseSBpdCBpcyB0byBiZSB0YWtlbi4gQ2Fubm90IGJlIG5lZ2F0aXZlLlxyXG4gICAgICogQHBhcmFtIF9zcGVlZE1vZGlmaWVyIEhvdyBmYXN0IHRoZSBjb25uZWN0aW9uIGNhbiBiZSB3YWxrZWQgb24uIERlZmF1bHRzIHRvIDFcclxuICAgICAqIEBwYXJhbSBfYm90aFdheXMgSWYgdHJ1ZSwgY3JlYXRlcyBhIGNvbm5lY3Rpb24gaW4gYm90aCBkaXJlY3Rpb25zLiBEZWZhdWx0OiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFkZENvbm5lY3Rpb24oX3N0YXJ0OiBDb21wb25lbnRXYXlwb2ludCwgX2VuZDogQ29tcG9uZW50V2F5cG9pbnQsIF9jb3N0OiBudW1iZXIsIF9zcGVlZE1vZGlmaWVyOiBudW1iZXIgPSAxLCBfYm90aFdheXM6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBfc3RhcnQuYWRkQ29ubmVjdGlvbih7IGNvc3Q6IF9jb3N0LCBlbmQ6IF9lbmQsIHN0YXJ0OiBfc3RhcnQsIHNwZWVkTW9kaWZpZXI6IF9zcGVlZE1vZGlmaWVyIH0pO1xyXG4gICAgICBpZiAoX2JvdGhXYXlzKVxyXG4gICAgICAgIF9lbmQuYWRkQ29ubmVjdGlvbih7IGNvc3Q6IF9jb3N0LCBlbmQ6IF9zdGFydCwgc3RhcnQ6IF9lbmQsIHNwZWVkTW9kaWZpZXI6IF9zcGVlZE1vZGlmaWVyIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaXNBY3RpdmUoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGNvbm5lY3Rpb25zKCk6IENvbm5lY3Rpb25bXSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNjb25uZWN0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIGN1cnJlbnQgd29ybGQgcG9zaXRpb24gb2YgdGhlIFdheXBvaW50LiBSZXR1cm5zIGEgbmV3IE1hdHJpeCB3aXRob3V0IGNvbm5lY3Rpb24gdG8gdGhlIFdheXBvaW50ICovXHJcbiAgICBwdWJsaWMgZ2V0IG10eFdvcmxkKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiBNYXRyaXg0eDQuUFJPRFVDVCh0aGlzLm10eExvY2FsLCB0aGlzLm5vZGUubXR4V29ybGQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBBZGRzIGEgbmV3IHtAbGluayBDb25uZWN0aW9ufSB0byB0aGlzIHdheXBvaW50ICovXHJcbiAgICBwdWJsaWMgYWRkQ29ubmVjdGlvbihfY29ubmVjdGlvbjogQ29ubmVjdGlvbik6IHZvaWQge1xyXG4gICAgICB0aGlzLiNjb25uZWN0aW9ucy5wdXNoKF9jb25uZWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVtb3ZlcyBhIHtAbGluayBDb25uZWN0aW9ufSBmcm9tIHRoaXMgd2F5cG9pbnQgKi9cclxuICAgIHB1YmxpYyByZW1vdmVDb25uZWN0aW9uKF9jb25uZWN0aW9uOiBDb25uZWN0aW9uKTogdm9pZCB7XHJcbiAgICAgIGxldCBpbmRleDogbnVtYmVyID0gdGhpcy4jY29ubmVjdGlvbnMuaW5kZXhPZihfY29ubmVjdGlvbik7XHJcbiAgICAgIGlmIChpbmRleCA8IDApIHJldHVybjtcclxuICAgICAgdGhpcy4jY29ubmVjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIG1hdHJpeDogdGhpcy5tdHhMb2NhbC5zZXJpYWxpemUoKSxcclxuICAgICAgICBjb25uZWN0aW9uczogdGhpcy4jY29ubmVjdGlvbnMubWFwKF9jb24gPT4ge1xyXG4gICAgICAgICAgbGV0IGNvbm5lY3Rpb246IFNlcmlhbGl6ZWRDb25uZWN0aW9uID0geyBjb3N0OiBfY29uLmNvc3QsIGVuZDogX2Nvbi5lbmQsIHNwZWVkTW9kaWZpZXI6IF9jb24uc3BlZWRNb2RpZmllciB9O1xyXG4gICAgICAgICAgaWYgKGNvbm5lY3Rpb24uZW5kIGluc3RhbmNlb2YgQ29tcG9uZW50V2F5cG9pbnQpIHtcclxuICAgICAgICAgICAgY29ubmVjdGlvbi5lbmQgPSBOb2RlLlBBVEhfRlJPTV9UTyh0aGlzLCBjb25uZWN0aW9uLmVuZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcclxuICAgICAgICB9KVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLm10eExvY2FsLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLm1hdHJpeCk7XHJcbiAgICAgIGNvbnN0IGhuZE5vZGVEZXNlcmlhbGl6ZWQ6IEV2ZW50TGlzdGVuZXJVbmlmaWVkID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuI2Nvbm5lY3Rpb25zID0gX3NlcmlhbGl6YXRpb24uY29ubmVjdGlvbnMubWFwKChfY29uOiBTZXJpYWxpemVkQ29ubmVjdGlvbikgPT4ge1xyXG4gICAgICAgICAgbGV0IGNvbm5lY3Rpb246IENvbm5lY3Rpb24gPSB7IGNvc3Q6IF9jb24uY29zdCwgZW5kOiB0aGlzLnNlcmlhbGl6ZWRXYXlwb2ludFRvV2F5cG9pbnQoX2Nvbi5lbmQpLCBzcGVlZE1vZGlmaWVyOiBfY29uLnNwZWVkTW9kaWZpZXIsIHN0YXJ0OiB0aGlzIH07XHJcbiAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQsIGhuZE5vZGVEZXNlcmlhbGl6ZWQpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQsIGhuZE5vZGVEZXNlcmlhbGl6ZWQpO1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkcmF3R2l6bW9zKCk6IHZvaWQge1xyXG4gICAgICBsZXQgc2NhbGVWZWN0b3I6IFZlY3RvcjMgPSBWZWN0b3IzLlNDQUxFKFZlY3RvcjMuT05FKCksIDAuMSk7XHJcbiAgICAgIGxldCBtdHg6IE1hdHJpeDR4NCA9IHRoaXMubXR4V29ybGQ7XHJcbiAgICAgIEdpem1vcy5kcmF3U3BoZXJlKE1hdHJpeDR4NC5DT01QT1NJVElPTihtdHgudHJhbnNsYXRpb24sIFZlY3RvcjMuWkVSTygpLCBzY2FsZVZlY3RvciksIENvbG9yLkNTUyhcIm9yYW5nZVwiKSk7XHJcbiAgICAgIC8vIHJldHVybjtcclxuICAgICAgbGV0IGxpbmVzOiBWZWN0b3IzW10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgY29ubmVjdGlvbiBvZiB0aGlzLmNvbm5lY3Rpb25zKSB7XHJcbiAgICAgICAgLy8gaWYgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnQgYXJlIG9uIHRoZSBzYW1lIHBvaW50LCBkb24ndCBkcmF3IGxpbmUuXHJcbiAgICAgICAgbGV0IHRtcE10eDogTWF0cml4NHg0ID0gY29ubmVjdGlvbi5lbmQubXR4V29ybGQuY2xvbmU7XHJcbiAgICAgICAgbGV0IGRpcmVjdGlvblZlY3RvcjogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShtdHgudHJhbnNsYXRpb24sIHRtcE10eC50cmFuc2xhdGlvbik7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvblZlY3Rvci5tYWduaXR1ZGVTcXVhcmVkID09PSAwKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgLy8gaWYgb25lIG9mIHRoZSB3YXlwb2ludHMgaXMgaW5hY3RpdmUsIGRvbid0IGRyYXcgZ2l6bW9zXHJcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uLmVuZC5pc0FjdGl2ZSB8fCAhY29ubmVjdGlvbi5zdGFydC5pc0FjdGl2ZSkgY29udGludWU7XHJcblxyXG4gICAgICAgIC8vIGFjdHVhbCBsaW5lXHJcbiAgICAgICAgbGluZXMucHVzaChtdHgudHJhbnNsYXRpb24pO1xyXG4gICAgICAgIGxpbmVzLnB1c2godG1wTXR4LnRyYW5zbGF0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gYXJyb3cgaGVhZHNcclxuICAgICAgICBsZXQgZGlyZWN0aW9uTXR4OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuTE9PS19JTih0bXBNdHgudHJhbnNsYXRpb24sIGRpcmVjdGlvblZlY3Rvcik7XHJcbiAgICAgICAgZGlyZWN0aW9uTXR4LnNjYWxlKHNjYWxlVmVjdG9yKTtcclxuICAgICAgICBHaXptb3MuZHJhd1dpcmVDb25lKGRpcmVjdGlvbk10eCwgQ29sb3IuQ1NTKFwib3JhbmdlXCIpKTtcclxuICAgICAgfVxyXG4gICAgICBHaXptb3MuZHJhd0xpbmVzKGxpbmVzLCBNYXRyaXg0eDQuSURFTlRJVFkoKSwgQ29sb3IuQ1NTKFwib3JhbmdlXCIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQW4gaW50ZXJuYWwgZnVuY3Rpb24gdG8gaGVscCB0aGUgZGVzZXJpYWxpemF6dGlvbiBwcm9jZXNzLiAqL1xyXG4gICAgcHJpdmF0ZSBzZXJpYWxpemVkV2F5cG9pbnRUb1dheXBvaW50KF9wb2ludDogc3RyaW5nIHwgV2F5cG9pbnQpOiBXYXlwb2ludCB7XHJcbiAgICAgIGlmICh0eXBlb2YgX3BvaW50ICE9PSBcInN0cmluZ1wiKSByZXR1cm4gX3BvaW50O1xyXG4gICAgICByZXR1cm4gTm9kZS5GSU5EKHRoaXMsIF9wb2ludCkgYXMgQ29tcG9uZW50V2F5cG9pbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgI2hhbmRsZUF0dGFjaCgpOiB2b2lkIHtcclxuICAgICAgQ29tcG9uZW50V2F5cG9pbnQuI3dheXBvaW50cy5wdXNoKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgICNoYW5kbGVEZXRhY2goKTogdm9pZCB7XHJcbiAgICAgIGxldCBpbmRleDogbnVtYmVyID0gQ29tcG9uZW50V2F5cG9pbnQuI3dheXBvaW50cy5pbmRleE9mKHRoaXMpO1xyXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgIENvbXBvbmVudFdheXBvaW50LiN3YXlwb2ludHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIERlZmluZXMgYSBDb25uZWN0aW9uIGluIHRoZSB3YXkgaXQncyBzZXJpYWxpemVkIGluIHJlc291cmNlcyBAaW50ZXJuYWwgKi9cclxuICBpbnRlcmZhY2UgU2VyaWFsaXplZENvbm5lY3Rpb24ge1xyXG4gICAgZW5kOiBXYXlwb2ludCB8IHN0cmluZztcclxuICAgIGNvc3Q6IG51bWJlcjtcclxuICAgIHNwZWVkTW9kaWZpZXI6IG51bWJlcjtcclxuICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQSBkaXJlY3RlZCBjb25uZWN0aW9uIGJldHdlZW4gdHdvIHdheXBvaW50c1xyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMjRcclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIENvbm5lY3Rpb24ge1xyXG4gICAgLyoqIFRoZSBzdGFydCAvIG9yaWdpbiB3YXlwb2ludCBvZiB0aGlzIGNvbm5lY3Rpb24uICovXHJcbiAgICBzdGFydDogV2F5cG9pbnQ7XHJcbiAgICAvKiogVGhlIGVuZCAvIHRhcmdldCB3YXlwb2ludCBvZiB0aGlzIGNvbm5lY3Rpb24uICovXHJcbiAgICBlbmQ6IFdheXBvaW50O1xyXG4gICAgLyoqIFRoZSBjb3N0IG9mIHRoZSBjb25uZWN0aW9uLCB0aGUgaGlnaGVyIHRoZSBsZXNzIGxpa2VseSB0byBiZSB0YWtlbi4gQ2Fubm90IGJlIG5lZ2F0aXZlLiAqL1xyXG4gICAgY29zdDogbnVtYmVyO1xyXG4gICAgLyoqIE1vZGlmaWVzIHRoZSBzcGVlZCB0aGF0IGEgd2Fsa2VyIGNhbiB3YWxrIHBhc3QgdGhpcyBjb25uZWN0aW9uIGJ5IG11bHRpcGx5aW5nIHRoZSBzcGVlZCB3aXRoIHRoaXMgdmFsdWUuIE5lZWRzIHRvIGJlID4wICovXHJcbiAgICBzcGVlZE1vZGlmaWVyOiBudW1iZXI7XHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgYXV0b21hdGljIGFkanVzdG1lbnQgb2YgdGhlIGNvbGxpZGVyXHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gQk9EWV9JTklUIHtcclxuICAgIC8qKiBDb2xsaWRlciB1c2VzIHRoZSBwaXZvdCBvZiB0aGUgbWVzaCBmb3IgaW5pdGlsaWFsaXphdGlvbiAqL1xyXG4gICAgVE9fTUVTSCxcclxuICAgIC8qKiBDb2xsaWRlciB1c2VzIHRoZSB0cmFuc2Zvcm0gb2YgdGhlIG5vZGUgZm9yIGluaXRpbGlhbGl6YXRpb24gKi9cclxuICAgIFRPX05PREUsXHJcbiAgICAvKiogQ29sbGlkZXIgdXNlcyBpdHMgb3duIHBpdm90IGZvciBpbml0aWxpYWxpemF0aW9uICovXHJcbiAgICBUT19QSVZPVFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWN0cyBhcyB0aGUgcGh5c2ljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHtAbGluayBOb2RlfSBpdCdzIGF0dGFjaGVkIHRvLlxyXG4gICAqIEl0J3MgdGhlIGNvbm5lY3Rpb24gYmV0d2VlbiB0aGUgRlVER0UgcmVuZGVyZWQgd29ybGQgYW5kIHRoZSBQaHlzaWNzIHdvcmxkLlxyXG4gICAqIEZvciB0aGUgcGh5c2ljcyB0byBjb3JyZWN0bHkgZ2V0IHRoZSB0cmFuc2Zvcm1hdGlvbnMgcm90YXRpb25zIG5lZWQgdG8gYmUgYXBwbGllZCB3aXRoIGZyb20gbGVmdCA9IHRydWUuXHJcbiAgICogT3Igcm90YXRpb25zIG5lZWQgdG8gaGFwcGVuIGJlZm9yZSBzY2FsaW5nLlxyXG4gICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50UmlnaWRib2R5IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRSaWdpZGJvZHkpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbWFwQm9keVR5cGU6IHsgW3R5cGU6IG51bWJlcl06IG51bWJlciB9ID0gKHR5cGVvZiBPSU1PID09IFwidW5kZWZpbmVkXCIpID9cclxuICAgICAge1xyXG4gICAgICAgIFtCT0RZX1RZUEUuRFlOQU1JQ106IEJPRFlfVFlQRS5EWU5BTUlDLCBbQk9EWV9UWVBFLlNUQVRJQ106IEJPRFlfVFlQRS5TVEFUSUMsIFtCT0RZX1RZUEUuS0lORU1BVElDXTogQk9EWV9UWVBFLktJTkVNQVRJQ1xyXG4gICAgICB9IDoge1xyXG4gICAgICAgIFtCT0RZX1RZUEUuRFlOQU1JQ106IE9JTU8uUmlnaWRCb2R5VHlwZS5EWU5BTUlDLCBbQk9EWV9UWVBFLlNUQVRJQ106IE9JTU8uUmlnaWRCb2R5VHlwZS5TVEFUSUMsIFtCT0RZX1RZUEUuS0lORU1BVElDXTogT0lNTy5SaWdpZEJvZHlUeXBlLktJTkVNQVRJQ1xyXG4gICAgICB9O1xyXG5cclxuICAgIC8qKiBUcmFuc2Zvcm1hdGlvbiBvZiB0aGUgY29sbGlkZXIgcmVsYXRpdmUgdG8gdGhlIG5vZGUncyB0cmFuc2Zvcm0uIE9uY2Ugc2V0IG1vc3RseSByZW1haW5zIGNvbnN0YW50LiBcclxuICAgICAqIElmIGFsdGVyZWQsIHtAbGluayBpc0luaXRpYWxpemVkfSBtdXN0IGJlIHJlc2V0IHRvIGZhbHNlIHRvIHJlY3JlYXRlIHRoZSBjb2xsaWRlciBpbiB0aGUgbmV4dCB7QGxpbmsgUmVuZGVyLnByZXBhcmV9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtdHhQaXZvdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogVmVydGljZXMgdGhhdCBidWlsZCBhIGNvbnZleCBtZXNoIChmb3JtIHRoYXQgaXMgaW4gaXRzZWxmIGNsb3NlZCkuIE5lZWRzIHRvIHNldCBpbiB0aGUgY29uc3RydWN0aW9uIG9mIHRoZSByYiBpZiBub25lIG9mIHRoZSBzdGFuZGFyZCBjb2xsaWRlcnMgaXMgdXNlZC4gXHJcbiAgICAgKiBVbnRlc3RlZCBhbmQgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQgYnkgc2VyaWFsaXphdGlvbiBhbmQgbXV0YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb252ZXhNZXNoOiBGbG9hdDMyQXJyYXkgPSBudWxsO1xyXG5cclxuICAgIC8qKiBDb2xsaXNpb25zIHdpdGggcmlnaWRib2RpZXMgaGFwcGVuaW5nIHRvIHRoaXMgYm9keSwgY2FuIGJlIHVzZWQgdG8gYnVpbGQgYSBjdXN0b20gb25Db2xsaXNpb25TdGF5IGZ1bmN0aW9uYWxpdHkuICovXHJcbiAgICBwdWJsaWMgY29sbGlzaW9uczogQ29tcG9uZW50UmlnaWRib2R5W10gPSBuZXcgQXJyYXkoKTtcclxuICAgIC8qKiBUcmlnZ2VycyB0aGF0IGFyZSBjdXJyZW50bHkgdHJpZ2dlcmluZyB0aGlzIGJvZHkgKi9cclxuICAgIHB1YmxpYyB0cmlnZ2VyaW5nczogQ29tcG9uZW50UmlnaWRib2R5W10gPSBuZXcgQXJyYXkoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBUaGUgZ3JvdXBzIHRoaXMgb2JqZWN0IGNvbGxpZGVzIHdpdGguIEdyb3VwcyBtdXN0IGJlIHdyaXRlbiBpbiBmb3JtIG9mXHJcbiAgICAgKiAgZS5nLiBjb2xsaXNpb25NYXNrID0ge0BsaW5rIENPTExJU0lPTl9HUk9VUC5ERUZBVUxUfSB8IHtAbGluayBDT0xMSVNJT05fR1JPVVB9Li4uLiBhbmQgc28gb24gdG8gY29sbGlkZSB3aXRoIG11bHRpcGxlIGdyb3Vwcy4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb2xsaXNpb25NYXNrOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQXV0b21hdGljIGFkanVzdG1lbnQgb2YgdGhlIHBpdm90IHdoZW4ge0BsaW5rIFJlbmRlci5wcmVwYXJlfSBpcyBjYWxsZWQgYWNjb3JkaW5nIHRvIHtAbGluayBCT0RZX0lOSVR9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbml0aWFsaXphdGlvbjogQk9EWV9JTklUID0gQk9EWV9JTklULlRPX1BJVk9UO1xyXG4gICAgLyoqIE1hcmtzIGlmIGNvbGxpZGVyIHdhcyBpbml0aWFsaXplZC4gUmVzZXQgdG8gZmFsc2UgdG8gaW5pdGlhbGl6ZSBhZ2FpbiBlLmcuIGFmdGVyIG1hbmlwdWxhdGlvbiBvZiBtdHhQaXZvdCAqL1xyXG4gICAgcHVibGljIGlzSW5pdGlhbGl6ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKiogSUQgdG8gcmVmZXJlbmNlIHRoaXMgc3BlY2lmaWMgQ29tcG9uZW50UmlnaWRib2R5ICovXHJcbiAgICAjaWQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgLy9Qcml2YXRlIGluZm9ybWF0aW9ucyAtIE1vc3RseSBPaW1vUGh5c2ljcyB2YXJpYWJsZXMgdGhhdCBzaG91bGQgbm90IGJlIGV4cG9zZWQgdG8gdGhlIEZVREdFIFVzZXIgYW5kIG1hbmlwdWxhdGVkIGJ5IHRoZW1cclxuICAgICNjb2xsaWRlcjogT0lNTy5TaGFwZTtcclxuICAgICNjb2xsaWRlckluZm86IE9JTU8uU2hhcGVDb25maWc7XHJcbiAgICAjY29sbGlzaW9uR3JvdXA6IENPTExJU0lPTl9HUk9VUCA9IENPTExJU0lPTl9HUk9VUC5ERUZBVUxUO1xyXG4gICAgI3R5cGVDb2xsaWRlcjogQ09MTElERVJfVFlQRSA9IENPTExJREVSX1RZUEUuQ1VCRTtcclxuXHJcbiAgICAjcmlnaWRib2R5OiBPSU1PLlJpZ2lkQm9keTtcclxuICAgICNyaWdpZGJvZHlJbmZvOiBPSU1PLlJpZ2lkQm9keUNvbmZpZyA9IG5ldyBPSU1PLlJpZ2lkQm9keUNvbmZpZygpO1xyXG4gICAgI3R5cGVCb2R5OiBCT0RZX1RZUEUgPSBCT0RZX1RZUEUuRFlOQU1JQztcclxuXHJcbiAgICAjbWFzc0RhdGE6IE9JTU8uTWFzc0RhdGEgPSBuZXcgT0lNTy5NYXNzRGF0YSgpO1xyXG4gICAgI3Jlc3RpdHV0aW9uOiBudW1iZXI7XHJcbiAgICAjZnJpY3Rpb246IG51bWJlcjtcclxuICAgICNkYW1waW5nTGluZWFyOiBudW1iZXIgPSAwLjE7XHJcbiAgICAjZGFtcGluZ0FuZ3VsYXI6IG51bWJlciA9IDAuMTtcclxuICAgICNlZmZlY3RSb3RhdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuT05FKCk7XHJcbiAgICAjZWZmZWN0R3Jhdml0eTogbnVtYmVyID0gMTtcclxuICAgICNpc1RyaWdnZXI6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICNtdHhQaXZvdFVuc2NhbGVkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgICNtdHhQaXZvdEludmVyc2U6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG5cclxuICAgICNjYWxsYmFja3M6IE9JTU8uQ29udGFjdENhbGxiYWNrOyAvL0NhbGxiYWNrIE1ldGhvZHMgd2hlbiB3aXRoaW4gdGhlIG9pbW9TeXN0ZW0gYSBldmVudCBpcyBoYXBwZW5pbmdcclxuXHJcbiAgICAvLyAjcGh5c2ljczogUGh5c2ljczsgLy9UT0RPOiBrZWVwIGEgcG9pbnRlciB0byB0aGUgcGh5c2ljcyBpbnN0YW5jZSB1c2VkIGJ5IHRoaXMgY29tcG9uZW50XHJcblxyXG4gICAgLyoqIENyZWF0aW5nIGEgbmV3IHJpZ2lkYm9keSB3aXRoIGEgd2VpZ2h0IGluIGtnLCBhIHBoeXNpY3MgdHlwZSAoZGVmYXVsdCA9IGR5bmFtaWMpLCBhIGNvbGxpZGVyIHR5cGUgd2hhdCBwaHlzaWNhbCBmb3JtIGhhcyB0aGUgY29sbGlkZXIsIHRvIHdoYXQgZ3JvdXAgZG9lcyBpdCBiZWxvbmcsIGlzIHRoZXJlIGEgdHJhbnNmb3JtIE1hdHJpeCB0aGF0IHNob3VsZCBiZSB1c2VkLCBhbmQgaXMgdGhlIGNvbGxpZGVyIGRlZmluZWQgYXMgYSBncm91cCBvZiBwb2ludHMgdGhhdCByZXByZXNlbnQgYSBjb252ZXggbWVzaC4gKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbWFzczogbnVtYmVyID0gMSwgX3R5cGU6IEJPRFlfVFlQRSA9IEJPRFlfVFlQRS5EWU5BTUlDLCBfY29sbGlkZXJUeXBlOiBDT0xMSURFUl9UWVBFID0gQ09MTElERVJfVFlQRS5DVUJFLCBfZ3JvdXA6IENPTExJU0lPTl9HUk9VUCA9IFBoeXNpY3Muc2V0dGluZ3MuZGVmYXVsdENvbGxpc2lvbkdyb3VwLCBfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQgPSBudWxsLCBfY29udmV4TWVzaDogRmxvYXQzMkFycmF5ID0gbnVsbCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmNyZWF0ZShfbWFzcywgX3R5cGUsIF9jb2xsaWRlclR5cGUsIF9ncm91cCwgX210eFRyYW5zZm9ybSwgX2NvbnZleE1lc2gpO1xyXG5cclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIHRoaXMuaG5kRXZlbnQpO1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgdGhpcy5obmRFdmVudCk7XHJcbiAgICAgIC8vIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5OT0RFX0RFU0VSSUFMSVpFRCwgdGhpcy5obmRFdmVudCk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gQWNjZXNzb3JzXHJcbiAgICBwdWJsaWMgZ2V0IGlkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNpZDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVXNlZCBmb3IgY2FsY3VsYXRpb24gb2YgdGhlIGdlb21ldHJpY2FsIHJlbGF0aW9uc2hpcCBvZiBub2RlIGFuZCBjb2xsaWRlciBieSB7QGxpbmsgUmVuZGVyfSovXHJcbiAgICBwdWJsaWMgZ2V0IG10eFBpdm90SW52ZXJzZSgpOiBNYXRyaXg0eDQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbXR4UGl2b3RJbnZlcnNlO1xyXG4gICAgfVxyXG4gICAgLyoqIFVzZWQgZm9yIGNhbGN1bGF0aW9uIG9mIHRoZSBnZW9tZXRyaWNhbCByZWxhdGlvbnNoaXAgb2Ygbm9kZSBhbmQgY29sbGlkZXIgYnkge0BsaW5rIFJlbmRlcn0qL1xyXG4gICAgcHVibGljIGdldCBtdHhQaXZvdFVuc2NhbGVkKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtdHhQaXZvdFVuc2NhbGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXRyaWV2ZSB0aGUgYm9keSB0eXBlLiBTZWUge0BsaW5rIEJPRFlfVFlQRX0gKi9cclxuICAgIHB1YmxpYyBnZXQgdHlwZUJvZHkoKTogQk9EWV9UWVBFIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3R5cGVCb2R5O1xyXG4gICAgfVxyXG4gICAgLyoqIFNldCB0aGUgYm9keSB0eXBlLiBTZWUge0BsaW5rIEJPRFlfVFlQRX0gKi9cclxuICAgIHB1YmxpYyBzZXQgdHlwZUJvZHkoX3ZhbHVlOiBCT0RZX1RZUEUpIHtcclxuICAgICAgdGhpcy4jdHlwZUJvZHkgPSBfdmFsdWU7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRUeXBlKENvbXBvbmVudFJpZ2lkYm9keS5tYXBCb2R5VHlwZVt0aGlzLiN0eXBlQm9keV0pO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0TWFzc0RhdGEodGhpcy4jbWFzc0RhdGEpOyAvL2hhdmUgdG8gcmVzZXQgbWFzcyBhZnRlciBjaGFuZ2luZyB0aGUgdHlwZSwgc2luY2UgT2ltbyBpcyBoYW5kbGluZyBtYXNzIGludGVybmFsbHkgd3Jvbmcgd2hlbiBzd2l0Y2hpbmcgdHlwZXNcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIHNoYXBlIHRoYXQgcmVwcmVzZW50cyB0aGUge0BsaW5rIE5vZGV9IGluIHRoZSBwaHlzaWNhbCB3b3JsZC4gRGVmYXVsdCBpcyBhIEN1YmUuICovXHJcbiAgICBwdWJsaWMgZ2V0IHR5cGVDb2xsaWRlcigpOiBDT0xMSURFUl9UWVBFIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3R5cGVDb2xsaWRlcjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgdHlwZUNvbGxpZGVyKF92YWx1ZTogQ09MTElERVJfVFlQRSkge1xyXG4gICAgICBpZiAoX3ZhbHVlICE9IHRoaXMuI3R5cGVDb2xsaWRlciAmJiB0aGlzLiNyaWdpZGJvZHkgIT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuI3R5cGVDb2xsaWRlciA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgY29sbGlzaW9uIGdyb3VwIHRoaXMge0BsaW5rIE5vZGV9IGJlbG9uZ3MgdG8gaXQncyB0aGUgZGVmYXVsdCBncm91cCBub3JtYWxseSB3aGljaCBtZWFucyBpdCBwaHlzaWNhbGx5IGNvbGxpZGVzIHdpdGggZXZlcnkgZ3JvdXAgYmVzaWRlcyB0cmlnZ2VyLiAqL1xyXG4gICAgcHVibGljIGdldCBjb2xsaXNpb25Hcm91cCgpOiBDT0xMSVNJT05fR1JPVVAge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY29sbGlzaW9uR3JvdXA7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGNvbGxpc2lvbkdyb3VwKF92YWx1ZTogQ09MTElTSU9OX0dST1VQKSB7XHJcbiAgICAgIHRoaXMuI2NvbGxpc2lvbkdyb3VwID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy4jcmlnaWRib2R5ICE9IG51bGwpXHJcbiAgICAgICAgdGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpLnNldENvbGxpc2lvbkdyb3VwKHRoaXMuI2NvbGxpc2lvbkdyb3VwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogTWFya2luZyB0aGUgQm9keSBhcyBhIHRyaWdnZXIgdGhlcmVmb3JlIG5vdCBpbmZsdWVuY2luZyB0aGUgY29sbGlzaW9uIHN5c3RlbSBidXQgb25seSBzZW5kaW5nIHRyaWdnZXJFdmVudHMgKi9cclxuICAgIHB1YmxpYyBnZXQgaXNUcmlnZ2VyKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jaXNUcmlnZ2VyO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBpc1RyaWdnZXIoX3ZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgIHRoaXMuI2lzVHJpZ2dlciA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuZ2V0T2ltb1JpZ2lkYm9keSgpICE9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmdldE9pbW9SaWdpZGJvZHkoKS5faXNUcmlnZ2VyID0gdGhpcy4jaXNUcmlnZ2VyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwaHlzaWNhbCB3ZWlnaHQgb2YgdGhlIHtAbGluayBOb2RlfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1hc3MoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JpZ2lkYm9keS5nZXRNYXNzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHRpbmcgdGhlIHBoeXNpY2FsIHdlaWdodCBvZiB0aGUge0BsaW5rIE5vZGV9IGluIGtnXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgbWFzcyhfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtYXNzRGF0YS5tYXNzID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5ub2RlICE9IG51bGwpXHJcbiAgICAgICAgaWYgKHRoaXMuI3JpZ2lkYm9keSAhPSBudWxsKVxyXG4gICAgICAgICAgdGhpcy4jcmlnaWRib2R5LnNldE1hc3NEYXRhKHRoaXMuI21hc3NEYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRHJhZyBvZiBsaW5lYXIgbW92ZW1lbnQuIEEgQm9keSBkb2VzIHNsb3cgZG93biBldmVuIG9uIGEgc3VyZmFjZSB3aXRob3V0IGZyaWN0aW9uLiAqL1xyXG4gICAgcHVibGljIGdldCBkYW1wVHJhbnNsYXRpb24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JpZ2lkYm9keS5nZXRMaW5lYXJEYW1waW5nKCk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGRhbXBUcmFuc2xhdGlvbihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNkYW1waW5nTGluZWFyID0gX3ZhbHVlO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0TGluZWFyRGFtcGluZyhfdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBEcmFnIG9mIHJvdGF0aW9uLiAqL1xyXG4gICAgcHVibGljIGdldCBkYW1wUm90YXRpb24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JpZ2lkYm9keS5nZXRBbmd1bGFyRGFtcGluZygpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBkYW1wUm90YXRpb24oX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jZGFtcGluZ0FuZ3VsYXIgPSBfdmFsdWU7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRBbmd1bGFyRGFtcGluZyhfdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgZmFjdG9yIHRoaXMgcmlnaWRib2R5IHJlYWN0cyByb3RhdGlvbnMgdGhhdCBoYXBwZW4gaW4gdGhlIHBoeXNpY2FsIHdvcmxkLiAwIHRvIGxvY2sgcm90YXRpb24gdGhpcyBheGlzLiAqL1xyXG4gICAgcHVibGljIGdldCBlZmZlY3RSb3RhdGlvbigpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2VmZmVjdFJvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBlZmZlY3RSb3RhdGlvbihfZWZmZWN0OiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuI2VmZmVjdFJvdGF0aW9uID0gX2VmZmVjdDtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldFJvdGF0aW9uRmFjdG9yKG5ldyBPSU1PLlZlYzModGhpcy4jZWZmZWN0Um90YXRpb24ueCwgdGhpcy4jZWZmZWN0Um90YXRpb24ueSwgdGhpcy4jZWZmZWN0Um90YXRpb24ueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgZmFjdG9yIHRoaXMgcmlnaWRib2R5IHJlYWN0cyB0byB3b3JsZCBncmF2aXR5LiBEZWZhdWx0ID0gMSBlLmcuIDEqOS44MSBtL3MuICovXHJcbiAgICBwdWJsaWMgZ2V0IGVmZmVjdEdyYXZpdHkoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2VmZmVjdEdyYXZpdHk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGVmZmVjdEdyYXZpdHkoX2VmZmVjdDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI2VmZmVjdEdyYXZpdHkgPSBfZWZmZWN0O1xyXG4gICAgICBpZiAodGhpcy4jcmlnaWRib2R5ICE9IG51bGwpIHRoaXMuI3JpZ2lkYm9keS5zZXRHcmF2aXR5U2NhbGUodGhpcy4jZWZmZWN0R3Jhdml0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGZyaWN0aW9uIG9mIHRoZSByaWdpZGJvZHksIHdoaWNoIGlzIHRoZSBmYWN0b3Igb2Ygc2xpZGluZyByZXNpc3RhbmNlIG9mIHRoaXMgcmlnaWRib2R5IG9uIHN1cmZhY2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgZnJpY3Rpb24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2ZyaWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBmcmljdGlvbiBvZiB0aGUgcmlnaWRib2R5LCB3aGljaCBpcyB0aGUgZmFjdG9yIG9mICBzbGlkaW5nIHJlc2lzdGFuY2Ugb2YgdGhpcyByaWdpZGJvZHkgb24gc3VyZmFjZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBmcmljdGlvbihfZnJpY3Rpb246IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNmcmljdGlvbiA9IF9mcmljdGlvbjtcclxuICAgICAgaWYgKHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKSAhPSBudWxsKVxyXG4gICAgICAgIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5zZXRGcmljdGlvbih0aGlzLiNmcmljdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHJlc3RpdHV0aW9uIG9mIHRoZSByaWdpZGJvZHksIHdoaWNoIGlzIHRoZSBmYWN0b3Igb2YgYm91bmNpbmVzcyBvZiB0aGlzIHJpZ2lkYm9keSBvbiBzdXJmYWNlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHJlc3RpdHV0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyZXN0aXR1dGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcmVzdGl0dXRpb24gb2YgdGhlIHJpZ2lkYm9keSwgd2hpY2ggaXMgdGhlIGZhY3RvciBvZiBib3VuY2luZXNzIG9mIHRoaXMgcmlnaWRib2R5IG9uIHN1cmZhY2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgcmVzdGl0dXRpb24oX3Jlc3RpdHV0aW9uOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jcmVzdGl0dXRpb24gPSBfcmVzdGl0dXRpb247XHJcbiAgICAgIGlmICh0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkgIT0gbnVsbClcclxuICAgICAgICB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkuc2V0UmVzdGl0dXRpb24odGhpcy4jcmVzdGl0dXRpb24pO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmb3JtYXRpb25cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmlnaWRib2R5IGluIHRoZSBmb3JtIHRoZSBwaHlzaWNzIGVuZ2luZSBpcyB1c2luZyBpdCwgc2hvdWxkIG5vdCBiZSB1c2VkIHVubGVzcyBhIGZ1bmN0aW9uYWxpdHlcclxuICAgICAqIGlzIG5vdCBwcm92aWRlZCB0aHJvdWdoIHRoZSBGVURHRSBJbnRlZ3JhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE9pbW9SaWdpZGJvZHkoKTogT0lNTy5SaWdpZEJvZHkge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcmlnaWRib2R5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSb3RhdGluZyB0aGUgcmlnaWRib2R5IHRoZXJlZm9yZSBjaGFuZ2luZyBpdCdzIHJvdGF0aW9uIG92ZXIgdGltZSBkaXJlY3RseSBpbiBwaHlzaWNzLiBUaGlzIHdheSBwaHlzaWNzIGlzIGNoYW5naW5nIGluc3RlYWQgb2YgdHJhbnNmb3JtLiBcclxuICAgICAqICBCdXQgeW91IGFyZSBhYmxlIHRvIGluY3JlbWVudGFsIGNoYW5naW5nIGl0IGluc3RlYWQgb2YgYSBkaXJlY3Qgcm90YXRpb24uICBBbHRob3VnaCBpdCdzIGFsd2F5cyBwcmVmZXJlZCB0byB1c2UgZm9yY2VzIGluIHBoeXNpY3MuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGVCb2R5KF9yb3RhdGlvbkNoYW5nZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkucm90YXRlWHl6KG5ldyBPSU1PLlZlYzMoX3JvdGF0aW9uQ2hhbmdlLnggKiBDYWxjLmRlZzJyYWQsIF9yb3RhdGlvbkNoYW5nZS55ICogQ2FsYy5kZWcycmFkLCBfcm90YXRpb25DaGFuZ2UueiAqIENhbGMuZGVnMnJhZCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUcmFuc2xhdGluZyB0aGUgcmlnaWRib2R5IHRoZXJlZm9yZSBjaGFuZ2luZyBpdCdzIHBsYWNlIG92ZXIgdGltZSBkaXJlY3RseSBpbiBwaHlzaWNzLiBUaGlzIHdheSBwaHlzaWNzIGlzIGNoYW5naW5nIGluc3RlYWQgb2YgdHJhbnNmb3JtLiBcclxuICAgICAqICBCdXQgeW91IGFyZSBhYmxlIHRvIGluY3JlbWVudGFsbHkgY2hhbmdpbmcgaXQgaW5zdGVhZCBvZiBhIGRpcmVjdCBwb3NpdGlvbi4gQWx0aG91Z2ggaXQncyBhbHdheXMgcHJlZmVyZWQgdG8gdXNlIGZvcmNlcyBpbiBwaHlzaWNzLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZUJvZHkoX3RyYW5zbGF0aW9uQ2hhbmdlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS50cmFuc2xhdGUobmV3IE9JTU8uVmVjMyhfdHJhbnNsYXRpb25DaGFuZ2UueCwgX3RyYW5zbGF0aW9uQ2hhbmdlLnksIF90cmFuc2xhdGlvbkNoYW5nZS56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgUE9TSVRJT04gb2YgdGhlIHtAbGluayBOb2RlfSBpbiB0aGUgcGh5c2ljYWwgc3BhY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFBvc2l0aW9uKCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdG1wUG9zOiBPSU1PLlZlYzMgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0UG9zaXRpb24oKTtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRtcFBvcy54LCB0bXBQb3MueSwgdG1wUG9zLnopO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBQT1NJVElPTiBvZiB0aGUge0BsaW5rIE5vZGV9IGluIHRoZSBwaHlzaWNhbCBzcGFjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UG9zaXRpb24oX3ZhbHVlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRQb3NpdGlvbihuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY3VycmVudCBST1RBVElPTiBvZiB0aGUge0BsaW5rIE5vZGV9IGluIHRoZSBwaHlzaWNhbCBzcGFjZS4gTm90ZSB0aGlzIHJhbmdlIGZyb20gLXBpIHRvIHBpLCBzbyAtOTAgdG8gOTAuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRSb3RhdGlvbigpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IG9yaWVudGF0aW9uOiBPSU1PLlF1YXQgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0T3JpZW50YXRpb24oKTtcclxuICAgICAgbGV0IHRtcFF1YXQ6IFF1YXRlcm5pb24gPSBSZWN5Y2xlci5nZXQoUXVhdGVybmlvbik7XHJcbiAgICAgIHRtcFF1YXQuc2V0KG9yaWVudGF0aW9uLngsIG9yaWVudGF0aW9uLnksIG9yaWVudGF0aW9uLnosIG9yaWVudGF0aW9uLncpO1xyXG4gICAgICBsZXQgZXVsZXJBbmdsZXM6IFZlY3RvcjMgPSB0bXBRdWF0LmV1bGVyQW5nbGVzLmNsb25lO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh0bXBRdWF0KTtcclxuICAgICAgcmV0dXJuIGV1bGVyQW5nbGVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBST1RBVElPTiBvZiB0aGUge0BsaW5rIE5vZGV9IGluIHRoZSBwaHlzaWNhbCBzcGFjZSwgaW4gZGVncmVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0Um90YXRpb24oX3ZhbHVlOiBWZWN0b3IzIHwgUXVhdGVybmlvbik6IHZvaWQge1xyXG4gICAgICBsZXQgcXVhdGVybmlvbjogUXVhdGVybmlvbiA9IF92YWx1ZSBpbnN0YW5jZW9mIFZlY3RvcjMgPyBRdWF0ZXJuaW9uLlJPVEFUSU9OKF92YWx1ZSkgOiBfdmFsdWU7XHJcbiAgICAgIGxldCBxdWF0OiBPSU1PLlF1YXQgPSBuZXcgT0lNTy5RdWF0KHF1YXRlcm5pb24ueCwgcXVhdGVybmlvbi55LCBxdWF0ZXJuaW9uLnosIHF1YXRlcm5pb24udyk7XHJcbiAgICAgIGlmIChfdmFsdWUgaW5zdGFuY2VvZiBWZWN0b3IzKVxyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKHF1YXRlcm5pb24pO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0T3JpZW50YXRpb24ocXVhdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldCB0aGUgY3VycmVudCBTQ0FMSU5HIGluIHRoZSBwaHlzaWNhbCBzcGFjZS4gKi9cclxuICAgIHB1YmxpYyBnZXRTY2FsaW5nKCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IHRoaXMubm9kZS5tdHhXb3JsZC5zY2FsaW5nLmNsb25lO1xyXG4gICAgICBzY2FsaW5nLnggKj0gdGhpcy5tdHhQaXZvdC5zY2FsaW5nLng7XHJcbiAgICAgIHNjYWxpbmcueSAqPSB0aGlzLm10eFBpdm90LnNjYWxpbmcueTtcclxuICAgICAgc2NhbGluZy56ICo9IHRoaXMubXR4UGl2b3Quc2NhbGluZy56O1xyXG4gICAgICByZXR1cm4gc2NhbGluZztcclxuICAgIH1cclxuXHJcbiAgICAvKiogU2NhbGluZyByZXF1aXJlcyB0aGUgY29sbGlkZXIgdG8gYmUgY29tcGxldGVseSByZWNyZWF0ZWQgYW5ldyAqL1xyXG4gICAgcHVibGljIHNldFNjYWxpbmcoX3ZhbHVlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIC8vIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gX3ZhbHVlLmNsb25lOyAgIFxyXG4gICAgICB0aGlzLmNyZWF0ZUNvbGxpZGVyKG5ldyBPSU1PLlZlYzMoX3ZhbHVlLnggLyAyLCBfdmFsdWUueSAvIDIsIF92YWx1ZS56IC8gMiksIHRoaXMuI3R5cGVDb2xsaWRlcik7IC8vcmVjcmVhdGUgdGhlIGNvbGxpZGVyXHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyID0gbmV3IE9JTU8uU2hhcGUodGhpcy4jY29sbGlkZXJJbmZvKTtcclxuICAgICAgbGV0IG9sZENvbGxpZGVyOiBPSU1PLlNoYXBlID0gdGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYWRkU2hhcGUodGhpcy4jY29sbGlkZXIpOyAvL2FkZCBuZXcgY29sbGlkZXIsIGJlZm9yZSByZW1vdmluZyB0aGUgb2xkLCBzbyB0aGUgcmIgaXMgbmV2ZXIgYWN0aXZlIHdpdGggMCBjb2xsaWRlcnNcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnJlbW92ZVNoYXBlKG9sZENvbGxpZGVyKTsgLy9yZW1vdmUgdGhlIG9sZCBjb2xsaWRlclxyXG4gICAgICB0aGlzLiNjb2xsaWRlci51c2VyRGF0YSA9IHRoaXM7IC8vcmVzZXQgdGhlIGV4dHJhIGluZm9ybWF0aW9uIHNvIHRoYXQgdGhpcyBjb2xsaWRlciBrbm93cyB0byB3aGljaCBGVURHRSBDb21wb25lbnQgaXQncyBjb25uZWN0ZWRcclxuICAgICAgdGhpcy4jY29sbGlkZXIuc2V0Q29sbGlzaW9uR3JvdXAodGhpcy5jb2xsaXNpb25Hcm91cCk7XHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyLnNldENvbGxpc2lvbk1hc2sodGhpcy5jb2xsaXNpb25NYXNrKTtcclxuXHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyLnNldFJlc3RpdHV0aW9uKHRoaXMuI3Jlc3RpdHV0aW9uKTtcclxuICAgICAgdGhpcy4jY29sbGlkZXIuc2V0RnJpY3Rpb24odGhpcy4jZnJpY3Rpb24pO1xyXG4gICAgICB0aGlzLiNjb2xsaWRlci5zZXRDb250YWN0Q2FsbGJhY2sodGhpcy4jY2FsbGJhY2tzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIHRoZSByaWdpZGJvZHkgYWNjb3JkaW5nIHRvIGl0cyBpbml0aWFsaXphdGlvbiBzZXR0aW5nIHRvIG1hdGNoIHRoZSBtZXNoLCB0aGUgbm9kZSBvciBpdHMgb3duIHBpdm90IG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW5pdGlhbGl6ZSgpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLm5vZGUpIC8vIGRlbGF5IGluaXRpYWxpemF0aW9uIHVudGlsIHRoaXMgcmlnaWRib2R5IGlzIGF0dGFjaGVkIHRvIGEgbm9kZVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgc3dpdGNoIChOdW1iZXIodGhpcy5pbml0aWFsaXphdGlvbikpIHtcclxuICAgICAgICBjYXNlIEJPRFlfSU5JVC5UT19OT0RFOlxyXG4gICAgICAgICAgdGhpcy5tdHhQaXZvdCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCT0RZX0lOSVQuVE9fTUVTSDpcclxuICAgICAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gdGhpcy5ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuICAgICAgICAgIGlmIChjbXBNZXNoKVxyXG4gICAgICAgICAgICB0aGlzLm10eFBpdm90ID0gY21wTWVzaC5tdHhQaXZvdC5jbG9uZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQk9EWV9JTklULlRPX1BJVk9UOlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUFJPRFVDVCh0aGlzLm5vZGUubXR4V29ybGQsIHRoaXMubXR4UGl2b3QpO1xyXG5cclxuICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IzID0gbXR4V29ybGQudHJhbnNsYXRpb247IC8vQWRkaW5nIHRoZSBvZmZzZXRzIGZyb20gdGhlIHBpdm90XHJcbiAgICAgIGxldCByb3RhdGlvbjogVmVjdG9yMyA9IG10eFdvcmxkLnJvdGF0aW9uO1xyXG4gICAgICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IG10eFdvcmxkLnNjYWxpbmc7XHJcbiAgICAgIC8vc2NhbGluZyByZXF1aXJlcyBjb2xsaWRlciB0byBiZSByZWNyZWF0ZWRcclxuICAgICAgdGhpcy5zZXRTY2FsaW5nKHNjYWxpbmcpO1xyXG5cclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldE1hc3NEYXRhKHRoaXMuI21hc3NEYXRhKTtcclxuICAgICAgdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbik7IC8vc2V0IHRoZSBhY3R1YWwgbmV3IHJvdGF0aW9uL3Bvc2l0aW9uIGZvciB0aGlzIFJiIGFnYWluIHNpbmNlIGl0J3Mgbm93IHVwZGF0ZWRcclxuICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbik7XHJcblxyXG4gICAgICBsZXQgc2NhbGluZ0ludmVyc2U6IFZlY3RvcjMgPSB0aGlzLm5vZGUubXR4V29ybGQuc2NhbGluZy5tYXAoX2kgPT4gMSAvIF9pKTtcclxuICAgICAgdGhpcy4jbXR4UGl2b3RVbnNjYWxlZCA9IE1hdHJpeDR4NC5DT01QT1NJVElPTih0aGlzLm10eFBpdm90LnRyYW5zbGF0aW9uLCB0aGlzLm10eFBpdm90LnJvdGF0aW9uLCBzY2FsaW5nSW52ZXJzZSk7XHJcbiAgICAgIHRoaXMuI210eFBpdm90SW52ZXJzZSA9IE1hdHJpeDR4NC5JTlZFUlNFKHRoaXMuI210eFBpdm90VW5zY2FsZWQpO1xyXG5cclxuICAgICAgdGhpcy5hZGRSaWdpZGJvZHlUb1dvcmxkKCk7XHJcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gVmVsb2NpdHkgYW5kIEZvcmNlc1xyXG4gICAgLyoqXHJcbiAgICAqIEdldCB0aGUgY3VycmVudCBWRUxPQ0lUWSBvZiB0aGUge0BsaW5rIE5vZGV9XHJcbiAgICAqL1xyXG4gICAgcHVibGljIGdldFZlbG9jaXR5KCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdmVsb2NpdHk6IE9JTU8uVmVjMyA9IHRoaXMuI3JpZ2lkYm9keS5nZXRMaW5lYXJWZWxvY2l0eSgpO1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjModmVsb2NpdHkueCwgdmVsb2NpdHkueSwgdmVsb2NpdHkueik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBWRUxPQ0lUWSBvZiB0aGUge0BsaW5rIE5vZGV9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRWZWxvY2l0eShfdmFsdWU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgbGV0IHZlbG9jaXR5OiBPSU1PLlZlYzMgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0TGluZWFyVmVsb2NpdHkodmVsb2NpdHkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjdXJyZW50IEFOR1VMQVIgLSBWRUxPQ0lUWSBvZiB0aGUge0BsaW5rIE5vZGV9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRBbmd1bGFyVmVsb2NpdHkoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB2ZWxvY2l0eTogT0lNTy5WZWMzID0gdGhpcy4jcmlnaWRib2R5LmdldEFuZ3VsYXJWZWxvY2l0eSgpO1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjModmVsb2NpdHkueCwgdmVsb2NpdHkueSwgdmVsb2NpdHkueik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBBTkdVTEFSIC0gVkVMT0NJVFkgb2YgdGhlIHtAbGluayBOb2RlfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0QW5ndWxhclZlbG9jaXR5KF92YWx1ZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICBsZXQgdmVsb2NpdHk6IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRBbmd1bGFyVmVsb2NpdHkodmVsb2NpdHkpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICogQXBwbGllcyBhIGNvbnRpbm91cyBGT1JDRSBhdCB0aGUgY2VudGVyIG9mIHRoZSBSSUdJREJPRFkgaW4gdGhlIHRocmVlIGRpbWVuc2lvbnMuIENvbnNpZGVyaW5nIHRoZSByaWdpZGJvZHkncyBNQVNTLlxyXG4gICAgKiBUaGUgZm9yY2UgaXMgbWVhc3VyZWQgaW4gbmV3dG9uLCAxa2cgbmVlZHMgYWJvdXQgMTAgTmV3dG9uIHRvIGZpZ2h0IGFnYWluc3QgZ3Jhdml0eS5cclxuICAgICovXHJcbiAgICBwdWJsaWMgYXBwbHlGb3JjZShfZm9yY2U6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFwcGx5Rm9yY2VUb0NlbnRlcihuZXcgT0lNTy5WZWMzKF9mb3JjZS54LCBfZm9yY2UueSwgX2ZvcmNlLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQXBwbGllcyBhIGNvbnRpbm91cyBGT1JDRSBhdCBhIHNwZWNpZmljIHBvaW50IGluIHRoZSB3b3JsZCB0byB0aGUgUklHSURCT0RZIGluIHRoZSB0aHJlZSBkaW1lbnNpb25zLiBDb25zaWRlcmluZyB0aGUgcmlnaWRib2R5J3MgTUFTU1xyXG4gICAgKi9cclxuICAgIHB1YmxpYyBhcHBseUZvcmNlQXRQb2ludChfZm9yY2U6IFZlY3RvcjMsIF93b3JsZFBvaW50OiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hcHBseUZvcmNlKG5ldyBPSU1PLlZlYzMoX2ZvcmNlLngsIF9mb3JjZS55LCBfZm9yY2UueiksIG5ldyBPSU1PLlZlYzMoX3dvcmxkUG9pbnQueCwgX3dvcmxkUG9pbnQueSwgX3dvcmxkUG9pbnQueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBcHBsaWVzIGEgY29udGlub3VzIFJPVEFUSU9OQUwgRk9SQ0UgKFRvcnF1ZSkgdG8gdGhlIFJJR0lEQk9EWSBpbiB0aGUgdGhyZWUgZGltZW5zaW9ucy4gQ29uc2lkZXJpbmcgdGhlIHJpZ2lkYm9keSdzIE1BU1NcclxuICAgICovXHJcbiAgICBwdWJsaWMgYXBwbHlUb3JxdWUoX3JvdGF0aW9uYWxGb3JjZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYXBwbHlUb3JxdWUobmV3IE9JTU8uVmVjMyhfcm90YXRpb25hbEZvcmNlLngsIF9yb3RhdGlvbmFsRm9yY2UueSwgX3JvdGF0aW9uYWxGb3JjZS56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFwcGxpZXMgYSBpbnN0YW50IEZPUkNFIGF0IGEgcG9pbnQvcmlnaWRib2R5Y2VudGVyIHRvIHRoZSBSSUdJREJPRFkgaW4gdGhlIHRocmVlIGRpbWVuc2lvbnMuIENvbnNpZGVyaW5nIHRoZSByaWdpZGJvZCdzIE1BU1NcclxuICAgICogSW5mbHVlbmNpbmcgdGhlIGFuZ3VsYXIgc3BlZWQgYW5kIHRoZSBsaW5lYXIgc3BlZWQuIFxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBhcHBseUltcHVsc2VBdFBvaW50KF9pbXB1bHNlOiBWZWN0b3IzLCBfd29ybGRQb2ludDogVmVjdG9yMyA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgX3dvcmxkUG9pbnQgPSBfd29ybGRQb2ludCAhPSBudWxsID8gX3dvcmxkUG9pbnQgOiB0aGlzLmdldFBvc2l0aW9uKCk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hcHBseUltcHVsc2UobmV3IE9JTU8uVmVjMyhfaW1wdWxzZS54LCBfaW1wdWxzZS55LCBfaW1wdWxzZS56KSwgbmV3IE9JTU8uVmVjMyhfd29ybGRQb2ludC54LCBfd29ybGRQb2ludC55LCBfd29ybGRQb2ludC56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFwcGxpZXMgYSBpbnN0YW50IEZPUkNFIHRvIHRoZSBSSUdJREJPRFkgaW4gdGhlIHRocmVlIGRpbWVuc2lvbnMuIENvbnNpZGVyaW5nIHRoZSByaWdpZGJvZHkncyBNQVNTXHJcbiAgICAqIE9ubHkgaW5mbHVlbmNpbmcgaXQncyBzcGVlZCBub3Qgcm90YXRpb24uXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5TGluZWFySW1wdWxzZShfaW1wdWxzZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYXBwbHlMaW5lYXJJbXB1bHNlKG5ldyBPSU1PLlZlYzMoX2ltcHVsc2UueCwgX2ltcHVsc2UueSwgX2ltcHVsc2UueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBhIGluc3RhbnQgUk9UQVRJT05BTC1GT1JDRSB0byB0aGUgUklHSURCT0RZIGluIHRoZSB0aHJlZSBkaW1lbnNpb25zLiBDb25zaWRlcmluZyB0aGUgcmlnaWRib2R5J3MgTUFTU1xyXG4gICAgICogT25seSBpbmZsdWVuY2luZyBpdCdzIHJvdGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXBwbHlBbmd1bGFySW1wdWxzZShfcm90YXRpb25hbEltcHVsc2U6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFwcGx5QW5ndWxhckltcHVsc2UobmV3IE9JTU8uVmVjMyhfcm90YXRpb25hbEltcHVsc2UueCwgX3JvdGF0aW9uYWxJbXB1bHNlLnksIF9yb3RhdGlvbmFsSW1wdWxzZS56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2luZyB0aGUgVkVMT0NJVFkgb2YgdGhlIFJJR0lEQk9EWS4gT25seSBpbmZsdWVuY2luZyB0aGUgbGluZWFyIHNwZWVkIG5vdCBhbmd1bGFyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRWZWxvY2l0eShfdmFsdWU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFkZExpbmVhclZlbG9jaXR5KG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdpbmcgdGhlIFZFTE9DSVRZIG9mIHRoZSBSSUdJREJPRFkuIE9ubHkgaW5mbHVlbmNpbmcgdGhlIGFuZ3VsYXIgc3BlZWQgbm90IHRoZSBsaW5lYXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZEFuZ3VsYXJWZWxvY2l0eShfdmFsdWU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFkZEFuZ3VsYXJWZWxvY2l0eShuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlLSAvIEFjdGl2YXRlIHRoZSByaWdpZGJvZGllcyBhdXRvLXNsZWVwaW5nIGZ1bmN0aW9uLlxyXG4gICAgICogSWYgYWN0aXZhdGVkIHRoZSByaWdpZGJvZHkgd2lsbCBhdXRvbWF0aWNhbGx5IHNsZWVwIHdoZW4gbmVlZGVkLCBpbmNyZWFzaW5nIHBlcmZvcm1hbmNlLlxyXG4gICAgICogSWYgZGVhY3RpdmF0ZWQgdGhlIHJpZ2lkYm9keSBnZXRzIHN0b3BwZWQgZnJvbSBzbGVlcGluZyB3aGVuIG1vdmVtZW50IGlzIHRvbyBtaW5pbWFsLiBEZWNyZWFzaW5nIHBlcmZvcm1hbmNlLCBmb3IgcmFyZWx5IG1vcmUgcHJlY2lzZSBwaHlzaWNzIHJlc3VsdHMgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhY3RpdmF0ZUF1dG9TbGVlcChfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldEF1dG9TbGVlcChfb24pO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIENvbGxpc2lvblxyXG4gICAgLy8gLyoqXHJcbiAgICAvLyAgKiBDaGVja2luZyBmb3IgQ29sbGlzaW9uIHdpdGggb3RoZXIgQ29sbGlkZXJzIGFuZCBkaXNwYXRjaGVzIGEgY3VzdG9tIGV2ZW50IHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbGxpZGVyLlxyXG4gICAgLy8gICogQXV0b21hdGljYWxseSBjYWxsZWQgaW4gdGhlIFJlbmRlck1hbmFnZXIsIG5vIGludGVyYWN0aW9uIG5lZWRlZC5cclxuICAgIC8vICAqL1xyXG4gICAgLy8gcHVibGljIGNoZWNrQ29sbGlzaW9uRXZlbnRzKCk6IHZvaWQge1xyXG4gICAgLy8gICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgLy8gY2hlY2sgY29sbGlzaW9ucyBvbmx5IGlmIGluaXRpYWxpemF0aW9uIGNvbXBsZXRlZFxyXG4gICAgLy8gICAgIHJldHVybjtcclxuXHJcbiAgICAvLyAgIGxldCBjb250YWN0TGluazogT0lNTy5Db250YWN0TGluayA9IHRoaXMuI3JpZ2lkYm9keS5nZXRDb250YWN0TGlua0xpc3QoKTsgLy8gYWxsIHBoeXNpY2FsIGNvbnRhY3RzIGJldHdlZW4gY29sbGlkaW5nIGJvZGllcyBvbiB0aGlzIHJiXHJcbiAgICAvLyAgIHdoaWxlIChjb250YWN0TGluayAhPSBudWxsKSB7XHJcbiAgICAvLyAgICAgbGV0IG90aGVyOiBDb21wb25lbnRSaWdpZGJvZHkgPSBjb250YWN0TGluay5nZXRPdGhlcigpLnVzZXJEYXRhOyAvLyBnZXQgdGhlIG90aGVyIGNvbXBvbmVudCByaWdpZGJvZHkgaW52b2x2ZWQgaW4gdGhlIGNvbGxpc2lvblxyXG4gICAgLy8gICAgIGlmICghb3RoZXIuaXNJbml0aWFsaXplZCkge1xyXG4gICAgLy8gICAgICAgY29udGFjdExpbmsgPSBjb250YWN0TGluay5nZXROZXh0KCk7XHJcbiAgICAvLyAgICAgICBjb250aW51ZTtcclxuICAgIC8vICAgICB9XHJcblxyXG4gICAgLy8gICAgIGxldCBjb250YWN0OiBPSU1PLkNvbnRhY3QgPSBjb250YWN0TGluay5nZXRDb250YWN0KCk7XHJcbiAgICAvLyAgICAgbGV0IHdhc1RvdWNoaW5nOiBib29sZWFuID0gdGhpcy5jb2xsaXNpb25zLmluY2x1ZGVzKG90aGVyKTtcclxuICAgIC8vICAgICBsZXQgaXNUb3VjaGluZzogYm9vbGVhbiA9IGNvbnRhY3QuaXNUb3VjaGluZygpO1xyXG5cclxuICAgIC8vICAgICBpZiAoIXdhc1RvdWNoaW5nICYmIGlzVG91Y2hpbmcpIHsgLy8gRU5URVJcclxuICAgIC8vICAgICAgIGxldCBtYW5pZm9sZDogT0lNTy5NYW5pZm9sZCA9IGNvbnRhY3QuZ2V0TWFuaWZvbGQoKTtcclxuICAgIC8vICAgICAgIGxldCBwb2ludHM6IE9JTU8uTWFuaWZvbGRQb2ludFtdID0gbWFuaWZvbGQuZ2V0UG9pbnRzKCk7IC8vIEFsbCBwb2ludHMgaW4gdGhlIGNvbGxpc2lvbiB3aGVyZSB0aGUgdHdvIGJvZGllcyBhcmUgdG91Y2hpbmcsIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBmdWxsIGltcGFjdFxyXG4gICAgLy8gICAgICAgbGV0IG5vcm1hbEltcHVsc2U6IG51bWJlciA9IDA7XHJcbiAgICAvLyAgICAgICBsZXQgYmlub3JtYWxJbXB1bHNlOiBudW1iZXIgPSAwO1xyXG4gICAgLy8gICAgICAgbGV0IHRhbmdlbnRJbXB1bHNlOiBudW1iZXIgPSAwO1xyXG4gICAgLy8gICAgICAgZm9yIChsZXQgbWFuaWZvbGRQb2ludCBvZiBwb2ludHMpIHsgLy8gVGhlIGltcGFjdCBvZiB0aGUgY29sbGlzaW9uIGludm9sdmluZyBhbGwgdG91Y2hpbmcgcG9pbnRzXHJcbiAgICAvLyAgICAgICAgIG5vcm1hbEltcHVsc2UgKz0gbWFuaWZvbGRQb2ludC5nZXROb3JtYWxJbXB1bHNlKCk7XHJcbiAgICAvLyAgICAgICAgIGJpbm9ybWFsSW1wdWxzZSArPSBtYW5pZm9sZFBvaW50LmdldEJpbm9ybWFsSW1wdWxzZSgpO1xyXG4gICAgLy8gICAgICAgICB0YW5nZW50SW1wdWxzZSArPSBtYW5pZm9sZFBvaW50LmdldFRhbmdlbnRJbXB1bHNlKCk7XHJcbiAgICAvLyAgICAgICB9XHJcbiAgICAvLyAgICAgICBsZXQgbm9ybWFsOiBPSU1PLlZlYzMgPSBtYW5pZm9sZC5nZXROb3JtYWwoKTtcclxuICAgIC8vICAgICAgIGxldCBjb2xsaXNpb25Ob3JtYWw6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMyhub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KTtcclxuICAgIC8vICAgICAgIGxldCBjb2xsaXNpb25DZW50ZXJQb2ludDogVmVjdG9yMyA9IHRoaXMuY29sbGlzaW9uQ2VudGVyUG9pbnQocG9pbnRzLCBtYW5pZm9sZC5nZXROdW1Qb2ludHMoKSk7XHJcbiAgICAvLyAgICAgICB0aGlzLmNvbGxpc2lvbnMucHVzaChvdGhlcik7XHJcbiAgICAvLyAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLkNPTExJU0lPTl9FTlRFUiwgb3RoZXIsIG5vcm1hbEltcHVsc2UsIHRhbmdlbnRJbXB1bHNlLCBiaW5vcm1hbEltcHVsc2UsIGNvbGxpc2lvbkNlbnRlclBvaW50LCBjb2xsaXNpb25Ob3JtYWwpKTsgLy8gU2VuZGluZyB0aGUgZ2l2ZW4gZXZlbnRcclxuICAgIC8vICAgICB9IGVsc2UgaWYgKHdhc1RvdWNoaW5nICYmICFpc1RvdWNoaW5nKSB7IC8vIEVYSVRcclxuICAgIC8vICAgICAgIHRoaXMuY29sbGlzaW9ucy5zcGxpY2UodGhpcy5jb2xsaXNpb25zLmluZGV4T2Yob3RoZXIpLCAxKTtcclxuICAgIC8vICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnRQaHlzaWNzKEVWRU5UX1BIWVNJQ1MuQ09MTElTSU9OX0VYSVQsIG90aGVyLCAwLCAwLCAwKSk7XHJcbiAgICAvLyAgICAgfVxyXG5cclxuICAgIC8vICAgICBjb250YWN0TGluayA9IGNvbnRhY3RMaW5rLmdldE5leHQoKTsgLy8gU3RhcnQgdGhlIHNhbWUgcm91dGluZSB3aXRoIHRoZSBuZXh0IGNvbGxpc2lvbiBpbiB0aGUgbGlzdFxyXG4gICAgLy8gICB9XHJcbiAgICAvLyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyBhIHJheSB0aHJvdWdoIHRoaXMgc3BlY2lmaWMgYm9keSBpZ25vcmluZyB0aGUgcmVzdCBvZiB0aGUgd29ybGQgYW5kIGNoZWNrcyBpZiB0aGlzIGJvZHkgd2FzIGhpdCBieSB0aGUgcmF5LFxyXG4gICAgICogcmV0dXJuaW5nIGluZm8gYWJvdXQgdGhlIGhpdC4gUHJvdmlkZXMgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSBhbmQgaW5mb3JtYXRpb24gYSByZWd1bGFyIHJheWNhc3QgZG9lcyBidXQgdGhlIHJheSBpcyBvbmx5IHRlc3RpbmcgYWdhaW5zdCB0aGlzIHNwZWNpZmljIGJvZHkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByYXljYXN0VGhpc0JvZHkoX29yaWdpbjogVmVjdG9yMywgX2RpcmVjdGlvbjogVmVjdG9yMywgX2xlbmd0aDogbnVtYmVyLCBfZGVidWdEcmF3OiBib29sZWFuID0gZmFsc2UpOiBSYXlIaXRJbmZvIHtcclxuICAgICAgbGV0IGhpdEluZm86IFJheUhpdEluZm8gPSBuZXcgUmF5SGl0SW5mbygpO1xyXG4gICAgICBsZXQgZ2VvbWV0cnk6IE9JTU8uR2VvbWV0cnkgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkuZ2V0R2VvbWV0cnkoKTtcclxuICAgICAgbGV0IHRyYW5zZm9ybTogT0lNTy5UcmFuc2Zvcm0gPSB0aGlzLiNyaWdpZGJvZHkuZ2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgIGxldCBzY2FsZWREaXJlY3Rpb246IFZlY3RvcjMgPSBfZGlyZWN0aW9uLmNsb25lO1xyXG4gICAgICBzY2FsZWREaXJlY3Rpb24uc2NhbGUoX2xlbmd0aCk7XHJcbiAgICAgIGxldCBlbmRwb2ludDogVmVjdG9yMyA9IFZlY3RvcjMuU1VNKHNjYWxlZERpcmVjdGlvbiwgX29yaWdpbi5jbG9uZSk7XHJcbiAgICAgIGxldCBvaW1vUmF5OiBPSU1PLlJheUNhc3RIaXQgPSBuZXcgT0lNTy5SYXlDYXN0SGl0KCk7XHJcbiAgICAgIGxldCBoaXQ6IGJvb2xlYW4gPSBnZW9tZXRyeS5yYXlDYXN0KG5ldyBPSU1PLlZlYzMoX29yaWdpbi54LCBfb3JpZ2luLnksIF9vcmlnaW4ueiksIG5ldyBPSU1PLlZlYzMoZW5kcG9pbnQueCwgZW5kcG9pbnQueSwgZW5kcG9pbnQueiksIHRyYW5zZm9ybSwgb2ltb1JheSk7IC8vdGhlIGFjdHVhbCBPaW1vUGh5c2ljcyBSYXljYXN0XHJcbiAgICAgIGlmIChoaXQpIHsgIC8vSWYgaGl0IHJldHVybiBhIGJ1bmNoIG9mIGluZm9ybWF0aW9ucyBhYm91dCB0aGUgaGl0XHJcbiAgICAgICAgaGl0SW5mby5oaXQgPSB0cnVlO1xyXG4gICAgICAgIGhpdEluZm8uaGl0UG9pbnQgPSBuZXcgVmVjdG9yMyhvaW1vUmF5LnBvc2l0aW9uLngsIG9pbW9SYXkucG9zaXRpb24ueSwgb2ltb1JheS5wb3NpdGlvbi56KTtcclxuICAgICAgICBoaXRJbmZvLmhpdE5vcm1hbCA9IG5ldyBWZWN0b3IzKG9pbW9SYXkubm9ybWFsLngsIG9pbW9SYXkubm9ybWFsLnksIG9pbW9SYXkubm9ybWFsLnopO1xyXG4gICAgICAgIGxldCBkeDogbnVtYmVyID0gX29yaWdpbi54IC0gaGl0SW5mby5oaXRQb2ludC54OyAgLy9jYWxjdWxhdGUgaGl0IGRpc3RhbmNlXHJcbiAgICAgICAgbGV0IGR5OiBudW1iZXIgPSBfb3JpZ2luLnkgLSBoaXRJbmZvLmhpdFBvaW50Lnk7XHJcbiAgICAgICAgbGV0IGR6OiBudW1iZXIgPSBfb3JpZ2luLnogLSBoaXRJbmZvLmhpdFBvaW50Lno7XHJcbiAgICAgICAgaGl0SW5mby5oaXREaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopO1xyXG4gICAgICAgIGhpdEluZm8ucmlnaWRib2R5Q29tcG9uZW50ID0gdGhpcztcclxuICAgICAgICBoaXRJbmZvLnJheU9yaWdpbiA9IF9vcmlnaW47XHJcbiAgICAgICAgaGl0SW5mby5yYXlFbmQgPSBlbmRwb2ludDtcclxuICAgICAgfSBlbHNlIHsgLy9Pbmx5IHRlbGwgdGhlIG9yaWdpbiwgYW5kIHRoZSBoaXQgcG9pbnQgaXMgdGhlIGVuZCBvZiB0aGUgcmF5LlxyXG4gICAgICAgIGhpdEluZm8ucmF5T3JpZ2luID0gX29yaWdpbjtcclxuICAgICAgICBoaXRJbmZvLmhpdFBvaW50ID0gbmV3IFZlY3RvcjMoZW5kcG9pbnQueCwgZW5kcG9pbnQueSwgZW5kcG9pbnQueik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF9kZWJ1Z0RyYXcpIHtcclxuICAgICAgICBQaHlzaWNzLmRlYnVnRHJhdy5kZWJ1Z1JheShoaXRJbmZvLnJheU9yaWdpbiwgaGl0SW5mby5oaXRQb2ludCwgbmV3IENvbG9yKDAsIDEsIDAsIDEpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaGl0SW5mbztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gU2F2aW5nL0xvYWRpbmcgLSBTb21lIHByb3BlcnRpZXMgbWlnaHQgYmUgbWlzc2luZywgZS5nLiBjb252ZXhNZXNoIChGbG9hdDMyQXJyYXkpXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuZ2V0TXV0YXRvcigpO1xyXG5cclxuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb24ubXR4UGl2b3Q7XHJcbiAgICAgIGRlbGV0ZSBzZXJpYWxpemF0aW9uLmFjdGl2ZTtcclxuXHJcbiAgICAgIHNlcmlhbGl6YXRpb24udHlwZUJvZHkgPSBCT0RZX1RZUEVbdGhpcy4jdHlwZUJvZHldO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnR5cGVDb2xsaWRlciA9IENPTExJREVSX1RZUEVbdGhpcy4jdHlwZUNvbGxpZGVyXTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pbml0aWFsaXphdGlvbiA9IEJPRFlfSU5JVFt0aGlzLmluaXRpYWxpemF0aW9uXTtcclxuXHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaWQgPSB0aGlzLiNpZDtcclxuICAgICAgc2VyaWFsaXphdGlvbi5waXZvdCA9IHRoaXMubXR4UGl2b3Quc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICB0aGlzLm10eFBpdm90LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnBpdm90KTtcclxuICAgICAgdGhpcy4jaWQgPSBfc2VyaWFsaXphdGlvbi5pZDtcclxuICAgICAgdGhpcy5tYXNzID0gaWZOdW1iZXIoX3NlcmlhbGl6YXRpb24ubWFzcywgdGhpcy5tYXNzKTtcclxuICAgICAgdGhpcy5kYW1wVHJhbnNsYXRpb24gPSBpZk51bWJlcihfc2VyaWFsaXphdGlvbi5kYW1wVHJhbnNsYXRpb24sIHRoaXMuZGFtcFRyYW5zbGF0aW9uKTtcclxuICAgICAgdGhpcy5kYW1wUm90YXRpb24gPSBpZk51bWJlcihfc2VyaWFsaXphdGlvbi5kYW1wUm90YXRpb24sIHRoaXMuZGFtcFJvdGF0aW9uKTtcclxuICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IGlmTnVtYmVyKF9zZXJpYWxpemF0aW9uLmNvbGxpc2lvbkdyb3VwLCB0aGlzLmNvbGxpc2lvbkdyb3VwKTtcclxuICAgICAgdGhpcy5lZmZlY3RSb3RhdGlvbiA9IF9zZXJpYWxpemF0aW9uLmVmZmVjdFJvdGF0aW9uIHx8IHRoaXMuZWZmZWN0Um90YXRpb247XHJcbiAgICAgIHRoaXMuZWZmZWN0R3Jhdml0eSA9IGlmTnVtYmVyKF9zZXJpYWxpemF0aW9uLmVmZmVjdEdyYXZpdHksIHRoaXMuZWZmZWN0R3Jhdml0eSk7XHJcbiAgICAgIHRoaXMuZnJpY3Rpb24gPSBpZk51bWJlcihfc2VyaWFsaXphdGlvbi5mcmljdGlvbiwgdGhpcy5mcmljdGlvbik7XHJcbiAgICAgIHRoaXMucmVzdGl0dXRpb24gPSBpZk51bWJlcihfc2VyaWFsaXphdGlvbi5yZXN0aXR1dGlvbiwgdGhpcy5yZXN0aXR1dGlvbik7XHJcbiAgICAgIHRoaXMuaXNUcmlnZ2VyID0gX3NlcmlhbGl6YXRpb24uaXNUcmlnZ2VyIHx8IHRoaXMuaXNUcmlnZ2VyO1xyXG4gICAgICB0aGlzLmluaXRpYWxpemF0aW9uID0gX3NlcmlhbGl6YXRpb24uaW5pdGlhbGl6YXRpb247XHJcblxyXG4gICAgICB0aGlzLmluaXRpYWxpemF0aW9uID0gPG51bWJlcj48dW5rbm93bj5CT0RZX0lOSVRbX3NlcmlhbGl6YXRpb24uaW5pdGlhbGl6YXRpb25dO1xyXG4gICAgICB0aGlzLnR5cGVCb2R5ID0gPG51bWJlcj48dW5rbm93bj5CT0RZX1RZUEVbX3NlcmlhbGl6YXRpb24udHlwZUJvZHldO1xyXG4gICAgICB0aGlzLnR5cGVDb2xsaWRlciA9IDxudW1iZXI+PHVua25vd24+Q09MTElERVJfVFlQRVtfc2VyaWFsaXphdGlvbi50eXBlQ29sbGlkZXJdO1xyXG4gICAgICAvLyB0aGlzLmNyZWF0ZSh0aGlzLm1hc3MsIHRoaXMuI3R5cGVCb2R5LCB0aGlzLiN0eXBlQ29sbGlkZXIsIHRoaXMuY29sbGlzaW9uR3JvdXAsIG51bGwsIHRoaXMuY29udmV4TWVzaCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDaGFuZ2UgcHJvcGVydGllcyBieSBhbiBhc3NvY2lhdGl2ZSBhcnJheSAqL1xyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGlmIChfbXV0YXRvci50eXBlQm9keSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgX211dGF0b3IudHlwZUJvZHkgPSBwYXJzZUludChfbXV0YXRvci50eXBlQm9keSk7XHJcbiAgICAgIGlmIChfbXV0YXRvci50eXBlQ29sbGlkZXIgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIF9tdXRhdG9yLnR5cGVDb2xsaWRlciA9IHBhcnNlSW50KF9tdXRhdG9yLnR5cGVDb2xsaWRlcik7XHJcbiAgICAgIGlmIChfbXV0YXRvci5pbml0aWFsaXphdGlvbiAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgX211dGF0b3IuaW5pdGlhbGl6YXRpb24gPSBwYXJzZUludChfbXV0YXRvci5pbml0aWFsaXphdGlvbik7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgICAgaWYgKF9tdXRhdG9yLmluaXRpYWxpemF0aW9uICE9IHVuZGVmaW5lZCAmJiB0aGlzLmlzQWN0aXZlKVxyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAvLyBUT0RPOiBzZWUgaWYgdGhpcyBhbHRlcm5hdGl2ZSBzaG91bGQgYmUsIGF0IGxlYXN0IHBhcnRpYWxseSwgZG9uZSB3aXRoIG11dGF0ZVNlbGVjdGlvblxyXG4gICAgICAvLyBsZXQgY2FsbElmRXhpc3Q6IEZ1bmN0aW9uID0gKF9rZXk6IHN0cmluZywgX3NldHRlcjogRnVuY3Rpb24pID0+IHtcclxuICAgICAgLy8gICBpZiAoX211dGF0b3JbX2tleV0pXHJcbiAgICAgIC8vICAgICBfc2V0dGVyKF9tdXRhdG9yW19rZXldKTtcclxuICAgICAgLy8gfTtcclxuXHJcbiAgICAgIC8vIGNhbGxJZkV4aXN0KFwiZnJpY3Rpb25cIiwgKF92YWx1ZTogbnVtYmVyKSA9PiB0aGlzLmZyaWN0aW9uID0gX3ZhbHVlKTtcclxuICAgICAgLy8gY2FsbElmRXhpc3QoXCJyZXN0aXR1dGlvblwiLCAoX3ZhbHVlOiBudW1iZXIpID0+IHRoaXMucmVzdGl0dXRpb24gPSBfdmFsdWUpO1xyXG4gICAgICAvLyBjYWxsSWZFeGlzdChcIm1hc3NcIiwgKF92YWx1ZTogbnVtYmVyKSA9PiB0aGlzLm1hc3MgPSBfdmFsdWUpO1xyXG4gICAgICAvLyBjYWxsSWZFeGlzdChcImRhbXBUcmFuc2xhdGlvblwiLCAoX3ZhbHVlOiBudW1iZXIpID0+IHRoaXMuZGFtcFRyYW5zbGF0aW9uID0gX3ZhbHVlKTtcclxuICAgICAgLy8gY2FsbElmRXhpc3QoXCJkYW1wUm90YXRpb25cIiwgKF92YWx1ZTogbnVtYmVyKSA9PiB0aGlzLmRhbXBSb3RhdGlvbiA9IF92YWx1ZSk7XHJcbiAgICAgIC8vIGNhbGxJZkV4aXN0KFwiZWZmZWN0R3Jhdml0eVwiLCAoX3ZhbHVlOiBudW1iZXIpID0+IHRoaXMuZWZmZWN0R3Jhdml0eSA9IF92YWx1ZSk7XHJcbiAgICAgIC8vIGNhbGxJZkV4aXN0KFwiY29sbGlzaW9uR3JvdXBcIiwgKF92YWx1ZTogQ09MTElTSU9OX0dST1VQKSA9PiB0aGlzLmNvbGxpc2lvbkdyb3VwID0gX3ZhbHVlKTtcclxuICAgICAgLy8gY2FsbElmRXhpc3QoXCJ0eXBlQm9keVwiLCAoX3ZhbHVlOiBzdHJpbmcpID0+IHRoaXMudHlwZUJvZHkgPSBwYXJzZUludChfdmFsdWUpKTtcclxuICAgICAgLy8gY2FsbElmRXhpc3QoXCJ0eXBlQ29sbGlkZXJcIiwgKF92YWx1ZTogc3RyaW5nKSA9PiB0aGlzLnR5cGVDb2xsaWRlciA9IHBhcnNlSW50KF92YWx1ZSkpO1xyXG5cclxuICAgICAgLy8gdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5NVVRBVEUpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKHRydWUpO1xyXG5cclxuICAgICAgbXV0YXRvci5mcmljdGlvbiA9IHRoaXMuZnJpY3Rpb247XHJcbiAgICAgIG11dGF0b3IucmVzdGl0dXRpb24gPSB0aGlzLnJlc3RpdHV0aW9uO1xyXG4gICAgICBtdXRhdG9yLm1hc3MgPSB0aGlzLm1hc3M7XHJcbiAgICAgIG11dGF0b3IuZGFtcFRyYW5zbGF0aW9uID0gdGhpcy5kYW1wVHJhbnNsYXRpb247XHJcbiAgICAgIG11dGF0b3IuZGFtcFJvdGF0aW9uID0gdGhpcy5kYW1wUm90YXRpb247XHJcbiAgICAgIG11dGF0b3IuZWZmZWN0R3Jhdml0eSA9IHRoaXMuZWZmZWN0R3Jhdml0eTtcclxuICAgICAgbXV0YXRvci50eXBlQm9keSA9IHRoaXMuI3R5cGVCb2R5O1xyXG4gICAgICBtdXRhdG9yLnR5cGVDb2xsaWRlciA9IHRoaXMuI3R5cGVDb2xsaWRlcjtcclxuICAgICAgbXV0YXRvci5pc1RyaWdnZXIgPSB0aGlzLiNpc1RyaWdnZXI7XHJcblxyXG4gICAgICAvLyBPYmplY3QucHJldmVudEV4dGVuc2lvbnMobXV0YXRvcik7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHN1cGVyLmdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcik7XHJcbiAgICAgIGlmICh0eXBlcy50eXBlQm9keSlcclxuICAgICAgICB0eXBlcy50eXBlQm9keSA9IEJPRFlfVFlQRTtcclxuICAgICAgaWYgKHR5cGVzLnR5cGVDb2xsaWRlcilcclxuICAgICAgICB0eXBlcy50eXBlQ29sbGlkZXIgPSBDT0xMSURFUl9UWVBFO1xyXG4gICAgICBpZiAodHlwZXMuaW5pdGlhbGl6YXRpb24pXHJcbiAgICAgICAgdHlwZXMuaW5pdGlhbGl6YXRpb24gPSBCT0RZX0lOSVQ7XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmNvbnZleE1lc2g7IC8vQ29udmV4IE1lc2ggY2FuJ3QgYmUgc2hvd24gaW4gdGhlIGVkaXRvciBiZWNhdXNlIGZsb2F0MzJBcnJheSBpcyBub3QgYSB2aWFibGUgbXV0YXRvclxyXG4gICAgICBkZWxldGUgX211dGF0b3IuY29sbGlzaW9uTWFzaztcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLmlzSW5pdGlhbGl6ZWQ7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyBBY3RpdmF0ZSB0aGUgZnVuY3Rpb25zIG9mIHRoaXMgY29tcG9uZW50IGFzIHJlc3BvbnNlIHRvIGV2ZW50c1xyXG4gICAgcHJpdmF0ZSBobmRFdmVudCA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIHN3aXRjaCAoX2V2ZW50LnR5cGUpIHtcclxuICAgICAgICBjYXNlIEVWRU5ULkNPTVBPTkVOVF9BREQ6XHJcbiAgICAgICAgICAvLyB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FDVElWQVRFLCB0aGlzLmFkZFJpZ2lkYm9keVRvV29ybGQpO1xyXG4gICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9ERUFDVElWQVRFLCB0aGlzLnJlbW92ZVJpZ2lkYm9keUZyb21Xb3JsZCk7XHJcbiAgICAgICAgICAvLyB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5OT0RFX0FDVElWQVRFLCB0aGlzLmFkZFJpZ2lkYm9keVRvV29ybGQsIHRydWUpOyAvLyB1c2UgY2FwdHVyZSB0byByZWFjdCB0byBicm9hZGNhc3QhXHJcbiAgICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5OT0RFX0RFQUNUSVZBVEUsIHRoaXMuaG5kTm9kZURlYWN0aXZhdGUsIHRydWUpO1xyXG4gICAgICAgICAgaWYgKCF0aGlzLm5vZGUuY21wVHJhbnNmb3JtKVxyXG4gICAgICAgICAgICBEZWJ1Zy53YXJuKFwiQ29tcG9uZW50UmlnaWRib2R5IGF0dGFjaGVkIHRvIG5vZGUgbWlzc2luZyBDb21wb25lbnRUcmFuc2Zvcm1cIiwgdGhpcy5ub2RlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRVZFTlQuQ09NUE9ORU5UX1JFTU9WRTpcclxuICAgICAgICAgIC8vIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCB0aGlzLmFkZFJpZ2lkYm9keVRvV29ybGQpO1xyXG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9SRU1PVkUsIHRoaXMucmVtb3ZlUmlnaWRib2R5RnJvbVdvcmxkKTtcclxuICAgICAgICAgIC8vIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfQUNUSVZBVEUsIHRoaXMuYWRkUmlnaWRib2R5VG9Xb3JsZCwgdHJ1ZSk7IC8vIHVzZSBjYXB0dXJlIHRvIHJlYWN0IHRvIGJyb2FkY2FzdCFcclxuICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVBQ1RJVkFURSwgdGhpcy5obmROb2RlRGVhY3RpdmF0ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICB0aGlzLnJlbW92ZVJpZ2lkYm9keUZyb21Xb3JsZCgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFVkVOVC5OT0RFX0RFU0VSSUFMSVpFRDpcclxuICAgICAgICAgIGlmICghdGhpcy5ub2RlLmNtcFRyYW5zZm9ybSlcclxuICAgICAgICAgICAgRGVidWcuZXJyb3IoXCJDb21wb25lbnRSaWdpZGJvZHkgYXR0YWNoZWQgdG8gbm9kZSBtaXNzaW5nIENvbXBvbmVudFRyYW5zZm9ybVwiLCB0aGlzLm5vZGUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8jcmVnaW9uIENyZWF0aW9uXHJcbiAgICBwcml2YXRlIGNyZWF0ZShfbWFzczogbnVtYmVyID0gMSwgX3R5cGU6IEJPRFlfVFlQRSA9IEJPRFlfVFlQRS5EWU5BTUlDLCBfY29sbGlkZXJUeXBlOiBDT0xMSURFUl9UWVBFID0gQ09MTElERVJfVFlQRS5DVUJFLCBfZ3JvdXA6IENPTExJU0lPTl9HUk9VUCA9IFBoeXNpY3Muc2V0dGluZ3MuZGVmYXVsdENvbGxpc2lvbkdyb3VwLCBfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQgPSBudWxsLCBfY29udmV4TWVzaDogRmxvYXQzMkFycmF5ID0gbnVsbCk6IHZvaWQge1xyXG4gICAgICAvL1NldHRpbmcgdXAgYWxsIGluY29taW5nIHZhbHVlcyB0byBiZSBpbnRlcm5hbCB2YWx1ZXNcclxuICAgICAgdGhpcy5jb252ZXhNZXNoID0gX2NvbnZleE1lc2g7XHJcbiAgICAgIHRoaXMuI3R5cGVCb2R5ID0gX3R5cGU7XHJcbiAgICAgIHRoaXMuI2NvbGxpc2lvbkdyb3VwID0gX2dyb3VwO1xyXG4gICAgICB0aGlzLiN0eXBlQ29sbGlkZXIgPSBfY29sbGlkZXJUeXBlO1xyXG4gICAgICB0aGlzLm1hc3MgPSBfbWFzcztcclxuICAgICAgdGhpcy4jcmVzdGl0dXRpb24gPSBQaHlzaWNzLnNldHRpbmdzLmRlZmF1bHRSZXN0aXR1dGlvbjtcclxuICAgICAgdGhpcy4jZnJpY3Rpb24gPSBQaHlzaWNzLnNldHRpbmdzLmRlZmF1bHRGcmljdGlvbjtcclxuICAgICAgdGhpcy5jb2xsaXNpb25NYXNrID0gUGh5c2ljcy5zZXR0aW5ncy5kZWZhdWx0Q29sbGlzaW9uTWFzaztcclxuICAgICAgLy9DcmVhdGUgdGhlIGFjdHVhbCByaWdpZGJvZHkgaW4gdGhlIE9pbW9QaHlzaWNzIFNwYWNlXHJcbiAgICAgIHRoaXMuY3JlYXRlUmlnaWRib2R5KF9tYXNzLCBfdHlwZSwgdGhpcy4jdHlwZUNvbGxpZGVyLCBfbXR4VHJhbnNmb3JtLCB0aGlzLiNjb2xsaXNpb25Hcm91cCk7XHJcbiAgICAgIHRoaXMuI2lkID0gUGh5c2ljcy5kaXN0cmlidXRlQm9keUlEKCk7XHJcblxyXG4gICAgICAvLyBFdmVudCBDYWxsYmFja3MgZGlyZWN0bHkgZnJvbSBPSU1PIFBoeXNpY3NcclxuICAgICAgdGhpcy4jY2FsbGJhY2tzID0gbmV3IE9JTU8uQ29udGFjdENhbGxiYWNrKCk7IC8vZmVobVxyXG4gICAgICB0aGlzLiNjYWxsYmFja3MuYmVnaW5UcmlnZ2VyQ29udGFjdCA9IHRoaXMudHJpZ2dlckVudGVyO1xyXG4gICAgICB0aGlzLiNjYWxsYmFja3MuZW5kVHJpZ2dlckNvbnRhY3QgPSB0aGlzLnRyaWdnZXJFeGl0O1xyXG4gICAgICB0aGlzLiNjYWxsYmFja3MucG9zdFNvbHZlID0gdGhpcy5jb2xsaXNpb25FbnRlcjsgLy8gdXNlIHBvc3RTb2x2ZSBmb3IgY29sbGlzaW9uRW50ZXIgdG8gZ2V0IHRoZSBpbXB1bHNlXHJcbiAgICAgIHRoaXMuI2NhbGxiYWNrcy5lbmRDb250YWN0ID0gdGhpcy5jb2xsaXNpb25FeGl0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGVzIHRoZSBhY3R1YWwgT2ltb1BoeXNpY3MgUmlnaWRib2R5IG91dCBvZiBpbmZvcm1hdGlvbnMgdGhlIEZVREdFIENvbXBvbmVudCBoYXMuICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZVJpZ2lkYm9keShfbWFzczogbnVtYmVyLCBfdHlwZTogQk9EWV9UWVBFLCBfY29sbGlkZXJUeXBlOiBDT0xMSURFUl9UWVBFLCBfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQsIF9jb2xsaXNpb25Hcm91cDogQ09MTElTSU9OX0dST1VQID0gQ09MTElTSU9OX0dST1VQLkRFRkFVTFQpOiB2b2lkIHtcclxuICAgICAgbGV0IG9pbW9UeXBlOiBudW1iZXI7IC8vTmVlZCB0aGUgY29udmVyc2lvbiBmcm9tIHNpbXBsZSBlbnVtIHRvIG51bWJlciBiZWNhdXNlIGlmIGVudW0gaXMgZGVmaW5lZCBhcyBPaW1vLlJpZ2lkeUJvZHlUeXBlIHlvdSBoYXZlIHRvIGluY2x1ZGUgT2ltbyB0byB1c2UgRlVER0UgYXQgYWxsXHJcbiAgICAgIHN3aXRjaCAoX3R5cGUpIHtcclxuICAgICAgICBjYXNlIEJPRFlfVFlQRS5EWU5BTUlDOlxyXG4gICAgICAgICAgb2ltb1R5cGUgPSBPSU1PLlJpZ2lkQm9keVR5cGUuRFlOQU1JQztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQk9EWV9UWVBFLlNUQVRJQzpcclxuICAgICAgICAgIG9pbW9UeXBlID0gT0lNTy5SaWdpZEJvZHlUeXBlLlNUQVRJQztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQk9EWV9UWVBFLktJTkVNQVRJQzpcclxuICAgICAgICAgIG9pbW9UeXBlID0gT0lNTy5SaWdpZEJvZHlUeXBlLktJTkVNQVRJQztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBvaW1vVHlwZSA9IE9JTU8uUmlnaWRCb2R5VHlwZS5EWU5BTUlDO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHJlbW92ZSBhbGwgcHJldmlvdXMgc2hhcGVzIGZyb20gd29ybGQuIE5lY2Vzc2FyeT9cclxuICAgICAgLy8gd2hpbGUgKHRoaXMuI3JpZ2lkYm9keSAmJiB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkgIT0gbnVsbClcclxuICAgICAgLy8gICB0aGlzLiNyaWdpZGJvZHkucmVtb3ZlU2hhcGUodGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpKTtcclxuXHJcbiAgICAgIGxldCB0bXBUcmFuc2Zvcm06IE1hdHJpeDR4NCA9IF9tdHhUcmFuc2Zvcm0gPT0gbnVsbCA/IHN1cGVyLm5vZGUgIT0gbnVsbCA/IHN1cGVyLm5vZGUubXR4V29ybGQgOiBNYXRyaXg0eDQuSURFTlRJVFkoKSA6IF9tdHhUcmFuc2Zvcm07IC8vR2V0IHRyYW5zZm9ybSBpbmZvcm1hdGlvbnMgZnJvbSB0aGUgd29ybGQsIHNpbmNlIHBoeXNpY3MgZG9lcyBub3QgY2FyZSBhYm91dCBoaWVyYXJjaHlcclxuICAgICAgLy9Db252ZXJ0IGluZm9ybWF0aW9ucyBmcm9tIEZVREdFIHRvIE9pbW9QaHlzaWNzIGFuZCBjcmVhdGluZyBhIGNvbGxpZGVyIHdpdGggaXQsIHdoaWxlIGFsc28gYWRkaW5nIGEgcGl2b3QgdG8gZGVyaXZhdGUgZnJvbSB0aGUgdHJhbnNmb3JtIGluZm9ybWF0aW9ucyBpZiBuZWVkZWRcclxuICAgICAgbGV0IHNjYWxlOiBPSU1PLlZlYzMgPSBuZXcgT0lNTy5WZWMzKCh0bXBUcmFuc2Zvcm0uc2NhbGluZy54ICogdGhpcy5tdHhQaXZvdC5zY2FsaW5nLngpIC8gMiwgKHRtcFRyYW5zZm9ybS5zY2FsaW5nLnkgKiB0aGlzLm10eFBpdm90LnNjYWxpbmcueSkgLyAyLCAodG1wVHJhbnNmb3JtLnNjYWxpbmcueiAqIHRoaXMubXR4UGl2b3Quc2NhbGluZy56KSAvIDIpO1xyXG4gICAgICBsZXQgcG9zaXRpb246IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzModG1wVHJhbnNmb3JtLnRyYW5zbGF0aW9uLnggKyB0aGlzLm10eFBpdm90LnRyYW5zbGF0aW9uLngsIHRtcFRyYW5zZm9ybS50cmFuc2xhdGlvbi55ICsgdGhpcy5tdHhQaXZvdC50cmFuc2xhdGlvbi55LCB0bXBUcmFuc2Zvcm0udHJhbnNsYXRpb24ueiArIHRoaXMubXR4UGl2b3QudHJhbnNsYXRpb24ueik7XHJcbiAgICAgIGxldCByb3RhdGlvbjogT0lNTy5WZWMzID0gbmV3IE9JTU8uVmVjMyh0bXBUcmFuc2Zvcm0ucm90YXRpb24ueCArIHRoaXMubXR4UGl2b3Qucm90YXRpb24ueCwgdG1wVHJhbnNmb3JtLnJvdGF0aW9uLnkgKyB0aGlzLm10eFBpdm90LnJvdGF0aW9uLnksIHRtcFRyYW5zZm9ybS5yb3RhdGlvbi56ICsgdGhpcy5tdHhQaXZvdC5yb3RhdGlvbi56KTtcclxuICAgICAgdGhpcy5jcmVhdGVDb2xsaWRlcihzY2FsZSwgX2NvbGxpZGVyVHlwZSk7XHJcbiAgICAgIC8vU2V0dGluZyBpbmZvcm1hdGlvbnMgYWJvdXQgbWFzcywgcG9zaXRpb24vcm90YXRpb24gYW5kIHBoeXNpY2FsIHJlYWN0aW9uIHR5cGVcclxuICAgICAgdGhpcy4jbWFzc0RhdGEubWFzcyA9IF9tYXNzOyAvL190eXBlICE9IFBIWVNJQ1NfVFlQRS5TVEFUSUMgPyBfbWFzcyA6IDA7IC8vSWYgYSBvYmplY3QgaXMgc3RhdGljIGl0IGFjdHMgYXMgaWYgaXQgaGFzIG5vIG1hc3NcclxuICAgICAgdGhpcy4jcmlnaWRib2R5SW5mby50eXBlID0gb2ltb1R5cGU7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keUluZm8ucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5SW5mby5yb3RhdGlvbi5mcm9tRXVsZXJYeXoobmV3IE9JTU8uVmVjMyhyb3RhdGlvbi54LCByb3RhdGlvbi55LCByb3RhdGlvbi56KSk7IC8vQ29udmVydCBldWxlckFuZ2xlcyBpbiBkZWdyZWUgdG8gdGhlIGludGVybmFsbHkgdXNlZCBxdWF0ZXJuaW9uc1xyXG4gICAgICAvL0NyZWF0aW5nIHRoZSBhY3R1YWwgcmlnaWRib2R5IGFuZCBpdCdzIGNvbGxpZGVyXHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keSA9IG5ldyBPSU1PLlJpZ2lkQm9keSh0aGlzLiNyaWdpZGJvZHlJbmZvKTtcclxuICAgICAgdGhpcy4jY29sbGlkZXIgPSBuZXcgT0lNTy5TaGFwZSh0aGlzLiNjb2xsaWRlckluZm8pO1xyXG4gICAgICAvL0ZpbGxpbmcgdGhlIGFkZGl0aW9uYWwgc2V0dGluZ3MgYW5kIGluZm9ybWF0aW9ucyB0aGUgcmlnaWRib2R5IG5lZWRzLiBXaG8gaXMgY29sbGlkaW5nLCBob3cgaXMgdGhlIGNvbGxpc2lvbiBoYW5kbGVkIChkYW1waW5nLCBpbmZsdWVuY2UgZmFjdG9ycylcclxuICAgICAgdGhpcy4jY29sbGlkZXIudXNlckRhdGEgPSB0aGlzO1xyXG4gICAgICB0aGlzLiNjb2xsaWRlci5zZXRDb2xsaXNpb25Hcm91cChfY29sbGlzaW9uR3JvdXApO1xyXG4gICAgICB0aGlzLiNjb2xsaWRlci5zZXRDb2xsaXNpb25NYXNrKHRoaXMuY29sbGlzaW9uTWFzayk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hZGRTaGFwZSh0aGlzLiNjb2xsaWRlcik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRNYXNzRGF0YSh0aGlzLiNtYXNzRGF0YSk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5zZXRSZXN0aXR1dGlvbih0aGlzLiNyZXN0aXR1dGlvbik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5zZXRGcmljdGlvbih0aGlzLiNmcmljdGlvbik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5zZXRDb250YWN0Q2FsbGJhY2sodGhpcy4jY2FsbGJhY2tzKTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldExpbmVhckRhbXBpbmcodGhpcy4jZGFtcGluZ0xpbmVhcik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRBbmd1bGFyRGFtcGluZyh0aGlzLiNkYW1waW5nQW5ndWxhcik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRHcmF2aXR5U2NhbGUodGhpcy4jZWZmZWN0R3Jhdml0eSk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRSb3RhdGlvbkZhY3RvcihuZXcgT0lNTy5WZWMzKHRoaXMuI2VmZmVjdFJvdGF0aW9uLngsIHRoaXMuI2VmZmVjdFJvdGF0aW9uLnksIHRoaXMuI2VmZmVjdFJvdGF0aW9uLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ3JlYXRlcyBhIGNvbGxpZGVyIGEgc2hhcGUgdGhhdCByZXByZXNlbnRzIHRoZSBvYmplY3QgaW4gdGhlIHBoeXNpY2FsIHdvcmxkLiAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlQ29sbGlkZXIoX3NjYWxlOiBPSU1PLlZlYzMsIF9jb2xsaWRlclR5cGU6IENPTExJREVSX1RZUEUpOiB2b2lkIHtcclxuICAgICAgbGV0IHNoYXBlQ29uZjogT0lNTy5TaGFwZUNvbmZpZyA9IG5ldyBPSU1PLlNoYXBlQ29uZmlnKCk7IC8vQ29sbGlkZXIgd2l0aCBnZW9tZXRyeSBhbmQgaW5mb3MgbGlrZSBmcmljdGlvbi9yZXN0aXR1dGlvbiBhbmQgbW9yZVxyXG4gICAgICBsZXQgZ2VvbWV0cnk6IE9JTU8uR2VvbWV0cnk7XHJcbiAgICAgIGlmICh0aGlzLnR5cGVDb2xsaWRlciAhPSBfY29sbGlkZXJUeXBlKSAvL0lmIHRoZSBjb2xsaWRlciB0eXBlIHdhcyBjaGFuZ2VkIHNldCB0aGUgaW50ZXJuYWwgb25lIG5ldywgZWxzZSBkb24ndCBzbyB0aGVyZSBpcyBub3QgaW5maW5pdGUgc2V0IGNhbGxzXHJcbiAgICAgICAgdGhpcy50eXBlQ29sbGlkZXIgPSBfY29sbGlkZXJUeXBlO1xyXG4gICAgICBzd2l0Y2ggKF9jb2xsaWRlclR5cGUpIHsgIC8vQ3JlYXRlIGEgZGlmZmVyZW50IE9pbW9QaHlzaWNzIGdlb21ldHJ5IGJhc2VkIG9uIHRoZSBnaXZlbiB0eXBlLiBUaGF0IGlzIG9ubHkgdGhlIG1hdGhlbWF0aWNhbCBzaGFwZSBvZiB0aGUgY29sbGlkZXJcclxuICAgICAgICBjYXNlIENPTExJREVSX1RZUEUuQ1VCRTpcclxuICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IE9JTU8uQm94R2VvbWV0cnkoX3NjYWxlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ09MTElERVJfVFlQRS5TUEhFUkU6XHJcbiAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBPSU1PLlNwaGVyZUdlb21ldHJ5KF9zY2FsZS54KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ09MTElERVJfVFlQRS5DQVBTVUxFOlxyXG4gICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgT0lNTy5DYXBzdWxlR2VvbWV0cnkoX3NjYWxlLngsIF9zY2FsZS55KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQ09MTElERVJfVFlQRS5DWUxJTkRFUjpcclxuICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IE9JTU8uQ3lsaW5kZXJHZW9tZXRyeShfc2NhbGUueCwgX3NjYWxlLnkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT0xMSURFUl9UWVBFLkNPTkU6XHJcbiAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBPSU1PLkNvbmVHZW9tZXRyeShfc2NhbGUueCwgX3NjYWxlLnkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT0xMSURFUl9UWVBFLlBZUkFNSUQ6XHJcbiAgICAgICAgICBnZW9tZXRyeSA9IHRoaXMuY3JlYXRlQ29udmV4R2VvbWV0cnlDb2xsaWRlcih0aGlzLmNyZWF0ZVB5cmFtaWRWZXJ0aWNlcygpLCBfc2NhbGUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT0xMSURFUl9UWVBFLkNPTlZFWDpcclxuICAgICAgICAgIGdlb21ldHJ5ID0gdGhpcy5jcmVhdGVDb252ZXhHZW9tZXRyeUNvbGxpZGVyKHRoaXMuY29udmV4TWVzaCwgX3NjYWxlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHNoYXBlQ29uZi5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICB0aGlzLiNjb2xsaWRlckluZm8gPSBzaGFwZUNvbmY7IC8vdGhlIGNvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb25zIHRoYXQgYXJlIHVzZWQgdG8gYWRkIGFuIGFjdHVhbCBjb2xsaWRlciB0byB0aGUgcmlnaWRib2R5IGluIGNyZWF0ZVJpZ2lkYm9keVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGluZyBhIHNoYXBlIHRoYXQgcmVwcmVzZW50cyBhIGluIGl0c2VsZiBjbG9zZWQgZm9ybSwgb3V0IG9mIHRoZSBnaXZlbiB2ZXJ0aWNlcy4gKi9cclxuICAgIHByaXZhdGUgY3JlYXRlQ29udmV4R2VvbWV0cnlDb2xsaWRlcihfdmVydGljZXM6IEZsb2F0MzJBcnJheSwgX3NjYWxlOiBPSU1PLlZlYzMpOiBPSU1PLkNvbnZleEh1bGxHZW9tZXRyeSB7XHJcbiAgICAgIGxldCB2ZXJ0aWNlc0FzVmVjMzogT0lNTy5WZWMzW10gPSBuZXcgQXJyYXkoKTsgLy9Db252ZXJ0IEZVREdFIFZlY3RvcjMgdG8gT2ltb1ZlYzNcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF92ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMykgeyAvLzMgVmFsdWVzIGZvciBvbmUgcG9pbnRcclxuICAgICAgICB2ZXJ0aWNlc0FzVmVjMy5wdXNoKG5ldyBPSU1PLlZlYzMoX3ZlcnRpY2VzW2ldICogX3NjYWxlLngsIF92ZXJ0aWNlc1tpICsgMV0gKiBfc2NhbGUueSwgX3ZlcnRpY2VzW2kgKyAyXSAqIF9zY2FsZS56KSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ldyBPSU1PLkNvbnZleEh1bGxHZW9tZXRyeSh2ZXJ0aWNlc0FzVmVjMyk7IC8vVGVsbCBPaW1vUGh5c2ljcyB0byBjcmVhdGUgYSBodWxsIHRoYXQgaW52b2x2ZXMgYWxsIHBvaW50cyBidXQgY2xvc2UgaXQgb2YuIEEgY29udmV4IHNoYXBlIGNhbiBub3QgaGF2ZSBhIGhvbGUgaW4gaXQuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHZlcnRpY2VzIHRoYXQgY29uc3RydWN0IGEgcHlyYW1pZC4gVGhlIHZlcnRpY2VzIG9mIHRoZSBpbXBsZW1lbnRlZCBweXJhbWlkIG1lc2ggY2FuIGJlIHVzZWQgdG9vLiBCdXQgdGhleSBhcmUgaGFsZmVkIGFuZCBkb3VibGUgc2lkZWQsIHNvIGl0J3MgbW9yZSBwZXJmb3JtYW50IHRvIHVzZSB0aGlzLiAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVQeXJhbWlkVmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgbGV0IHZlcnRpY2VzOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAvKjAqLy0xLCAwLCAxLCAvKjEqLyAxLCAwLCAxLCAgLyoyKi8gMSwgMCwgLTEsIC8qMyovIC0xLCAwLCAtMSxcclxuICAgICAgICAvKjQqLyAwLCAyLCAwXHJcbiAgICAgIF0pO1xyXG4gICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEFkZGluZyB0aGlzIENvbXBvbmVudFJpZ2lkYm9keSB0byB0aGUgUGh5c2lzY3Mud29ybGQgZ2l2aW5nIHRoZSBvaW1vUGh5c2ljcyBzeXN0ZW0gdGhlIGluZm9ybWF0aW9uIG5lZWRlZCAqL1xyXG4gICAgcHJpdmF0ZSBhZGRSaWdpZGJvZHlUb1dvcmxkID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuI3JpZ2lkYm9keS5fd29ybGQpXHJcbiAgICAgICAgUGh5c2ljcy5hZGRSaWdpZGJvZHkodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBDYXB0dXJlIG9ubHkgZXZlbnRzIHRoYXQgYXJlIGJyb2FkY2FzdCB0byB0aGlzIG5vZGUgZnJvbSBhbiBhbmNlc3Rvci4gRG9uJ3QgY2FwdHVyZSBldmVudHMgdGhhdCBnZXQgc2VuZCB0byBkZXNjZW5kYW50cy4gKi9cclxuICAgIHByaXZhdGUgaG5kTm9kZURlYWN0aXZhdGUgPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICBsZXQgcGF0aDogTm9kZVtdID0gdGhpcy5ub2RlLmdldFBhdGgoKTtcclxuICAgICAgaWYgKCFwYXRoLmluY2x1ZGVzKDxOb2RlPl9ldmVudC50YXJnZXQpKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIHRoaXMucmVtb3ZlUmlnaWRib2R5RnJvbVdvcmxkKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBSZW1vdmluZyB0aGlzIENvbXBvbmVudFJpZ2lkYm9keSBmcm9tIHRoZSBQaHlzaXNjcy53b3JsZCB0YWtpbmcgdGhlIGluZm9ybWF0aW9ucyBmcm9tIHRoZSBvaW1vUGh5c2ljcyBzeXN0ZW0gKi9cclxuICAgIHByaXZhdGUgcmVtb3ZlUmlnaWRib2R5RnJvbVdvcmxkID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICBQaHlzaWNzLnJlbW92ZVJpZ2lkYm9keSh0aGlzKTtcclxuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vI3JlZ2lvbiBwcml2YXRlIEVWRU5UIGZ1bmN0aW9uc1xyXG4gICAgLy9DYWxjdWxhdGluZyB0aGUgY2VudGVyIG9mIGEgY29sbGlzaW9uIGFzIGEgc2luZ3VsYXIgcG9pbnQgLSBpbiBjYXNlIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgcG9pbnQgLSBieSBnZXR0aW5nIHRoZSBnZW9tZXRyaWNhbCBjZW50ZXIgb2YgYWxsIGNvbGxpZGluZyBwb2ludHNcclxuICAgIHByaXZhdGUgY29sbGlzaW9uQ2VudGVyUG9pbnQoX2NvbFBvaW50czogT0lNTy5NYW5pZm9sZFBvaW50W10sIF9udW1Qb2ludHM6IG51bWJlcik6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdG90YWxQb2ludHM6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCB0b3RhbFg6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCB0b3RhbFk6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCB0b3RhbFo6IG51bWJlciA9IDA7XHJcbiAgICAgIF9jb2xQb2ludHMuZm9yRWFjaCgoX3ZhbHVlOiBPSU1PLk1hbmlmb2xkUG9pbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBpZiAodG90YWxQb2ludHMgPCBfbnVtUG9pbnRzKSB7XHJcbiAgICAgICAgICB0b3RhbFBvaW50cysrO1xyXG4gICAgICAgICAgdG90YWxYICs9IF92YWx1ZS5nZXRQb3NpdGlvbjIoKS54O1xyXG4gICAgICAgICAgdG90YWxZICs9IF92YWx1ZS5nZXRQb3NpdGlvbjIoKS55O1xyXG4gICAgICAgICAgdG90YWxaICs9IF92YWx1ZS5nZXRQb3NpdGlvbjIoKS56O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0b3RhbFggLyBfbnVtUG9pbnRzLCB0b3RhbFkgLyBfbnVtUG9pbnRzLCB0b3RhbFogLyBfbnVtUG9pbnRzKTs7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBwcml2YXRlIGNvbGxpc2lvbkVudGVyKF9jb250YWN0OiBPSU1PLkNvbnRhY3QpOiB2b2lkIHtcclxuICAgICAgbGV0IGJvZHlBOiBDb21wb25lbnRSaWdpZGJvZHkgPSBfY29udGFjdC5nZXRTaGFwZTEoKT8udXNlckRhdGE7XHJcbiAgICAgIGxldCBib2R5QjogQ29tcG9uZW50UmlnaWRib2R5ID0gX2NvbnRhY3QuZ2V0U2hhcGUyKCk/LnVzZXJEYXRhO1xyXG5cclxuICAgICAgaWYgKCFib2R5QSB8fCAhYm9keUIgfHwgYm9keUEuY29sbGlzaW9ucy5pbmNsdWRlcyhib2R5QikpIC8vIGFscmVhZHkgZW50ZXJlZFxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGJvZHlBLmNvbGxpc2lvbnMucHVzaChib2R5Qik7XHJcbiAgICAgIGJvZHlCLmNvbGxpc2lvbnMucHVzaChib2R5QSk7XHJcblxyXG4gICAgICAvLyBUT0RPOiBtYXliZSByYXRoZXIgZXhwb3NlIHRoZSBtYW5pZm9sZCB0byB0aGUgZXZlbnQgb3Igc29tZXRoaW5nXHJcbiAgICAgIGxldCBtYW5pZm9sZDogT0lNTy5NYW5pZm9sZCA9IF9jb250YWN0LmdldE1hbmlmb2xkKCk7XHJcbiAgICAgIGxldCBwb2ludHM6IE9JTU8uTWFuaWZvbGRQb2ludFtdID0gbWFuaWZvbGQuZ2V0UG9pbnRzKCk7IC8vIEFsbCBwb2ludHMgaW4gdGhlIGNvbGxpc2lvbiB3aGVyZSB0aGUgdHdvIGJvZGllcyBhcmUgdG91Y2hpbmcsIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBmdWxsIGltcGFjdFxyXG4gICAgICBsZXQgbm9ybWFsSW1wdWxzZTogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHRhbmdlbnRJbXB1bHNlOiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgYmlub3JtYWxJbXB1bHNlOiBudW1iZXIgPSAwO1xyXG4gICAgICBmb3IgKGxldCBtYW5pZm9sZFBvaW50IG9mIHBvaW50cykgeyAvLyBUaGUgaW1wYWN0IG9mIHRoZSBjb2xsaXNpb24gaW52b2x2aW5nIGFsbCB0b3VjaGluZyBwb2ludHNcclxuICAgICAgICBub3JtYWxJbXB1bHNlICs9IG1hbmlmb2xkUG9pbnQuZ2V0Tm9ybWFsSW1wdWxzZSgpO1xyXG4gICAgICAgIHRhbmdlbnRJbXB1bHNlICs9IG1hbmlmb2xkUG9pbnQuZ2V0VGFuZ2VudEltcHVsc2UoKTtcclxuICAgICAgICBiaW5vcm1hbEltcHVsc2UgKz0gbWFuaWZvbGRQb2ludC5nZXRCaW5vcm1hbEltcHVsc2UoKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgbm9ybWFsOiBPSU1PLlZlYzMgPSBtYW5pZm9sZC5nZXROb3JtYWwoKTtcclxuICAgICAgbGV0IGNvbGxpc2lvbk5vcm1hbDogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopO1xyXG4gICAgICBsZXQgY29sbGlzaW9uQ2VudGVyUG9pbnQ6IFZlY3RvcjMgPSBib2R5QS5jb2xsaXNpb25DZW50ZXJQb2ludChwb2ludHMsIG1hbmlmb2xkLmdldE51bVBvaW50cygpKTtcclxuICAgICAgYm9keUEuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnRQaHlzaWNzKEVWRU5UX1BIWVNJQ1MuQ09MTElTSU9OX0VOVEVSLCBib2R5Qiwgbm9ybWFsSW1wdWxzZSwgdGFuZ2VudEltcHVsc2UsIGJpbm9ybWFsSW1wdWxzZSwgY29sbGlzaW9uQ2VudGVyUG9pbnQsIGNvbGxpc2lvbk5vcm1hbCkpO1xyXG4gICAgICBib2R5Qi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5DT0xMSVNJT05fRU5URVIsIGJvZHlBLCBub3JtYWxJbXB1bHNlLCB0YW5nZW50SW1wdWxzZSwgYmlub3JtYWxJbXB1bHNlLCBjb2xsaXNpb25DZW50ZXJQb2ludCwgY29sbGlzaW9uTm9ybWFsKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjb2xsaXNpb25FeGl0KF9jb250YWN0OiBPSU1PLkNvbnRhY3QpOiB2b2lkIHtcclxuICAgICAgbGV0IGJvZHlBOiBDb21wb25lbnRSaWdpZGJvZHkgPSBfY29udGFjdC5nZXRTaGFwZTEoKT8udXNlckRhdGE7XHJcbiAgICAgIGxldCBib2R5QjogQ29tcG9uZW50UmlnaWRib2R5ID0gX2NvbnRhY3QuZ2V0U2hhcGUyKCk/LnVzZXJEYXRhO1xyXG5cclxuICAgICAgaWYgKCFib2R5QSB8fCAhYm9keUIgfHwgIWJvZHlBLmNvbGxpc2lvbnMuaW5jbHVkZXMoYm9keUIpKSAvLyBhbHJlYWR5IGV4aXRlZFxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGJvZHlBLmNvbGxpc2lvbnMuc3BsaWNlKGJvZHlBLmNvbGxpc2lvbnMuaW5kZXhPZihib2R5QiksIDEpO1xyXG4gICAgICBib2R5Qi5jb2xsaXNpb25zLnNwbGljZShib2R5Qi5jb2xsaXNpb25zLmluZGV4T2YoYm9keUEpLCAxKTtcclxuXHJcbiAgICAgIGJvZHlBLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLkNPTExJU0lPTl9FWElULCBib2R5QiwgMCwgMCwgMCkpO1xyXG4gICAgICBib2R5Qi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5DT0xMSVNJT05fRVhJVCwgYm9keUEsIDAsIDAsIDApKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVHJpZ2dlciBFbnRlcmluZ0V2ZW50IENhbGxiYWNrLCBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBPSU1PIFBoeXNpY3Mgd2l0aGluIHRoZWlyIGNhbGN1bGF0aW9ucy5cclxuICAgICogU2luY2UgdGhlIGV2ZW50IGRvZXMgbm90IGtub3cgd2hpY2ggYm9keSBpcyB0aGUgdHJpZ2dlciBpbmlhdG9yLCB0aGUgZXZlbnQgY2FuIGJlIGxpc3RlbmVkIHRvXHJcbiAgICAqIG9uIGVpdGhlciB0aGUgdHJpZ2dlciBvciB0aGUgdHJpZ2dlcmVkLiAoVGhpcyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggdGhlIEZVREdFIE9JTU8gRm9yayEpXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmlnZ2VyRW50ZXIoX2NvbnRhY3Q6IE9JTU8uQ29udGFjdCk6IHZvaWQge1xyXG4gICAgICBsZXQgYm9keUE6IENvbXBvbmVudFJpZ2lkYm9keSA9IF9jb250YWN0LmdldFNoYXBlMSgpPy51c2VyRGF0YTtcclxuICAgICAgbGV0IGJvZHlCOiBDb21wb25lbnRSaWdpZGJvZHkgPSBfY29udGFjdC5nZXRTaGFwZTIoKT8udXNlckRhdGE7XHJcblxyXG4gICAgICBpZiAoIWJvZHlBIHx8ICFib2R5QiB8fCBib2R5QS50cmlnZ2VyaW5ncy5pbmNsdWRlcyhib2R5QikpIC8vIGFscmVhZHkgZW50ZXJlZFxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGJvZHlBLnRyaWdnZXJpbmdzLnB1c2goYm9keUIpO1xyXG4gICAgICBib2R5Qi50cmlnZ2VyaW5ncy5wdXNoKGJvZHlBKTtcclxuXHJcbiAgICAgIGxldCBtYW5pZm9sZDogT0lNTy5NYW5pZm9sZCA9IF9jb250YWN0LmdldE1hbmlmb2xkKCk7XHJcbiAgICAgIGxldCBwb2ludHM6IE9JTU8uTWFuaWZvbGRQb2ludFtdID0gbWFuaWZvbGQuZ2V0UG9pbnRzKCk7IFxyXG4gICAgICBsZXQgbm9ybWFsOiBPSU1PLlZlYzMgPSBtYW5pZm9sZC5nZXROb3JtYWwoKTtcclxuICAgICAgbGV0IGNvbGxpc2lvbk5vcm1hbDogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopO1xyXG4gICAgICBsZXQgY29sbGlzaW9uQ2VudGVyUG9pbnQ6IFZlY3RvcjMgPSBib2R5QS5jb2xsaXNpb25DZW50ZXJQb2ludChwb2ludHMsIG1hbmlmb2xkLmdldE51bVBvaW50cygpKTtcclxuXHJcbiAgICAgIGJvZHlBLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLlRSSUdHRVJfRU5URVIsIGJvZHlCLCAwLCAwLCAwLCBjb2xsaXNpb25DZW50ZXJQb2ludCwgY29sbGlzaW9uTm9ybWFsKSk7XHJcbiAgICAgIGJvZHlCLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLlRSSUdHRVJfRU5URVIsIGJvZHlBLCAwLCAwLCAwLCBjb2xsaXNpb25DZW50ZXJQb2ludCwgY29sbGlzaW9uTm9ybWFsKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRyaWdnZXIgTGVhdmluZ0V2ZW50IENhbGxiYWNrLCBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBPSU1PIFBoeXNpY3Mgd2l0aGluIHRoZWlyIGNhbGN1bGF0aW9ucy5cclxuICAgICogU2luY2UgdGhlIGV2ZW50IGRvZXMgbm90IGtub3cgd2hpY2ggYm9keSBpcyB0aGUgdHJpZ2dlciBpbmlhdG9yLCB0aGUgZXZlbnQgY2FuIGJlIGxpc3RlbmVkIHRvXHJcbiAgICAqIG9uIGVpdGhlciB0aGUgdHJpZ2dlciBvciB0aGUgdHJpZ2dlcmVkLiAoVGhpcyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggdGhlIEZVREdFIE9JTU8gRm9yayEpXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmlnZ2VyRXhpdChfY29udGFjdDogT0lNTy5Db250YWN0KTogdm9pZCB7XHJcbiAgICAgIGxldCBib2R5QTogQ29tcG9uZW50UmlnaWRib2R5ID0gX2NvbnRhY3QuZ2V0U2hhcGUxKCk/LnVzZXJEYXRhO1xyXG4gICAgICBsZXQgYm9keUI6IENvbXBvbmVudFJpZ2lkYm9keSA9IF9jb250YWN0LmdldFNoYXBlMigpPy51c2VyRGF0YTtcclxuXHJcbiAgICAgIGlmICghYm9keUEgfHwgIWJvZHlCIHx8ICFib2R5QS50cmlnZ2VyaW5ncy5pbmNsdWRlcyhib2R5QikpIC8vIGFscmVhZHkgZXhpdGVkXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgYm9keUEudHJpZ2dlcmluZ3Muc3BsaWNlKGJvZHlBLmNvbGxpc2lvbnMuaW5kZXhPZihib2R5QiksIDEpO1xyXG4gICAgICBib2R5Qi50cmlnZ2VyaW5ncy5zcGxpY2UoYm9keUIuY29sbGlzaW9ucy5pbmRleE9mKGJvZHlBKSwgMSk7XHJcblxyXG4gICAgICBib2R5QS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5UUklHR0VSX0VYSVQsIGJvZHlCLCAwLCAwLCAwKSk7XHJcbiAgICAgIGJvZHlCLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLlRSSUdHRVJfRVhJVCwgYm9keUEsIDAsIDAsIDApKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKiogSW50ZXJuYWwgY2xhc3MgZm9yIGhvbGRpbmcgZGF0YSBhYm91dCBwaHlzaWNzIGRlYnVnIHZlcnRpY2VzLiovXHJcbiAgZXhwb3J0IGNsYXNzIFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlciB7XHJcbiAgICBwdWJsaWMgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICBwdWJsaWMgbnVtVmVydGljZXM6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgYXR0cmliczogQXJyYXk8UGh5c2ljc0RlYnVnVmVydGV4QXR0cmlidXRlPjtcclxuICAgIHB1YmxpYyBpbmRpY2VzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHVibGljIG9mZnNldHM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgc3RyaWRlOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYnVmZmVyOiBXZWJHTEJ1ZmZlcjtcclxuICAgIHB1YmxpYyBkYXRhTGVuZ3RoOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFNldHVwIHRoZSByZW5kZXJpbmcgY29udGV4dCBmb3IgdGhpcyBidWZmZXIgYW5kIGNyZWF0ZSB0aGUgYWN0dWFsIGJ1ZmZlciBmb3IgdGhpcyBjb250ZXh0LiAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9yZW5kZXJpbmdDb250ZXh0OiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XHJcbiAgICAgIHRoaXMuZ2wgPSBfcmVuZGVyaW5nQ29udGV4dDtcclxuICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBGaWxsIHRoZSBib3VuZCBidWZmZXIgd2l0aCBkYXRhLiBVc2VkIGF0IGJ1ZmZlciBpbml0aWFsaXphdGlvbiAqL1xyXG4gICAgcHVibGljIHNldERhdGEoX2FycmF5OiBBcnJheTxudW1iZXI+KTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLmF0dHJpYnMgPT0gbnVsbCkgdGhyb3cgXCJzZXQgYXR0cmlidXRlcyBmaXJzdFwiO1xyXG4gICAgICB0aGlzLm51bVZlcnRpY2VzID0gX2FycmF5Lmxlbmd0aCAvICh0aGlzLnN0cmlkZSAvIDQpO1xyXG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuICAgICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KF9hcnJheSksIHRoaXMuZ2wuRFlOQU1JQ19EUkFXKTtcclxuICAgICAgLy9ub3QgbmVjZXNzYXJ5IGFuIGluIHdlYmdsMiBhbnltb3JlIHRvIHJlYmluZCB0aGUgc2FtZSBsYXN0IGJ1ZmZlciAod2hpY2ggaXMgYWNoaWV2ZWQgYnkgZ2l2aW5nIGEgbnVsbCBidWZmZXIpLCBhZnRlciBidWZmZXIgaXMgY2hhbmdlZC4gUmVtb3ZlZCBpdCBvbiBhbGwgb3RoZXIgb2NjYXNpb25zXHJcbiAgICAgIC8vIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7IFxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBTZXQgU2hhZGVyIEF0dHJpYnV0ZXMgaW5mb3JtYXRpb25zIGJ5IGdldHRpbmcgdGhlaXIgcG9zaXRpb24gaW4gdGhlIHNoYWRlciwgc2V0dGluZyB0aGUgb2Zmc2V0LCBzdHJpZGUgYW5kIHNpemUuIEZvciBsYXRlciB1c2UgaW4gdGhlIGJpbmRpbmcgcHJvY2VzcyAqL1xyXG4gICAgcHVibGljIHNldEF0dHJpYnMoX2F0dHJpYnM6IEFycmF5PFBoeXNpY3NEZWJ1Z1ZlcnRleEF0dHJpYnV0ZT4pOiB2b2lkIHtcclxuICAgICAgdGhpcy5hdHRyaWJzID0gX2F0dHJpYnM7XHJcbiAgICAgIHRoaXMub2Zmc2V0cyA9IFtdO1xyXG4gICAgICB0aGlzLnN0cmlkZSA9IDA7XHJcbiAgICAgIGxldCBuOiBudW1iZXIgPSBfYXR0cmlicy5sZW5ndGg7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICB0aGlzLm9mZnNldHMucHVzaCh0aGlzLnN0cmlkZSk7XHJcbiAgICAgICAgdGhpcy5zdHJpZGUgKz0gX2F0dHJpYnNbaV0uZmxvYXQzMkNvdW50ICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UOyAvLyAzMmJpdCBmbG9hdCBCeXRlcyBhcmUgYSBjb25zdGFudCBvZiA0XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgYXR0cmlidXRlIGluIHRoZSBzaGFkZXIgKi9cclxuICAgIHB1YmxpYyBsb2FkQXR0cmliSW5kaWNlcyhfcHJvZ3JhbTogUGh5c2ljc0RlYnVnU2hhZGVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuaW5kaWNlcyA9IF9wcm9ncmFtLmdldEF0dHJpYkluZGljZXModGhpcy5hdHRyaWJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRW5hYmxlIGEgYXR0cmlidXRlIGluIGEgc2hhZGVyIGZvciB0aGlzIGNvbnRleHQsICovXHJcbiAgICBwdWJsaWMgYmluZEF0dHJpYnMoKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLmluZGljZXMgPT0gbnVsbCkgdGhyb3cgXCJpbmRpY2VzIGFyZSBub3QgbG9hZGVkXCI7XHJcbiAgICAgIGxldCBuOiBudW1iZXIgPSB0aGlzLmF0dHJpYnMubGVuZ3RoO1xyXG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTsgLy9tYWtpbmcgdGhlIGJ1ZmZlciBvZiB0aGlzIGNsYXNzIHRoZSBjdXJyZW50IGJ1ZmZlclxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmluZGljZXNbaV0pOyAvL2VuYWJsZSB0aGUgQXR0cmlidXRlXHJcbiAgICAgICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuaW5kaWNlc1tpXSwgdGhpcy5hdHRyaWJzW2ldLmZsb2F0MzJDb3VudCwgdGhpcy5nbC5GTE9BVCwgZmFsc2UsIHRoaXMuc3RyaWRlLCB0aGlzLm9mZnNldHNbaV0pOyAvL2NyZWF0ZXMgYSBwb2ludGVyIGFuZCBzdHJ1Y3R1cmUgZm9yIHRoaXMgYXR0cmlidXRlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBJbnRlcm5hbCBjbGFzcyBmb3IgaG9sZGluZyBkYXRhIGFib3V0IFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlcnMgKi9cclxuICBleHBvcnQgY2xhc3MgUGh5c2ljc0RlYnVnSW5kZXhCdWZmZXIge1xyXG4gICAgcHVibGljIGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgcHVibGljIGJ1ZmZlcjogV2ViR0xCdWZmZXI7XHJcbiAgICBwdWJsaWMgY291bnQ6IG51bWJlcjtcclxuXHJcbiAgICAvKiogU2V0dXAgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB0aGlzIGJ1ZmZlciBhbmQgY3JlYXRlIHRoZSBhY3R1YWwgYnVmZmVyIGZvciB0aGlzIGNvbnRleHQuICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3JlbmRlcmluZ0NvbnRleHQ6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcclxuICAgICAgdGhpcy5nbCA9IF9yZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEZpbGwgdGhlIGJvdW5kIGJ1ZmZlciB3aXRoIGRhdGEgYW1vdW50LiBVc2VkIGF0IGJ1ZmZlciBpbml0aWFsaXphdGlvbiAqL1xyXG4gICAgcHVibGljIHNldERhdGEoX2FycmF5OiBBcnJheTxudW1iZXI+KTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XHJcbiAgICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBuZXcgSW50MTZBcnJheShfYXJyYXkpLCB0aGlzLmdsLkRZTkFNSUNfRFJBVyk7XHJcbiAgICAgIHRoaXMuY291bnQgPSBfYXJyYXkubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgYWN0dWFsIERyYXdDYWxsIGZvciBwaHlzaWNzRGVidWdEcmF3IEJ1ZmZlcnMuIFRoaXMgaXMgd2hlcmUgdGhlIGluZm9ybWF0aW9uIGZyb20gdGhlIGRlYnVnIGlzIGFjdHVhbGx5IGRyYXduLiAqL1xyXG4gICAgcHVibGljIGRyYXcoX21vZGU6IG51bWJlciA9IHRoaXMuZ2wuVFJJQU5HTEVTLCBfY291bnQ6IG51bWJlciA9IC0xKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XHJcbiAgICAgIHRoaXMuZ2wuZHJhd0VsZW1lbnRzKF9tb2RlLCBfY291bnQgPj0gMCA/IF9jb3VudCA6IHRoaXMuY291bnQsIHRoaXMuZ2wuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEludGVybmFsIGNsYXNzIGZvciBtYW5hZ2luZyBkYXRhIGFib3V0IHdlYkdMIEF0dHJpYnV0ZXMgKi9cclxuICBleHBvcnQgY2xhc3MgUGh5c2ljc0RlYnVnVmVydGV4QXR0cmlidXRlIHtcclxuICAgIHB1YmxpYyBmbG9hdDMyQ291bnQ6IG51bWJlcjtcclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9mbG9hdDMyQ291bnQ6IG51bWJlciwgX25hbWU6IHN0cmluZykge1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgICAgdGhpcy5mbG9hdDMyQ291bnQgPSBfZmxvYXQzMkNvdW50O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEludGVybmFsIGNsYXNzIGZvciBTaGFkZXJzIHVzZWQgb25seSBieSB0aGUgcGh5c2ljcyBkZWJ1Z0RyYXcgKi9cclxuICBleHBvcnQgY2xhc3MgUGh5c2ljc0RlYnVnU2hhZGVyIHtcclxuICAgIHB1YmxpYyBnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcclxuICAgIHB1YmxpYyBwcm9ncmFtOiBXZWJHTFByb2dyYW07XHJcbiAgICBwdWJsaWMgdmVydGV4U2hhZGVyOiBXZWJHTFNoYWRlcjtcclxuICAgIHB1YmxpYyBmcmFnbWVudFNoYWRlcjogV2ViR0xTaGFkZXI7XHJcbiAgICBwdWJsaWMgdW5pZm9ybUxvY2F0aW9uTWFwOiBNYXA8c3RyaW5nLCBXZWJHTFVuaWZvcm1Mb2NhdGlvbj47XHJcblxyXG4gICAgLyoqIEludHJvZHVjZSB0aGUgRlVER0UgUmVuZGVyaW5nIENvbnRleHQgdG8gdGhpcyBjbGFzcywgY3JlYXRpbmcgYSBwcm9ncmFtIGFuZCB2ZXJ0ZXgvZnJhZ21lbnQgc2hhZGVyIGluIHRoaXMgY29udGV4dCAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9yZW5kZXJpbmdDb250ZXh0OiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XHJcbiAgICAgIHRoaXMuZ2wgPSBfcmVuZGVyaW5nQ29udGV4dDtcclxuICAgICAgdGhpcy5wcm9ncmFtID0gdGhpcy5nbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodGhpcy5nbC5WRVJURVhfU0hBREVSKTtcclxuICAgICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHRoaXMuZ2wuRlJBR01FTlRfU0hBREVSKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGFrZSBnbHNsIHNoYWRlcnMgYXMgc3RyaW5ncyBhbmQgY29tcGlsZSB0aGVtLCBhdHRhY2hpbmcgdGhlIGNvbXBpbGVkIHNoYWRlcnMgdG8gYSBwcm9ncmFtIHRoYXRzIHVzZWQgYnkgdGhpcyByZW5kZXJpbmcgY29udGV4dC4gKi9cclxuICAgIHB1YmxpYyBjb21waWxlKF92ZXJ0ZXhTb3VyY2U6IHN0cmluZywgX2ZyYWdtZW50U291cmNlOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgdGhpcy51bmlmb3JtTG9jYXRpb25NYXAgPSBuZXcgTWFwPHN0cmluZywgV2ViR0xVbmlmb3JtTG9jYXRpb24+KCk7XHJcbiAgICAgIHRoaXMuY29tcGlsZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlciwgX3ZlcnRleFNvdXJjZSk7XHJcbiAgICAgIHRoaXMuY29tcGlsZVNoYWRlcih0aGlzLmZyYWdtZW50U2hhZGVyLCBfZnJhZ21lbnRTb3VyY2UpO1xyXG4gICAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcih0aGlzLnByb2dyYW0sIHRoaXMudmVydGV4U2hhZGVyKTtcclxuICAgICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIodGhpcy5wcm9ncmFtLCB0aGlzLmZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgdGhpcy5nbC5saW5rUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICBpZiAoIXRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLnByb2dyYW0sIHRoaXMuZ2wuTElOS19TVEFUVVMpKSB7ICAvL21ha2Ugc3VyZSB0aGUgbGlua2luZyB3b3JrZWQsIHNvIHRoZSBwcm9ncmFtIGlzIHZhbGlkLCBhbmQgc2hhZGVycyBhcmUgd29ya2luZ1xyXG4gICAgICAgIERlYnVnLmxvZyh0aGlzLmdsLmdldFByb2dyYW1JbmZvTG9nKHRoaXMucHJvZ3JhbSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZ2wudmFsaWRhdGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgIGlmICghdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMucHJvZ3JhbSwgdGhpcy5nbC5WQUxJREFURV9TVEFUVVMpKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVSUk9SIHZhbGlkYXRpbmcgcHJvZ3JhbSFcIiwgdGhpcy5nbC5nZXRQcm9ncmFtSW5mb0xvZyh0aGlzLnByb2dyYW0pKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IGluZGV4IG9mIGEgYXR0cmlidXRlIGluIGEgc2hhZGVyIGluIHRoaXMgcHJvZ3JhbSAqL1xyXG4gICAgcHVibGljIGdldEF0dHJpYkluZGV4KF9uYW1lOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIF9uYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IHRoZSBsb2NhdGlvbiBvZiBhIHVuaWZvcm0gaW4gYSBzaGFkZXIgaW4gdGhpcyBwcm9ncmFtICovXHJcbiAgICBwdWJsaWMgZ2V0VW5pZm9ybUxvY2F0aW9uKF9uYW1lOiBzdHJpbmcpOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB7XHJcbiAgICAgIGlmICh0aGlzLnVuaWZvcm1Mb2NhdGlvbk1hcC5oYXMoX25hbWUpKSByZXR1cm4gdGhpcy51bmlmb3JtTG9jYXRpb25NYXAuZ2V0KF9uYW1lKTtcclxuICAgICAgbGV0IGxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgX25hbWUpO1xyXG4gICAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbk1hcC5zZXQoX25hbWUsIGxvY2F0aW9uKTtcclxuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgYWxsIGluZGljZXMgZm9yIGV2ZXJ5IGF0dHJpYnV0ZSBpbiB0aGUgc2hhZGVycyBvZiB0aGlzIHByb2dyYW0gKi9cclxuICAgIHB1YmxpYyBnZXRBdHRyaWJJbmRpY2VzKF9hdHRyaWJzOiBBcnJheTxQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGU+KTogQXJyYXk8bnVtYmVyPiB7XHJcbiAgICAgIGxldCBpbmRpY2VzOiBBcnJheTxudW1iZXI+ID0gW107XHJcbiAgICAgIF9hdHRyaWJzLmZvckVhY2goX3ZhbHVlID0+IHtcclxuICAgICAgICBpbmRpY2VzLnB1c2godGhpcy5nZXRBdHRyaWJJbmRleChfdmFsdWUubmFtZSkpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGluZGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRlbGwgdGhlIEZVREdFIFJlbmRlcmluZyBDb250ZXh0IHRvIHVzZSB0aGlzIHByb2dyYW0gdG8gZHJhdy4gKi9cclxuICAgIHB1YmxpYyB1c2UoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDb21waWxlIGEgc2hhZGVyIG91dCBvZiBhIHN0cmluZyBhbmQgdmFsaWRhdGUgaXQuICovXHJcbiAgICBwdWJsaWMgY29tcGlsZVNoYWRlcihfc2hhZGVyOiBXZWJHTFNoYWRlciwgX3NvdXJjZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKF9zaGFkZXIsIF9zb3VyY2UpO1xyXG4gICAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIoX3NoYWRlcik7XHJcbiAgICAgIGlmICghdGhpcy5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIoX3NoYWRlciwgdGhpcy5nbC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICBEZWJ1Zy5sb2codGhpcy5nbC5nZXRTaGFkZXJJbmZvTG9nKF9zaGFkZXIpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEludGVybmFsIENsYXNzIHVzZWQgdG8gZHJhdyBkZWJ1Z0luZm9ybWF0aW9ucyBhYm91dCB0aGUgcGh5c2ljcyBzaW11bGF0aW9uIG9udG8gdGhlIHJlbmRlckNvbnRleHQuIE5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkLiBcclxuICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSAyMDIwIC8vQmFzZWQgb24gT2ltb1BoeXNpY3MgSGF4ZSBEZWJ1Z0RyYXdEZW1vIFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBQaHlzaWNzRGVidWdEcmF3IGV4dGVuZHMgUmVuZGVyV2ViR0wge1xyXG4gICAgcHVibGljIG9pbW9EZWJ1Z0RyYXc6IE9JTU8uRGVidWdEcmF3OyAvL3RoZSBvcmlnaW5hbCBwaHlzaWNzIGVuZ2luZSBkZWJ1Z0RyYXcgY2xhc3MgcmVjZWl2aW5nIGNhbGxzIGZyb20gdGhlIG9pbW9QaHlzaWNzLldvcmxkLCBhbmQgcHJvdmlkaW5nIGluZm9ybWF0aW9ucyBpbiBmb3JtIG9mIHBvaW50cy9saW5lcy90cmlhbmdsZXMgd2hhdCB0aGUgcGh5c2ljcyB3b3JsZCBsb29rcyBsaWtlXHJcbiAgICBwdWJsaWMgc3R5bGU6IE9JTU8uRGVidWdEcmF3U3R5bGU7IC8vY29sb3JzIG9mIHRoZSBkZWJ1ZyBpbmZvcm1hdGlvbnMsIHVuY2hhbmdlZCBpbiBGVURHRSBpbnRlZ3JhdGlvbiwgYmFzaWNhbGx5IGNvbG9yaW5nIHRoaW5ncyBsaWtlIHNsZWVwaW5nL2FjdGl2ZSByYidzIGRpZmZlcmVudGx5LCBqb2ludHMgd2hpdGUgYW5kIHN1Y2guIE5vIG5lZWQgdG8gaGF2ZSB1c2VycyBjaGFuZ2UgYW55dGhpbmcuXHJcbiAgICBwdWJsaWMgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XHJcblxyXG4gICAgcHVibGljIHByb2dyYW06IFdlYkdMUHJvZ3JhbTsgLy9wcm9ncmFtIHRoYXQgaXMgdXNlZCBpbiB0aGUgRlVER0UgcmVuZGVyaW5nIGNvbnRleHQgY29udGFpbmluZyBzaGFkZXJzIGFuZCB1c2UgaW5mb3JtYXRpb25zIGZvciB0aGUgY29udGV4dCB0byBrbm93IGhvdyB0byBkcmF3XHJcbiAgICBwdWJsaWMgc2hhZGVyOiBQaHlzaWNzRGVidWdTaGFkZXI7XHJcblxyXG4gICAgLy9CdWZmZXJzIGZvciBwb2ludHMvbGluZXMvdHJpYW5nbGVzLiBJbmRleCBCdWZmZXIgZm9yIHRoZSBhbW91bnQgb2YgZHJhd0NhbGxzIGFuZCBWZXJ0ZXggQnVmZmVyIGZvciB0aGUgaW5mb3JtYXRpb25zXHJcbiAgICBwdWJsaWMgcG9pbnRWQk86IFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlcjtcclxuICAgIHB1YmxpYyBwb2ludElCTzogUGh5c2ljc0RlYnVnSW5kZXhCdWZmZXI7XHJcblxyXG4gICAgcHVibGljIGxpbmVWQk86IFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlcjtcclxuICAgIHB1YmxpYyBsaW5lSUJPOiBQaHlzaWNzRGVidWdJbmRleEJ1ZmZlcjtcclxuXHJcbiAgICBwdWJsaWMgdHJpVkJPOiBQaHlzaWNzRGVidWdWZXJ0ZXhCdWZmZXI7XHJcbiAgICBwdWJsaWMgdHJpSUJPOiBQaHlzaWNzRGVidWdJbmRleEJ1ZmZlcjtcclxuXHJcbiAgICBwdWJsaWMgcG9pbnREYXRhOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHVibGljIHBvaW50SWJvRGF0YTogQXJyYXk8bnVtYmVyPjtcclxuICAgIHB1YmxpYyBudW1Qb2ludERhdGE6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgbGluZURhdGE6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgbGluZUlib0RhdGE6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgbnVtTGluZURhdGE6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgdHJpRGF0YTogQXJyYXk8bnVtYmVyPjtcclxuICAgIHB1YmxpYyB0cmlJYm9EYXRhOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHVibGljIG51bVRyaURhdGE6IG51bWJlcjtcclxuXHJcbiAgICAvKiogQ3JlYXRpbmcgdGhlIGRlYnVnIGZvciBwaHlzaWNzIGluIEZVREdFLiBUZWxsIGl0IHRvIGRyYXcgb25seSB3aXJlZnJhbWUgb2JqZWN0cywgc2luY2UgRlVER0UgaXMgaGFuZGxpbmcgcmVuZGVyaW5nIG9mIHRoZSBvYmplY3RzIGJlc2lkZXMgcGh5c2ljcy4gXHJcbiAgICAgKiBPdmVycmlkZSBPaW1vUGh5c2ljcyBGdW5jdGlvbnMgd2l0aCBvd24gcmVuZGVyaW5nLiBJbml0aWFsaXplIGJ1ZmZlcnMgYW5kIGNvbm5lY3QgdGhlbSB3aXRoIHRoZSBjb250ZXh0IGZvciBsYXRlciB1c2UuICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICB0aGlzLnN0eWxlID0gbmV3IE9JTU8uRGVidWdEcmF3U3R5bGUoKTtcclxuICAgICAgdGhpcy5vaW1vRGVidWdEcmF3ID0gbmV3IE9JTU8uRGVidWdEcmF3KCk7XHJcbiAgICAgIHRoaXMub2ltb0RlYnVnRHJhdy53aXJlZnJhbWUgPSB0cnVlOyAvL1RyaWFuZ2xlIFJlbmRlcmluZyBpcyBoYW5kbGVkIGJ5IEZVREdFIHNvLCBvbmx5IHRoZSBwaHlzaWNzIGxpbmVzL3BvaW50cyBuZWVkIHRvIGJlIHJlbmRlcmVkLCBhbHRob3VnaCB0cmlhbmdsZSBpcyBzdGlsbCBpbXBsZW1lbnRlZFxyXG5cclxuICAgICAgdGhpcy5nbCA9IFJlbmRlcldlYkdMLmNyYzM7XHJcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZU92ZXJyaWRlKCk7XHJcbiAgICAgIHRoaXMuc2hhZGVyID0gbmV3IFBoeXNpY3NEZWJ1Z1NoYWRlcih0aGlzLmdsKTtcclxuICAgICAgdGhpcy5zaGFkZXIuY29tcGlsZSh0aGlzLnZlcnRleFNoYWRlclNvdXJjZSgpLCB0aGlzLmZyYWdtZW50U2hhZGVyU291cmNlKCkpO1xyXG5cclxuICAgICAgdGhpcy5pbml0aWFsaXplQnVmZmVycygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZWNlaXZlIHRoZSBjdXJyZW50IERlYnVnTW9kZSBmcm9tIHRoZSBwaHlzaWNzIHNldHRpbmdzIGFuZCBzZXQgdGhlIE9pbW9QaHlzaWNzLkRlYnVnRHJhdyBib29sZWFucyB0byBzaG93IG9ubHkgY2VydGFpbiBpbmZvcm1hdGlvbnMuXHJcbiAgICAgKiBOZWVkZWQgc2luY2Ugc29tZSBkZWJ1ZyBpbmZvcm1hdGlvbnMgZXhjbHVkZSBvdGhlcnMsIGFuZCBjYW4ndCBiZSBkcmF3biBhdCB0aGUgc2FtZSB0aW1lLCBieSBPaW1vUGh5c2ljcy4gQW5kIGZvciB1c2VycyBpdCBwcm92aWRlcyBtb3JlIHJlYWRhYmlsaXR5XHJcbiAgICAgKiB0byBkZWJ1ZyBvbmx5IHdoYXQgdGhleSBuZWVkIGFuZCBpcyBjb21tb25seSBkZWJ1Z2dlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldERlYnVnTW9kZShfbW9kZTogUEhZU0lDU19ERUJVR01PREUgPSBQSFlTSUNTX0RFQlVHTU9ERS5OT05FKTogdm9pZCB7XHJcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICBsZXQgZHJhdyA9IHsgZHJhd0FhYmJzOiBmYWxzZSwgZHJhd0Jhc2VzOiBmYWxzZSwgZHJhd0J2aDogZmFsc2UsIGRyYXdDb250YWN0QmFzZXM6IGZhbHNlLCBkcmF3Q29udGFjdHM6IGZhbHNlLCBkcmF3Sm9pbnRMaW1pdHM6IGZhbHNlLCBkcmF3Sm9pbnRzOiBmYWxzZSwgZHJhd1BhaXJzOiBmYWxzZSwgZHJhd1NoYXBlczogZmFsc2UgfTtcclxuXHJcbiAgICAgIHN3aXRjaCAoX21vZGUpIHtcclxuICAgICAgICBjYXNlIFBIWVNJQ1NfREVCVUdNT0RFLkNPTExJREVSUzogLy9Db2xsaWRlcnMgYW5kIEJhc2VzXHJcbiAgICAgICAgICBkcmF3LmRyYXdCYXNlcyA9IGRyYXcuZHJhd1NoYXBlcyA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFBIWVNJQ1NfREVCVUdNT0RFLkpPSU5UU19BTkRfQ09MTElERVI6IC8vQ29sbGlkZXJzIGFuZCBqb2ludHNcclxuICAgICAgICAgIGRyYXcuZHJhd0pvaW50cyA9IGRyYXcuZHJhd0pvaW50TGltaXRzID0gZHJhdy5kcmF3U2hhcGVzID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgUEhZU0lDU19ERUJVR01PREUuUEhZU0lDX09CSkVDVFNfT05MWTogLy9QaHlzaWNzIE9iamVjdHMgb25seSwgc2hvd3Mgc2FtZSBhcyBDb2xsaWRlciAvIEpvaW50cyBidXQgYWxzbyBoaWRpbmcgZXZlcnkgb3RoZXIgZnVkZ2Ugb2JqZWN0XHJcbiAgICAgICAgICBkcmF3LmRyYXdCYXNlcyA9IGRyYXcuZHJhd0pvaW50TGltaXRzID0gZHJhdy5kcmF3Sm9pbnRzID0gZHJhdy5kcmF3U2hhcGVzID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgUEhZU0lDU19ERUJVR01PREUuQ09OVEFDVFM6IC8vQ29udGFjdHNcclxuICAgICAgICAgIGRyYXcuZHJhd0Jhc2VzID0gZHJhdy5kcmF3Q29udGFjdEJhc2VzID0gZHJhdy5kcmF3Q29udGFjdHMgPSBkcmF3LmRyYXdQYWlycyA9IGRyYXcuZHJhd1NoYXBlcyA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFBIWVNJQ1NfREVCVUdNT0RFLkJPVU5ESU5HX0JPWEVTOiAvL0JvdW5kaW5nIEJveCAvIEJyb2FkcGhhc2UgQnZoIC8gQmFzZXNcclxuICAgICAgICAgIGRyYXcuZHJhd0FhYmJzID0gZHJhdy5kcmF3QmFzZXMgPSBkcmF3LmRyYXdCdmggPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLm9pbW9EZWJ1Z0RyYXcsIGRyYXcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGluZyB0aGUgZW1wdHkgcmVuZGVyIGJ1ZmZlcnMuIERlZmluaW5nIHRoZSBhdHRyaWJ1dGVzIHVzZWQgaW4gc2hhZGVycy5cclxuICAgICAqIE5lZWRzIHRvIGNyZWF0ZSBlbXB0eSBidWZmZXJzIHRvIGFscmVhZHkgaGF2ZSB0aGVtIHJlYWR5IHRvIGRyYXcgbGF0ZXIgb24sIGxpbmtpbmcgaXMgb25seSBwb3NzaWJsZSB3aXRoIGV4aXN0aW5nIGJ1ZmZlcnMuICovXHJcbiAgICBwdWJsaWMgaW5pdGlhbGl6ZUJ1ZmZlcnMoKTogdm9pZCB7XHJcbiAgICAgIGxldCBhdHRyaWJzOiBBcnJheTxQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGU+ID0gW1xyXG4gICAgICAgIG5ldyBQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGUoMywgXCJhUG9zaXRpb25cIiksXHJcbiAgICAgICAgbmV3IFBoeXNpY3NEZWJ1Z1ZlcnRleEF0dHJpYnV0ZSgzLCBcImFOb3JtYWxcIiksXHJcbiAgICAgICAgbmV3IFBoeXNpY3NEZWJ1Z1ZlcnRleEF0dHJpYnV0ZSgzLCBcImFDb2xvclwiKVxyXG4gICAgICBdO1xyXG5cclxuICAgICAgdGhpcy5wb2ludFZCTyA9IG5ldyBQaHlzaWNzRGVidWdWZXJ0ZXhCdWZmZXIodGhpcy5nbCk7XHJcbiAgICAgIHRoaXMucG9pbnRJQk8gPSBuZXcgUGh5c2ljc0RlYnVnSW5kZXhCdWZmZXIodGhpcy5nbCk7XHJcbiAgICAgIHRoaXMucG9pbnRWQk8uc2V0QXR0cmlicyhhdHRyaWJzKTtcclxuICAgICAgdGhpcy5wb2ludFZCTy5sb2FkQXR0cmliSW5kaWNlcyh0aGlzLnNoYWRlcik7XHJcbiAgICAgIHRoaXMubGluZVZCTyA9IG5ldyBQaHlzaWNzRGVidWdWZXJ0ZXhCdWZmZXIodGhpcy5nbCk7XHJcbiAgICAgIHRoaXMubGluZUlCTyA9IG5ldyBQaHlzaWNzRGVidWdJbmRleEJ1ZmZlcih0aGlzLmdsKTtcclxuICAgICAgdGhpcy5saW5lVkJPLnNldEF0dHJpYnMoYXR0cmlicyk7XHJcbiAgICAgIHRoaXMubGluZVZCTy5sb2FkQXR0cmliSW5kaWNlcyh0aGlzLnNoYWRlcik7XHJcbiAgICAgIHRoaXMudHJpVkJPID0gbmV3IFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlcih0aGlzLmdsKTtcclxuICAgICAgdGhpcy50cmlJQk8gPSBuZXcgUGh5c2ljc0RlYnVnSW5kZXhCdWZmZXIodGhpcy5nbCk7XHJcbiAgICAgIHRoaXMudHJpVkJPLnNldEF0dHJpYnMoYXR0cmlicyk7XHJcbiAgICAgIHRoaXMudHJpVkJPLmxvYWRBdHRyaWJJbmRpY2VzKHRoaXMuc2hhZGVyKTtcclxuXHJcbiAgICAgIHRoaXMuY2xlYXJCdWZmZXJzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEJlZm9yZSBPaW1vUGh5c2ljcy53b3JsZCBpcyBmaWxsaW5nIHRoZSBkZWJ1Zy4gTWFrZSBzdXJlIHRoZSBidWZmZXJzIGFyZSByZXNldC4gQWxzbyByZWNlaXZpbmcgdGhlIGRlYnVnTW9kZSBmcm9tIHNldHRpbmdzIGFuZCB1cGRhdGluZyB0aGUgY3VycmVudCBwcm9qZWN0aW9uIGZvciB0aGUgdmVydGV4U2hhZGVyLiAqL1xyXG4gICAgcHVibGljIGNsZWFyQnVmZmVycygpOiB2b2lkIHtcclxuICAgICAgdGhpcy5nbC5saW5lV2lkdGgoMi4wKTsgLy9Eb2VzIG5vdCBhZmZlY3QgYW55dGhpbmcgYmVjYXVzZSBsaW5lV2lkdGggaXMgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGJ5IE1pY3Jvc29mdCBFZGdlIGFuZCBGVURHRSBpcyBvcHRpbWl6ZWQgZm9yIENocm9tZVxyXG5cclxuICAgICAgdGhpcy5wb2ludERhdGEgPSBbXTsgLy9SZXNldHRpbmcgdGhlIGRhdGEgdG8gYmUgZmlsbGVkIGFnYWluXHJcbiAgICAgIHRoaXMubGluZURhdGEgPSBbXTtcclxuICAgICAgdGhpcy50cmlEYXRhID0gW107XHJcblxyXG4gICAgICB0aGlzLm51bVBvaW50RGF0YSA9IDA7IC8vUmVzZXR0aW5nIHRoZSBhbW91bnQgb2YgZGF0YSBjYWxsc1xyXG4gICAgICB0aGlzLm51bUxpbmVEYXRhID0gMDtcclxuICAgICAgdGhpcy5udW1UcmlEYXRhID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQWZ0ZXIgT2ltb1BoeXNpY3Mud29ybGQgZmlsbGVkIHRoZSBkZWJ1Zy4gUmVuZGVyaW5nIGNhbGxzLiBTZXR0aW5nIHRoaXMgcHJvZ3JhbSB0byBiZSB1c2VkIGJ5IHRoZSBGVURHRSByZW5kZXJpbmcgY29udGV4dC4gQW5kIGRyYXcgZWFjaCB1cGRhdGVkIGJ1ZmZlciBhbmQgcmVzZXR0aW5nIHRoZW0uICovXHJcbiAgICBwdWJsaWMgZHJhd0J1ZmZlcnMoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2hhZGVyLnVzZSgpO1xyXG4gICAgICB0aGlzLmdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5zaGFkZXIuZ2V0VW5pZm9ybUxvY2F0aW9uKFwidV9tdHhXb3JsZFRvVmlld1wiKSwgZmFsc2UsIFBoeXNpY3MubWFpbkNhbS5tdHhXb3JsZFRvVmlldy5nZXQoKSk7XHJcblxyXG4gICAgICB0aGlzLmdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcclxuICAgICAgaWYgKHRoaXMubnVtUG9pbnREYXRhID4gMCkge1xyXG4gICAgICAgIHRoaXMucG9pbnRJYm9EYXRhID0gW107ICAvL0J1ZmZlciBzaXplIG1hdGNoaW5nIHRvIHdoYXRzIG5lZWRlZFxyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm51bVBvaW50RGF0YTsgaSsrKSB7XHJcbiAgICAgICAgICB0aGlzLnBvaW50SWJvRGF0YS5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvaW50SUJPLnNldERhdGEodGhpcy5wb2ludElib0RhdGEpOyAvL1NldCBJbmRleCBidWZmZXIgdG8gY29ycmVjdCBzaXplXHJcbiAgICAgICAgdGhpcy5wb2ludFZCTy5zZXREYXRhKHRoaXMucG9pbnREYXRhKTsgLy9TZXQgVmVydGV4IEJ1ZmZlciB0byBjdXJyZW50IERhdGFcclxuICAgICAgICB0aGlzLnBvaW50VkJPLmJpbmRBdHRyaWJzKCk7XHJcbiAgICAgICAgdGhpcy5wb2ludElCTy5kcmF3KHRoaXMuZ2wuUE9JTlRTLCB0aGlzLm51bVBvaW50RGF0YSk7IC8vVGhlIGFjdHVhbCBkcmF3IGNhbGwgZm9yIGVhY2ggaW5kZXggaW4gaWJvXHJcbiAgICAgICAgdGhpcy5udW1Qb2ludERhdGEgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLm51bUxpbmVEYXRhID4gMCkge1xyXG4gICAgICAgIHRoaXMubGluZUlib0RhdGEgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5udW1MaW5lRGF0YTsgaSsrKSB7XHJcbiAgICAgICAgICB0aGlzLmxpbmVJYm9EYXRhLnB1c2goaSAqIDIpO1xyXG4gICAgICAgICAgdGhpcy5saW5lSWJvRGF0YS5wdXNoKGkgKiAyICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGluZUlCTy5zZXREYXRhKHRoaXMubGluZUlib0RhdGEpO1xyXG4gICAgICAgIHRoaXMubGluZVZCTy5zZXREYXRhKHRoaXMubGluZURhdGEpO1xyXG4gICAgICAgIHRoaXMubGluZVZCTy5iaW5kQXR0cmlicygpO1xyXG4gICAgICAgIHRoaXMubGluZUlCTy5kcmF3KHRoaXMuZ2wuTElORVMsIHRoaXMubnVtTGluZURhdGEgKiAyKTtcclxuICAgICAgICB0aGlzLm51bUxpbmVEYXRhID0gMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5udW1UcmlEYXRhID4gMCkge1xyXG4gICAgICAgIHRoaXMudHJpSWJvRGF0YSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm51bVRyaURhdGE7IGkrKykge1xyXG4gICAgICAgICAgdGhpcy50cmlJYm9EYXRhLnB1c2goaSAqIDMpO1xyXG4gICAgICAgICAgdGhpcy50cmlJYm9EYXRhLnB1c2goaSAqIDMgKyAxKTtcclxuICAgICAgICAgIHRoaXMudHJpSWJvRGF0YS5wdXNoKGkgKiAzICsgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJpSUJPLnNldERhdGEodGhpcy50cmlJYm9EYXRhKTtcclxuICAgICAgICB0aGlzLnRyaVZCTy5zZXREYXRhKHRoaXMudHJpRGF0YSk7XHJcbiAgICAgICAgdGhpcy50cmlWQk8uYmluZEF0dHJpYnMoKTtcclxuICAgICAgICB0aGlzLnRyaUlCTy5kcmF3KHRoaXMuZ2wuVFJJQU5HTEVTLCB0aGlzLm51bVRyaURhdGEgKiAzKTtcclxuICAgICAgICB0aGlzLm51bVRyaURhdGEgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIERyYXdpbmcgdGhlIHJheSBpbnRvIHRoZSBkZWJ1Z0RyYXcgQ2FsbC4gQnkgdXNpbmcgdGhlIG92ZXJ3cml0dGVuIGxpbmUgcmVuZGVyaW5nIGZ1bmN0aW9ucyBhbmQgZHJhd2luZyBhIHBvaW50IChwb2ludFNpemUgZGVmaW5lZCBpbiB0aGUgc2hhZGVyKSBhdCB0aGUgZW5kIG9mIHRoZSByYXkuICovXHJcbiAgICBwdWJsaWMgZGVidWdSYXkoX29yaWdpbjogVmVjdG9yMywgX2VuZDogVmVjdG9yMywgX2NvbG9yOiBDb2xvcik6IHZvaWQge1xyXG4gICAgICB0aGlzLm9pbW9EZWJ1Z0RyYXcubGluZShuZXcgT0lNTy5WZWMzKF9vcmlnaW4ueCwgX29yaWdpbi55LCBfb3JpZ2luLnopLCBuZXcgT0lNTy5WZWMzKF9lbmQueCwgX2VuZC55LCBfZW5kLnopLCBuZXcgT0lNTy5WZWMzKF9jb2xvci5yLCBfY29sb3IuZywgX2NvbG9yLmIpKTtcclxuICAgICAgdGhpcy5vaW1vRGVidWdEcmF3LnBvaW50KG5ldyBPSU1PLlZlYzMoX2VuZC54LCBfZW5kLnksIF9lbmQueiksIG5ldyBPSU1PLlZlYzMoX2NvbG9yLnIsIF9jb2xvci5nLCBfY29sb3IuYikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBPdmVycmlkaW5nIHRoZSBleGlzdGluZyBmdW5jdGlvbnMgZnJvbSBPaW1vUGh5c2ljcy5EZWJ1Z0RyYXcgd2l0aG91dCBhY3R1YWxseSBpbmhlcml0IGZyb20gdGhlIGNsYXNzLCB0byBhdm9pZCBjb21waWxlciBwcm9ibGVtcy4gXHJcbiAgICAgKiBPdmVycmlkaW5nIHRoZW0gdG8gcmVjZWl2ZSBkZWJ1Z0luZm9ybWF0aW9ucyBpbiB0aGUgZm9ybWF0IHRoZSBwaHlzaWMgZW5naW5lIHByb3ZpZGVzIHRoZW0gYnV0IGhhbmRsaW5nIHRoZSByZW5kZXJpbmcgaW4gdGhlIGZ1ZGdlIGNvbnRleHQuICovXHJcbiAgICBwcml2YXRlIGluaXRpYWxpemVPdmVycmlkZSgpOiB2b2lkIHtcclxuICAgICAgLy9PdmVycmlkZSBwb2ludC9saW5lL3RyaWFuZ2xlIGZ1bmN0aW9ucyBvZiBPaW1vUGh5c2ljcyB3aGljaCBhcmUgdXNlZCB0byBkcmF3IHdpcmVmcmFtZXMgb2Ygb2JqZWN0cywgbGluZXMgb2YgcmF5Y2FzdHMgb3IgdHJpYW5nbGVzIHdoZW4gdGhlIG9iamVjdHMgYXJlIHJlbmRlcmVkIGJ5IHRoZSBwaHlzaWNzIG5vdCBGVURHRSAodW51c2VkKVxyXG5cclxuICAgICAgT0lNTy5EZWJ1Z0RyYXcucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gKF92OiBPSU1PLlZlYzMsIF9jb2xvcjogT0lNTy5WZWMzKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGRlYnVnV3JhcHBlcjogUGh5c2ljc0RlYnVnRHJhdyA9IFBoeXNpY3MuZGVidWdEcmF3OyAvL0dldCB0aGUgY3VzdG9tIHBoeXNpY3MgZGVidWcgY2xhc3MgdG8gaGF2ZSBhY2Nlc3MgdG8gdGhlIGRhdGEuXHJcbiAgICAgICAgaWYgKFBoeXNpY3MubWFpbkNhbSAhPSBudWxsKSB7IC8vb25seSBhY3Qgd2hlbiB0aGVyZSBpcyBhIGNhbWVyYSB0aGF0IGlzIHJlbmRlcmluZ1xyXG4gICAgICAgICAgbGV0IGRhdGE6IEFycmF5PE51bWJlcj4gPSBkZWJ1Z1dyYXBwZXIucG9pbnREYXRhOyAvL2dldCB0aGUgYWxyZWFkeSB3cml0dGVuIGJ1ZmZlciBpbmZvcm1hdGlvbnNcclxuICAgICAgICAgIGRhdGEucHVzaChfdi54LCBfdi55LCBfdi56KTsgLy9Db29yZGluYXRlcyBvZiB0aGUgcG9pbnRcclxuICAgICAgICAgIGRhdGEucHVzaCgwLCAwLCAwKTsgLy9Qb2ludCBOb3JtYWxzIC0gRW1wdHkgc2luY2UgaXQncyBub3QgYSBwb2x5Z29uXHJcbiAgICAgICAgICBkYXRhLnB1c2goX2NvbG9yLngsIF9jb2xvci55LCBfY29sb3Iueik7IC8vQ29sb3Igb2YgdGhlIHBvaW50XHJcbiAgICAgICAgICBkZWJ1Z1dyYXBwZXIubnVtUG9pbnREYXRhKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgT0lNTy5EZWJ1Z0RyYXcucHJvdG90eXBlLmxpbmUgPSBmdW5jdGlvbiAoX3YxOiBPSU1PLlZlYzMsIF92MjogT0lNTy5WZWMzLCBfY29sb3I6IE9JTU8uVmVjMyk6IHZvaWQge1xyXG4gICAgICAgIGxldCBkZWJ1Z1dyYXBwZXI6IFBoeXNpY3NEZWJ1Z0RyYXcgPSBQaHlzaWNzLmRlYnVnRHJhdztcclxuICAgICAgICBpZiAoUGh5c2ljcy5tYWluQ2FtICE9IG51bGwpIHtcclxuICAgICAgICAgIGxldCBkYXRhOiBBcnJheTxudW1iZXI+ID0gZGVidWdXcmFwcGVyLmxpbmVEYXRhO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF92MS54LCBfdjEueSwgX3YxLnopOyAvL1BvaW50IDEgQ29vcmRpbmF0ZXNcclxuICAgICAgICAgIGRhdGEucHVzaCgwLCAwLCAwKTsgLy9QMSBOb3JtYWxzIC0gRW1wdHkgc2luY2UgaXQncyBub3QgYSBwb2x5Z29uXHJcbiAgICAgICAgICBkYXRhLnB1c2goX2NvbG9yLngsIF9jb2xvci55LCBfY29sb3Iueik7IC8vUDEgQ29sb3JcclxuICAgICAgICAgIGRhdGEucHVzaChfdjIueCwgX3YyLnksIF92Mi56KTsgLy9Qb2ludCAyIENvb3JkaW5hdGVzXHJcbiAgICAgICAgICBkYXRhLnB1c2goMCwgMCwgMCk7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX2NvbG9yLngsIF9jb2xvci55LCBfY29sb3Iueik7XHJcbiAgICAgICAgICBkZWJ1Z1dyYXBwZXIubnVtTGluZURhdGErKztcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBPSU1PLkRlYnVnRHJhdy5wcm90b3R5cGUudHJpYW5nbGUgPSBmdW5jdGlvbiAoX3YxOiBPSU1PLlZlYzMsIF92MjogT0lNTy5WZWMzLCBfdjM6IE9JTU8uVmVjMywgX24xOiBPSU1PLlZlYzMsIF9uMjogT0lNTy5WZWMzLCBfbjM6IE9JTU8uVmVjMywgX2NvbG9yOiBPSU1PLlZlYzMpOiB2b2lkIHtcclxuICAgICAgICBsZXQgZGVidWdXcmFwcGVyOiBQaHlzaWNzRGVidWdEcmF3ID0gUGh5c2ljcy5kZWJ1Z0RyYXc7XHJcbiAgICAgICAgaWYgKFBoeXNpY3MubWFpbkNhbSAhPSBudWxsKSB7XHJcbiAgICAgICAgICBsZXQgZGF0YTogQXJyYXk8bnVtYmVyPiA9IGRlYnVnV3JhcHBlci50cmlEYXRhO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF92MS54LCBfdjEueSwgX3YxLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF9uMS54LCBfbjEueSwgX24xLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF9jb2xvci54LCBfY29sb3IueSwgX2NvbG9yLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF92Mi54LCBfdjIueSwgX3YyLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF9uMi54LCBfbjIueSwgX24yLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF9jb2xvci54LCBfY29sb3IueSwgX2NvbG9yLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF92My54LCBfdjMueSwgX3YzLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF9uMy54LCBfbjMueSwgX24zLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF9jb2xvci54LCBfY29sb3IueSwgX2NvbG9yLnopO1xyXG4gICAgICAgICAgZGVidWdXcmFwcGVyLm51bVRyaURhdGErKztcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBzb3VyY2UgY29kZSAoc3RyaW5nKSBvZiB0aGUgaW4gcGh5c2ljc0RlYnVnIHVzZWQgdmVyeSBzaW1wbGUgdmVydGV4U2hhZGVyLlxyXG4gICAgICogIEhhbmRsaW5nIHRoZSBwcm9qZWN0aW9uICh3aGljaCBpbmNsdWRlcywgdmlldy93b3JsZFtpcyBhbHdheXMgaWRlbnRpdHkgaW4gdGhpcyBjYXNlXS9wcm9qZWN0aW9uIGluIEZVREdFKS4gSW5jcmVhc2luZyB0aGUgc2l6ZSBvZiBzaW5nbGUgcG9pbnRzIGRyYXduLlxyXG4gICAgICogIEFuZCB0cmFuc2ZlciBwb3NpdGlvbiBjb2xvciB0byB0aGUgZnJhZ21lbnRTaGFkZXIuICovXHJcbiAgICBwcml2YXRlIHZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYFxyXG5cdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHRcdFx0YXR0cmlidXRlIHZlYzMgYVBvc2l0aW9uO1xyXG5cdFx0XHRhdHRyaWJ1dGUgdmVjMyBhQ29sb3I7XHJcblx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XHJcblx0XHRcdHZhcnlpbmcgdmVjMyB2UG9zaXRpb247XHJcblx0XHRcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xyXG5cdFx0XHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xyXG5cdFx0XHR1bmlmb3JtIG1hdDQgdV9tdHhXb3JsZFRvVmlldztcclxuXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0XHR2UG9zaXRpb24gPSBhUG9zaXRpb247XHJcblx0XHRcdFx0dkNvbG9yID0gYUNvbG9yO1xyXG5cdFx0XHRcdHZOb3JtYWwgPSBhTm9ybWFsO1xyXG5cdFx0XHRcdGdsX1Bvc2l0aW9uID0gdV9tdHhXb3JsZFRvVmlldyAqIHZlYzQoYVBvc2l0aW9uLDEuMCk7XHJcblx0XHRcdFx0Z2xfUG9pbnRTaXplID0gNi4wO1xyXG5cdFx0XHR9YDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIHNvdXJjZSBjb2RlIChzdHJpbmcpIG9mIHRoZSBpbiBwaHlzaWNzRGVidWcgdXNlZCBzdXBlciBzaW1wbGUgZnJhZ21lbnRTaGFkZXIuIFVubGl0IC0gb25seSBjb2xvcml6aW5nIHRoZSBkcmF3biBwaXhlbHMsIG5vcm1hbHMvcG9zaXRpb24gYXJlIGdpdmVuIHRvIG1ha2UgaXQgZXhwYW5kYWJsZSAqL1xyXG4gICAgcHJpdmF0ZSBmcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYFxyXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XHJcblx0XHRcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XHJcblxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh2Q29sb3IsIDEuMCk7XHJcblx0XHRcdH1gO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIHBoeXNpY2FsIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggYSBkZWZpbmVkIGF4ZSBvZiB0cmFuc2xhdGlvbiBhbmQgcm90YXRpb24uIFR3byBEZWdyZWVzIG9mIEZyZWVkb20gaW4gdGhlIGRlZmluZWQgYXhpcy5cclxuICAgKiBUd28gUmlnaWRCb2RpZXMgbmVlZCB0byBiZSBkZWZpbmVkIHRvIHVzZSBpdC4gQSBtb3RvciBjYW4gYmUgZGVmaW5lZCBmb3Igcm90YXRpb24gYW5kIHRyYW5zbGF0aW9uLCBhbG9uZyB3aXRoIHNwcmluZyBzZXR0aW5ncy5cclxuICAgKiBcclxuICAgKiBgYGB0ZXh0XHJcbiAgICogICAgICAgICAgSm9pbnRIb2xkZXIgLSBib2R5QW5jaG9yXHJcbiAgICogICAgICAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkFxyXG4gICAqICAgICAgICAgICAgICAgICAgICDilIIgICDilIJcclxuICAgKiAgICAgICAgICAgPOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgiAgIOKUguKUgOKUgOKUgOKUgOKUgOKUgD4gdGllZCBib2R5LCBzbGlkaW5nIG9uIGF4aXMgPSAxc3QgZGVncmVlIG9mIGZyZWVkb21cclxuICAgKiAgICAgICAgICAgICAgICAgICAg4pSCICAg4pSCICAgICAgICByb3RhdGluZyBhcm91bmQgYXhpcyA9IDJuZCBkZWdyZWUgb2YgZnJlZWRvbSBcclxuICAgKiAgICAgICAgICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSYXHJcbiAgICogYGBgICBcclxuICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEpvaW50Q3lsaW5kcmljYWwgZXh0ZW5kcyBKb2ludEF4aWFsIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBKb2ludC5yZWdpc3RlclN1YmNsYXNzKEpvaW50Q3lsaW5kcmljYWwpO1xyXG5cclxuICAgIHByb3RlY3RlZCBqb2ludDogT0lNTy5DeWxpbmRyaWNhbEpvaW50O1xyXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogT0lNTy5DeWxpbmRyaWNhbEpvaW50Q29uZmlnID0gbmV3IE9JTU8uQ3lsaW5kcmljYWxKb2ludENvbmZpZygpO1xyXG4gICAgcHJvdGVjdGVkIG1vdG9yOiBPSU1PLlRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yO1xyXG5cclxuICAgICNzcHJpbmdEYW1waW5nUm90YXRpb246IG51bWJlciA9IDA7XHJcbiAgICAjc3ByaW5nRnJlcXVlbmN5Um90YXRpb246IG51bWJlciA9IDA7XHJcblxyXG4gICAgI21vdG9yRm9yY2U6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI21heFJvdG9yOiBudW1iZXIgPSAzNjA7XHJcbiAgICAjbWluUm90b3I6IG51bWJlciA9IDA7XHJcbiAgICAjcm90b3JUb3JxdWU6IG51bWJlciA9IDA7XHJcbiAgICAjcm90b3JTcGVlZDogbnVtYmVyID0gMDtcclxuXHJcbiAgICAjcm90b3I6IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3I7XHJcbiAgICAjcm90b3JTcHJpbmdEYW1wZXI6IE9JTU8uU3ByaW5nRGFtcGVyO1xyXG5cclxuICAgIC8qKiBDcmVhdGluZyBhIGN5bGluZHJpY2FsIGpvaW50IGJldHdlZW4gdHdvIENvbXBvbmVudFJpZ2lkYm9kaWVzIG1vdmluZyBvbiBvbmUgYXhpcyBhbmQgcm90YXRpbmcgYXJvdW5kIGFub3RoZXIgYm91bmQgb24gYSBsb2NhbCBhbmNob3Jwb2ludC4gKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYXhpczogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDEsIDApLCBfbG9jYWxBbmNob3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAwKSkge1xyXG4gICAgICBzdXBlcihfYm9keUFuY2hvciwgX2JvZHlUaWVkLCBfYXhpcywgX2xvY2FsQW5jaG9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBzcHJpbmdEYW1waW5nKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHN1cGVyLnNwcmluZ0RhbXBpbmcgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHJhbnNsYXRpb25hbFNwcmluZ0RhbXBlcigpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNwcmluZyBpbiBIei4gQXQgMCB0aGUgc3ByaW5nIGlzIHJpZ2lkLCBlcXVhbHMgbm8gc3ByaW5nLiBUaGUgc21hbGxlciB0aGUgdmFsdWUgdGhlIGxlc3MgcmVzdHJpY3RpdmUgaXMgdGhlIHNwcmluZy5cclxuICAgICovXHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0ZyZXF1ZW5jeShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBzdXBlci5zcHJpbmdGcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHJhbnNsYXRpb25hbFNwcmluZ0RhbXBlcigpLmZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC4gSW5mbHVlbmNpbmcgVE9SUVVFIC8gUk9UQVRJT05cclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0RhbXBpbmdSb3RhdGlvbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRGFtcGluZ1JvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzcHJpbmdEYW1waW5nUm90YXRpb24oX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZ1JvdGF0aW9uID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFJvdGF0aW9uYWxTcHJpbmdEYW1wZXIoKS5kYW1waW5nUmF0aW8gPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gSW5mbHVlbmNpbmcgVE9SUVVFIC8gUk9UQVRJT05cclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3lSb3RhdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRnJlcXVlbmN5Um90YXRpb24oX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRnJlcXVlbmN5Um90YXRpb24gPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0Um90YXRpb25hbFNwcmluZ0RhbXBlcigpLmZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIFVwcGVyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMtQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1heFJvdG9yKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtYXhSb3RvcjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbWF4Um90b3IoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWF4Um90b3IgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0Um90YXRpb25hbExpbWl0TW90b3IoKS51cHBlckxpbWl0ID0gX3ZhbHVlICogQ2FsYy5kZWcycmFkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIExvd2VyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMgQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1pblJvdG9yKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtaW5Sb3RvcjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbWluUm90b3IoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWluUm90b3IgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0Um90YXRpb25hbExpbWl0TW90b3IoKS5sb3dlckxpbWl0ID0gX3ZhbHVlICogQ2FsYy5kZWcycmFkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIHRhcmdldCByb3RhdGlvbmFsIHNwZWVkIG9mIHRoZSBtb3RvciBpbiBtL3MuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHJvdG9yU3BlZWQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JvdG9yU3BlZWQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHJvdG9yU3BlZWQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jcm90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRSb3RhdGlvbmFsTGltaXRNb3RvcigpLm1vdG9yU3BlZWQgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgbWF4aW11bSBtb3RvciB0b3JxdWUgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcm90b3JUb3JxdWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JvdG9yVG9ycXVlO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCByb3RvclRvcnF1ZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyb3RvclRvcnF1ZSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRSb3RhdGlvbmFsTGltaXRNb3RvcigpLm1vdG9yVG9ycXVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBVcHBlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBtYXhNb3RvcihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBzdXBlci5tYXhNb3RvciA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbClcclxuICAgICAgICB0aGlzLmpvaW50LmdldFRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yKCkudXBwZXJMaW1pdCA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBMb3dlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBtaW5Nb3RvcihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBzdXBlci5taW5Nb3RvciA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbClcclxuICAgICAgICB0aGlzLmpvaW50LmdldFRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yKCkubG93ZXJMaW1pdCA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IG1vdG9yU3BlZWQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIubW90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbClcclxuICAgICAgICB0aGlzLmpvaW50LmdldFRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yKCkubW90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBtYXhpbXVtIG1vdG9yIGZvcmNlIGluIE5ld3Rvbi4gZm9yY2UgPD0gMCBlcXVhbHMgZGlzYWJsZWQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1vdG9yRm9yY2UoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yRm9yY2U7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1vdG9yRm9yY2UoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbW90b3JGb3JjZSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUcmFuc2xhdGlvbmFsTGltaXRNb3RvcigpLm1vdG9yRm9yY2UgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNhdmluZy9Mb2FkaW5nXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuI2dldE11dGF0b3IoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmRlbGV0ZUZyb21NdXRhdG9yKF9tdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IsIF9zZWxlY3Rpb24sIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0Sm9pbnQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JvdG9yU3ByaW5nRGFtcGVyID0gbmV3IE9JTU8uU3ByaW5nRGFtcGVyKCkuc2V0U3ByaW5nKHRoaXMuc3ByaW5nRnJlcXVlbmN5Um90YXRpb24sIHRoaXMuc3ByaW5nRGFtcGluZ1JvdGF0aW9uKTtcclxuXHJcbiAgICAgIHRoaXMubW90b3IgPSBuZXcgT0lNTy5UcmFuc2xhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyhzdXBlci5taW5Nb3Rvciwgc3VwZXIubWF4TW90b3IpO1xyXG4gICAgICB0aGlzLm1vdG9yLnNldE1vdG9yKHN1cGVyLm1vdG9yU3BlZWQsIHRoaXMubW90b3JGb3JjZSk7XHJcbiAgICAgIHRoaXMuI3JvdG9yID0gbmV3IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHModGhpcy5taW5Sb3RvciAqIENhbGMuZGVnMnJhZCwgdGhpcy5tYXhSb3RvciAqIENhbGMuZGVnMnJhZCk7XHJcbiAgICAgIHRoaXMuI3JvdG9yLnNldE1vdG9yKHRoaXMucm90b3JTcGVlZCwgdGhpcy5yb3RvclRvcnF1ZSk7XHJcblxyXG4gICAgICB0aGlzLmNvbmZpZyA9IG5ldyBPSU1PLkN5bGluZHJpY2FsSm9pbnRDb25maWcoKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQoKTtcclxuXHJcbiAgICAgIHRoaXMuY29uZmlnLnRyYW5zbGF0aW9uYWxTcHJpbmdEYW1wZXIgPSB0aGlzLnNwcmluZ0RhbXBlcjtcclxuICAgICAgdGhpcy5jb25maWcudHJhbnNsYXRpb25hbExpbWl0TW90b3IgPSB0aGlzLm1vdG9yO1xyXG4gICAgICB0aGlzLmNvbmZpZy5yb3RhdGlvbmFsTGltaXRNb3RvciA9IHRoaXMuI3JvdG9yO1xyXG4gICAgICB0aGlzLmNvbmZpZy5yb3RhdGlvbmFsU3ByaW5nRGFtcGVyID0gdGhpcy4jcm90b3JTcHJpbmdEYW1wZXI7XHJcblxyXG4gICAgICB0aGlzLmpvaW50ID0gbmV3IE9JTU8uQ3lsaW5kcmljYWxKb2ludCh0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHRoaXMuY29uZmlndXJlSm9pbnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAjZ2V0TXV0YXRvciA9ICgpOiBNdXRhdG9yID0+IHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XHJcbiAgICAgICAgbW90b3JGb3JjZTogdGhpcy5tb3RvckZvcmNlLFxyXG4gICAgICAgIHNwcmluZ0RhbXBpbmdSb3RhdGlvbjogdGhpcy5zcHJpbmdEYW1waW5nUm90YXRpb24sXHJcbiAgICAgICAgc3ByaW5nRnJlcXVlbmN5Um90YXRpb246IHRoaXMuc3ByaW5nRnJlcXVlbmN5Um90YXRpb24sXHJcbiAgICAgICAgbWF4Um90b3I6IHRoaXMubWF4Um90b3IsXHJcbiAgICAgICAgbWluUm90b3I6IHRoaXMubWluUm90b3IsXHJcbiAgICAgICAgcm90b3JUb3JxdWU6IHRoaXMucm90b3JUb3JxdWUsXHJcbiAgICAgICAgcm90b3JTcGVlZDogdGhpcy5yb3RvclNwZWVkXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfTtcclxuXHJcbiAgICAjbXV0YXRlID0gKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCA9PiB7XHJcbiAgICAgIHRoaXMubXV0YXRlQmFzZShfbXV0YXRvciwgW1wibW90b3JGb3JjZVwiLCBcInJvdG9yVG9ycXVlXCIsIFwicm90b3JTcGVlZFwiLCBcIm1heFJvdG9yXCIsIFwibWluUm90b3JcIiwgXCJzcHJpbmdEYW1waW5nUm90YXRpb25cIiwgXCJzcHJpbmdGcmVxdWVuY3lSb3RhdGlvblwiLCBcInNwcmluZ0ZyZXF1ZW5jeVwiXSk7XHJcbiAgICB9O1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAgICogQSBwaHlzaWNhbCBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIGEgZGVmaW5lZCBheGUgbW92ZW1lbnQuXHJcbiAgICAgKiBVc2VkIHRvIGNyZWF0ZSBhIHNsaWRpbmcgam9pbnQgYWxvbmcgb25lIGF4aXMuIFR3byBSaWdpZEJvZGllcyBuZWVkIHRvIGJlIGRlZmluZWQgdG8gdXNlIGl0LlxyXG4gICAgICogQSBtb3RvciBjYW4gYmUgZGVmaW5lZCB0byBtb3ZlIHRoZSBjb25uZWN0ZWQgYWxvbmcgdGhlIGRlZmluZWQgYXhpcy4gR3JlYXQgdG8gY29uc3RydWN0IHN0YW5kYXJkIHNwcmluZ3Mgb3IgcGh5c2ljYWwgc2xpZGVycy5cclxuICAgICAqIFxyXG4gICAgICogYGBgdGV4dFxyXG4gICAgICogICAgICAgICAgSm9pbnRIb2xkZXIgLSBib2R5QW5jaG9yXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSQXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAg4pSCICAg4pSCXHJcbiAgICAgKiAgICAgICAgICAgPOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgiAgIOKUguKUgOKUgOKUgOKUgOKUgOKUgD4gdGllZCBib2R5LCBzbGlkaW5nIG9uIG9uZSBBeGlzLCAxIERlZ3JlZSBvZiBGcmVlZG9tXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAg4pSCICAg4pSCXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSYXHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBKb2ludFByaXNtYXRpYyBleHRlbmRzIEpvaW50QXhpYWwge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IEpvaW50LnJlZ2lzdGVyU3ViY2xhc3MoSm9pbnRQcmlzbWF0aWMpO1xyXG5cclxuICAgIHByb3RlY3RlZCBqb2ludDogT0lNTy5QcmlzbWF0aWNKb2ludDtcclxuICAgIHByb3RlY3RlZCBjb25maWc6IE9JTU8uUHJpc21hdGljSm9pbnRDb25maWcgPSBuZXcgT0lNTy5QcmlzbWF0aWNKb2ludENvbmZpZygpO1xyXG4gICAgcHJvdGVjdGVkIG1vdG9yOiBPSU1PLlRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yO1xyXG4gICAgLy9JbnRlcm5hbGx5IHVzZWQgdmFyaWFibGVzIC0gSm9pbnQgUHJvcGVydGllcyB0aGF0IGFyZSB1c2VkIGV2ZW4gd2hlbiBubyBhY3R1YWwgam9pbnQgaXMgY3VycmVudGx5IGV4aXN0ZW50XHJcblxyXG4gICAgI21vdG9yRm9yY2U6IG51bWJlciA9IDA7XHJcblxyXG4gICAgLyoqIENyZWF0aW5nIGEgcHJpc21hdGljIGpvaW50IGJldHdlZW4gdHdvIENvbXBvbmVudFJpZ2lkYm9kaWVzIG9ubHkgbW92aW5nIG9uIG9uZSBheGlzIGJvdW5kIG9uIGEgbG9jYWwgYW5jaG9ycG9pbnQuICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2F4aXM6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAxLCAwKSwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCwgX2F4aXMsIF9sb2NhbEFuY2hvcik7XHJcblxyXG4gICAgICB0aGlzLm1heE1vdG9yID0gMTA7XHJcbiAgICAgIHRoaXMubWluTW90b3IgPSAtMTA7XHJcbiAgICB9XHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIG1heGltdW0gbW90b3IgZm9yY2UgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gVGhpcyBpcyB0aGUgZm9yY2UgdGhhdCB0aGUgbW90b3IgaXMgdXNpbmcgdG8gaG9sZCB0aGUgcG9zaXRpb24sIG9yIHJlYWNoIGl0IGlmIGEgbW90b3JTcGVlZCBpcyBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1vdG9yRm9yY2UoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yRm9yY2U7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1vdG9yRm9yY2UoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbW90b3JGb3JjZSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yKCkubW90b3JGb3JjZSA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgbW90b3JGb3JjZTogdGhpcy5tb3RvckZvcmNlLFxyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5tb3RvckZvcmNlID0gX3NlcmlhbGl6YXRpb24ubW90b3JGb3JjZTtcclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIG11dGF0b3IubW90b3JGb3JjZSA9IHRoaXMubW90b3JGb3JjZTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9tdXRhdG9yLm1vdG9yRm9yY2UpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMubW90b3JGb3JjZSA9IF9tdXRhdG9yLm1vdG9yRm9yY2U7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5tb3RvckZvcmNlO1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IsIF9zZWxlY3Rpb24sIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKiogQWN0dWFsIGNyZWF0aW9uIG9mIGEgam9pbnQgaW4gdGhlIE9pbW9QaHlzaWNzIHN5c3RlbSAqL1xyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdEpvaW50KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLm1vdG9yID0gbmV3IE9JTU8uVHJhbnNsYXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHModGhpcy5taW5Nb3RvciwgdGhpcy5tYXhNb3Rvcik7IC8vQ3JlYXRlIG1vdG9yIHNldHRpbmdzLCB0byBob2xkIHBvc2l0aW9ucywgc2V0IGNvbnN0cmFpbnQgbWluL21heFxyXG4gICAgICB0aGlzLm1vdG9yLnNldE1vdG9yKHRoaXMubW90b3JTcGVlZCwgdGhpcy5tb3RvckZvcmNlKTtcclxuXHJcbiAgICAgIHRoaXMuY29uZmlnID0gbmV3IE9JTU8uUHJpc21hdGljSm9pbnRDb25maWcoKTsgLy9DcmVhdGUgYSBzcGVjaWZpYyBjb25maWcgZm9yIHRoaXMgam9pbnQgdHlwZSB0aGF0IGlzIGNhbGN1bGF0aW5nIHRoZSBsb2NhbCBheGlzIGZvciBib3RoIGJvZGllc1xyXG4gICAgICBzdXBlci5jb25zdHJ1Y3RKb2ludCgpO1xyXG5cclxuICAgICAgdGhpcy5jb25maWcuc3ByaW5nRGFtcGVyID0gdGhpcy5zcHJpbmdEYW1wZXI7IC8vVGVsbGluZyB0aGUgY29uZmlnIHRvIHVzZSB0aGUgbW90b3Ivc3ByaW5nIG9mIHRoZSBGVURHRSBDb21wb25lbnRcclxuICAgICAgdGhpcy5jb25maWcubGltaXRNb3RvciA9IHRoaXMubW90b3I7XHJcblxyXG4gICAgICB0aGlzLmpvaW50ID0gbmV3IE9JTU8uUHJpc21hdGljSm9pbnQodGhpcy5jb25maWcpO1xyXG4gICAgICB0aGlzLmNvbmZpZ3VyZUpvaW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAqIEEgcGh5c2ljYWwgY29ubmVjdGlvbiBiZXR3ZWVuIHR3byBib2RpZXMsIGRlc2lnbmVkIHRvIHNpbXVsYXRlIGJlaGF2aW91ciB3aXRoaW4gYSByZWFsIGJvZHkuIEl0IGhhcyB0d28gYXhpcywgYSBzd2luZyBhbmQgdHdpc3QgYXhpcywgYW5kIGFsc28gdGhlIHBlcnBlbmRpY3VsYXIgYXhpcywgXHJcbiAgICAqIHNpbWlsYXIgdG8gYSBTcGhlcmljYWwgam9pbnQsIGJ1dCBtb3JlIHJlc3RyaWN0aXZlIGluIGl0J3MgYW5nbGVzIGFuZCBvbmx5IHR3byBkZWdyZWVzIG9mIGZyZWVkb20uIFR3byBSaWdpZEJvZGllcyBuZWVkIHRvIGJlIGRlZmluZWQgdG8gdXNlIGl0LiBNb3N0bHkgdXNlZCB0byBjcmVhdGUgaHVtYW5saWtlIGpvaW50cyB0aGF0IGJlaGF2ZSBsaWtlIGEgXHJcbiAgICAqIGxpZmVsZXNzIGJvZHkuXHJcbiAgICAqIGBgYHRleHQgICAgICAgIFxyXG4gICAgKiAgICAgICAgICAgICAgICAgIFxyXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgLSBpdCBjYW4gdHdpc3Qgb24gb25lIGF4aXMgYW5kIHN3aW5nIG9uIGFub3RoZXJcclxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXHJcbiAgICAqICAgICAgICAgeiAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkCDilIIg4pSM4pSA4pSA4pSA4pSQXHJcbiAgICAqICAgICAgICAg4oaRICAgICAgICAgICAg4pSCICAg4pSCIOKGkyDilIIgICDilIIgICAgICAgIGUuZy4geiA9IFR3aXN0QXhpcywgaXQgY2FuIHJvdGF0ZSBpbi1pdHNlbGYgYXJvdW5kIHRoaXMgYXhpcyBcclxuICAgICogICAgLXgg4oaQ4pSA4pS84pSA4oaSIHggICAgICAgIOKUgiAgIOKUgiB4IOKUgiAgIOKUgiAgICAgICAgZS5nLiB4ID0gU3dpbmdBeGlzLCBpdCBjYW4gcm90YXRlIGFuY2hvcmVkIGFyb3VuZCB0aGUgYmFzZSBvbiB0aGlzIGF4aXMgICBcclxuICAgICogICAgICAgICDihpMgICAgICAgICAgICDilIIgICDilIIgICDilIIgICDilIIgICAgICAgICAgIFxyXG4gICAgKiAgICAgICAgLXogICAgICAgICAgICDilJTilIDilIDilIDilJggICDilJTilIDilIDilIDilJggICAgICAgICBlLmcuIHlvdSBjYW4gdHdpc3QgdGhlIGxlZyBpbi1pdHNlbGYgdG8gYSBjZXJ0YWluIGRlZ3JlZSxcclxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dCBhbHNvIHJvdGF0ZSBpdCBmb3J3YXJkL2JhY2t3YXJkL2xlZnQvcmlnaHQgdG8gYSBjZXJ0YWluIGRlZ3JlZVxyXG4gICAgKiAgICAgICAgICAgICAgICBib2R5QW5jaG9yICAgICAgICAgIGJvZHlUaWVkXHJcbiAgICAqICAgICAgICAgICAgICAoZS5nLiBwZWx2aXMpICAgICAgICAgKGUuZy4gdXBwZXItbGVnKVxyXG4gICAgKiBcclxuICAgICogYGBgXHJcbiAgICAqIFR3aXN0IGVxdWFscyBhIHJvdGF0aW9uIGFyb3VuZCBhIHBvaW50IHdpdGhvdXQgbW92aW5nIG9uIGFuIGF4aXMuXHJcbiAgICAqIFN3aW5nIGVxdWFscyBhIHJvdGF0aW9uIG9uIGEgcG9pbnQgd2l0aCBhIG1vdmluZyBsb2NhbCBheGlzLlxyXG4gICAgICogQGF1dGhvciBNYXJrbyBGZWhyZW5iYWNoLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAgKi9cclxuICBleHBvcnQgY2xhc3MgSm9pbnRSYWdkb2xsIGV4dGVuZHMgSm9pbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IEpvaW50LnJlZ2lzdGVyU3ViY2xhc3MoSm9pbnRSYWdkb2xsKTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgam9pbnQ6IE9JTU8uUmFnZG9sbEpvaW50O1xyXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogT0lNTy5SYWdkb2xsSm9pbnRDb25maWcgPSBuZXcgT0lNTy5SYWdkb2xsSm9pbnRDb25maWcoKTtcclxuXHJcbiAgICAjc3ByaW5nRGFtcGluZ1R3aXN0OiBudW1iZXIgPSAwO1xyXG4gICAgI3NwcmluZ0ZyZXF1ZW5jeVR3aXN0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNzcHJpbmdEYW1waW5nU3dpbmc6IG51bWJlciA9IDA7XHJcbiAgICAjc3ByaW5nRnJlcXVlbmN5U3dpbmc6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI21heE1vdG9yVHdpc3Q6IG51bWJlciA9IDM2MDtcclxuICAgICNtaW5Nb3RvclR3aXN0OiBudW1iZXIgPSAwO1xyXG4gICAgI21vdG9yVG9ycXVlVHdpc3Q6IG51bWJlciA9IDA7XHJcbiAgICAjbW90b3JTcGVlZFR3aXN0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNtb3RvclR3aXN0OiBPSU1PLlJvdGF0aW9uYWxMaW1pdE1vdG9yO1xyXG4gICAgI3NwcmluZ0RhbXBlclR3aXN0OiBPSU1PLlNwcmluZ0RhbXBlcjtcclxuICAgICNzcHJpbmdEYW1wZXJTd2luZzogT0lNTy5TcHJpbmdEYW1wZXI7XHJcbiAgICAjYXhpc0ZpcnN0OiBPSU1PLlZlYzM7XHJcbiAgICAjYXhpc1NlY29uZDogT0lNTy5WZWMzO1xyXG5cclxuICAgICNtYXhBbmdsZUZpcnN0OiBudW1iZXIgPSAwO1xyXG4gICAgI21heEFuZ2xlU2Vjb25kOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYXhpc0ZpcnN0OiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMSwgMCwgMCksIF9heGlzU2Vjb25kOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMSksIF9sb2NhbEFuY2hvcjogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDAsIDApKSB7XHJcbiAgICAgIHN1cGVyKF9ib2R5QW5jaG9yLCBfYm9keVRpZWQpO1xyXG4gICAgICB0aGlzLmF4aXNGaXJzdCA9IF9heGlzRmlyc3Q7XHJcbiAgICAgIHRoaXMuYXhpc1NlY29uZCA9IF9heGlzU2Vjb25kO1xyXG4gICAgICB0aGlzLmFuY2hvciA9IF9sb2NhbEFuY2hvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXhpcyBjb25uZWN0aW5nIHRoZSB0aGUgdHdvIHtAbGluayBOb2RlfXMgZS5nLiBWZWN0b3IzKDAsMSwwKSB0byBoYXZlIGEgdXB3YXJkIGNvbm5lY3Rpb24uXHJcbiAgICAgKiAgV2hlbiBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIHRoZSBqb2ludCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBheGlzRmlyc3QoKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLiNheGlzRmlyc3QueCwgdGhpcy4jYXhpc0ZpcnN0LnksIHRoaXMuI2F4aXNGaXJzdC56KTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgYXhpc0ZpcnN0KF92YWx1ZTogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLiNheGlzRmlyc3QgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgYXhpcyBjb25uZWN0aW5nIHRoZSB0aGUgdHdvIHtAbGluayBOb2RlfXMgZS5nLiBWZWN0b3IzKDAsMSwwKSB0byBoYXZlIGEgdXB3YXJkIGNvbm5lY3Rpb24uXHJcbiAgICAqICBXaGVuIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gdGhlIGpvaW50IG5lZWRzIHRvIGJlIHJlY29ubmVjdGVkLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBnZXQgYXhpc1NlY29uZCgpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuI2F4aXNTZWNvbmQueCwgdGhpcy4jYXhpc1NlY29uZC55LCB0aGlzLiNheGlzU2Vjb25kLnopO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBheGlzU2Vjb25kKF92YWx1ZTogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLiNheGlzU2Vjb25kID0gbmV3IE9JTU8uVmVjMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KTtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXhpbXVtIGFuZ2xlIG9mIHJvdGF0aW9uIGFsb25nIHRoZSBmaXJzdCBheGlzLiBWYWx1ZSBuZWVkcyB0byBiZSBwb3NpdGl2ZS4gQ2hhbmdlcyBkbyByZWJ1aWxkIHRoZSBqb2ludFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1heEFuZ2xlRmlyc3RBeGlzKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtYXhBbmdsZUZpcnN0ICogQ2FsYy5yYWQyZGVnO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBtYXhBbmdsZUZpcnN0QXhpcyhfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtYXhBbmdsZUZpcnN0ID0gX3ZhbHVlICogQ2FsYy5kZWcycmFkO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gYW5nbGUgb2Ygcm90YXRpb24gYWxvbmcgdGhlIHNlY29uZCBheGlzLiBWYWx1ZSBuZWVkcyB0byBiZSBwb3NpdGl2ZS4gQ2hhbmdlcyBkbyByZWJ1aWxkIHRoZSBqb2ludFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1heEFuZ2xlU2Vjb25kQXhpcygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWF4QW5nbGVTZWNvbmQgKiBDYWxjLnJhZDJkZWc7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1heEFuZ2xlU2Vjb25kQXhpcyhfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtYXhBbmdsZVNlY29uZCA9IF92YWx1ZSAqIENhbGMuZGVnMnJhZDtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkYW1waW5nIG9mIHRoZSBzcHJpbmcuIDEgZXF1YWxzIGNvbXBsZXRseSBkYW1wZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc3ByaW5nRGFtcGluZ1R3aXN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdEYW1waW5nVHdpc3Q7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0RhbXBpbmdUd2lzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdEYW1waW5nVHdpc3QgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHdpc3RTcHJpbmdEYW1wZXIoKS5kYW1waW5nUmF0aW8gPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gVGhlIHNtYWxsZXIgdGhlIHZhbHVlIHRoZSBsZXNzIHJlc3RyaWN0aXZlIGlzIHRoZSBzcHJpbmcuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGdldCBzcHJpbmdGcmVxdWVuY3lUd2lzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5VHdpc3Q7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0ZyZXF1ZW5jeVR3aXN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVR3aXN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFR3aXN0U3ByaW5nRGFtcGVyKCkuZnJlcXVlbmN5ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBzcHJpbmdEYW1waW5nU3dpbmcoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmdTd2luZztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRGFtcGluZ1N3aW5nKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0RhbXBpbmdTd2luZyA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTd2luZ1NwcmluZ0RhbXBlcigpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNwcmluZyBpbiBIei4gQXQgMCB0aGUgc3ByaW5nIGlzIHJpZ2lkLCBlcXVhbHMgbm8gc3ByaW5nLiBUaGUgc21hbGxlciB0aGUgdmFsdWUgdGhlIGxlc3MgcmVzdHJpY3RpdmUgaXMgdGhlIHNwcmluZy5cclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0ZyZXF1ZW5jeVN3aW5nKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3lTd2luZztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRnJlcXVlbmN5U3dpbmcoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRnJlcXVlbmN5U3dpbmcgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0U3dpbmdTcHJpbmdEYW1wZXIoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIFVwcGVyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMtQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1heE1vdG9yVHdpc3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21heE1vdG9yVHdpc3QgKiBDYWxjLnJhZDJkZWc7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1heE1vdG9yVHdpc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgX3ZhbHVlICo9IENhbGMuZGVnMnJhZDtcclxuICAgICAgdGhpcy4jbWF4TW90b3JUd2lzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUd2lzdExpbWl0TW90b3IoKS51cHBlckxpbWl0ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIExvd2VyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMgQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1pbk1vdG9yVHdpc3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21pbk1vdG9yVHdpc3QgKiBDYWxjLnJhZDJkZWc7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1pbk1vdG9yVHdpc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgX3ZhbHVlICo9IENhbGMuZGVnMnJhZDtcclxuICAgICAgdGhpcy4jbWluTW90b3JUd2lzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUd2lzdExpbWl0TW90b3IoKS5sb3dlckxpbWl0ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSB0YXJnZXQgcm90YXRpb25hbCBzcGVlZCBvZiB0aGUgbW90b3IgaW4gbS9zLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtb3RvclNwZWVkVHdpc3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yU3BlZWRUd2lzdDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbW90b3JTcGVlZFR3aXN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21vdG9yU3BlZWRUd2lzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUd2lzdExpbWl0TW90b3IoKS5tb3RvclNwZWVkID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBtYXhpbXVtIG1vdG9yIHRvcnF1ZSBpbiBOZXd0b24uIGZvcmNlIDw9IDAgZXF1YWxzIGRpc2FibGVkLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtb3RvclRvcnF1ZVR3aXN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtb3RvclRvcnF1ZVR3aXN0O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBtb3RvclRvcnF1ZVR3aXN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21vdG9yVG9ycXVlVHdpc3QgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHdpc3RMaW1pdE1vdG9yKCkubW90b3JUb3JxdWUgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogSWYgdGhlIHR3byBjb25uZWN0ZWQgUmlnaWRCb2RpZXMgY29sbGlkZSB3aXRoIGVhdGggb3RoZXIuIChEZWZhdWx0ID0gZmFsc2UpXHJcbiAgICAgKi9cclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gU2F2aW5nL0xvYWRpbmdcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy4jZ2V0TXV0YXRvcigpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmF4aXNGaXJzdCA9IHRoaXMuYXhpc0ZpcnN0LnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmF4aXNTZWNvbmQgPSB0aGlzLmF4aXNTZWNvbmQuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgdGhpcy5heGlzRmlyc3QuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYXhpc0ZpcnN0KTtcclxuICAgICAgYXdhaXQgdGhpcy5heGlzU2Vjb25kLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmF4aXNTZWNvbmQpO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5heGlzRmlyc3QpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMuYXhpc0ZpcnN0ID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmF4aXNGaXJzdCkpKTtcclxuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IuYXhpc1NlY29uZCkgIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgdGhpcy5heGlzU2Vjb25kID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmF4aXNTZWNvbmQpKSk7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5heGlzRmlyc3Q7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5heGlzU2Vjb25kO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmRlbGV0ZUZyb21NdXRhdG9yKF9tdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IsIF9zZWxlY3Rpb24sIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIG11dGF0b3IuYXhpc0ZpcnN0ID0gdGhpcy5heGlzRmlyc3QuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBtdXRhdG9yLmF4aXNTZWNvbmQgPSB0aGlzLmF4aXNTZWNvbmQuZ2V0TXV0YXRvcigpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGVyVHdpc3QgPSBuZXcgT0lNTy5TcHJpbmdEYW1wZXIoKS5zZXRTcHJpbmcodGhpcy5zcHJpbmdGcmVxdWVuY3lUd2lzdCwgdGhpcy5zcHJpbmdEYW1waW5nVHdpc3QpO1xyXG4gICAgICB0aGlzLiNzcHJpbmdEYW1wZXJTd2luZyA9IG5ldyBPSU1PLlNwcmluZ0RhbXBlcigpLnNldFNwcmluZyh0aGlzLnNwcmluZ0ZyZXF1ZW5jeVN3aW5nLCB0aGlzLnNwcmluZ0RhbXBpbmdTd2luZyk7XHJcblxyXG4gICAgICB0aGlzLiNtb3RvclR3aXN0ID0gbmV3IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHModGhpcy5taW5Nb3RvclR3aXN0LCB0aGlzLm1heE1vdG9yVHdpc3QpO1xyXG4gICAgICB0aGlzLiNtb3RvclR3aXN0LnNldE1vdG9yKHRoaXMubW90b3JTcGVlZFR3aXN0LCB0aGlzLm1vdG9yVG9ycXVlVHdpc3QpO1xyXG5cclxuICAgICAgdGhpcy5jb25maWcgPSBuZXcgT0lNTy5SYWdkb2xsSm9pbnRDb25maWcoKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQodGhpcy5heGlzRmlyc3QsIHRoaXMuYXhpc1NlY29uZCk7XHJcbiAgICAgIHRoaXMuY29uZmlnLnN3aW5nU3ByaW5nRGFtcGVyID0gdGhpcy4jc3ByaW5nRGFtcGVyU3dpbmc7XHJcbiAgICAgIHRoaXMuY29uZmlnLnR3aXN0U3ByaW5nRGFtcGVyID0gdGhpcy4jc3ByaW5nRGFtcGVyVHdpc3Q7XHJcbiAgICAgIHRoaXMuY29uZmlnLnR3aXN0TGltaXRNb3RvciA9IHRoaXMuI21vdG9yVHdpc3Q7XHJcbiAgICAgIHRoaXMuY29uZmlnLm1heFN3aW5nQW5nbGUxID0gdGhpcy4jbWF4QW5nbGVGaXJzdDtcclxuICAgICAgdGhpcy5jb25maWcubWF4U3dpbmdBbmdsZTIgPSB0aGlzLiNtYXhBbmdsZVNlY29uZDtcclxuXHJcbiAgICAgIHRoaXMuam9pbnQgPSBuZXcgT0lNTy5SYWdkb2xsSm9pbnQodGhpcy5jb25maWcpO1xyXG4gICAgICBzdXBlci5jb25maWd1cmVKb2ludCgpO1xyXG4gICAgfVxyXG5cclxuICAgICNnZXRNdXRhdG9yID0gKCk6IE11dGF0b3IgPT4ge1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICBtYXhBbmdsZUZpcnN0OiB0aGlzLiNtYXhBbmdsZUZpcnN0LFxyXG4gICAgICAgIG1heEFuZ2xlU2Vjb25kOiB0aGlzLiNtYXhBbmdsZVNlY29uZCxcclxuICAgICAgICBzcHJpbmdEYW1waW5nVHdpc3Q6IHRoaXMuc3ByaW5nRGFtcGluZ1R3aXN0LFxyXG4gICAgICAgIHNwcmluZ0ZyZXF1ZW5jeVR3aXN0OiB0aGlzLnNwcmluZ0ZyZXF1ZW5jeVR3aXN0LFxyXG4gICAgICAgIHNwcmluZ0RhbXBpbmdTd2luZzogdGhpcy5zcHJpbmdEYW1waW5nU3dpbmcsXHJcbiAgICAgICAgc3ByaW5nRnJlcXVlbmN5U3dpbmc6IHRoaXMuc3ByaW5nRnJlcXVlbmN5U3dpbmcsXHJcbiAgICAgICAgbWF4TW90b3JUd2lzdDogdGhpcy4jbWF4TW90b3JUd2lzdCxcclxuICAgICAgICBtaW5Nb3RvclR3aXN0OiB0aGlzLiNtaW5Nb3RvclR3aXN0LFxyXG4gICAgICAgIG1vdG9yU3BlZWRUd2lzdDogdGhpcy5tb3RvclNwZWVkVHdpc3QsXHJcbiAgICAgICAgbW90b3JUb3JxdWVUd2lzdDogdGhpcy5tb3RvclRvcnF1ZVR3aXN0XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfTtcclxuXHJcbiAgICAjbXV0YXRlID0gKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9tdXRhdG9yLm1heEFuZ2xlRmlyc3QpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMuI21heEFuZ2xlRmlyc3QgPSBfbXV0YXRvci5tYXhBbmdsZUZpcnN0O1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5tYXhBbmdsZVNlY29uZCkgIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgdGhpcy4jbWF4QW5nbGVTZWNvbmQgPSBfbXV0YXRvci5tYXhBbmdsZVNlY29uZDtcclxuICAgICAgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBbXHJcbiAgICAgICAgXCJzcHJpbmdEYW1waW5nVHdpc3RcIiwgXCJzcHJpbmdGcmVxdWVuY3lUd2lzdFwiLCBcInNwcmluZ0RhbXBpbmdTd2luZ1wiLCBcInNwcmluZ0ZyZXF1ZW5jeVN3aW5nXCIsIFwibWF4TW90b3JUd2lzdFwiLCBcIm1pbk1vdG9yVHdpc3RcIiwgXCJtb3RvclNwZWVkVHdpc3RcIiwgXCJtb3RvclRvcnF1ZVR3aXN0XCJcclxuICAgICAgXSk7XHJcbiAgICB9O1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAgICogQSBwaHlzaWNhbCBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIGEgZGVmaW5lZCBheGUgb2Ygcm90YXRpb24uIEFsc28ga25vd24gYXMgSElOR0Ugam9pbnQuXHJcbiAgICAgKiBUd28gUmlnaWRCb2RpZXMgbmVlZCB0byBiZSBkZWZpbmVkIHRvIHVzZSBpdC4gQSBtb3RvciBjYW4gYmUgZGVmaW5lZCB0byByb3RhdGUgdGhlIGNvbm5lY3RlZCBhbG9uZyB0aGUgZGVmaW5lZCBheGlzLlxyXG4gICAgICogXHJcbiAgICAgKiBgYGB0ZXh0ICAgICAgICBcclxuICAgICAqICAgICAgICAgICAgICAgICAgcm90YXRpb24gYXhpcywgMXN0IERlZ3JlZSBvZiBmcmVlZG9tXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAg4oaRXHJcbiAgICAgKiAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkOKUguKUjOKUgOKUgOKUgOKUgOKUkCAgICAgXHJcbiAgICAgKiAgICAgICAgICAgICAgIOKUgiAgIOKUguKUguKUgiAgICDilIIgIFxyXG4gICAgICogICAgICAgICAgICAgICDilIIgICDilILilILilIIgICAg4pSCIFxyXG4gICAgICogICAgICAgICAgICAgICDilIIgICDilILilILilIIgICAg4pSCIFxyXG4gICAgICogICAgICAgICAgICAgICDilJTilIDilIDilIDilJjilILilJTilIDilIDilIDilIDilJhcclxuICAgICAqICAgICAgICAgICAgICAgICAgICDilIIgICBcclxuICAgICAqICAgICAgYm9keUFuY2hvciAgICAgICAgIGJvZHlUaWVkXHJcbiAgICAgKiAgIChlLmcuIERvb3JoaW5nZSkgICAgICAgKGUuZy4gRG9vcilcclxuICAgICAqIGBgYFxyXG4gICAgICogQGF1dGhvciBNYXJrbyBGZWhyZW5iYWNoLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEpvaW50UmV2b2x1dGUgZXh0ZW5kcyBKb2ludEF4aWFsIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBKb2ludC5yZWdpc3RlclN1YmNsYXNzKEpvaW50UmV2b2x1dGUpO1xyXG5cclxuICAgIHByb3RlY3RlZCBqb2ludDogT0lNTy5SZXZvbHV0ZUpvaW50O1xyXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogT0lNTy5SZXZvbHV0ZUpvaW50Q29uZmlnID0gbmV3IE9JTU8uUmV2b2x1dGVKb2ludENvbmZpZygpO1xyXG5cclxuICAgICNtb3RvclRvcnF1ZTogbnVtYmVyID0gMDtcclxuICAgICNyb3RvcjogT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2F4aXM6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAxLCAwKSwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCwgX2F4aXMsIF9sb2NhbEFuY2hvcik7XHJcblxyXG4gICAgICB0aGlzLm1heE1vdG9yID0gMzYwO1xyXG4gICAgICB0aGlzLm1pbk1vdG9yID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgVXBwZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcy1BbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgbWF4TW90b3IoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIubWF4TW90b3IgPSBfdmFsdWU7XHJcbiAgICAgIF92YWx1ZSAqPSBDYWxjLmRlZzJyYWQ7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50KVxyXG4gICAgICAgIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcigpLnVwcGVyTGltaXQgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgTG93ZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcyBBbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgbWluTW90b3IoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIubWluTW90b3IgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50KVxyXG4gICAgICAgIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcigpLmxvd2VyTGltaXQgPSBfdmFsdWUgKiBDYWxjLmRlZzJyYWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIG1heGltdW0gbW90b3IgZm9yY2UgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbW90b3JUb3JxdWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yVG9ycXVlO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBtb3RvclRvcnF1ZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtb3RvclRvcnF1ZSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yKCkubW90b3JUb3JxdWUgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogSWYgdGhlIHR3byBjb25uZWN0ZWQgUmlnaWRCb2RpZXMgY29sbGlkZSB3aXRoIGVhdGggb3RoZXIuIChEZWZhdWx0ID0gZmFsc2UpXHJcbiAgICAgKi9cclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gU2F2aW5nL0xvYWRpbmdcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIG1vdG9yVG9ycXVlOiB0aGlzLm1vdG9yVG9ycXVlLFxyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5tb3RvclRvcnF1ZSA9IF9zZXJpYWxpemF0aW9uLm1vdG9yVG9ycXVlO1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IoKTtcclxuICAgICAgbXV0YXRvci5tb3RvclRvcnF1ZSA9IHRoaXMubW90b3JUb3JxdWU7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5tb3RvclRvcnF1ZSkgIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgdGhpcy5tb3RvclRvcnF1ZSA9IF9tdXRhdG9yLm1vdG9yVG9ycXVlO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IubW90b3JUb3JxdWU7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcm90b3IgPSBuZXcgT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyhzdXBlci5taW5Nb3RvciAqIENhbGMuZGVnMnJhZCwgc3VwZXIubWF4TW90b3IgKiBDYWxjLmRlZzJyYWQpO1xyXG4gICAgICB0aGlzLiNyb3Rvci5zZXRNb3Rvcih0aGlzLm1vdG9yU3BlZWQsIHRoaXMubW90b3JUb3JxdWUpO1xyXG5cclxuICAgICAgdGhpcy5jb25maWcgPSBuZXcgT0lNTy5SZXZvbHV0ZUpvaW50Q29uZmlnKCk7XHJcbiAgICAgIHN1cGVyLmNvbnN0cnVjdEpvaW50KCk7XHJcblxyXG4gICAgICB0aGlzLmNvbmZpZy5zcHJpbmdEYW1wZXIgPSB0aGlzLnNwcmluZ0RhbXBlcjtcclxuICAgICAgdGhpcy5jb25maWcubGltaXRNb3RvciA9IHRoaXMuI3JvdG9yO1xyXG5cclxuICAgICAgdGhpcy5qb2ludCA9IG5ldyBPSU1PLlJldm9sdXRlSm9pbnQodGhpcy5jb25maWcpO1xyXG4gICAgICB0aGlzLmNvbmZpZ3VyZUpvaW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAgKiBBIHBoeXNpY2FsIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggdGhyZWUgRGVncmVlcyBvZiBGcmVlZG9tLCBhbHNvIGtub3duIGFzIGJhbGwgYW5kIHNvY2tldCBqb2ludC4gVHdvIGJvZGllcyBjb25uZWN0ZWQgYXQgdGhlaXIgYW5jaG9yIGJ1dCBmcmVlIHRvIHJvdGF0ZS5cclxuICAgICAqIFVzZWQgZm9yIHRoaW5ncyBsaWtlIHRoZSBjb25uZWN0aW9uIG9mIGJvbmVzIGluIHRoZSBodW1hbiBzaG91bGRlciAoaWYgc2ltcGxpZmllZCwgZWxzZSBiZXR0ZXIgdXNlIEpvaW50UmFnZG9sbCkuIFR3byBSaWdpZEJvZGllcyBuZWVkIHRvIGJlIGRlZmluZWQgdG8gdXNlIGl0LiBPbmx5IHNwcmluZyBzZXR0aW5ncyBjYW4gYmUgZGVmaW5lZC5cclxuICAgICAqIDMgRGVncmVlcyBhcmUgc3dpbmcgaG9yaXpvbnRhbCwgc3dpbmcgdmVydGljYWwgYW5kIHR3aXN0LlxyXG4gICAgICogXHJcbiAgICAgKiBgYGB0ZXh0XHJcbiAgICAgKiAgICAgICAgICAgICAgSm9pbnRIb2xkZXJcclxuICAgICAqICAgICAgICAgeiAgICAgIGJvZHlBbmNob3IgKGUuZy4gSHVtYW4tU2hvdWxkZXIpICAgICBcclxuICAgICAqICAgICAgeSAg4oaRICAgICAgICAgIFxyXG4gICAgICogICAgICAgIFxcfCAgICAgICAgICDilIDilIDilIAo4peP4pSA4pSA4pSAXHJcbiAgICAgKiAgLXggPC0tLXwtLS0+IHggICAgICAgICAgIGJvZHlUaWVkICAgICAgICBcclxuICAgICAqICAgICAgICAgfFxcICAgICAgICAgICAgICAgIChlLmcuIFVwcGVyLUFybSkgXHJcbiAgICAgKiAgICAgICAgIOKGkyAteSAgICAgICBcclxuICAgICAqICAgICAgICAteiAgICAgICAgICBcclxuICAgICAqIGBgYFxyXG4gICAgICogQGF1dGhvciBNYXJrbyBGZWhyZW5iYWNoLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEpvaW50U3BoZXJpY2FsIGV4dGVuZHMgSm9pbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IEpvaW50LnJlZ2lzdGVyU3ViY2xhc3MoSm9pbnRTcGhlcmljYWwpO1xyXG5cclxuICAgIHByb3RlY3RlZCBqb2ludDogT0lNTy5TcGhlcmljYWxKb2ludDtcclxuICAgIHByb3RlY3RlZCBjb25maWc6IE9JTU8uU3BoZXJpY2FsSm9pbnRDb25maWcgPSBuZXcgT0lNTy5TcGhlcmljYWxKb2ludENvbmZpZygpO1xyXG5cclxuICAgICNzcHJpbmdEYW1waW5nOiBudW1iZXIgPSAwO1xyXG4gICAgI3NwcmluZ0ZyZXF1ZW5jeTogbnVtYmVyID0gMDtcclxuICAgICNzcHJpbmdEYW1wZXI6IE9JTU8uU3ByaW5nRGFtcGVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfbG9jYWxBbmNob3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAwKSkge1xyXG4gICAgICBzdXBlcihfYm9keUFuY2hvciwgX2JvZHlUaWVkKTtcclxuICAgICAgdGhpcy5hbmNob3IgPSBuZXcgVmVjdG9yMyhfbG9jYWxBbmNob3IueCwgX2xvY2FsQW5jaG9yLnksIF9sb2NhbEFuY2hvci56KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBzcHJpbmdEYW1waW5nKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdEYW1waW5nO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzcHJpbmdEYW1waW5nKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0RhbXBpbmcgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0U3ByaW5nRGFtcGVyKCkuZGFtcGluZ1JhdGlvID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyZXF1ZW5jeSBvZiB0aGUgc3ByaW5nIGluIEh6LiBBdCAwIHRoZSBzcHJpbmcgaXMgcmlnaWQsIGVxdWFscyBubyBzcHJpbmcuIFRoZSBzbWFsbGVyIHRoZSB2YWx1ZSB0aGUgbGVzcyByZXN0cmljdGl2ZSBpcyB0aGUgc3ByaW5nLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc3ByaW5nRnJlcXVlbmN5KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3k7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0ZyZXF1ZW5jeShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdGcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0U3ByaW5nRGFtcGVyKCkuZnJlcXVlbmN5ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNhdmluZy9Mb2FkaW5nXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBzcHJpbmdEYW1waW5nOiB0aGlzLnNwcmluZ0RhbXBpbmcsXHJcbiAgICAgICAgc3ByaW5nRnJlcXVlbmN5OiB0aGlzLnNwcmluZ0ZyZXF1ZW5jeSxcclxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuc3ByaW5nRGFtcGluZyA9IF9zZXJpYWxpemF0aW9uLnNwcmluZ0RhbXBpbmc7XHJcbiAgICAgIHRoaXMuc3ByaW5nRnJlcXVlbmN5ID0gX3NlcmlhbGl6YXRpb24uc3ByaW5nRnJlcXVlbmN5O1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IoKTtcclxuICAgICAgbXV0YXRvci5zcHJpbmdEYW1waW5nID0gdGhpcy5zcHJpbmdEYW1waW5nO1xyXG4gICAgICBtdXRhdG9yLnNwcmluZ0ZyZXF1ZW5jeSA9IHRoaXMuc3ByaW5nRnJlcXVlbmN5O1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBbXCJzcHJpbmdEYW1waW5nXCIsIFwic3ByaW5nRnJlcXVlbmN5XCJdKTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNwcmluZ0RhbXBpbmc7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zcHJpbmdGcmVxdWVuY3k7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGVyID0gbmV3IE9JTU8uU3ByaW5nRGFtcGVyKCkuc2V0U3ByaW5nKHRoaXMuc3ByaW5nRnJlcXVlbmN5LCB0aGlzLnNwcmluZ0RhbXBpbmcpO1xyXG4gICAgICB0aGlzLmNvbmZpZyA9IG5ldyBPSU1PLlNwaGVyaWNhbEpvaW50Q29uZmlnKCk7XHJcbiAgICAgIHN1cGVyLmNvbnN0cnVjdEpvaW50KCk7XHJcbiAgICAgIHRoaXMuY29uZmlnLnNwcmluZ0RhbXBlciA9IHRoaXMuI3NwcmluZ0RhbXBlcjtcclxuXHJcbiAgICAgIHRoaXMuam9pbnQgPSBuZXcgT0lNTy5TcGhlcmljYWxKb2ludCh0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHN1cGVyLmNvbmZpZ3VyZUpvaW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAgKiBBIHBoeXNpY2FsIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggdHdvIGRlZmluZWQgYXhpcyAobm9ybWFsbHkgZS5nLiAoMCwwLDEpIGFuZCByb3RhdGlvbigxLDAsMCkpLCB0aGV5IHNoYXJlIHRoZSBzYW1lIGFuY2hvciBhbmQgaGF2ZSBmcmVlIHJvdGF0aW9uLCBidXQgdHJhbnNmZXIgdGhlIHR3aXN0LlxyXG4gICAgICogSW4gcmVhbGl0eSB1c2VkIGluIGNhcnMgdG8gdHJhbnNmZXIgdGhlIG1vcmUgc3RhYmxlIHN0YXRpb25hcnkgZm9yY2Ugb24gdGhlIHZlbG9jaXR5IGF4aXMgdG8gdGhlIGJ1bXBpbmcsIGRhbXBlZCBtb3Zpbmcgd2hlZWwuIFR3byBSaWdpZEJvZGllcyBuZWVkIHRvIGJlIGRlZmluZWQgdG8gdXNlIGl0LlxyXG4gICAgICogVGhlIHR3byBtb3RvcnMgY2FuIGJlIGRlZmluZWQgZm9yIHRoZSB0d28gcm90YXRpb24gYXhpcywgYWxvbmcgd2l0aCBzcHJpbmdzLiBcclxuICAgICAqIGBgYHRleHQgICAgICAgIFxyXG4gICAgICogICAgICAgICAgICAgICAgICBcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciAtIHR3aXN0IGlzIHRyYW5zZmVyZWQgYmV0d2VlbiBib2RpZXNcclxuICAgICAqICAgICAgICAgeiAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgKiAgICAgICAgIOKGkSAgICAgICAgICAgIC0tLS0tICB8ICAtLS0tLS0tLS0tLS1cclxuICAgICAqICAgICAgICAgfCAgICAgICAgICAgfCAgICAgfCDihpMgfCAgICAgICAgICAgIHwgXHJcbiAgICAgKiAgLXggPC0tLXwtLS0+IHggICAgIHwgICAgIHwgeCB8ICAgICAgICAgICAgfCAgICAgICAgICAgZS5nLiB3aGVlbCBjYW4gc3RpbGwgdHVybiB1cC9kb3duLCBcclxuICAgICAqICAgICAgICAgfCAgICAgICAgICAgfCAgICAgfCAgIHwgICAgICAgICAgICB8ICAgICAgICAgICBsZWZ0IHJpZ2h0IGJ1dCB0cmFuc2ZlcmluZyBpdCdzIHJvdGF0aW9uIG9uIHRvIHRoZSB3aGVlbC1heGlzLlxyXG4gICAgICogICAgICAgICDihpMgICAgICAgICAgICAtLS0tLSAgICAgLS0tLS0tLS0tLS0tXHJcbiAgICAgKiAgICAgICAgLXogICAgXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgYXR0YWNoZWRSQiAgICAgICAgICBjb25uZWN0ZWRSQlxyXG4gICAgICogICAgICAgICAgICAgICAgKGUuZy4gd2hlZWwpICAgICAgIChlLmcuIHdoZWVsLWF4aXMpXHJcbiAgICAgKiBgYGBcclxuICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICAgKi9cclxuICBleHBvcnQgY2xhc3MgSm9pbnRVbml2ZXJzYWwgZXh0ZW5kcyBKb2ludCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gSm9pbnQucmVnaXN0ZXJTdWJjbGFzcyhKb2ludFVuaXZlcnNhbCk7XHJcblxyXG4gICAgcHJvdGVjdGVkIGpvaW50OiBPSU1PLlVuaXZlcnNhbEpvaW50O1xyXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogT0lNTy5Vbml2ZXJzYWxKb2ludENvbmZpZyA9IG5ldyBPSU1PLlVuaXZlcnNhbEpvaW50Q29uZmlnKCk7XHJcblxyXG4gICAgI3NwcmluZ0RhbXBpbmdGaXJzdDogbnVtYmVyID0gMDtcclxuICAgICNzcHJpbmdGcmVxdWVuY3lGaXJzdDogbnVtYmVyID0gMDtcclxuXHJcbiAgICAjc3ByaW5nRGFtcGluZ1NlY29uZDogbnVtYmVyID0gMDtcclxuICAgICNzcHJpbmdGcmVxdWVuY3lTZWNvbmQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI21heFJvdG9yRmlyc3Q6IG51bWJlciA9IDM2MDtcclxuICAgICNtaW5Sb3RvckZpcnN0OiBudW1iZXIgPSAwO1xyXG4gICAgI3JvdG9yVG9ycXVlRmlyc3Q6IG51bWJlciA9IDA7XHJcbiAgICAjcm90b3JTcGVlZEZpcnN0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNtYXhSb3RvclNlY29uZDogbnVtYmVyID0gMzYwO1xyXG4gICAgI21pblJvdG9yU2Vjb25kOiBudW1iZXIgPSAwO1xyXG4gICAgI3JvdG9yVG9ycXVlU2Vjb25kOiBudW1iZXIgPSAwO1xyXG4gICAgI3JvdG9yU3BlZWRTZWNvbmQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI21vdG9yRmlyc3Q6IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3I7XHJcbiAgICAjbW90b3JTZWNvbmQ6IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3I7XHJcbiAgICAjYXhpc1NwcmluZ0RhbXBlckZpcnN0OiBPSU1PLlNwcmluZ0RhbXBlcjtcclxuICAgICNheGlzU3ByaW5nRGFtcGVyU2Vjb25kOiBPSU1PLlNwcmluZ0RhbXBlcjtcclxuICAgICNheGlzRmlyc3Q6IE9JTU8uVmVjMztcclxuICAgICNheGlzU2Vjb25kOiBPSU1PLlZlYzM7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9ib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYm9keVRpZWQ6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9heGlzRmlyc3Q6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygxLCAwLCAwKSwgX2F4aXNTZWNvbmQ6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAxKSwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCk7XHJcbiAgICAgIHRoaXMuYXhpc0ZpcnN0ID0gX2F4aXNGaXJzdDtcclxuICAgICAgdGhpcy5heGlzU2Vjb25kID0gX2F4aXNTZWNvbmQ7XHJcbiAgICAgIHRoaXMuYW5jaG9yID0gX2xvY2FsQW5jaG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBHZXQvU2V0IHRyYW5zZm9yIG9mIGZ1ZGdlIHByb3BlcnRpZXMgdG8gdGhlIHBoeXNpY3MgZW5naW5lXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBheGlzIGNvbm5lY3RpbmcgdGhlIHRoZSB0d28ge0BsaW5rIE5vZGV9cyBlLmcuIFZlY3RvcjMoMCwxLDApIHRvIGhhdmUgYSB1cHdhcmQgY29ubmVjdGlvbi5cclxuICAgICAqICBXaGVuIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gdGhlIGpvaW50IG5lZWRzIHRvIGJlIHJlY29ubmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGF4aXNGaXJzdCgpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuI2F4aXNGaXJzdC54LCB0aGlzLiNheGlzRmlyc3QueSwgdGhpcy4jYXhpc0ZpcnN0LnopO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBheGlzRmlyc3QoX3ZhbHVlOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuI2F4aXNGaXJzdCA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XHJcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICogVGhlIGF4aXMgY29ubmVjdGluZyB0aGUgdGhlIHR3byB7QGxpbmsgTm9kZX1zIGUuZy4gVmVjdG9yMygwLDEsMCkgdG8gaGF2ZSBhIHVwd2FyZCBjb25uZWN0aW9uLlxyXG4gICAgKiAgV2hlbiBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIHRoZSBqb2ludCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGF4aXNTZWNvbmQoKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLiNheGlzU2Vjb25kLngsIHRoaXMuI2F4aXNTZWNvbmQueSwgdGhpcy4jYXhpc1NlY29uZC56KTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgYXhpc1NlY29uZChfdmFsdWU6IFZlY3RvcjMpIHtcclxuICAgICAgdGhpcy4jYXhpc1NlY29uZCA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XHJcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGFtcGluZyBvZiB0aGUgc3ByaW5nLiAxIGVxdWFscyBjb21wbGV0bHkgZGFtcGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0RhbXBpbmdGaXJzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRGFtcGluZ0ZpcnN0O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzcHJpbmdEYW1waW5nRmlyc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZ0ZpcnN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFNwcmluZ0RhbXBlcjEoKS5kYW1waW5nUmF0aW8gPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gVGhlIHNtYWxsZXIgdGhlIHZhbHVlIHRoZSBsZXNzIHJlc3RyaWN0aXZlIGlzIHRoZSBzcHJpbmcuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGdldCBzcHJpbmdGcmVxdWVuY3lGaXJzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5Rmlyc3Q7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0ZyZXF1ZW5jeUZpcnN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeUZpcnN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFNwcmluZ0RhbXBlcjEoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGFtcGluZyBvZiB0aGUgc3ByaW5nLiAxIGVxdWFscyBjb21wbGV0bHkgZGFtcGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0RhbXBpbmdTZWNvbmQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmdTZWNvbmQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0RhbXBpbmdTZWNvbmQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZ1NlY29uZCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTcHJpbmdEYW1wZXIyKCkuZGFtcGluZ1JhdGlvID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyZXF1ZW5jeSBvZiB0aGUgc3ByaW5nIGluIEh6LiBBdCAwIHRoZSBzcHJpbmcgaXMgcmlnaWQsIGVxdWFscyBubyBzcHJpbmcuIFRoZSBzbWFsbGVyIHRoZSB2YWx1ZSB0aGUgbGVzcyByZXN0cmljdGl2ZSBpcyB0aGUgc3ByaW5nLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc3ByaW5nRnJlcXVlbmN5U2Vjb25kKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3lTZWNvbmQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0ZyZXF1ZW5jeVNlY29uZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdGcmVxdWVuY3lTZWNvbmQgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0U3ByaW5nRGFtcGVyMigpLmZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgVXBwZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcy1BbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWF4Um90b3JGaXJzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWF4Um90b3JGaXJzdDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbWF4Um90b3JGaXJzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtYXhSb3RvckZpcnN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IxKCkudXBwZXJMaW1pdCA9IF92YWx1ZSAqIENhbGMuZGVnMnJhZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgTG93ZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcyBBbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWluUm90b3JGaXJzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWluUm90b3JGaXJzdDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbWluUm90b3JGaXJzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtaW5Sb3RvckZpcnN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IxKCkubG93ZXJMaW1pdCA9IF92YWx1ZSAqIENhbGMuZGVnMnJhZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgdGFyZ2V0IHJvdGF0aW9uYWwgc3BlZWQgb2YgdGhlIG1vdG9yIGluIG0vcy4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcm90b3JTcGVlZEZpcnN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyb3RvclNwZWVkRmlyc3Q7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHJvdG9yU3BlZWRGaXJzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyb3RvclNwZWVkRmlyc3QgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcjEoKS5tb3RvclNwZWVkID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gbW90b3IgdG9ycXVlIGluIE5ld3Rvbi4gZm9yY2UgPD0gMCBlcXVhbHMgZGlzYWJsZWQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHJvdG9yVG9ycXVlRmlyc3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JvdG9yVG9ycXVlRmlyc3Q7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHJvdG9yVG9ycXVlRmlyc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jcm90b3JUb3JxdWVGaXJzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMSgpLm1vdG9yVG9ycXVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIFVwcGVyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMtQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1heFJvdG9yU2Vjb25kKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtYXhSb3RvclNlY29uZDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbWF4Um90b3JTZWNvbmQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWF4Um90b3JTZWNvbmQgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcjIoKS51cHBlckxpbWl0ID0gX3ZhbHVlICogQ2FsYy5kZWcycmFkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBMb3dlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBBeGlzIEFuZ2xlIG1lYXN1cmVkIGluIERlZ3JlZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtaW5Sb3RvclNlY29uZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWluUm90b3JTZWNvbmQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1pblJvdG9yU2Vjb25kKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21pblJvdG9yU2Vjb25kID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IyKCkubG93ZXJMaW1pdCA9IF92YWx1ZSAqIENhbGMuZGVnMnJhZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgdGFyZ2V0IHJvdGF0aW9uYWwgc3BlZWQgb2YgdGhlIG1vdG9yIGluIG0vcy4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcm90b3JTcGVlZFNlY29uZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcm90b3JTcGVlZFNlY29uZDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgcm90b3JTcGVlZFNlY29uZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyb3RvclNwZWVkU2Vjb25kID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IyKCkubW90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgbWF4aW11bSBtb3RvciB0b3JxdWUgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcm90b3JUb3JxdWVTZWNvbmQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JvdG9yVG9ycXVlU2Vjb25kO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCByb3RvclRvcnF1ZVNlY29uZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyb3RvclRvcnF1ZVNlY29uZCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMigpLm1vdG9yVG9ycXVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIElmIHRoZSB0d28gY29ubmVjdGVkIFJpZ2lkQm9kaWVzIGNvbGxpZGUgd2l0aCBlYXRoIG90aGVyLiAoRGVmYXVsdCA9IGZhbHNlKVxyXG4gICAgICovXHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNhdmluZy9Mb2FkaW5nXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuI2dldE11dGF0b3IoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5maXJzdEF4aXMgPSB0aGlzLmF4aXNGaXJzdC5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5zZWNvbmRBeGlzID0gdGhpcy5heGlzU2Vjb25kLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuYXhpc0ZpcnN0ID0gYXdhaXQgbmV3IFZlY3RvcjMoKS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5heGlzRmlyc3QpO1xyXG4gICAgICB0aGlzLmF4aXNTZWNvbmQgPSBhd2FpdCBuZXcgVmVjdG9yMygpLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmF4aXNTZWNvbmQpO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5heGlzRmlyc3QpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMuYXhpc0ZpcnN0ID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmF4aXNGaXJzdCkpKTtcclxuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IuYXhpc1NlY29uZCkgIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgdGhpcy5heGlzU2Vjb25kID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmF4aXNTZWNvbmQpKSk7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5heGlzRmlyc3Q7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5heGlzU2Vjb25kO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmRlbGV0ZUZyb21NdXRhdG9yKF9tdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IsIF9zZWxlY3Rpb24sIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIG11dGF0b3IuYXhpc0ZpcnN0ID0gdGhpcy5heGlzRmlyc3QuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBtdXRhdG9yLmF4aXNTZWNvbmQgPSB0aGlzLmF4aXNTZWNvbmQuZ2V0TXV0YXRvcigpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jYXhpc1NwcmluZ0RhbXBlckZpcnN0ID0gbmV3IE9JTU8uU3ByaW5nRGFtcGVyKCkuc2V0U3ByaW5nKHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeUZpcnN0LCB0aGlzLiNzcHJpbmdEYW1waW5nRmlyc3QpO1xyXG4gICAgICB0aGlzLiNheGlzU3ByaW5nRGFtcGVyU2Vjb25kID0gbmV3IE9JTU8uU3ByaW5nRGFtcGVyKCkuc2V0U3ByaW5nKHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVNlY29uZCwgdGhpcy4jc3ByaW5nRGFtcGluZ1NlY29uZCk7XHJcblxyXG4gICAgICB0aGlzLiNtb3RvckZpcnN0ID0gbmV3IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHModGhpcy4jbWluUm90b3JGaXJzdCAqIENhbGMuZGVnMnJhZCwgdGhpcy4jbWF4Um90b3JGaXJzdCAqIENhbGMuZGVnMnJhZCk7XHJcbiAgICAgIHRoaXMuI21vdG9yRmlyc3Quc2V0TW90b3IodGhpcy4jcm90b3JTcGVlZEZpcnN0LCB0aGlzLiNyb3RvclRvcnF1ZUZpcnN0KTtcclxuICAgICAgdGhpcy4jbW90b3JTZWNvbmQgPSBuZXcgT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyh0aGlzLiNtaW5Sb3RvckZpcnN0ICogQ2FsYy5kZWcycmFkLCB0aGlzLiNtYXhSb3RvckZpcnN0ICogQ2FsYy5kZWcycmFkKTtcclxuICAgICAgdGhpcy4jbW90b3JTZWNvbmQuc2V0TW90b3IodGhpcy4jcm90b3JTcGVlZEZpcnN0LCB0aGlzLiNyb3RvclRvcnF1ZUZpcnN0KTtcclxuXHJcbiAgICAgIHRoaXMuY29uZmlnID0gbmV3IE9JTU8uVW5pdmVyc2FsSm9pbnRDb25maWcoKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQodGhpcy4jYXhpc0ZpcnN0LCB0aGlzLiNheGlzU2Vjb25kKTtcclxuICAgICAgdGhpcy5jb25maWcubGltaXRNb3RvcjEgPSB0aGlzLiNtb3RvckZpcnN0O1xyXG4gICAgICB0aGlzLmNvbmZpZy5saW1pdE1vdG9yMiA9IHRoaXMuI21vdG9yU2Vjb25kO1xyXG4gICAgICB0aGlzLmNvbmZpZy5zcHJpbmdEYW1wZXIxID0gdGhpcy4jYXhpc1NwcmluZ0RhbXBlckZpcnN0O1xyXG4gICAgICB0aGlzLmNvbmZpZy5zcHJpbmdEYW1wZXIyID0gdGhpcy4jYXhpc1NwcmluZ0RhbXBlclNlY29uZDtcclxuXHJcbiAgICAgIHRoaXMuam9pbnQgPSBuZXcgT0lNTy5Vbml2ZXJzYWxKb2ludCh0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHN1cGVyLmNvbmZpZ3VyZUpvaW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgI2dldE11dGF0b3IgPSAoKTogTXV0YXRvciA9PiB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHNwcmluZ0RhbXBpbmdGaXJzdDogdGhpcy4jc3ByaW5nRGFtcGluZ0ZpcnN0LFxyXG4gICAgICAgIHNwcmluZ0ZyZXF1ZW5jeUZpcnN0OiB0aGlzLiNzcHJpbmdGcmVxdWVuY3lGaXJzdCxcclxuICAgICAgICBzcHJpbmdEYW1waW5nU2Vjb25kOiB0aGlzLiNzcHJpbmdEYW1waW5nU2Vjb25kLFxyXG4gICAgICAgIHNwcmluZ0ZyZXF1ZW5jeVNlY29uZDogdGhpcy4jc3ByaW5nRnJlcXVlbmN5U2Vjb25kLFxyXG4gICAgICAgIG1heFJvdG9yRmlyc3Q6IHRoaXMuI21heFJvdG9yRmlyc3QsXHJcbiAgICAgICAgbWluUm90b3JGaXJzdDogdGhpcy4jbWluUm90b3JGaXJzdCxcclxuICAgICAgICByb3RvclNwZWVkRmlyc3Q6IHRoaXMuI3JvdG9yU3BlZWRGaXJzdCxcclxuICAgICAgICByb3RvclRvcnF1ZUZpcnN0OiB0aGlzLiNyb3RvclRvcnF1ZUZpcnN0LFxyXG4gICAgICAgIG1heFJvdG9yU2Vjb25kOiB0aGlzLiNtYXhSb3RvclNlY29uZCxcclxuICAgICAgICBtaW5Sb3RvclNlY29uZDogdGhpcy4jbWluUm90b3JTZWNvbmQsXHJcbiAgICAgICAgcm90b3JTcGVlZFNlY29uZDogdGhpcy4jcm90b3JTcGVlZFNlY29uZCxcclxuICAgICAgICByb3RvclRvcnF1ZVNlY29uZDogdGhpcy4jcm90b3JUb3JxdWVTZWNvbmRcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9O1xyXG5cclxuICAgICNtdXRhdGUgPSAoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkID0+IHtcclxuICAgICAgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBbXHJcbiAgICAgICAgXCJzcHJpbmdEYW1waW5nRmlyc3RcIiwgXCJzcHJpbmdGcmVxdWVuY3lGaXJzdFwiLCBcInNwcmluZ0RhbXBpbmdTZWNvbmRcIiwgXCJzcHJpbmdGcmVxdWVuY3lTZWNvbmRcIixcclxuICAgICAgICBcIm1heFJvdG9yRmlyc3RcIiwgXCJtaW5Sb3RvckZpcnN0XCIsIFwicm90b3JTcGVlZEZpcnN0XCIsIFwicm90b3JUb3JxdWVGaXJzdFwiLFxyXG4gICAgICAgIFwibWF4Um90b3JTZWNvbmRcIiwgXCJtaW5Sb3RvclNlY29uZFwiLCBcInJvdG9yU3BlZWRTZWNvbmRcIiwgXCIucm90b3JUb3JxdWVTZWNvbmRcIl1cclxuICAgICAgKTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAgKiBBIHBoeXNpY2FsIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggbm8gbW92ZW1lbnQuIFxyXG4gICAgICogQmVzdCB3YXkgdG8gc2ltdWxhdGUgY29udmV4IG9iamVjdHMgbGlrZSBhIGNoYWlyIHNlYXQgY29ubmVjdGVkIHRvIGNoYWlyIGxlZ3MuXHJcbiAgICAgKiBUaGUgYWN0dWFsIGFuY2hvciBwb2ludCBkb2VzIG5vdCBtYXR0ZXIgdGhhdCBtdWNoLCBvbmx5IGluIHZlcnkgc3BlY2lmaWMgZWRnZSBjYXNlcy5cclxuICAgICAqIEJlY2F1c2Ugd2VsZGluZyBtZWFucyB0aGV5IHNpbXBseSBkbyBub3QgZGlzY29ubmVjdC4gKHVubGVzcyB5b3UgYWRkIEJyZWFrYWJpbGl0eSlcclxuICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICAgKi9cclxuICBleHBvcnQgY2xhc3MgSm9pbnRXZWxkaW5nIGV4dGVuZHMgSm9pbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IEpvaW50LnJlZ2lzdGVyU3ViY2xhc3MoSm9pbnRXZWxkaW5nKTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgam9pbnQ6IE9JTU8uR2VuZXJpY0pvaW50O1xyXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogT0lNTy5HZW5lcmljSm9pbnRDb25maWcgPSBuZXcgT0lNTy5HZW5lcmljSm9pbnRDb25maWcoKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCk7XHJcblxyXG4gICAgICB0aGlzLmFuY2hvciA9IG5ldyBWZWN0b3IzKF9sb2NhbEFuY2hvci54LCBfbG9jYWxBbmNob3IueSwgX2xvY2FsQW5jaG9yLnopO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5jb25maWcgPSBuZXcgT0lNTy5HZW5lcmljSm9pbnRDb25maWcoKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQobmV3IE9JTU8uTWF0MygpLCBuZXcgT0lNTy5NYXQzKCkpO1xyXG5cclxuICAgICAgdGhpcy5qb2ludCA9IG5ldyBPSU1PLkdlbmVyaWNKb2ludCh0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHRoaXMuam9pbnQuc2V0QWxsb3dDb2xsaXNpb24odGhpcy5pbnRlcm5hbENvbGxpc2lvbik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uL0Rpc3RyaWJ1dGlvbi9PaW1vUGh5c2ljcy5kLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAqIE1hbmFnZXMgdGhlIE9JTU8gcGh5c2ljcyBlbmdpbmUgZm9yIEZVREdFLiBNdWx0aXBsZSBpbnN0YW5jZXMgbWF5IGJlIGNyZWF0ZWQsIG9uZSBpcyBhY3RpdmUgYXQgYSB0aW1lLlxyXG4gICAgKiBBbGwgbWV0aG9kcyBhcmUgc3RhdGljIGFuZCB1c2UgdGhlIGN1cnJlbnRseSBhY3RpdmUgaW5zdGFuY2UuIEF0IHN0YXJ0dXAsIGEgZGVmYXVsdCBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCBiZWNvbWUgdGhlIGFjdGl2ZSBpbnN0YW5jZVxyXG4gICAgKiBBdHRhY2hpbmcgYSB7QGxpbmsgQ29tcG9uZW50UmlnaWRib2R5fSB0byBhIHtAbGluayBOb2RlfSBwbGFjZXMgYSBwaHlzaWNzIGNvbGxpZGVyIGluIHRoZSBwaHlzaWNzIGluc3RhbmNlIGFjdGl2ZSBhdCB0aGF0IHRpbWUuXHJcbiAgICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVIDIwMjBcclxuICAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFBoeXNpY3Mge1xyXG4gICAgLyoqIFRoZSBTRVRUSU5HUyB0aGF0IGFwcGx5IHRvIHRoZSBwaHlzaWNhbCB3b3JsZC4gUmFuZ2luZyBmcm9tIHRoaW5ncyBsaWtlIHNsZWVwaW5nLCBjb2xsaXNpb25TaGFwZVRoaWNrbmVzcyBhbmQgb3RoZXJzICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldHRpbmdzOiBQaHlzaWNzU2V0dGluZ3MgPSBuZXcgUGh5c2ljc1NldHRpbmdzKENPTExJU0lPTl9HUk9VUC5ERUZBVUxULCAoQ09MTElTSU9OX0dST1VQLkRFRkFVTFQgfCBDT0xMSVNJT05fR1JPVVAuR1JPVVBfMSB8IENPTExJU0lPTl9HUk9VUC5HUk9VUF8yIHwgQ09MTElTSU9OX0dST1VQLkdST1VQXzMgfCBDT0xMSVNJT05fR1JPVVAuR1JPVVBfNCkpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJhY3RpdmU6IFBoeXNpY3MgPSBuZXcgUGh5c2ljcygpO1xyXG5cclxuICAgIHByaXZhdGUgb2ltb1dvcmxkOiBPSU1PLldvcmxkO1xyXG4gICAgcHJpdmF0ZSBib2R5TGlzdDogQ29tcG9uZW50UmlnaWRib2R5W10gPSBuZXcgQXJyYXkoKTtcclxuICAgIHByaXZhdGUgam9pbnRMaXN0OiBKb2ludFtdID0gbmV3IEFycmF5KCk7XHJcblxyXG4gICAgLyoqIFRoZSByZW5kZXJpbmcgb2YgcGh5c2ljYWwgZGVidWcgaW5mb3JtYXRpb25zLiBVc2VkIGludGVybmFsbHkgbm8gaW50ZXJhY3Rpb24gbmVlZGVkLiovXHJcbiAgICAjZGVidWdEcmF3OiBQaHlzaWNzRGVidWdEcmF3O1xyXG4gICAgLyoqIFRoZSBjYW1lcmEvdmlld3BvcnQgdGhlIHBoeXNpY3MgYXJlIGRlYnVnZ2VkIHRvLiBVc2VkIGludGVybmFsbHkgbm8gaW50ZXJhY3Rpb24gbmVlZGVkLiAqL1xyXG4gICAgI21haW5DYW06IENvbXBvbmVudENhbWVyYTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgT0lNTyA9PSBcInVuZGVmaW5lZFwiKSB7Ly8gQ2hlY2sgaWYgT0lNTyBOYW1lc3BhY2Ugd2FzIGxvYWRlZCwgZWxzZSBkbyBub3QgdXNlIGFueSBwaHlzaWNzLiBDaGVjayBpcyBuZWVkZWQgdG8gZW5zdXJlIEZVREdFIGNhbiBiZSB1c2VkIHdpdGhvdXQgUGh5c2ljc1xyXG4gICAgICAgIERlYnVnLmVycm9yKFwiT0lNTyBwaHlzaWNzIGVuZ2luZSBub3QgY29ubmVjdGVkIVwiKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm9pbW9Xb3JsZCA9IG5ldyBPSU1PLldvcmxkKCk7XHJcbiAgICAgIHRoaXMuI2RlYnVnRHJhdyA9IG5ldyBQaHlzaWNzRGVidWdEcmF3KCk7ICAvL0NyZWF0ZSBhIEZVREdFIFBoeXNpY3MgZGVidWdnaW5nIGhhbmRsaW5nIG9iamVjdFxyXG4gICAgICB0aGlzLm9pbW9Xb3JsZC5zZXREZWJ1Z0RyYXcodGhpcy4jZGVidWdEcmF3Lm9pbW9EZWJ1Z0RyYXcpOyAvL1RlbGwgT2ltb1BoeXNpY3Mgd2hlcmUgdG8gZGVidWcgdG8gYW5kIGhvdyBpdCB3aWxsIGJlIGhhbmRsZWRcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIHRoZSBjdXJyZW50bHkgYWN0aXZlIFBoeXNpY3MgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXQgYWN0aXZlSW5zdGFuY2UoX3BoeXNpY3M6IFBoeXNpY3MpIHtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZSA9IF9waHlzaWNzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgUGh5c2ljcyBpbnN0YW5jZSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgYWN0aXZlSW5zdGFuY2UoKTogUGh5c2ljcyB7XHJcbiAgICAgIHJldHVybiBQaHlzaWNzLsaSYWN0aXZlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGRlYnVnRHJhdygpOiBQaHlzaWNzRGVidWdEcmF3IHtcclxuICAgICAgcmV0dXJuIFBoeXNpY3MuxpJhY3RpdmUuI2RlYnVnRHJhdztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IG1haW5DYW0oKTogQ29tcG9uZW50Q2FtZXJhIHtcclxuICAgICAgcmV0dXJuIFBoeXNpY3MuxpJhY3RpdmUuI21haW5DYW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENhc3QgYSBSQVkgaW50byB0aGUgcGh5c2ljYWwgd29ybGQgZnJvbSBhIG9yaWdpbiBwb2ludCBpbiBhIGNlcnRhaW4gZGlyZWN0aW9uLiBSZWNlaXZpbmcgaW5mb3JtYXRpb25zIGFib3V0IHRoZSBoaXQgb2JqZWN0IGFuZCB0aGVcclxuICAgICogaGl0IHBvaW50LiBEbyBub3Qgc3BlY2lmeSBhIF9ncm91cCB0byByYXljYXN0IHRoZSB3aG9sZSB3b3JsZCwgZWxzZSBvbmx5IGJvZGllcyB3aXRoaW4gdGhlIHNwZWNpZmljIGdyb3VwIGNhbiBiZSBoaXQuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByYXljYXN0KF9vcmlnaW46IFZlY3RvcjMsIF9kaXJlY3Rpb246IFZlY3RvcjMsIF9sZW5ndGg6IG51bWJlciA9IDEsIF9kZWJ1Z0RyYXc6IGJvb2xlYW4gPSBmYWxzZSwgX2dyb3VwOiBDT0xMSVNJT05fR1JPVVAgPSBDT0xMSVNJT05fR1JPVVAuREVGQVVMVCk6IFJheUhpdEluZm8ge1xyXG4gICAgICBsZXQgaGl0SW5mbzogUmF5SGl0SW5mbyA9IG5ldyBSYXlIaXRJbmZvKCk7XHJcbiAgICAgIGxldCByYXk6IE9JTU8uUmF5Q2FzdENsb3Nlc3QgPSBuZXcgT0lNTy5SYXlDYXN0Q2xvc2VzdCgpO1xyXG4gICAgICBsZXQgYmVnaW46IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzMoX29yaWdpbi54LCBfb3JpZ2luLnksIF9vcmlnaW4ueik7XHJcbiAgICAgIGxldCBlbmQ6IE9JTU8uVmVjMyA9IHRoaXMuZ2V0UmF5RW5kUG9pbnQoYmVnaW4sIG5ldyBWZWN0b3IzKF9kaXJlY3Rpb24ueCwgX2RpcmVjdGlvbi55LCBfZGlyZWN0aW9uLnopLCBfbGVuZ3RoKTtcclxuICAgICAgcmF5LmNsZWFyKCk7XHJcbiAgICAgIGlmIChfZ3JvdXAgPT0gQ09MTElTSU9OX0dST1VQLkRFRkFVTFQpIHsgLy9DYXNlIDE6IFJheWNhc3RpbmcgdGhlIHdob2xlIHdvcmxkLCBub3JtYWwgbW9kZVxyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLnJheUNhc3QoYmVnaW4sIGVuZCwgcmF5KTtcclxuICAgICAgfSBlbHNlIHsgLy9DYXNlMjogUmF5Y2FzdGluZyBvbiBlYWNoIGJvZHkgaW4gYSBzcGVjaWZpYyBncm91cFxyXG4gICAgICAgIGxldCBhbGxIaXRzOiBSYXlIaXRJbmZvW10gPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICBQaHlzaWNzLsaSYWN0aXZlLmJvZHlMaXN0LmZvckVhY2goZnVuY3Rpb24gKF92YWx1ZTogQ29tcG9uZW50UmlnaWRib2R5KTogdm9pZCB7XHJcbiAgICAgICAgICBpZiAoX3ZhbHVlLmNvbGxpc2lvbkdyb3VwID09IF9ncm91cCkge1xyXG4gICAgICAgICAgICBoaXRJbmZvID0gX3ZhbHVlLnJheWNhc3RUaGlzQm9keShfb3JpZ2luLCBfZGlyZWN0aW9uLCBfbGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKGhpdEluZm8uaGl0ID09IHRydWUpIHsgLy9FdmVyeSBoaXQgaXMgY291bGQgcG90ZW50aWFsbHkgYmUgdGhlIGNsb3Nlc3RcclxuICAgICAgICAgICAgICBhbGxIaXRzLnB1c2goaGl0SW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhbGxIaXRzLmZvckVhY2goZnVuY3Rpb24gKF92YWx1ZTogUmF5SGl0SW5mbyk6IHZvaWQgeyAvL2dldCB0aGUgY2xvc2VzdCBoaXRJbmZvXHJcbiAgICAgICAgICBpZiAoX3ZhbHVlLmhpdERpc3RhbmNlIDwgaGl0SW5mby5oaXREaXN0YW5jZSB8fCBoaXRJbmZvLmhpdCA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBoaXRJbmZvID0gX3ZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyYXkuaGl0KSB7IC8vRmlsbCBpbiBpbmZvcm1hdGlvbnMgb24gdGhlIGhpdFxyXG4gICAgICAgIGhpdEluZm8uaGl0ID0gdHJ1ZTtcclxuICAgICAgICBoaXRJbmZvLmhpdFBvaW50ID0gbmV3IFZlY3RvcjMocmF5LnBvc2l0aW9uLngsIHJheS5wb3NpdGlvbi55LCByYXkucG9zaXRpb24ueik7XHJcbiAgICAgICAgaGl0SW5mby5oaXROb3JtYWwgPSBuZXcgVmVjdG9yMyhyYXkubm9ybWFsLngsIHJheS5ub3JtYWwueSwgcmF5Lm5vcm1hbC56KTtcclxuICAgICAgICBoaXRJbmZvLmhpdERpc3RhbmNlID0gdGhpcy5nZXRSYXlEaXN0YW5jZShfb3JpZ2luLCBoaXRJbmZvLmhpdFBvaW50KTtcclxuICAgICAgICBoaXRJbmZvLnJpZ2lkYm9keUNvbXBvbmVudCA9IHJheS5zaGFwZS51c2VyRGF0YTtcclxuICAgICAgICBoaXRJbmZvLnJheUVuZCA9IG5ldyBWZWN0b3IzKGVuZC54LCBlbmQueSwgZW5kLnopO1xyXG4gICAgICAgIGhpdEluZm8ucmF5T3JpZ2luID0gX29yaWdpbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBoaXRJbmZvLnJheU9yaWdpbiA9IF9vcmlnaW47XHJcbiAgICAgICAgaGl0SW5mby5oaXRQb2ludCA9IG5ldyBWZWN0b3IzKGVuZC54LCBlbmQueSwgZW5kLnopO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfZGVidWdEcmF3KSB7IC8vSGFuZGxlIGRlYnVnZ2luZ1xyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUuI2RlYnVnRHJhdy5kZWJ1Z1JheShoaXRJbmZvLnJheU9yaWdpbiwgaGl0SW5mby5oaXRQb2ludCwgbmV3IENvbG9yKDAsIDEsIDAsIDEpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaGl0SW5mbztcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNpbXVsYXRlcyB0aGUgcGh5c2ljYWwgd29ybGQuIF9kZWx0YVRpbWUgaXMgdGhlIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gcGh5c2ljYWwgc3RlcHMgaW4gc2Vjb25kcy4gRGVmYXVsdCBpcyB7QGxpbmsgTG9vcC50aW1lRnJhbWVHYW1lfSAvIDEwMDAgdG8gcnVuIGluIHN5bmMgd2l0aCB0aGUge0BsaW5rIExvb3B9LlxyXG4gICAgKiBUaGUgbWF4aW11bSB2YWx1ZSBpcyAxLzMwIG9mIGEgc2Vjb25kLCB0byBoYXZlIG1vcmUgY29uc2lzdGVudCBmcmFtZSBjYWxjdWxhdGlvbnMuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzaW11bGF0ZShfZGVsdGFUaW1lOiBudW1iZXIgPSBMb29wLnRpbWVGcmFtZUdhbWUgLyAxMDAwKTogdm9pZCB7XHJcbiAgICAgIGlmIChQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdC5sZW5ndGggPiAwKVxyXG4gICAgICAgIFBoeXNpY3MuY29ubmVjdEpvaW50cygpOyAvLyBDb25uZWN0IGpvaW50cyBpZiBhbnl0aGluZyBoYXMgaGFwcGVuZWQgYmV0d2VlbiB0aGUgbGFzdCBjYWxsIHRvIGFueSBvZiB0aGUgdHdvIHBhaXJlZCByaWdpZGJvZGllc1xyXG4gICAgICBpZiAoX2RlbHRhVGltZSA9PSAwKSAvLyBObyB0aW1lIHBhc3NlZCwgbm8gbmVlZCB0byB1cGRhdGUgdGhlIHBoeXNpY3Mgd29ybGRcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBfZGVsdGFUaW1lID0gX2RlbHRhVGltZSA+IDEgLyAzMCA/IDEgLyAzMCA6IF9kZWx0YVRpbWU7IC8vIElmIGluc3RlYWQgb2YgYSBmaXhlZCByYXRlIHRoZSBnYW1lIGZyYW1lcmF0ZSBpcyB1c2VkLCBtYWtlIHN1cmUgaXJyZWd1bGFyIHRpbWluZ3MgYXJlIGZpeGVkIHRvIDMwZnBzXHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLnN0ZXAoX2RlbHRhVGltZSk7ICAvLyBVcGRhdGUgdGhlIHNpbXVsYXRpb24gYnkgdGhlIGdpdmVuIGRlbHRhVGltZVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgaW5zdGFuY2UgdXNpbmcgdGhlIHtAbGluayBDb21wb25lbnRDYW1lcmF9IGdpdmVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhdyhfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEsIF9tb2RlPzogUEhZU0lDU19ERUJVR01PREUpOiB2b2lkIHtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS4jZGVidWdEcmF3LnNldERlYnVnTW9kZShfbW9kZSk7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUuI21haW5DYW0gPSBfY21wQ2FtZXJhO1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5kZWJ1Z0RyYXcoKTsgLy9GaWxsaW5nIHRoZSBwaHlzaWNzIHdvcmxkIGRlYnVnIGluZm9ybWF0aW9ucyBpbnRvIHRoZSBkZWJ1ZyByZW5kZXJpbmcgaGFuZGxlclxyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLiNkZWJ1Z0RyYXcuZHJhd0J1ZmZlcnMoKTtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS4jZGVidWdEcmF3LmNsZWFyQnVmZmVycygpOyAgLy9VcGRhdGVzIGluZm8gYWJvdXQgdGhlIGN1cnJlbnQgcHJvamVjdGlvbiwgcmVzZXR0aW5nIHRoZSBwb2ludHMvbGluZXMvdHJpYW5nbGVzIHRoYXQgbmVlZCB0byBiZSBkcmF3biBmcm9tIGRlYnVnXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogQWRqdXN0cyB0aGUgdHJhbnNmb3JtcyBvZiB0aGUge0BsaW5rIENvbXBvbmVudFJpZ2lkYm9keX1zIGluIHRoZSBnaXZlbiBicmFuY2ggdG8gbWF0Y2ggdGhlaXIgbm9kZXMgb3IgbWVzaGVzXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFkanVzdFRyYW5zZm9ybXMoX2JyYW5jaDogTm9kZSwgX3RvTWVzaDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlci5wcmVwYXJlKF9icmFuY2gsIHsgaWdub3JlUGh5c2ljczogdHJ1ZSB9KTtcclxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBSZW5kZXIubm9kZXNQaHlzaWNzKVxyXG4gICAgICAgIG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudFJpZ2lkYm9keSkuaW5pdGlhbGl6ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBHZXQgdGhlIGFwcGxpZWQgZ3Jhdml0YXRpb25hbCBmb3JjZSBvZiB0aGUgYWN0aXZlIGluc3RhbmNlLiBEZWZhdWx0IGVhcnRoIGdyYXZpdHkgPSA5LjgxIG0vc1xyXG4gICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0R3Jhdml0eSgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHRtcFZlYzogT0lNTy5WZWMzID0gUGh5c2ljcy7GkmFjdGl2ZS5vaW1vV29ybGQuZ2V0R3Jhdml0eSgpO1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjModG1wVmVjLngsIHRtcFZlYy55LCB0bXBWZWMueik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNldCB0aGUgYXBwbGllZCBncmF2aXRhdGlvbmFsIGZvcmNlIG9mIHRoZSBhY3RpdmUgaW5zdGFuY2UuIERlZmF1bHQgZWFydGggZ3Jhdml0eSA9IDkuODEgbS9zXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXRHcmF2aXR5KF92YWx1ZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICBsZXQgdG1wVmVjOiBPSU1PLlZlYzMgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5zZXRHcmF2aXR5KHRtcFZlYyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFkZCBhIG5ldyBPSU1PIFJpZ2lkYm9keSB0byB0aGUgYWN0aXZlIGluc3RhbmNlLCBoYXBwZW5zIGF1dG9tYXRpY2FsbHkgd2hlbiBhZGRpbmcgYSBGVURHRSBSaWdpZGJvZHkgQ29tcG9uZW50LlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYWRkUmlnaWRib2R5KF9jbXBSQjogQ29tcG9uZW50UmlnaWRib2R5KTogdm9pZCB7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUuYm9keUxpc3QucHVzaChfY21wUkIpO1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5hZGRSaWdpZEJvZHkoX2NtcFJCLmdldE9pbW9SaWdpZGJvZHkoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJlbW92ZSB0aGUgT0lNTyBSaWdpZGJvZHkgdG8gdGhlIGFjdGl2ZSBpbnN0YW5jZSwgaGFwcGVucyBhdXRvbWF0aWNhbGx5IHdoZW4gcmVtb3ZpbmcgYSBGVURHRSBSaWdpZGJvZHkgQ29tcG9uZW50XHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVSaWdpZGJvZHkoX2NtcFJCOiBDb21wb25lbnRSaWdpZGJvZHkpOiB2b2lkIHtcclxuICAgICAgLy8gVE9ETzogdHdvIGxpc3RzIGFyZSBiZWluZyBtYW5hZ2VkLCBpbmZvIG1pZ2h0IGRldmlhdGUuIENsZWFudXAhXHJcbiAgICAgIGxldCBvaW1vUmlnaWRCb2R5OiBPSU1PLlJpZ2lkQm9keSA9IF9jbXBSQi5nZXRPaW1vUmlnaWRib2R5KCk7XHJcbiAgICAgIGlmIChvaW1vUmlnaWRCb2R5Ll93b3JsZClcclxuICAgICAgICBvaW1vUmlnaWRCb2R5Ll93b3JsZC5yZW1vdmVSaWdpZEJvZHkob2ltb1JpZ2lkQm9keSk7XHJcbiAgICAgIC8vIHdoYXQgaWYgdGhlIHJpZ2lkYm9keXMgb2ltby13b3JsZCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhlIGFjdGl2ZSBpbnN0YW5jZT9cclxuICAgICAgbGV0IGlkOiBudW1iZXIgPSBQaHlzaWNzLsaSYWN0aXZlLmJvZHlMaXN0LmluZGV4T2YoX2NtcFJCKTtcclxuICAgICAgaWYgKGlkID4gLTEpXHJcbiAgICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5ib2R5TGlzdC5zcGxpY2UoaWQsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBZGQgYSBuZXcgT0lNTyBKb2ludC9Db25zdHJhaW50IHRvIHRoZSBhY3RpdmUgaW5zdGFuY2UsIGhhcHBlbnMgYXV0b21hdGljYWxseSB3aGVuIGFkZGluZyBhIEZVREdFIEpvaW50IENvbXBvbmVudFxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYWRkSm9pbnQoX2NtcEpvaW50OiBKb2ludCk6IHZvaWQge1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5hZGRKb2ludChfY21wSm9pbnQuZ2V0T2ltb0pvaW50KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDYWxsZWQgaW50ZXJuYWxseSB0byBpbmZvcm0gdGhlIHBoeXNpY3Mgc3lzdGVtIHRoYXQgYSBqb2ludCBoYXMgYSBjaGFuZ2Ugb2YgY29yZSBwcm9wZXJ0aWVzIGFuZCBuZWVkcyB0byBiZSByZWNyZWF0ZWQuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjaGFuZ2VKb2ludFN0YXR1cyhfY21wSm9pbnQ6IEpvaW50KTogdm9pZCB7XHJcbiAgICAgIGlmIChQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdC5pbmRleE9mKF9jbXBKb2ludCkgPCAwKVxyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUuam9pbnRMaXN0LnB1c2goX2NtcEpvaW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBSZW1vdmUgdGhlIE9JTU8gSm9pbnQvQ29uc3RyYWludCB0byB0aGUgYWN0aXZlIGluc3RhbmNlLCBoYXBwZW5zIGF1dG9tYXRpY2FsbHkgd2hlbiByZW1vdmluZyBhIEZVREdFIEpvaW50IENvbXBvbmVudFxyXG4gICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVKb2ludChfY21wSm9pbnQ6IEpvaW50KTogdm9pZCB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5vaW1vV29ybGQucmVtb3ZlSm9pbnQoX2NtcEpvaW50LmdldE9pbW9Kb2ludCgpKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yOiB1bmtub3duKSB7XHJcbiAgICAgICAgRGVidWcuZnVkZ2UoX2Vycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGFsbCB0aGUgQ29tcG9uZW50UmlnaWRib2RpZXMgdGhhdCBhcmUga25vd24gdG8gdGhlIGFjdGl2ZSBpbnN0YW5jZS4gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Qm9keUxpc3QoKTogQ29tcG9uZW50UmlnaWRib2R5W10ge1xyXG4gICAgICByZXR1cm4gUGh5c2ljcy7GkmFjdGl2ZS5ib2R5TGlzdDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2l2aW5nIGEgQ29tcG9uZW50UmlnaWRib2R5IGEgc3BlY2lmaWMgaWRlbnRpZmljYXRpb24gbnVtYmVyIHNvIGl0IGNhbiBiZSByZWZlcmVuY2VkIGluIHRoZSBsb2FkaW5nIHByb2Nlc3MuIEFuZCByZW1vdmVkIHJiJ3MgY2FuIHJlY2VpdmUgYSBuZXcgaWQuICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRpc3RyaWJ1dGVCb2R5SUQoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IGZyZWVJZDogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IGZyZWU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5ib2R5TGlzdC5mb3JFYWNoKChfdmFsdWU6IENvbXBvbmVudFJpZ2lkYm9keSk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmIChfdmFsdWUuaWQgIT0gZnJlZUlkKSB7XHJcbiAgICAgICAgICBmcmVlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZnJlZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWZyZWUpIHtcclxuICAgICAgICAgIGZyZWVJZCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gZnJlZUlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIENvbm5lY3QgYWxsIGpvaW50cyB0aGF0IGFyZSBub3QgY29ubmVjdGVkIHlldC4gVXNlZCBpbnRlcm5hbGx5IG5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkLiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgY2FsbGVkIGFuZCBuZWVkZWQgdG8gbWFrZSBzdXJlIGpvaW50cyBjb25uZWN0L2Rpc2Nvbm5lY3RcclxuICAgICAqIGlmIGFueSBvZiB0aGUgdHdvIHBhaXJlZCBDb21wb25lbnRSaWdpZGJvZGllcyBjaGFuZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY29ubmVjdEpvaW50cygpOiB2b2lkIHsgLy9UcnkgdG8gY29ubmVjdCBkaXJ0eSBqb2ludHMgdW50aWwgdGhleSBhcmUgY29ubmVjdGVkXHJcbiAgICAgIGxldCBqb2ludHNUb0Nvbm5lY3Q6IEpvaW50W10gPSBQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdDtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5qb2ludExpc3QgPSBbXTtcclxuICAgICAgam9pbnRzVG9Db25uZWN0LmZvckVhY2goKF9qb2ludDogSm9pbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBpZiAoX2pvaW50LmlzQ29ubmVjdGVkKCkgPT0gZmFsc2UpXHJcbiAgICAgICAgICBpZiAoX2pvaW50LmlzQWN0aXZlKVxyXG4gICAgICAgICAgICBfam9pbnQuY29ubmVjdCgpO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdC5wdXNoKF9qb2ludCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZW1vdmUgYWxsIG9pbW8gam9pbnRzIGFuZCByaWdpZGJvZGllcywgc28gdGhhdCB0aGV5IGNhbiBiZSByZXVzZWQgaW4gYW5vdGhlciB3b3JsZCAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYW51cCgpOiB2b2lkIHtcclxuICAgICAgbGV0IG9pbW9Xb3JsZDogT0lNTy5Xb3JsZCA9IFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkO1xyXG4gICAgICBpZiAob2ltb1dvcmxkICE9IG51bGwpIHtcclxuICAgICAgICAvL1Jlc2V0dGluZyB0aGUgd29ybGQgc28gYSBuZXcgd29ybGQgY2FuIGJlIGNyZWF0ZWQsIGZpeCBmb3IgcmUtb3BlbmluZyBhIHByb2plY3QgaW4gZWRpdG9yLCBtYWtpbmcgc3VyZSB0aGVyZSBhcmUgbm8gb2xkIHRoaW5ncyBjYWxjdWxhdGVkXHJcbiAgICAgICAgbGV0IGpvaW50c1dvcmxkOiBudW1iZXIgPSBvaW1vV29ybGQuZ2V0TnVtSm9pbnRzKCk7XHJcbiAgICAgICAgbGV0IGJvZGllc1dvcmxkOiBudW1iZXIgPSBvaW1vV29ybGQuZ2V0TnVtUmlnaWRCb2RpZXMoKTtcclxuICAgICAgICBmb3IgKGxldCBib2R5IG9mIFBoeXNpY3MuxpJhY3RpdmUuYm9keUxpc3QpXHJcbiAgICAgICAgICBib2R5LmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICBQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdCA9IG5ldyBBcnJheSgpOyAvLyBUT0RPOiBzZWUgaWYgaXQgd291bGQgYmUgc21hcnRlciwgZG8gdXNlIHRoZXNlIGFycmF5cy4gRGVmaW5pdGVseSBtb3JlIGludHVpdGl2ZS4uLlxyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBqb2ludHNXb3JsZDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgb2ltb0pvaW50OiBPSU1PLkpvaW50ID0gUGh5c2ljcy7GkmFjdGl2ZS5vaW1vV29ybGQuZ2V0Sm9pbnRMaXN0KCk7XHJcbiAgICAgICAgICBvaW1vV29ybGQucmVtb3ZlSm9pbnQob2ltb0pvaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGJvZGllc1dvcmxkOyBpKyspIHtcclxuICAgICAgICAgIGxldCBvaW1vQm9keTogT0lNTy5SaWdpZEJvZHkgPSBvaW1vV29ybGQuZ2V0UmlnaWRCb2R5TGlzdCgpO1xyXG4gICAgICAgICAgb2ltb1dvcmxkLnJlbW92ZVJpZ2lkQm9keShvaW1vQm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gLyoqIFJldHVybnMgdGhlIENvbXBvbmVudFJpZ2lkYm9keSB3aXRoIHRoZSBnaXZlbiBpZC4gVXNlZCBpbnRlcm5hbGx5IHRvIHJlY29ubmVjdCBqb2ludHMgb24gbG9hZGluZyBpbiB0aGUgZWRpdG9yLiAqL1xyXG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgZ2V0Qm9keUJ5SUQoX2lkOiBudW1iZXIpOiBDb21wb25lbnRSaWdpZGJvZHkge1xyXG4gICAgLy8gICBsZXQgYm9keTogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbDtcclxuICAgIC8vICAgUGh5c2ljcy4jYWN0aXZlUGh5c2ljcy5ib2R5TGlzdC5mb3JFYWNoKCh2YWx1ZTogQ29tcG9uZW50UmlnaWRib2R5KTogdm9pZCA9PiB7XHJcbiAgICAvLyAgICAgaWYgKHZhbHVlLmlkID09IF9pZCkge1xyXG4gICAgLy8gICAgICAgYm9keSA9IHZhbHVlO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgfSk7XHJcbiAgICAvLyAgIHJldHVybiBib2R5O1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8qKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIGVuZHBvaW50IG9mIG1hdGhlbWF0aWNhbCByYXkuIEJ5IGFkZGluZyB0aGUgbXVsdGlwbGllZCBkaXJlY3Rpb24gdG8gdGhlIG9yaWdpbi4gXHJcbiAgICAgICAqIFVzZWQgYmVjYXVzZSBPaW1vUGh5c2ljcyBkZWZpbmVzIHJheSBieSBzdGFydC9lbmQuIEJ1dCBHYW1lRW5naW5lcyBjb21tb25seSB1c2Ugb3JpZ2luL2RpcmVjdGlvbi5cclxuICAgICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRSYXlFbmRQb2ludChfc3RhcnQ6IE9JTU8uVmVjMywgX2RpcmVjdGlvbjogVmVjdG9yMywgX2xlbmd0aDogbnVtYmVyKTogT0lNTy5WZWMzIHtcclxuICAgICAgbGV0IG9yaWdpbjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgb3JpZ2luLnNldChfc3RhcnQueCwgX3N0YXJ0LnksIF9zdGFydC56KTtcclxuICAgICAgbGV0IHNjYWxlZERpcmVjdGlvbjogVmVjdG9yMyA9IF9kaXJlY3Rpb24uY2xvbmU7XHJcbiAgICAgIHNjYWxlZERpcmVjdGlvbi5zY2FsZShfbGVuZ3RoKTtcclxuICAgICAgbGV0IGVuZHBvaW50OiBWZWN0b3IzID0gVmVjdG9yMy5TVU0oc2NhbGVkRGlyZWN0aW9uLCBvcmlnaW4pO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShzY2FsZWREaXJlY3Rpb24pO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShlbmRwb2ludCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG9yaWdpbik7XHJcbiAgICAgIHJldHVybiBuZXcgT0lNTy5WZWMzKGVuZHBvaW50LngsIGVuZHBvaW50LnksIGVuZHBvaW50LnopO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBnZXQgdGhlIGRpc3RhbmNlIGluIHdoaWNoIGEgcmF5IGhpdCBieSBzdWJ0cmFjdGluZyBwb2ludHMgZnJvbSBlYWNoIG90aGVyIGFuZCBnZXQgdGhlIHNxdWFyZSByb290IG9mIHRoZSBzcXVhcmVkIHByb2R1Y3Qgb2YgZWFjaCBjb21wb25lbnQuICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRSYXlEaXN0YW5jZShfb3JpZ2luOiBWZWN0b3IzLCBfaGl0UG9pbnQ6IFZlY3RvcjMpOiBudW1iZXIge1xyXG4gICAgICBsZXQgZHg6IG51bWJlciA9IF9vcmlnaW4ueCAtIF9oaXRQb2ludC54O1xyXG4gICAgICBsZXQgZHk6IG51bWJlciA9IF9vcmlnaW4ueSAtIF9oaXRQb2ludC55O1xyXG4gICAgICBsZXQgZHo6IG51bWJlciA9IF9vcmlnaW4ueiAtIF9oaXRQb2ludC56O1xyXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJldHVybnMgdGhlIGFjdHVhbCB1c2VkIHdvcmxkIG9mIHRoZSBPSU1PIHBoeXNpY3MgZW5naW5lLiBObyB1c2VyIGludGVyYWN0aW9uIG5lZWRlZCAtIE9ubHkgZm9yIGFkdmFuY2VkIHVzZXJzIHRoYXQgbmVlZCB0byBhY2Nlc3MgaXQgZGlyZWN0bHkgKi9cclxuICAgIHB1YmxpYyBnZXRPaW1vV29ybGQoKTogT0lNTy5Xb3JsZCB7XHJcbiAgICAgIHJldHVybiBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAvKiogVXBkYXRlcyBhbGwge0BsaW5rIFJpZ2lkYm9kaWVzfSBrbm93biB0byB0aGUgUGh5c2ljcy53b3JsZCB0byBtYXRjaCB0aGVpciBjb250YWluZXJzIG9yIG1lc2hlcyB0cmFuc2Zvcm1hdGlvbnMgKi9cclxuICAgIC8vIHByaXZhdGUgdXBkYXRlV29ybGRGcm9tV29ybGRNYXRyaXgoX3RvTWVzaDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAvLyAgIGZvciAobGV0IGJvZHkgb2YgdGhpcy5ib2R5TGlzdClcclxuICAgIC8vICAgICBib2R5LnVwZGF0ZUZyb21Xb3JsZChfdG9NZXNoKTtcclxuICAgIC8vIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBEZWZpbmVzIGEgdGhyZWVkaW1lbnNpb25hbCBib3ggYnkgdHdvIGNvcm5lci1wb2ludHMsIG9uZSB3aXRoIG1pbmltYWwgdmFsdWVzIGFuZCBvbmUgd2l0aCBtYXhpbXVtIHZhbHVlc1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBCb3ggaW1wbGVtZW50cyBSZWN5Y2FibGUge1xyXG4gICAgcHVibGljIG1pbjogVmVjdG9yMztcclxuICAgIHB1YmxpYyBtYXg6IFZlY3RvcjM7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9taW46IFZlY3RvcjMgPSBWZWN0b3IzLk9ORShJbmZpbml0eSksIF9tYXg6IFZlY3RvcjMgPSBWZWN0b3IzLk9ORSgtSW5maW5pdHkpKSB7XHJcbiAgICAgIHRoaXMuc2V0KF9taW4sIF9tYXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIHRoZSBjb3JuZXJzIG9mIHRoaXMgYm94LCBzdGFuZGFyZCB2YWx1ZXMgYXJlIEluZmluaXR5IGZvciBtaW4sIGFuZCAtSW5maW5pdHkgZm9yIG1heCwgXHJcbiAgICAgKiBjcmVhdGluZyBhbiBpbXBvc3NpYmxlIGludmVydGVkIGJveCB0aGF0IGNhbiBub3QgY29udGFpbiBhbnkgcG9pbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX21pbjogVmVjdG9yMyA9IFZlY3RvcjMuT05FKEluZmluaXR5KSwgX21heDogVmVjdG9yMyA9IFZlY3RvcjMuT05FKC1JbmZpbml0eSkpOiB2b2lkIHtcclxuICAgICAgdGhpcy5taW4gPSBfbWluO1xyXG4gICAgICB0aGlzLm1heCA9IF9tYXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBhbmQgdGhlIGJveCBpZiBuZWNlc3NhcnkgdG8gaW5jbHVkZSB0aGUgZ2l2ZW4gcG9pbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGV4cGFuZChfaW5jbHVkZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLm1pbi5taW4oX2luY2x1ZGUpO1xyXG4gICAgICB0aGlzLm1heC5tYXgoX2luY2x1ZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLm1pbi5zZXQoSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSk7XHJcbiAgICAgIHRoaXMubWF4LnNldCgtSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5KTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBTdG9yZXMgaW5mb3JtYXRpb24gcHJvdmlkZWQgYnkge0BsaW5rIFJlbmRlcn0tcGlja2luZyBlLmcuIHVzaW5nIHtAbGluayBQaWNrZXJ9IGFuZCBwcm92aWRlcyBtZXRob2RzIGZvciBmdXJ0aGVyIGNhbGN1bGF0aW9uIG9mIHBvc2l0aW9ucyBhbmQgbm9ybWFscyBldGMuXHJcbiAgICogXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUGljayB7XHJcbiAgICBwdWJsaWMgbm9kZTogTm9kZTtcclxuICAgIHB1YmxpYyB6QnVmZmVyOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgY29sb3I6IENvbG9yO1xyXG4gICAgcHVibGljIHRleHR1cmVVVjogVmVjdG9yMjtcclxuICAgIHB1YmxpYyBnaXptbz86IEdpem1vO1xyXG4gICAgI210eFZpZXdUb1dvcmxkOiBNYXRyaXg0eDQ7XHJcbiAgICAjcG9zV29ybGQ6IFZlY3RvcjM7XHJcbiAgICAjcG9zTWVzaDogVmVjdG9yMztcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25vZGU6IE5vZGUpIHtcclxuICAgICAgdGhpcy5ub2RlID0gX25vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY2Nlc3NvciB0byBjYWxjdWxhdGUgYW5kIHN0b3JlIHdvcmxkIHBvc2l0aW9uIG9mIGludGVyc2VjdGlvbiBvZiB7QGxpbmsgUmF5fSBhbmQge0BsaW5rIE1lc2h9IG9ubHkgd2hlbiB1c2VkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHBvc1dvcmxkKCk6IFZlY3RvcjMge1xyXG4gICAgICBpZiAodGhpcy4jcG9zV29ybGQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Bvc1dvcmxkO1xyXG4gICAgICBsZXQgcG9pbnRJbkNsaXBTcGFjZTogVmVjdG9yMyA9IFZlY3RvcjMuWih0aGlzLnpCdWZmZXIpO1xyXG4gICAgICBsZXQgbTogRmxvYXQzMkFycmF5ID0gdGhpcy4jbXR4Vmlld1RvV29ybGQuZ2V0KCk7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjMgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKHBvaW50SW5DbGlwU3BhY2UsIHRoaXMuI210eFZpZXdUb1dvcmxkLCB0cnVlKTtcclxuICAgICAgbGV0IHc6IG51bWJlciA9IG1bM10gKiBwb2ludEluQ2xpcFNwYWNlLnggKyBtWzddICogcG9pbnRJbkNsaXBTcGFjZS55ICsgbVsxMV0gKiBwb2ludEluQ2xpcFNwYWNlLnogKyBtWzE1XTtcclxuICAgICAgcmVzdWx0LnNjYWxlKDEgLyB3KTtcclxuXHJcbiAgICAgIHRoaXMuI3Bvc1dvcmxkID0gcmVzdWx0O1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWNjZXNzb3IgdG8gY2FsY3VsYXRlIGFuZCBzdG9yZSBwb3NpdGlvbiBpbiBtZXNoLXNwYWNlIG9mIGludGVyc2VjdGlvbiBvZiB7QGxpbmsgUmF5fSBhbmQge0BsaW5rIE1lc2h9IG9ubHkgd2hlbiB1c2VkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHBvc01lc2goKTogVmVjdG9yMyB7XHJcbiAgICAgIGlmICh0aGlzLiNwb3NNZXNoKVxyXG4gICAgICAgIHJldHVybiB0aGlzLiNwb3NNZXNoO1xyXG4gICAgICBsZXQgbXR4V29ybGRUb01lc2g6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JTlZFUlNFKHRoaXMubm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCkubXR4V29ybGQpO1xyXG4gICAgICBsZXQgcG9zTWVzaDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04odGhpcy5wb3NXb3JsZCwgbXR4V29ybGRUb01lc2gpO1xyXG4gICAgICB0aGlzLiNwb3NNZXNoID0gcG9zTWVzaDtcclxuICAgICAgcmV0dXJuIHBvc01lc2g7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY2Nlc3NvciB0byBjYWxjdWxhdGUgYW5kIHN0b3JlIHRoZSBmYWNlIG5vcm1hbCBpbiB3b3JsZC1zcGFjZSBhdCB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIG9mIHtAbGluayBSYXl9IGFuZCB7QGxpbmsgTWVzaH0gb25seSB3aGVuIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbm9ybWFsKCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgY21wTWVzaDogQ29tcG9uZW50TWVzaCA9IHRoaXMubm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCk7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjM7XHJcblxyXG4gICAgICBmb3IgKGxldCBmYWNlIG9mIGNtcE1lc2gubWVzaC5mYWNlcykge1xyXG4gICAgICAgIGlmIChmYWNlLmlzSW5zaWRlKHRoaXMucG9zTWVzaCkpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IGZhY2Uubm9ybWFsLmNsb25lO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXN1bHQudHJhbnNmb3JtKGNtcE1lc2gubXR4V29ybGQsIGZhbHNlKTtcclxuICAgICAgcmVzdWx0Lm5vcm1hbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHNvbGVseSBieSB0aGUgcmVuZGVyZXIgdG8gZW5hYmxlIGNhbGN1bGF0aW9uIG9mIHRoZSB3b3JsZCBjb29yZGluYXRlcyBvZiB0aGlzIHtAbGluayBQaWNrfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IG10eFZpZXdUb1dvcmxkKF9tdHhWaWV3VG9Xb3JsZDogTWF0cml4NHg0KSB7XHJcbiAgICAgIHRoaXMuI210eFZpZXdUb1dvcmxkID0gX210eFZpZXdUb1dvcmxkO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFByb3ZpZGVzIHN0YXRpYyBtZXRob2RzIGZvciBwaWNraW5nIHVzaW5nIHtAbGluayBSZW5kZXJ9XHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUGlja2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSByYXkgcGx1cyBtaW4gYW5kIG1heCB2YWx1ZXMgZm9yIHRoZSBuZWFyIGFuZCBmYXIgcGxhbmVzIHRvIGNvbnN0cnVjdCB0aGUgcGlja2VyLWNhbWVyYSxcclxuICAgICAqIHRoZW4gcmVuZGVycyB0aGUgcGljay10ZXh0dXJlIGFuZCByZXR1cm5zIGFuIHVuc29ydGVkIHtAbGluayBQaWNrfS1hcnJheSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXRzIG9mIHRoZSByYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja1JheShfbm9kZXM6IE5vZGVbXSwgX3JheTogUmF5LCBfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlcik6IFBpY2tbXTtcclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja1JheShfZ2l6bW9zOiBHaXptb1tdLCBfcmF5OiBSYXksIF9taW46IG51bWJlciwgX21heDogbnVtYmVyKTogUGlja1tdO1xyXG4gICAgcHVibGljIHN0YXRpYyBwaWNrUmF5KF9mcm9tOiBOb2RlW10gfCBHaXptb1tdLCBfcmF5OiBSYXksIF9taW46IG51bWJlciwgX21heDogbnVtYmVyKTogUGlja1tdIHtcclxuICAgICAgaWYgKF9mcm9tLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuXHJcbiAgICAgIGxldCBjbXBDYW1lcmFQaWNrOiBDb21wb25lbnRDYW1lcmEgPSBSZWN5Y2xlci5yZXVzZShDb21wb25lbnRDYW1lcmEpO1xyXG4gICAgICBjbXBDYW1lcmFQaWNrLm10eFdvcmxkLnRyYW5zbGF0aW9uID0gX3JheS5vcmlnaW47XHJcbiAgICAgIGNtcENhbWVyYVBpY2subXR4V29ybGQubG9va0F0KFZlY3RvcjMuU1VNKF9yYXkub3JpZ2luLCBfcmF5LmRpcmVjdGlvbikpO1xyXG4gICAgICBjbXBDYW1lcmFQaWNrLnByb2plY3RDZW50cmFsKDEsIDAuMDAxLCBGSUVMRF9PRl9WSUVXLkRJQUdPTkFMLCBfbWluLCBfbWF4KTtcclxuICAgICAgY21wQ2FtZXJhUGljay5yZXNldFdvcmxkVG9WaWV3KCk7XHJcblxyXG4gICAgICBsZXQgcGlja3M6IFBpY2tbXTtcclxuICAgICAgaWYgKF9mcm9tWzBdIGluc3RhbmNlb2YgTm9kZSlcclxuICAgICAgICBwaWNrcyA9IFJlbmRlci5waWNrKDxOb2RlW10+X2Zyb20sIGNtcENhbWVyYVBpY2spO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcGlja3MgPSBHaXptb3MucGljayg8R2l6bW9bXT5fZnJvbSwgY21wQ2FtZXJhUGljayk7XHJcblxyXG4gICAgICBSZWN5Y2xlci5zdG9yZShjbXBDYW1lcmFQaWNrKTtcclxuICAgICAgcmV0dXJuIHBpY2tzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSBjYW1lcmEgYW5kIGEgcG9pbnQgb24gaXRzIHZpcnR1YWwgbm9ybWVkIHByb2plY3Rpb24gcGxhbmUgKGRpc3RhbmNlIDEpIHRvIGNvbnN0cnVjdCB0aGUgcGlja2VyLWNhbWVyYSxcclxuICAgICAqIHRoZW4gcmVuZGVycyB0aGUgcGljay10ZXh0dXJlIGFuZCByZXR1cm5zIGFuIHVuc29ydGVkIHtAbGluayBQaWNrfS1hcnJheSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXRzIG9mIHRoZSByYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja0NhbWVyYShfbm9kZXM6IE5vZGVbXSwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhLCBfcG9zUHJvamVjdGlvbjogVmVjdG9yMik6IFBpY2tbXTtcclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja0NhbWVyYShfbm9kZXM6IEdpem1vW10sIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX3Bvc1Byb2plY3Rpb246IFZlY3RvcjIpOiBQaWNrW107XHJcbiAgICBwdWJsaWMgc3RhdGljIHBpY2tDYW1lcmEoX2Zyb206IE5vZGVbXSB8IEdpem1vW10sIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX3Bvc1Byb2plY3Rpb246IFZlY3RvcjIpOiBQaWNrW10ge1xyXG4gICAgICBsZXQgcmF5OiBSYXkgPSBuZXcgUmF5KG5ldyBWZWN0b3IzKC1fcG9zUHJvamVjdGlvbi54LCBfcG9zUHJvamVjdGlvbi55LCAxKSk7XHJcbiAgICAgIGxldCBsZW5ndGg6IG51bWJlciA9IHJheS5kaXJlY3Rpb24ubWFnbml0dWRlO1xyXG5cclxuICAgICAgaWYgKF9jbXBDYW1lcmEubm9kZSkge1xyXG4gICAgICAgIGxldCBtdHhDYW1lcmE6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5QUk9EVUNUKF9jbXBDYW1lcmEubm9kZS5tdHhXb3JsZCwgX2NtcENhbWVyYS5tdHhQaXZvdCk7XHJcbiAgICAgICAgcmF5LnRyYW5zZm9ybShtdHhDYW1lcmEpO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eENhbWVyYSk7XHJcbiAgICAgIH0gZWxzZVxyXG4gICAgICAgIHJheS50cmFuc2Zvcm0oX2NtcENhbWVyYS5tdHhQaXZvdCk7XHJcblxyXG4gICAgICBsZXQgcGlja3M6IFBpY2tbXSA9IFBpY2tlci5waWNrUmF5KDxHZW5lcmFsPl9mcm9tLCByYXksIGxlbmd0aCAqIF9jbXBDYW1lcmEuZ2V0TmVhcigpLCBsZW5ndGggKiBfY21wQ2FtZXJhLmdldEZhcigpKTtcclxuICAgICAgcmV0dXJuIHBpY2tzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgdGhlIGNhbWVyYSBvZiB0aGUgZ2l2ZW4gdmlld3BvcnQgYW5kIGEgcG9pbnQgdGhlIGNsaWVudCBzdXJmYWNlIHRvIGNvbnN0cnVjdCB0aGUgcGlja2VyLWNhbWVyYSxcclxuICAgICAqIHRoZW4gcmVuZGVycyB0aGUgcGljay10ZXh0dXJlIGFuZCByZXR1cm5zIGFuIHVuc29ydGVkIHtAbGluayBQaWNrfS1hcnJheSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXRzIG9mIHRoZSByYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja1ZpZXdwb3J0KF92aWV3cG9ydDogVmlld3BvcnQsIF9wb3NDbGllbnQ6IFZlY3RvcjIpOiBQaWNrW10ge1xyXG4gICAgICBsZXQgcG9zUHJvamVjdGlvbjogVmVjdG9yMiA9IF92aWV3cG9ydC5wb2ludENsaWVudFRvUHJvamVjdGlvbihfcG9zQ2xpZW50KTtcclxuICAgICAgbGV0IG5vZGVzOiBOb2RlW10gPSBBcnJheS5mcm9tKF92aWV3cG9ydC5nZXRCcmFuY2goKS5nZXRJdGVyYXRvcih0cnVlKSk7XHJcbiAgICAgIGxldCBwaWNrczogUGlja1tdID0gUGlja2VyLnBpY2tDYW1lcmEobm9kZXMsIF92aWV3cG9ydC5jYW1lcmEsIHBvc1Byb2plY3Rpb24pO1xyXG4gICAgICBpZiAoX3ZpZXdwb3J0Lmdpem1vc0VuYWJsZWQpXHJcbiAgICAgICAgcGlja3MgPSBwaWNrcy5jb25jYXQoUGlja2VyLnBpY2tDYW1lcmEoX3ZpZXdwb3J0LmdldEdpem1vcyhub2RlcyksIF92aWV3cG9ydC5jYW1lcmEsIHBvc1Byb2plY3Rpb24pKTsgLy8gdGhpcyBpcyBraW5kIG9mIHdhc3RlZnVsIGJlY2F1c2Ugd2UgZG8gdGhlIHNhbWUgY2FsY3VsYXRpb25zIHR3aWNlXHJcblxyXG4gICAgICByZXR1cm4gcGlja3M7XHJcbiAgICB9XHJcblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERlZmluZWQgYnkgYW4gb3JpZ2luIGFuZCBhIGRpcmVjdGlvbiBvZiB0eXBlIHtAbGluayBQaWNrfSwgcmF5cyBhcmUgdXNlZCB0byBjYWxjdWxhdGUgcGlja2luZyBhbmQgaW50ZXJzZWN0aW9uc1xyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFJheSB7XHJcbiAgICBwdWJsaWMgb3JpZ2luOiBWZWN0b3IzO1xyXG4gICAgcHVibGljIGRpcmVjdGlvbjogVmVjdG9yMztcclxuICAgIC8qKiBUT0RPOiBzdXBwb3J0IGxlbmd0aCAqL1xyXG4gICAgcHVibGljIGxlbmd0aDogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfZGlyZWN0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5aKDEpLCBfb3JpZ2luOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCksIF9sZW5ndGg6IG51bWJlciA9IDEpIHtcclxuICAgICAgdGhpcy5vcmlnaW4gPSBfb3JpZ2luO1xyXG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IF9kaXJlY3Rpb247XHJcbiAgICAgIHRoaXMubGVuZ3RoID0gX2xlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbiBvZiB0aGlzIHJheSB3aXRoIGEgcGxhbmUgZGVmaW5lZCBieSBcclxuICAgICAqIHRoZSBnaXZlbiBwb2ludCBvZiBvcmlnaW4gYW5kIHRoZSBwbGFuZXMgbm9ybWFsLiBBbGwgdmFsdWVzIGFuZCBjYWxjdWxhdGlvbnNcclxuICAgICAqIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhlIHNhbWUgY29vcmRpbmF0ZSBzeXN0ZW0sIHByZWZlcmFibHkgdGhlIHdvcmxkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnRlcnNlY3RQbGFuZShfb3JpZ2luOiBWZWN0b3IzLCBfbm9ybWFsOiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBkaWZmZXJlbmNlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF9vcmlnaW4sIHRoaXMub3JpZ2luKTtcclxuICAgICAgbGV0IGZhY3RvcjogbnVtYmVyID0gVmVjdG9yMy5ET1QoZGlmZmVyZW5jZSwgX25vcm1hbCkgLyBWZWN0b3IzLkRPVCh0aGlzLmRpcmVjdGlvbiwgX25vcm1hbCk7XHJcbiAgICAgIGxldCBpbnRlcnNlY3Q6IFZlY3RvcjMgPSBWZWN0b3IzLlNVTSh0aGlzLm9yaWdpbiwgVmVjdG9yMy5TQ0FMRSh0aGlzLmRpcmVjdGlvbiwgZmFjdG9yKSk7XHJcbiAgICAgIHJldHVybiBpbnRlcnNlY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb24gb2YgdGhpcyByYXkgd2l0aCBhIHBsYW5lIGRlZmluZWQgYnkgdGhlIGZhY2UuIFxyXG4gICAgICogQWxsIHZhbHVlcyBhbmQgY2FsY3VsYXRpb25zIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhlIHNhbWUgY29vcmRpbmF0ZSBzeXN0ZW0sIHByZWZlcmFibHkgdGhlIHdvcmxkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnRlcnNlY3RGYWNlUGxhbmUoX2ZhY2U6IEZhY2UpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0UGxhbmUoX2ZhY2UuZ2V0UG9zaXRpb24oMCksIF9mYWNlLm5vcm1hbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaG9ydGVzdCBkaXN0YW5jZSBmcm9tIHRoZSByYXkgdG8gdGhlIGdpdmVuIHRhcmdldCBwb2ludC5cclxuICAgICAqIEFsbCB2YWx1ZXMgYW5kIGNhbGN1bGF0aW9ucyBtdXN0IGJlIHJlbGF0aXZlIHRvIHRoZSBzYW1lIGNvb3JkaW5hdGUgc3lzdGVtLCBwcmVmZXJhYmx5IHRoZSB3b3JsZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldERpc3RhbmNlKF90YXJnZXQ6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IG9yaWdpblRvVGFyZ2V0OiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF90YXJnZXQsIHRoaXMub3JpZ2luKTtcclxuICAgICAgbGV0IHJheVNlY3Rpb246IFZlY3RvcjMgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04odGhpcy5kaXJlY3Rpb24sIDEpO1xyXG4gICAgICBsZXQgcHJvamVjdGVkTGVuZ3RoOiBudW1iZXIgPSBWZWN0b3IzLkRPVChvcmlnaW5Ub1RhcmdldCwgcmF5U2VjdGlvbik7XHJcbiAgICAgIHJheVNlY3Rpb24uc2NhbGUocHJvamVjdGVkTGVuZ3RoKTtcclxuICAgICAgcmF5U2VjdGlvbi5hZGQodGhpcy5vcmlnaW4pO1xyXG4gICAgICBsZXQgZGlzdGFuY2U6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3RhcmdldCwgcmF5U2VjdGlvbik7XHJcbiAgICAgIHJldHVybiBkaXN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSB0aGUgcmF5IGJ5IHRoZSBnaXZlbiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zZm9ybShfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5vcmlnaW4udHJhbnNmb3JtKF9tdHhUcmFuc2Zvcm0pO1xyXG4gICAgICB0aGlzLmRpcmVjdGlvbi50cmFuc2Zvcm0oX210eFRyYW5zZm9ybSwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJlYWRhYmxlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHJheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGBvcmlnaW46ICR7dGhpcy5vcmlnaW4udG9TdHJpbmcoKX0sIGRpcmVjdGlvbjogJHt0aGlzLmRpcmVjdGlvbi50b1N0cmluZygpfSwgbGVuZ3RoOiAke3RoaXMubGVuZ3RoLnRvUHJlY2lzaW9uKDUpfWA7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBpbnRlcmZhY2UgdG8gcmVuZGVyIHZpc3VhbCBhaWRzIGluIHRoZSBlZGl0b3IuIEltcGxlbWVudGVkIGJ5IHtAbGluayBDb21wb25lbnR9cy4gQ2FuIGJlIHVzZWQgb24gaXRzIG93biB0byBkcmF3IGFuZCBwaWNrIHZpc3VhbCBhaWRzIGluZGVwZW5kZW50IG9mIGEgc2NlbmUgZ3JhcGguXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBHaXptbyB7XHJcbiAgICBub2RlPzogTm9kZTtcclxuICAgIC8qKlxyXG4gICAgICogSW1wbGVtZW50IHRoaXMgdG8gZHJhdyB2aXN1YWwgYWlkcyBpbnNpZGUgdGhlIGVkaXRvcnMgcmVuZGVyIHZpZXcuIFVzZSB7QGxpbmsgR2l6bW9zfSBpbnNpZGUgdGhlIG92ZXJyaWRlIHRvIGRyYXcgc3R1ZmYuXHJcbiAgICAgKi9cclxuICAgIGRyYXdHaXptb3M/KF9jbXBDYW1lcmE/OiBDb21wb25lbnRDYW1lcmEsIF9waWNraW5nPzogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWUge0BsaW5rIGRyYXdHaXptb3N9LiBPbmx5IGRpc3BsYXllZCB3aGlsZSB0aGUgY29ycmVzcG9uZGluZyBub2RlIGlzIHNlbGVjdGVkLlxyXG4gICAgICovXHJcbiAgICBkcmF3R2l6bW9zU2VsZWN0ZWQ/KF9jbXBDYW1lcmE/OiBDb21wb25lbnRDYW1lcmEpOiB2b2lkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGdpem1vcyBkcmF3aW5nIGludGVyZmFjZS4ge0BsaW5rIENvbXBvbmVudH1zIGNhbiB1c2UgdGhpcyB0byBkcmF3IHZpc3VhbCBhaWRzIGluc2lkZSB7QGxpbmsgQ29tcG9uZW50LmRyYXdHaXptb3N9IGFuZCB7QGxpbmsgQ29tcG9uZW50LmRyYXdHaXptb3NTZWxlY3RlZH0uXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIEdpem1vcyB7XHJcbiAgICAvKiogXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBvcGFjaXR5IG9mIG9jY2x1ZGVkIGdpem1vIHBhcnRzLiBVc2UgdGhpcyB0byBjb250cm9sIHRoZSB2aXNpYmlsaXR5IG9mIGdpem1vcyBiZWhpbmQgb2JqZWN0cy5cclxuICAgICAqIFNldCB0byAwIHRvIG1ha2Ugb2NjbHVkZWQgZ2l6bW8gcGFydHMgZGlzYXBwZWFyLiBTZXQgdG8gMSB0byBtYWtlIG9jY2x1ZGVkIGdpem1vIHBhcnRzIGZ1bGx5IHZpc2libGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGFscGhhT2NjbHVkZWQ6IG51bWJlciA9IDAuMzsgLy8gY3VycmVudGx5IGdpem1vcyBjYW4gYWx3YXlzIGJlIHBpY2tlZCBldmVuIGlmIHRoaXMgaXMgc2V0IHRvIDAuLi5cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBhcnJheUJ1ZmZlcjogV2ViR0xCdWZmZXIgPSBSZW5kZXJXZWJHTC5hc3NlcnQoUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpLmNyZWF0ZUJ1ZmZlcigpKTtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBwaWNrSWQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IHBvc0ljb25zOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTsgLy8gY2FjaGUgdGhlIHBvc2l0aW9ucyBvZiBpY29ucyB0byBhdm9pZCBkcmF3aW5nIHRoZW0gd2l0aGluIGVhY2ggb3RoZXJcclxuXHJcbiAgICBzdGF0aWMgI2NhbWVyYTogQ29tcG9uZW50Q2FtZXJhO1xyXG5cclxuICAgIHN0YXRpYyAjbWVzaGVzOiB7IFtrZXk6IHN0cmluZ106IE1lc2ggfSA9IHt9O1xyXG4gICAgc3RhdGljICNtYXBNZXNoVG9XaXJlQnVmZmVyczogV2Vha01hcDxNZXNoLCBSZW5kZXJCdWZmZXJzPiA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG4gICAgLy8gVE9ETzogdGhpbmsgYWJvdXQgZHJhd2luZyB0aGVzZSBvbiB0aGUgZmx5IGluc3RlYWQgb2YgY2FjaGluZyB0aGVtLiBUaGVuIHdlIGNvdWxkIGFjY2VwdCBhIHBvc2l0aW9uLCByYWRpdXMgZXRjLiBwYXJhbWV0ZXIgYW5kIGRyYXcgdGhlbSBpbmRlcGVuZGVudCBmcm9tIHRoZSBtdHhXb3JsZFxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0IHdpcmVDaXJjbGUoKTogVmVjdG9yM1tdIHtcclxuICAgICAgY29uc3QgcmFkaXVzOiBudW1iZXIgPSAwLjU7XHJcbiAgICAgIGNvbnN0IHNlZ21lbnRzOiBudW1iZXIgPSA0NTtcclxuICAgICAgY29uc3QgY2lyY2xlOiBWZWN0b3IzW10gPSBuZXcgQXJyYXkoc2VnbWVudHMpLmZpbGwobnVsbCkubWFwKCgpID0+IFJlY3ljbGVyLmdldChWZWN0b3IzKSk7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBzZWdtZW50czsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYW5nbGU6IG51bWJlciA9IChpIC8gc2VnbWVudHMpICogMiAqIE1hdGguUEk7XHJcbiAgICAgICAgY29uc3QgeDogbnVtYmVyID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIGNvbnN0IHk6IG51bWJlciA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICBjaXJjbGVbaV0uc2V0KHgsIHksIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBsaW5lczogVmVjdG9yM1tdID0gW107XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBzZWdtZW50czsgaSsrKVxyXG4gICAgICAgIGxpbmVzLnB1c2goY2lyY2xlW2ldLCBjaXJjbGVbKGkgKyAxKSAlIHNlZ21lbnRzXSk7XHJcblxyXG4gICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KEdpem1vcywgXCJ3aXJlQ2lyY2xlXCIsIHsgdmFsdWU6IGxpbmVzIH0pO1xyXG4gICAgICByZXR1cm4gR2l6bW9zLndpcmVDaXJjbGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0IHdpcmVTcGhlcmUoKTogVmVjdG9yM1tdIHtcclxuICAgICAgbGV0IGxpbmVzOiBWZWN0b3IzW10gPSBHaXptb3Mud2lyZUNpcmNsZS5jb25jYXQoKTtcclxuICAgICAgbGV0IG10eFJvdGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT05fWCg5MCk7XHJcbiAgICAgIGxpbmVzLnB1c2goLi4uR2l6bW9zLndpcmVDaXJjbGUubWFwKChfcG9pbnQ6IFZlY3RvcjMpID0+IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3BvaW50LCBtdHhSb3RhdGlvbikpKTtcclxuICAgICAgbXR4Um90YXRpb24ucm90YXRlWSg5MCk7XHJcbiAgICAgIGxpbmVzLnB1c2goLi4uR2l6bW9zLndpcmVDaXJjbGUubWFwKChfcG9pbnQ6IFZlY3RvcjMpID0+IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3BvaW50LCBtdHhSb3RhdGlvbikpKTtcclxuXHJcbiAgICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoR2l6bW9zLCBcIndpcmVTcGhlcmVcIiwgeyB2YWx1ZTogbGluZXMgfSk7XHJcbiAgICAgIHJldHVybiBHaXptb3Mud2lyZVNwaGVyZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXQgd2lyZUNvbmUoKTogVmVjdG9yM1tdIHtcclxuICAgICAgY29uc3QgcmFkaXVzOiBudW1iZXIgPSAwLjU7XHJcbiAgICAgIGNvbnN0IGhlaWdodDogbnVtYmVyID0gMTtcclxuICAgICAgY29uc3QgYXBleDogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpO1xyXG4gICAgICBjb25zdCBxdWFkOiBWZWN0b3IzW10gPSBbXHJcbiAgICAgICAgbmV3IFZlY3RvcjMocmFkaXVzLCAwLCBoZWlnaHQpLFxyXG4gICAgICAgIG5ldyBWZWN0b3IzKC1yYWRpdXMsIDAsIGhlaWdodCksXHJcbiAgICAgICAgbmV3IFZlY3RvcjMoMCwgcmFkaXVzLCBoZWlnaHQpLFxyXG4gICAgICAgIG5ldyBWZWN0b3IzKDAsIC1yYWRpdXMsIGhlaWdodClcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGxldCBsaW5lczogVmVjdG9yM1tdID0gR2l6bW9zLndpcmVDaXJjbGUubWFwKChfcG9pbnQ6IFZlY3RvcjMpID0+IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3BvaW50LCBNYXRyaXg0eDQuVFJBTlNMQVRJT04oVmVjdG9yMy5aKDEpKSkpO1xyXG5cclxuICAgICAgbGluZXMucHVzaCguLi5bYXBleCwgcXVhZFswXSwgYXBleCwgcXVhZFsxXSwgYXBleCwgcXVhZFsyXSwgYXBleCwgcXVhZFszXV0pO1xyXG5cclxuICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShHaXptb3MsIFwid2lyZUNvbmVcIiwgeyB2YWx1ZTogbGluZXMgfSk7XHJcbiAgICAgIHJldHVybiBHaXptb3Mud2lyZUNvbmU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0IHdpcmVDdWJlKCk6IFZlY3RvcjNbXSB7XHJcbiAgICAgIGNvbnN0IGhhbGZTaXplOiBudW1iZXIgPSAwLjU7XHJcbiAgICAgIGNvbnN0IGN1YmU6IFZlY3RvcjNbXSA9IFtcclxuICAgICAgICBuZXcgVmVjdG9yMyhoYWxmU2l6ZSwgaGFsZlNpemUsIGhhbGZTaXplKSwgbmV3IFZlY3RvcjMoLWhhbGZTaXplLCBoYWxmU2l6ZSwgaGFsZlNpemUpLFxyXG4gICAgICAgIG5ldyBWZWN0b3IzKC1oYWxmU2l6ZSwgLWhhbGZTaXplLCBoYWxmU2l6ZSksIG5ldyBWZWN0b3IzKGhhbGZTaXplLCAtaGFsZlNpemUsIGhhbGZTaXplKSxcclxuICAgICAgICBuZXcgVmVjdG9yMyhoYWxmU2l6ZSwgaGFsZlNpemUsIC1oYWxmU2l6ZSksIG5ldyBWZWN0b3IzKC1oYWxmU2l6ZSwgaGFsZlNpemUsIC1oYWxmU2l6ZSksXHJcbiAgICAgICAgbmV3IFZlY3RvcjMoLWhhbGZTaXplLCAtaGFsZlNpemUsIC1oYWxmU2l6ZSksIG5ldyBWZWN0b3IzKGhhbGZTaXplLCAtaGFsZlNpemUsIC1oYWxmU2l6ZSlcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGNvbnN0IGxpbmVzOiBWZWN0b3IzW10gPSBbXHJcbiAgICAgICAgY3ViZVswXSwgY3ViZVsxXSwgY3ViZVsxXSwgY3ViZVsyXSwgY3ViZVsyXSwgY3ViZVszXSwgY3ViZVszXSwgY3ViZVswXSxcclxuICAgICAgICBjdWJlWzRdLCBjdWJlWzVdLCBjdWJlWzVdLCBjdWJlWzZdLCBjdWJlWzZdLCBjdWJlWzddLCBjdWJlWzddLCBjdWJlWzRdLFxyXG4gICAgICAgIGN1YmVbMF0sIGN1YmVbNF0sIGN1YmVbMV0sIGN1YmVbNV0sIGN1YmVbMl0sIGN1YmVbNl0sIGN1YmVbM10sIGN1YmVbN11cclxuICAgICAgXTtcclxuXHJcbiAgICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoR2l6bW9zLCBcIndpcmVDdWJlXCIsIHsgdmFsdWU6IGxpbmVzIH0pO1xyXG4gICAgICByZXR1cm4gR2l6bW9zLndpcmVDdWJlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJlIHdlIGN1cnJlbnRseSByZW5kZXJpbmcgZm9yIHBpY2tpbmc/XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgI3BpY2tpbmcoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBpY2tJZCAhPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIGdpdmVuIGdpem1vcyBmcm9tIHRoZSBwb2ludCBvZiB2aWV3IG9mIHRoZSBnaXZlbiBjYW1lcmEuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhdyhfZ2l6bW9zOiBHaXptb1tdLCBfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEsIF9zZWxlY3RlZD86IE5vZGVbXSk6IHZvaWQge1xyXG4gICAgICBmb3IgKGNvbnN0IGdpem1vIG9mIF9naXptb3MpXHJcbiAgICAgICAgaWYgKGdpem1vLm5vZGUpXHJcbiAgICAgICAgICBSZWZsZWN0LnNldChnaXptby5ub2RlLCBcInpDYW1lcmFcIiwgX2NtcENhbWVyYS5wb2ludFdvcmxkVG9DbGlwKGdpem1vLm5vZGUubXR4V29ybGQudHJhbnNsYXRpb24pLnopO1xyXG5cclxuICAgICAgX2dpem1vcyA9IF9naXptb3Muc29ydCgoX2EsIF9iKSA9PlxyXG4gICAgICAgIChfYi5ub2RlID8gUmVmbGVjdC5nZXQoX2Iubm9kZSwgXCJ6Q2FtZXJhXCIpIDogMikgLVxyXG4gICAgICAgIChfYS5ub2RlID8gUmVmbGVjdC5nZXQoX2Eubm9kZSwgXCJ6Q2FtZXJhXCIpIDogMilcclxuICAgICAgKTtcclxuXHJcbiAgICAgIEdpem1vcy4jY2FtZXJhID0gX2NtcENhbWVyYTtcclxuICAgICAgR2l6bW9zLnBvc0ljb25zLmNsZWFyKCk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTC5idWZmZXJDYW1lcmEoX2NtcENhbWVyYSk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGdpem1vIG9mIF9naXptb3MpIHtcclxuICAgICAgICBnaXptby5kcmF3R2l6bW9zPy4oX2NtcENhbWVyYSwgR2l6bW9zLiNwaWNraW5nKTtcclxuICAgICAgICBpZiAoX3NlbGVjdGVkPy5pbmNsdWRlcyhnaXptby5ub2RlKSlcclxuICAgICAgICAgIGdpem1vLmRyYXdHaXptb3NTZWxlY3RlZD8uKF9jbXBDYW1lcmEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaWNrcyBhbGwgZ2l6bW9zIGluIHRoZSBsaW5lIG9mIHNpZ2h0IGFuZCByZXR1cm5zIGFuIHVuc29ydGVkIGFycmF5IG9mIHtAbGluayBQaWNrfXMgZWFjaCBhc3NvY2lhdGVkIHdpdGggdGhlIGdpem1vIHRoZSBwaWNrIHJheSBoaXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcGljayhfZ2l6bW9zOiBHaXptb3NbXSwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogUGlja1tdIHtcclxuICAgICAgcmV0dXJuIFJlbmRlcldlYkdMLnBpY2tGcm9tKF9naXptb3MsIF9jbXBDYW1lcmEsIHBpY2spO1xyXG5cclxuICAgICAgZnVuY3Rpb24gcGljayhfZ2l6bW9zOiBHaXptb1tdLCBfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEpOiBQaWNrW10ge1xyXG4gICAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgICAgY3JjMy51bmlmb3JtTWF0cml4M2Z2KFNoYWRlclBpY2tUZXh0dXJlZC51bmlmb3Jtc1tcInVfbXR4UGl2b3RcIl0sIGZhbHNlLCBNYXRyaXgzeDMuSURFTlRJVFkoKS5nZXQoKSk7IC8vIG9ubHkgbmVlZGVkIGZvciB0ZXh0dXJlZCBwaWNrIHNoYWRlciwgYnV0IGdpem1vcyBoYXZlIG5vIHBpdm90XHJcblxyXG4gICAgICAgIEdpem1vcy4jY2FtZXJhID0gX2NtcENhbWVyYTtcclxuICAgICAgICBHaXptb3MucG9zSWNvbnMuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgbGV0IHBpY2tzOiBQaWNrW10gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBnaXptbyBvZiBfZ2l6bW9zKSB7XHJcbiAgICAgICAgICBpZiAoIWdpem1vLmRyYXdHaXptb3MpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgIEdpem1vcy5waWNrSWQgPSBwaWNrcy5sZW5ndGg7XHJcbiAgICAgICAgICBnaXptby5kcmF3R2l6bW9zKF9jbXBDYW1lcmEsIEdpem1vcy4jcGlja2luZyk7XHJcbiAgICAgICAgICBsZXQgcGljazogUGljayA9IG5ldyBQaWNrKGdpem1vLm5vZGUpO1xyXG4gICAgICAgICAgcGljay5naXptbyA9IGdpem1vO1xyXG4gICAgICAgICAgcGlja3MucHVzaChwaWNrKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEdpem1vcy5waWNrSWQgPSBudWxsO1xyXG5cclxuICAgICAgICByZXR1cm4gcGlja3M7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgY2FtZXJhIGZydXN0dW0gZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLiBUaGUgZnJ1c3R1bSBpcyBvcmllbnRlZCBhbG9uZyB0aGUgei1heGlzLCB3aXRoIHRoZSB0aXAgb2YgdGhlIHRydW5jYXRlZCBweXJhbWlkIGF0IHRoZSBvcmlnaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhd1dpcmVGcnVzdHVtKF9hc3BlY3Q6IG51bWJlciwgX2ZvdjogbnVtYmVyLCBfbmVhcjogbnVtYmVyLCBfZmFyOiBudW1iZXIsIF9kaXJlY3Rpb246IEZJRUxEX09GX1ZJRVcsIF9tdHhXb3JsZDogTWF0cml4NHg0LCBfY29sb3I6IENvbG9yLCBfYWxwaGFPY2NsdWRlZDogbnVtYmVyID0gR2l6bW9zLmFscGhhT2NjbHVkZWQpOiB2b2lkIHtcclxuICAgICAgY29uc3QgZjogbnVtYmVyID0gTWF0aC50YW4oQ2FsYy5kZWcycmFkICogX2ZvdiAvIDIpO1xyXG5cclxuICAgICAgbGV0IHNjYWxlWDogbnVtYmVyID0gZjtcclxuICAgICAgbGV0IHNjYWxlWTogbnVtYmVyID0gZjtcclxuXHJcbiAgICAgIHN3aXRjaCAoX2RpcmVjdGlvbikge1xyXG4gICAgICAgIGNhc2UgRklFTERfT0ZfVklFVy5IT1JJWk9OVEFMOlxyXG4gICAgICAgICAgc2NhbGVZID0gZiAvIF9hc3BlY3Q7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEZJRUxEX09GX1ZJRVcuVkVSVElDQUw6XHJcbiAgICAgICAgICBzY2FsZVggPSBmICogX2FzcGVjdDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRklFTERfT0ZfVklFVy5ESUFHT05BTDpcclxuICAgICAgICAgIGNvbnN0IGRpYWdvbmFsQXNwZWN0OiBudW1iZXIgPSBNYXRoLnNxcnQoX2FzcGVjdCk7XHJcbiAgICAgICAgICBzY2FsZVggPSBmICogZGlhZ29uYWxBc3BlY3Q7XHJcbiAgICAgICAgICBzY2FsZVkgPSBmIC8gZGlhZ29uYWxBc3BlY3Q7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbmVhclg6IG51bWJlciA9IF9uZWFyICogc2NhbGVYO1xyXG4gICAgICBjb25zdCBuZWFyWTogbnVtYmVyID0gX25lYXIgKiBzY2FsZVk7XHJcbiAgICAgIGNvbnN0IGZhclg6IG51bWJlciA9IF9mYXIgKiBzY2FsZVg7XHJcbiAgICAgIGNvbnN0IGZhclk6IG51bWJlciA9IF9mYXIgKiBzY2FsZVk7XHJcblxyXG4gICAgICBjb25zdCBmcnVzdHVtOiBWZWN0b3IzW10gPSBuZXcgQXJyYXkoOCkuZmlsbChudWxsKS5tYXAoKCkgPT4gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpKTtcclxuXHJcbiAgICAgIGZydXN0dW1bMF0uc2V0KC1uZWFyWCwgbmVhclksIF9uZWFyKTtcclxuICAgICAgZnJ1c3R1bVsxXS5zZXQobmVhclgsIG5lYXJZLCBfbmVhcik7XHJcbiAgICAgIGZydXN0dW1bMl0uc2V0KG5lYXJYLCAtbmVhclksIF9uZWFyKTtcclxuICAgICAgZnJ1c3R1bVszXS5zZXQoLW5lYXJYLCAtbmVhclksIF9uZWFyKTtcclxuXHJcbiAgICAgIGZydXN0dW1bNF0uc2V0KC1mYXJYLCBmYXJZLCBfZmFyKTtcclxuICAgICAgZnJ1c3R1bVs1XS5zZXQoZmFyWCwgZmFyWSwgX2Zhcik7XHJcbiAgICAgIGZydXN0dW1bNl0uc2V0KGZhclgsIC1mYXJZLCBfZmFyKTtcclxuICAgICAgZnJ1c3R1bVs3XS5zZXQoLWZhclgsIC1mYXJZLCBfZmFyKTtcclxuXHJcbiAgICAgIEdpem1vcy5kcmF3TGluZXMoW1xyXG4gICAgICAgIGZydXN0dW1bMF0sIGZydXN0dW1bMV0sIGZydXN0dW1bMV0sIGZydXN0dW1bMl0sIGZydXN0dW1bMl0sIGZydXN0dW1bM10sIGZydXN0dW1bM10sIGZydXN0dW1bMF0sIC8vIG5lYXIgcGxhbmVcclxuICAgICAgICBmcnVzdHVtWzRdLCBmcnVzdHVtWzVdLCBmcnVzdHVtWzVdLCBmcnVzdHVtWzZdLCBmcnVzdHVtWzZdLCBmcnVzdHVtWzddLCBmcnVzdHVtWzddLCBmcnVzdHVtWzRdLCAvLyBmYXIgcGxhbmVcclxuICAgICAgICBmcnVzdHVtWzBdLCBmcnVzdHVtWzRdLCBmcnVzdHVtWzFdLCBmcnVzdHVtWzVdLCBmcnVzdHVtWzJdLCBmcnVzdHVtWzZdLCBmcnVzdHVtWzNdLCBmcnVzdHVtWzddICAvLyBzaWRlc1xyXG4gICAgICBdLCBfbXR4V29ybGQsIF9jb2xvciwgX2FscGhhT2NjbHVkZWQpO1xyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmVNdWx0aXBsZSguLi5mcnVzdHVtKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgd2lyZWZyYW1lIGN1YmUuIFRoZSBjdWJlIGhhcyBhIHNpZGUtbGVuZ3RoIG9mIDEgYW5kIGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgb3JpZ2luLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXdXaXJlQ3ViZShfbXR4V29ybGQ6IE1hdHJpeDR4NCwgX2NvbG9yOiBDb2xvciwgX2FscGhhT2NjbHVkZWQ6IG51bWJlciA9IEdpem1vcy5hbHBoYU9jY2x1ZGVkKTogdm9pZCB7XHJcbiAgICAgIEdpem1vcy5kcmF3TGluZXMoR2l6bW9zLndpcmVDdWJlLCBfbXR4V29ybGQsIF9jb2xvciwgX2FscGhhT2NjbHVkZWQpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgd2lyZWZyYW1lIHNwaGVyZS4gVGhlIHNwaGVyZSBoYXMgYSBkaWFtZXRlciBvZiAxIGFuZCBpcyBjZW50ZXJlZCBhcm91bmQgdGhlIG9yaWdpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3V2lyZVNwaGVyZShfbXR4V29ybGQ6IE1hdHJpeDR4NCwgX2NvbG9yOiBDb2xvciwgX2FscGhhT2NjbHVkZWQ6IG51bWJlciA9IEdpem1vcy5hbHBoYU9jY2x1ZGVkKTogdm9pZCB7XHJcbiAgICAgIGxldCBtdHhXb3JsZDogTWF0cml4NHg0ID0gX210eFdvcmxkLmNsb25lO1xyXG5cclxuICAgICAgR2l6bW9zLmRyYXdMaW5lcyhHaXptb3Mud2lyZVNwaGVyZSwgbXR4V29ybGQsIF9jb2xvciwgX2FscGhhT2NjbHVkZWQpO1xyXG4gICAgICBtdHhXb3JsZC5sb29rQXQoR2l6bW9zLiNjYW1lcmEubXR4V29ybGQudHJhbnNsYXRpb24pO1xyXG4gICAgICBHaXptb3MuZHJhd1dpcmVDaXJjbGUobXR4V29ybGQsIF9jb2xvciwgX2FscGhhT2NjbHVkZWQpO1xyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4V29ybGQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYSBjb25lIHdpdGggYSBoZWlnaHQgYW5kIGRpYW1ldGVyIG9mIDEuIFRoZSBjb25lIGlzIG9yaWVudGVkIGFsb25nIHRoZSB6LWF4aXMgd2l0aCB0aGUgdGlwIGF0IHRoZSBvcmlnaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhd1dpcmVDb25lKF9tdHhXb3JsZDogTWF0cml4NHg0LCBfY29sb3I6IENvbG9yLCBfYWxwaGFPY2NsdWRlZDogbnVtYmVyID0gR2l6bW9zLmFscGhhT2NjbHVkZWQpOiB2b2lkIHtcclxuICAgICAgR2l6bW9zLmRyYXdMaW5lcyhHaXptb3Mud2lyZUNvbmUsIF9tdHhXb3JsZCwgX2NvbG9yLCBfYWxwaGFPY2NsdWRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIGNpcmNsZSB3aXRoIGEgZGlhbWV0ZXIgb2YgMS4gVGhlIGNpcmNsZSBsaWVzIGluIHRoZSB4LXkgcGxhbmUsIHdpdGggaXRzIGNlbnRlciBhdCB0aGUgb3JpZ2luLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXdXaXJlQ2lyY2xlKF9tdHhXb3JsZDogTWF0cml4NHg0LCBfY29sb3I6IENvbG9yLCBfYWxwaGFPY2NsdWRlZDogbnVtYmVyID0gR2l6bW9zLmFscGhhT2NjbHVkZWQpOiB2b2lkIHtcclxuICAgICAgR2l6bW9zLmRyYXdMaW5lcyhHaXptb3Mud2lyZUNpcmNsZSwgX210eFdvcmxkLCBfY29sb3IsIF9hbHBoYU9jY2x1ZGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGxpbmVzIGJldHdlZW4gZWFjaCBwYWlyIG9mIHRoZSBnaXZlbiB2ZXJ0aWNlcy4gXHJcbiAgICAgKiBWZXJ0aWNlcyBhcmUgcGFpcmVkIHNlcXVlbnRpYWxseSwgc28gZm9yIGV4YW1wbGUsIGxpbmVzIHdpbGwgYmUgZHJhd24gYmV0d2VlbiB2ZXJ0aWNlcyAwIGFuZCAxLCAyIGFuZCAzLCA0IGFuZCA1LCBldGMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhd0xpbmVzKF92ZXJ0aWNlczogVmVjdG9yM1tdLCBfbXR4V29ybGQ6IE1hdHJpeDR4NCwgX2NvbG9yOiBDb2xvciwgX2FscGhhT2NjbHVkZWQ6IG51bWJlciA9IEdpem1vcy5hbHBoYU9jY2x1ZGVkKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGNvbnN0IHNoYWRlcjogU2hhZGVySW50ZXJmYWNlID0gR2l6bW9zLiNwaWNraW5nID8gU2hhZGVyUGljayA6IFNoYWRlckdpem1vO1xyXG4gICAgICBzaGFkZXIudXNlUHJvZ3JhbSgpO1xyXG5cclxuICAgICAgY29uc3QgbGluZURhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoX3ZlcnRpY2VzLmxlbmd0aCAqIDMpO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgX3ZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnQ6IFZlY3RvcjMgPSBfdmVydGljZXNbaV07XHJcbiAgICAgICAgbGluZURhdGEuc2V0KHBvaW50LmdldCgpLCBpICogMyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNyYzMuYmluZFZlcnRleEFycmF5KG51bGwpO1xyXG4gICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIEdpem1vcy5hcnJheUJ1ZmZlcik7XHJcbiAgICAgIGNyYzMuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoU0hBREVSX0FUVFJJQlVURS5QT1NJVElPTik7XHJcbiAgICAgIGNyYzMudmVydGV4QXR0cmliUG9pbnRlcihTSEFERVJfQVRUUklCVVRFLlBPU0lUSU9OLCAzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcblxyXG4gICAgICBHaXptb3MuYnVmZmVyTWF0cml4KHNoYWRlciwgX210eFdvcmxkKTtcclxuICAgICAgY3JjMy5idWZmZXJEYXRhKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCBsaW5lRGF0YSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5EWU5BTUlDX0RSQVcpO1xyXG5cclxuICAgICAgR2l6bW9zLmRyYXdHaXptb3Moc2hhZGVyLCBHaXptb3MuZHJhd0FycmF5cywgX3ZlcnRpY2VzLmxlbmd0aCwgX2NvbG9yLCBfYWxwaGFPY2NsdWRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIHdpcmVmcmFtZSBtZXNoLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXdXaXJlTWVzaChfbWVzaDogTWVzaCwgX210eFdvcmxkOiBNYXRyaXg0eDQsIF9jb2xvcjogQ29sb3IsIF9hbHBoYU9jY2x1ZGVkOiBudW1iZXIgPSBHaXptb3MuYWxwaGFPY2NsdWRlZCk6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjb25zdCBzaGFkZXI6IFNoYWRlckludGVyZmFjZSA9IEdpem1vcy4jcGlja2luZyA/IFNoYWRlclBpY2sgOiBTaGFkZXJHaXptbztcclxuICAgICAgc2hhZGVyLnVzZVByb2dyYW0oKTtcclxuXHJcbiAgICAgIGNvbnN0IHdpcmVCdWZmZXJzOiBSZW5kZXJCdWZmZXJzID0gR2l6bW9zLiNtYXBNZXNoVG9XaXJlQnVmZmVycy5nZXQoX21lc2gpID8/IHt9O1xyXG5cclxuICAgICAgaWYgKCFHaXptb3MuI21hcE1lc2hUb1dpcmVCdWZmZXJzLmhhcyhfbWVzaCkpIHtcclxuICAgICAgICBjb25zdCBpbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHJlbmRlckJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMgPSBfbWVzaC5nZXRSZW5kZXJCdWZmZXJzKCk7XHJcbiAgICAgICAgY29uc3QgcmVuZGVyTWVzaDogUmVuZGVyTWVzaCA9IF9tZXNoLnJlbmRlck1lc2g7XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHJlbmRlck1lc2guaW5kaWNlcy5sZW5ndGg7IGkgKz0gMykgeyAvLyBUT0RPOiB0aGluayBhYm91dCBjYWNoaW5nIHRoaXMgaW4gdGhlIG1lc2hcclxuICAgICAgICAgIGNvbnN0IGE6IG51bWJlciA9IHJlbmRlck1lc2guaW5kaWNlc1tpXTtcclxuICAgICAgICAgIGNvbnN0IGI6IG51bWJlciA9IHJlbmRlck1lc2guaW5kaWNlc1tpICsgMV07XHJcbiAgICAgICAgICBjb25zdCBjOiBudW1iZXIgPSByZW5kZXJNZXNoLmluZGljZXNbaSArIDJdO1xyXG4gIFxyXG4gICAgICAgICAgLy8gQWRkIHRoZSBsaW5lIHNlZ21lbnRzIGZvciB0aGUgdHJpYW5nbGUgdG8gdGhlIGxpbmUgaW5kaWNlc1xyXG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGEsIGIsIGIsIGMsIGMsIGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2V0IHVwIHZlcnRleCBhdHRyaWJ1dGUgb2JqZWN0XHJcbiAgICAgICAgd2lyZUJ1ZmZlcnMudmFvID0gUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMVmVydGV4QXJyYXlPYmplY3Q+KGNyYzMuY3JlYXRlVmVydGV4QXJyYXkoKSk7XHJcbiAgICAgICAgd2lyZUJ1ZmZlcnMuaW5kaWNlcyA9IFJlbmRlcldlYkdMLmFzc2VydChSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCkuY3JlYXRlQnVmZmVyKCkpO1xyXG4gICAgICAgIHdpcmVCdWZmZXJzLnBvc2l0aW9ucyA9IHJlbmRlckJ1ZmZlcnMucG9zaXRpb25zO1xyXG4gICAgICAgIHdpcmVCdWZmZXJzLm5JbmRpY2VzID0gaW5kaWNlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGNyYzMuYmluZFZlcnRleEFycmF5KHdpcmVCdWZmZXJzLnZhbyk7XHJcbiAgICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHdpcmVCdWZmZXJzLmluZGljZXMpO1xyXG4gICAgICAgIGNyYzMuYnVmZmVyRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBuZXcgVWludDE2QXJyYXkoaW5kaWNlcyksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHJlbmRlckJ1ZmZlcnMucG9zaXRpb25zKTtcclxuICAgICAgICBjcmMzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KFNIQURFUl9BVFRSSUJVVEUuUE9TSVRJT04pO1xyXG4gICAgICAgIGNyYzMudmVydGV4QXR0cmliUG9pbnRlcihTSEFERVJfQVRUUklCVVRFLlBPU0lUSU9OLCAzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIEdpem1vcy5idWZmZXJNYXRyaXgoc2hhZGVyLCBfbXR4V29ybGQpO1xyXG4gICAgICBjcmMzLmJpbmRWZXJ0ZXhBcnJheSh3aXJlQnVmZmVycy52YW8pO1xyXG4gICAgICBHaXptb3MuZHJhd0dpem1vcyhzaGFkZXIsIEdpem1vcy5kcmF3RWxlbWVudHNMaW5lcywgd2lyZUJ1ZmZlcnMubkluZGljZXMsIF9jb2xvciwgX2FscGhhT2NjbHVkZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYW4gYXJyb3cgYXQgdGhlIGdpdmVuIHdvcmxkIHBvc2l0aW9uLCBmYWNpbmcgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBsZW5ndGggYW5kIHdpZHRoLiBcclxuICAgICAqIFNpemUgcmVmZXJzIHRvIHRoZSBzaXplIG9mIHRoZSBhcnJvdyBoZWFkOiB0aGUgaGVpZ2h0IG9mIHRoZSBweXJhbWlkOyB0aGUgc2l6ZSBvZiB0aGUgY3ViZTsgdGhlIGRpYW1ldGVyIG9mIHRoZSBzcGhlcmUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhd0Fycm93KF9wb3NpdGlvbjogVmVjdG9yMywgX2NvbG9yOiBDb2xvciwgX2RpcmVjdGlvbjogVmVjdG9yMywgX3VwOiBWZWN0b3IzLCBfbGVuZ3RoOiBudW1iZXIsIF93aWR0aDogbnVtYmVyLCBfc2l6ZTogbnVtYmVyLCBfaGVhZDogdHlwZW9mIE1lc2hDdWJlIHwgdHlwZW9mIE1lc2hQeXJhbWlkIHwgdHlwZW9mIE1lc2hTcGhlcmUgfCBudWxsID0gTWVzaFB5cmFtaWQsIF9hbHBoYU9jY2x1ZGVkOiBudW1iZXIgPSBHaXptb3MuYWxwaGFPY2NsdWRlZCk6IHZvaWQge1xyXG4gICAgICBjb25zdCBzY2FsaW5nOiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMykuc2V0KF93aWR0aCwgX3dpZHRoLCBfbGVuZ3RoIC0gX3NpemUpO1xyXG4gICAgICBjb25zdCBtdHhXb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LkNPTVBPU0lUSU9OKF9wb3NpdGlvbik7XHJcbiAgICAgIG10eFdvcmxkLnNjYWxpbmcgPSBzY2FsaW5nO1xyXG4gICAgICBtdHhXb3JsZC5sb29rSW4oX2RpcmVjdGlvbiwgX3VwKTtcclxuICAgICAgbXR4V29ybGQudHJhbnNsYXRlWigwLjUpO1xyXG4gICAgICBHaXptb3MuZHJhd0N1YmUobXR4V29ybGQsIF9jb2xvciwgX2FscGhhT2NjbHVkZWQpO1xyXG4gICAgICBtdHhXb3JsZC50cmFuc2xhdGVaKDAuNSk7XHJcblxyXG4gICAgICBpZiAoX2hlYWQgPT0gTWVzaFB5cmFtaWQpIHtcclxuICAgICAgICBjb25zdCB3aWR0aEhlYWQ6IG51bWJlciA9IF9zaXplIC8gMjtcclxuICAgICAgICBtdHhXb3JsZC5zY2FsaW5nID0gc2NhbGluZy5zZXQod2lkdGhIZWFkLCB3aWR0aEhlYWQsIF9zaXplKTtcclxuICAgICAgICBtdHhXb3JsZC5yb3RhdGVYKDkwKTsgLy8gcm90YXRlIHRoZSBweXJhbWlkIHNvIGl0IHBvaW50cyBpbiB0aGUgcmlnaHQgZGlyZWN0aW9uXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbXR4V29ybGQuc2NhbGluZyA9IHNjYWxpbmcuc2V0KF9zaXplLCBfc2l6ZSwgX3NpemUpO1xyXG4gICAgICAgIG10eFdvcmxkLnRyYW5zbGF0ZVooMC41KTsgLy8gdHJhbnNsYXRlIGN1YmUvc3BoZXJlIHNvIGl0IHNpdHMgb24gdG9wIG9mIHRoZSBhcnJvd1xyXG4gICAgICB9XHJcblxyXG4gICAgICBHaXptb3MuZHJhd01lc2goR2l6bW9zLmdldE1lc2goX2hlYWQpLCBtdHhXb3JsZCwgX2NvbG9yLCBfYWxwaGFPY2NsdWRlZCk7XHJcblxyXG4gICAgICBSZWN5Y2xlci5zdG9yZU11bHRpcGxlKG10eFdvcmxkLCBzY2FsaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgc29saWQgY3ViZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3Q3ViZShfbXR4V29ybGQ6IE1hdHJpeDR4NCwgX2NvbG9yOiBDb2xvciwgX2FscGhhT2NjbHVkZWQ6IG51bWJlciA9IEdpem1vcy5hbHBoYU9jY2x1ZGVkKTogdm9pZCB7XHJcbiAgICAgIEdpem1vcy5kcmF3TWVzaChHaXptb3MuZ2V0TWVzaChNZXNoQ3ViZSksIF9tdHhXb3JsZCwgX2NvbG9yLCBfYWxwaGFPY2NsdWRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIHNvbGlkIHNwaGVyZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3U3BoZXJlKF9tdHhXb3JsZDogTWF0cml4NHg0LCBfY29sb3I6IENvbG9yLCBfYWxwaGFPY2NsdWRlZDogbnVtYmVyID0gR2l6bW9zLmFscGhhT2NjbHVkZWQpOiB2b2lkIHtcclxuICAgICAgR2l6bW9zLmRyYXdNZXNoKEdpem1vcy5nZXRNZXNoKE1lc2hTcGhlcmUpLCBfbXR4V29ybGQsIF9jb2xvciwgX2FscGhhT2NjbHVkZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYSBzb2xpZCBxdWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXdRdWFkKF9tdHhXb3JsZDogTWF0cml4NHg0LCBfY29sb3I6IENvbG9yLCBfYWxwaGFPY2NsdWRlZDogbnVtYmVyID0gR2l6bW9zLmFscGhhT2NjbHVkZWQpOiB2b2lkIHtcclxuICAgICAgR2l6bW9zLmRyYXdNZXNoKEdpem1vcy5nZXRNZXNoKE1lc2hRdWFkKSwgX210eFdvcmxkLCBfY29sb3IsIF9hbHBoYU9jY2x1ZGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgc29saWQgZG91YmxlIHNpZGVkIHF1YWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhd1Nwcml0ZShfbXR4V29ybGQ6IE1hdHJpeDR4NCwgX2NvbG9yOiBDb2xvciwgX2FscGhhT2NjbHVkZWQ6IG51bWJlciA9IEdpem1vcy5hbHBoYU9jY2x1ZGVkKTogdm9pZCB7XHJcbiAgICAgIEdpem1vcy5kcmF3TWVzaChHaXptb3MuZ2V0TWVzaChNZXNoU3ByaXRlKSwgX210eFdvcmxkLCBfY29sb3IsIF9hbHBoYU9jY2x1ZGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgc29saWQgcHlyYW1pZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3UHlyYW1pZChfbXR4V29ybGQ6IE1hdHJpeDR4NCwgX2NvbG9yOiBDb2xvciwgX2FscGhhT2NjbHVkZWQ6IG51bWJlciA9IEdpem1vcy5hbHBoYU9jY2x1ZGVkKTogdm9pZCB7XHJcbiAgICAgIEdpem1vcy5kcmF3TWVzaChHaXptb3MuZ2V0TWVzaChNZXNoUHlyYW1pZCksIF9tdHhXb3JsZCwgX2NvbG9yLCBfYWxwaGFPY2NsdWRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIHNvbGlkIG1lc2guXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhd01lc2goX21lc2g6IE1lc2gsIF9tdHhXb3JsZDogTWF0cml4NHg0LCBfY29sb3I6IENvbG9yLCBfYWxwaGFPY2NsdWRlZDogbnVtYmVyID0gR2l6bW9zLmFscGhhT2NjbHVkZWQpOiB2b2lkIHtcclxuICAgICAgY29uc3Qgc2hhZGVyOiBTaGFkZXJJbnRlcmZhY2UgPSBHaXptb3MuI3BpY2tpbmcgPyBTaGFkZXJQaWNrIDogU2hhZGVyR2l6bW87XHJcbiAgICAgIHNoYWRlci51c2VQcm9ncmFtKCk7XHJcbiAgICAgIFxyXG4gICAgICBSZW5kZXJXZWJHTC51c2VOb2RlVW5pZm9ybXMoc2hhZGVyLCBfbXR4V29ybGQsIG51bGwsIG51bGwsIEdpem1vcy5waWNrSWQpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVycyA9IF9tZXNoLnVzZVJlbmRlckJ1ZmZlcnMoKTtcclxuICAgICAgR2l6bW9zLmRyYXdHaXptb3Moc2hhZGVyLCBHaXptb3MuZHJhd0VsZW1lbnRzVHJpYW5sZ2VzLCByZW5kZXJCdWZmZXJzLm5JbmRpY2VzLCBfY29sb3IsIF9hbHBoYU9jY2x1ZGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGFuIGljb24gZnJvbSBhIHtAbGluayBUZXh0dXJlfSBvbiBhIHtAbGluayBNZXNoUXVhZH0uIFRoZSBpY29uIGlzIGFmZmVjdGVkIGJ5IHRoZSBnaXZlbiB0cmFuc2Zvcm0gYW5kIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXdJY29uKF90ZXh0dXJlOiBUZXh0dXJlLCBfbXR4V29ybGQ6IE1hdHJpeDR4NCwgX2NvbG9yOiBDb2xvciwgX2FscGhhT2NjbHVkZWQ6IG51bWJlciA9IEdpem1vcy5hbHBoYU9jY2x1ZGVkKTogdm9pZCB7XHJcbiAgICAgIGxldCBwb3NpdGlvbjogc3RyaW5nID0gX210eFdvcmxkLnRyYW5zbGF0aW9uLnRvU3RyaW5nKCk7XHJcbiAgICAgIGlmIChHaXptb3MucG9zSWNvbnMuaGFzKHBvc2l0aW9uKSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIEdpem1vcy5wb3NJY29ucy5hZGQocG9zaXRpb24pO1xyXG5cclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHJcbiAgICAgIGNvbnN0IHNoYWRlcjogU2hhZGVySW50ZXJmYWNlID0gR2l6bW9zLiNwaWNraW5nID8gU2hhZGVyUGlja1RleHR1cmVkIDogU2hhZGVyR2l6bW9UZXh0dXJlZDtcclxuICAgICAgc2hhZGVyLnVzZVByb2dyYW0oKTtcclxuXHJcbiAgICAgIGxldCBtdHhXb3JsZDogTWF0cml4NHg0ID0gX210eFdvcmxkLmNsb25lO1xyXG4gICAgICBsZXQgY29sb3I6IENvbG9yID0gX2NvbG9yLmNsb25lO1xyXG5cclxuICAgICAgbGV0IGJhY2s6IFZlY3RvcjMgPSBHaXptb3MuI2NhbWVyYS5tdHhXb3JsZC5mb3J3YXJkLm5lZ2F0ZSgpO1xyXG4gICAgICBsZXQgdXA6IFZlY3RvcjMgPSBHaXptb3MuI2NhbWVyYS5tdHhXb3JsZC51cDtcclxuICAgICAgbXR4V29ybGQubG9va0luKGJhY2ssIHVwKTtcclxuXHJcbiAgICAgIGxldCBkaXN0YW5jZTogbnVtYmVyID0gVmVjdG9yMy5ESUZGRVJFTkNFKEdpem1vcy4jY2FtZXJhLm10eFdvcmxkLnRyYW5zbGF0aW9uLCBtdHhXb3JsZC50cmFuc2xhdGlvbikubWFnbml0dWRlO1xyXG4gICAgICBsZXQgZmFkZUZhcjogbnVtYmVyID0gNDtcclxuICAgICAgbGV0IGZhZGVOZWFyOiBudW1iZXIgPSAxLjU7XHJcbiAgICAgIGlmIChkaXN0YW5jZSA+IDAgJiYgZGlzdGFuY2UgPCBmYWRlRmFyKSB7XHJcbiAgICAgICAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgLSBmYWRlTmVhcikgLyAoZmFkZUZhciAtIGZhZGVOZWFyKTtcclxuICAgICAgICBjb2xvci5hID0gQ2FsYy5sZXJwKDAsIGNvbG9yLmEsIGRpc3RhbmNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgX3RleHR1cmUudXNlUmVuZGVyRGF0YShURVhUVVJFX0xPQ0FUSU9OLkNPTE9SLlVOSVQpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0xaShzaGFkZXIudW5pZm9ybXNbVEVYVFVSRV9MT0NBVElPTi5DT0xPUi5VTklGT1JNXSwgVEVYVFVSRV9MT0NBVElPTi5DT0xPUi5JTkRFWCk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTC51c2VOb2RlVW5pZm9ybXMoc2hhZGVyLCBtdHhXb3JsZCwgbnVsbCwgbnVsbCwgR2l6bW9zLnBpY2tJZCk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzID0gR2l6bW9zLmdldE1lc2goTWVzaFF1YWQpLnVzZVJlbmRlckJ1ZmZlcnMoKTtcclxuICAgICAgR2l6bW9zLmRyYXdHaXptb3Moc2hhZGVyLCBHaXptb3MuZHJhd0VsZW1lbnRzVHJpYW5sZ2VzLCByZW5kZXJCdWZmZXJzLm5JbmRpY2VzLCBjb2xvciwgX2FscGhhT2NjbHVkZWQpO1xyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmVNdWx0aXBsZShtdHhXb3JsZCwgY29sb3IsIGJhY2ssIHVwKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBidWZmZXJDb2xvcihfc2hhZGVyOiBTaGFkZXJJbnRlcmZhY2UsIF9jb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpLnVuaWZvcm00ZnYoX3NoYWRlci51bmlmb3Jtc1tcInVfdmN0Q29sb3JcIl0sIF9jb2xvci5nZXQoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgYnVmZmVyTWF0cml4KF9zaGFkZXI6IFNoYWRlckludGVyZmFjZSwgX210eFdvcmxkOiBNYXRyaXg0eDQpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpLnVuaWZvcm1NYXRyaXg0ZnYoX3NoYWRlci51bmlmb3Jtc1tcInVfbXR4TWVzaFRvV29ybGRcIl0sIGZhbHNlLCBfbXR4V29ybGQuZ2V0KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGRyYXdHaXptb3MoX3NoYWRlcjogU2hhZGVySW50ZXJmYWNlLCBfZHJhdzogRnVuY3Rpb24sIF9jb3VudDogbnVtYmVyLCBfY29sb3I6IENvbG9yLCBfYWxwaGFPY2NsdWRlZDogbnVtYmVyID0gR2l6bW9zLmFscGhhT2NjbHVkZWQpOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHJcbiAgICAgIGlmIChfYWxwaGFPY2NsdWRlZCA+IDApIHtcclxuICAgICAgICBsZXQgY29sb3I6IENvbG9yID0gX2NvbG9yLmNsb25lO1xyXG4gICAgICAgIGNvbG9yLmEgKj0gX2FscGhhT2NjbHVkZWQ7XHJcblxyXG4gICAgICAgIC8vIGRyYXcgb2NjbHVkZWQgcGFydHMgd2hlcmUgdGhlIGRlcHRoIHRlc3QgZmFpbGVkIChieSBpbnZlcnRpbmcgdGhlIGRlcHRoIHRlc3QgKyBubyBkZXB0aCB3cml0ZSlcclxuICAgICAgICBjcmMzLmRlcHRoRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkdFUVVBTCk7XHJcbiAgICAgICAgY3JjMy5kZXB0aE1hc2soZmFsc2UpO1xyXG4gICAgICAgIEdpem1vcy5idWZmZXJDb2xvcihfc2hhZGVyLCBjb2xvcik7XHJcbiAgICAgICAgX2RyYXcoX2NvdW50KTtcclxuICAgICAgICBjcmMzLmRlcHRoRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkxFU1MpO1xyXG4gICAgICAgIGNyYzMuZGVwdGhNYXNrKHRydWUpO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKGNvbG9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgR2l6bW9zLmJ1ZmZlckNvbG9yKF9zaGFkZXIsIF9jb2xvcik7XHJcbiAgICAgIF9kcmF3KF9jb3VudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZHJhd0VsZW1lbnRzVHJpYW5sZ2VzKF9jb3VudDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKS5kcmF3RWxlbWVudHMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsIF9jb3VudCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZHJhd0VsZW1lbnRzTGluZXMoX2NvdW50OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpLmRyYXdFbGVtZW50cyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkxJTkVTLCBfY291bnQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGRyYXdBcnJheXMoX2NvdW50OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpLmRyYXdBcnJheXMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5MSU5FUywgMCwgX2NvdW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRNZXNoKF9jb25zdHJ1Y3RvcjogbmV3IChfbmFtZTogc3RyaW5nKSA9PiBNZXNoKTogTWVzaCB7XHJcbiAgICAgIGxldCBrZXk6IHN0cmluZyA9IF9jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICBsZXQgbWVzaDogTWVzaCA9IEdpem1vcy4jbWVzaGVzW2tleV07XHJcbiAgICAgIGlmIChtZXNoKVxyXG4gICAgICAgIHJldHVybiBtZXNoO1xyXG5cclxuICAgICAgbWVzaCA9IG5ldyBfY29uc3RydWN0b3Ioa2V5KTtcclxuICAgICAgUHJvamVjdC5kZXJlZ2lzdGVyKG1lc2gpO1xyXG4gICAgICBHaXptb3MuI21lc2hlc1trZXldID0gbWVzaDtcclxuICAgICAgcmV0dXJuIG1lc2g7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IHR5cGUgTWFwTGlnaHRUeXBlVG9MaWdodExpc3QgPSBNYXA8VHlwZU9mTGlnaHQsIFJlY3ljYWJsZUFycmF5PENvbXBvbmVudExpZ2h0Pj47XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyUHJlcGFyZU9wdGlvbnMge1xyXG4gICAgaWdub3JlUGh5c2ljcz86IGJvb2xlYW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgbWFpbiBpbnRlcmZhY2UgdG8gdGhlIHJlbmRlciBlbmdpbmUsIGhlcmUgV2ViR0wgKHNlZSBzdXBlcmNsYXNzIHtAbGluayBSZW5kZXJXZWJHTH0gYW5kIHRoZSBSZW5kZXJJbmplY3RvcnNcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyIGV4dGVuZHMgUmVuZGVyV2ViR0wge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWN0Q2xpcDogUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSgtMSwgMSwgMiwgLTIpO1xyXG4gICAgcHVibGljIHN0YXRpYyBwaWNrQnVmZmVyOiBJbnQzMkFycmF5OyAgIC8vIFRPRE86IHJlc2VhcmNoIGlmIHBpY2tpbmcgc2hvdWxkIGJlIG9wdGltaXplZCB1c2luZyByYWRpdXMgcGlja2luZyB0byBmaWx0ZXJcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgbm9kZXNQaHlzaWNzOiBSZWN5Y2FibGVBcnJheTxOb2RlPiA9IG5ldyBSZWN5Y2FibGVBcnJheSgpO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRzUGljazogUmVjeWNhYmxlQXJyYXk8Q29tcG9uZW50UGljaz4gPSBuZXcgUmVjeWNhYmxlQXJyYXkoKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgbGlnaHRzOiBNYXBMaWdodFR5cGVUb0xpZ2h0TGlzdCA9IG5ldyBNYXAoKTtcclxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IG5vZGVzU2ltcGxlOiBSZWN5Y2FibGVBcnJheTxOb2RlPiA9IG5ldyBSZWN5Y2FibGVBcnJheSgpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgbm9kZXNBbHBoYTogUmVjeWNhYmxlQXJyYXk8Tm9kZT4gPSBuZXcgUmVjeWNhYmxlQXJyYXkoKTtcclxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudHNTa2VsZXRvbjogUmVjeWNhYmxlQXJyYXk8Q29tcG9uZW50U2tlbGV0b24+ID0gbmV3IFJlY3ljYWJsZUFycmF5KCk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBjb2F0czogU2V0PENvYXQ+ID0gbmV3IFNldCgpOyAvLyBUT0RPOiB0ZXN0IGlmIHNldHMgYXJlIGFuIGFwcHJvcHJpYXRlIGRhdGEgc3RydWN0dXJlIGhlcmVcclxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IG1vZGlmaWNhdGlvbnNQcm9jZXNzZWQ6IFNldDx7IG1vZGlmaWVkOiBib29sZWFuIH0+ID0gbmV3IFNldCgpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdGltZXN0YW1wVXBkYXRlOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWN1cnNpdmVseSBpdGVyYXRlcyBvdmVyIHRoZSBicmFuY2ggc3RhcnRpbmcgd2l0aCB0aGUgbm9kZSBnaXZlbiwgcmVjYWxjdWxhdGVzIGFsbCB3b3JsZCB0cmFuc2Zvcm1zLCBcclxuICAgICAqIGNvbGxlY3RzIGFsbCBsaWdodHMgYW5kIGZlZWRzIGFsbCBzaGFkZXJzIHVzZWQgaW4gdGhlIGdyYXBoIHdpdGggdGhlc2UgbGlnaHRzLiBTb3J0cyBub2RlcyBmb3IgZGlmZmVyZW50XHJcbiAgICAgKiByZW5kZXIgcGFzc2VzLlxyXG4gICAgICogQHBhcmFtIF9yZWNhbGN1bGF0ZSAtIHNldCB0cnVlIHRvIGZvcmNlIHJlY2FsY3VsYXRpb24gb2YgYWxsIHdvcmxkIHRyYW5zZm9ybXMgaW4gdGhlIGdpdmVuIGJyYW5jaCwgZXZlbiBpZiB0aGVpciBsb2NhbCB0cmFuc2Zvcm1zIGhhdmVuJ3QgY2hhbmdlZFxyXG4gICAgICovXHJcbiAgICBAUGVyZm9ybWFuY2VNb25pdG9yLm1lYXN1cmUoXCJSZW5kZXIucHJlcGFyZVwiKVxyXG4gICAgcHVibGljIHN0YXRpYyBwcmVwYXJlKF9icmFuY2g6IE5vZGUsIF9vcHRpb25zOiBSZW5kZXJQcmVwYXJlT3B0aW9ucyA9IHt9LCBfbXR4V29ybGQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpLCBfcmVjYWxjdWxhdGU6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBSZW5kZXIudGltZXN0YW1wVXBkYXRlID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIFJlbmRlci5ub2Rlc1NpbXBsZS5yZXNldCgpO1xyXG4gICAgICBSZW5kZXIubm9kZXNBbHBoYS5yZXNldCgpO1xyXG4gICAgICBSZW5kZXIubm9kZXNQaHlzaWNzLnJlc2V0KCk7XHJcbiAgICAgIFJlbmRlci5jb21wb25lbnRzUGljay5yZXNldCgpO1xyXG4gICAgICBSZW5kZXIuY29tcG9uZW50c1NrZWxldG9uLnJlc2V0KCk7XHJcbiAgICAgIFJlbmRlci5jb2F0cy5jbGVhcigpO1xyXG4gICAgICBSZW5kZXIubW9kaWZpY2F0aW9uc1Byb2Nlc3NlZC5jbGVhcigpO1xyXG4gICAgICBSZW5kZXIubGlnaHRzLmZvckVhY2goX2FycmF5ID0+IF9hcnJheS5yZXNldCgpKTtcclxuICAgICAgTm9kZS5yZXNldFJlbmRlckRhdGEoKTtcclxuICAgICAgQ29hdC5yZXNldFJlbmRlckRhdGEoKTtcclxuXHJcbiAgICAgIF9icmFuY2guZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuUkVOREVSX1BSRVBBUkVfU1RBUlQpKTtcclxuXHJcbiAgICAgIHRoaXMucHJlcGFyZUJyYW5jaChfYnJhbmNoLCBfb3B0aW9ucywgX210eFdvcmxkLCBfcmVjYWxjdWxhdGUpO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBwcm9jZXNzZWQgb2YgUmVuZGVyLm1vZGlmaWNhdGlvbnNQcm9jZXNzZWQpXHJcbiAgICAgICAgcHJvY2Vzc2VkLm1vZGlmaWVkID0gZmFsc2U7XHJcbiAgICAgIF9icmFuY2guZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuUkVOREVSX1BSRVBBUkVfRU5EKSk7XHJcbiAgICAgIGZvciAoY29uc3QgY21wU2tlbGV0b24gb2YgUmVuZGVyLmNvbXBvbmVudHNTa2VsZXRvbikge1xyXG4gICAgICAgIGNtcFNrZWxldG9uLnVwZGF0ZSgpO1xyXG4gICAgICAgIGNtcFNrZWxldG9uLnVwZGF0ZVJlbmRlckJ1ZmZlcigpO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoY29uc3QgY29hdCBvZiBSZW5kZXIuY29hdHMpXHJcbiAgICAgICAgY29hdC51cGRhdGVSZW5kZXJEYXRhKCk7XHJcblxyXG4gICAgICBOb2RlLnVwZGF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG4gICAgICBDb2F0LnVwZGF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG5cclxuICAgICAgUmVuZGVyLmJ1ZmZlckxpZ2h0cyhSZW5kZXIubGlnaHRzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFkZExpZ2h0cyhfY21wTGlnaHRzOiBDb21wb25lbnRMaWdodFtdKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGNtcExpZ2h0IG9mIF9jbXBMaWdodHMpIHtcclxuICAgICAgICBpZiAoIWNtcExpZ2h0LmlzQWN0aXZlKVxyXG4gICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgIGxldCB0eXBlOiBUeXBlT2ZMaWdodCA9IGNtcExpZ2h0LmxpZ2h0LmdldFR5cGUoKTtcclxuICAgICAgICBsZXQgbGlnaHRzT2ZUeXBlOiBSZWN5Y2FibGVBcnJheTxDb21wb25lbnRMaWdodD4gPSBSZW5kZXIubGlnaHRzLmdldCh0eXBlKTtcclxuICAgICAgICBpZiAoIWxpZ2h0c09mVHlwZSkge1xyXG4gICAgICAgICAgbGlnaHRzT2ZUeXBlID0gbmV3IFJlY3ljYWJsZUFycmF5PENvbXBvbmVudExpZ2h0PigpO1xyXG4gICAgICAgICAgUmVuZGVyLmxpZ2h0cy5zZXQodHlwZSwgbGlnaHRzT2ZUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGlnaHRzT2ZUeXBlLnB1c2goY21wTGlnaHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHdpdGggYSB7QGxpbmsgUGlja2VyfS1jYW1lcmEsIHRoaXMgbWV0aG9kIHJlbmRlcnMgb25lIHBpeGVsIHdpdGggcGlja2luZyBpbmZvcm1hdGlvbiBcclxuICAgICAqIGZvciBlYWNoIG5vZGUgaW4gdGhlIGxpbmUgb2Ygc2lnaHQgYW5kIHJldHVybiB0aGF0IGFzIGFuIHVuc29ydGVkIHtAbGluayBQaWNrfS1hcnJheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHBpY2soX25vZGVzOiBOb2RlW10sIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSk6IFBpY2tbXSB7IC8vIFRPRE86IHNlZSBpZiB0aGlyZCBwYXJhbWV0ZXIgX3dvcmxkPzogTWF0cml4NHg0IHdvdWxkIGJlIHVzZWZ1bGxcclxuICAgICAgcmV0dXJuIFJlbmRlci5waWNrRnJvbShfbm9kZXMsIF9jbXBDYW1lcmEsIHN1cGVyLnBpY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIHNjZW5lIGZyb20gdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhlIGdpdmVuIGNhbWVyYVxyXG4gICAgICovXHJcbiAgICBAUGVyZm9ybWFuY2VNb25pdG9yLm1lYXN1cmUoXCJSZW5kZXIuZHJhd1wiKVxyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3KF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBub2RlIG9mIFJlbmRlci5ub2Rlc0FscGhhKVxyXG4gICAgICAgIFJlZmxlY3Quc2V0KG5vZGUsIFwiekNhbWVyYVwiLCBfY21wQ2FtZXJhLnBvaW50V29ybGRUb0NsaXAobm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCkubXR4V29ybGQudHJhbnNsYXRpb24pLnopO1xyXG5cclxuICAgICAgY29uc3Qgc29ydGVkOiBOb2RlW10gPSBSZW5kZXIubm9kZXNBbHBoYS5nZXRTb3J0ZWQoKF9hOiBOb2RlLCBfYjogTm9kZSkgPT4gUmVmbGVjdC5nZXQoX2IsIFwiekNhbWVyYVwiKSAtIFJlZmxlY3QuZ2V0KF9hLCBcInpDYW1lcmFcIikpO1xyXG5cclxuICAgICAgUmVuZGVyLmRyYXdOb2RlcyhSZW5kZXIubm9kZXNTaW1wbGUsIHNvcnRlZCwgX2NtcENhbWVyYSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJlcGFyZUJyYW5jaChfYnJhbmNoOiBOb2RlLCBfb3B0aW9uczogUmVuZGVyUHJlcGFyZU9wdGlvbnMsIF9tdHhXb3JsZDogTWF0cml4NHg0LCBfcmVjYWxjdWxhdGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKCFfYnJhbmNoLmlzQWN0aXZlKVxyXG4gICAgICAgIHJldHVybjsgLy8gZG9uJ3QgYWRkIGJyYW5jaCB0byByZW5kZXIgbGlzdCBpZiBub3QgYWN0aXZlXHJcblxyXG4gICAgICBfYnJhbmNoLm5Ob2Rlc0luQnJhbmNoID0gMTtcclxuICAgICAgX2JyYW5jaC5yYWRpdXMgPSAwO1xyXG5cclxuICAgICAgX2JyYW5jaC5kaXNwYXRjaEV2ZW50VG9UYXJnZXRPbmx5KG5ldyBFdmVudChFVkVOVC5SRU5ERVJfUFJFUEFSRSkpO1xyXG4gICAgICBfYnJhbmNoLnRpbWVzdGFtcFVwZGF0ZSA9IFJlbmRlci50aW1lc3RhbXBVcGRhdGU7XHJcblxyXG4gICAgICBsZXQgY21wVHJhbnNmb3JtOiBDb21wb25lbnRUcmFuc2Zvcm0gPSBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRUcmFuc2Zvcm0pO1xyXG4gICAgICBpZiAoY21wVHJhbnNmb3JtICYmIGNtcFRyYW5zZm9ybS5pc0FjdGl2ZSkge1xyXG4gICAgICAgIGlmICgoX3JlY2FsY3VsYXRlIHx8PSBjbXBUcmFuc2Zvcm0ubXR4TG9jYWwubW9kaWZpZWQpKSB7XHJcbiAgICAgICAgICAvLyBQZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNZWFzdXJlKFwiUmVuZGVyLnByZXBhcmUgbXR4V29ybGQgKiBtdHhMb2NhbFwiKTtcclxuICAgICAgICAgIGxldCBtdHhXb3JsZEJyYW5jaDogTWF0cml4NHg0ID0gTWF0cml4NHg0LlBST0RVQ1QoX210eFdvcmxkLCBfYnJhbmNoLmNtcFRyYW5zZm9ybS5tdHhMb2NhbCk7XHJcbiAgICAgICAgICAvLyBQZXJmb3JtYW5jZU1vbml0b3IuZW5kTWVhc3VyZShcIlJlbmRlci5wcmVwYXJlIG10eFdvcmxkICogbXR4TG9jYWxcIik7XHJcbiAgICAgICAgICBfYnJhbmNoLm10eFdvcmxkLmNvcHkobXR4V29ybGRCcmFuY2gpO1xyXG4gICAgICAgICAgUmVjeWNsZXIuc3RvcmUobXR4V29ybGRCcmFuY2gpO1xyXG4gICAgICAgICAgUmVuZGVyLm1vZGlmaWNhdGlvbnNQcm9jZXNzZWQuYWRkKGNtcFRyYW5zZm9ybS5tdHhMb2NhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2VcclxuICAgICAgICBfYnJhbmNoLm10eFdvcmxkLmNvcHkoX210eFdvcmxkKTsgLy8gb3ZlcndyaXRlIHJlYWRvbmx5IG10eFdvcmxkIG9mIHRoZSBjdXJyZW50IG5vZGVcclxuXHJcbiAgICAgIGxldCBjbXBSaWdpZGJvZHk6IENvbXBvbmVudFJpZ2lkYm9keSA9IF9icmFuY2guZ2V0Q29tcG9uZW50KENvbXBvbmVudFJpZ2lkYm9keSk7XHJcbiAgICAgIGlmIChjbXBSaWdpZGJvZHkgJiYgY21wUmlnaWRib2R5LmlzQWN0aXZlKSB7IC8vVE9ETzogc3VwcG9ydCBkZS0vYWN0aXZhdGlvbiB0aHJvdWdob3V0XHJcbiAgICAgICAgUmVuZGVyLm5vZGVzUGh5c2ljcy5wdXNoKF9icmFuY2gpOyAvLyBhZGQgdGhpcyBub2RlIHRvIHBoeXNpY3MgbGlzdFxyXG4gICAgICAgIGlmICghX29wdGlvbnM/Lmlnbm9yZVBoeXNpY3MpXHJcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybUJ5UGh5c2ljcyhfYnJhbmNoLCBjbXBSaWdpZGJvZHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgY21wUGljazogQ29tcG9uZW50UGljayA9IF9icmFuY2guZ2V0Q29tcG9uZW50KENvbXBvbmVudFBpY2spO1xyXG4gICAgICBpZiAoY21wUGljayAmJiBjbXBQaWNrLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgUmVuZGVyLmNvbXBvbmVudHNQaWNrLnB1c2goY21wUGljayk7IC8vIGFkZCB0aGlzIGNvbXBvbmVudCB0byBwaWNrIGxpc3RcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGNtcExpZ2h0czogQ29tcG9uZW50TGlnaHRbXSA9IF9icmFuY2guZ2V0Q29tcG9uZW50cyhDb21wb25lbnRMaWdodCk7XHJcbiAgICAgIFJlbmRlci5hZGRMaWdodHMoY21wTGlnaHRzKTtcclxuXHJcbiAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gX2JyYW5jaC5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCk7XHJcbiAgICAgIGxldCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwgPSBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRNYXRlcmlhbCk7XHJcblxyXG4gICAgICBpZiAoY21wTWVzaCAmJiBjbXBNZXNoLmlzQWN0aXZlICYmIGNtcE1hdGVyaWFsICYmIGNtcE1hdGVyaWFsLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgaWYgKGNtcE1lc2gubXR4UGl2b3QubW9kaWZpZWQgfHwgX2JyYW5jaC5tdHhXb3JsZC5tb2RpZmllZCkge1xyXG4gICAgICAgICAgLy8gUGVyZm9ybWFuY2VNb25pdG9yLnN0YXJ0TWVhc3VyZShcIlJlbmRlci5wcmVwYXJlIG10eFdvcmxkICogbXR4UGl2b3RcIik7XHJcbiAgICAgICAgICBsZXQgbXR4V29ybGRNZXNoOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUFJPRFVDVChfYnJhbmNoLm10eFdvcmxkLCBjbXBNZXNoLm10eFBpdm90KTtcclxuICAgICAgICAgIC8vIFBlcmZvcm1hbmNlTW9uaXRvci5lbmRNZWFzdXJlKFwiUmVuZGVyLnByZXBhcmUgbXR4V29ybGQgKiBtdHhQaXZvdFwiKTtcclxuICAgICAgICAgIGNtcE1lc2gubXR4V29ybGQuY29weShtdHhXb3JsZE1lc2gpO1xyXG4gICAgICAgICAgUmVjeWNsZXIuc3RvcmUobXR4V29ybGRNZXNoKTsgLy8gVE9ETzogZXhhbWluZSwgd2h5IHJlY3ljbGluZyB0aGlzIGNhdXNlcyBtZXNoZXMgdG8gYmUgbWlzcGxhY2VkLi4uXHJcbiAgICAgICAgICBSZW5kZXIubW9kaWZpY2F0aW9uc1Byb2Nlc3NlZC5hZGQoY21wTWVzaC5tdHhQaXZvdCk7XHJcbiAgICAgICAgICBSZW5kZXIubW9kaWZpY2F0aW9uc1Byb2Nlc3NlZC5hZGQoX2JyYW5jaC5tdHhXb3JsZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY21wRmFjZUNhbWVyYTogQ29tcG9uZW50RmFjZUNhbWVyYSA9IF9icmFuY2guZ2V0Q29tcG9uZW50KENvbXBvbmVudEZhY2VDYW1lcmEpO1xyXG4gICAgICAgIGxldCBjbXBQYXJ0aWNsZVN5c3RlbTogQ29tcG9uZW50UGFydGljbGVTeXN0ZW0gPSBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSk7XHJcbiAgICAgICAgX2JyYW5jaC51cGRhdGVSZW5kZXJEYXRhKGNtcE1lc2gsIGNtcE1hdGVyaWFsLCBjbXBGYWNlQ2FtZXJhLCBjbXBQYXJ0aWNsZVN5c3RlbSk7XHJcblxyXG4gICAgICAgIF9icmFuY2gucmFkaXVzID0gY21wTWVzaC5yYWRpdXM7XHJcbiAgICAgICAgaWYgKGNtcE1hdGVyaWFsLnNvcnRGb3JBbHBoYSB8fCBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRUZXh0KSkgLy8gYWx3YXlzIHNvcnQgdGV4dCBmb3IgYWxwaGFcclxuICAgICAgICAgIFJlbmRlci5ub2Rlc0FscGhhLnB1c2goX2JyYW5jaCk7IC8vIGFkZCB0aGlzIG5vZGUgdG8gcmVuZGVyIGxpc3RcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBSZW5kZXIubm9kZXNTaW1wbGUucHVzaChfYnJhbmNoKTsgLy8gYWRkIHRoaXMgbm9kZSB0byByZW5kZXIgbGlzdFxyXG5cclxuICAgICAgICBsZXQgbWF0ZXJpYWw6IE1hdGVyaWFsID0gY21wTWF0ZXJpYWwubWF0ZXJpYWw7XHJcbiAgICAgICAgaWYgKG1hdGVyaWFsKVxyXG4gICAgICAgICAgUmVuZGVyLmNvYXRzLmFkZChtYXRlcmlhbC5jb2F0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGNtcFNrZWxldG9uczogQ29tcG9uZW50U2tlbGV0b25bXSA9IF9icmFuY2guZ2V0Q29tcG9uZW50cyhDb21wb25lbnRTa2VsZXRvbik7XHJcbiAgICAgIGZvciAobGV0IGNtcFNrZWxldG9uIG9mIGNtcFNrZWxldG9ucylcclxuICAgICAgICBpZiAoY21wU2tlbGV0b24gJiYgY21wU2tlbGV0b24uaXNBY3RpdmUpXHJcbiAgICAgICAgICBSZW5kZXIuY29tcG9uZW50c1NrZWxldG9uLnB1c2goY21wU2tlbGV0b24pO1xyXG5cclxuICAgICAgZm9yIChsZXQgY2hpbGQgb2YgX2JyYW5jaC5nZXRDaGlsZHJlbigpKSB7XHJcbiAgICAgICAgUmVuZGVyLnByZXBhcmVCcmFuY2goY2hpbGQsIF9vcHRpb25zLCBfYnJhbmNoLm10eFdvcmxkLCBfcmVjYWxjdWxhdGUpO1xyXG5cclxuICAgICAgICBfYnJhbmNoLm5Ob2Rlc0luQnJhbmNoICs9IGNoaWxkLm5Ob2Rlc0luQnJhbmNoO1xyXG4gICAgICAgIGxldCBjbXBNZXNoQ2hpbGQ6IENvbXBvbmVudE1lc2ggPSBjaGlsZC5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCk7XHJcbiAgICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IzID0gY21wTWVzaENoaWxkID8gY21wTWVzaENoaWxkLm10eFdvcmxkLnRyYW5zbGF0aW9uIDogY2hpbGQubXR4V29ybGQudHJhbnNsYXRpb247XHJcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZTtcclxuICAgICAgICBfYnJhbmNoLnJhZGl1cyA9IE1hdGgubWF4KF9icmFuY2gucmFkaXVzLCBwb3NpdGlvbi5nZXREaXN0YW5jZShfYnJhbmNoLm10eFdvcmxkLnRyYW5zbGF0aW9uKSArIGNoaWxkLnJhZGl1cyk7XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUocG9zaXRpb24pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdHJhbnNmb3JtQnlQaHlzaWNzKF9ub2RlOiBOb2RlLCBfY21wUmlnaWRib2R5OiBDb21wb25lbnRSaWdpZGJvZHkpOiB2b2lkIHtcclxuICAgICAgaWYgKCFfY21wUmlnaWRib2R5LmlzSW5pdGlhbGl6ZWQpIC8vIHx8IFByb2plY3QubW9kZSA9PSBNT0RFLkVESVRPUilcclxuICAgICAgICBfY21wUmlnaWRib2R5LmluaXRpYWxpemUoKTtcclxuXHJcbiAgICAgIGlmICghUGh5c2ljcy5nZXRCb2R5TGlzdCgpLmxlbmd0aClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBpZiAoIV9ub2RlLm10eExvY2FsKSB7XHJcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcihcIkNvbXBvbmVudFJpZ2lkYm9keSByZXF1aXJlcyBDb21wb25lbnRUcmFuc2Zvcm0gYXQgdGhlIHNhbWUgTm9kZVwiKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIF9jbXBSaWdpZGJvZHkuY2hlY2tDb2xsaXNpb25FdmVudHMoKTtcclxuXHJcbiAgICAgIGlmIChfY21wUmlnaWRib2R5LnR5cGVCb2R5ID09IEJPRFlfVFlQRS5LSU5FTUFUSUMgfHwgUHJvamVjdC5tb2RlID09IE1PREUuRURJVE9SKSB7IC8vQ2FzZSBvZiBLaW5lbWF0aWMgUmlnaWRib2R5XHJcbiAgICAgICAgbGV0IG10eFBpdm90V29ybGQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5QUk9EVUNUKF9ub2RlLm10eFdvcmxkLCBfY21wUmlnaWRib2R5Lm10eFBpdm90VW5zY2FsZWQpO1xyXG4gICAgICAgIF9jbXBSaWdpZGJvZHkuc2V0UG9zaXRpb24obXR4UGl2b3RXb3JsZC50cmFuc2xhdGlvbik7XHJcbiAgICAgICAgX2NtcFJpZ2lkYm9keS5zZXRSb3RhdGlvbihtdHhQaXZvdFdvcmxkLnJvdGF0aW9uKTtcclxuICAgICAgICBSZWN5Y2xlci5zdG9yZShtdHhQaXZvdFdvcmxkKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBtdHhXb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LkNPTVBPU0lUSU9OKF9jbXBSaWdpZGJvZHkuZ2V0UG9zaXRpb24oKSwgX2NtcFJpZ2lkYm9keS5nZXRSb3RhdGlvbigpKTtcclxuICAgICAgbXR4V29ybGQubXVsdGlwbHkoX2NtcFJpZ2lkYm9keS5tdHhQaXZvdEludmVyc2UpO1xyXG4gICAgICBfbm9kZS5tdHhXb3JsZC50cmFuc2xhdGlvbiA9IG10eFdvcmxkLnRyYW5zbGF0aW9uO1xyXG4gICAgICBfbm9kZS5tdHhXb3JsZC5yb3RhdGlvbiA9IG10eFdvcmxkLnJvdGF0aW9uO1xyXG4gICAgICBsZXQgcGFyZW50OiBOb2RlID0gX25vZGUuZ2V0UGFyZW50KCk7XHJcbiAgICAgIGxldCBtdHhMb2NhbDogTWF0cml4NHg0ID0gcGFyZW50ID9cclxuICAgICAgICBNYXRyaXg0eDQuUkVMQVRJVkUoX25vZGUubXR4V29ybGQsIHBhcmVudC5tdHhXb3JsZCwgcGFyZW50Lm10eFdvcmxkSW52ZXJzZSkgOlxyXG4gICAgICAgIF9ub2RlLm10eFdvcmxkLmNsb25lO1xyXG4gICAgICBfbm9kZS5tdHhMb2NhbC5jb3B5KG10eExvY2FsKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4V29ybGQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhMb2NhbCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFJlbmRlckJ1ZmZlcnMge1xyXG4gICAgdmFvPzogV2ViR0xWZXJ0ZXhBcnJheU9iamVjdDtcclxuICAgIGluZGljZXM/OiBXZWJHTEJ1ZmZlcjtcclxuICAgIHBvc2l0aW9ucz86IFdlYkdMQnVmZmVyO1xyXG4gICAgbm9ybWFscz86IFdlYkdMQnVmZmVyO1xyXG4gICAgdGV4dHVyZVVWcz86IFdlYkdMQnVmZmVyO1xyXG4gICAgY29sb3JzPzogV2ViR0xCdWZmZXI7XHJcbiAgICB0YW5nZW50cz86IFdlYkdMQnVmZmVyO1xyXG4gICAgYm9uZXM/OiBXZWJHTEJ1ZmZlcjtcclxuICAgIHdlaWdodHM/OiBXZWJHTEJ1ZmZlcjtcclxuICAgIG5JbmRpY2VzPzogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5zZXJ0ZWQgaW50byBhIHtAbGluayBNZXNofSwgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBjYWxjdWxhdGVzIGFuZCByZXByZXNlbnRzIHRoZSBtZXNoIGRhdGEgaW4gdGhlIGZvcm0gbmVlZGVkIGJ5IHRoZSByZW5kZXIgZW5naW5lXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFJlbmRlck1lc2gge1xyXG4gICAgcHVibGljIGJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnM7XHJcbiAgICBwdWJsaWMgbWVzaDogTWVzaDtcclxuXHJcbiAgICAvKiogaW5kaWNlcyB0byBjcmVhdGUgZmFjZXMgZnJvbSB0aGUgdmVydGljZXMsIHJvdGF0aW9uIGRldGVybWluZXMgZGlyZWN0aW9uIG9mIGZhY2Utbm9ybWFsICovXHJcbiAgICAjaW5kaWNlczogVWludDE2QXJyYXk7XHJcbiAgICAvKiogdmVydGljZXMgb2YgdGhlIGFjdHVhbCBwb2ludCBjbG91ZCwgc29tZSBwb2ludHMgbWlnaHQgYmUgaW4gdGhlIHNhbWUgbG9jYXRpb24gaW4gb3JkZXIgdG8gcmVmZXIgdG8gZGlmZmVyZW50IHRleGVscyAqL1xyXG4gICAgI3Bvc2l0aW9uczogRmxvYXQzMkFycmF5O1xyXG4gICAgLyoqIHZlcnRleCBub3JtYWxzIGZvciBzbW9vdGggc2hhZGluZywgaW50ZXJwb2xhdGVkIGJldHdlZW4gdmVydGljZXMgZHVyaW5nIHJlbmRlcmluZyAqL1xyXG4gICAgI25vcm1hbHM6IEZsb2F0MzJBcnJheTtcclxuICAgIC8qKiB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdmVydGljZXMgYnkgdGhlIHBvc2l0aW9uIGluIHRoZSBhcnJheSAqL1xyXG4gICAgI3RleHR1cmVVVnM6IEZsb2F0MzJBcnJheTtcclxuICAgIC8qIGNvbG9ycyAqL1xyXG4gICAgI2NvbG9yczogRmxvYXQzMkFycmF5O1xyXG4gICAgLyoqIHZlcnRleCB0YW5nZW50cyBmb3Igbm9ybWFsIG1hcHBpbmcsIGJhc2VkIG9uIHRoZSB2ZXJ0ZXggbm9ybWFscyBhbmQgdGhlIFVWIGNvb3JkaW5hdGVzICovXHJcbiAgICAjdGFuZ2VudHM6IEZsb2F0MzJBcnJheTtcclxuICAgIFxyXG4gICAgI2JvbmVzOiBVaW50OEFycmF5O1xyXG4gICAgI3dlaWdodHM6IEZsb2F0MzJBcnJheTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX21lc2g6IE1lc2gpIHtcclxuICAgICAgdGhpcy5tZXNoID0gX21lc2g7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBwb3NpdGlvbnMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3Bvc2l0aW9ucyB8fCAoIC8vIHJldHVybiBjYWNoZSBvciAuLi5cclxuICAgICAgICAvLyAuLi4gZmxhdHRlbiBhbGwgdmVydGV4IHBvc2l0aW9ucyBmcm9tIGNsb3VkIGludG8gYSB0eXBlZCBhcnJheVxyXG4gICAgICAgIHRoaXMuI3Bvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5tZXNoLnZlcnRpY2VzLmZsYXRNYXAoKF92ZXJ0ZXg6IFZlcnRleCwgX2luZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgIHJldHVybiBbLi4udGhpcy5tZXNoLnZlcnRpY2VzLnBvc2l0aW9uKF9pbmRleCkuZ2V0KCldO1xyXG4gICAgICAgIH0pKSk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHBvc2l0aW9ucyhfdmVydGljZXM6IEZsb2F0MzJBcnJheSkge1xyXG4gICAgICB0aGlzLiNwb3NpdGlvbnMgPSBfdmVydGljZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpbmRpY2VzKCk6IFVpbnQxNkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2luZGljZXMgfHwgKCAvLyByZXR1cm4gY2FjaGUgb3IgLi4uXHJcbiAgICAgICAgLy8gLi4uIGZsYXR0ZW4gYWxsIGluZGljZXMgZnJvbSB0aGUgZmFjZXMgaW50byBhIHR5cGVkIGFycmF5XHJcbiAgICAgICAgdGhpcy4jaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLm1lc2guZmFjZXMuZmxhdE1hcCgoX2ZhY2U6IEZhY2UpID0+IF9mYWNlLmluZGljZXMpXHJcbiAgICAgICAgKSk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGluZGljZXMoX2luZGljZXM6IFVpbnQxNkFycmF5KSB7XHJcbiAgICAgIHRoaXMuI2luZGljZXMgPSBfaW5kaWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IG5vcm1hbHMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgaWYgKHRoaXMuI25vcm1hbHMgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgYSBjaGVjayBzaW1pbGlhciB0byB0aGUgb25lIGZvciB0YW5nZW50cyBiZWxvdywgdG8gc2VlIGlmIG5vcm1hbHMgYXJlIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgdmVydGljZXNcclxuXHJcbiAgICAgICAgLy8gc3VtIHVwIGFsbCB1bnNjYWxlZCBub3JtYWxzIG9mIGZhY2VzIGNvbm5lY3RlZCB0byBvbmUgdmVydGV4LCB3ZWlnaHRlZCBieSB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgdHdvIG5laWdoYm91ciB2ZXJ0aWNlcy4uLlxyXG4gICAgICAgIHRoaXMubWVzaC52ZXJ0aWNlcy5mb3JFYWNoKF92ZXJ0ZXggPT4gX3ZlcnRleC5ub3JtYWwuc2V0KDAsIDAsIDApKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgZmFjZSBvZiB0aGlzLm1lc2guZmFjZXMpXHJcbiAgICAgICAgICBmYWNlLmluZGljZXMuZm9yRWFjaCgoX2lWZXJ0ZXgsIF9pRmFjZVZlcnRleCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm1lc2gudmVydGljZXMubm9ybWFsKF9pVmVydGV4KS5hZGQoVmVjdG9yMy5TQ0FMRShmYWNlLm5vcm1hbFVuc2NhbGVkLCBmYWNlLmFuZ2xlc1tfaUZhY2VWZXJ0ZXhdKSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAvLyAuLi4gYW5kIG5vcm1hbGl6ZSB0aGVtXHJcbiAgICAgICAgdGhpcy5tZXNoLnZlcnRpY2VzLmZvckVhY2goX3ZlcnRleCA9PiB7XHJcbiAgICAgICAgICAvLyBzb21lIHZlcnRpY2VzIG1pZ2h0IGJlIHVudXNlZCBhbmQgeWllbGQgYSB6ZXJvLW5vcm1hbC4uLlxyXG4gICAgICAgICAgaWYgKF92ZXJ0ZXgubm9ybWFsLm1hZ25pdHVkZVNxdWFyZWQgPiAwKVxyXG4gICAgICAgICAgICBfdmVydGV4Lm5vcm1hbC5ub3JtYWxpemUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gdGhpcy7Gkm5vcm1hbHNWZXJ0ZXggPSBuZXcgRmxvYXQzMkFycmF5KG5vcm1hbHNWZXJ0ZXguZmxhdE1hcCgoX25vcm1hbDogVmVjdG9yMykgPT4gWy4uLl9ub3JtYWwuZ2V0KCldKSk7XHJcblxyXG4gICAgICAgIHRoaXMuI25vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KFxyXG4gICAgICAgICAgdGhpcy5tZXNoLnZlcnRpY2VzLmZsYXRNYXAoKF92ZXJ0ZXgsIF9pbmRleCkgPT4gWy4uLnRoaXMubWVzaC52ZXJ0aWNlcy5ub3JtYWwoX2luZGV4KS5nZXQoKV0pXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuI25vcm1hbHM7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG5vcm1hbHMoX25vcm1hbHM6IEZsb2F0MzJBcnJheSkge1xyXG4gICAgICB0aGlzLiNub3JtYWxzID0gX25vcm1hbHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB0YW5nZW50cygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBpZiAodGhpcy4jdGFuZ2VudHMgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5tZXNoLnZlcnRpY2VzLnNvbWUoX3ZlcnRleCA9PiAhX3ZlcnRleC51dikpIHsgLy8gYXNzdW1lIGFsbCB2ZXJ0aWNlcyBoYXZlIHRleHR1cmUgY29vcmRpbmF0ZXMgb3Igbm9uZVxyXG4gICAgICAgICAgdGhpcy4jdGFuZ2VudHMgPSBuZXcgRmxvYXQzMkFycmF5KCk7IC8vIG5vIHRleHR1cmUgY29vcmRpbmF0ZXMsIG5vIHRhbmdlbnRzXHJcbiAgICAgICAgICByZXR1cm4gdGhpcy4jdGFuZ2VudHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5tZXNoLnZlcnRpY2VzLnNvbWUoX3ZlcnRleCA9PiAhX3ZlcnRleC50YW5nZW50KSkgeyAvLyBhc3N1bWUgYWxsIHZlcnRpY2VzIGhhdmUgdGFuZ2VudHMgb3Igbm9uZVxyXG4gICAgICAgICAgY29uc3QgdGFuZ2VudHM6IFZlY3RvcjNbXSA9IG5ldyBBcnJheSh0aGlzLm1lc2gudmVydGljZXMubGVuZ3RoKTtcclxuICAgICAgICAgIGNvbnN0IGJpdGFuZ2VudHM6IFZlY3RvcjNbXSA9IG5ldyBBcnJheSh0aGlzLm1lc2gudmVydGljZXMubGVuZ3RoKTtcclxuICAgICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0YW5nZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0YW5nZW50c1tpXSA9IFZlY3RvcjMuWkVSTygpO1xyXG4gICAgICAgICAgICBiaXRhbmdlbnRzW2ldID0gVmVjdG9yMy5aRVJPKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gdGhpcy5tZXNoLnZlcnRpY2VzLmZvckVhY2goX3ZlcnRleCA9PiBfdmVydGV4LnRhbmdlbnQuc2V0KDAsIDAsIDApKTtcclxuXHJcbiAgICAgICAgICBmb3IgKGxldCBmYWNlIG9mIHRoaXMubWVzaC5mYWNlcykge1xyXG4gICAgICAgICAgICBsZXQgaTA6IG51bWJlciA9IGZhY2UuaW5kaWNlc1swXTtcclxuICAgICAgICAgICAgbGV0IGkxOiBudW1iZXIgPSBmYWNlLmluZGljZXNbMV07XHJcbiAgICAgICAgICAgIGxldCBpMjogbnVtYmVyID0gZmFjZS5pbmRpY2VzWzJdO1xyXG5cclxuICAgICAgICAgICAgLy92ZXJ0aWNlcyBzdXJyb3VuZGluZyBvbmUgdHJpYW5nbGVcclxuICAgICAgICAgICAgbGV0IHYwOiBWZWN0b3IzID0gdGhpcy5tZXNoLnZlcnRpY2VzLnBvc2l0aW9uKGkwKTtcclxuICAgICAgICAgICAgbGV0IHYxOiBWZWN0b3IzID0gdGhpcy5tZXNoLnZlcnRpY2VzLnBvc2l0aW9uKGkxKTtcclxuICAgICAgICAgICAgbGV0IHYyOiBWZWN0b3IzID0gdGhpcy5tZXNoLnZlcnRpY2VzLnBvc2l0aW9uKGkyKTtcclxuXHJcbiAgICAgICAgICAgIC8vdGhlaXIgVVZzXHJcbiAgICAgICAgICAgIGxldCB1djA6IFZlY3RvcjIgPSB0aGlzLm1lc2gudmVydGljZXMudXYoaTApO1xyXG4gICAgICAgICAgICBsZXQgdXYxOiBWZWN0b3IyID0gdGhpcy5tZXNoLnZlcnRpY2VzLnV2KGkxKTtcclxuICAgICAgICAgICAgbGV0IHV2MjogVmVjdG9yMiA9IHRoaXMubWVzaC52ZXJ0aWNlcy51dihpMik7XHJcblxyXG4gICAgICAgICAgICAvL1dlIGNvbXB1dGUgdGhlIGVkZ2VzIG9mIHRoZSB0cmlhbmdsZS4uLlxyXG4gICAgICAgICAgICBsZXQgZGVsdGFQb3MwOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKHYxLCB2MCk7XHJcbiAgICAgICAgICAgIGxldCBkZWx0YVBvczE6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodjIsIHYwKTtcclxuXHJcbiAgICAgICAgICAgIC8vLi4uYW5kIHRoZSBlZGdlcyBvZiB0aGUgdHJpYW5nbGVzIGluIFVWIHNwYWNlLi4uXHJcbiAgICAgICAgICAgIGxldCBkZWx0YVVWMDogVmVjdG9yMiA9IFZlY3RvcjIuRElGRkVSRU5DRSh1djEsIHV2MCk7XHJcbiAgICAgICAgICAgIGxldCBkZWx0YVVWMTogVmVjdG9yMiA9IFZlY3RvcjIuRElGRkVSRU5DRSh1djIsIHV2MCk7XHJcblxyXG4gICAgICAgICAgICAvLy4uLmFuZCBjb21wdXRlIHRoZSB0YW5nZW50XHJcbiAgICAgICAgICAgIGxldCByOiBudW1iZXIgPSAxIC8gVmVjdG9yMi5DUk9TUyhkZWx0YVVWMCwgZGVsdGFVVjEpO1xyXG4gICAgICAgICAgICBsZXQgZmFjZVRhbmdlbnQ6IFZlY3RvcjMgPSBWZWN0b3IzLlNDQUxFKFZlY3RvcjMuRElGRkVSRU5DRShWZWN0b3IzLlNDQUxFKGRlbHRhUG9zMCwgZGVsdGFVVjEueSksIFZlY3RvcjMuU0NBTEUoZGVsdGFQb3MxLCBkZWx0YVVWMC55KSksIHIpO1xyXG4gICAgICAgICAgICBsZXQgZmFjZUJpdGFuZ2VudDogVmVjdG9yMyA9IFZlY3RvcjMuU0NBTEUoVmVjdG9yMy5ESUZGRVJFTkNFKFZlY3RvcjMuU0NBTEUoZGVsdGFQb3MxLCAtZGVsdGFVVjAueCksIFZlY3RvcjMuU0NBTEUoZGVsdGFQb3MwLCAtZGVsdGFVVjEueCkpLCByKTsgLy8gZm9yIHdpbmRpbmcgb3JkZXIgY291bnRlciBjbG9ja3dpc2VcclxuXHJcbiAgICAgICAgICAgIHRhbmdlbnRzW2kwXS5hZGQoVmVjdG9yMy5TQ0FMRShmYWNlVGFuZ2VudCwgZmFjZS5hbmdsZXNbMF0pKTtcclxuICAgICAgICAgICAgdGFuZ2VudHNbaTFdLmFkZChWZWN0b3IzLlNDQUxFKGZhY2VUYW5nZW50LCBmYWNlLmFuZ2xlc1sxXSkpO1xyXG4gICAgICAgICAgICB0YW5nZW50c1tpMl0uYWRkKFZlY3RvcjMuU0NBTEUoZmFjZVRhbmdlbnQsIGZhY2UuYW5nbGVzWzJdKSk7XHJcblxyXG4gICAgICAgICAgICBiaXRhbmdlbnRzW2kwXS5hZGQoVmVjdG9yMy5TQ0FMRShmYWNlQml0YW5nZW50LCBmYWNlLmFuZ2xlc1swXSkpO1xyXG4gICAgICAgICAgICBiaXRhbmdlbnRzW2kxXS5hZGQoVmVjdG9yMy5TQ0FMRShmYWNlQml0YW5nZW50LCBmYWNlLmFuZ2xlc1sxXSkpO1xyXG4gICAgICAgICAgICBiaXRhbmdlbnRzW2kyXS5hZGQoVmVjdG9yMy5TQ0FMRShmYWNlQml0YW5nZW50LCBmYWNlLmFuZ2xlc1syXSkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMubWVzaC52ZXJ0aWNlcy5mb3JFYWNoKChfdmVydGV4LCBfaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgbGV0IG5vcm1hbDogVmVjdG9yMyA9IHRoaXMubWVzaC52ZXJ0aWNlcy5ub3JtYWwoX2luZGV4KTtcclxuICAgICAgICAgICAgbGV0IHRhbmdlbnQ6IFZlY3RvcjMgPSB0YW5nZW50c1tfaW5kZXhdO1xyXG4gICAgICAgICAgICBsZXQgYml0YW5nZW50OiBWZWN0b3IzID0gYml0YW5nZW50c1tfaW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgLy8gcmVvcnRob2dvbmFsaXplXHJcbiAgICAgICAgICAgIHRhbmdlbnQuYWRkKFZlY3RvcjMuU0NBTEUobm9ybWFsLCAtIFZlY3RvcjMuRE9UKG5vcm1hbCwgdGFuZ2VudCkpKTtcclxuICAgICAgICAgICAgaWYgKHRhbmdlbnQubWFnbml0dWRlU3F1YXJlZCA+IDApIC8vIHNvbWUgdmVydGljZXMgbWlnaHQgYmUgdW51c2VkIGFuZCB5aWVsZCBhIHplcm8tdGFuZ2VudC4uLlxyXG4gICAgICAgICAgICAgIHRhbmdlbnQubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgaGFuZGVkbmVzczogbnVtYmVyID0gKFZlY3RvcjMuRE9UKFZlY3RvcjMuQ1JPU1Mobm9ybWFsLCB0YW5nZW50KSwgYml0YW5nZW50KSA8IDApID8gLTEgOiAxO1xyXG5cclxuICAgICAgICAgICAgX3ZlcnRleC50YW5nZW50ID0gbmV3IFZlY3RvcjQodGFuZ2VudC54LCB0YW5nZW50LnksIHRhbmdlbnQueiwgaGFuZGVkbmVzcyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuI3RhbmdlbnRzID0gbmV3IEZsb2F0MzJBcnJheShcclxuICAgICAgICAgIHRoaXMubWVzaC52ZXJ0aWNlcy5mbGF0TWFwKF92ZXJ0ZXggPT4gX3ZlcnRleC50YW5nZW50LmdldCgpKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLiN0YW5nZW50cztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgdGFuZ2VudHMoX3RhbmdlbnRzOiBGbG9hdDMyQXJyYXkpIHtcclxuICAgICAgdGhpcy4jdGFuZ2VudHMgPSBfdGFuZ2VudHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB0ZXh0dXJlVVZzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiN0ZXh0dXJlVVZzIHx8ICggLy8gcmV0dXJuIGNhY2hlIG9yIC4uLlxyXG4gICAgICAgIC8vIC4uLiBmbGF0dGVuIGFsbCB1dnMgZnJvbSB0aGUgY2xvdXMgaW50byBhIHR5cGVkIGFycmF5XHJcbiAgICAgICAgdGhpcy4jdGV4dHVyZVVWcyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5tZXNoLnZlcnRpY2VzXHJcbiAgICAgICAgICAuZmlsdGVyKF92ZXJ0ZXggPT4gX3ZlcnRleC51dilcclxuICAgICAgICAgIC5mbGF0TWFwKChfdmVydGV4OiBWZXJ0ZXgpID0+IFsuLi5fdmVydGV4LnV2LmdldCgpXSlcclxuICAgICAgICApKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgdGV4dHVyZVVWcyhfdGV4dHVyZVVWczogRmxvYXQzMkFycmF5KSB7XHJcbiAgICAgIHRoaXMuI3RleHR1cmVVVnMgPSBfdGV4dHVyZVVWcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGNvbG9ycygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY29sb3JzIHx8IChcclxuICAgICAgICB0aGlzLiNjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMubWVzaC52ZXJ0aWNlc1xyXG4gICAgICAgICAgLmZpbHRlcihfdmVydGV4ID0+IF92ZXJ0ZXguY29sb3IpXHJcbiAgICAgICAgICAuZmxhdE1hcChfdmVydGV4ID0+IFsuLi5fdmVydGV4LmNvbG9yLmdldCgpXSlcclxuICAgICAgICApKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgY29sb3JzKF9jb2xvcnM6IEZsb2F0MzJBcnJheSkge1xyXG4gICAgICB0aGlzLiNjb2xvcnMgPSBfY29sb3JzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgYm9uZXMoKTogVWludDhBcnJheSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNib25lcyB8fCAoIC8vIHJldHVybiBjYWNoZSBvciAuLi5cclxuICAgICAgICB0aGlzLiNib25lcyA9IHRoaXMubWVzaC52ZXJ0aWNlcy5zb21lKF92ZXJ0ZXggPT4gX3ZlcnRleC5ib25lcykgP1xyXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodGhpcy5tZXNoLnZlcnRpY2VzLmZsYXRNYXAoKF92ZXJ0ZXg6IFZlcnRleCwgX2luZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYm9uZXM6IEJvbmVbXSA9IHRoaXMubWVzaC52ZXJ0aWNlcy5ib25lcyhfaW5kZXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gW2JvbmVzPy5bMF0/LmluZGV4IHx8IDAsIGJvbmVzPy5bMV0/LmluZGV4IHx8IDAsIGJvbmVzPy5bMl0/LmluZGV4IHx8IDAsIGJvbmVzPy5bM10/LmluZGV4IHx8IDBdO1xyXG4gICAgICAgICAgfSkpIDpcclxuICAgICAgICAgIHVuZGVmaW5lZFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBib25lcyhfaUJvbmVzOiBVaW50OEFycmF5KSB7XHJcbiAgICAgIHRoaXMuI2JvbmVzID0gX2lCb25lcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHdlaWdodHMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3dlaWdodHMgfHwgKCAvLyByZXR1cm4gY2FjaGUgb3IgLi4uXHJcbiAgICAgICAgdGhpcy4jd2VpZ2h0cyA9IHRoaXMubWVzaC52ZXJ0aWNlcy5zb21lKF92ZXJ0ZXggPT4gX3ZlcnRleC5ib25lcykgP1xyXG4gICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1lc2gudmVydGljZXMuZmxhdE1hcCgoX3ZlcnRleDogVmVydGV4LCBfaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBib25lczogQm9uZVtdID0gdGhpcy5tZXNoLnZlcnRpY2VzLmJvbmVzKF9pbmRleCk7XHJcbiAgICAgICAgICAgIHJldHVybiBbYm9uZXM/LlswXT8ud2VpZ2h0IHx8IDAsIGJvbmVzPy5bMV0/LndlaWdodCB8fCAwLCBib25lcz8uWzJdPy53ZWlnaHQgfHwgMCwgYm9uZXM/LlszXT8ud2VpZ2h0IHx8IDBdO1xyXG4gICAgICAgICAgfSkpIDpcclxuICAgICAgICAgIHVuZGVmaW5lZFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCB3ZWlnaHRzKF93ZWlnaHRzOiBGbG9hdDMyQXJyYXkpIHtcclxuICAgICAgdGhpcy4jd2VpZ2h0cyA9IF93ZWlnaHRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoaXMgcmVuZGVyIG1lc2ggYW5kIGFsbCBpdHMgYnVmZmVyc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3Bvc2l0aW9ucyA9IG51bGw7XHJcbiAgICAgIHRoaXMuI2luZGljZXMgPSBudWxsO1xyXG4gICAgICB0aGlzLiN0ZXh0dXJlVVZzID0gbnVsbDtcclxuICAgICAgdGhpcy4jbm9ybWFscyA9IG51bGw7XHJcbiAgICAgIHRoaXMuI2NvbG9ycyA9IG51bGw7XHJcbiAgICAgIHRoaXMuI3RhbmdlbnRzID0gbnVsbDtcclxuXHJcbiAgICAgIHRoaXMuI2JvbmVzID0gbnVsbDtcclxuICAgICAgdGhpcy4jd2VpZ2h0cyA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQ29udHJvbHMgdGhlIHJlbmRlcmluZyBvZiBhIGJyYW5jaCwgdXNpbmcgdGhlIGdpdmVuIHtAbGluayBDb21wb25lbnRDYW1lcmF9LFxyXG4gICAqIGFuZCB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIHJlbmRlcmVkIGltYWdlIGZyb20gdGhlIG9mZnNjcmVlbiByZW5kZXJidWZmZXIgdG8gdGhlIHRhcmdldCBjYW52YXNcclxuICAgKiB0aHJvdWdoIGEgc2VyaWVzIG9mIHtAbGluayBGcmFtaW5nfSBvYmplY3RzLiBUaGUgc3RhZ2VzIGludm9sdmVkIGFyZSBpbiBvcmRlciBvZiByZW5kZXJpbmdcclxuICAgKiB7QGxpbmsgUmVuZGVyfS52aWV3cG9ydCAtPiB7QGxpbmsgVmlld3BvcnR9LnNvdXJjZSAtPiB7QGxpbmsgVmlld3BvcnR9LmRlc3RpbmF0aW9uIC0+IERPTS1DYW52YXMgLT4gQ2xpZW50KENTUylcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5LTIwMjIgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjNcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vaHMtZnVydHdhbmdlbi9GVURHRS93aWtpL1ZpZXdwb3J0XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFZpZXdwb3J0IGV4dGVuZHMgRXZlbnRUYXJnZXRVbmlmaWVkIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGZvY3VzOiBWaWV3cG9ydDtcclxuXHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nID0gXCJWaWV3cG9ydFwiOyAvLyBUaGUgbmFtZSB0byBjYWxsIHRoaXMgdmlld3BvcnQgYnkuXHJcbiAgICBwdWJsaWMgY2FtZXJhOiBDb21wb25lbnRDYW1lcmEgPSBudWxsOyAvLyBUaGUgY2FtZXJhIHJlcHJlc2VudGluZyB0aGUgdmlldyBwYXJhbWV0ZXJzIHRvIHJlbmRlciB0aGUgYnJhbmNoLlxyXG4gICAgcHVibGljIHJlY3RTb3VyY2U6IFJlY3RhbmdsZTtcclxuICAgIHB1YmxpYyByZWN0RGVzdGluYXRpb246IFJlY3RhbmdsZTtcclxuXHJcbiAgICAvLyBUT0RPOiB2ZXJpZnkgaWYgY2xpZW50IHRvIGNhbnZhcyBzaG91bGQgYmUgaW4gVmlld3BvcnQgb3Igc29tZXdoZXJlIGVsc2UgKFdpbmRvdywgQ29udGFpbmVyPylcclxuICAgIC8vIE11bHRpcGxlIHZpZXdwb3J0cyB1c2luZyB0aGUgc2FtZSBjYW52YXMgc2hvdWxkbid0IGRpZmZlciBoZXJlLi4uXHJcbiAgICAvLyBkaWZmZXJlbnQgZnJhbWluZyBtZXRob2RzIGNhbiBiZSB1c2VkLCB0aGlzIGlzIHRoZSBkZWZhdWx0XHJcbiAgICBwdWJsaWMgZnJhbWVDbGllbnRUb0NhbnZhczogRnJhbWluZ1NjYWxlZCA9IG5ldyBGcmFtaW5nU2NhbGVkKCk7XHJcbiAgICBwdWJsaWMgZnJhbWVDYW52YXNUb0Rlc3RpbmF0aW9uOiBGcmFtaW5nQ29tcGxleCA9IG5ldyBGcmFtaW5nQ29tcGxleCgpO1xyXG4gICAgcHVibGljIGZyYW1lRGVzdGluYXRpb25Ub1NvdXJjZTogRnJhbWluZ1NjYWxlZCA9IG5ldyBGcmFtaW5nU2NhbGVkKCk7XHJcbiAgICBwdWJsaWMgZnJhbWVTb3VyY2VUb1JlbmRlcjogRnJhbWluZ1NjYWxlZCA9IG5ldyBGcmFtaW5nU2NhbGVkKCk7XHJcblxyXG4gICAgcHVibGljIGFkanVzdGluZ0ZyYW1lczogYm9vbGVhbiA9IHRydWU7IC8vIFRPRE86IG1heWJlIG9ubHkgYWRqdXN0IGZyYW1lcyB3aGVuIGFueXRoaW5nIGNoYW5nZXMgaW5zdGVhZCBvZiBldmVyeSBkcmF3biBmcmFtZT9cclxuICAgIHB1YmxpYyBhZGp1c3RpbmdDYW1lcmE6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgcHVibGljIHBoeXNpY3NEZWJ1Z01vZGU6IFBIWVNJQ1NfREVCVUdNT0RFID0gUEhZU0lDU19ERUJVR01PREUuTk9ORTtcclxuXHJcbiAgICBwdWJsaWMgZ2l6bW9zRW5hYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHVibGljIGdpem1vc1NlbGVjdGVkOiBOb2RlW107XHJcbiAgICBwdWJsaWMgZ2l6bW9zRmlsdGVyOiB7IFtfZ2l6bW86IHN0cmluZ106IGJvb2xlYW4gfSA9IE9iamVjdC5mcm9tRW50cmllcyhDb21wb25lbnQuc3ViY2xhc3NlcyAvLyBUT0RPOiBtYXliZSBtYWtlIHRoaXMgbGF6eSBUT0RPOiBjaGFuZ2UgdG8ganMgb2JqZWN0XHJcbiAgICAgIC5maWx0ZXIoKF9jbGFzczogdHlwZW9mIENvbXBvbmVudCkgPT4gKF9jbGFzcy5wcm90b3R5cGUpLmRyYXdHaXptb3MgfHwgKF9jbGFzcy5wcm90b3R5cGUpLmRyYXdHaXptb3NTZWxlY3RlZClcclxuICAgICAgLm1hcCgoX2NsYXNzOiB0eXBlb2YgQ29tcG9uZW50KSA9PiBbX2NsYXNzLm5hbWUsIHRydWVdKVxyXG4gICAgKTtcclxuXHJcbiAgICBwdWJsaWMgY29tcG9uZW50c1BpY2s6IFJlY3ljYWJsZUFycmF5PENvbXBvbmVudFBpY2s+ID0gbmV3IFJlY3ljYWJsZUFycmF5KCk7XHJcblxyXG4gICAgI2JyYW5jaDogTm9kZSA9IG51bGw7IC8vIFRoZSB0byByZW5kZXIgd2l0aCBhbGwgaXRzIGRlc2NlbmRhbnRzLlxyXG4gICAgI2NyYzI6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IG51bGw7XHJcbiAgICAjY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCA9IG51bGw7XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyAjcmVnaW9uIEV2ZW50cyAocGFzc2luZyBmcm9tIGNhbnZhcyB0byB2aWV3cG9ydCBhbmQgZnJvbSB0aGVyZSBpbnRvIGJyYW5jaClcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmlld3BvcnQgY3VycmVudGx5IGhhcyBmb2N1cyBhbmQgdGh1cyByZWNlaXZlcyBrZXlib2FyZCBldmVudHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBoYXNGb2N1cygpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIChWaWV3cG9ydC5mb2N1cyA9PSB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBkZXN0aW5hdGlvbiBjYW52YXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBjYW52YXMoKTogSFRNTENhbnZhc0VsZW1lbnQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY2FudmFzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgMkQtY29udGV4dCBhdHRhY2hlZCB0byB0aGUgZGVzdGluYXRpb24gY2FudmFzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY29udGV4dCgpOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY3JjMjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbm5lY3RzIHRoZSB2aWV3cG9ydCB0byB0aGUgZ2l2ZW4gY2FudmFzIHRvIHJlbmRlciB0aGUgZ2l2ZW4gYnJhbmNoIHRvIHVzaW5nIHRoZSBnaXZlbiBjYW1lcmEtY29tcG9uZW50LCBhbmQgbmFtZXMgdGhlIHZpZXdwb3J0IGFzIGdpdmVuLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW5pdGlhbGl6ZShfbmFtZTogc3RyaW5nLCBfYnJhbmNoOiBOb2RlLCBfY2FtZXJhOiBDb21wb25lbnRDYW1lcmEsIF9jYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCB7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICB0aGlzLmNhbWVyYSA9IF9jYW1lcmE7XHJcbiAgICAgIHRoaXMuI2NhbnZhcyA9IF9jYW52YXM7XHJcbiAgICAgIHRoaXMuI2NyYzIgPSBfY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgdGhpcy4jY2FudmFzLnRhYkluZGV4ID0gMDsgLy8gY2FuIGdldCBmb2N1cyBhbmQgcmVjZWl2ZSBrZXlib2FyZCBldmVudHNcclxuXHJcbiAgICAgIHRoaXMucmVjdFNvdXJjZSA9IFJlbmRlci5nZXRDYW52YXNSZWN0KCk7XHJcbiAgICAgIHRoaXMucmVjdERlc3RpbmF0aW9uID0gdGhpcy5nZXRDbGllbnRSZWN0YW5nbGUoKTtcclxuXHJcbiAgICAgIHRoaXMuc2V0QnJhbmNoKF9icmFuY2gpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgc2l6ZSBvZiB0aGUgZGVzdGluYXRpb24gY2FudmFzIGFzIGEgcmVjdGFuZ2xlLCB4IGFuZCB5IGFyZSBhbHdheXMgMCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENhbnZhc1JlY3RhbmdsZSgpOiBSZWN0YW5nbGUge1xyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVCgwLCAwLCB0aGlzLiNjYW52YXMud2lkdGgsIHRoaXMuI2NhbnZhcy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY2xpZW50IHJlY3RhbmdsZSB0aGUgY2FudmFzIGlzIGRpc3BsYXllZCBhbmQgZml0IGluLCB4IGFuZCB5IGFyZSBhbHdheXMgMCBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENsaWVudFJlY3RhbmdsZSgpOiBSZWN0YW5nbGUge1xyXG4gICAgICAvLyBGVURHRSBkb2Vzbid0IGNhcmUgYWJvdXQgd2hlcmUgdGhlIGNsaWVudCByZWN0IGlzLCBvbmx5IGFib3V0IHRoZSBzaXplIG1hdHRlcnMuXHJcbiAgICAgIC8vIHJldHVybiBSZWN0YW5nbGUuR0VUKHRoaXMuY2FudmFzLm9mZnNldExlZnQsIHRoaXMuY2FudmFzLm9mZnNldFRvcCwgdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsIHRoaXMuY2FudmFzLmNsaWVudEhlaWdodCk7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIHRoaXMuI2NhbnZhcy5jbGllbnRXaWR0aCwgdGhpcy4jY2FudmFzLmNsaWVudEhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGJyYW5jaCB0byBiZSBkcmF3biBpbiB0aGUgdmlld3BvcnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRCcmFuY2goX2JyYW5jaDogTm9kZSk6IHZvaWQge1xyXG4gICAgICBpZiAoX2JyYW5jaCkge1xyXG4gICAgICAgIF9icmFuY2guYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5ULkFUVEFDSF9CUkFOQ0gpKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLiNicmFuY2ggPSBfYnJhbmNoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIGJyYW5jaCB0aGlzIHZpZXdwb3J0IHJlbmRlcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEJyYW5jaCgpOiBOb2RlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2JyYW5jaDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAjcmVnaW9uIERyYXdpbmdcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHZpZXdwb3J0IGRpc3BsYXlpbmcgaXRzIGJyYW5jaC4gQnkgZGVmYXVsdCwgdGhlIHRyYW5zZm9ybXMgaW4gdGhlIGJyYW5jaCBhcmUgcmVjYWxjdWxhdGVkIGZpcnN0LlxyXG4gICAgICogUGFzcyBgZmFsc2VgIGlmIGNhbGN1bGF0aW9uIHdhcyBhbHJlYWR5IGRvbmUgZm9yIHRoaXMgZnJhbWUgXHJcbiAgICAgKi9cclxuICAgIC8vIEBQZXJmb3JtYW5jZU1vbml0b3IubWVhc3VyZShcIlZpZXdwb3J0LmRyYXdcIilcclxuICAgIHB1YmxpYyBkcmF3KF9wcmVwYXJlQnJhbmNoOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICB0aGlzLnByZXBhcmUoX3ByZXBhcmVCcmFuY2gpO1xyXG5cclxuICAgICAgUmVuZGVyLnJlc2V0RnJhbWVidWZmZXIoKTtcclxuICAgICAgUmVuZGVyLmNsZWFyKHRoaXMuY2FtZXJhLmNsckJhY2tncm91bmQpO1xyXG5cclxuICAgICAgaWYgKHRoaXMucGh5c2ljc0RlYnVnTW9kZSAhPSBQSFlTSUNTX0RFQlVHTU9ERS5QSFlTSUNfT0JKRUNUU19PTkxZKSB7XHJcbiAgICAgICAgUmVuZGVyLmRyYXcodGhpcy5jYW1lcmEpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5naXptb3NFbmFibGVkKVxyXG4gICAgICAgICAgR2l6bW9zLmRyYXcodGhpcy5nZXRHaXptb3MoKSwgdGhpcy5jYW1lcmEsIHRoaXMuZ2l6bW9zU2VsZWN0ZWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5waHlzaWNzRGVidWdNb2RlICE9IFBIWVNJQ1NfREVCVUdNT0RFLk5PTkUpIHtcclxuICAgICAgICBQaHlzaWNzLmRyYXcodGhpcy5jYW1lcmEsIHRoaXMucGh5c2ljc0RlYnVnTW9kZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuUkVOREVSX0VORCkpO1xyXG5cclxuICAgICAgdGhpcy4jY3JjMi5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy4jY3JjMi5kcmF3SW1hZ2UoXHJcbiAgICAgICAgUmVuZGVyLmdldENhbnZhcygpLFxyXG4gICAgICAgIHRoaXMucmVjdFNvdXJjZS54LCB0aGlzLnJlY3RTb3VyY2UueSwgdGhpcy5yZWN0U291cmNlLndpZHRoLCB0aGlzLnJlY3RTb3VyY2UuaGVpZ2h0LFxyXG4gICAgICAgIHRoaXMucmVjdERlc3RpbmF0aW9uLngsIHRoaXMucmVjdERlc3RpbmF0aW9uLnksIHRoaXMucmVjdERlc3RpbmF0aW9uLndpZHRoLCB0aGlzLnJlY3REZXN0aW5hdGlvbi5oZWlnaHRcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQWRqdXN0cyBhbGwgZnJhbWVzIGFuZCB0aGUgY2FtZXJhIHRvIGZpdCB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBjYW52YXMuIFByZXBhcmVzIHRoZSBicmFuY2ggZm9yIHJlbmRlcmluZy5cclxuICAgICovXHJcbiAgICAvLyBAUGVyZm9ybWFuY2VNb25pdG9yLm1lYXN1cmUoXCJWaWV3cG9ydC5wcmVwYXJlXCIpXHJcbiAgICBwdWJsaWMgcHJlcGFyZShfcHJlcGFyZUJyYW5jaDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLiNicmFuY2gpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBpZiAoIXRoaXMuY2FtZXJhLmlzQWN0aXZlKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE1lYXN1cmUoXCJWaWV3cG9ydC5wcmVwYXJlIGNtcENhbWVyYS5tdHhXb3JsZCAqIGNtcENhbWVyYS5tdHhQaXZvdFwiKTtcclxuICAgICAgaWYgKHRoaXMuY2FtZXJhLm5vZGUpIHtcclxuICAgICAgICBjb25zdCBtdHhXb3JsZENhbWVyYTogTWF0cml4NHg0ID0gTWF0cml4NHg0LlBST0RVQ1QodGhpcy5jYW1lcmEubm9kZS5tdHhXb3JsZCwgdGhpcy5jYW1lcmEubXR4UGl2b3QpO1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLm10eFdvcmxkLmNvcHkobXR4V29ybGRDYW1lcmEpO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFdvcmxkQ2FtZXJhKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmNhbWVyYS5tdHhXb3JsZC5jb3B5KHRoaXMuY2FtZXJhLm10eFBpdm90KTtcclxuICAgICAgfVxyXG4gICAgICAvLyBQZXJmb3JtYW5jZU1vbml0b3IuZW5kTWVhc3VyZShcIlZpZXdwb3J0LnByZXBhcmUgY21wQ2FtZXJhLm10eFdvcmxkICogY21wQ2FtZXJhLm10eFBpdm90XCIpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuYWRqdXN0aW5nRnJhbWVzKVxyXG4gICAgICAgIHRoaXMuYWRqdXN0RnJhbWVzKCk7XHJcbiAgICAgIGlmICh0aGlzLmFkanVzdGluZ0NhbWVyYSlcclxuICAgICAgICB0aGlzLmFkanVzdENhbWVyYSgpO1xyXG4gICAgICBpZiAoX3ByZXBhcmVCcmFuY2gpXHJcbiAgICAgICAgdGhpcy5wcmVwYXJlQnJhbmNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwYXJlcyBhbGwgbm9kZXMgaW4gdGhlIGJyYW5jaCBmb3IgcmVuZGVyaW5nIGJ5IHVwZGF0aW5nIHRoZWlyIHdvcmxkIHRyYW5zZm9ybXMgZXRjLlxyXG4gICAgICovXHJcbiAgICAvLyBAUGVyZm9ybWFuY2VNb25pdG9yLm1lYXN1cmUoXCJWaWV3cG9ydC5wcmVwYXJlQnJhbmNoXCIpXHJcbiAgICBwdWJsaWMgcHJlcGFyZUJyYW5jaCgpOiB2b2lkIHtcclxuICAgICAgbGV0IG10eFJvb3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgICBpZiAodGhpcy4jYnJhbmNoLmdldFBhcmVudCgpKVxyXG4gICAgICAgIG10eFJvb3QgPSB0aGlzLiNicmFuY2guZ2V0UGFyZW50KCkubXR4V29ybGQ7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuUkVOREVSX1BSRVBBUkVfU1RBUlQpKTtcclxuICAgICAgUmVuZGVyLnByZXBhcmUodGhpcy4jYnJhbmNoLCB7fSwgbXR4Um9vdCk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuUkVOREVSX1BSRVBBUkVfRU5EKSk7XHJcbiAgICAgIHRoaXMuY29tcG9uZW50c1BpY2sgPSBSZW5kZXIuY29tcG9uZW50c1BpY2s7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhIHBpY2sgb24gYWxsIHtAbGluayBDb21wb25lbnRQaWNrfXMgaW4gdGhlIGJyYW5jaCBvZiB0aGlzIHZpZXdwb3J0XHJcbiAgICAgKiB1c2luZyBhIHJheSBmcm9tIGl0cyBjYW1lcmEgdGhyb3VnaCB0aGUgY2xpZW50IGNvb3JkaW5hdGVzIGdpdmVuIGluIHRoZSBldmVudC5cclxuICAgICAqIERpc3BhdGNoZXMgdGhlIGV2ZW50IHRvIGFsbCBub2RlcyBoaXQuICBcclxuICAgICAqIElmIHtAbGluayBQSUNLLkNBTUVSQX0gd2FzIGNob3NlbiBhcyB0aGUgbWV0aG9kIHRvIHBpY2ssIGEgcGljayBwcm9wZXJ0eSBnZXRzIGFkZGVkIHRvIHRoZSBldmVudCwgXHJcbiAgICAgKiB3aGljaCBob2xkcyB0aGUgZGV0YWlsZWQgaW5mb3JtYXRpb24sIGJ1dCBpcyBvdmVyd3JpdHRlbiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGlzcGF0Y2hQb2ludGVyRXZlbnQoX2V2ZW50OiBQb2ludGVyRXZlbnQpOiB2b2lkIHtcclxuICAgICAgbGV0IHBvc0NsaWVudDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKF9ldmVudC5jbGllbnRYLCBfZXZlbnQuY2xpZW50WSk7XHJcbiAgICAgIGxldCByYXk6IFJheSA9IHRoaXMuZ2V0UmF5RnJvbUNsaWVudChwb3NDbGllbnQpO1xyXG4gICAgICAvLyBsZXQgY2FtZXJhUGlja3M6IFJlY3ljYWJsZUFycmF5PE5vZGU+ID0gUmVjeWNsZXIuZ2V0KFJlY3ljYWJsZUFycmF5KTsgLy9UT0RPOiB0aGluayBhYm91dCBvcHRpbWl6YXRpb24gbGF0ZXJcclxuICAgICAgbGV0IGNhbWVyYVBpY2tzOiBOb2RlW10gPSBbXTtcclxuICAgICAgbGV0IG90aGVyUGlja3M6IENvbXBvbmVudFBpY2tbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBjbXBQaWNrIG9mIHRoaXMuY29tcG9uZW50c1BpY2spXHJcbiAgICAgICAgaWYgKGNtcFBpY2sucGljayA9PSBQSUNLLkNBTUVSQSlcclxuICAgICAgICAgIGNhbWVyYVBpY2tzLnB1c2goY21wUGljay5ub2RlKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBvdGhlclBpY2tzLnB1c2goY21wUGljayk7XHJcblxyXG5cclxuICAgICAgaWYgKGNhbWVyYVBpY2tzLmxlbmd0aCkge1xyXG4gICAgICAgIGxldCBwaWNrczogUGlja1tdID0gUGlja2VyLnBpY2tDYW1lcmEoY2FtZXJhUGlja3MsIHRoaXMuY2FtZXJhLCB0aGlzLnBvaW50Q2xpZW50VG9Qcm9qZWN0aW9uKHBvc0NsaWVudCkpO1xyXG4gICAgICAgIGZvciAobGV0IHBpY2sgb2YgcGlja3MpIHtcclxuICAgICAgICAgIFJlZmxlY3Quc2V0KF9ldmVudCwgXCJwaWNrXCIsIHBpY2spO1xyXG4gICAgICAgICAgcGljay5ub2RlLmRpc3BhdGNoRXZlbnQoX2V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IGNtcFBpY2sgb2Ygb3RoZXJQaWNrcykge1xyXG4gICAgICAgIGNtcFBpY2sucGlja0FuZERpc3BhdGNoKHJheSwgX2V2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0IGFsbCBmcmFtZXMgaW52b2x2ZWQgaW4gdGhlIHJlbmRlcmluZyBwcm9jZXNzIGZyb20gdGhlIGRpc3BsYXkgYXJlYSBpbiB0aGUgY2xpZW50IHVwIHRvIHRoZSByZW5kZXJlciBjYW52YXNcclxuICAgICAqL1xyXG4gICAgLy8gQFBlcmZvcm1hbmNlTW9uaXRvci5tZWFzdXJlKFwiVmlld3BvcnQuYWRqdXN0RnJhbWVzXCIpXHJcbiAgICBwdWJsaWMgYWRqdXN0RnJhbWVzKCk6IHZvaWQge1xyXG4gICAgICAvLyBnZXQgdGhlIHJlY3RhbmdsZSBvZiB0aGUgY2FudmFzIGFyZWEgYXMgZGlzcGxheWVkIChjb25zaWRlciBjc3MpXHJcbiAgICAgIGxldCByZWN0Q2xpZW50OiBSZWN0YW5nbGUgPSB0aGlzLmdldENsaWVudFJlY3RhbmdsZSgpO1xyXG4gICAgICAvLyBhZGp1c3QgdGhlIGNhbnZhcyBzaXplIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZnJhbWluZyBhcHBsaWVkIHRvIGNsaWVudFxyXG4gICAgICBsZXQgcmVjdENhbnZhczogUmVjdGFuZ2xlID0gdGhpcy5mcmFtZUNsaWVudFRvQ2FudmFzLmdldFJlY3QocmVjdENsaWVudCk7XHJcbiAgICAgIHRoaXMuI2NhbnZhcy53aWR0aCA9IHJlY3RDYW52YXMud2lkdGg7XHJcbiAgICAgIHRoaXMuI2NhbnZhcy5oZWlnaHQgPSByZWN0Q2FudmFzLmhlaWdodDtcclxuXHJcbiAgICAgIGxldCByZWN0VGVtcDogUmVjdGFuZ2xlO1xyXG4gICAgICAvLyBhZGp1c3QgdGhlIGRlc3RpbmF0aW9uIGFyZWEgb24gdGhlIHRhcmdldC1jYW52YXMgdG8gcmVuZGVyIHRvIGJ5IGFwcGx5aW5nIHRoZSBmcmFtaW5nIHRvIGNhbnZhc1xyXG4gICAgICByZWN0VGVtcCA9IHRoaXMuZnJhbWVDYW52YXNUb0Rlc3RpbmF0aW9uLmdldFJlY3QocmVjdENhbnZhcyk7XHJcbiAgICAgIHRoaXMucmVjdERlc3RpbmF0aW9uLmNvcHkocmVjdFRlbXApO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShyZWN0VGVtcCk7XHJcbiAgICAgIC8vIGFkanVzdCB0aGUgYXJlYSBvbiB0aGUgc291cmNlLWNhbnZhcyB0byByZW5kZXIgZnJvbSBieSBhcHBseWluZyB0aGUgZnJhbWluZyB0byBkZXN0aW5hdGlvbiBhcmVhXHJcbiAgICAgIHJlY3RUZW1wID0gdGhpcy5mcmFtZURlc3RpbmF0aW9uVG9Tb3VyY2UuZ2V0UmVjdCh0aGlzLnJlY3REZXN0aW5hdGlvbik7XHJcblxyXG4gICAgICB0aGlzLnJlY3RTb3VyY2UuY29weShyZWN0VGVtcCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJlY3RUZW1wKTtcclxuXHJcbiAgICAgIC8vIGhhdmluZyBhbiBvZmZzZXQgc291cmNlIGRvZXMgbWFrZSBzZW5zZSBvbmx5IHdoZW4gbXVsdGlwbGUgdmlld3BvcnRzIGRpc3BsYXkgcGFydHMgb2YgdGhlIHNhbWUgcmVuZGVyaW5nLiBGb3Igbm93OiBzaGlmdCBpdCB0byAwLDBcclxuICAgICAgdGhpcy5yZWN0U291cmNlLnggPSB0aGlzLnJlY3RTb3VyY2UueSA9IDA7XHJcbiAgICAgIC8vIHN0aWxsLCBhIHBhcnRpYWwgaW1hZ2Ugb2YgdGhlIHJlbmRlcmluZyBtYXkgYmUgcmV0cmlldmVkIGJ5IG1vdmluZyBhbmQgcmVzaXppbmcgdGhlIHJlbmRlciB2aWV3cG9ydC4gRm9yIG5vdywgaXQncyBhbHdheXMgYWRqdXN0ZWQgdG8gdGhlIGN1cnJlbnQgdmlld3BvcnRcclxuICAgICAgbGV0IHJlY3RSZW5kZXI6IFJlY3RhbmdsZSA9IHRoaXMuZnJhbWVTb3VyY2VUb1JlbmRlci5nZXRSZWN0KHRoaXMucmVjdFNvdXJjZSk7XHJcbiAgICAgIFJlbmRlci5zZXRSZW5kZXJSZWN0YW5nbGUocmVjdFJlbmRlcik7XHJcblxyXG4gICAgICBsZXQgcmVjdE9mZnNjcmVlbkNhbnZhczogUmVjdGFuZ2xlID0gUmVuZGVyLmdldENhbnZhc1JlY3QoKTsgLy8gdGhlcmUgYXJlIGZhciB0byBtYW55IHJlY3RhbmdsZXMgaW52b2x2ZWQgaGVyZS4uLlxyXG5cclxuICAgICAgLy8gbm8gbW9yZSB0cmFuc2Zvcm1hdGlvbiBhZnRlciB0aGlzIGZvciBub3csIG9mZnNjcmVlbiBjYW52YXMgYW5kIHJlbmRlci12aWV3cG9ydCBoYXZlIHRoZSBzYW1lIHNpemVcclxuICAgICAgUmVuZGVyLnNldENhbnZhc1NpemUocmVjdFJlbmRlci53aWR0aCwgcmVjdFJlbmRlci5oZWlnaHQpO1xyXG5cclxuICAgICAgaWYgKHJlY3RSZW5kZXIud2lkdGggIT0gcmVjdE9mZnNjcmVlbkNhbnZhcy53aWR0aCB8fCByZWN0UmVuZGVyLmhlaWdodCAhPSByZWN0T2Zmc2NyZWVuQ2FudmFzLmhlaWdodClcclxuICAgICAgICBSZW5kZXIuYWRqdXN0QXR0YWNobWVudHMoKTtcclxuXHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJlY3RDbGllbnQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShyZWN0Q2FudmFzKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUocmVjdFJlbmRlcik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJlY3RPZmZzY3JlZW5DYW52YXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0IHRoZSBjYW1lcmEgcGFyYW1ldGVycyB0byBmaXQgdGhlIHJlbmRlcmluZyBpbnRvIHRoZSByZW5kZXIgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkanVzdENhbWVyYSgpOiB2b2lkIHtcclxuICAgICAgbGV0IHJlY3Q6IFJlY3RhbmdsZSA9IFJlbmRlci5nZXRSZW5kZXJSZWN0YW5nbGUoKTtcclxuICAgICAgLy8gaWYgKHRoaXMuY2FtZXJhLmdldFByb2plY3Rpb24oKSA9PSBQUk9KRUNUSU9OLk9SVEhPR1JBUEhJQylcclxuICAgICAgLy8gICB0aGlzLmNhbWVyYS5wcm9qZWN0T3J0aG9ncmFwaGljKC1yZWN0LndpZHRoIC8gMjAsIHJlY3Qud2lkdGggLyAyMCwgcmVjdC5oZWlnaHQgLyAyMCwgLXJlY3QuaGVpZ2h0IC8gMjApO1xyXG4gICAgICAvLyBlbHNlXHJcbiAgICAgIHRoaXMuY2FtZXJhLnByb2plY3RDZW50cmFsKFxyXG4gICAgICAgIHJlY3Qud2lkdGggLyByZWN0LmhlaWdodCwgdGhpcy5jYW1lcmEuZ2V0RmllbGRPZlZpZXcoKSwgdGhpcy5jYW1lcmEuZ2V0RGlyZWN0aW9uKCksIHRoaXMuY2FtZXJhLmdldE5lYXIoKSwgdGhpcy5jYW1lcmEuZ2V0RmFyKClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHRoaXMuY2FtZXJhLnJlc2V0V29ybGRUb1ZpZXcoKTtcclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gUG9pbnRzXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgUmF5fSBpbiB3b3JsZCBjb29yZGluYXRlcyBmcm9tIHRoaXMgY2FtZXJhIHRocm91Z2ggdGhlIHBvaW50IGdpdmVuIGluIGNsaWVudCBzcGFjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmF5RnJvbUNsaWVudChfcG9pbnQ6IFZlY3RvcjIpOiBSYXkge1xyXG4gICAgICBsZXQgcG9zUHJvamVjdGlvbjogVmVjdG9yMiA9IHRoaXMucG9pbnRDbGllbnRUb1Byb2plY3Rpb24oX3BvaW50KTtcclxuICAgICAgbGV0IHJheTogUmF5ID0gbmV3IFJheShuZXcgVmVjdG9yMygtcG9zUHJvamVjdGlvbi54LCBwb3NQcm9qZWN0aW9uLnksIDEpKTtcclxuXHJcbiAgICAgIC8vIHJheS5kaXJlY3Rpb24uc2NhbGUoY2FtZXJhLmRpc3RhbmNlKTtcclxuICAgICAgcmF5LnRyYW5zZm9ybSh0aGlzLmNhbWVyYS5tdHhQaXZvdCk7XHJcbiAgICAgIGxldCBjYW1lcmFOb2RlOiBOb2RlID0gdGhpcy5jYW1lcmEubm9kZTtcclxuICAgICAgaWYgKGNhbWVyYU5vZGUpXHJcbiAgICAgICAgcmF5LnRyYW5zZm9ybShjYW1lcmFOb2RlLm10eFdvcmxkKTtcclxuXHJcbiAgICAgIHJldHVybiByYXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIHByb2plY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGluIHdvcmxkIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludFdvcmxkVG9DbGllbnQoX3Bvc2l0aW9uOiBWZWN0b3IzKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBwcm9qZWN0aW9uOiBWZWN0b3IzID0gdGhpcy5jYW1lcmEucG9pbnRXb3JsZFRvQ2xpcChfcG9zaXRpb24pO1xyXG4gICAgICBsZXQgcG9zQ2xpZW50OiBWZWN0b3IyID0gdGhpcy5wb2ludENsaXBUb0NsaWVudChwcm9qZWN0aW9uLnRvVmVjdG9yMigpKTtcclxuICAgICAgcmV0dXJuIHBvc0NsaWVudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwb2ludCBvbiB0aGUgc291cmNlLXJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvaW50Q2xpZW50VG9Tb3VyY2UoX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gdGhpcy5mcmFtZUNsaWVudFRvQ2FudmFzLmdldFBvaW50KF9jbGllbnQsIHRoaXMuZ2V0Q2xpZW50UmVjdGFuZ2xlKCkpO1xyXG4gICAgICByZXN1bHQgPSB0aGlzLmZyYW1lQ2FudmFzVG9EZXN0aW5hdGlvbi5nZXRQb2ludChyZXN1bHQsIHRoaXMuZ2V0Q2FudmFzUmVjdGFuZ2xlKCkpO1xyXG4gICAgICByZXN1bHQgPSB0aGlzLmZyYW1lRGVzdGluYXRpb25Ub1NvdXJjZS5nZXRQb2ludChyZXN1bHQsIHRoaXMucmVjdFNvdXJjZSk7XHJcbiAgICAgIC8vVE9ETzogd2hlbiBTb3VyY2UsIFJlbmRlciBhbmQgUmVuZGVyVmlld3BvcnQgZGV2aWF0ZSwgY29udGludWUgdHJhbnNmb3JtYXRpb24gXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIHJlbmRlci1yZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IG9uIHRoZSBzb3VyY2UgcmVjdGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludFNvdXJjZVRvUmVuZGVyKF9zb3VyY2U6IFZlY3RvcjIpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHByb2plY3Rpb25SZWN0YW5nbGU6IFJlY3RhbmdsZSA9IHRoaXMuY2FtZXJhLmdldFByb2plY3Rpb25SZWN0YW5nbGUoKTtcclxuICAgICAgbGV0IHBvaW50OiBWZWN0b3IyID0gdGhpcy5mcmFtZVNvdXJjZVRvUmVuZGVyLmdldFBvaW50KF9zb3VyY2UsIHByb2plY3Rpb25SZWN0YW5nbGUpO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhwcm9qZWN0aW9uUmVjdGFuZ2xlLnRvU3RyaW5nKCkpO1xyXG4gICAgICByZXR1cm4gcG9pbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgb24gdGhlIHJlbmRlci1yZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IG9uIHRoZSBjbGllbnQgcmVjdGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludENsaWVudFRvUmVuZGVyKF9jbGllbnQ6IFZlY3RvcjIpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHBvaW50OiBWZWN0b3IyID0gdGhpcy5wb2ludENsaWVudFRvU291cmNlKF9jbGllbnQpO1xyXG4gICAgICBwb2ludCA9IHRoaXMucG9pbnRTb3VyY2VUb1JlbmRlcihwb2ludCk7XHJcbiAgICAgIC8vVE9ETzogd2hlbiBSZW5kZXIgYW5kIFJlbmRlclZpZXdwb3J0IGRldmlhdGUsIGNvbnRpbnVlIHRyYW5zZm9ybWF0aW9uIFxyXG4gICAgICByZXR1cm4gcG9pbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgb24gYSBwcm9qZWN0aW9uIHN1cmZhY2UgaW4gdGhlIGh5cG90aGV0aWNhbCBkaXN0YW5jZSBvZiAxIHRvIHRoZSBjYW1lcmEgIFxyXG4gICAgICogbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IG9uIHRoZSBjbGllbnQgcmVjdGFuZ2xlXHJcbiAgICAgKiBUT0RPOiBleGFtaW5lLCBpZiB0aGlzIHNob3VsZCBiZSBhIGNhbWVyYS1tZXRob2QuIEN1cnJlbnQgaW1wbGVtZW50YXRpb24gaXMgZm9yIGNlbnRyYWwtcHJvamVjdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGllbnRUb1Byb2plY3Rpb24oX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcG9zUmVuZGVyOiBWZWN0b3IyID0gdGhpcy5wb2ludENsaWVudFRvUmVuZGVyKF9jbGllbnQpO1xyXG4gICAgICBsZXQgcmVjdFJlbmRlcjogUmVjdGFuZ2xlID0gdGhpcy5mcmFtZVNvdXJjZVRvUmVuZGVyLmdldFJlY3QodGhpcy5yZWN0U291cmNlKTtcclxuICAgICAgbGV0IHJlY3RQcm9qZWN0aW9uOiBSZWN0YW5nbGUgPSB0aGlzLmNhbWVyYS5nZXRQcm9qZWN0aW9uUmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgICBsZXQgcG9zUHJvamVjdGlvbjogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIHJlY3RQcm9qZWN0aW9uLndpZHRoICogcG9zUmVuZGVyLnggLyByZWN0UmVuZGVyLndpZHRoLFxyXG4gICAgICAgIHJlY3RQcm9qZWN0aW9uLmhlaWdodCAqIHBvc1JlbmRlci55IC8gcmVjdFJlbmRlci5oZWlnaHRcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHBvc1Byb2plY3Rpb24uc3VidHJhY3QobmV3IFZlY3RvcjIocmVjdFByb2plY3Rpb24ud2lkdGggLyAyLCByZWN0UHJvamVjdGlvbi5oZWlnaHQgLyAyKSk7XHJcbiAgICAgIHBvc1Byb2plY3Rpb24ueSAqPSAtMTtcclxuXHJcbiAgICAgIHJldHVybiBwb3NQcm9qZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IGluIHRoZSBjbGllbnQgcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBpbiBub3JtZWQgY2xpcHNwYWNlIHJlY3RhbmdsZSwgXHJcbiAgICAgKiB3aGljaCBzdHJldGNoZXMgZnJvbSAtMSB0byAxIGluIGJvdGggZGltZW5zaW9ucywgeSBwb2ludGluZyB1cFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGlwVG9DbGllbnQoX25vcm1lZDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICAvLyBsZXQgcmVjdENsaWVudDogUmVjdGFuZ2xlID0gdGhpcy5nZXRDbGllbnRSZWN0YW5nbGUoKTtcclxuICAgICAgLy8gbGV0IHJlc3VsdDogVmVjdG9yMiA9IFZlY3RvcjIuT05FKDAuNSk7XHJcbiAgICAgIC8vIHJlc3VsdC54ICo9IChfbm9ybWVkLnggKyAxKSAqIHJlY3RDbGllbnQud2lkdGg7XHJcbiAgICAgIC8vIHJlc3VsdC55ICo9ICgxIC0gX25vcm1lZC55KSAqIHJlY3RDbGllbnQuaGVpZ2h0O1xyXG4gICAgICAvLyByZXN1bHQuYWRkKHJlY3RDbGllbnQucG9zaXRpb24pO1xyXG4gICAgICAvL1RPRE86IGNoZWNrIGlmIHJlY3REZXN0aW5hdGlvbiBjYW4gc2FmZWx5IChhbmQgbW9yZSBwZXJmb21hbnQpIGJlIHVzZWQgaW5zdGVhZCBnZXRDbGllbnRSZWN0YW5nbGVcclxuICAgICAgbGV0IHBvaW50Q2xpZW50OiBWZWN0b3IyID0gUmVuZGVyLnJlY3RDbGlwLnBvaW50VG9SZWN0KF9ub3JtZWQsIHRoaXMucmVjdERlc3RpbmF0aW9uKTtcclxuICAgICAgcmV0dXJuIHBvaW50Q2xpZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IGluIHRoZSBjbGllbnQgcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBpbiBub3JtZWQgY2xpcHNwYWNlIHJlY3RhbmdsZSwgXHJcbiAgICAgKiB3aGljaCBzdHJldGNoZXMgZnJvbSAtMSB0byAxIGluIGJvdGggZGltZW5zaW9ucywgeSBwb2ludGluZyB1cFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGlwVG9DYW52YXMoX25vcm1lZDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcG9pbnRDYW52YXM6IFZlY3RvcjIgPSBSZW5kZXIucmVjdENsaXAucG9pbnRUb1JlY3QoX25vcm1lZCwgdGhpcy5nZXRDYW52YXNSZWN0YW5nbGUoKSk7XHJcbiAgICAgIHJldHVybiBwb2ludENhbnZhcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwb2ludCBpbiB0aGUgYnJvd3NlciBwYWdlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvaW50Q2xpZW50VG9TY3JlZW4oX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgc2NyZWVuOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIodGhpcy4jY2FudmFzLm9mZnNldExlZnQgKyBfY2xpZW50LngsIHRoaXMuI2NhbnZhcy5vZmZzZXRUb3AgKyBfY2xpZW50LnkpO1xyXG4gICAgICByZXR1cm4gc2NyZWVuO1xyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgdGhlIGdpem1vcyBpbiB0aGUgYnJhbmNoIG9mIHRoaXMgdmlld3BvcnQgdGhhdCBhcmUgYWN0aXZlLCBmaWx0ZXJlZCBieSB7QGxpbmsgZ2l6bW9zRmlsdGVyfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0R2l6bW9zKF9ub2RlczogTm9kZVtdID0gQXJyYXkuZnJvbSh0aGlzLiNicmFuY2guZ2V0SXRlcmF0b3IodHJ1ZSkpKTogR2l6bW9bXSB7XHJcbiAgICAgIHJldHVybiBfbm9kZXNcclxuICAgICAgICAuZmxhdE1hcChfbm9kZSA9PiBfbm9kZS5nZXRBbGxDb21wb25lbnRzKCkpXHJcbiAgICAgICAgLmZpbHRlcihfY29tcG9uZW50ID0+IF9jb21wb25lbnQuaXNBY3RpdmUgJiYgKF9jb21wb25lbnQuZHJhd0dpem1vcyB8fCBfY29tcG9uZW50LmRyYXdHaXptb3NTZWxlY3RlZCkgJiYgdGhpcy5naXptb3NGaWx0ZXJbX2NvbXBvbmVudC50eXBlXSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERpZmZlcmVudCB4ciBzZXNzaW9uIG1vZGVzIGF2YWlsYWJsZS4gQ291bGQgYmUgZXhwYW5kIHdpdGggbW9yZSBtb2RlcyBpbiB0aGUgZnV0dXJlLlxyXG4gICAqIEBhdXRob3JzIFZhbGVudGluIFNjaG1pZGJlcmdlciwgSEZVLCAyMDIyIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gWFJfU0VTU0lPTl9NT0RFIHtcclxuICAgIElNTUVSU0lWRV9WUiA9IFwiaW1tZXJzaXZlLXZyXCJcclxuICAgIC8vSU1NRVJTSVZFX0FSID0gXCJpbW1lcnNpdmUtYXJcIixcclxuICAgIC8vSU5MSU5FID0gXCJpbmxpbmVcIlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlmZmVyZW50IHJlZmVyZW5jZSB2ci1zcGFjZXMgYXZhaWxhYmxlLCBjcmVhdG9yIGhhcyB0byBjaGVjayBpZiB0aGUgc3BhY2UgaXMgc3VwcG9ydGVkIHdpdGggaXRzIGRldmljZS5cclxuICAgKiBDb3VsZCBiZSBleHBhbmQgd2l0aCBtb3JlIGF2YWlsYWJsZSBzcGFjZSB0eXBlcyBpbiB0aGUgZnV0dXJlLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIFhSX1JFRkVSRU5DRV9TUEFDRSB7XHJcbiAgICBWSUVXRVIgPSBcInZpZXdlclwiLFxyXG4gICAgTE9DQUwgPSBcImxvY2FsXCJcclxuICAgIC8vIExPQ0FMX0ZMT09SID0gXCJsb2NhbC1mbG9vclwiLFxyXG4gICAgLy8gQk9VTkRFRF9GTE9PUiA9IFwiYm91bmRlZC1mbG9vclwiLFxyXG4gICAgLy8gVU5CT1VOREVEID0gXCJ1bmJvdW5kZWRcIlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogWFJWaWV3cG9ydCAod2ViWFIpLWV4dGVuc2lvbiBvZiBWaWV3cG9ydCwgdG8gZGlzcGxheWluZyBpdHMgYnJhbmNoIG9uIEhlYWQgTW91bnRlZCBhbmQgQVIgKG5vdCBpbXBsZW10ZWQgeWV0KSBEZXZpY2VzIFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBYUlZpZXdwb3J0IGV4dGVuZHMgVmlld3BvcnQge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgeHJWaWV3cG9ydEluc3RhbmNlOiBYUlZpZXdwb3J0ID0gbnVsbDtcclxuICAgIHB1YmxpYyB2ckRldmljZTogQ29tcG9uZW50VlJEZXZpY2UgPSBudWxsO1xyXG4gICAgcHVibGljIHNlc3Npb246IFhSU2Vzc2lvbiA9IG51bGw7XHJcbiAgICBwdWJsaWMgcmVmZXJlbmNlU3BhY2U6IFhSUmVmZXJlbmNlU3BhY2UgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSB1c2VWUkNvbnRyb2xsZXI6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvLyBwcml2YXRlIHBvc2VNdHg6IE1hdHJpeDR4NCA9IG5ldyBNYXRyaXg0eDQoKTtcclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgWFJWaWV3cG9ydC54clZpZXdwb3J0SW5zdGFuY2UgPSB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVG8gcmV0cmlldmUgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2Ugb2YgeHIgdmlld3BvcnQsIHJlYWRvbmx5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCBkZWZhdWx0KCk6IFhSVmlld3BvcnQge1xyXG4gICAgICByZXR1cm4gdGhpcy54clZpZXdwb3J0SW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogQ29ubmVjdHMgdGhlIHZpZXdwb3J0IHRvIHRoZSBnaXZlbiBjYW52YXMgdG8gcmVuZGVyIHRoZSBnaXZlbiBicmFuY2ggdG8gdXNpbmcgdGhlIGdpdmVuIGNhbWVyYS1jb21wb25lbnQsIGFuZCBuYW1lcyB0aGUgdmlld3BvcnQgYXMgZ2l2ZW4uXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgaW5pdGlhbGl6ZShfbmFtZTogc3RyaW5nLCBfYnJhbmNoOiBOb2RlLCBfY2FtZXJhWFI6IENvbXBvbmVudFZSRGV2aWNlIC8qIHwgQ29tcG9uZW50Q2FtZXJhQVIqLywgX2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgc3VwZXIuaW5pdGlhbGl6ZShfbmFtZSwgX2JyYW5jaCwgX2NhbWVyYVhSLCBfY2FudmFzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBWUiBTZXNzaW9uIGlzIGluaXRpYWxpemVkIGhlcmUsIGFsc28gVlIgLSBDb250cm9sbGVyIGFyZSBpbml0aWFsaXplZCwgaWYgYm9vbGVhbiBpcyB0cnVlLlxyXG4gICAgICogQ3JlYXRvciBoYXMgdG8gY2FsbCBGcmFtZVJlcXVlc3RYUiBhZnRlciB0aGlzIE1ldGhvZCB0byBydW4gdGhlIHZpZXdwb3J0IGluIHZpcnR1YWwgcmVhbGl0eS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGluaXRpYWxpemVWUihfdnJTZXNzaW9uTW9kZTogWFJfU0VTU0lPTl9NT0RFID0gWFJfU0VTU0lPTl9NT0RFLklNTUVSU0lWRV9WUiwgX3ZyUmVmZXJlbmNlU3BhY2VUeXBlOiBYUl9SRUZFUkVOQ0VfU1BBQ0UgPSBYUl9SRUZFUkVOQ0VfU1BBQ0UuTE9DQUwsIF92ckNvbnRyb2xsZXI6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBsZXQgc2Vzc2lvbjogWFJTZXNzaW9uID0gYXdhaXQgbmF2aWdhdG9yLnhyLnJlcXVlc3RTZXNzaW9uKF92clNlc3Npb25Nb2RlKTtcclxuICAgICAgdGhpcy5yZWZlcmVuY2VTcGFjZSA9IGF3YWl0IHNlc3Npb24ucmVxdWVzdFJlZmVyZW5jZVNwYWNlKF92clJlZmVyZW5jZVNwYWNlVHlwZSk7XHJcbiAgICAgIGF3YWl0IFJlbmRlci5nZXRSZW5kZXJpbmdDb250ZXh0KCkubWFrZVhSQ29tcGF0aWJsZSgpO1xyXG4gICAgICBsZXQgbmF0aXZlU2NhbGVGYWN0b3I6IG51bWJlciA9IFhSV2ViR0xMYXllci5nZXROYXRpdmVGcmFtZWJ1ZmZlclNjYWxlRmFjdG9yKHNlc3Npb24pO1xyXG4gICAgICAvL1RPRE86ICBGaWVsZCBvZiB2aWV3IGvDtm5udGUgYW4gZGVyIFN0ZWxsZSBub2NoIHZlcsOkbmRlcnQgd2VyZGVuLlxyXG4gICAgICBsZXQgYmFzZUxheWVyOiBYUldlYkdMTGF5ZXIgPSBuZXcgWFJXZWJHTExheWVyKHNlc3Npb24sIFJlbmRlci5nZXRSZW5kZXJpbmdDb250ZXh0KCksIHsgZnJhbWVidWZmZXJTY2FsZUZhY3RvcjogbmF0aXZlU2NhbGVGYWN0b3IgfSk7XHJcbiAgICAgIGF3YWl0IHNlc3Npb24udXBkYXRlUmVuZGVyU3RhdGUoeyBiYXNlTGF5ZXI6IGJhc2VMYXllciB9KTtcclxuICAgICAgUmVuZGVyLnNldEZyYW1lYnVmZmVyVGFyZ2V0KGJhc2VMYXllci5mcmFtZWJ1ZmZlcik7XHJcbiAgICAgIFJlbmRlci5zZXRDYW52YXNTaXplKGJhc2VMYXllci5mcmFtZWJ1ZmZlcldpZHRoLCBiYXNlTGF5ZXIuZnJhbWVidWZmZXJIZWlnaHQpO1xyXG4gICAgICBSZW5kZXIuc2V0UmVuZGVyUmVjdGFuZ2xlKFJlY3RhbmdsZS5HRVQoMCwgMCwgYmFzZUxheWVyLmZyYW1lYnVmZmVyV2lkdGgsIGJhc2VMYXllci5mcmFtZWJ1ZmZlckhlaWdodCkpO1xyXG4gICAgICBSZW5kZXIuYWRqdXN0QXR0YWNobWVudHMoKTtcclxuICAgICAgdGhpcy5hZGp1c3RpbmdGcmFtZXMgPSBmYWxzZTsgLy8gd2ViIHhyIGhhbmRsZXMgdGhpcyBub3dcclxuICAgICAgdGhpcy52ckRldmljZSA9IDxDb21wb25lbnRWUkRldmljZT50aGlzLmNhbWVyYTtcclxuICAgICAgdGhpcy5pbml0aWFsaXplUmVmZXJlbmNlU3BhY2UoKTtcclxuXHJcbiAgICAgIHRoaXMudXNlVlJDb250cm9sbGVyID0gX3ZyQ29udHJvbGxlcjtcclxuICAgICAgaWYgKF92ckNvbnRyb2xsZXIpIHtcclxuICAgICAgICB0aGlzLnZyRGV2aWNlLnJpZ2h0Q250cmwuY21wVHJhbnNmb3JtID0gbmV3IENvbXBvbmVudFRyYW5zZm9ybSgpO1xyXG4gICAgICAgIHRoaXMudnJEZXZpY2UubGVmdENudHJsLmNtcFRyYW5zZm9ybSA9IG5ldyBDb21wb25lbnRUcmFuc2Zvcm0oKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcclxuXHJcbiAgICAgIHRoaXMucHJlcGFyZUJyYW5jaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIEFSIHNlc3Npb24gY291bGQgYmUgaW5pdGlhbGl6ZWQgaGVyZS4gVXAgdGlsbCBub3cgbm90IGltcGxlbWVudGVkLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGluaXRpYWxpemVBUihfYXJTZXNzaW9uTW9kZTogWFJfU0VTU0lPTl9NT0RFID0gbnVsbCwgX2FyUmVmZXJlbmNlU3BhY2VUeXBlOiBYUl9SRUZFUkVOQ0VfU1BBQ0UgPSBudWxsKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIERlYnVnLmVycm9yKFwiTk9UIElNUExFTUVOVEVEIFlFVCEgQ2hlY2sgb3V0IGluaXRpYWxpemVWUiFcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoZSB4ciB2aWV3cG9ydCBkaXNwbGF5aW5nIGl0cyBicmFuY2guIEJ5IGRlZmF1bHQsIHRoZSB0cmFuc2Zvcm1zIGluIHRoZSBicmFuY2ggYXJlIHJlY2FsY3VsYXRlZCBmaXJzdC5cclxuICAgICAqIFBhc3MgYGZhbHNlYCBpZiBjYWxjdWxhdGlvbiB3YXMgYWxyZWFkeSBkb25lIGZvciB0aGlzIGZyYW1lIFxyXG4gICAgICogQ2FsbGVkIGZyb20gbG9vcCBtZXRob2Qge0BsaW5rIExvb3B9IGFnYWluIHdpdGggdGhlIHhyRnJhbWUgcGFyYW1ldGVyIGhhbmRvdmVyLCBhcyBzb29uIGFzIEZSQU1FX1JFUVVFU1RfWFIgaXMgY2FsbGVkIGZyb20gY3JlYXRvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRyYXcoX3ByZXBhcmVCcmFuY2g6IGJvb2xlYW4gPSB0cnVlLCBfeHJGcmFtZTogWFJGcmFtZSA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcclxuICAgICAgICBzdXBlci5kcmF3KF9wcmVwYXJlQnJhbmNoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBwb3NlOiBYUlZpZXdlclBvc2UgPSBfeHJGcmFtZT8uZ2V0Vmlld2VyUG9zZSh0aGlzLnJlZmVyZW5jZVNwYWNlKTtcclxuICAgICAgaWYgKCFwb3NlKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIHRoaXMudnJEZXZpY2UubXR4TG9jYWwuc2V0KHBvc2UudHJhbnNmb3JtLm1hdHJpeCk7XHJcbiAgICAgIHRoaXMudnJEZXZpY2UubXR4TG9jYWwucm90YXRlWSgxODApOyAvLyByb3RhdGUgYmFjayBiZWNhdXNlIHRoZSBYUiBSaWcgaXMgbG9va2luZyBpbiB0aGUgZGlyZWN0aW9uIG9mIG5lZ2F0aXZlIHpcclxuICAgICAgc3VwZXIucHJlcGFyZShfcHJlcGFyZUJyYW5jaCk7XHJcblxyXG4gICAgICBSZW5kZXIucmVzZXRGcmFtZWJ1ZmZlcigpO1xyXG4gICAgICBSZW5kZXIuY2xlYXIodGhpcy5jYW1lcmEuY2xyQmFja2dyb3VuZCk7XHJcblxyXG4gICAgICBsZXQgZ2xMYXllcjogWFJXZWJHTExheWVyID0gdGhpcy5zZXNzaW9uLnJlbmRlclN0YXRlLmJhc2VMYXllcjtcclxuICAgICAgZm9yIChsZXQgdmlldyBvZiBwb3NlLnZpZXdzKSB7XHJcbiAgICAgICAgbGV0IHZpZXdwb3J0OiBnbG9iYWxUaGlzLlhSVmlld3BvcnQgPSBnbExheWVyLmdldFZpZXdwb3J0KHZpZXcpO1xyXG4gICAgICAgIFJlbmRlci5zZXRWaWV3cG9ydCh2aWV3cG9ydC54LCB2aWV3cG9ydC55LCB2aWV3cG9ydC53aWR0aCwgdmlld3BvcnQuaGVpZ2h0KTtcclxuICAgICAgICBSZW5kZXIuc2V0U2Npc3NvclRlc3QodHJ1ZSwgdmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnVzZVZSQ29udHJvbGxlcilcclxuICAgICAgICAgIHRoaXMuc2V0Q29udHJvbGxlckNvbmZpZ3MoX3hyRnJhbWUpO1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLnJlc2V0V29ybGRUb1ZpZXcoKTsgLy8gVE9ETzogZmluZCBhIGxlc3MgZXhwZW5zaXZlIHdheSB0byBkbyB0aGlzLCBtYXliZSB1c2UgdHdvIGNhbWVyYXNcclxuICAgICAgICB0aGlzLmNhbWVyYS5tdHhQcm9qZWN0aW9uLnNldCh2aWV3LnByb2plY3Rpb25NYXRyaXgpO1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLm10eENhbWVyYUludmVyc2Uuc2V0KHZpZXcudHJhbnNmb3JtLmludmVyc2UubWF0cml4KTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucGh5c2ljc0RlYnVnTW9kZSAhPSBQSFlTSUNTX0RFQlVHTU9ERS5QSFlTSUNfT0JKRUNUU19PTkxZKSBcclxuICAgICAgICAgIFJlbmRlci5kcmF3KHRoaXMuY2FtZXJhKTtcclxuICAgICAgICBpZiAodGhpcy5waHlzaWNzRGVidWdNb2RlICE9IFBIWVNJQ1NfREVCVUdNT0RFLk5PTkUpIFxyXG4gICAgICAgICAgUGh5c2ljcy5kcmF3KHRoaXMuY2FtZXJhLCB0aGlzLnBoeXNpY3NEZWJ1Z01vZGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZXNldCBmb3Igb3RoZXIgcmVuZGVyIG9wZXJhdGlvbnMgZS5nLiBwaWNraW5nXHJcbiAgICAgIFJlbmRlci5zZXRTY2lzc29yVGVzdChmYWxzZSk7XHJcbiAgICAgIFJlbmRlci5zZXRSZW5kZXJSZWN0YW5nbGUoUmVuZGVyLmdldFJlbmRlclJlY3RhbmdsZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmUgdGhlIHJlZmVyZW5jZSBzcGFjZSB0byBzZXQgdGhlIGluaXRpYWwgcG9zaXRpb24vb3JpZW50YXRpb24gb2YgdGhlIHZyIGRldmljZSBpbiBhY2NvcmRhbmNlIHRvIHRoZSBub2RlIHRoZSB2ciBkZXZpY2UgaXMgYXR0YWNoZWQgdG8uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaW5pdGlhbGl6ZVJlZmVyZW5jZVNwYWNlKCk6IHZvaWQge1xyXG4gICAgICBsZXQgbXR4V29ybGQ6IE1hdHJpeDR4NCA9IHRoaXMudnJEZXZpY2Uubm9kZT8uZ2V0Q29tcG9uZW50KENvbXBvbmVudFZSRGV2aWNlKT8ubXR4V29ybGQ7XHJcbiAgICAgIGlmICghbXR4V29ybGQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbXR4V29ybGQgPSBtdHhXb3JsZC5jbG9uZTtcclxuICAgICAgbXR4V29ybGQucm90YXRlWSgxODApOyAvLyByb3RhdGUgYmVjYXVzZSB0aGUgWFIgUmlnIGlzIGxvb2tpbmcgaW4gdGhlIGRpcmVjdGlvbiBvZiBuZWdhdGl2ZSB6XHJcbiAgICAgIGxldCBpbnZNdHhUcmFuc2ZvbTogTWF0cml4NHg0ID0gTWF0cml4NHg0LklOVkVSU0UobXR4V29ybGQpOyAvLyBpbnZlcnNlIGJlY2F1c2Ugd2UgYXJlIG1vdmluZyB0aGUgcmVmZXJlbmNlIHNwYWNlXHJcbiAgICAgIFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZSA9IFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZS5nZXRPZmZzZXRSZWZlcmVuY2VTcGFjZShuZXcgWFJSaWdpZFRyYW5zZm9ybShpbnZNdHhUcmFuc2ZvbS50cmFuc2xhdGlvbiwgaW52TXR4VHJhbnNmb20ucXVhdGVybmlvbikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vU2V0cyBjb250cm9sbGVyIG1hdHJpY2VzIGFuZCB0aHVtYnN0aWNrcyBtb3ZlbWVudHMuXHJcbiAgICBwcml2YXRlIHNldENvbnRyb2xsZXJDb25maWdzKF94ckZyYW1lOiBYUkZyYW1lKTogdm9pZCB7XHJcbiAgICAgIGlmIChfeHJGcmFtZSkge1xyXG4gICAgICAgIGlmIChYUlZpZXdwb3J0LmRlZmF1bHQuc2Vzc2lvbi5pbnB1dFNvdXJjZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgWFJWaWV3cG9ydC5kZWZhdWx0LnNlc3Npb24uaW5wdXRTb3VyY2VzLmZvckVhY2goX2NvbnRyb2xsZXIgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRyb2xsZXIuaGFuZGVkbmVzcykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAoXCJyaWdodFwiKTpcclxuICAgICAgICAgICAgICAgICAgdGhpcy52ckRldmljZS5yaWdodENudHJsLmNtcFRyYW5zZm9ybS5tdHhMb2NhbC5zZXQoX3hyRnJhbWUuZ2V0UG9zZShfY29udHJvbGxlci50YXJnZXRSYXlTcGFjZSwgWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlKS50cmFuc2Zvcm0ubWF0cml4KTtcclxuICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZyRGV2aWNlLnJpZ2h0Q250cmwuZ2FtZVBhZClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZyRGV2aWNlLnJpZ2h0Q250cmwuZ2FtZVBhZCA9IF9jb250cm9sbGVyLmdhbWVwYWQ7XHJcbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudnJEZXZpY2UucmlnaHRDbnRybC50aHVtYnN0aWNrWCA9IF9jb250cm9sbGVyLmdhbWVwYWQuYXhlc1syXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZyRGV2aWNlLnJpZ2h0Q250cmwudGh1bWJzdGlja1kgPSBfY29udHJvbGxlci5nYW1lcGFkLmF4ZXNbM107XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIChcImxlZnRcIik6XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMudnJEZXZpY2UubGVmdENudHJsLmNtcFRyYW5zZm9ybS5tdHhMb2NhbC5zZXQoX3hyRnJhbWUuZ2V0UG9zZShfY29udHJvbGxlci50YXJnZXRSYXlTcGFjZSwgWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlKS50cmFuc2Zvcm0ubWF0cml4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmICghdGhpcy52ckRldmljZS5sZWZ0Q250cmwuZ2FtZVBhZClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZyRGV2aWNlLmxlZnRDbnRybC5nYW1lUGFkID0gX2NvbnRyb2xsZXIuZ2FtZXBhZDtcclxuICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ckRldmljZS5sZWZ0Q250cmwudGh1bWJzdGlja1ggPSBfY29udHJvbGxlci5nYW1lcGFkLmF4ZXNbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ckRldmljZS5sZWZ0Q250cmwudGh1bWJzdGlja1kgPSBfY29udHJvbGxlci5nYW1lcGFkLmF4ZXNbM107XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlOiB1bmtub3duKSB7XHJcbiAgICAgICAgICAgICAgRGVidWcuZXJyb3IoXCJJbnB1dCBTb3VyY2VzIEVycm9yOiBcIiArIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIE1hcEZpbGVuYW1lVG9Db250ZW50IHtcclxuICAgIFtmaWxlbmFtZTogc3RyaW5nXTogc3RyaW5nO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBIYW5kbGVzIGZpbGUgdHJhbnNmZXIgZnJvbSBhIEZVREdFLUJyb3dzZXJhcHAgdG8gdGhlIGxvY2FsIGZpbGVzeXN0ZW0gd2l0aG91dCBhIGxvY2FsIHNlcnZlci4gIFxyXG4gICAqIFNhdmVzIHRvIHRoZSBkb3dubG9hZC1wYXRoIGdpdmVuIGJ5IHRoZSBicm93c2VyLCBsb2FkcyBmcm9tIHRoZSBwbGF5ZXIncyBjaG9pY2UuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEZpbGVJb0Jyb3dzZXJMb2NhbCBleHRlbmRzIEV2ZW50VGFyZ2V0U3RhdGljIHtcclxuICAgIHByaXZhdGUgc3RhdGljIHNlbGVjdG9yOiBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgLy8gVE9ETzogcmVmYWN0b3IgdG8gYXN5bmMgZnVuY3Rpb24gdG8gYmUgaGFuZGxlZCB1c2luZyBwcm9taXNlLCBpbnN0ZWFkIG9mIHVzaW5nIGV2ZW50IHRhcmdldFxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVuIGZpbGUgc2VsZWN0IGRpYWxvZyB0byBsb2FkIGZpbGVzIGZyb20gbG9jYWwgZmlsZXN5c3RlbSBpbnRvIGJyb3dzZXIgYXBwbGljYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZChfbXVsdGlwbGU6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8TWFwRmlsZW5hbWVUb0NvbnRlbnQ+IHtcclxuICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IudHlwZSA9IFwiZmlsZVwiO1xyXG4gICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IubXVsdGlwbGUgPSBfbXVsdGlwbGU7XHJcbiAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3Rvci5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBGaWxlSW9Ccm93c2VyTG9jYWwuaGFuZGxlRmlsZVNlbGVjdCk7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxNYXBGaWxlbmFtZVRvQ29udGVudD4oX3Jlc29sdmUgPT4ge1xyXG4gICAgICAgIGZ1bmN0aW9uIGhuZExvYWRlZChfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgICBGaWxlSW9Ccm93c2VyTG9jYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5GSUxFX0xPQURFRCwgaG5kTG9hZGVkKTtcclxuICAgICAgICAgIF9yZXNvbHZlKCg8Q3VzdG9tRXZlbnQ+X2V2ZW50KS5kZXRhaWwubWFwRmlsZW5hbWVUb0NvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuRklMRV9MT0FERUQsIGhuZExvYWRlZCk7XHJcbiAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yLmNsaWNrKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIGFzeW5jIGZ1bmN0aW9uIHRvIGJlIGhhbmRsZWQgdXNpbmcgcHJvbWlzZSwgaW5zdGVhZCBvZiB1c2luZyBldmVudCB0YXJnZXRcclxuICAgIC8qKlxyXG4gICAgICogT3BlbiBhIGZpbGUgZG93bmxvYWQgZGlhbG9nIHRvIHNhdmUgZmlsZXMgdG8gbG9jYWwgZmlsZXN5c3RlbS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzYXZlKF90b1NhdmU6IE1hcEZpbGVuYW1lVG9Db250ZW50LCBfdHlwZTogc3RyaW5nID0gXCJ0ZXh0L3BsYWluXCIpOiBQcm9taXNlPE1hcEZpbGVuYW1lVG9Db250ZW50PiB7XHJcbiAgICAgIGZvciAobGV0IGZpbGVuYW1lIGluIF90b1NhdmUpIHtcclxuICAgICAgICBsZXQgY29udGVudDogc3RyaW5nID0gX3RvU2F2ZVtmaWxlbmFtZV07XHJcbiAgICAgICAgbGV0IGJsb2I6IEJsb2IgPSBuZXcgQmxvYihbY29udGVudF0sIHsgdHlwZTogX3R5cGUgfSk7XHJcbiAgICAgICAgbGV0IHVybDogc3RyaW5nID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICAgICAgLy8qLyB1c2luZyBhbmNob3IgZWxlbWVudCBmb3IgZG93bmxvYWRcclxuICAgICAgICBsZXQgZG93bmxvYWRlcjogSFRNTEFuY2hvckVsZW1lbnQ7XHJcbiAgICAgICAgZG93bmxvYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG4gICAgICAgIGRvd25sb2FkZXIuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCB1cmwpO1xyXG4gICAgICAgIGRvd25sb2FkZXIuc2V0QXR0cmlidXRlKFwiZG93bmxvYWRcIiwgZmlsZW5hbWUpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRlcik7XHJcbiAgICAgICAgZG93bmxvYWRlci5jbGljaygpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZG93bmxvYWRlcik7XHJcbiAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPE1hcEZpbGVuYW1lVG9Db250ZW50PihfcmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgX3Jlc29sdmUoX3RvU2F2ZSk7XHJcbiAgICAgICAgLy8gZnVuY3Rpb24gaG5kU2F2ZWQoX2V2ZW50OiBFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIC8vICAgRmlsZUlvQnJvd3NlckxvY2FsLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuRklMRV9TQVZFRCwgaG5kU2F2ZWQpO1xyXG4gICAgICAgIC8vICAgX3Jlc29sdmUoKDxDdXN0b21FdmVudD5fZXZlbnQpLmRldGFpbCk7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAvLyBGaWxlSW9Ccm93c2VyTG9jYWwuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5GSUxFX1NBVkVELCBobmRTYXZlZCk7XHJcbiAgICAgICAgLy8gbGV0IGV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChFVkVOVC5GSUxFX1NBVkVELCB7IGRldGFpbDogeyBtYXBGaWxlbmFtZVRvQ29udGVudDogX3RvU2F2ZSB9IH0pO1xyXG4gICAgICAgIC8vIEZpbGVJb0Jyb3dzZXJMb2NhbC50YXJnZXRTdGF0aWMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCB0aGUgdGhlIGZpbGVzIHJlZmVyZW5jZWQgaW4ge0BsaW5rIEZpbGVMaXN0fSBpbnRvIHRoZSBwcm92aWRlZCB7QGxpbmsgTWFwRmlsZW5hbWVUb0NvbnRlbnR9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZEZpbGVzKF9maWxlTGlzdDogRmlsZUxpc3QsIF9sb2FkZWQ6IE1hcEZpbGVuYW1lVG9Db250ZW50KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGZvciAobGV0IGZpbGUgb2YgX2ZpbGVMaXN0KSB7XHJcbiAgICAgICAgY29uc3QgY29udGVudDogc3RyaW5nID0gYXdhaXQgbmV3IFJlc3BvbnNlKGZpbGUpLnRleHQoKTtcclxuICAgICAgICBfbG9hZGVkW2ZpbGUubmFtZV0gPSBjb250ZW50O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgaGFuZGxlRmlsZVNlbGVjdChfZXZlbnQ6IEV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIERlYnVnLmZ1ZGdlKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaGFuZGxlRmlsZVNlbGVjdFwiKTtcclxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IpO1xyXG4gICAgICBsZXQgZmlsZUxpc3Q6IEZpbGVMaXN0ID0gKDxIVE1MSW5wdXRFbGVtZW50Pl9ldmVudC50YXJnZXQpLmZpbGVzO1xyXG4gICAgICBEZWJ1Zy5mdWRnZShmaWxlTGlzdCwgZmlsZUxpc3QubGVuZ3RoKTtcclxuICAgICAgaWYgKGZpbGVMaXN0Lmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBsb2FkZWQ6IE1hcEZpbGVuYW1lVG9Db250ZW50ID0ge307XHJcbiAgICAgIGF3YWl0IEZpbGVJb0Jyb3dzZXJMb2NhbC5sb2FkRmlsZXMoZmlsZUxpc3QsIGxvYWRlZCk7XHJcblxyXG4gICAgICBsZXQgZXZlbnQ6IEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEVWRU5ULkZJTEVfTE9BREVELCB7IGRldGFpbDogeyBtYXBGaWxlbmFtZVRvQ29udGVudDogbG9hZGVkIH0gfSk7XHJcbiAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC50YXJnZXRTdGF0aWMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG59ICIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIE11dGFibGUgYXJyYXkgb2Yge0BsaW5rIE11dGFibGV9cy4gVGhlIHtAbGluayBNdXRhdG9yfXMgb2YgdGhlIGVudHJpZXMgYXJlIGluY2x1ZGVkIGFzIGFycmF5IGluIHRoZSB7QGxpbmsgTXV0YXRvcn1cclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE11dGFibGVBcnJheTxUIGV4dGVuZHMgTXV0YWJsZT4gZXh0ZW5kcyBBcnJheTxUPiB7XHJcbiAgICAjdHlwZTogbmV3ICgpID0+IFQ7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF90eXBlOiBuZXcgKCkgPT4gVCwgLi4uX2FyZ3M6IFRbXSkge1xyXG4gICAgICBzdXBlciguLi5fYXJncyk7XHJcbiAgICAgIHRoaXMuI3R5cGUgPSBfdHlwZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHR5cGUoKTogbmV3ICgpID0+IFQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jdHlwZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYXJyYW5nZSB0aGUgZW50cmllcyBvZiB0aGUgYXJyYXkgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBzZXF1ZW5jZSBvZiBpbmRpY2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFycmFuZ2UoX3NlcXVlbmNlOiBudW1iZXJbXSk6IHZvaWQge1xyXG4gICAgICBsZXQgbGVuZ3RoOiBudW1iZXIgPSB0aGlzLmxlbmd0aDtcclxuICAgICAgZm9yIChsZXQgaW5kZXggb2YgX3NlcXVlbmNlKSB7XHJcbiAgICAgICAgbGV0IG9yaWdpbmFsOiBUID0gdGhpc1tpbmRleF07XHJcbiAgICAgICAgLy8gVE9ETzogb3B0aW1pemUsIGNvcHkgb25seSBkb3VibGUgZW50cmllc1xyXG4gICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgIGxldCBjb3B5OiBUID0gbmV3IG9yaWdpbmFsLmNvbnN0cnVjdG9yKCk7XHJcbiAgICAgICAgY29weS5tdXRhdGUob3JpZ2luYWwuZ2V0TXV0YXRvcigpKTtcclxuICAgICAgICB0aGlzLnB1c2goY29weSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zcGxpY2UoMCwgbGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgd2l0aCB0aGlzIGFycmF5cyBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHR5cGVzIGFzIHN0cmluZy12YWx1ZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0ge307XHJcbiAgICAgIGZvciAobGV0IGVudHJ5IGluIHRoaXMpXHJcbiAgICAgICAgdHlwZXNbZW50cnldID0gdGhpc1tlbnRyeV0uY29uc3RydWN0b3IubmFtZTtcclxuXHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCBlYWNoIGVsZW1lbnRzIG11dGF0b3IgYnkgaW52b2tpbmcge0BsaW5rIE11dGFibGUuZ2V0TXV0YXRvcn0gb24gdGhlbVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgcmV0dXJuIHRoaXMubWFwKChfdmFsdWUpID0+IF92YWx1ZS5nZXRNdXRhdG9yKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VlIHtAbGluayBNdXRhYmxlLmdldE11dGF0b3JGb3JVc2VySW50ZXJmYWNlfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckZvclVzZXJJbnRlcmZhY2UoKTogTXV0YXRvciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldE11dGF0b3IoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE11dGF0ZSB0aGUgZWxlbWVudHMgb2YgdGhpcyBhcnJheSBkZWZpbmVkIGJ5IHRoZSBfbXV0YXRvciBieSBpbnZva2luZyB7QGxpbmsgTXV0YWJsZS5tdXRhdGV9IG9uIGl0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgZm9yIChsZXQgZW50cnkgaW4gX211dGF0b3IpXHJcbiAgICAgICAgYXdhaXQgdGhpc1s8R2VuZXJhbD5lbnRyeV0ubXV0YXRlKF9tdXRhdG9yW2VudHJ5XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG11dGF0b3IgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBlbnRyeSBpbiB0aGlzKSB7XHJcbiAgICAgICAgbGV0IG11dGF0b3JWYWx1ZTogT2JqZWN0ID0gX211dGF0b3JbZW50cnldO1xyXG4gICAgICAgIGlmICghbXV0YXRvclZhbHVlKVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKHRoaXNbZW50cnldIGluc3RhbmNlb2YgTXV0YWJsZSlcclxuICAgICAgICAgIF9tdXRhdG9yW2VudHJ5XSA9IHRoaXNbZW50cnldLmdldE11dGF0b3IoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBfbXV0YXRvcltlbnRyeV0gPSB0aGlzW2VudHJ5XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGQlgge1xyXG4gIC8qKlxyXG4gICAqIFJlYWRlciB0byByZWFkIGRhdGEgZnJvbSBhbiBhcnJheSBidWZmZXIgbW9yZSBjb252ZW5pZW50bHkuXHJcbiAgICogSXQgc2F2ZXMgYSBjdXJyZW50IG9mZnNldCB3aGljaCBpcyB1cGRhdGVkIHdoZW4gZGF0YSBpcyByZWFkIGR1ZSB0byBpdHMgYnl0ZWxlbmd0aC5cclxuICAgKiBkZXNwaXRlIGdldFNlcXVlbmNlIGl0IGlzIG1vc3RseSBhIGNvcHkgb2YgdGhlIHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL3BpY29kZTcvYmluYXJ5LXJlYWRlclxyXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQnVmZmVyUmVhZGVyIHtcclxuICAgIHB1YmxpYyBvZmZzZXQ6IG51bWJlcjtcclxuICAgIHB1YmxpYyByZWFkb25seSB2aWV3OiBEYXRhVmlldztcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2J1ZmZlcjogQXJyYXlCdWZmZXJMaWtlKSB7XHJcbiAgICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyhfYnVmZmVyKTtcclxuICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRDaGFyKF9vZmZzZXQ6IG51bWJlciA9IHRoaXMub2Zmc2V0KTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5nZXRVaW50OChfb2Zmc2V0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEJvb2woX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VWludDgoX29mZnNldCkgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0VWludDgoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLm9mZnNldCA9IF9vZmZzZXQgKyAxO1xyXG4gICAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQ4KF9vZmZzZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRVaW50MzIoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLm9mZnNldCA9IF9vZmZzZXQgKyA0O1xyXG4gICAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQzMihfb2Zmc2V0LCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0VWludDY0KF9vZmZzZXQ6IG51bWJlciA9IHRoaXMub2Zmc2V0KTogYmlnaW50IHtcclxuICAgICAgdGhpcy5vZmZzZXQgPSBfb2Zmc2V0ICsgODtcclxuICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRCaWdVaW50NjQoX29mZnNldCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEludDE2KF9vZmZzZXQ6IG51bWJlciA9IHRoaXMub2Zmc2V0KTogbnVtYmVyIHtcclxuICAgICAgdGhpcy5vZmZzZXQgPSBfb2Zmc2V0ICsgMjtcclxuICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRJbnQxNihfb2Zmc2V0LCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0SW50MzIoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLm9mZnNldCA9IF9vZmZzZXQgKyA0O1xyXG4gICAgICByZXR1cm4gdGhpcy52aWV3LmdldEludDMyKF9vZmZzZXQsIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRJbnQ2NChfb2Zmc2V0OiBudW1iZXIgPSB0aGlzLm9mZnNldCk6IGJpZ2ludCB7XHJcbiAgICAgIHRoaXMub2Zmc2V0ID0gX29mZnNldCArIDg7XHJcbiAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0QmlnSW50NjQoX29mZnNldCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEZsb2F0MzIoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLm9mZnNldCA9IF9vZmZzZXQgKyA0O1xyXG4gICAgICByZXR1cm4gdGhpcy52aWV3LmdldEZsb2F0MzIoX29mZnNldCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEZsb2F0NjQoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLm9mZnNldCA9IF9vZmZzZXQgKyA4O1xyXG4gICAgICByZXR1cm4gdGhpcy52aWV3LmdldEZsb2F0NjQoX29mZnNldCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFN0cmluZyhfbGVuZ3RoOiBudW1iZXIsIF9vZmZzZXQ6IG51bWJlciA9IHRoaXMub2Zmc2V0KTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoLi4udGhpcy5nZXRTZXF1ZW5jZSh0aGlzLmdldFVpbnQ4LCBfbGVuZ3RoLCBfb2Zmc2V0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljICpnZXRTZXF1ZW5jZTxUIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihfZ2V0dGVyOiAoKSA9PiBULCBfbGVuZ3RoOiBudW1iZXIsIF9vZmZzZXQ6IG51bWJlciA9IHRoaXMub2Zmc2V0KTogR2VuZXJhdG9yPFQ+IHtcclxuICAgICAgdGhpcy5vZmZzZXQgPSBfb2Zmc2V0O1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgX2xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgeWllbGQgX2dldHRlci5jYWxsKHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZCWCB7XHJcbiAgLyoqXHJcbiAgICogSW50ZXJmYWNlIHRvIHJlcHJlc2VudCBmYnggZmlsZXMgY29udGFpbmluZyBpdHMgZG9jdW1lbnRzLCBkZWZpbml0aW9ucywgb2JqZWN0cyBhbmQgY29ubmVjdGlvbnMuXHJcbiAgICogSXRzIG9iamVjdHMgYXJlIGRldmlkZWQgaW4gYWxsIGFuZCB0aGUgZGlmZmVyZW50IG9iamVjdCB0eXBlcy5cclxuICAgKiBAYXV0aG9yIE1hdHRoaWFzIFJvbWluZywgSEZVLCAyMDIzXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBGQlgge1xyXG4gICAgZG9jdW1lbnRzOiBEb2N1bWVudFtdO1xyXG4gICAgZGVmaW5pdGlvbnM/OiBEZWZpbml0aW9ucztcclxuICAgIG9iamVjdHM6IHtcclxuICAgICAgYWxsOiBPYmplY3RbXTtcclxuICAgICAgbW9kZWxzOiBNb2RlbFtdO1xyXG4gICAgICBnZW9tZXRyaWVzOiBHZW9tZXRyeVtdO1xyXG4gICAgICBwb3NlczogT2JqZWN0W107XHJcbiAgICAgIG1hdGVyaWFsczogTWF0ZXJpYWxbXTtcclxuICAgICAgdGV4dHVyZXM6IFRleHR1cmVbXTtcclxuICAgICAgYW5pbVN0YWNrczogT2JqZWN0W107XHJcbiAgICB9O1xyXG4gICAgY29ubmVjdGlvbnM6IENvbm5lY3Rpb25bXTtcclxuICB9XHJcblxyXG4gIGludGVyZmFjZSBPYmplY3RCYXNlIHtcclxuICAgIHVpZDogbnVtYmVyO1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgdHlwZT86IHN0cmluZztcclxuICAgIHN1YnR5cGU/OiBzdHJpbmc7XHJcbiAgICBjaGlsZHJlbj86IE9iamVjdFtdO1xyXG4gICAgcGFyZW50cz86IE9iamVjdFtdO1xyXG5cclxuICAgIGxvYWRlZDogYm9vbGVhbjtcclxuICAgIGxvYWQ6ICgpID0+IE9iamVjdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVyZmFjZSB0byByZXByZXNlbnQgZmJ4LW9iamVjdHMuXHJcbiAgICogQWxsIGZpZWxkcyBvdGhlciB0aGFuIHVpZCwgbmFtZSwgdHlwZSwgc3VidHlwZSwgY2hpbGRyZW4gYW5kIHBhcmVudHMgYXJlIGxvYWRlZCB3aXRoIHRoZSBsb2FkLW1ldGhvZC5cclxuICAgKiBFYWNoIG9iamVjdCBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgYW4gZXhwbGljaXQgZmJ4IG9iamVjdCB0eXBlIGRlZmluZWQgaW4gRnVkZ2VDb3JlLkZCWC4gRXhwbGljaXQgdHlwZXMgaGF2ZSBiZWVuIGRlZmluZWRcclxuICAgKiB3aXRoIHRoZSBoZWxwIG9mIGZvbGxvd2luZyByZWZlcmVuY2U6XHJcbiAgICogaHR0cHM6Ly9hcmNoaXZlLmJsZW5kZXIub3JnL3dpa2kvaW5kZXgucGhwL1VzZXI6TW9udDI5L0ZvdW5kYXRpb24vRkJYX0ZpbGVfU3RydWN0dXJlLyNTb21lX1NwZWNpZmljX1Byb3BlcnR5X1R5cGVzXHJcbiAgICogQGF1dGhvciBNYXR0aGlhcyBSb21pbmcsIEhGVSwgMjAyM1xyXG4gICAqIEBpZ25vcmVcclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE9iamVjdCBleHRlbmRzIE9iamVjdEJhc2Uge1xyXG4gICAgW25hbWU6IHN0cmluZ106IE5vZGVQcm9wZXJ0eSB8IHsgW25hbWU6IHN0cmluZ106IE5vZGVQcm9wZXJ0eSB9IHwgUHJvcGVydHk3MCB8IE9iamVjdCB8IE9iamVjdFtdIHwgKCgpID0+IE9iamVjdCk7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIERvY3VtZW50IGV4dGVuZHMgT2JqZWN0QmFzZSB7XHJcbiAgICBTb3VyY2VPYmplY3Q/OiB1bmRlZmluZWQ7XHJcbiAgICBBY3RpdmVBbmltU3RhY2tOYW1lPzogc3RyaW5nO1xyXG4gICAgUm9vdE5vZGU/OiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIE5vZGVBdHRyaWJ1dGUgZXh0ZW5kcyBPYmplY3RCYXNlIHtcclxuICAgIFR5cGVGbGFncz86IHN0cmluZztcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgR2VvbWV0cnkgZXh0ZW5kcyBPYmplY3RCYXNlIHtcclxuICAgIEdlb21ldHJ5VmVyc2lvbj86IG51bWJlcjtcclxuICAgIFZlcnRpY2VzPzogRmxvYXQzMkFycmF5O1xyXG4gICAgUG9seWdvblZlcnRleEluZGV4PzogSW50MzJBcnJheTtcclxuICAgIExheWVyRWxlbWVudE5vcm1hbD86IExheWVyRWxlbWVudE5vcm1hbDtcclxuICAgIExheWVyRWxlbWVudFVWPzogTGF5ZXJFbGVtZW50VVY7IC8vIHwgTGF5ZXJFbGVtZW50VVZbXTsgLy8gVE9ETzogbWlnaHQgbmVlZCB0byByZWFkZCB0aGlzXHJcbiAgICBMYXllckVsZW1lbnRNYXRlcmlhbD86IExheWVyRWxlbWVudE1hdGVyaWFsO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNb2RlbCBleHRlbmRzIE9iamVjdEJhc2Uge1xyXG4gICAgVmVyc2lvbj86IG51bWJlcjtcclxuICAgIExjbFRyYW5zbGF0aW9uPzogRnVkZ2VDb3JlLlZlY3RvcjMgfCBBbmltQ3VydmVOb2RlO1xyXG4gICAgTGNsUm90YXRpb24/OiBGdWRnZUNvcmUuVmVjdG9yMyB8IEFuaW1DdXJ2ZU5vZGU7XHJcbiAgICBMY2xTY2FsaW5nPzogRnVkZ2VDb3JlLlZlY3RvcjMgfCBBbmltQ3VydmVOb2RlO1xyXG4gICAgUHJlUm90YXRpb24/OiBGdWRnZUNvcmUuVmVjdG9yMztcclxuICAgIFBvc3RSb3RhdGlvbj86IEZ1ZGdlQ29yZS5WZWN0b3IzO1xyXG4gICAgU2NhbGluZ09mZnNldD86IEZ1ZGdlQ29yZS5WZWN0b3IzO1xyXG4gICAgU2NhbGluZ1Bpdm90PzogRnVkZ2VDb3JlLlZlY3RvcjM7XHJcbiAgICBSb3RhdGlvbk9mZnNldD86IEZ1ZGdlQ29yZS5WZWN0b3IzO1xyXG4gICAgUm90YXRpb25QaXZvdD86IEZ1ZGdlQ29yZS5WZWN0b3IzO1xyXG4gICAgSW5oZXJpdFR5cGU/OiBudW1iZXI7XHJcbiAgICBFdWxlck9yZGVyPzogc3RyaW5nO1xyXG4gICAgY3VycmVudFVWU2V0Pzogc3RyaW5nO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNYXRlcmlhbCBleHRlbmRzIE9iamVjdEJhc2Uge1xyXG4gICAgVmVyc2lvbj86IG51bWJlcjtcclxuICAgIFNoYWRpbmdNb2RlbD86IHN0cmluZztcclxuXHJcbiAgICBEaWZmdXNlPzogRnVkZ2VDb3JlLlZlY3RvcjM7XHJcbiAgICBEaWZmdXNlQ29sb3I/OiBGdWRnZUNvcmUuVmVjdG9yMyB8IFRleHR1cmU7XHJcbiAgICBEaWZmdXNlRmFjdG9yPzogbnVtYmVyO1xyXG5cclxuICAgIEFtYmllbnQ/OiBGdWRnZUNvcmUuVmVjdG9yMztcclxuICAgIEFtYmllbnRDb2xvcj86IEZ1ZGdlQ29yZS5WZWN0b3IzIHwgVGV4dHVyZTtcclxuXHJcbiAgICBTaGluaW5lc3M/OiBudW1iZXI7XHJcbiAgICBTaGluaW5lc3NFeHBvbmVudD86IEZ1ZGdlQ29yZS5WZWN0b3IzIHwgVGV4dHVyZTtcclxuXHJcbiAgICBTcGVjdWxhcj86IEZ1ZGdlQ29yZS5WZWN0b3IzO1xyXG4gICAgU3BlY3VsYXJDb2xvcj86IEZ1ZGdlQ29yZS5WZWN0b3IzIHwgVGV4dHVyZTtcclxuICAgIFNwZWN1bGFyRmFjdG9yPzogbnVtYmVyO1xyXG5cclxuICAgIFJlZmxlY3Rpdml0eT86IG51bWJlcjtcclxuICAgIFJlZmxlY3Rpb25GYWN0b3I/OiBudW1iZXI7XHJcblxyXG4gICAgT3BhY2l0eT86IG51bWJlcjtcclxuICAgIFRyYW5zcGFyZW5jeUZhY3Rvcj86IG51bWJlcjtcclxuXHJcbiAgICBFbWlzc2l2ZT86IEZ1ZGdlQ29yZS5WZWN0b3IzO1xyXG4gICAgTm9ybWFsTWFwPzogVGV4dHVyZTtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgRGVmb3JtZXIgZXh0ZW5kcyBPYmplY3RCYXNlIHtcclxuICAgIFZlcnNpb24/OiBudW1iZXI7XHJcbiAgICBTa2lubmluZ1R5cGU/OiBzdHJpbmc7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFN1YkRlZm9ybWVyIGV4dGVuZHMgT2JqZWN0QmFzZSB7XHJcbiAgICBWZXJzaW9uPzogbnVtYmVyO1xyXG4gICAgVHJhbnNmb3JtPzogRmxvYXQzMkFycmF5O1xyXG4gICAgVHJhbnNmb3JtTGluaz86IEZsb2F0MzJBcnJheTtcclxuICAgIEluZGV4ZXM/OiBVaW50MTZBcnJheTtcclxuICAgIFdlaWdodHM/OiBGbG9hdDMyQXJyYXk7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFRleHR1cmUgZXh0ZW5kcyBPYmplY3RCYXNlIHtcclxuICAgIEZpbGVOYW1lPzogc3RyaW5nO1xyXG4gICAgUmVsYXRpdmVGaWxlbmFtZT86IHN0cmluZztcclxuICAgIE1vZGVsVVZTY2FsaW5nPzogbnVtYmVyO1xyXG4gICAgTW9kZWxVVlRyYW5zbGF0aW9uPzogbnVtYmVyO1xyXG4gICAgVVZTZXQ/OiBzdHJpbmc7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFZpZGVvIGV4dGVuZHMgT2JqZWN0QmFzZSB7XHJcbiAgICBGaWxlTmFtZT86IHN0cmluZztcclxuICAgIFJlbGF0aXZlRmlsZW5hbWU/OiBzdHJpbmc7XHJcbiAgICBVc2VNaXBNYXA/OiBudW1iZXI7XHJcbiAgICBDb250ZW50PzogVWludDhBcnJheTtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbUN1cnZlTm9kZSBleHRlbmRzIE9iamVjdEJhc2Uge1xyXG4gICAgZFg/OiBudW1iZXIgfCBBbmltQ3VydmU7XHJcbiAgICBkWT86IG51bWJlciB8IEFuaW1DdXJ2ZTtcclxuICAgIGRaPzogbnVtYmVyIHwgQW5pbUN1cnZlO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBbmltQ3VydmUgZXh0ZW5kcyBPYmplY3RCYXNlIHtcclxuICAgIEtleVZlcj86IG51bWJlcjtcclxuICAgIERlZmF1bHQ/OiBudW1iZXI7XHJcbiAgICBLZXlUaW1lPzogQmlnSW50NjRBcnJheTtcclxuICAgIEtleVZhbHVlRmxvYXQ/OiBGbG9hdDMyQXJyYXk7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIExheWVyRWxlbWVudCB7XHJcbiAgICBOYW1lOiBzdHJpbmc7XHJcbiAgICBWZXJzaW9uOiBudW1iZXI7XHJcbiAgICBNYXBwaW5nSW5mb3JtYXRpb25UeXBlOiBzdHJpbmc7XHJcbiAgICBSZWZlcmVuY2VJbmZvcm1hdGlvblR5cGU6IHN0cmluZztcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTGF5ZXJFbGVtZW50Tm9ybWFsIGV4dGVuZHMgTGF5ZXJFbGVtZW50IHtcclxuICAgIE5vcm1hbHM6IEZsb2F0MzJBcnJheTtcclxuICAgIE5vcm1hbHNXOiBGbG9hdDMyQXJyYXk7XHJcbiAgICBOb3JtYWxzSW5kZXg/OiBVaW50MTZBcnJheTsgLy8gVE9ETzogZmluZCBhbiBGQlggZmlsZSB3aGljaCB1c2VzIG5vcm1hbHMgaW5kZXhcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTGF5ZXJFbGVtZW50VVYgZXh0ZW5kcyBMYXllckVsZW1lbnQge1xyXG4gICAgVVY/OiBGbG9hdDMyQXJyYXk7XHJcbiAgICBVVkluZGV4PzogVWludDE2QXJyYXk7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIExheWVyRWxlbWVudE1hdGVyaWFsIGV4dGVuZHMgTGF5ZXJFbGVtZW50IHtcclxuICAgIE1hdGVyaWFscz86IG51bWJlcjtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIE1BUFBJTkdfSU5GT1JNQVRJT05fVFlQRSB7XHJcbiAgICBCWV9WRVJURVgsIEJZX1BPTFlHT04sIEJZX1BPTFlHT05fVkVSVEVYLCBCWV9FREdFLCBBTExfU0FNRVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gUkVGRVJFTkNFX0lORk9STUFUSU9OX1RZUEUge1xyXG4gICAgRElSRUNULCBJTkRFWF9UT19ESVJFQ1RcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29ubmVjdGlvbiB7XHJcbiAgICBwYXJlbnRVSUQ6IG51bWJlcjtcclxuICAgIGNoaWxkVUlEOiBudW1iZXI7XHJcbiAgICBwcm9wZXJ0eU5hbWU6IHN0cmluZztcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgRGVmaW5pdGlvbnMge1xyXG4gICAgdmVyc2lvbjogbnVtYmVyO1xyXG4gICAgb2JqZWN0VHlwZXM6IE9iamVjdFR5cGVbXTtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgT2JqZWN0VHlwZSB7XHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICBjb3VudDogbnVtYmVyO1xyXG4gICAgcHJvcGVydHlUZW1wbGF0ZTogUHJvcGVydHlUZW1wbGF0ZTtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcGVydHlUZW1wbGF0ZSB7XHJcbiAgICBbcHJvcGVydHlOYW1lOiBzdHJpbmddOiBQcm9wZXJ0eTcwO1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEFzc2V0IGxvYWRlciBmb3IgRmlsbWJveCBmaWxlcy5cclxuICAgKiBAYXV0aG9yIE1hdHRoaWFzIFJvbWluZywgSEZVLCAyMDIzXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEZCWExvYWRlciB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBsb2FkZXJzOiB7IFt1cmk6IHN0cmluZ106IEZCWExvYWRlciB9O1xyXG5cclxuICAgIHN0YXRpYyAjZGVmYXVsdE1hdGVyaWFsOiBNYXRlcmlhbDtcclxuICAgIHN0YXRpYyAjZGVmYXVsdFNraW5NYXRlcmlhbDogTWF0ZXJpYWw7XHJcblxyXG4gICAgcHVibGljIHJlYWRvbmx5IGZieDogRkJYLkZCWDtcclxuICAgIHB1YmxpYyByZWFkb25seSBub2RlczogRkJYLk5vZGVbXTtcclxuICAgIHB1YmxpYyByZWFkb25seSB1cmk6IHN0cmluZztcclxuXHJcbiAgICAjc2NlbmVzOiBHcmFwaFtdO1xyXG4gICAgI25vZGVzOiBOb2RlW107XHJcbiAgICAjbWVzaGVzOiBNZXNoRkJYW107XHJcbiAgICAjbWF0ZXJpYWxzOiBNYXRlcmlhbFtdO1xyXG4gICAgI3NraW5NYXRlcmlhbHM6IE1hdGVyaWFsW10gPSBbXTtcclxuICAgICN0ZXh0dXJlczogVGV4dHVyZVtdO1xyXG4gICAgI3NrZWxldG9uczogQ29tcG9uZW50U2tlbGV0b25bXTtcclxuICAgICNhbmltYXRpb25zOiBBbmltYXRpb25bXTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2J1ZmZlcjogQXJyYXlCdWZmZXIsIF91cmk6IHN0cmluZykge1xyXG4gICAgICB0aGlzLnVyaSA9IF91cmk7XHJcbiAgICAgIHRoaXMubm9kZXMgPSBGQlgucGFyc2VOb2Rlc0Zyb21CaW5hcnkoX2J1ZmZlcik7XHJcbiAgICAgIERlYnVnLmxvZyh0aGlzLm5vZGVzKTtcclxuICAgICAgdGhpcy5mYnggPSBGQlgubG9hZEZyb21Ob2Rlcyh0aGlzLm5vZGVzKTtcclxuICAgICAgRGVidWcubG9nKHRoaXMuZmJ4KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXQgZGVmYXVsdE1hdGVyaWFsKCk6IE1hdGVyaWFsIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2RlZmF1bHRNYXRlcmlhbCB8fCAodGhpcy4jZGVmYXVsdE1hdGVyaWFsID1cclxuICAgICAgICBuZXcgTWF0ZXJpYWwoXCJGQlhEZWZhdWx0TWF0ZXJpYWxcIiwgU2hhZGVyR291cmF1ZCwgbmV3IENvYXRSZW1pc3NpdmUoQ29sb3IuQ1NTKFwid2hpdGVcIikpKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldCBkZWZhdWx0U2tpbk1hdGVyaWFsKCk6IE1hdGVyaWFsIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2RlZmF1bHRTa2luTWF0ZXJpYWwgfHwgKHRoaXMuI2RlZmF1bHRTa2luTWF0ZXJpYWwgPVxyXG4gICAgICAgIG5ldyBNYXRlcmlhbChcIkZCWERlZmF1bHRTa2luTWF0ZXJpYWxcIiwgU2hhZGVyR291cmF1ZFNraW4sIG5ldyBDb2F0UmVtaXNzaXZlKENvbG9yLkNTUyhcIndoaXRlXCIpKSlcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIExPQUQoX3VyaTogc3RyaW5nKTogUHJvbWlzZTxGQlhMb2FkZXI+IHtcclxuICAgICAgaWYgKCF0aGlzLmxvYWRlcnMpXHJcbiAgICAgICAgdGhpcy5sb2FkZXJzID0ge307XHJcbiAgICAgIGlmICghdGhpcy5sb2FkZXJzW191cmldKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2U6IFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goX3VyaSk7XHJcbiAgICAgICAgY29uc3QgYmluYXJ5OiBBcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXJzW191cmldID0gbmV3IEZCWExvYWRlcihiaW5hcnksIF91cmkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLmxvYWRlcnNbX3VyaV07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldFNjZW5lKF9pbmRleDogbnVtYmVyID0gMCk6IFByb21pc2U8R3JhcGg+IHtcclxuICAgICAgaWYgKCF0aGlzLiNzY2VuZXMpXHJcbiAgICAgICAgdGhpcy4jc2NlbmVzID0gW107XHJcbiAgICAgIGlmICghdGhpcy4jc2NlbmVzW19pbmRleF0pIHtcclxuICAgICAgICBjb25zdCBkb2N1bWVudEZCWDogRkJYLkRvY3VtZW50ID0gdGhpcy5mYnguZG9jdW1lbnRzW19pbmRleF0ubG9hZCgpO1xyXG4gICAgICAgIGNvbnN0IHNjZW5lOiBHcmFwaCA9IG5ldyBHcmFwaChkb2N1bWVudEZCWC5uYW1lKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkRkJYIG9mIGRvY3VtZW50RkJYLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICBpZiAoY2hpbGRGQlgudHlwZSA9PSBcIk1vZGVsXCIpIHtcclxuICAgICAgICAgICAgc2NlbmUuYWRkQ2hpbGQoYXdhaXQgdGhpcy5nZXROb2RlKHRoaXMuZmJ4Lm9iamVjdHMubW9kZWxzLmluZGV4T2YoY2hpbGRGQlgpKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5mYngub2JqZWN0cy5hbmltU3RhY2tzICYmIHRoaXMuZmJ4Lm9iamVjdHMuYW5pbVN0YWNrcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCBhbmltYXRpb246IEFuaW1hdGlvbiA9IGF3YWl0IHRoaXMuZ2V0QW5pbWF0aW9uKGRvY3VtZW50RkJYLkFjdGl2ZUFuaW1TdGFja05hbWUubGVuZ3RoID4gMCA/XHJcbiAgICAgICAgICAgIHRoaXMuZmJ4Lm9iamVjdHMuYW5pbVN0YWNrcy5maW5kSW5kZXgoX2FuaW1TdGFjayA9PiBfYW5pbVN0YWNrLm5hbWUgPT0gZG9jdW1lbnRGQlguQWN0aXZlQW5pbVN0YWNrTmFtZSkgOiAwKTtcclxuICAgICAgICAgIGlmIChhbmltYXRpb24pXHJcbiAgICAgICAgICAgIHNjZW5lLmFkZENvbXBvbmVudChuZXcgQ29tcG9uZW50QW5pbWF0aW9uKGFuaW1hdGlvbikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBza2VsZXRvbiBvZiB0aGlzLiNza2VsZXRvbnMpXHJcbiAgICAgICAgICBzY2VuZS5hZGRDb21wb25lbnQoc2tlbGV0b24pO1xyXG5cclxuICAgICAgICBQcm9qZWN0LnJlZ2lzdGVyKHNjZW5lKTtcclxuICAgICAgICB0aGlzLiNzY2VuZXNbX2luZGV4XSA9IHNjZW5lO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLiNzY2VuZXNbX2luZGV4XTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0Tm9kZShfaW5kZXg6IG51bWJlcik6IFByb21pc2U8Tm9kZT4ge1xyXG4gICAgICBpZiAoIXRoaXMuI25vZGVzKVxyXG4gICAgICAgIHRoaXMuI25vZGVzID0gW107XHJcbiAgICAgIGlmICghdGhpcy4jbm9kZXNbX2luZGV4XSkge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBub2RlIHdpdGggdHJhbnNmb3JtXHJcbiAgICAgICAgY29uc3QgbW9kZWxGQlg6IEZCWC5Nb2RlbCA9IHRoaXMuZmJ4Lm9iamVjdHMubW9kZWxzW19pbmRleF0ubG9hZCgpO1xyXG4gICAgICAgIGNvbnN0IG5vZGU6IE5vZGUgPSBuZXcgTm9kZShtb2RlbEZCWC5uYW1lKTtcclxuICAgICAgICBhd2FpdCB0aGlzLmdlbmVyYXRlVHJhbnNmb3JtKG1vZGVsRkJYLCBub2RlKTtcclxuICAgICAgICB0aGlzLiNub2Rlc1tfaW5kZXhdID0gbm9kZTtcclxuXHJcbiAgICAgICAgLy8gYXR0YWNoIGNoaWxkcmVuIGFuZCBjb21wb25lbnRzXHJcbiAgICAgICAgaWYgKG1vZGVsRkJYLmNoaWxkcmVuKSBmb3IgKGNvbnN0IGNoaWxkRkJYIG9mIG1vZGVsRkJYLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICBpZiAoY2hpbGRGQlgudHlwZSA9PSBcIk1vZGVsXCIpIHtcclxuICAgICAgICAgICAgbm9kZS5hZGRDaGlsZChhd2FpdCB0aGlzLmdldE5vZGUodGhpcy5mYngub2JqZWN0cy5tb2RlbHMuaW5kZXhPZihjaGlsZEZCWCkpKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRGQlgudHlwZSA9PSBcIkdlb21ldHJ5XCIpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVzaDogTWVzaEZCWCA9IGF3YWl0IHRoaXMuZ2V0TWVzaCh0aGlzLmZieC5vYmplY3RzLmdlb21ldHJpZXMuaW5kZXhPZihjaGlsZEZCWCkpO1xyXG4gICAgICAgICAgICBjb25zdCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gbmV3IENvbXBvbmVudE1lc2gobWVzaCk7XHJcbiAgICAgICAgICAgIG5vZGUuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnRNYXRlcmlhbChGQlhMb2FkZXIuZGVmYXVsdE1hdGVyaWFsKSk7XHJcbiAgICAgICAgICAgIGlmIChtZXNoLnJlbmRlck1lc2guYm9uZXMpIHtcclxuICAgICAgICAgICAgICBjbXBNZXNoLnNrZWxldG9uID0gYXdhaXQgdGhpcy5nZXRTa2VsZXRvbihjaGlsZEZCWC5jaGlsZHJlblswXS5jaGlsZHJlblswXS5jaGlsZHJlblswXSk7XHJcbiAgICAgICAgICAgICAgLy8gZm9yIChjb25zdCBzdWJEZWZvcm1lckZCWCBvZiBjaGlsZEZCWC5jaGlsZHJlblswXS5jaGlsZHJlbiBhcyBGQlguU3ViRGVmb3JtZXJbXSkge1xyXG4gICAgICAgICAgICAgIC8vICAgY29uc3QgYm9uZTogTm9kZSA9IGNtcE1lc2guc2tlbGV0b24uYm9uZXNbc3ViRGVmb3JtZXJGQlguY2hpbGRyZW5bMF0ubmFtZV07XHJcbiAgICAgICAgICAgICAgLy8gICBib25lLm10eExvY2FsLnNldChzdWJEZWZvcm1lckZCWC5UcmFuc2Zvcm1MaW5rKTtcclxuICAgICAgICAgICAgICAvLyAgIGlmIChib25lLmdldFBhcmVudCgpKVxyXG4gICAgICAgICAgICAgIC8vICAgICBib25lLm10eExvY2FsLm11bHRpcGx5KGJvbmUuZ2V0UGFyZW50KCkubXR4V29ybGRJbnZlcnNlKTtcclxuICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWF0ZXJpYWwpLm1hdGVyaWFsID0gRkJYTG9hZGVyLmRlZmF1bHRTa2luTWF0ZXJpYWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZS5hZGRDb21wb25lbnQoY21wTWVzaCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkRkJYLnR5cGUgPT0gXCJNYXRlcmlhbFwiKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGFkZGl0aW9uYWwgc2tpbiBtYXRlcmlhbHMgZ2V0IGNyZWF0ZWQgaGVyZSwgY2hlY2sgaWYgdGhlIG9yaWdpbmFsIG1hdGVyaWFsIGlzIHN0aWxsIG5lZWRlZFxyXG4gICAgICAgICAgICBjb25zdCBpTWF0ZXJpYWw6IG51bWJlciA9IHRoaXMuZmJ4Lm9iamVjdHMubWF0ZXJpYWxzLmluZGV4T2YoY2hpbGRGQlgpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXRlcmlhbDogTWF0ZXJpYWwgPSBhd2FpdCB0aGlzLmdldE1hdGVyaWFsKGlNYXRlcmlhbCk7XHJcbiAgICAgICAgICAgIG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1hdGVyaWFsKS5tYXRlcmlhbCA9IG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpLm1lc2gucmVuZGVyTWVzaC5ib25lcyA/XHJcbiAgICAgICAgICAgICAgdGhpcy4jc2tpbk1hdGVyaWFsc1tpTWF0ZXJpYWxdIHx8ICh0aGlzLiNza2luTWF0ZXJpYWxzW2lNYXRlcmlhbF0gPSBuZXcgTWF0ZXJpYWwoXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5uYW1lLFxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwuZ2V0U2hhZGVyKCkgPT0gU2hhZGVyUGhvbmcgP1xyXG4gICAgICAgICAgICAgICAgICBTaGFkZXJQaG9uZ1NraW4gOlxyXG4gICAgICAgICAgICAgICAgICBTaGFkZXJQaG9uZ1RleHR1cmVkU2tpbixcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLmNvYXRcclxuICAgICAgICAgICAgICApKSA6XHJcbiAgICAgICAgICAgICAgbWF0ZXJpYWw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLiNub2Rlc1tfaW5kZXhdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRNZXNoKF9pbmRleDogbnVtYmVyKTogUHJvbWlzZTxNZXNoRkJYPiB7XHJcbiAgICAgIGlmICghdGhpcy4jbWVzaGVzKVxyXG4gICAgICAgIHRoaXMuI21lc2hlcyA9IFtdO1xyXG4gICAgICBpZiAoIXRoaXMuI21lc2hlc1tfaW5kZXhdKVxyXG4gICAgICAgIHRoaXMuI21lc2hlc1tfaW5kZXhdID0gYXdhaXQgbmV3IE1lc2hGQlgoKS5sb2FkKHRoaXMudXJpLCBfaW5kZXgpO1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWVzaGVzW19pbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldE1hdGVyaWFsKF9pbmRleDogbnVtYmVyKTogUHJvbWlzZTxNYXRlcmlhbD4ge1xyXG4gICAgICBpZiAoIXRoaXMuI21hdGVyaWFscylcclxuICAgICAgICB0aGlzLiNtYXRlcmlhbHMgPSBbXTtcclxuICAgICAgaWYgKCF0aGlzLiNtYXRlcmlhbHNbX2luZGV4XSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGVyaWFsRkJYOiBGQlguTWF0ZXJpYWwgPSB0aGlzLmZieC5vYmplY3RzLm1hdGVyaWFsc1tfaW5kZXhdLmxvYWQoKTtcclxuICAgICAgICBpZiAoIShtYXRlcmlhbEZCWC5EaWZmdXNlQ29sb3IgaW5zdGFuY2VvZiBWZWN0b3IzKSlcclxuICAgICAgICAgIG1hdGVyaWFsRkJYLkRpZmZ1c2VDb2xvcj8uY2hpbGRyZW5bMF0ubG9hZCgpO1xyXG4gICAgICAgIC8vIEZCWCBzdXBwb3J0cyBsYW1iZXJ0IGFuZCBwaG9uZyBzaGFkaW5nLCBlaXRoZXIgd2F5IGZ1ZGdlIGhhcyBubyBsYW1iZXJ0IHNoYWRlciBzbyB3ZSBhbHdheXMgdXNlIHBob25nLlxyXG4gICAgICAgIC8vIEluIERpZmZ1c2VDb2xvciB0aGUgdGV4dHVyZSBvZiB0aGUgbWF0ZXJpYWwgY29sb3IgaXMgc3RvcmVkLCBpZiBpdCdzIGRlZmluZWQgd2UgdXNlIGEgdGV4dHVyZSBzaGFkZXIuXHJcbiAgICAgICAgLy8gVE9ETzogbWF0ZXJpYWxGQlggYWxzbyBjb250YWlucyBhZGRpdGlvbmFsIHZhbHVlcyBsaWtlIHNoaW5pbmVzcyBhbmQgcmVmbGVjdGl2aXR5IChhbmQgb3RoZXJzKSB3aGljaCBhcmUgbm90IHN1cHBwb3J0ZWQuXHJcbiAgICAgICAgdGhpcy4jbWF0ZXJpYWxzW19pbmRleF0gPSBuZXcgTWF0ZXJpYWwoXHJcbiAgICAgICAgICBtYXRlcmlhbEZCWC5uYW1lLFxyXG4gICAgICAgICAgbWF0ZXJpYWxGQlguRGlmZnVzZUNvbG9yICYmICEobWF0ZXJpYWxGQlguRGlmZnVzZUNvbG9yIGluc3RhbmNlb2YgVmVjdG9yMykgP1xyXG4gICAgICAgICAgICBTaGFkZXJQaG9uZ1RleHR1cmVkIDpcclxuICAgICAgICAgICAgU2hhZGVyUGhvbmcsXHJcbiAgICAgICAgICBtYXRlcmlhbEZCWC5EaWZmdXNlQ29sb3IgJiYgIShtYXRlcmlhbEZCWC5EaWZmdXNlQ29sb3IgaW5zdGFuY2VvZiBWZWN0b3IzKSA/XHJcbiAgICAgICAgICAgIG5ldyBDb2F0UmVtaXNzaXZlVGV4dHVyZWQoXHJcbiAgICAgICAgICAgICAgbmV3IENvbG9yKC4uLm1hdGVyaWFsRkJYLkRpZmZ1c2UuZ2V0KCkpLFxyXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0VGV4dHVyZSh0aGlzLmZieC5vYmplY3RzLnRleHR1cmVzLmluZGV4T2YobWF0ZXJpYWxGQlguRGlmZnVzZUNvbG9yKSksXHJcbiAgICAgICAgICAgICAgbWF0ZXJpYWxGQlguRGlmZnVzZUZhY3RvciA/PyAxLFxyXG4gICAgICAgICAgICAgIG1hdGVyaWFsRkJYLlNwZWN1bGFyRmFjdG9yID8/IGF2ZXJhZ2UobWF0ZXJpYWxGQlguU3BlY3VsYXI/LmdldCgpKSA/PyAwXHJcbiAgICAgICAgICAgICkgOlxyXG4gICAgICAgICAgICBuZXcgQ29hdFJlbWlzc2l2ZShcclxuICAgICAgICAgICAgICBuZXcgQ29sb3IoLi4uKG1hdGVyaWFsRkJYLkRpZmZ1c2VDb2xvciBhcyBWZWN0b3IzID8/IG1hdGVyaWFsRkJYLkRpZmZ1c2UpLmdldCgpKSxcclxuICAgICAgICAgICAgICBtYXRlcmlhbEZCWC5EaWZmdXNlRmFjdG9yID8/IDEsXHJcbiAgICAgICAgICAgICAgbWF0ZXJpYWxGQlguU3BlY3VsYXJGYWN0b3IgPz8gYXZlcmFnZShtYXRlcmlhbEZCWC5TcGVjdWxhcj8uZ2V0KCkpID8/IDBcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuI21hdGVyaWFsc1tfaW5kZXhdO1xyXG5cclxuICAgICAgZnVuY3Rpb24gYXZlcmFnZShfYXJyYXk6IEZsb2F0MzJBcnJheSk6IG51bWJlciB7IC8vIFRPRE86IHNwZWN1bGFyIGZhY3RvciB2ZWN0b3IgKHRvZ2V0aGVyIHdpdGggc3BlY3VsYXIgY29sb3IgdGV4dHVyZSkgaXMgbm90IHN1cHBvcnRlZCBzbyB3ZSB1c2UgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHZlY3RvciB0byBhcHByb3hpbWF0ZSBhIHNpbmd1bGFyIHNwZWN1bGFyIGZhY3Rvci5cclxuICAgICAgICBpZiAoX2FycmF5KVxyXG4gICAgICAgICAgcmV0dXJuIF9hcnJheS5yZWR1Y2UoKF9hLCBfYikgPT4gX2EgKyBfYikgLyBfYXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0VGV4dHVyZShfaW5kZXg6IG51bWJlcik6IFByb21pc2U8VGV4dHVyZT4ge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKF9yZXNvbHZlLCBfcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLiN0ZXh0dXJlcylcclxuICAgICAgICAgIHRoaXMuI3RleHR1cmVzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuI3RleHR1cmVzW19pbmRleF0pXHJcbiAgICAgICAgICByZXR1cm4gX3Jlc29sdmUodGhpcy4jdGV4dHVyZXNbX2luZGV4XSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZpZGVvRkJYOiBGQlguVmlkZW8gPSB0aGlzLmZieC5vYmplY3RzLnRleHR1cmVzW19pbmRleF0uY2hpbGRyZW5bMF07XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZTogVGV4dHVyZUltYWdlID0gbmV3IFRleHR1cmVJbWFnZSgpO1xyXG4gICAgICAgIHRleHR1cmUuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICB0ZXh0dXJlLmltYWdlLm9ubG9hZCA9ICgpID0+IF9yZXNvbHZlKHRleHR1cmUpO1xyXG4gICAgICAgIHRleHR1cmUuaW1hZ2Uub25lcnJvciA9IF9yZWplY3Q7XHJcbiAgICAgICAgdGV4dHVyZS5pbWFnZS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt2aWRlb0ZCWC5Db250ZW50XSwgeyB0eXBlOiBcImltYWdlL3BuZ1wiIH0pKTtcclxuICAgICAgICB0aGlzLiN0ZXh0dXJlc1tfaW5kZXhdID0gdGV4dHVyZTtcclxuICAgICAgICAvLyBUT0RPOiBnZXQgYW5kIHNldCBtaXBtYXAgaW5mb3JtYXRpb24gPz8/XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByb2JsZW06IG1laHJlcmUgRGVmb3JtZXIgdmVyd2Vpc2VuIGF1ZiBkYXMgc2VsYmUgU2tlbGV0dCBhYmVyIG51dHplbiBkYWJlaSBuaWNodCBpbW1lciBhbGxlIEtub2NoZW5cclxuICAgIC8vID0+IFByb2JsZW0gYmVzdGVodCBhdWNoIGltIEdMVEZMb2FkZXJcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmllZnMgdGhlIHNrZWxldG9uIGNvbnRhaW5pbmcgdGhlIGdpdmVuIGxpbWIgbm9kZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldFNrZWxldG9uKF9mYnhMaW1iTm9kZTogRkJYLk1vZGVsKTogUHJvbWlzZTxDb21wb25lbnRTa2VsZXRvbj4ge1xyXG4gICAgICBpZiAoIXRoaXMuI3NrZWxldG9ucylcclxuICAgICAgICB0aGlzLiNza2VsZXRvbnMgPSBbXTtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NrZWxldG9ucy5maW5kKF9za2VsZXRvbiA9PiBfZmJ4TGltYk5vZGUubmFtZSBpbiBfc2tlbGV0b24uYm9uZXMpIHx8IGF3YWl0IChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc2tlbGV0b246IENvbXBvbmVudFNrZWxldG9uID0gbmV3IENvbXBvbmVudFNrZWxldG9uKCk7IC8vIG5ldyBTa2VsZXRvbihgU2tlbGV0b24ke3RoaXMuI3NrZWxldG9ucy5sZW5ndGh9YCk7XHJcbiAgICAgICAgbGV0IHJvb3ROb2RlOiBGQlguTW9kZWwgPSBfZmJ4TGltYk5vZGU7XHJcbiAgICAgICAgd2hpbGUgKHJvb3ROb2RlLnBhcmVudHMgJiYgcm9vdE5vZGUucGFyZW50cy5zb21lKF9wYXJlbnQgPT4gX3BhcmVudC5zdWJ0eXBlID09IFwiTGltYk5vZGVcIikpXHJcbiAgICAgICAgICByb290Tm9kZSA9IHJvb3ROb2RlLnBhcmVudHMuZmluZChfcGFyZW50ID0+IF9wYXJlbnQuc3VidHlwZSA9PSBcIkxpbWJOb2RlXCIpO1xyXG4gICAgICAgIGNvbnN0IGlSb290Tm9kZTogbnVtYmVyID0gdGhpcy5mYngub2JqZWN0cy5tb2RlbHMuZmluZEluZGV4KF9tb2RlbCA9PiBfbW9kZWwubmFtZSA9PSByb290Tm9kZS5uYW1lKTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGF3YWl0IHRoaXMuZ2V0Tm9kZShpUm9vdE5vZGUpKSB7XHJcbiAgICAgICAgICAvLyBUT0RPOiBtYXliZSBtb3ZlIHRoaXMgaW50byB0aGUgY29tcG9uZW50LCBhcyB0aGlzIGlzIHByb2JhYmx5IG5lZWRlZCBpbiBnbHRmIGltcG9ydCBhc3dlbGxcclxuICAgICAgICAgIGlmICh0aGlzLmZieC5vYmplY3RzLm1vZGVsc1t0aGlzLiNub2Rlcy5pbmRleE9mKG5vZGUpXS5zdWJ0eXBlID09IFwiTGltYk5vZGVcIikge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnQ6IE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50KVxyXG4gICAgICAgICAgICAgIG5vZGUubXR4V29ybGQuY29weShcclxuICAgICAgICAgICAgICAgIG5vZGUuY21wVHJhbnNmb3JtID9cclxuICAgICAgICAgICAgICAgICAgTWF0cml4NHg0LlBST0RVQ1QocGFyZW50Lm10eFdvcmxkLCBub2RlLm10eExvY2FsKSA6XHJcbiAgICAgICAgICAgICAgICAgIHBhcmVudC5tdHhXb3JsZFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIG5vZGUubXR4V29ybGRJbnZlcnNlLmNvcHkoTWF0cml4NHg0LklOVkVSU0Uobm9kZS5tdHhXb3JsZCkpO1xyXG4gICAgICAgICAgICBza2VsZXRvbi5hZGRCb25lKG5vZGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy4jc2tlbGV0b25zLnB1c2goc2tlbGV0b24pO1xyXG4gICAgICAgIHJldHVybiBza2VsZXRvbjtcclxuICAgICAgfSkoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0QW5pbWF0aW9uKF9pbmRleDogbnVtYmVyKTogUHJvbWlzZTxBbmltYXRpb24+IHtcclxuICAgICAgaWYgKCF0aGlzLiNhbmltYXRpb25zKVxyXG4gICAgICAgIHRoaXMuI2FuaW1hdGlvbnMgPSBbXTtcclxuICAgICAgaWYgKCF0aGlzLiNhbmltYXRpb25zW19pbmRleF0pIHtcclxuICAgICAgICBjb25zdCBhbmltU3RhY2s6IEZCWC5PYmplY3QgPSB0aGlzLmZieC5vYmplY3RzLmFuaW1TdGFja3NbX2luZGV4XTtcclxuICAgICAgICBjb25zdCBhbmltTm9kZXNGQlg6IEZCWC5BbmltQ3VydmVOb2RlW10gPSBhbmltU3RhY2suY2hpbGRyZW5bMF0uY2hpbGRyZW47XHJcblxyXG4gICAgICAgIGxldCBmYnhBbmltTm9kZUdyb3VwZWQ6IE1hcDxGQlguTW9kZWwsIEZCWC5BbmltQ3VydmVOb2RlW10+ID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZmJ4QW5pbU5vZGUgb2YgYW5pbU5vZGVzRkJYKSB7XHJcbiAgICAgICAgICBjb25zdCBrZXk6IEZCWC5Nb2RlbCA9IGZieEFuaW1Ob2RlLnBhcmVudHMuZmluZChfcGFyZW50ID0+IF9wYXJlbnQudHlwZSA9PSBcIk1vZGVsXCIpO1xyXG4gICAgICAgICAgaWYgKGtleSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgaWYgKCFmYnhBbmltTm9kZUdyb3VwZWQuaGFzKGtleSkpXHJcbiAgICAgICAgICAgIGZieEFuaW1Ob2RlR3JvdXBlZC5zZXQoa2V5LCBbXSk7XHJcbiAgICAgICAgICBmYnhBbmltTm9kZUdyb3VwZWQuZ2V0KGtleSkucHVzaChmYnhBbmltTm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBhbmltYXRpb25TdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHt9O1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IFtmYnhNb2RlbCwgZmJ4QW5pbU5vZGVzXSBvZiBmYnhBbmltTm9kZUdyb3VwZWQpIHtcclxuICAgICAgICAgIGxldCBjdXJyZW50U3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSBhbmltYXRpb25TdHJ1Y3R1cmU7XHJcblxyXG4gICAgICAgICAgbGV0IHBhcmVudDogRkJYLk1vZGVsID0gZmJ4TW9kZWwucGFyZW50cy5maW5kKF9wYXJlbnQgPT4gX3BhcmVudC50eXBlID09IFwiTW9kZWxcIik7XHJcbiAgICAgICAgICBsZXQgcGF0aDogRkJYLk1vZGVsW10gPSBbXTtcclxuICAgICAgICAgIHBhdGgucHVzaChmYnhNb2RlbCk7XHJcbiAgICAgICAgICB3aGlsZSAocGFyZW50ICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBwYXRoLnB1c2gocGFyZW50KTtcclxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudHMuZmluZChfcGFyZW50ID0+IF9wYXJlbnQudHlwZSA9PSBcIk1vZGVsXCIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAoY29uc3QgZmJ4UGF0aE1vZGVsIG9mIHBhdGgucmV2ZXJzZSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RydWN0dXJlLmNoaWxkcmVuID09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlLmNoaWxkcmVuID0ge307XHJcblxyXG4gICAgICAgICAgICBpZiAoKGN1cnJlbnRTdHJ1Y3R1cmUuY2hpbGRyZW4gYXMgQW5pbWF0aW9uU3RydWN0dXJlKVtmYnhQYXRoTW9kZWwubmFtZV0gPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgIChjdXJyZW50U3RydWN0dXJlLmNoaWxkcmVuIGFzIEFuaW1hdGlvblN0cnVjdHVyZSlbZmJ4UGF0aE1vZGVsLm5hbWVdID0ge307XHJcbiAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmUgPSAoY3VycmVudFN0cnVjdHVyZS5jaGlsZHJlbiBhcyBBbmltYXRpb25TdHJ1Y3R1cmUpW2ZieFBhdGhNb2RlbC5uYW1lXSBhcyBBbmltYXRpb25TdHJ1Y3R1cmU7XHJcblxyXG4gICAgICAgICAgICBpZiAoZmJ4UGF0aE1vZGVsID09IGZieE1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgbXR4TG9jYWw6IEFuaW1hdGlvblNlcXVlbmNlTWF0cml4NHg0ID0ge307XHJcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBmYnhBbmltTm9kZSBvZiBmYnhBbmltTm9kZXMpXHJcbiAgICAgICAgICAgICAgICBtdHhMb2NhbFt7XHJcbiAgICAgICAgICAgICAgICAgIFQ6IFwidHJhbnNsYXRpb25cIixcclxuICAgICAgICAgICAgICAgICAgUjogXCJyb3RhdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgICBTOiBcInNjYWxlXCJcclxuICAgICAgICAgICAgICAgIH1bZmJ4QW5pbU5vZGUubmFtZV1dID0gdGhpcy5nZXRBbmltYXRpb25WZWN0b3IzKGZieEFuaW1Ob2RlLCBmYnhQYXRoTW9kZWwpO1xyXG4gICAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmUuY29tcG9uZW50cyA9IHtcclxuICAgICAgICAgICAgICAgIENvbXBvbmVudFRyYW5zZm9ybTogW1xyXG4gICAgICAgICAgICAgICAgICB7IG10eExvY2FsOiBtdHhMb2NhbCB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy4jYW5pbWF0aW9uc1tfaW5kZXhdID0gbmV3IEFuaW1hdGlvbihhbmltU3RhY2submFtZSwgYW5pbWF0aW9uU3RydWN0dXJlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy4jYW5pbWF0aW9uc1tfaW5kZXhdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZmV0Y2hlZCBmcm9tIHRocmVlLmpzLCBhZGFwdGVkIHRvIEZVREdFIGFuZCBvcHRpbWl6ZWRcclxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi9kZXYvZXhhbXBsZXMvanNtL2xvYWRlcnMvRkJYTG9hZGVyLmpzXHJcbiAgICAgKiBsaW5lIDM5NTBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZVRyYW5zZm9ybShfbW9kZWxGQlg6IEZCWC5Nb2RlbCwgX25vZGU6IE5vZGUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgY29uc3QgcGFyZW50SW5kZXg6IG51bWJlciA9IHRoaXMuZmJ4Lm9iamVjdHMubW9kZWxzLmluZGV4T2YoX21vZGVsRkJYLnBhcmVudHMuZmluZChfcGFyZW50ID0+IF9wYXJlbnQudHlwZSA9PSBcIk1vZGVsXCIpKTtcclxuICAgICAgY29uc3QgcGFyZW50OiBOb2RlID0gcGFyZW50SW5kZXggPj0gMCA/IGF3YWl0IHRoaXMuZ2V0Tm9kZShwYXJlbnRJbmRleCkgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICBjb25zdCBtdHhMb2NhbFJvdGF0aW9uOiBNYXRyaXg0eDQgPSBfbW9kZWxGQlguUHJlUm90YXRpb24gfHwgX21vZGVsRkJYLkxjbFJvdGF0aW9uIHx8IF9tb2RlbEZCWC5Qb3N0Um90YXRpb24gP1xyXG4gICAgICAgIE1hdHJpeDR4NC5JREVOVElUWSgpIDpcclxuICAgICAgICB1bmRlZmluZWQ7XHJcbiAgICAgIGlmIChfbW9kZWxGQlguUHJlUm90YXRpb24pIHtcclxuICAgICAgICBtdHhMb2NhbFJvdGF0aW9uLnJvdGF0ZSh0aGlzLmdldE9yZGVyZWQoX21vZGVsRkJYLlByZVJvdGF0aW9uLCBfbW9kZWxGQlgpKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoX21vZGVsRkJYLkxjbFJvdGF0aW9uKSB7XHJcbiAgICAgICAgbXR4TG9jYWxSb3RhdGlvbi5yb3RhdGUodGhpcy5nZXRPcmRlcmVkKHRoaXMuZ2V0VHJhbnNmb3JtVmVjdG9yKF9tb2RlbEZCWC5MY2xSb3RhdGlvbiwgVmVjdG9yMy5aRVJPKSwgX21vZGVsRkJYKSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF9tb2RlbEZCWC5Qb3N0Um90YXRpb24pIHtcclxuICAgICAgICBsZXQgbXR4UG9zdFJvdGF0aW9uSW52ZXJzZTogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJPVEFUSU9OKHRoaXMuZ2V0T3JkZXJlZChfbW9kZWxGQlguUG9zdFJvdGF0aW9uLCBfbW9kZWxGQlgpKTtcclxuICAgICAgICBtdHhQb3N0Um90YXRpb25JbnZlcnNlID0gTWF0cml4NHg0LklOVkVSU0UobXR4UG9zdFJvdGF0aW9uSW52ZXJzZSk7XHJcbiAgICAgICAgbXR4TG9jYWxSb3RhdGlvbi5tdWx0aXBseShtdHhQb3N0Um90YXRpb25JbnZlcnNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbXR4TG9jYWxTY2FsaW5nOiBNYXRyaXg0eDQgPSBfbW9kZWxGQlguTGNsU2NhbGluZyA/XHJcbiAgICAgICAgTWF0cml4NHg0LlNDQUxJTkcodGhpcy5nZXRUcmFuc2Zvcm1WZWN0b3IoX21vZGVsRkJYLkxjbFNjYWxpbmcsIFZlY3RvcjMuT05FKSkgOlxyXG4gICAgICAgIHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIGNvbnN0IG10eFBhcmVudFdvcmxkUm90YXRpb246IE1hdHJpeDR4NCA9IHBhcmVudCA/IE1hdHJpeDR4NC5ST1RBVElPTihwYXJlbnQubXR4V29ybGQucm90YXRpb24pIDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgY29uc3QgbXR4UGFyZW50V29ybGRTY2FsZTogTWF0cml4NHg0ID0gcGFyZW50ID8gKCgpID0+IHtcclxuICAgICAgICBjb25zdCBtdHhQYXJlbnRXb3JsZFNjYWxlOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSU5WRVJTRShtdHhQYXJlbnRXb3JsZFJvdGF0aW9uKTtcclxuICAgICAgICBtdHhQYXJlbnRXb3JsZFNjYWxlLnRyYW5zbGF0ZShWZWN0b3IzLlNDQUxFKHBhcmVudC5tdHhXb3JsZC50cmFuc2xhdGlvbiwgLTEpKTtcclxuICAgICAgICBtdHhQYXJlbnRXb3JsZFNjYWxlLm11bHRpcGx5KHBhcmVudC5tdHhXb3JsZCk7XHJcbiAgICAgICAgcmV0dXJuIG10eFBhcmVudFdvcmxkU2NhbGU7XHJcbiAgICAgIH0pKCkgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICBjb25zdCBtdHhXb3JsZFJvdGF0aW9uU2NhbGU6IE1hdHJpeDR4NCA9IHBhcmVudCB8fCBtdHhMb2NhbFJvdGF0aW9uIHx8IG10eExvY2FsU2NhbGluZyA/IE1hdHJpeDR4NC5JREVOVElUWSgpIDogdW5kZWZpbmVkO1xyXG4gICAgICBpZiAocGFyZW50IHx8IG10eExvY2FsUm90YXRpb24gfHwgbXR4TG9jYWxTY2FsaW5nKSB7XHJcbiAgICAgICAgY29uc3QgaW5oZXJpdFR5cGU6IG51bWJlciA9IF9tb2RlbEZCWC5Jbmhlcml0VHlwZSB8fCAwO1xyXG4gICAgICAgIGlmIChpbmhlcml0VHlwZSA9PSAwKSB7XHJcbiAgICAgICAgICBpZiAocGFyZW50KVxyXG4gICAgICAgICAgICBtdHhXb3JsZFJvdGF0aW9uU2NhbGUubXVsdGlwbHkobXR4UGFyZW50V29ybGRSb3RhdGlvbik7XHJcbiAgICAgICAgICBpZiAobXR4TG9jYWxSb3RhdGlvbilcclxuICAgICAgICAgICAgbXR4V29ybGRSb3RhdGlvblNjYWxlLm11bHRpcGx5KG10eExvY2FsUm90YXRpb24pO1xyXG4gICAgICAgICAgaWYgKHBhcmVudClcclxuICAgICAgICAgICAgbXR4V29ybGRSb3RhdGlvblNjYWxlLm11bHRpcGx5KG10eFBhcmVudFdvcmxkU2NhbGUpO1xyXG4gICAgICAgICAgaWYgKG10eExvY2FsU2NhbGluZylcclxuICAgICAgICAgICAgbXR4V29ybGRSb3RhdGlvblNjYWxlLm11bHRpcGx5KG10eExvY2FsU2NhbGluZyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpbmhlcml0VHlwZSA9PSAxKSB7XHJcbiAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIG10eFdvcmxkUm90YXRpb25TY2FsZS5tdWx0aXBseShtdHhQYXJlbnRXb3JsZFJvdGF0aW9uKTtcclxuICAgICAgICAgICAgbXR4V29ybGRSb3RhdGlvblNjYWxlLm11bHRpcGx5KG10eFBhcmVudFdvcmxkU2NhbGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG10eExvY2FsUm90YXRpb24pXHJcbiAgICAgICAgICAgIG10eFdvcmxkUm90YXRpb25TY2FsZS5tdWx0aXBseShtdHhMb2NhbFJvdGF0aW9uKTtcclxuICAgICAgICAgIGlmIChtdHhMb2NhbFNjYWxpbmcpXHJcbiAgICAgICAgICAgIG10eFdvcmxkUm90YXRpb25TY2FsZS5tdWx0aXBseShtdHhMb2NhbFNjYWxpbmcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAocGFyZW50KVxyXG4gICAgICAgICAgICBtdHhXb3JsZFJvdGF0aW9uU2NhbGUubXVsdGlwbHkobXR4UGFyZW50V29ybGRSb3RhdGlvbik7XHJcbiAgICAgICAgICBpZiAobXR4TG9jYWxSb3RhdGlvbilcclxuICAgICAgICAgICAgbXR4V29ybGRSb3RhdGlvblNjYWxlLm11bHRpcGx5KG10eExvY2FsUm90YXRpb24pO1xyXG4gICAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICBtdHhXb3JsZFJvdGF0aW9uU2NhbGUubXVsdGlwbHkobXR4UGFyZW50V29ybGRTY2FsZSk7XHJcbiAgICAgICAgICAgIGxldCBtdHhQYXJlbnRMb2NhbFNjYWxpbmdJbnZlcnNlOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuU0NBTElORyhwYXJlbnQubXR4TG9jYWwuc2NhbGluZyk7XHJcbiAgICAgICAgICAgIG10eFBhcmVudExvY2FsU2NhbGluZ0ludmVyc2UgPSBNYXRyaXg0eDQuSU5WRVJTRShtdHhQYXJlbnRMb2NhbFNjYWxpbmdJbnZlcnNlKTtcclxuICAgICAgICAgICAgbXR4V29ybGRSb3RhdGlvblNjYWxlLm11bHRpcGx5KG10eFBhcmVudExvY2FsU2NhbGluZ0ludmVyc2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG10eExvY2FsU2NhbGluZylcclxuICAgICAgICAgICAgbXR4V29ybGRSb3RhdGlvblNjYWxlLm11bHRpcGx5KG10eExvY2FsU2NhbGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGxvY2FsIHRyYW5zZm9ybSBtYXRyaXhcclxuICAgICAgbGV0IHRyYW5zbGF0aW9uOiBWZWN0b3IzO1xyXG4gICAgICB0cmFuc2xhdGlvbiA9IFZlY3RvcjMuWkVSTygpO1xyXG4gICAgICBpZiAoX21vZGVsRkJYLkxjbFRyYW5zbGF0aW9uKVxyXG4gICAgICAgIHRyYW5zbGF0aW9uLmFkZCh0aGlzLmdldFRyYW5zZm9ybVZlY3RvcihfbW9kZWxGQlguTGNsVHJhbnNsYXRpb24sIFZlY3RvcjMuWkVSTykpO1xyXG4gICAgICBpZiAoX21vZGVsRkJYLlJvdGF0aW9uT2Zmc2V0KVxyXG4gICAgICAgIHRyYW5zbGF0aW9uLmFkZChfbW9kZWxGQlguUm90YXRpb25PZmZzZXQpO1xyXG4gICAgICBpZiAoX21vZGVsRkJYLlJvdGF0aW9uUGl2b3QpXHJcbiAgICAgICAgdHJhbnNsYXRpb24uYWRkKF9tb2RlbEZCWC5Sb3RhdGlvblBpdm90KTtcclxuXHJcbiAgICAgIGNvbnN0IG10eFRyYW5zZm9ybTogTWF0cml4NHg0ID0gTWF0cml4NHg0LlRSQU5TTEFUSU9OKHRyYW5zbGF0aW9uKTtcclxuICAgICAgaWYgKG10eExvY2FsUm90YXRpb24pXHJcbiAgICAgICAgbXR4VHJhbnNmb3JtLm11bHRpcGx5KG10eExvY2FsUm90YXRpb24pO1xyXG5cclxuICAgICAgdHJhbnNsYXRpb24gPSBWZWN0b3IzLlpFUk8oKTtcclxuICAgICAgaWYgKF9tb2RlbEZCWC5Sb3RhdGlvblBpdm90KVxyXG4gICAgICAgIHRyYW5zbGF0aW9uLnN1YnRyYWN0KF9tb2RlbEZCWC5Sb3RhdGlvblBpdm90KTtcclxuICAgICAgaWYgKF9tb2RlbEZCWC5TY2FsaW5nT2Zmc2V0KVxyXG4gICAgICAgIHRyYW5zbGF0aW9uLmFkZChfbW9kZWxGQlguU2NhbGluZ09mZnNldCk7XHJcbiAgICAgIGlmIChfbW9kZWxGQlguU2NhbGluZ1Bpdm90KVxyXG4gICAgICAgIHRyYW5zbGF0aW9uLmFkZChfbW9kZWxGQlguU2NhbGluZ1Bpdm90KTtcclxuICAgICAgbXR4VHJhbnNmb3JtLnRyYW5zbGF0ZSh0cmFuc2xhdGlvbik7XHJcblxyXG4gICAgICBpZiAobXR4TG9jYWxTY2FsaW5nKVxyXG4gICAgICAgIG10eFRyYW5zZm9ybS5tdWx0aXBseShtdHhMb2NhbFNjYWxpbmcpO1xyXG4gICAgICBpZiAoX21vZGVsRkJYLlNjYWxpbmdQaXZvdClcclxuICAgICAgICBtdHhUcmFuc2Zvcm0udHJhbnNsYXRlKFZlY3RvcjMuU0NBTEUoX21vZGVsRkJYLlNjYWxpbmdQaXZvdCwgLTEpKTtcclxuXHJcbiAgICAgIGNvbnN0IG10eFdvcmxkVHJhbnNsYXRpb246IE1hdHJpeDR4NCA9IHBhcmVudCA/XHJcbiAgICAgICAgTWF0cml4NHg0LlRSQU5TTEFUSU9OKE1hdHJpeDR4NC5QUk9EVUNUKFxyXG4gICAgICAgICAgcGFyZW50Lm10eFdvcmxkLFxyXG4gICAgICAgICAgTWF0cml4NHg0LlRSQU5TTEFUSU9OKG10eFRyYW5zZm9ybS50cmFuc2xhdGlvbilcclxuICAgICAgICApLnRyYW5zbGF0aW9uKSA6XHJcbiAgICAgICAgTWF0cml4NHg0LlRSQU5TTEFUSU9OKG10eFRyYW5zZm9ybS50cmFuc2xhdGlvbik7XHJcblxyXG4gICAgICBtdHhUcmFuc2Zvcm0uY29weShtdHhXb3JsZFRyYW5zbGF0aW9uKTtcclxuICAgICAgbXR4VHJhbnNmb3JtLm11bHRpcGx5KG10eFdvcmxkUm90YXRpb25TY2FsZSk7XHJcbiAgICAgIF9ub2RlLm10eFdvcmxkLmNvcHkobXR4VHJhbnNmb3JtKTtcclxuXHJcbiAgICAgIGlmIChwYXJlbnQpXHJcbiAgICAgICAgbXR4VHJhbnNmb3JtLm11bHRpcGx5KE1hdHJpeDR4NC5JTlZFUlNFKHBhcmVudC5tdHhXb3JsZCksIHRydWUpO1xyXG4gICAgICBfbm9kZS5hZGRDb21wb25lbnQobmV3IENvbXBvbmVudFRyYW5zZm9ybShtdHhUcmFuc2Zvcm0pKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFRyYW5zZm9ybVZlY3RvcihfdmVjdG9yOiBWZWN0b3IzIHwgRkJYLkFuaW1DdXJ2ZU5vZGUsIF9kZWZhdWx0OiAoKSA9PiBWZWN0b3IzKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgX3ZlY3RvciA9PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgX2RlZmF1bHQoKSA6XHJcbiAgICAgICAgICBfdmVjdG9yIGluc3RhbmNlb2YgVmVjdG9yMyA/XHJcbiAgICAgICAgICAgIF92ZWN0b3IgOlxyXG4gICAgICAgICAgICBuZXcgVmVjdG9yMyhcclxuICAgICAgICAgICAgICB0eXBlb2YgKF92ZWN0b3IgPSBfdmVjdG9yLmxvYWQoKSkuZFggPT0gXCJudW1iZXJcIiA/XHJcbiAgICAgICAgICAgICAgICBfdmVjdG9yLmRYIDpcclxuICAgICAgICAgICAgICAgIChfdmVjdG9yLmRYLmxvYWQoKSBhcyBGQlguQW5pbUN1cnZlKS5EZWZhdWx0LFxyXG4gICAgICAgICAgICAgIHR5cGVvZiBfdmVjdG9yLmRZID09IFwibnVtYmVyXCIgP1xyXG4gICAgICAgICAgICAgICAgX3ZlY3Rvci5kWSA6XHJcbiAgICAgICAgICAgICAgICAoX3ZlY3Rvci5kWS5sb2FkKCkgYXMgRkJYLkFuaW1DdXJ2ZSkuRGVmYXVsdCxcclxuICAgICAgICAgICAgICB0eXBlb2YgX3ZlY3Rvci5kWiA9PSBcIm51bWJlclwiID9cclxuICAgICAgICAgICAgICAgIF92ZWN0b3IuZFogOlxyXG4gICAgICAgICAgICAgICAgKF92ZWN0b3IuZFoubG9hZCgpIGFzIEZCWC5BbmltQ3VydmUpLkRlZmF1bHRcclxuICAgICAgICAgICAgKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0QW5pbWF0aW9uVmVjdG9yMyhfYW5pbU5vZGU6IEZCWC5BbmltQ3VydmVOb2RlLCBfdGFyZ2V0OiBGQlguTW9kZWwpOiBBbmltYXRpb25TZXF1ZW5jZVZlY3RvcjMge1xyXG4gICAgICBjb25zdCB2ZWN0b3JTZXF1ZW5jZTogQW5pbWF0aW9uU2VxdWVuY2VWZWN0b3IzID0ge307XHJcbiAgICAgIGZvciAoY29uc3QgdmFsdWVOYW1lIGluIF9hbmltTm9kZSkgaWYgKHZhbHVlTmFtZSA9PSBcImRYXCIgfHwgdmFsdWVOYW1lID09IFwiZFlcIiB8fCB2YWx1ZU5hbWUgPT0gXCJkWlwiKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWU6IEZCWC5BbmltQ3VydmUgfCBudW1iZXIgPSBfYW5pbU5vZGVbdmFsdWVOYW1lXTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgIGNvbnN0IHNlcXVlbmNlOiBBbmltYXRpb25TZXF1ZW5jZSA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZSgpO1xyXG4gICAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHZhbHVlLktleVRpbWUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSByZWZlcmVuY2UgdGltZSBpcyBkZWZpbmVkIGFzIGEgc2lnbmVkIGludDY0LCB1bml0IGJlaW5nIDEvNDYxODYxNTgwMDAgc2Vjb25kc1xyXG4gICAgICAgICAgICAvLyByZWY6IGh0dHBzOi8vYXJjaGl2ZS5ibGVuZGVyLm9yZy93aWtpL2luZGV4LnBocC9Vc2VyOk1vbnQyOS9Gb3VuZGF0aW9uL0ZCWF9GaWxlX1N0cnVjdHVyZS8jU29tZV9TcGVjaWZpY19Qcm9wZXJ0eV9UeXBlc1xyXG4gICAgICAgICAgICBzZXF1ZW5jZS5hZGRLZXkobmV3IEFuaW1hdGlvbktleShcclxuICAgICAgICAgICAgICBOdW1iZXIoKHZhbHVlLktleVRpbWVbaV0gLSB2YWx1ZS5LZXlUaW1lLnJlZHVjZSgoX21pbiwgX3YpID0+IF92IDwgX21pbiA/IF92IDogX21pbikpIC8gQmlnSW50KFwiNDYxODYxNThcIikpLFxyXG4gICAgICAgICAgICAgIHZhbHVlLktleVZhbHVlRmxvYXRbaV1cclxuICAgICAgICAgICAgKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2ZWN0b3JTZXF1ZW5jZVt2YWx1ZU5hbWVbMV0udG9Mb3dlckNhc2UoKV0gPSBzZXF1ZW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChfYW5pbU5vZGUubmFtZSA9PSBcIlJcIiAmJiAoX3RhcmdldC5QcmVSb3RhdGlvbiB8fCBfdGFyZ2V0LlBvc3RSb3RhdGlvbikpIHtcclxuICAgICAgICBsZXQgcHJlUm90b3RhdGlvbjogTWF0cml4NHg0O1xyXG4gICAgICAgIGlmIChfdGFyZ2V0LlByZVJvdGF0aW9uKVxyXG4gICAgICAgICAgcHJlUm90b3RhdGlvbiA9IE1hdHJpeDR4NC5ST1RBVElPTihfdGFyZ2V0LlByZVJvdGF0aW9uKTtcclxuICAgICAgICBsZXQgcG9zdFJvdGF0aW9uOiBNYXRyaXg0eDQ7XHJcbiAgICAgICAgaWYgKF90YXJnZXQuUG9zdFJvdGF0aW9uKVxyXG4gICAgICAgICAgcG9zdFJvdGF0aW9uID0gTWF0cml4NHg0LlJPVEFUSU9OKF90YXJnZXQuUG9zdFJvdGF0aW9uKTtcclxuXHJcbiAgICAgICAgW3ZlY3RvclNlcXVlbmNlLngsIHZlY3RvclNlcXVlbmNlLnksIHZlY3RvclNlcXVlbmNlLnpdXHJcbiAgICAgICAgICAuZmxhdE1hcChfc2VxID0+IF9zZXE/LmdldEtleXMoKSlcclxuICAgICAgICAgIC5tYXAoX2tleSA9PiBfa2V5Py50aW1lKVxyXG4gICAgICAgICAgLnNvcnQoKF90aW1lQSwgX3RpbWVCKSA9PiBfdGltZUEgLSBfdGltZUIpIC8vIHNvcnQgdGltZXNcclxuICAgICAgICAgIC5maWx0ZXIoKF90aW1lLCBfaW5kZXgsIF90aW1lcykgPT4gX3RpbWUgIT0gX3RpbWVzW19pbmRleCArIDFdKSAvLyByZW1vdmUgZHVwbGljYXRlc1xyXG4gICAgICAgICAgLm1hcChfdGltZSA9PiB7IC8vIGZpbmQga2V5cyBmb3IgYWxsIGF4ZXMgYXQgdGltZVxyXG4gICAgICAgICAgICByZXR1cm4geyB4OiBmaW5kS2V5KHZlY3RvclNlcXVlbmNlLngpLCB5OiBmaW5kS2V5KHZlY3RvclNlcXVlbmNlLnkpLCB6OiBmaW5kS2V5KHZlY3RvclNlcXVlbmNlLnopIH07XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRLZXkoX3NlcXVlbmNlOiBBbmltYXRpb25TZXF1ZW5jZSk6IEFuaW1hdGlvbktleSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIF9zZXF1ZW5jZT8uZ2V0S2V5cygpLmZpbmQoX2tleSA9PiBfa2V5LnRpbWUgPT0gX3RpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLmZvckVhY2goX2ZyYW1lID0+IHtcclxuICAgICAgICAgICAgbGV0IHZjdEV1bGVyQW5nbGVzOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICAgICAgICB2Y3RFdWxlckFuZ2xlcy5zZXQoXHJcbiAgICAgICAgICAgICAgX2ZyYW1lLng/LnZhbHVlID8/IDAsXHJcbiAgICAgICAgICAgICAgX2ZyYW1lLnk/LnZhbHVlID8/IDAsXHJcbiAgICAgICAgICAgICAgX2ZyYW1lLno/LnZhbHVlID8/IDBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgY29uc3QgbXR4Um90YXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTih2Y3RFdWxlckFuZ2xlcyk7XHJcbiAgICAgICAgICAgIGlmIChwcmVSb3RvdGF0aW9uKVxyXG4gICAgICAgICAgICAgIG10eFJvdGF0aW9uLm11bHRpcGx5KHByZVJvdG90YXRpb24sIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAocG9zdFJvdGF0aW9uKVxyXG4gICAgICAgICAgICAgIG10eFJvdGF0aW9uLm11bHRpcGx5KHBvc3RSb3RhdGlvbik7XHJcbiAgICAgICAgICAgIHZjdEV1bGVyQW5nbGVzID0gbXR4Um90YXRpb24ucm90YXRpb247XHJcbiAgICAgICAgICAgIGlmIChfZnJhbWUueClcclxuICAgICAgICAgICAgICBfZnJhbWUueC52YWx1ZSA9IHZjdEV1bGVyQW5nbGVzLng7XHJcbiAgICAgICAgICAgIGlmIChfZnJhbWUueSlcclxuICAgICAgICAgICAgICBfZnJhbWUueS52YWx1ZSA9IHZjdEV1bGVyQW5nbGVzLnk7XHJcbiAgICAgICAgICAgIGlmIChfZnJhbWUueilcclxuICAgICAgICAgICAgICBfZnJhbWUuei52YWx1ZSA9IHZjdEV1bGVyQW5nbGVzLno7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHZlY3RvclNlcXVlbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0T3JkZXJlZChfcm90YXRpb246IFZlY3RvcjMsIF9tb2RlbEZCWDogRkJYLk1vZGVsKTogVmVjdG9yMyB7XHJcbiAgICAgIGlmICghX21vZGVsRkJYLkV1bGVyT3JkZXIpXHJcbiAgICAgICAgcmV0dXJuIF9yb3RhdGlvbjtcclxuXHJcbiAgICAgIGNvbnN0IGRhdGE6IEZsb2F0MzJBcnJheSA9IF9yb3RhdGlvbi5nZXQoKTtcclxuICAgICAgY29uc3QgcmVzdWx0OiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICByZXN1bHQuc2V0KFxyXG4gICAgICAgIGRhdGFbX21vZGVsRkJYLkV1bGVyT3JkZXIuaW5kZXhPZihcIlpcIildLFxyXG4gICAgICAgIGRhdGFbX21vZGVsRkJYLkV1bGVyT3JkZXIuaW5kZXhPZihcIllcIildLFxyXG4gICAgICAgIGRhdGFbX21vZGVsRkJYLkV1bGVyT3JkZXIuaW5kZXhPZihcIlhcIildXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGQlgge1xyXG4gIC8qKlxyXG4gICAqIEludGVyZmFjZSB0byByZXByZXNlbnQgZmJ4LW5vZGVzIGNvbnRhaW5pbmcgaXRzIG5hbWUsIGNoaWxkcmVuIGFuZCBwcm9wZXJ0aWVzLlxyXG4gICAqIENoaWxkcmVuIGFuZCBwcm9wZXJpdGVzIGFyZSBsYXp5LlxyXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTm9kZSB7XHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG4gICAgXHJcbiAgICBwcml2YXRlIGxvYWRQcm9wZXJ0aWVzOiAoKSA9PiBOb2RlUHJvcGVydHlbXTtcclxuICAgIHByaXZhdGUgbG9hZENoaWxkcmVuOiAoKSA9PiBOb2RlW107XHJcbiAgICBcclxuICAgICNjaGlsZHJlbjogTm9kZVtdO1xyXG4gICAgI3Byb3BlcnRpZXM6IE5vZGVQcm9wZXJ0eVtdO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfbG9hZFByb3BlcnRpZXM6ICgpID0+IE5vZGVQcm9wZXJ0eVtdLCBfbG9hZENoaWxkcmVuOiAoKSA9PiBOb2RlW10pIHtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMubG9hZFByb3BlcnRpZXMgPSBfbG9hZFByb3BlcnRpZXM7XHJcbiAgICAgIHRoaXMubG9hZENoaWxkcmVuID0gX2xvYWRDaGlsZHJlbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHByb3BlcnRpZXMoKTogTm9kZVByb3BlcnR5W10ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcHJvcGVydGllcyB8fCAodGhpcy4jcHJvcGVydGllcyA9IHRoaXMubG9hZFByb3BlcnRpZXMoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBjaGlsZHJlbigpOiBOb2RlW10ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY2hpbGRyZW4gfHwgKHRoaXMuI2NoaWxkcmVuID0gdGhpcy5sb2FkQ2hpbGRyZW4oKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgdHlwZSBQcm9wZXJ0eTcwID0gYm9vbGVhbiB8IG51bWJlciB8IHN0cmluZyB8IEZ1ZGdlQ29yZS5WZWN0b3IzO1xyXG5cclxuICBleHBvcnQgdHlwZSBOb2RlUHJvcGVydHkgPSBib29sZWFuIHwgbnVtYmVyIHwgc3RyaW5nIHwgVWludDhBcnJheSB8IFVpbnQxNkFycmF5IHwgRmxvYXQzMkFycmF5O1xyXG5cclxuICBleHBvcnQgZW51bSBBUlJBWV9FTkNPRElORyB7XHJcbiAgICBVTkNPTVBSRVNTRUQsIENPTVBSRVNTRURcclxuICB9XHJcbiAgXHJcbn0iLCJuYW1lc3BhY2UgRkJYIHtcclxuICAvKipcclxuICAgKiBMb2FkcyBhbiBmYnggZmlsZSBmcm9tIGl0cyBmYngtbm9kZSBhcnJheSB3aGljaCBtYXkgYmUgcmV0cmlldmVkIGJ5IHBhcnNlTm9kZXNGcm9tQmluYXJ5LlxyXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgZnVuY3Rpb24gbG9hZEZyb21Ob2Rlcyhfbm9kZXM6IE5vZGVbXSk6IEZCWCB7XHJcbiAgICBjb25zdCBmYng6IEZCWCA9IHtcclxuICAgICAgZG9jdW1lbnRzOiB1bmRlZmluZWQsXHJcbiAgICAgIG9iamVjdHM6IHtcclxuICAgICAgICBhbGw6IHVuZGVmaW5lZCxcclxuICAgICAgICBtb2RlbHM6IFtdLFxyXG4gICAgICAgIGdlb21ldHJpZXM6IFtdLFxyXG4gICAgICAgIG1hdGVyaWFsczogW10sXHJcbiAgICAgICAgcG9zZXM6IFtdLFxyXG4gICAgICAgIHRleHR1cmVzOiBbXSxcclxuICAgICAgICBhbmltU3RhY2tzOiBbXVxyXG4gICAgICB9LFxyXG4gICAgICBjb25uZWN0aW9uczogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBfbm9kZXMpIHtcclxuICAgICAgaWYgKG5vZGUubmFtZSA9PSBcIkRvY3VtZW50c1wiKVxyXG4gICAgICAgIGZieC5kb2N1bWVudHMgPSBub2RlLmNoaWxkcmVuXHJcbiAgICAgICAgICAuZmlsdGVyKF9kb2N1bWVudE5vZGUgPT4gX2RvY3VtZW50Tm9kZS5uYW1lID09IFwiRG9jdW1lbnRcIilcclxuICAgICAgICAgIC5tYXAoX2RvY3VtZW50Tm9kZSA9PiBnZXREb2N1bWVudChfZG9jdW1lbnROb2RlKSk7XHJcbiAgICAgIGVsc2UgaWYgKG5vZGUubmFtZSA9PSBcIk9iamVjdHNcIilcclxuICAgICAgICBmYngub2JqZWN0cy5hbGwgPSBub2RlLmNoaWxkcmVuLm1hcChfb2JqZWN0Tm9kZSA9PiBnZXRPYmplY3QoX29iamVjdE5vZGUsIGZieCkpO1xyXG4gICAgICBlbHNlIGlmIChub2RlLm5hbWUgPT0gXCJDb25uZWN0aW9uc1wiKVxyXG4gICAgICAgIGZieC5jb25uZWN0aW9ucyA9IG5vZGUuY2hpbGRyZW4ubWFwKF9jb25uZWN0aW9uTm9kZSA9PiBnZXRDb25uZWN0aW9uKF9jb25uZWN0aW9uTm9kZSkpO1xyXG4gICAgICBpZiAoZmJ4LmRvY3VtZW50cyAmJiBmYngub2JqZWN0cy5hbGwgJiYgZmJ4LmNvbm5lY3Rpb25zKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIGdyb3VwT2JqZWN0cyhmYngpO1xyXG4gICAgYXBwbHlDb25uZWN0aW9ucyhmYnguY29ubmVjdGlvbnMsIGZieC5kb2N1bWVudHMsIGZieC5vYmplY3RzLmFsbCk7XHJcblxyXG4gICAgcmV0dXJuIGZieDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldERvY3VtZW50KF9ub2RlOiBOb2RlKTogRG9jdW1lbnQge1xyXG4gICAgY29uc3QgZG9jdW1lbnQ6IE9iamVjdCA9IHtcclxuICAgICAgdWlkOiBfbm9kZS5wcm9wZXJ0aWVzWzBdIGFzIG51bWJlcixcclxuICAgICAgbmFtZTogX25vZGUucHJvcGVydGllc1syXSBhcyBzdHJpbmcsXHJcbiAgICAgIGxvYWRlZDogZmFsc2UsXHJcbiAgICAgIGxvYWQ6ICgpID0+IGxvYWRPYmplY3RQcm9wZXJ0aWVzKF9ub2RlLCBkb2N1bWVudClcclxuICAgIH07XHJcbiAgICByZXR1cm4gZG9jdW1lbnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRPYmplY3QoX25vZGU6IE5vZGUsIF9mYng6IEZCWCk6IE9iamVjdCB7XHJcbiAgICBjb25zdCBuYW1lQW5kVHlwZTogc3RyaW5nW10gPSAoX25vZGUucHJvcGVydGllc1sxXSBhcyBzdHJpbmcpLnNwbGl0KFwiOjpcIik7XHJcbiAgICBjb25zdCBvYmplY3Q6IE9iamVjdCA9IHtcclxuICAgICAgdWlkOiBfbm9kZS5wcm9wZXJ0aWVzWzBdIGFzIG51bWJlcixcclxuICAgICAgbmFtZTogbmFtZUFuZFR5cGVbMF0sXHJcbiAgICAgIHR5cGU6IG5hbWVBbmRUeXBlWzFdLFxyXG4gICAgICBzdWJ0eXBlOiBfbm9kZS5wcm9wZXJ0aWVzWzJdIGFzIHN0cmluZyxcclxuICAgICAgbG9hZGVkOiBmYWxzZSxcclxuICAgICAgbG9hZDogKCkgPT4gbG9hZE9iamVjdFByb3BlcnRpZXMoX25vZGUsIG9iamVjdClcclxuICAgIH07XHJcbiAgICByZXR1cm4gb2JqZWN0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ3JvdXBPYmplY3RzKF9mYng6IEZCWCk6IHZvaWQge1xyXG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgX2ZieC5vYmplY3RzLmFsbCkge1xyXG4gICAgICBpZiAob2JqZWN0LnR5cGUgPT0gXCJNb2RlbFwiKVxyXG4gICAgICAgIF9mYngub2JqZWN0cy5tb2RlbHMucHVzaChvYmplY3QpO1xyXG4gICAgICBlbHNlIGlmIChvYmplY3QudHlwZSA9PSBcIkdlb21ldHJ5XCIpXHJcbiAgICAgICAgX2ZieC5vYmplY3RzLmdlb21ldHJpZXMucHVzaChvYmplY3QpO1xyXG4gICAgICBlbHNlIGlmIChvYmplY3QudHlwZSA9PSBcIk1hdGVyaWFsXCIpXHJcbiAgICAgICAgX2ZieC5vYmplY3RzLm1hdGVyaWFscy5wdXNoKG9iamVjdCk7XHJcbiAgICAgIGVsc2UgaWYgKG9iamVjdC50eXBlID09IFwiUG9zZVwiKVxyXG4gICAgICAgIF9mYngub2JqZWN0cy5wb3Nlcy5wdXNoKG9iamVjdCk7XHJcbiAgICAgIGVsc2UgaWYgKG9iamVjdC50eXBlID09IFwiVGV4dHVyZVwiKVxyXG4gICAgICAgIF9mYngub2JqZWN0cy50ZXh0dXJlcy5wdXNoKG9iamVjdCk7XHJcbiAgICAgIGVsc2UgaWYgKG9iamVjdC50eXBlID09IFwiQW5pbVN0YWNrXCIpXHJcbiAgICAgICAgX2ZieC5vYmplY3RzLmFuaW1TdGFja3MucHVzaChvYmplY3QpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbihfbm9kZTogTm9kZSk6IENvbm5lY3Rpb24ge1xyXG4gICAgaWYgKCEoX25vZGUucHJvcGVydGllc1swXSA9PSBcIk9PXCIgfHwgX25vZGUucHJvcGVydGllc1swXSA9PSBcIk9QXCIpKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgQ29ubmVjdGlvbiB0eXBlICR7X25vZGUucHJvcGVydGllc1swXX0gaXMgbm90IHN1cHBvcnRlZGApO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNoaWxkVUlEOiBfbm9kZS5wcm9wZXJ0aWVzWzFdIGFzIG51bWJlcixcclxuICAgICAgcGFyZW50VUlEOiBfbm9kZS5wcm9wZXJ0aWVzWzJdIGFzIG51bWJlcixcclxuICAgICAgcHJvcGVydHlOYW1lOiBfbm9kZS5wcm9wZXJ0aWVzWzBdID09IFwiT1BcIiA/IF9ub2RlLnByb3BlcnRpZXNbM10gYXMgc3RyaW5nIDogbnVsbFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGx5Q29ubmVjdGlvbnMoX2Nvbm5lY3Rpb25zOiBDb25uZWN0aW9uW10sIF9kb2N1bWVudHM6IERvY3VtZW50W10sIF9vYmplY3RzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIF9jb25uZWN0aW9ucykge1xyXG4gICAgICBsZXQgcGFyZW50OiBPYmplY3QgPSBfZG9jdW1lbnRzLmZpbmQoX2RvY3VtZW50ID0+IF9kb2N1bWVudC5sb2FkKCkuUm9vdE5vZGUgPT0gY29ubmVjdGlvbi5wYXJlbnRVSUQpIGFzIE9iamVjdDtcclxuICAgICAgbGV0IGNoaWxkOiBPYmplY3Q7XHJcbiAgICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIF9vYmplY3RzKSB7XHJcbiAgICAgICAgaWYgKHBhcmVudCA9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnVpZCA9PSBjb25uZWN0aW9uLnBhcmVudFVJRClcclxuICAgICAgICAgIHBhcmVudCA9IG9iamVjdDtcclxuICAgICAgICBpZiAoY2hpbGQgPT0gdW5kZWZpbmVkICYmIG9iamVjdC51aWQgPT0gY29ubmVjdGlvbi5jaGlsZFVJRClcclxuICAgICAgICAgIGNoaWxkID0gb2JqZWN0O1xyXG4gICAgICAgIGlmIChwYXJlbnQgIT0gdW5kZWZpbmVkICYmIGNoaWxkICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjaGlsZClcclxuICAgICAgICAoY2hpbGQucGFyZW50cyB8fCAoY2hpbGQucGFyZW50cyA9IFtdKSkucHVzaChwYXJlbnQpO1xyXG4gICAgICBpZiAoY29ubmVjdGlvbi5wcm9wZXJ0eU5hbWUgPT0gbnVsbClcclxuICAgICAgICAocGFyZW50LmNoaWxkcmVuIHx8IChwYXJlbnQuY2hpbGRyZW4gPSBbXSkpLnB1c2goY2hpbGQpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgKHBhcmVudCBhcyBPYmplY3QpW2Zvcm1hdFByb3BlcnR5TmFtZShjb25uZWN0aW9uLnByb3BlcnR5TmFtZSldID0gY2hpbGQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb2FkT2JqZWN0UHJvcGVydGllcyhfbm9kZTogTm9kZSwgX29iamVjdDogT2JqZWN0KTogT2JqZWN0IHtcclxuICAgIGlmIChfb2JqZWN0LmxvYWRlZClcclxuICAgICAgcmV0dXJuIF9vYmplY3Q7XHJcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIF9ub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgIGlmIChjaGlsZC5uYW1lID09IFwiUHJvcGVydGllczcwXCIpXHJcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eTcwIG9mIGNoaWxkLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICBjb25zdCBuYW1lOiBzdHJpbmcgPSBmb3JtYXRQcm9wZXJ0eU5hbWUocHJvcGVydHk3MC5wcm9wZXJ0aWVzWzBdIGFzIHN0cmluZyk7XHJcbiAgICAgICAgICBpZiAoIV9vYmplY3RbbmFtZV0pXHJcbiAgICAgICAgICAgIF9vYmplY3RbbmFtZV0gPSBnZXRQcm9wZXJ0eTcwVmFsdWUocHJvcGVydHk3MCk7XHJcbiAgICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBuYW1lOiBzdHJpbmcgPSBmb3JtYXRQcm9wZXJ0eU5hbWUoY2hpbGQubmFtZSk7XHJcbiAgICAgICAgaWYgKCFfb2JqZWN0W25hbWVdKVxyXG4gICAgICAgICAgX29iamVjdFtuYW1lXSA9IGdldFByb3BlcnR5VmFsdWUoY2hpbGQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfb2JqZWN0LmxvYWRlZCA9IHRydWU7XHJcbiAgICByZXR1cm4gX29iamVjdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFByb3BlcnR5VmFsdWUoX25vZGU6IE5vZGUpOiBOb2RlUHJvcGVydHkgfCBPYmplY3Qge1xyXG4gICAgcmV0dXJuIF9ub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDBcclxuICAgICAgPyBfbm9kZS5jaGlsZHJlbi5yZWR1Y2UoXHJcbiAgICAgICAgKF9zdWJQcm9wZXJ0aWVzLCBfc3ViUHJvcGVydHkpID0+IHtcclxuICAgICAgICAgIGNvbnN0IG5hbWU6IHN0cmluZyA9IGZvcm1hdFByb3BlcnR5TmFtZShfc3ViUHJvcGVydHkubmFtZSk7XHJcbiAgICAgICAgICBpZiAoX3N1YlByb3BlcnRpZXNbbmFtZV0gPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBfc3ViUHJvcGVydGllc1tuYW1lXSA9IGdldFByb3BlcnR5VmFsdWUoX3N1YlByb3BlcnR5KTtcclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIShfc3ViUHJvcGVydGllc1tuYW1lXSBpbnN0YW5jZW9mIEFycmF5KSlcclxuICAgICAgICAgICAgICBfc3ViUHJvcGVydGllc1tuYW1lXSA9IFtfc3ViUHJvcGVydGllc1tuYW1lXSBhcyBPYmplY3RdO1xyXG4gICAgICAgICAgICAoX3N1YlByb3BlcnRpZXNbbmFtZV0gYXMgT2JqZWN0W10pLnB1c2goZ2V0UHJvcGVydHlWYWx1ZShfc3ViUHJvcGVydHkpIGFzIE9iamVjdCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gX3N1YlByb3BlcnRpZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7fSBhcyBPYmplY3RcclxuICAgICAgKVxyXG4gICAgICA6IF9ub2RlLnByb3BlcnRpZXNbMF07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRQcm9wZXJ0eTcwVmFsdWUoX25vZGU6IE5vZGUpOiBQcm9wZXJ0eTcwIHtcclxuICAgIHN3aXRjaCAoX25vZGUucHJvcGVydGllc1sxXSBhcyBzdHJpbmcpIHtcclxuICAgICAgY2FzZSBcImJvb2xcIjpcclxuICAgICAgICByZXR1cm4gX25vZGUucHJvcGVydGllc1s0XSBhcyBib29sZWFuO1xyXG5cclxuICAgICAgY2FzZSBcImludFwiOlxyXG4gICAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICBjYXNlIFwiVUxvbmdMb25nXCI6XHJcbiAgICAgIGNhc2UgXCJkb3VibGVcIjpcclxuICAgICAgY2FzZSBcIk51bWJlclwiOlxyXG4gICAgICBjYXNlIFwiRmllbGRPZlZpZXdcIjpcclxuICAgICAgICByZXR1cm4gX25vZGUucHJvcGVydGllc1s0XSBhcyBudW1iZXI7XHJcblxyXG4gICAgICBjYXNlIFwiQ29sb3JcIjpcclxuICAgICAgY2FzZSBcIkNvbG9yUkdCXCI6XHJcbiAgICAgIGNhc2UgXCJWZWN0b3IzRFwiOlxyXG4gICAgICBjYXNlIFwiTGNsIFRyYW5zbGF0aW9uXCI6XHJcbiAgICAgIGNhc2UgXCJMY2wgUm90YXRpb25cIjpcclxuICAgICAgY2FzZSBcIkxjbCBTY2FsaW5nXCI6XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGdWRnZUNvcmUuVmVjdG9yMyguLi5fbm9kZS5wcm9wZXJ0aWVzLnNsaWNlKDQsIDcpIGFzIG51bWJlcltdKTtcclxuXHJcbiAgICAgIGNhc2UgXCJLU3RyaW5nXCI6XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIF9ub2RlLnByb3BlcnRpZXNbNF0gYXMgc3RyaW5nO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZm9ybWF0UHJvcGVydHlOYW1lKF9uYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIF9uYW1lLnJlcGxhY2UoL1teYS16QS1aXS8sIFwiXCIpO1xyXG4gIH1cclxuXHJcbn0iLCJuYW1lc3BhY2UgRkJYIHtcclxuICAvKipcclxuICAgKiBQYXJzZXMgZmJ4LW5vZGVzIGFycmF5IGZyb20gYSBiaW5hcnkgZmJ4LWZpbGUuXHJcbiAgICogZGVzcGl0ZSB0aGUgbGF6eSBub2RlIGltcGxlbWVudGF0aW9uIGl0IGlzIG1vc3RseSBhIGNvcHkgb2YgdGhlIHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL3BpY29kZTcvZmJ4LXBhcnNlclxyXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgZnVuY3Rpb24gcGFyc2VOb2Rlc0Zyb21CaW5hcnkoX2J1ZmZlcjogQXJyYXlCdWZmZXIpOiBOb2RlW10ge1xyXG4gICAgaWYgKF9idWZmZXIuYnl0ZUxlbmd0aCA8IGJpbmFyeVN0YXJ0Q2hhcnMubGVuZ3RoKVxyXG4gICAgICB0aHJvdyBcIk5vdCBhIGJpbmFyeSBGQlggZmlsZVwiO1xyXG5cclxuICAgIGNvbnN0IGRhdGE6IEJ1ZmZlclJlYWRlciA9IG5ldyBCdWZmZXJSZWFkZXIoX2J1ZmZlcik7XHJcbiAgICBjb25zdCBmaXJzdENoYXJzOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5nZXRTZXF1ZW5jZShkYXRhLmdldFVpbnQ4LCBiaW5hcnlTdGFydENoYXJzLmxlbmd0aCkpO1xyXG4gICAgY29uc3QgbWF0Y2hlc0ZCWEJpbmFyeUZpcnN0Q2hhcnM6IGJvb2xlYW5cclxuICAgICAgPSBmaXJzdENoYXJzLmV2ZXJ5KChfdmFsdWUsIF9pbmRleCkgPT4gX3ZhbHVlID09IGJpbmFyeVN0YXJ0Q2hhcnNbX2luZGV4XSk7XHJcbiAgICBpZiAoIW1hdGNoZXNGQlhCaW5hcnlGaXJzdENoYXJzKVxyXG4gICAgICB0aHJvdyBcIk5vdCBhIGJpbmFyeSBGQlggZmlsZVwiO1xyXG5cclxuICAgIGNvbnN0IHZlcnNpb246IG51bWJlciA9IGRhdGEuZ2V0VWludDMyKCk7XHJcbiAgICBjb25zdCBub2RlQXR0cmlidXRlc0FzVUludDY0OiBib29sZWFuID0gdmVyc2lvbiA+PSA3NTAwOyAvLyBXYXJ1bSA+PSA3NTAwP1xyXG4gICAgY29uc3Qgbm9kZXM6IE5vZGVbXSA9IFtdO1xyXG5cclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgIGNvbnN0IG5vZGU6IE5vZGUgPSByZWFkTm9kZShkYXRhLCBub2RlQXR0cmlidXRlc0FzVUludDY0KTtcclxuICAgICAgaWYgKG5vZGUgPT0gbnVsbCkgYnJlYWs7XHJcbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5vZGVzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZE5vZGUoX2RhdGE6IEJ1ZmZlclJlYWRlciwgX2F0dHJpYnV0ZXNBc1VpbnQ2NDogYm9vbGVhbik6IE5vZGUge1xyXG4gICAgY29uc3QgZW5kT2Zmc2V0OiBudW1iZXIgPSBfYXR0cmlidXRlc0FzVWludDY0ID8gTnVtYmVyKF9kYXRhLmdldFVpbnQ2NCgpKSA6IF9kYXRhLmdldFVpbnQzMigpO1xyXG4gICAgaWYgKGVuZE9mZnNldCA9PSAwKVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBjb25zdCBwcm9wZXJ0aWVzTGVuZ3RoOiBudW1iZXIgPSBfYXR0cmlidXRlc0FzVWludDY0ID8gTnVtYmVyKF9kYXRhLmdldFVpbnQ2NCgpKSA6IF9kYXRhLmdldFVpbnQzMigpO1xyXG4gICAgY29uc3QgcHJvcGVydGllc0J5dGVMZW5ndGg6IG51bWJlciA9IF9hdHRyaWJ1dGVzQXNVaW50NjQgPyBOdW1iZXIoX2RhdGEuZ2V0VWludDY0KCkpIDogX2RhdGEuZ2V0VWludDMyKCk7XHJcbiAgICBjb25zdCBuYW1lTGVuZ3RoOiBudW1iZXIgPSBfZGF0YS5nZXRVaW50OCgpO1xyXG4gICAgY29uc3QgbmFtZTogc3RyaW5nID0gX2RhdGEuZ2V0U3RyaW5nKG5hbWVMZW5ndGgpO1xyXG4gICAgY29uc3QgcHJvcGVydGllc09mZnNldDogbnVtYmVyID0gX2RhdGEub2Zmc2V0O1xyXG4gICAgY29uc3QgY2hpbGRyZW5PZmZzZXQ6IG51bWJlciA9IHByb3BlcnRpZXNPZmZzZXQgKyBwcm9wZXJ0aWVzQnl0ZUxlbmd0aDtcclxuXHJcbiAgICBjb25zdCBub2RlOiBOb2RlID0gbmV3IE5vZGUoXHJcbiAgICAgIG5hbWUsXHJcbiAgICAgICgpID0+IHtcclxuICAgICAgICBfZGF0YS5vZmZzZXQgPSBwcm9wZXJ0aWVzT2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXM6IE5vZGVQcm9wZXJ0eVtdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaVByb3BlcnR5OiBudW1iZXIgPSAwOyBpUHJvcGVydHkgPCBwcm9wZXJ0aWVzTGVuZ3RoOyBpUHJvcGVydHkrKykge1xyXG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKHJlYWRQcm9wZXJ0eShfZGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcclxuICAgICAgfSxcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIF9kYXRhLm9mZnNldCA9IGNoaWxkcmVuT2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuOiBOb2RlW10gPSBbXTtcclxuICAgICAgICB3aGlsZSAoZW5kT2Zmc2V0IC0gX2RhdGEub2Zmc2V0ID4gbnVsbENvdW50QXROb2RlRW5kKSB7XHJcbiAgICAgICAgICBjb25zdCBjaGlsZDogRkJYLk5vZGUgPSByZWFkTm9kZShfZGF0YSwgX2F0dHJpYnV0ZXNBc1VpbnQ2NCk7XHJcbiAgICAgICAgICBpZiAoY2hpbGQpIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgX2RhdGEub2Zmc2V0ID0gZW5kT2Zmc2V0O1xyXG5cclxuICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZFByb3BlcnR5KF9kYXRhOiBCdWZmZXJSZWFkZXIpOiBGQlguTm9kZVByb3BlcnR5IHtcclxuICAgIGNvbnN0IHR5cGVDb2RlOiBzdHJpbmcgPSBfZGF0YS5nZXRDaGFyKCk7XHJcblxyXG4gICAgY29uc3QgdmFsdWU6IEZCWC5Ob2RlUHJvcGVydHkgPSB7XHJcbiAgICAgIEM6IF9kYXRhLmdldEJvb2wsXHJcbiAgICAgIFk6IF9kYXRhLmdldEludDE2LFxyXG4gICAgICBJOiBfZGF0YS5nZXRJbnQzMixcclxuICAgICAgTDogX2RhdGEuZ2V0SW50NjQsXHJcbiAgICAgIEY6IF9kYXRhLmdldEZsb2F0MzIsXHJcbiAgICAgIEQ6IF9kYXRhLmdldEZsb2F0NjQsXHJcbiAgICAgIFM6ICgpID0+IF9kYXRhLmdldFN0cmluZyhfZGF0YS5nZXRVaW50MzIoKSkucmVwbGFjZShcIlxceDAwXFx4MDFcIiwgXCI6OlwiKSxcclxuICAgICAgczogKCkgPT4gX2RhdGEuZ2V0U3RyaW5nKF9kYXRhLmdldFVpbnQzMigpKS5yZXBsYWNlKFwiXFx4MDBcXHgwMVwiLCBcIjo6XCIpLFxyXG4gICAgICBSOiAoKSA9PiBuZXcgVWludDhBcnJheShyZWFkUmF3KF9kYXRhLCBfZGF0YS5nZXRVaW50OCkpLFxyXG4gICAgICByOiAoKSA9PiBuZXcgVWludDhBcnJheShyZWFkQXJyYXkoX2RhdGEsIF9kYXRhLmdldFVpbnQ4KSksXHJcbiAgICAgIGI6ICgpID0+IG5ldyBVaW50OEFycmF5KHJlYWRBcnJheShfZGF0YSwgX2RhdGEuZ2V0VWludDgpKSxcclxuICAgICAgaTogKCkgPT4gbmV3IEludDMyQXJyYXkocmVhZEFycmF5KF9kYXRhLCBfZGF0YS5nZXRJbnQzMikpLFxyXG4gICAgICBsOiAoKSA9PiBuZXcgQmlnSW50NjRBcnJheShyZWFkQXJyYXkoX2RhdGEsIF9kYXRhLmdldEludDY0KSksXHJcbiAgICAgIGY6ICgpID0+IG5ldyBGbG9hdDMyQXJyYXkocmVhZEFycmF5KF9kYXRhLCBfZGF0YS5nZXRGbG9hdDMyKSksXHJcbiAgICAgIGQ6ICgpID0+IG5ldyBGbG9hdDMyQXJyYXkocmVhZEFycmF5KF9kYXRhLCBfZGF0YS5nZXRGbG9hdDY0KSlcclxuICAgIH1bdHlwZUNvZGVdPy5jYWxsKF9kYXRhKTtcclxuXHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcclxuICAgICAgRnVkZ2VDb3JlLkRlYnVnLndhcm4oYFVua25vd24gcHJvcGVydHkgdHlwZSAke3R5cGVDb2RlLmNoYXJDb2RlQXQoMCl9YCk7XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZEFycmF5PFQgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KF9kYXRhOiBCdWZmZXJSZWFkZXIsIF9nZXR0ZXI6ICgpID0+IFQpOiBHZW5lcmF0b3I8VD4ge1xyXG4gICAgY29uc3QgbGVuZ3RoOiBudW1iZXIgPSBfZGF0YS5nZXRVaW50MzIoKTtcclxuICAgIGNvbnN0IGVuY29kaW5nOiBGQlguQVJSQVlfRU5DT0RJTkcgPSBfZGF0YS5nZXRVaW50MzIoKTtcclxuICAgIGNvbnN0IGJ5dGVMZW5ndGg6IG51bWJlciA9IF9kYXRhLmdldFVpbnQzMigpO1xyXG4gICAgY29uc3QgZW5kT2Zmc2V0OiBudW1iZXIgPSBfZGF0YS5vZmZzZXQgKyBieXRlTGVuZ3RoO1xyXG5cclxuICAgIGNvbnN0IGl0ZXJhYmxlOiBHZW5lcmF0b3I8VD4gPSBlbmNvZGluZyA9PSBGQlguQVJSQVlfRU5DT0RJTkcuQ09NUFJFU1NFRCA/XHJcbiAgICAgICgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYXJyYXlEYXRhOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoX2RhdGEudmlldy5idWZmZXIsIF9kYXRhLm9mZnNldCwgYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgaW5mbGF0ZWREYXRhOiBVaW50OEFycmF5ID0gKFJlZmxlY3QuZ2V0KGdsb2JhbFRoaXMsIFwicGFrb1wiKSA/IHBha28uaW5mbGF0ZSA6IGZmbGF0ZS5pbmZsYXRlU3luYykoYXJyYXlEYXRhKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlclJlYWRlcihpbmZsYXRlZERhdGEuYnVmZmVyKS5nZXRTZXF1ZW5jZShfZ2V0dGVyLCBsZW5ndGgpO1xyXG4gICAgICB9KSgpIDpcclxuICAgICAgX2RhdGEuZ2V0U2VxdWVuY2UoX2dldHRlciwgbGVuZ3RoKTtcclxuXHJcbiAgICBfZGF0YS5vZmZzZXQgPSBlbmRPZmZzZXQ7XHJcblxyXG4gICAgcmV0dXJuIGl0ZXJhYmxlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZFJhdzxUIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihfZGF0YTogQnVmZmVyUmVhZGVyLCBfZ2V0dGVyOiAoKSA9PiBUKTogR2VuZXJhdG9yPFQ+IHtcclxuICAgIC8vIHJhdyBiaW5hcnkgZGF0YSBuZWVkcyB0byBiZSBpbnRlcnByZXRlZCBpbiBhIHNwZWNpYWwgd2F5IHNlZTpcclxuICAgIC8vIGh0dHBzOi8vY29kZS5ibGVuZGVyLm9yZy8yMDEzLzA4L2ZieC1iaW5hcnktZmlsZS1mb3JtYXQtc3BlY2lmaWNhdGlvbi9cclxuICAgIGNvbnN0IGxlbmd0aDogbnVtYmVyID0gX2RhdGEuZ2V0VWludDMyKCk7XHJcbiAgICByZXR1cm4gX2RhdGEuZ2V0U2VxdWVuY2UoX2dldHRlciwgbGVuZ3RoKTs7XHJcbiAgfVxyXG5cclxuICBjb25zdCBiaW5hcnlTdGFydENoYXJzOiBVaW50OEFycmF5XHJcbiAgICA9IFVpbnQ4QXJyYXkuZnJvbShcIktheWRhcmEgRkJYIEJpbmFyeVxceDIwXFx4MjBcXHgwMFxceDFhXFx4MDBcIi5zcGxpdChcIlwiKSwgX3YgPT4gX3YuY2hhckNvZGVBdCgwKSk7XHJcblxyXG4gIGNvbnN0IG51bGxDb3VudEF0Tm9kZUVuZDogbnVtYmVyID0gMTM7XHJcblxyXG59IiwibmFtZXNwYWNlIEdMVEYge1xyXG4gIGV4cG9ydCB0eXBlIEdsVGZJZCA9IG51bWJlcjtcclxuICAvKipcclxuICAgKiBBbiBvYmplY3QgcG9pbnRpbmcgdG8gYSBidWZmZXIgdmlldyBjb250YWluaW5nIHRoZSBpbmRpY2VzIG9mIGRldmlhdGluZyBhY2Nlc3NvciB2YWx1ZXMuIFRoZSBudW1iZXIgb2YgaW5kaWNlcyBpcyBlcXVhbCB0byBgYWNjZXNzb3Iuc3BhcnNlLmNvdW50YC4gSW5kaWNlcyAqKk1VU1QqKiBzdHJpY3RseSBpbmNyZWFzZS5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFjY2Vzc29yU3BhcnNlSW5kaWNlcyB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIHZpZXcgd2l0aCBzcGFyc2UgaW5kaWNlcy4gVGhlIHJlZmVyZW5jZWQgYnVmZmVyIHZpZXcgKipNVVNUIE5PVCoqIGhhdmUgaXRzIGB0YXJnZXRgIG9yIGBieXRlU3RyaWRlYCBwcm9wZXJ0aWVzIGRlZmluZWQuIFRoZSBidWZmZXIgdmlldyBhbmQgdGhlIG9wdGlvbmFsIGBieXRlT2Zmc2V0YCAqKk1VU1QqKiBiZSBhbGlnbmVkIHRvIHRoZSBgY29tcG9uZW50VHlwZWAgYnl0ZSBsZW5ndGguXHJcbiAgICAgKi9cclxuICAgIFwiYnVmZmVyVmlld1wiOiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBidWZmZXIgdmlldyBpbiBieXRlcy5cclxuICAgICAqL1xyXG4gICAgXCJieXRlT2Zmc2V0XCI/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRpY2VzIGRhdGEgdHlwZS5cclxuICAgICAqL1xyXG4gICAgXCJjb21wb25lbnRUeXBlXCI6IENPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX0JZVEUgfCBDT01QT05FTlRfVFlQRS5VTlNJR05FRF9TSE9SVCB8IENPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX0lOVDtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEFuIG9iamVjdCBwb2ludGluZyB0byBhIGJ1ZmZlciB2aWV3IGNvbnRhaW5pbmcgdGhlIGRldmlhdGluZyBhY2Nlc3NvciB2YWx1ZXMuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaXMgZXF1YWwgdG8gYGFjY2Vzc29yLnNwYXJzZS5jb3VudGAgdGltZXMgbnVtYmVyIG9mIGNvbXBvbmVudHMuIFRoZSBlbGVtZW50cyBoYXZlIHRoZSBzYW1lIGNvbXBvbmVudCB0eXBlIGFzIHRoZSBiYXNlIGFjY2Vzc29yLiBUaGUgZWxlbWVudHMgYXJlIHRpZ2h0bHkgcGFja2VkLiBEYXRhICoqTVVTVCoqIGJlIGFsaWduZWQgZm9sbG93aW5nIHRoZSBzYW1lIHJ1bGVzIGFzIHRoZSBiYXNlIGFjY2Vzc29yLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQWNjZXNzb3JTcGFyc2VWYWx1ZXMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGJ1ZmZlclZpZXcgd2l0aCBzcGFyc2UgdmFsdWVzLiBUaGUgcmVmZXJlbmNlZCBidWZmZXIgdmlldyAqKk1VU1QgTk9UKiogaGF2ZSBpdHMgYHRhcmdldGAgb3IgYGJ5dGVTdHJpZGVgIHByb3BlcnRpZXMgZGVmaW5lZC5cclxuICAgICAqL1xyXG4gICAgXCJidWZmZXJWaWV3XCI6IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGJ1ZmZlclZpZXcgaW4gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIFwiYnl0ZU9mZnNldFwiPzogbnVtYmVyO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU3BhcnNlIHN0b3JhZ2Ugb2YgYWNjZXNzb3IgdmFsdWVzIHRoYXQgZGV2aWF0ZSBmcm9tIHRoZWlyIGluaXRpYWxpemF0aW9uIHZhbHVlLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQWNjZXNzb3JTcGFyc2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBOdW1iZXIgb2YgZGV2aWF0aW5nIGFjY2Vzc29yIHZhbHVlcyBzdG9yZWQgaW4gdGhlIHNwYXJzZSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgXCJjb3VudFwiOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCBwb2ludGluZyB0byBhIGJ1ZmZlciB2aWV3IGNvbnRhaW5pbmcgdGhlIGluZGljZXMgb2YgZGV2aWF0aW5nIGFjY2Vzc29yIHZhbHVlcy4gVGhlIG51bWJlciBvZiBpbmRpY2VzIGlzIGVxdWFsIHRvIGBjb3VudGAuIEluZGljZXMgKipNVVNUKiogc3RyaWN0bHkgaW5jcmVhc2UuXHJcbiAgICAgKi9cclxuICAgIFwiaW5kaWNlc1wiOiBBY2Nlc3NvclNwYXJzZUluZGljZXM7XHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCBwb2ludGluZyB0byBhIGJ1ZmZlciB2aWV3IGNvbnRhaW5pbmcgdGhlIGRldmlhdGluZyBhY2Nlc3NvciB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIFwidmFsdWVzXCI6IEFjY2Vzc29yU3BhcnNlVmFsdWVzO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQSB0eXBlZCB2aWV3IGludG8gYSBidWZmZXIgdmlldyB0aGF0IGNvbnRhaW5zIHJhdyBiaW5hcnkgZGF0YS5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFjY2Vzc29yIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBidWZmZXJWaWV3LlxyXG4gICAgICovXHJcbiAgICBcImJ1ZmZlclZpZXdcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGJ1ZmZlciB2aWV3IGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBcImJ5dGVPZmZzZXRcIj86IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhdGF0eXBlIG9mIHRoZSBhY2Nlc3NvcidzIGNvbXBvbmVudHMuXHJcbiAgICAgKi9cclxuICAgIFwiY29tcG9uZW50VHlwZVwiOiBDT01QT05FTlRfVFlQRTtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHdoZXRoZXIgaW50ZWdlciBkYXRhIHZhbHVlcyBhcmUgbm9ybWFsaXplZCBiZWZvcmUgdXNhZ2UuXHJcbiAgICAgKi9cclxuICAgIFwibm9ybWFsaXplZFwiPzogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBlbGVtZW50cyByZWZlcmVuY2VkIGJ5IHRoaXMgYWNjZXNzb3IuXHJcbiAgICAgKi9cclxuICAgIFwiY291bnRcIjogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGFjY2Vzc29yJ3MgZWxlbWVudHMgYXJlIHNjYWxhcnMsIHZlY3RvcnMsIG9yIG1hdHJpY2VzLlxyXG4gICAgICovXHJcbiAgICBcInR5cGVcIjogQUNDRVNTT1JfVFlQRTtcclxuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSB2YWx1ZSBvZiBlYWNoIGNvbXBvbmVudCBpbiB0aGlzIGFjY2Vzc29yLlxyXG4gICAgICovXHJcbiAgICBcIm1heFwiPzogbnVtYmVyW107XHJcbiAgICAvKipcclxuICAgICAqIE1pbmltdW0gdmFsdWUgb2YgZWFjaCBjb21wb25lbnQgaW4gdGhpcyBhY2Nlc3Nvci5cclxuICAgICAqL1xyXG4gICAgXCJtaW5cIj86IG51bWJlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGFyc2Ugc3RvcmFnZSBvZiBlbGVtZW50cyB0aGF0IGRldmlhdGUgZnJvbSB0aGVpciBpbml0aWFsaXphdGlvbiB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgXCJzcGFyc2VcIj86IEFjY2Vzc29yU3BhcnNlO1xyXG4gICAgXCJuYW1lXCI/OiBhbnk7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogaHR0cHM6Ly9yZWdpc3RyeS5raHJvbm9zLm9yZy9nbFRGL3NwZWNzLzIuMC9nbFRGLTIuMC5odG1sI2FjY2Vzc29yLWRhdGEtdHlwZXNcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBDT01QT05FTlRfVFlQRSB7XHJcbiAgICBCWVRFID0gNTEyMCxcclxuICAgIFVOU0lHTkVEX0JZVEUgPSA1MTIxLFxyXG4gICAgU0hPUlQgPSA1MTIyLFxyXG4gICAgVU5TSUdORURfU0hPUlQgPSA1MTIzLFxyXG4gICAgVU5TSUdORURfSU5UID0gNTEyNSxcclxuICAgIEZMT0FUID0gNTEyNlxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gQUNDRVNTT1JfVFlQRSB7XHJcbiAgICBTQ0FMQVIgPSBcIlNDQUxBUlwiLFxyXG4gICAgVkVDMiA9IFwiVkVDMlwiLFxyXG4gICAgVkVDMyA9IFwiVkVDM1wiLFxyXG4gICAgVkVDNCA9IFwiVkVDNFwiLFxyXG4gICAgTUFUMiA9IFwiTUFUMlwiLFxyXG4gICAgTUFUMyA9IFwiTUFUM1wiLFxyXG4gICAgTUFUNCA9IFwiTUFUNFwiXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZGVzY3JpcHRvciBvZiB0aGUgYW5pbWF0ZWQgcHJvcGVydHkuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBbmltYXRpb25DaGFubmVsVGFyZ2V0IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGFuaW1hdGUuIFdoZW4gdW5kZWZpbmVkLCB0aGUgYW5pbWF0ZWQgb2JqZWN0ICoqTUFZKiogYmUgZGVmaW5lZCBieSBhbiBleHRlbnNpb24uXHJcbiAgICAgKi9cclxuICAgIFwibm9kZVwiPzogR2xUZklkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgbm9kZSdzIFRSUyBwcm9wZXJ0eSB0byBhbmltYXRlLCBvciB0aGUgYFwid2VpZ2h0c1wiYCBvZiB0aGUgTW9ycGggVGFyZ2V0cyBpdCBpbnN0YW50aWF0ZXMuIEZvciB0aGUgYFwidHJhbnNsYXRpb25cImAgcHJvcGVydHksIHRoZSB2YWx1ZXMgdGhhdCBhcmUgcHJvdmlkZWQgYnkgdGhlIHNhbXBsZXIgYXJlIHRoZSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgWCwgWSwgYW5kIFogYXhlcy4gRm9yIHRoZSBgXCJyb3RhdGlvblwiYCBwcm9wZXJ0eSwgdGhlIHZhbHVlcyBhcmUgYSBxdWF0ZXJuaW9uIGluIHRoZSBvcmRlciAoeCwgeSwgeiwgdyksIHdoZXJlIHcgaXMgdGhlIHNjYWxhci4gRm9yIHRoZSBgXCJzY2FsZVwiYCBwcm9wZXJ0eSwgdGhlIHZhbHVlcyBhcmUgdGhlIHNjYWxpbmcgZmFjdG9ycyBhbG9uZyB0aGUgWCwgWSwgYW5kIFogYXhlcy5cclxuICAgICAqL1xyXG4gICAgXCJwYXRoXCI6IFwidHJhbnNsYXRpb25cIiB8IFwicm90YXRpb25cIiB8IFwic2NhbGVcIiB8IFwid2VpZ2h0c1wiOyAvLyBodHRwczovL3JlZ2lzdHJ5Lmtocm9ub3Mub3JnL2dsVEYvc3BlY3MvMi4wL2dsVEYtMi4wLmh0bWwjYW5pbWF0aW9uc1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQW4gYW5pbWF0aW9uIGNoYW5uZWwgY29tYmluZXMgYW4gYW5pbWF0aW9uIHNhbXBsZXIgd2l0aCBhIHRhcmdldCBwcm9wZXJ0eSBiZWluZyBhbmltYXRlZC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvbkNoYW5uZWwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgYSBzYW1wbGVyIGluIHRoaXMgYW5pbWF0aW9uIHVzZWQgdG8gY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIFwic2FtcGxlclwiOiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZXNjcmlwdG9yIG9mIHRoZSBhbmltYXRlZCBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgXCJ0YXJnZXRcIjogQW5pbWF0aW9uQ2hhbm5lbFRhcmdldDtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEFuIGFuaW1hdGlvbiBzYW1wbGVyIGNvbWJpbmVzIHRpbWVzdGFtcHMgd2l0aCBhIHNlcXVlbmNlIG9mIG91dHB1dCB2YWx1ZXMgYW5kIGRlZmluZXMgYW4gaW50ZXJwb2xhdGlvbiBhbGdvcml0aG0uXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBbmltYXRpb25TYW1wbGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIGFuIGFjY2Vzc29yIGNvbnRhaW5pbmcga2V5ZnJhbWUgdGltZXN0YW1wcy5cclxuICAgICAqL1xyXG4gICAgXCJpbnB1dFwiOiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIEludGVycG9sYXRpb24gYWxnb3JpdGhtLlxyXG4gICAgICovXHJcbiAgICBcImludGVycG9sYXRpb25cIj86IFwiTElORUFSXCIgfCBcIlNURVBcIiB8IFwiQ1VCSUNTUExJTkVcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIGFuIGFjY2Vzc29yLCBjb250YWluaW5nIGtleWZyYW1lIG91dHB1dCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIFwib3V0cHV0XCI6IEdsVGZJZDtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEEga2V5ZnJhbWUgYW5pbWF0aW9uLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgYW5pbWF0aW9uIGNoYW5uZWxzLiBBbiBhbmltYXRpb24gY2hhbm5lbCBjb21iaW5lcyBhbiBhbmltYXRpb24gc2FtcGxlciB3aXRoIGEgdGFyZ2V0IHByb3BlcnR5IGJlaW5nIGFuaW1hdGVkLiBEaWZmZXJlbnQgY2hhbm5lbHMgb2YgdGhlIHNhbWUgYW5pbWF0aW9uICoqTVVTVCBOT1QqKiBoYXZlIHRoZSBzYW1lIHRhcmdldHMuXHJcbiAgICAgKi9cclxuICAgIFwiY2hhbm5lbHNcIjogQW5pbWF0aW9uQ2hhbm5lbFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBhbmltYXRpb24gc2FtcGxlcnMuIEFuIGFuaW1hdGlvbiBzYW1wbGVyIGNvbWJpbmVzIHRpbWVzdGFtcHMgd2l0aCBhIHNlcXVlbmNlIG9mIG91dHB1dCB2YWx1ZXMgYW5kIGRlZmluZXMgYW4gaW50ZXJwb2xhdGlvbiBhbGdvcml0aG0uXHJcbiAgICAgKi9cclxuICAgIFwic2FtcGxlcnNcIjogQW5pbWF0aW9uU2FtcGxlcltdO1xyXG4gICAgXCJuYW1lXCI/OiBhbnk7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBNZXRhZGF0YSBhYm91dCB0aGUgZ2xURiBhc3NldC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFzc2V0IHtcclxuICAgIC8qKlxyXG4gICAgICogQSBjb3B5cmlnaHQgbWVzc2FnZSBzdWl0YWJsZSBmb3IgZGlzcGxheSB0byBjcmVkaXQgdGhlIGNvbnRlbnQgY3JlYXRvci5cclxuICAgICAqL1xyXG4gICAgXCJjb3B5cmlnaHRcIj86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogVG9vbCB0aGF0IGdlbmVyYXRlZCB0aGlzIGdsVEYgbW9kZWwuICBVc2VmdWwgZm9yIGRlYnVnZ2luZy5cclxuICAgICAqL1xyXG4gICAgXCJnZW5lcmF0b3JcIj86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGdsVEYgdmVyc2lvbiBpbiB0aGUgZm9ybSBvZiBgPG1ham9yPi48bWlub3I+YCB0aGF0IHRoaXMgYXNzZXQgdGFyZ2V0cy5cclxuICAgICAqL1xyXG4gICAgXCJ2ZXJzaW9uXCI6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1pbmltdW0gZ2xURiB2ZXJzaW9uIGluIHRoZSBmb3JtIG9mIGA8bWFqb3I+LjxtaW5vcj5gIHRoYXQgdGhpcyBhc3NldCB0YXJnZXRzLiBUaGlzIHByb3BlcnR5ICoqTVVTVCBOT1QqKiBiZSBncmVhdGVyIHRoYW4gdGhlIGFzc2V0IHZlcnNpb24uXHJcbiAgICAgKi9cclxuICAgIFwibWluVmVyc2lvblwiPzogc3RyaW5nO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQSBidWZmZXIgcG9pbnRzIHRvIGJpbmFyeSBnZW9tZXRyeSwgYW5pbWF0aW9uLCBvciBza2lucy5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEJ1ZmZlciB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBVUkkgKG9yIElSSSkgb2YgdGhlIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgXCJ1cmlcIj86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBcImJ5dGVMZW5ndGhcIjogbnVtYmVyO1xyXG4gICAgXCJuYW1lXCI/OiBhbnk7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBIHZpZXcgaW50byBhIGJ1ZmZlciBnZW5lcmFsbHkgcmVwcmVzZW50aW5nIGEgc3Vic2V0IG9mIHRoZSBidWZmZXIuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBCdWZmZXJWaWV3IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIFwiYnVmZmVyXCI6IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9mZnNldCBpbnRvIHRoZSBidWZmZXIgaW4gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIFwiYnl0ZU9mZnNldFwiPzogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXJWaWV3IGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBcImJ5dGVMZW5ndGhcIjogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3RyaWRlLCBpbiBieXRlcy5cclxuICAgICAqL1xyXG4gICAgXCJieXRlU3RyaWRlXCI/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoaW50IHJlcHJlc2VudGluZyB0aGUgaW50ZW5kZWQgR1BVIGJ1ZmZlciB0eXBlIHRvIHVzZSB3aXRoIHRoaXMgYnVmZmVyIHZpZXcuXHJcbiAgICAgKi9cclxuICAgIFwidGFyZ2V0XCI/OiBudW1iZXIgfCBudW1iZXIgfCBudW1iZXI7XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEFuIG9ydGhvZ3JhcGhpYyBjYW1lcmEgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNyZWF0ZSBhbiBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXguXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBDYW1lcmFPcnRob2dyYXBoaWMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgaG9yaXpvbnRhbCBtYWduaWZpY2F0aW9uIG9mIHRoZSB2aWV3LiBUaGlzIHZhbHVlICoqTVVTVCBOT1QqKiBiZSBlcXVhbCB0byB6ZXJvLiBUaGlzIHZhbHVlICoqU0hPVUxEIE5PVCoqIGJlIG5lZ2F0aXZlLlxyXG4gICAgICovXHJcbiAgICBcInhtYWdcIjogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgdmVydGljYWwgbWFnbmlmaWNhdGlvbiBvZiB0aGUgdmlldy4gVGhpcyB2YWx1ZSAqKk1VU1QgTk9UKiogYmUgZXF1YWwgdG8gemVyby4gVGhpcyB2YWx1ZSAqKlNIT1VMRCBOT1QqKiBiZSBuZWdhdGl2ZS5cclxuICAgICAqL1xyXG4gICAgXCJ5bWFnXCI6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZsb2F0aW5nLXBvaW50IGRpc3RhbmNlIHRvIHRoZSBmYXIgY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgKipNVVNUIE5PVCoqIGJlIGVxdWFsIHRvIHplcm8uIGB6ZmFyYCAqKk1VU1QqKiBiZSBncmVhdGVyIHRoYW4gYHpuZWFyYC5cclxuICAgICAqL1xyXG4gICAgXCJ6ZmFyXCI6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZsb2F0aW5nLXBvaW50IGRpc3RhbmNlIHRvIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lLlxyXG4gICAgICovXHJcbiAgICBcInpuZWFyXCI6IG51bWJlcjtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEEgcGVyc3BlY3RpdmUgY2FtZXJhIGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjcmVhdGUgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIENhbWVyYVBlcnNwZWN0aXZlIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZsb2F0aW5nLXBvaW50IGFzcGVjdCByYXRpbyBvZiB0aGUgZmllbGQgb2Ygdmlldy5cclxuICAgICAqL1xyXG4gICAgXCJhc3BlY3RSYXRpb1wiPzogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgdmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zLiBUaGlzIHZhbHVlICoqU0hPVUxEKiogYmUgbGVzcyB0aGFuIM+ALlxyXG4gICAgICovXHJcbiAgICBcInlmb3ZcIjogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgZGlzdGFuY2UgdG8gdGhlIGZhciBjbGlwcGluZyBwbGFuZS5cclxuICAgICAqL1xyXG4gICAgXCJ6ZmFyXCI/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmbG9hdGluZy1wb2ludCBkaXN0YW5jZSB0byB0aGUgbmVhciBjbGlwcGluZyBwbGFuZS5cclxuICAgICAqL1xyXG4gICAgXCJ6bmVhclwiOiBudW1iZXI7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBIGNhbWVyYSdzIHByb2plY3Rpb24uICBBIG5vZGUgKipNQVkqKiByZWZlcmVuY2UgYSBjYW1lcmEgdG8gYXBwbHkgYSB0cmFuc2Zvcm0gdG8gcGxhY2UgdGhlIGNhbWVyYSBpbiB0aGUgc2NlbmUuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBDYW1lcmEge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvcnRob2dyYXBoaWMgY2FtZXJhIGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjcmVhdGUgYW4gb3J0aG9ncmFwaGljIHByb2plY3Rpb24gbWF0cml4LiBUaGlzIHByb3BlcnR5ICoqTVVTVCBOT1QqKiBiZSBkZWZpbmVkIHdoZW4gYHBlcnNwZWN0aXZlYCBpcyBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBcIm9ydGhvZ3JhcGhpY1wiPzogQ2FtZXJhT3J0aG9ncmFwaGljO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHBlcnNwZWN0aXZlIGNhbWVyYSBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY3JlYXRlIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXguIFRoaXMgcHJvcGVydHkgKipNVVNUIE5PVCoqIGJlIGRlZmluZWQgd2hlbiBgb3J0aG9ncmFwaGljYCBpcyBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBcInBlcnNwZWN0aXZlXCI/OiBDYW1lcmFQZXJzcGVjdGl2ZTtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIGlmIHRoZSBjYW1lcmEgdXNlcyBhIHBlcnNwZWN0aXZlIG9yIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBcInR5cGVcIjogYW55IHwgYW55IHwgc3RyaW5nO1xyXG4gICAgXCJuYW1lXCI/OiBhbnk7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBJbWFnZSBkYXRhIHVzZWQgdG8gY3JlYXRlIGEgdGV4dHVyZS4gSW1hZ2UgKipNQVkqKiBiZSByZWZlcmVuY2VkIGJ5IGFuIFVSSSAob3IgSVJJKSBvciBhIGJ1ZmZlciB2aWV3IGluZGV4LlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW1hZ2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgVVJJIChvciBJUkkpIG9mIHRoZSBpbWFnZS5cclxuICAgICAqL1xyXG4gICAgXCJ1cmlcIj86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGltYWdlJ3MgbWVkaWEgdHlwZS4gVGhpcyBmaWVsZCAqKk1VU1QqKiBiZSBkZWZpbmVkIHdoZW4gYGJ1ZmZlclZpZXdgIGlzIGRlZmluZWQuXHJcbiAgICAgKi9cclxuICAgIFwibWltZVR5cGVcIj86IGFueSB8IGFueSB8IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBidWZmZXJWaWV3IHRoYXQgY29udGFpbnMgdGhlIGltYWdlLiBUaGlzIGZpZWxkICoqTVVTVCBOT1QqKiBiZSBkZWZpbmVkIHdoZW4gYHVyaWAgaXMgZGVmaW5lZC5cclxuICAgICAqL1xyXG4gICAgXCJidWZmZXJWaWV3XCI/OiBHbFRmSWQ7XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlZmVyZW5jZSB0byBhIHRleHR1cmUuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBUZXh0dXJlSW5mbyB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgdGV4dHVyZS5cclxuICAgICAqL1xyXG4gICAgXCJpbmRleFwiOiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZXQgaW5kZXggb2YgdGV4dHVyZSdzIFRFWENPT1JEIGF0dHJpYnV0ZSB1c2VkIGZvciB0ZXh0dXJlIGNvb3JkaW5hdGUgbWFwcGluZy5cclxuICAgICAqL1xyXG4gICAgXCJ0ZXhDb29yZFwiPzogbnVtYmVyO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQSBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlcyB0aGF0IGFyZSB1c2VkIHRvIGRlZmluZSB0aGUgbWV0YWxsaWMtcm91Z2huZXNzIG1hdGVyaWFsIG1vZGVsIGZyb20gUGh5c2ljYWxseS1CYXNlZCBSZW5kZXJpbmcgKFBCUikgbWV0aG9kb2xvZ3kuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNYXRlcmlhbFBick1ldGFsbGljUm91Z2huZXNzIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZhY3RvcnMgZm9yIHRoZSBiYXNlIGNvbG9yIG9mIHRoZSBtYXRlcmlhbC5cclxuICAgICAqL1xyXG4gICAgXCJiYXNlQ29sb3JGYWN0b3JcIj86IG51bWJlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBjb2xvciB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBcImJhc2VDb2xvclRleHR1cmVcIj86IFRleHR1cmVJbmZvO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmFjdG9yIGZvciB0aGUgbWV0YWxuZXNzIG9mIHRoZSBtYXRlcmlhbC5cclxuICAgICAqL1xyXG4gICAgXCJtZXRhbGxpY0ZhY3RvclwiPzogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmFjdG9yIGZvciB0aGUgcm91Z2huZXNzIG9mIHRoZSBtYXRlcmlhbC5cclxuICAgICAqL1xyXG4gICAgXCJyb3VnaG5lc3NGYWN0b3JcIj86IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1ldGFsbGljLXJvdWdobmVzcyB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBcIm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZVwiPzogVGV4dHVyZUluZm87XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIE1hdGVyaWFsTm9ybWFsVGV4dHVyZUluZm8ge1xyXG4gICAgXCJpbmRleFwiPzogYW55O1xyXG4gICAgXCJ0ZXhDb29yZFwiPzogYW55O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2NhbGFyIHBhcmFtZXRlciBhcHBsaWVkIHRvIGVhY2ggbm9ybWFsIHZlY3RvciBvZiB0aGUgbm9ybWFsIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIFwic2NhbGVcIj86IG51bWJlcjtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWF0ZXJpYWxPY2NsdXNpb25UZXh0dXJlSW5mbyB7XHJcbiAgICBcImluZGV4XCI/OiBhbnk7XHJcbiAgICBcInRleENvb3JkXCI/OiBhbnk7XHJcbiAgICAvKipcclxuICAgICAqIEEgc2NhbGFyIG11bHRpcGxpZXIgY29udHJvbGxpbmcgdGhlIGFtb3VudCBvZiBvY2NsdXNpb24gYXBwbGllZC5cclxuICAgICAqL1xyXG4gICAgXCJzdHJlbmd0aFwiPzogbnVtYmVyO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVGhlIG1hdGVyaWFsIGFwcGVhcmFuY2Ugb2YgYSBwcmltaXRpdmUuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNYXRlcmlhbCB7XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIC8qKlxyXG4gICAgICogQSBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlcyB0aGF0IGFyZSB1c2VkIHRvIGRlZmluZSB0aGUgbWV0YWxsaWMtcm91Z2huZXNzIG1hdGVyaWFsIG1vZGVsIGZyb20gUGh5c2ljYWxseSBCYXNlZCBSZW5kZXJpbmcgKFBCUikgbWV0aG9kb2xvZ3kuIFdoZW4gdW5kZWZpbmVkLCBhbGwgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIGBwYnJNZXRhbGxpY1JvdWdobmVzc2AgKipNVVNUKiogYXBwbHkuXHJcbiAgICAgKi9cclxuICAgIFwicGJyTWV0YWxsaWNSb3VnaG5lc3NcIj86IE1hdGVyaWFsUGJyTWV0YWxsaWNSb3VnaG5lc3M7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0YW5nZW50IHNwYWNlIG5vcm1hbCB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBcIm5vcm1hbFRleHR1cmVcIj86IE1hdGVyaWFsTm9ybWFsVGV4dHVyZUluZm87XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvY2NsdXNpb24gdGV4dHVyZS5cclxuICAgICAqL1xyXG4gICAgXCJvY2NsdXNpb25UZXh0dXJlXCI/OiBNYXRlcmlhbE9jY2x1c2lvblRleHR1cmVJbmZvO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZW1pc3NpdmUgdGV4dHVyZS5cclxuICAgICAqL1xyXG4gICAgXCJlbWlzc2l2ZVRleHR1cmVcIj86IFRleHR1cmVJbmZvO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmFjdG9ycyBmb3IgdGhlIGVtaXNzaXZlIGNvbG9yIG9mIHRoZSBtYXRlcmlhbC5cclxuICAgICAqL1xyXG4gICAgXCJlbWlzc2l2ZUZhY3RvclwiPzogbnVtYmVyW107XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbHBoYSByZW5kZXJpbmcgbW9kZSBvZiB0aGUgbWF0ZXJpYWwuXHJcbiAgICAgKi9cclxuICAgIFwiYWxwaGFNb2RlXCI/OiBcIk9QQVFVRVwiIHwgXCJNQVNLXCIgfCBcIkJMRU5EXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbHBoYSBjdXRvZmYgdmFsdWUgb2YgdGhlIG1hdGVyaWFsLlxyXG4gICAgICovXHJcbiAgICBcImFscGhhQ3V0b2ZmXCI/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBtYXRlcmlhbCBpcyBkb3VibGUgc2lkZWQuXHJcbiAgICAgKi9cclxuICAgIFwiZG91YmxlU2lkZWRcIj86IGJvb2xlYW47XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBHZW9tZXRyeSB0byBiZSByZW5kZXJlZCB3aXRoIHRoZSBnaXZlbiBtYXRlcmlhbC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE1lc2hQcmltaXRpdmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHBsYWluIEpTT04gb2JqZWN0LCB3aGVyZSBlYWNoIGtleSBjb3JyZXNwb25kcyB0byBhIG1lc2ggYXR0cmlidXRlIHNlbWFudGljIGFuZCBlYWNoIHZhbHVlIGlzIHRoZSBpbmRleCBvZiB0aGUgYWNjZXNzb3IgY29udGFpbmluZyBhdHRyaWJ1dGUncyBkYXRhLlxyXG4gICAgICovXHJcbiAgICBcImF0dHJpYnV0ZXNcIjoge1xyXG4gICAgICBbazogc3RyaW5nXTogR2xUZklkO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBhY2Nlc3NvciB0aGF0IGNvbnRhaW5zIHRoZSB2ZXJ0ZXggaW5kaWNlcy5cclxuICAgICAqL1xyXG4gICAgXCJpbmRpY2VzXCI/OiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgbWF0ZXJpYWwgdG8gYXBwbHkgdG8gdGhpcyBwcmltaXRpdmUgd2hlbiByZW5kZXJpbmcuXHJcbiAgICAgKi9cclxuICAgIFwibWF0ZXJpYWxcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRvcG9sb2d5IHR5cGUgb2YgcHJpbWl0aXZlcyB0byByZW5kZXIuXHJcbiAgICAgKi9cclxuICAgIFwibW9kZVwiPzogTUVTSF9QUklNSVRJVkVfTU9ERTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgbW9ycGggdGFyZ2V0cy5cclxuICAgICAqL1xyXG4gICAgXCJ0YXJnZXRzXCI/OiB7XHJcbiAgICAgIFtrOiBzdHJpbmddOiBHbFRmSWQ7XHJcbiAgICB9W107XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gTUVTSF9QUklNSVRJVkVfTU9ERSB7XHJcbiAgICBQT0lOVFMsXHJcbiAgICBMSU5FUyxcclxuICAgIExJTkVfTE9PUCxcclxuICAgIExJTkVfU1RSSVAsXHJcbiAgICBUUklBTkdMRVMsXHJcbiAgICBUUklBTkdMRV9TVFJJUCxcclxuICAgIFRSSUFOR0xFX0ZBTlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBzZXQgb2YgcHJpbWl0aXZlcyB0byBiZSByZW5kZXJlZC4gIEl0cyBnbG9iYWwgdHJhbnNmb3JtIGlzIGRlZmluZWQgYnkgYSBub2RlIHRoYXQgcmVmZXJlbmNlcyBpdC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE1lc2gge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBwcmltaXRpdmVzLCBlYWNoIGRlZmluaW5nIGdlb21ldHJ5IHRvIGJlIHJlbmRlcmVkLlxyXG4gICAgICovXHJcbiAgICBcInByaW1pdGl2ZXNcIjogTWVzaFByaW1pdGl2ZVtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiB3ZWlnaHRzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIG1vcnBoIHRhcmdldHMuIFRoZSBudW1iZXIgb2YgYXJyYXkgZWxlbWVudHMgKipNVVNUKiogbWF0Y2ggdGhlIG51bWJlciBvZiBtb3JwaCB0YXJnZXRzLlxyXG4gICAgICovXHJcbiAgICBcIndlaWdodHNcIj86IG51bWJlcltdO1xyXG4gICAgXCJuYW1lXCI/OiBhbnk7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBIG5vZGUgaW4gdGhlIG5vZGUgaGllcmFyY2h5LiAgV2hlbiB0aGUgbm9kZSBjb250YWlucyBgc2tpbmAsIGFsbCBgbWVzaC5wcmltaXRpdmVzYCAqKk1VU1QqKiBjb250YWluIGBKT0lOVFNfMGAgYW5kIGBXRUlHSFRTXzBgIGF0dHJpYnV0ZXMuICBBIG5vZGUgKipNQVkqKiBoYXZlIGVpdGhlciBhIGBtYXRyaXhgIG9yIGFueSBjb21iaW5hdGlvbiBvZiBgdHJhbnNsYXRpb25gL2Byb3RhdGlvbmAvYHNjYWxlYCAoVFJTKSBwcm9wZXJ0aWVzLiBUUlMgcHJvcGVydGllcyBhcmUgY29udmVydGVkIHRvIG1hdHJpY2VzIGFuZCBwb3N0bXVsdGlwbGllZCBpbiB0aGUgYFQgKiBSICogU2Agb3JkZXIgdG8gY29tcG9zZSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4OyBmaXJzdCB0aGUgc2NhbGUgaXMgYXBwbGllZCB0byB0aGUgdmVydGljZXMsIHRoZW4gdGhlIHJvdGF0aW9uLCBhbmQgdGhlbiB0aGUgdHJhbnNsYXRpb24uIElmIG5vbmUgYXJlIHByb3ZpZGVkLCB0aGUgdHJhbnNmb3JtIGlzIHRoZSBpZGVudGl0eS4gV2hlbiBhIG5vZGUgaXMgdGFyZ2V0ZWQgZm9yIGFuaW1hdGlvbiAocmVmZXJlbmNlZCBieSBhbiBhbmltYXRpb24uY2hhbm5lbC50YXJnZXQpLCBgbWF0cml4YCAqKk1VU1QgTk9UKiogYmUgcHJlc2VudC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNhbWVyYSByZWZlcmVuY2VkIGJ5IHRoaXMgbm9kZS5cclxuICAgICAqL1xyXG4gICAgXCJjYW1lcmFcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGljZXMgb2YgdGhpcyBub2RlJ3MgY2hpbGRyZW4uXHJcbiAgICAgKi9cclxuICAgIFwiY2hpbGRyZW5cIj86IEdsVGZJZFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHNraW4gcmVmZXJlbmNlZCBieSB0aGlzIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIFwic2tpblwiPzogR2xUZklkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZsb2F0aW5nLXBvaW50IDR4NCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggc3RvcmVkIGluIGNvbHVtbi1tYWpvciBvcmRlci5cclxuICAgICAqL1xyXG4gICAgXCJtYXRyaXhcIj86IG51bWJlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIG1lc2ggaW4gdGhpcyBub2RlLlxyXG4gICAgICovXHJcbiAgICBcIm1lc2hcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5vZGUncyB1bml0IHF1YXRlcm5pb24gcm90YXRpb24gaW4gdGhlIG9yZGVyICh4LCB5LCB6LCB3KSwgd2hlcmUgdyBpcyB0aGUgc2NhbGFyLlxyXG4gICAgICovXHJcbiAgICBcInJvdGF0aW9uXCI/OiBudW1iZXJbXTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5vZGUncyBub24tdW5pZm9ybSBzY2FsZSwgZ2l2ZW4gYXMgdGhlIHNjYWxpbmcgZmFjdG9ycyBhbG9uZyB0aGUgeCwgeSwgYW5kIHogYXhlcy5cclxuICAgICAqL1xyXG4gICAgXCJzY2FsZVwiPzogbnVtYmVyW107XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBub2RlJ3MgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHgsIHksIGFuZCB6IGF4ZXMuXHJcbiAgICAgKi9cclxuICAgIFwidHJhbnNsYXRpb25cIj86IG51bWJlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2VpZ2h0cyBvZiB0aGUgaW5zdGFudGlhdGVkIG1vcnBoIHRhcmdldC4gVGhlIG51bWJlciBvZiBhcnJheSBlbGVtZW50cyAqKk1VU1QqKiBtYXRjaCB0aGUgbnVtYmVyIG9mIG1vcnBoIHRhcmdldHMgb2YgdGhlIHJlZmVyZW5jZWQgbWVzaC4gV2hlbiBkZWZpbmVkLCBgbWVzaGAgKipNVVNUKiogYWxzbyBiZSBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBcIndlaWdodHNcIj86IG51bWJlcltdO1xyXG4gICAgXCJuYW1lXCI/OiBzdHJpbmc7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VzdG9tIHByb3BlcnR5IHNldCBieSBGVURHRSBsb2FkZXIuIE5vdCBwYXJ0IG9mIGdsVEYgc3RhbmRhcmQgMi4wLlxyXG4gICAgICovXHJcbiAgICBpc0FuaW1hdGVkPzogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogQ3VzdG9tIHByb3BlcnR5IHNldCBieSBGVURHRSBsb2FkZXIuIE5vdCBwYXJ0IG9mIGdsVEYgc3RhbmRhcmQgMi4wLlxyXG4gICAgICovXHJcbiAgICBwYXJlbnQ/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFBhdGggZnJvbSB0aGUgcm9vdCBub2RlIHRvIHRoaXMgbm9kZS5cclxuICAgICAqIEN1c3RvbSBwcm9wZXJ0eSBzZXQgYnkgRlVER0UgbG9hZGVyLiBOb3QgcGFydCBvZiBnbFRGIHN0YW5kYXJkIDIuMC5cclxuICAgICAqL1xyXG4gICAgcGF0aD86IG51bWJlcltdO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBUZXh0dXJlIHNhbXBsZXIgcHJvcGVydGllcyBmb3IgZmlsdGVyaW5nIGFuZCB3cmFwcGluZyBtb2Rlcy5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIFNhbXBsZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWduaWZpY2F0aW9uIGZpbHRlci5cclxuICAgICAqL1xyXG4gICAgXCJtYWdGaWx0ZXJcIj86IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJORUFSRVNUXCJdIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFtcIkxJTkVBUlwiXTtcclxuICAgIC8qKlxyXG4gICAgICogTWluaWZpY2F0aW9uIGZpbHRlci5cclxuICAgICAqL1xyXG4gICAgXCJtaW5GaWx0ZXJcIj86IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJORUFSRVNUXCJdIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFtcIkxJTkVBUlwiXSB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJORUFSRVNUX01JUE1BUF9ORUFSRVNUXCJdIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFtcIkxJTkVBUl9NSVBNQVBfTkVBUkVTVFwiXSB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJORUFSRVNUX01JUE1BUF9MSU5FQVJcIl0gfCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0W1wiTElORUFSX01JUE1BUF9MSU5FQVJcIl07XHJcbiAgICAvKipcclxuICAgICAqIFMgKFUpIHdyYXBwaW5nIG1vZGUuXHJcbiAgICAgKi9cclxuICAgIFwid3JhcFNcIj86IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJDTEFNUF9UT19FREdFXCJdIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFtcIk1JUlJPUkVEX1JFUEVBVFwiXSB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJSRVBFQVRcIl07XHJcbiAgICAvKipcclxuICAgICAqIFQgKFYpIHdyYXBwaW5nIG1vZGUuXHJcbiAgICAgKi9cclxuICAgIFwid3JhcFRcIj86IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJDTEFNUF9UT19FREdFXCJdIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFtcIk1JUlJPUkVEX1JFUEVBVFwiXSB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJSRVBFQVRcIl07XHJcbiAgICBcIm5hbWVcIj86IHN0cmluZztcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRoZSByb290IG5vZGVzIG9mIGEgc2NlbmUuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBTY2VuZSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRpY2VzIG9mIGVhY2ggcm9vdCBub2RlLlxyXG4gICAgICovXHJcbiAgICBcIm5vZGVzXCI/OiBHbFRmSWRbXTtcclxuICAgIFwibmFtZVwiPzogYW55O1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogSm9pbnRzIGFuZCBtYXRyaWNlcyBkZWZpbmluZyBhIHNraW4uXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBTa2luIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBhY2Nlc3NvciBjb250YWluaW5nIHRoZSBmbG9hdGluZy1wb2ludCA0eDQgaW52ZXJzZS1iaW5kIG1hdHJpY2VzLlxyXG4gICAgICovXHJcbiAgICBcImludmVyc2VCaW5kTWF0cmljZXNcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBub2RlIHVzZWQgYXMgYSBza2VsZXRvbiByb290LlxyXG4gICAgICovXHJcbiAgICBcInNrZWxldG9uXCI/OiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIEluZGljZXMgb2Ygc2tlbGV0b24gbm9kZXMsIHVzZWQgYXMgam9pbnRzIGluIHRoaXMgc2tpbi5cclxuICAgICAqL1xyXG4gICAgXCJqb2ludHNcIjogR2xUZklkW107XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEEgdGV4dHVyZSBhbmQgaXRzIHNhbXBsZXIuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBUZXh0dXJlIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBzYW1wbGVyIHVzZWQgYnkgdGhpcyB0ZXh0dXJlLiBXaGVuIHVuZGVmaW5lZCwgYSBzYW1wbGVyIHdpdGggcmVwZWF0IHdyYXBwaW5nIGFuZCBhdXRvIGZpbHRlcmluZyAqKlNIT1VMRCoqIGJlIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIFwic2FtcGxlclwiPzogR2xUZklkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGltYWdlIHVzZWQgYnkgdGhpcyB0ZXh0dXJlLiBXaGVuIHVuZGVmaW5lZCwgYW4gZXh0ZW5zaW9uIG9yIG90aGVyIG1lY2hhbmlzbSAqKlNIT1VMRCoqIHN1cHBseSBhbiBhbHRlcm5hdGUgdGV4dHVyZSBzb3VyY2UsIG90aGVyd2lzZSBiZWhhdmlvciBpcyB1bmRlZmluZWQuXHJcbiAgICAgKi9cclxuICAgIFwic291cmNlXCI/OiBHbFRmSWQ7XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRoZSByb290IG9iamVjdCBmb3IgYSBnbFRGIGFzc2V0LlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgR2xUZiB7XHJcbiAgICAvKipcclxuICAgICAqIE5hbWVzIG9mIGdsVEYgZXh0ZW5zaW9ucyB1c2VkIGluIHRoaXMgYXNzZXQuXHJcbiAgICAgKi9cclxuICAgIFwiZXh0ZW5zaW9uc1VzZWRcIj86IHN0cmluZ1tdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYW1lcyBvZiBnbFRGIGV4dGVuc2lvbnMgcmVxdWlyZWQgdG8gcHJvcGVybHkgbG9hZCB0aGlzIGFzc2V0LlxyXG4gICAgICovXHJcbiAgICBcImV4dGVuc2lvbnNSZXF1aXJlZFwiPzogc3RyaW5nW107XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIGFjY2Vzc29ycy5cclxuICAgICAqL1xyXG4gICAgXCJhY2Nlc3NvcnNcIj86IEFjY2Vzc29yW107XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIGtleWZyYW1lIGFuaW1hdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIFwiYW5pbWF0aW9uc1wiPzogQW5pbWF0aW9uW107XHJcbiAgICAvKipcclxuICAgICAqIE1ldGFkYXRhIGFib3V0IHRoZSBnbFRGIGFzc2V0LlxyXG4gICAgICovXHJcbiAgICBcImFzc2V0XCI6IEFzc2V0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBidWZmZXJzLlxyXG4gICAgICovXHJcbiAgICBcImJ1ZmZlcnNcIj86IEJ1ZmZlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBidWZmZXJWaWV3cy5cclxuICAgICAqL1xyXG4gICAgXCJidWZmZXJWaWV3c1wiPzogQnVmZmVyVmlld1tdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBjYW1lcmFzLlxyXG4gICAgICovXHJcbiAgICBcImNhbWVyYXNcIj86IENhbWVyYVtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBpbWFnZXMuXHJcbiAgICAgKi9cclxuICAgIFwiaW1hZ2VzXCI/OiBJbWFnZVtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBtYXRlcmlhbHMuXHJcbiAgICAgKi9cclxuICAgIFwibWF0ZXJpYWxzXCI/OiBNYXRlcmlhbFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBtZXNoZXMuXHJcbiAgICAgKi9cclxuICAgIFwibWVzaGVzXCI/OiBNZXNoW107XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIG5vZGVzLlxyXG4gICAgICovXHJcbiAgICBcIm5vZGVzXCI/OiBOb2RlW107XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIHNhbXBsZXJzLlxyXG4gICAgICovXHJcbiAgICBcInNhbXBsZXJzXCI/OiBTYW1wbGVyW107XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgZGVmYXVsdCBzY2VuZS5cclxuICAgICAqL1xyXG4gICAgXCJzY2VuZVwiPzogR2xUZklkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBzY2VuZXMuXHJcbiAgICAgKi9cclxuICAgIFwic2NlbmVzXCI/OiBTY2VuZVtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBza2lucy5cclxuICAgICAqL1xyXG4gICAgXCJza2luc1wiPzogU2tpbltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiB0ZXh0dXJlcy5cclxuICAgICAqL1xyXG4gICAgXCJ0ZXh0dXJlc1wiPzogVGV4dHVyZVtdO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQXNzZXQgbG9hZGVyIGZvciBnbCBUcmFuc2ZlciBGb3JtYXQgZmlsZXMuXHJcbiAgICogQGF1dGhvcnMgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjIgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgR0xURkxvYWRlciB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBsb2FkZXJzOiB7IFt1cmw6IHN0cmluZ106IEdMVEZMb2FkZXIgfTtcclxuXHJcbiAgICBzdGF0aWMgI2RlZmF1bHRNYXRlcmlhbDogTWF0ZXJpYWw7XHJcbiAgICBzdGF0aWMgI2RlZmF1bHRTa2luTWF0ZXJpYWw6IE1hdGVyaWFsO1xyXG5cclxuICAgIHJlYWRvbmx5ICN1cmw6IHN0cmluZztcclxuICAgIHJlYWRvbmx5ICNnbHRmOiBHTFRGLkdsVGY7XHJcblxyXG4gICAgI3Jlc291cmNlczogUmVzb3VyY2VzID0ge307XHJcblxyXG4gICAgI25vZGVzOiBOb2RlW10gPSBbXTtcclxuICAgICNjYW1lcmFzOiBDb21wb25lbnRDYW1lcmFbXTtcclxuICAgICNza2VsZXRvbnM6IENvbXBvbmVudFNrZWxldG9uW107XHJcblxyXG4gICAgI2J1ZmZlcnM6IEFycmF5QnVmZmVyW107XHJcblxyXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihfZ2x0ZjogR0xURi5HbFRmLCBfdXJsOiBzdHJpbmcsIF9idWZmZXJDaHVuaz86IEFycmF5QnVmZmVyKSB7XHJcbiAgICAgIHRoaXMuI2dsdGYgPSBfZ2x0ZjtcclxuICAgICAgdGhpcy4jdXJsID0gX3VybDtcclxuICAgICAgaWYgKF9idWZmZXJDaHVuaylcclxuICAgICAgICB0aGlzLiNidWZmZXJzID0gW19idWZmZXJDaHVua107XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0IGRlZmF1bHRNYXRlcmlhbCgpOiBNYXRlcmlhbCB7XHJcbiAgICAgIGlmICghdGhpcy4jZGVmYXVsdE1hdGVyaWFsKSB7XHJcbiAgICAgICAgdGhpcy4jZGVmYXVsdE1hdGVyaWFsID0gbmV3IE1hdGVyaWFsKFwiR0xURkRlZmF1bHRNYXRlcmlhbFwiLCBTaGFkZXJQaG9uZywgbmV3IENvYXRSZW1pc3NpdmUoQ29sb3IuQ1NTKFwid2hpdGVcIiksIDEsIDAuNSkpO1xyXG4gICAgICAgIFByb2plY3QuZGVyZWdpc3Rlcih0aGlzLiNkZWZhdWx0TWF0ZXJpYWwpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLiNkZWZhdWx0TWF0ZXJpYWw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0IGRlZmF1bHRTa2luTWF0ZXJpYWwoKTogTWF0ZXJpYWwge1xyXG4gICAgICBpZiAoIXRoaXMuI2RlZmF1bHRTa2luTWF0ZXJpYWwpIHtcclxuICAgICAgICB0aGlzLiNkZWZhdWx0U2tpbk1hdGVyaWFsID0gbmV3IE1hdGVyaWFsKFwiR0xURkRlZmF1bHRTa2luTWF0ZXJpYWxcIiwgU2hhZGVyUGhvbmdTa2luLCBuZXcgQ29hdFJlbWlzc2l2ZShDb2xvci5DU1MoXCJ3aGl0ZVwiKSwgMSwgMC41KSk7XHJcbiAgICAgICAgUHJvamVjdC5kZXJlZ2lzdGVyKHRoaXMuI2RlZmF1bHRTa2luTWF0ZXJpYWwpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLiNkZWZhdWx0U2tpbk1hdGVyaWFsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyB0aGUgbG9hZGluZyBvZiBhbiBleHRlcm5hbCByZXNvdXJjZSBmcm9tIGEgZ2xURiBmaWxlLiBVc2VkIGJ5IHRoZSB7QGxpbmsgU2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbH1HTFRGIHNwZWNpYWxpemF0aW9ucyB0byBsb2FkIHRoZW1zZWx2ZXMuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2FkUmVzb3VyY2U8VCBleHRlbmRzIEdyYXBoR0xURiB8IE1lc2hHTFRGIHwgTWF0ZXJpYWxHTFRGIHwgQW5pbWF0aW9uR0xURiB8IEdyYXBoSW5zdGFuY2U+KF9yZXNvdXJjZTogVCwgX3VybD86IFJlcXVlc3RJbmZvKTogUHJvbWlzZTxUPiB7XHJcbiAgICAgIGNvbnN0IGxvYWRlcjogR0xURkxvYWRlciA9IGF3YWl0IEdMVEZMb2FkZXIuTE9BRCgoKDxTZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsPl9yZXNvdXJjZSkudXJsID8/IF91cmwpLnRvU3RyaW5nKCkpO1xyXG5cclxuICAgICAgaWYgKCFsb2FkZXIpIHtcclxuICAgICAgICBpZiAoIShfcmVzb3VyY2UgaW5zdGFuY2VvZiBHcmFwaEluc3RhbmNlKSlcclxuICAgICAgICAgIF9yZXNvdXJjZS5zdGF0dXMgPSBSRVNPVVJDRV9TVEFUVVMuRVJST1I7XHJcbiAgICAgICAgcmV0dXJuIF9yZXNvdXJjZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGxvYWRlZDogVDtcclxuXHJcbiAgICAgIGlmIChfcmVzb3VyY2UgaW5zdGFuY2VvZiBHcmFwaEluc3RhbmNlKVxyXG4gICAgICAgIGxvYWRlZCA9IGF3YWl0IGxvYWRlci5nZXRHcmFwaChfcmVzb3VyY2UuZ2V0KCkubmFtZSwgX3Jlc291cmNlKTtcclxuICAgICAgZWxzZSBpZiAoX3Jlc291cmNlIGluc3RhbmNlb2YgR3JhcGhHTFRGKVxyXG4gICAgICAgIGxvYWRlZCA9IGF3YWl0IGxvYWRlci5nZXRHcmFwaChfcmVzb3VyY2UubmFtZSwgX3Jlc291cmNlKTtcclxuICAgICAgZWxzZSBpZiAoX3Jlc291cmNlIGluc3RhbmNlb2YgTWVzaEdMVEYpXHJcbiAgICAgICAgbG9hZGVkID0gYXdhaXQgbG9hZGVyLmdldE1lc2goX3Jlc291cmNlLm5hbWUsIF9yZXNvdXJjZS5pUHJpbWl0aXZlLCBfcmVzb3VyY2UpO1xyXG4gICAgICBlbHNlIGlmIChfcmVzb3VyY2UgaW5zdGFuY2VvZiBNYXRlcmlhbEdMVEYpXHJcbiAgICAgICAgbG9hZGVkID0gYXdhaXQgbG9hZGVyLmdldE1hdGVyaWFsKF9yZXNvdXJjZS5uYW1lLCBfcmVzb3VyY2UpO1xyXG4gICAgICBlbHNlIGlmIChfcmVzb3VyY2UgaW5zdGFuY2VvZiBBbmltYXRpb25HTFRGKVxyXG4gICAgICAgIGxvYWRlZCA9IGF3YWl0IGxvYWRlci5nZXRBbmltYXRpb24oX3Jlc291cmNlLm5hbWUsIF9yZXNvdXJjZSk7XHJcblxyXG4gICAgICBpZiAoIWxvYWRlZCkge1xyXG4gICAgICAgIERlYnVnLmVycm9yKGAke19yZXNvdXJjZS5jb25zdHJ1Y3Rvci5uYW1lfSB8ICR7X3Jlc291cmNlIGluc3RhbmNlb2YgR3JhcGhJbnN0YW5jZSA/IF9yZXNvdXJjZS5pZFNvdXJjZSA6IF9yZXNvdXJjZS5pZFJlc291cmNlfTogRmFpbGVkIHRvIGxvYWQgcmVzb3VyY2UuYCk7XHJcbiAgICAgICAgaWYgKCEoX3Jlc291cmNlIGluc3RhbmNlb2YgR3JhcGhJbnN0YW5jZSkpXHJcbiAgICAgICAgICBfcmVzb3VyY2Uuc3RhdHVzID0gUkVTT1VSQ0VfU1RBVFVTLkVSUk9SO1xyXG5cclxuICAgICAgICByZXR1cm4gX3Jlc291cmNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShsb2FkZWQgaW5zdGFuY2VvZiBHcmFwaEluc3RhbmNlKSkge1xyXG4gICAgICAgIGxvYWRlZC5zdGF0dXMgPSBSRVNPVVJDRV9TVEFUVVMuUkVBRFk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGlmIChjYWNoZWQgJiYgIShfcmVzb3VyY2UgaW5zdGFuY2VvZiBHcmFwaEluc3RhbmNlKSkge1xyXG5cclxuICAgICAgLy8gICBpZiAoIVByb2plY3QucmVzb3VyY2VzW2NhY2hlZC5pZFJlc291cmNlXSlcclxuICAgICAgLy8gICAgIGNhY2hlZC5pZFJlc291cmNlID0gX3Jlc291cmNlLmlkUmVzb3VyY2U7IC8vIGNoYW5nZSB0aGUgaWQgb2YgdGhlIGNhY2hlZCByZXNvdXJjZSB0byB0aGUgaWQgb2YgdGhlIHJlc291cmNlIHRoYXQgcmVxdWVzdGVkIGl0XHJcblxyXG4gICAgICAvLyAgIGlmIChjYWNoZWQuaWRSZXNvdXJjZSAhPSBfcmVzb3VyY2UuaWRSZXNvdXJjZSkge1xyXG4gICAgICAvLyAgICAgLy8gdHdvIGRpZmZlcmVudCByZXNvdXJjZXMgaGF2ZSByZXF1ZXN0ZWQgdGhlIHNhbWUgY2FjaGVkIHJlc291cmNlXHJcbiAgICAgIC8vICAgICBEZWJ1Zy5lcnJvcihgJHtfcmVzb3VyY2UuaWRSZXNvdXJjZX06IEZhaWxlZCB0byBsb2FkIHJlc291cmNlLiAke19yZXNvdXJjZS50eXBlfSB3aXRoIG5hbWUgJyR7X3Jlc291cmNlLm5hbWV9JyBmcm9tICcke2xvYWRlci5uYW1lfScgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQgYnkgJyR7Y2FjaGVkLmlkUmVzb3VyY2V9Jy4gUGxlYXNlIGRlbGV0ZSB0aGUgZHVwbGljYXRlICcke19yZXNvdXJjZS5pZFJlc291cmNlfScgZnJvbSB0aGUgcHJvamVjdC5gKTtcclxuICAgICAgLy8gICAgIHJldHVybiBfcmVzb3VyY2U7XHJcbiAgICAgIC8vICAgfVxyXG5cclxuICAgICAgLy8gfVxyXG5cclxuICAgICAgcmV0dXJuIGxvYWRlZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgR0xURkxvYWRlcn0gaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiB1cmwgb3IgbnVsbCBpZiB0aGUgdXJsIGNhbid0IGJlIHJlc29sdmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIExPQUQoX3VybDogc3RyaW5nLCBfcmVnaXN0ZXJSZXNvdXJjZXM6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8R0xURkxvYWRlcj4ge1xyXG4gICAgICBpZiAoIXRoaXMubG9hZGVycylcclxuICAgICAgICBHTFRGTG9hZGVyLmxvYWRlcnMgPSB7fTtcclxuXHJcbiAgICAgIGlmICghdGhpcy5sb2FkZXJzW191cmxdKSB7XHJcbiAgICAgICAgbGV0IGdsdGY6IEdMVEYuR2xUZjtcclxuICAgICAgICBsZXQgYnVmZmVyOiBBcnJheUJ1ZmZlcjtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2U6IFJlc3BvbnNlID0gYXdhaXQgZmV0Y2gobmV3IFVSTChfdXJsLCBQcm9qZWN0LmJhc2VVUkwpKTtcclxuICAgICAgICAgIGNvbnN0IGZpbGVFeHRlbnNpb246IHN0cmluZyA9IF91cmwuc3BsaXQoJy4nKS5wb3AoKT8udG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICBpZiAoZmlsZUV4dGVuc2lvbiA9PSBcImdsdGZcIilcclxuICAgICAgICAgICAgZ2x0ZiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgICAgICBpZiAoZmlsZUV4dGVuc2lvbiA9PSBcImdsYlwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyOiBBcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3OiBEYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtYWdpYzogbnVtYmVyID0gZGF0YVZpZXcuZ2V0VWludDMyKDAsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAobWFnaWMgIT09IDB4NDY1NDZDNjcpXHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0dMVEZMb2FkZXIubmFtZX0gfCAke191cmx9OiBJbnZhbGlkIG1hZ2ljIG51bWJlciBpbiBHTEIgZmlsZS5gKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb246IG51bWJlciA9IGRhdGFWaWV3LmdldFVpbnQzMig0LCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKHZlcnNpb24gIT0gMilcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7R0xURkxvYWRlci5uYW1lfSB8ICR7X3VybH06IFVuc3VwcG9ydGVkIHZlcnNpb24gaW4gR0xCIGZpbGUuYCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBqc29uTGVuZ3RoOiBudW1iZXIgPSBkYXRhVmlldy5nZXRVaW50MzIoMTIsIHRydWUpO1xyXG4gICAgICAgICAgICBjb25zdCBqc29uRm9ybWF0OiBudW1iZXIgPSBkYXRhVmlldy5nZXRVaW50MzIoMTYsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGpzb25Gb3JtYXQgIT09IDB4NEU0RjUzNEEpXHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZvcm1hdC4gVGhlIGZpcnN0IGNodW5rIG9mIHRoZSBmaWxlIGlzIG5vdCBpbiBKU09OIGZvcm1hdC4nKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXI6IFRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGpzb25DaHVuazogc3RyaW5nID0gZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIDIwLCBqc29uTGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIGdsdGYgPSBKU09OLnBhcnNlKGpzb25DaHVuayk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCA+PSAyMCArIGpzb25MZW5ndGgpIHtcclxuICAgICAgICAgICAgICBjb25zdCBiaW5hcnlMZW5ndGg6IG51bWJlciA9IGRhdGFWaWV3LmdldFVpbnQzMigyMCArIGpzb25MZW5ndGgsIHRydWUpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGJpbmFyeUZvcm1hdDogbnVtYmVyID0gZGF0YVZpZXcuZ2V0VWludDMyKDI0ICsganNvbkxlbmd0aCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChiaW5hcnlGb3JtYXQgIT09IDB4MDA0RTQ5NDIpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZm9ybWF0LiBUaGUgc2Vjb25kIGNodW5rIG9mIHRoZSBmaWxlIGlzIG5vdCBpbiBiaW5hcnkgZm9ybWF0LicpO1xyXG5cclxuICAgICAgICAgICAgICBidWZmZXIgPSBhcnJheUJ1ZmZlci5zbGljZSgyOCArIGpzb25MZW5ndGgsIDI4ICsganNvbkxlbmd0aCArIGJpbmFyeUxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG4gICAgICAgICAgRGVidWcuZXJyb3IoYCR7R0xURkxvYWRlci5uYW1lfSB8ICR7X3VybH06IEZhaWxlZCB0byBsb2FkIGZpbGUuICR7ZXJyb3J9YCk7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEdMVEZMb2FkZXIuY2hlY2tDb21wYXRpYmlsaXR5KGdsdGYsIF91cmwpO1xyXG4gICAgICAgIEdMVEZMb2FkZXIucHJlUHJvY2VzcyhnbHRmLCBfdXJsKTtcclxuXHJcbiAgICAgICAgR0xURkxvYWRlci5sb2FkZXJzW191cmxdID0gbmV3IEdMVEZMb2FkZXIoZ2x0ZiwgX3VybCwgYnVmZmVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIEdMVEZMb2FkZXIubG9hZGVyc1tfdXJsXTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBjaGVja0NvbXBhdGliaWxpdHkoX2dsdGY6IEdMVEYuR2xUZiwgX3VybDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIGlmIChfZ2x0Zi5hc3NldC52ZXJzaW9uICE9IFwiMi4wXCIpXHJcbiAgICAgICAgRGVidWcud2FybihgJHtHTFRGTG9hZGVyLm5hbWV9IHwgJHtfdXJsfTogVGhpcyBsb2FkZXIgd2FzIGRldmVsb3BlZCBmb3IgZ2xURiAyLjAuIEl0IG1heSBub3Qgd29yayBhcyBpbnRlbmRlZCB3aXRoIHZlcnNpb24gJHtfZ2x0Zi5hc3NldC52ZXJzaW9ufS5gKTtcclxuICAgICAgaWYgKF9nbHRmLmFzc2V0Lm1pblZlcnNpb24gIT0gdW5kZWZpbmVkICYmIF9nbHRmLmFzc2V0Lm1pblZlcnNpb24gIT0gXCIyLjBcIilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7R0xURkxvYWRlci5uYW1lfSB8ICR7X3VybH06IFRoaXMgbG9hZGVyIHdhcyBkZXZlbG9wZWQgZm9yIGdsVEYgMi4wLiBJdCBkb2VzIG5vdCB3b3JrIHdpdGggcmVxdWlyZWQgbWluIHZlcnNpb24gJHtfZ2x0Zi5hc3NldC5taW5WZXJzaW9ufS5gKTtcclxuICAgICAgaWYgKF9nbHRmLmV4dGVuc2lvbnNVc2VkPy5sZW5ndGggPiAwKVxyXG4gICAgICAgIERlYnVnLndhcm4oYCR7R0xURkxvYWRlci5uYW1lfSB8ICR7X3VybH06IFRoaXMgbG9hZGVyIGRvZXMgbm90IHN1cHBvcnQgZ2xURiBleHRlbnNpb25zLiBJdCBtYXkgbm90IHdvcmsgYXMgaW50ZW5kZWQgd2l0aCBleHRlbnNpb25zICR7X2dsdGYuZXh0ZW5zaW9uc1VzZWQudG9TdHJpbmcoKX0uYCk7XHJcbiAgICAgIGlmIChfZ2x0Zi5leHRlbnNpb25zUmVxdWlyZWQ/Lmxlbmd0aCA+IDApXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0dMVEZMb2FkZXIubmFtZX0gfCAke191cmx9OiBUaGlzIGxvYWRlciBkb2VzIG5vdCBzdXBwb3J0IGdsVEYgZXh0ZW5zaW9ucy4gSXQgZG9lcyBub3Qgd29yayB3aXRoIHJlcXVpcmVkIGV4dGVuc2lvbnMgJHtfZ2x0Zi5leHRlbnNpb25zUmVxdWlyZWQudG9TdHJpbmcoKX0uYCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJlUHJvY2VzcyhfZ2x0ZjogR0xURi5HbFRmLCBfdXJsOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgLy8gYWRkIGEgbmFtZSB0byBlYWNoIHNjZW5lXHJcbiAgICAgIGlmIChfZ2x0Zi5zY2VuZXMpIHtcclxuICAgICAgICBfZ2x0Zi5zY2VuZSA9IF9nbHRmLnNjZW5lID8/IDA7XHJcbiAgICAgICAgYWRkTmFtZXMoXCJTY2VuZVwiLCBfZ2x0Zi5zY2VuZXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoX2dsdGYubm9kZXMpIHtcclxuICAgICAgICAvLyBtYXJrIGFsbCBub2RlcyB0aGF0IGFyZSBhbmltYXRlZFxyXG4gICAgICAgIF9nbHRmLmFuaW1hdGlvbnM/LmZvckVhY2goX2FuaW1hdGlvbiA9PiB7XHJcbiAgICAgICAgICBfYW5pbWF0aW9uLmNoYW5uZWxzLmZvckVhY2goX2NoYW5uZWwgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpTm9kZTogbnVtYmVyID0gX2NoYW5uZWwudGFyZ2V0Lm5vZGU7XHJcbiAgICAgICAgICAgIGlmIChpTm9kZSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgX2dsdGYubm9kZXNbaU5vZGVdLmlzQW5pbWF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIG1hcmsgcGFyZW50IG9mIGVhY2ggbm9kZVxyXG4gICAgICAgIF9nbHRmLm5vZGVzLmZvckVhY2goKF9ub2RlLCBfaU5vZGUpID0+IF9ub2RlLmNoaWxkcmVuPy5mb3JFYWNoKF9pQ2hpbGQgPT4gX2dsdGYubm9kZXNbX2lDaGlsZF0ucGFyZW50ID0gX2lOb2RlKSk7XHJcblxyXG4gICAgICAgIF9nbHRmLm5vZGVzLmZvckVhY2goKF9ub2RlLCBfaU5vZGUpID0+IHtcclxuICAgICAgICAgIC8vIGFkZCBuYW1lcyB0byBub2RlcyB0aGF0IGRvbid0IGhhdmUgb25lXHJcbiAgICAgICAgICBpZiAoX25vZGUubmFtZSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIF9ub2RlLm5hbWUgPSBgTm9kZSR7X2lOb2RlfWA7XHJcblxyXG4gICAgICAgICAgaWYgKF9ub2RlLmlzQW5pbWF0ZWQpIHtcclxuICAgICAgICAgICAgLy8gYWRkIHBhdGggdG8gZWFjaCBhbmltYXRlZCBub2RlXHJcbiAgICAgICAgICAgIGxldCBpUGFyZW50OiBudW1iZXIgPSBfbm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGxldCBwYXRoOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgICAgICBwYXRoLnB1c2goX2lOb2RlKTtcclxuICAgICAgICAgICAgd2hpbGUgKGlQYXJlbnQgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgcGF0aC5wdXNoKGlQYXJlbnQpO1xyXG4gICAgICAgICAgICAgIGlQYXJlbnQgPSBfZ2x0Zi5ub2Rlc1tpUGFyZW50XS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX25vZGUucGF0aCA9IHBhdGgucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKF9nbHRmLm1hdGVyaWFscylcclxuICAgICAgICBhZGROYW1lcyhcIk1hdGVyaWFsXCIsIF9nbHRmLm1hdGVyaWFscyk7XHJcblxyXG4gICAgICBpZiAoX2dsdGYubWVzaGVzKVxyXG4gICAgICAgIGFkZE5hbWVzKFwiTWVzaFwiLCBfZ2x0Zi5tZXNoZXMpO1xyXG5cclxuICAgICAgaWYgKF9nbHRmLmFuaW1hdGlvbnMpXHJcbiAgICAgICAgYWRkTmFtZXMoXCJBbmltYXRpb25cIiwgX2dsdGYuYW5pbWF0aW9ucyk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBhZGROYW1lcyhfdGVtcGxhdGU6IHN0cmluZywgX3RhcmdldDogeyBuYW1lPzogc3RyaW5nIH1bXSk6IHZvaWQge1xyXG4gICAgICAgIF90YXJnZXQuZm9yRWFjaCgoX2l0ZW0sIF9pbmRleCkgPT4ge1xyXG4gICAgICAgICAgaWYgKF9pdGVtLm5hbWUgPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBfaXRlbS5uYW1lID0gYCR7X3RlbXBsYXRlfSR7X2luZGV4fWA7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGdsVEYgZmlsZSBuYW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG5hbWUoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3VybC5zcGxpdChcIlxcXFxcIikucG9wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIG5ldyBpbnN0YW5jZXMgb2YgYWxsIHJlc291cmNlcyBvZiB0aGUgZ2l2ZW4gdHlwZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGxvYWRSZXNvdXJjZXM8VCBleHRlbmRzIFNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWw+KF9jbGFzczogbmV3ICgpID0+IFQpOiBQcm9taXNlPFRbXT4ge1xyXG4gICAgICBsZXQgcmVzb3VyY2VzOiBTZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsW10gPSBbXTtcclxuICAgICAgc3dpdGNoIChfY2xhc3MubmFtZSkge1xyXG4gICAgICAgIGNhc2UgR3JhcGgubmFtZTpcclxuICAgICAgICAgIGZvciAobGV0IGlTY2VuZTogbnVtYmVyID0gMDsgaVNjZW5lIDwgdGhpcy4jZ2x0Zi5zY2VuZXM/Lmxlbmd0aDsgaVNjZW5lKyspXHJcbiAgICAgICAgICAgIHJlc291cmNlcy5wdXNoKGF3YWl0IHRoaXMuZ2V0R3JhcGgoaVNjZW5lLCBuZXcgR3JhcGhHTFRGKCkpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTWVzaC5uYW1lOlxyXG4gICAgICAgICAgZm9yIChsZXQgaU1lc2g6IG51bWJlciA9IDA7IGlNZXNoIDwgdGhpcy4jZ2x0Zi5tZXNoZXM/Lmxlbmd0aDsgaU1lc2grKylcclxuICAgICAgICAgICAgZm9yIChsZXQgaVByaW1pdGl2ZTogbnVtYmVyID0gMDsgaVByaW1pdGl2ZSA8IHRoaXMuI2dsdGYubWVzaGVzW2lNZXNoXS5wcmltaXRpdmVzLmxlbmd0aDsgaVByaW1pdGl2ZSsrKVxyXG4gICAgICAgICAgICAgIHJlc291cmNlcy5wdXNoKGF3YWl0IHRoaXMuZ2V0TWVzaChpTWVzaCwgaVByaW1pdGl2ZSwgbmV3IE1lc2hHTFRGKCkpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTWF0ZXJpYWwubmFtZTpcclxuICAgICAgICAgIGZvciAobGV0IGlNYXRlcmlhbDogbnVtYmVyID0gMDsgaU1hdGVyaWFsIDwgdGhpcy4jZ2x0Zi5tYXRlcmlhbHM/Lmxlbmd0aDsgaU1hdGVyaWFsKyspXHJcbiAgICAgICAgICAgIHJlc291cmNlcy5wdXNoKGF3YWl0IHRoaXMuZ2V0TWF0ZXJpYWwoaU1hdGVyaWFsLCBuZXcgTWF0ZXJpYWxHTFRGKFwiSGkgOilcIikpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQW5pbWF0aW9uLm5hbWU6XHJcbiAgICAgICAgICBmb3IgKGxldCBpQW5pbWF0aW9uOiBudW1iZXIgPSAwOyBpQW5pbWF0aW9uIDwgdGhpcy4jZ2x0Zi5hbmltYXRpb25zPy5sZW5ndGg7IGlBbmltYXRpb24rKylcclxuICAgICAgICAgICAgcmVzb3VyY2VzLnB1c2goYXdhaXQgdGhpcy5nZXRBbmltYXRpb24oaUFuaW1hdGlvbiwgbmV3IEFuaW1hdGlvbkdMVEYoKSkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgcmVzb3VyY2VzKSB7XHJcbiAgICAgICAgaWYgKCFQcm9qZWN0LnJlc291cmNlc1tyZXNvdXJjZS5pZFJlc291cmNlXSlcclxuICAgICAgICAgIFByb2plY3QucmVnaXN0ZXIocmVzb3VyY2UpO1xyXG5cclxuICAgICAgICByZXNvdXJjZS5zdGF0dXMgPSBSRVNPVVJDRV9TVEFUVVMuUkVBRFk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiA8VFtdPnJlc291cmNlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgR3JhcGh9IGZvciB0aGUgZ2l2ZW4gc2NlbmUgbmFtZSBvciB0aGUgZGVmYXVsdCBzY2VuZSBpZiBubyBuYW1lIGlzIGdpdmVuLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0R3JhcGgoX25hbWU/OiBzdHJpbmcpOiBQcm9taXNlPEdyYXBoPjtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHtAbGluayBHcmFwaH0gZm9yIHRoZSBnaXZlbiBzY2VuZSBpbmRleCBvciB0aGUgZGVmYXVsdCBzY2VuZSBpZiBubyBpbmRleCBpcyBnaXZlbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldEdyYXBoKF9pU2NlbmU/OiBudW1iZXIpOiBQcm9taXNlPEdyYXBoPjtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSBzY2VuZSBmcm9tIHRoZSBnbFRGIGZpbGUgaW50byB0aGUgZ2l2ZW4ge0BsaW5rIEdyYXBofS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0R3JhcGg8VCBleHRlbmRzIE5vZGU+KF9pU2NlbmU6IG51bWJlciB8IHN0cmluZywgX2dyYXBoOiBUKTogUHJvbWlzZTxUPjtcclxuICAgIHB1YmxpYyBhc3luYyBnZXRHcmFwaChfaVNjZW5lOiBudW1iZXIgfCBzdHJpbmcgPSB0aGlzLiNnbHRmLnNjZW5lLCBfZ3JhcGg/OiBOb2RlKTogUHJvbWlzZTxOb2RlPiB7XHJcbiAgICAgIF9pU2NlbmUgPSB0aGlzLmdldEluZGV4KF9pU2NlbmUsIHRoaXMuI2dsdGYuc2NlbmVzKTtcclxuXHJcbiAgICAgIGlmIChfaVNjZW5lID09IC0xKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgY29uc3QgaWQ6IHN0cmluZyA9IGAke0dyYXBoR0xURi5uYW1lfXwke19pU2NlbmV9YDtcclxuXHJcbiAgICAgIGlmICghX2dyYXBoICYmIHRoaXMuI3Jlc291cmNlc1tpZF0pXHJcbiAgICAgICAgcmV0dXJuIDxOb2RlPjx1bmtub3duPnRoaXMuI3Jlc291cmNlc1tpZF07XHJcblxyXG4gICAgICB0aGlzLiNub2RlcyA9IFtdO1xyXG4gICAgICB0aGlzLiNjYW1lcmFzID0gW107XHJcbiAgICAgIHRoaXMuI3NrZWxldG9ucyA9IFtdO1xyXG5cclxuICAgICAgY29uc3QgZ2x0ZlNjZW5lOiBHTFRGLlNjZW5lID0gdGhpcy4jZ2x0Zi5zY2VuZXNbX2lTY2VuZV07XHJcbiAgICAgIGNvbnN0IGdyYXBoOiBOb2RlID0gX2dyYXBoID8/IG5ldyBHcmFwaEdMVEYoKTtcclxuICAgICAgZ3JhcGgubmFtZSA9IGdsdGZTY2VuZS5uYW1lO1xyXG4gICAgICBpZiAoZ3JhcGggaW5zdGFuY2VvZiBHcmFwaEdMVEYpXHJcbiAgICAgICAgZ3JhcGgudXJsID0gdGhpcy4jdXJsO1xyXG4gICAgICBpZiAoX2dyYXBoKSB7XHJcbiAgICAgICAgX2dyYXBoLnJlbW92ZUFsbENoaWxkcmVuKCk7XHJcbiAgICAgICAgX2dyYXBoLnJlbW92ZUNvbXBvbmVudHMoQ29tcG9uZW50U2tlbGV0b24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGlOb2RlIG9mIGdsdGZTY2VuZS5ub2RlcylcclxuICAgICAgICBncmFwaC5hZGRDaGlsZChhd2FpdCB0aGlzLmdldE5vZGVCeUluZGV4KGlOb2RlKSk7XHJcblxyXG4gICAgICAvLyBpZiAodGhpcy4jZ2x0Zi5hbmltYXRpb25zPy5sZW5ndGggPiAwICYmICFncmFwaC5nZXRDb21wb25lbnQoQ29tcG9uZW50QW5pbWF0aW9uKSkge1xyXG4gICAgICAvLyAgIGxldCBhbmltYXRpb246IEFuaW1hdGlvbiA9IGF3YWl0IHRoaXMuZ2V0QW5pbWF0aW9uKDApO1xyXG4gICAgICAvLyAgIFByb2plY3QucmVnaXN0ZXIoYW5pbWF0aW9uKTtcclxuICAgICAgLy8gICBncmFwaC5hZGRDb21wb25lbnQobmV3IENvbXBvbmVudEFuaW1hdGlvbihhbmltYXRpb24pKTtcclxuICAgICAgLy8gfVxyXG5cclxuICAgICAgLy8gVE9ETzogbG9hZCBvbmx5IHNrZWxldG9ucyB3aGljaCBiZWxvbmcgdG8gdGhlIHNjZW5lPz8/XHJcbiAgICAgIC8vIGlmICh0aGlzLmdsdGYuc2tpbnM/Lmxlbmd0aCA+IDApXHJcbiAgICAgIC8vICAgZm9yIChsZXQgaVNraW46IG51bWJlciA9IDA7IGlTa2luIDwgdGhpcy5nbHRmLnNraW5zLmxlbmd0aDsgaVNraW4rKylcclxuICAgICAgLy8gICAgIHNjZW5lLmFkZENvbXBvbmVudChhd2FpdCB0aGlzLmdldFNrZWxldG9uQnlJbmRleChpU2tpbikpO1xyXG4gICAgICBpZiAodGhpcy4jc2tlbGV0b25zKVxyXG4gICAgICAgIGZvciAoY29uc3Qgc2tlbGV0b24gb2YgdGhpcy4jc2tlbGV0b25zKVxyXG4gICAgICAgICAgZ3JhcGguYWRkQ29tcG9uZW50KHNrZWxldG9uKTtcclxuXHJcbiAgICAgIGlmICghX2dyYXBoKVxyXG4gICAgICAgIHRoaXMuI3Jlc291cmNlc1tpZF0gPSA8R3JhcGhHTFRGPmdyYXBoO1xyXG5cclxuICAgICAgcmV0dXJuIGdyYXBoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3Qge0BsaW5rIE5vZGV9IHdpdGggdGhlIGdpdmVuIG5hbWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXROb2RlKF9uYW1lOiBzdHJpbmcpOiBQcm9taXNlPE5vZGU+IHtcclxuICAgICAgY29uc3QgaU5vZGU6IG51bWJlciA9IHRoaXMuI2dsdGYubm9kZXMuZmluZEluZGV4KF9ub2RlID0+IF9ub2RlLm5hbWUgPT0gX25hbWUpO1xyXG4gICAgICBpZiAoaU5vZGUgPT0gLTEpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXN9OiBDb3VsZG4ndCBmaW5kIG5hbWUgJyR7X25hbWV9JyBpbiBnbFRGIG5vZGVzLmApO1xyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXROb2RlQnlJbmRleChpTm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgTm9kZX0gZm9yIHRoZSBnaXZlbiBpbmRleC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldE5vZGVCeUluZGV4KF9pTm9kZTogbnVtYmVyKTogUHJvbWlzZTxOb2RlPiB7XHJcbiAgICAgIGlmICghdGhpcy4jbm9kZXNbX2lOb2RlXSkge1xyXG4gICAgICAgIGNvbnN0IGdsdGZOb2RlOiBHTFRGLk5vZGUgPSB0aGlzLiNnbHRmLm5vZGVzW19pTm9kZV07XHJcbiAgICAgICAgY29uc3Qgbm9kZTogTm9kZSA9IG5ldyBOb2RlKGdsdGZOb2RlLm5hbWUpO1xyXG5cclxuICAgICAgICB0aGlzLiNub2Rlc1tfaU5vZGVdID0gbm9kZTtcclxuXHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKGdsdGZOb2RlLmNoaWxkcmVuKVxyXG4gICAgICAgICAgZm9yIChjb25zdCBpTm9kZSBvZiBnbHRmTm9kZS5jaGlsZHJlbilcclxuICAgICAgICAgICAgbm9kZS5hZGRDaGlsZChhd2FpdCB0aGlzLmdldE5vZGVCeUluZGV4KGlOb2RlKSk7XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIGZvciB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgIGlmIChnbHRmTm9kZS5tYXRyaXggfHwgZ2x0Zk5vZGUucm90YXRpb24gfHwgZ2x0Zk5vZGUuc2NhbGUgfHwgZ2x0Zk5vZGUudHJhbnNsYXRpb24gfHwgZ2x0Zk5vZGUuaXNBbmltYXRlZCkge1xyXG4gICAgICAgICAgbm9kZS5hZGRDb21wb25lbnQobmV3IENvbXBvbmVudFRyYW5zZm9ybSgpKTtcclxuICAgICAgICAgIGlmIChnbHRmTm9kZS5tYXRyaXgpIHtcclxuICAgICAgICAgICAgbm9kZS5tdHhMb2NhbC5zZXQoZ2x0Zk5vZGUubWF0cml4KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChnbHRmTm9kZS50cmFuc2xhdGlvbikge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICAgICAgICAgIHRyYW5zbGF0aW9uLnNldChnbHRmTm9kZS50cmFuc2xhdGlvblswXSwgZ2x0Zk5vZGUudHJhbnNsYXRpb25bMV0sIGdsdGZOb2RlLnRyYW5zbGF0aW9uWzJdKTtcclxuICAgICAgICAgICAgICBub2RlLm10eExvY2FsLnRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChnbHRmTm9kZS5yb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJvdGF0aW9uOiBRdWF0ZXJuaW9uID0gUmVjeWNsZXIuZ2V0KFF1YXRlcm5pb24pO1xyXG4gICAgICAgICAgICAgIHJvdGF0aW9uLnNldChnbHRmTm9kZS5yb3RhdGlvblswXSwgZ2x0Zk5vZGUucm90YXRpb25bMV0sIGdsdGZOb2RlLnJvdGF0aW9uWzJdLCBnbHRmTm9kZS5yb3RhdGlvblszXSk7XHJcbiAgICAgICAgICAgICAgbm9kZS5tdHhMb2NhbC5yb3RhdGlvbiA9IHJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKHJvdGF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ2x0Zk5vZGUuc2NhbGUpIHtcclxuICAgICAgICAgICAgICBjb25zdCBzY2FsZTogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgICAgICAgICBzY2FsZS5zZXQoZ2x0Zk5vZGUuc2NhbGVbMF0sIGdsdGZOb2RlLnNjYWxlWzFdLCBnbHRmTm9kZS5zY2FsZVsyXSk7XHJcbiAgICAgICAgICAgICAgbm9kZS5tdHhMb2NhbC5zY2FsaW5nID0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgUmVjeWNsZXIuc3RvcmUoc2NhbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjaGVjayBmb3IgY2FtZXJhXHJcbiAgICAgICAgaWYgKGdsdGZOb2RlLmNhbWVyYSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIG5vZGUuYWRkQ29tcG9uZW50KGF3YWl0IHRoaXMuZ2V0Q2FtZXJhQnlJbmRleChnbHRmTm9kZS5jYW1lcmEpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIGZvciBtZXNoIGFuZCBtYXRlcmlhbFxyXG4gICAgICAgIGlmIChnbHRmTm9kZS5tZXNoICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgY29uc3QgZ2x0Zk1lc2g6IEdMVEYuTWVzaCA9IHRoaXMuI2dsdGYubWVzaGVzPy5bZ2x0Zk5vZGUubWVzaF07XHJcbiAgICAgICAgICAvLyBUT0RPOiByZXZpZXcgdGhpc1xyXG4gICAgICAgICAgY29uc3Qgc3ViQ29tcG9uZW50czogW0NvbXBvbmVudE1lc2gsIENvbXBvbmVudE1hdGVyaWFsXVtdID0gW107XHJcbiAgICAgICAgICBmb3IgKGxldCBpUHJpbWl0aXZlOiBudW1iZXIgPSAwOyBpUHJpbWl0aXZlIDwgZ2x0Zk1lc2gucHJpbWl0aXZlcy5sZW5ndGg7IGlQcmltaXRpdmUrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gbmV3IENvbXBvbmVudE1lc2goYXdhaXQgdGhpcy5nZXRNZXNoKGdsdGZOb2RlLm1lc2gsIGlQcmltaXRpdmUpKTtcclxuICAgICAgICAgICAgY29uc3QgaXNTa2luOiBib29sZWFuID0gZ2x0Zk5vZGUuc2tpbiAhPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNTa2luKVxyXG4gICAgICAgICAgICAgIGNtcE1lc2guc2tlbGV0b24gPSBhd2FpdCB0aGlzLmdldFNrZWxldG9uQnlJbmRleChnbHRmTm9kZS5za2luKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWw7XHJcbiAgICAgICAgICAgIGNvbnN0IGlNYXRlcmlhbDogbnVtYmVyID0gZ2x0Zk1lc2gucHJpbWl0aXZlcz8uW2lQcmltaXRpdmVdPy5tYXRlcmlhbDtcclxuICAgICAgICAgICAgaWYgKGlNYXRlcmlhbCA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICBjbXBNYXRlcmlhbCA9IG5ldyBDb21wb25lbnRNYXRlcmlhbChpc1NraW4gP1xyXG4gICAgICAgICAgICAgICAgR0xURkxvYWRlci5kZWZhdWx0U2tpbk1hdGVyaWFsIDpcclxuICAgICAgICAgICAgICAgIEdMVEZMb2FkZXIuZGVmYXVsdE1hdGVyaWFsKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjb25zdCBpc0ZsYXQ6IGJvb2xlYW4gPSBnbHRmTWVzaC5wcmltaXRpdmVzW2lQcmltaXRpdmVdLmF0dHJpYnV0ZXMuTk9STUFMID09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICBjbXBNYXRlcmlhbCA9IG5ldyBDb21wb25lbnRNYXRlcmlhbChhd2FpdCB0aGlzLmdldE1hdGVyaWFsKGlNYXRlcmlhbCwgbnVsbCwgaXNTa2luLCBpc0ZsYXQpKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgdGhpcyBzaG91bGQgYmUgYSBmdWRnZSBtYXRlcmlhbCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgIGNvbnN0IGdsdGZNYXRlcmlhbDogR0xURi5NYXRlcmlhbCA9IHRoaXMuI2dsdGYubWF0ZXJpYWxzW2lNYXRlcmlhbF07XHJcbiAgICAgICAgICAgICAgaWYgKGdsdGZNYXRlcmlhbClcclxuICAgICAgICAgICAgICAgIGNtcE1hdGVyaWFsLnNvcnRGb3JBbHBoYSA9IGdsdGZNYXRlcmlhbC5hbHBoYU1vZGUgPT0gXCJCTEVORFwiO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3ViQ29tcG9uZW50cy5wdXNoKFtjbXBNZXNoLCBjbXBNYXRlcmlhbF0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChzdWJDb21wb25lbnRzLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIG5vZGUuYWRkQ29tcG9uZW50KHN1YkNvbXBvbmVudHNbMF1bMF0pO1xyXG4gICAgICAgICAgICBub2RlLmFkZENvbXBvbmVudChzdWJDb21wb25lbnRzWzBdWzFdKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN1YkNvbXBvbmVudHMuZm9yRWFjaCgoW19jbXBNZXNoLCBfY21wTWF0ZXJpYWxdLCBfaSkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IG5vZGVQYXJ0OiBOb2RlID0gbmV3IE5vZGUoYCR7bm9kZS5uYW1lfV9QcmltaXRpdmUke19pfWApO1xyXG4gICAgICAgICAgICAgIG5vZGVQYXJ0LmFkZENvbXBvbmVudChfY21wTWVzaCk7XHJcbiAgICAgICAgICAgICAgbm9kZVBhcnQuYWRkQ29tcG9uZW50KF9jbXBNYXRlcmlhbCk7XHJcbiAgICAgICAgICAgICAgbm9kZS5hZGRDaGlsZChub2RlUGFydCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuI25vZGVzW19pTm9kZV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB7QGxpbmsgQ29tcG9uZW50Q2FtZXJhfSB3aXRoIHRoZSBnaXZlbiBjYW1lcmEgbmFtZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldENhbWVyYShfbmFtZTogc3RyaW5nKTogUHJvbWlzZTxDb21wb25lbnRDYW1lcmE+IHtcclxuICAgICAgY29uc3QgaUNhbWVyYTogbnVtYmVyID0gdGhpcy4jZ2x0Zi5jYW1lcmFzLmZpbmRJbmRleChfY2FtZXJhID0+IF9jYW1lcmEubmFtZSA9PSBfbmFtZSk7XHJcbiAgICAgIGlmIChpQ2FtZXJhID09IC0xKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzfTogQ291bGRuJ3QgZmluZCBuYW1lICcke19uYW1lfScgaW4gZ2xURiBjYW1lcmFzLmApO1xyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRDYW1lcmFCeUluZGV4KGlDYW1lcmEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIENvbXBvbmVudENhbWVyYX0gZm9yIHRoZSBnaXZlbiBjYW1lcmEgaW5kZXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRDYW1lcmFCeUluZGV4KF9pQ2FtZXJhOiBudW1iZXIpOiBQcm9taXNlPENvbXBvbmVudENhbWVyYT4ge1xyXG4gICAgICBpZiAoIXRoaXMuI2NhbWVyYXMpXHJcbiAgICAgICAgdGhpcy4jY2FtZXJhcyA9IFtdO1xyXG4gICAgICBpZiAoIXRoaXMuI2NhbWVyYXNbX2lDYW1lcmFdKSB7XHJcbiAgICAgICAgY29uc3QgZ2x0ZkNhbWVyYTogR0xURi5DYW1lcmEgPSB0aGlzLiNnbHRmLmNhbWVyYXNbX2lDYW1lcmFdO1xyXG4gICAgICAgIGNvbnN0IGNhbWVyYTogQ29tcG9uZW50Q2FtZXJhID0gbmV3IENvbXBvbmVudENhbWVyYSgpO1xyXG5cclxuICAgICAgICBpZiAoZ2x0ZkNhbWVyYS5wZXJzcGVjdGl2ZSlcclxuICAgICAgICAgIGNhbWVyYS5wcm9qZWN0Q2VudHJhbChcclxuICAgICAgICAgICAgZ2x0ZkNhbWVyYS5wZXJzcGVjdGl2ZS5hc3BlY3RSYXRpbyxcclxuICAgICAgICAgICAgZ2x0ZkNhbWVyYS5wZXJzcGVjdGl2ZS55Zm92ICogQ2FsYy5yYWQyZGVnLFxyXG4gICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICBnbHRmQ2FtZXJhLnBlcnNwZWN0aXZlLnpuZWFyLFxyXG4gICAgICAgICAgICBnbHRmQ2FtZXJhLnBlcnNwZWN0aXZlLnpmYXJcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgY2FtZXJhLnByb2plY3RPcnRob2dyYXBoaWMoXHJcbiAgICAgICAgICAgIC1nbHRmQ2FtZXJhLm9ydGhvZ3JhcGhpYy54bWFnLFxyXG4gICAgICAgICAgICBnbHRmQ2FtZXJhLm9ydGhvZ3JhcGhpYy54bWFnLFxyXG4gICAgICAgICAgICAtZ2x0ZkNhbWVyYS5vcnRob2dyYXBoaWMueW1hZyxcclxuICAgICAgICAgICAgZ2x0ZkNhbWVyYS5vcnRob2dyYXBoaWMueW1hZ1xyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNhbWVyYTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy4jY2FtZXJhc1tfaUNhbWVyYV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB7QGxpbmsgQW5pbWF0aW9ufSB3aXRoIHRoZSBnaXZlbiBhbmltYXRpb24gbmFtZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldEFuaW1hdGlvbihfbmFtZTogc3RyaW5nKTogUHJvbWlzZTxBbmltYXRpb24+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgQW5pbWF0aW9ufSBmb3IgdGhlIGdpdmVuIGFuaW1hdGlvbiBpbmRleC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldEFuaW1hdGlvbihfaUFuaW1hdGlvbjogbnVtYmVyKTogUHJvbWlzZTxBbmltYXRpb24+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhbiBhbmltYXRpb24gZnJvbSB0aGUgZ2xURiBmaWxlIGludG8gdGhlIGdpdmVuIHtAbGluayBBbmltYXRpb259LlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRBbmltYXRpb248VCBleHRlbmRzIEFuaW1hdGlvbj4oX2lBbmltYXRpb246IG51bWJlciB8IHN0cmluZywgX2FuaW1hdGlvbjogVCk6IFByb21pc2U8VD47XHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0QW5pbWF0aW9uKF9pQW5pbWF0aW9uOiBudW1iZXIgfCBzdHJpbmcsIF9hbmltYXRpb24/OiBBbmltYXRpb24pOiBQcm9taXNlPEFuaW1hdGlvbj4ge1xyXG4gICAgICBfaUFuaW1hdGlvbiA9IHRoaXMuZ2V0SW5kZXgoX2lBbmltYXRpb24sIHRoaXMuI2dsdGYuYW5pbWF0aW9ucyk7XHJcblxyXG4gICAgICBpZiAoX2lBbmltYXRpb24gPT0gLTEpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICBjb25zdCBpZDogc3RyaW5nID0gYCR7QW5pbWF0aW9uLm5hbWV9fCR7X2lBbmltYXRpb259YDtcclxuXHJcbiAgICAgIGlmICghX2FuaW1hdGlvbiAmJiB0aGlzLiNyZXNvdXJjZXNbaWRdKVxyXG4gICAgICAgIHJldHVybiA8QW5pbWF0aW9uPnRoaXMuI3Jlc291cmNlc1tpZF07XHJcblxyXG4gICAgICBjb25zdCBnbHRmQW5pbWF0aW9uOiBHTFRGLkFuaW1hdGlvbiA9IHRoaXMuI2dsdGYuYW5pbWF0aW9ucz8uW19pQW5pbWF0aW9uXTtcclxuXHJcbiAgICAgIGlmICghZ2x0ZkFuaW1hdGlvbilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc306IENvdWxkbid0IGZpbmQgYW5pbWF0aW9uIHdpdGggaW5kZXggJHtfaUFuaW1hdGlvbn0uYCk7XHJcblxyXG4gICAgICBjb25zdCBhbmltYXRpb25TdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHt9O1xyXG4gICAgICBmb3IgKGNvbnN0IGdsdGZDaGFubmVsIG9mIGdsdGZBbmltYXRpb24uY2hhbm5lbHMpIHtcclxuICAgICAgICBjb25zdCBnbHRmTm9kZTogR0xURi5Ob2RlID0gdGhpcy4jZ2x0Zi5ub2Rlc1tnbHRmQ2hhbm5lbC50YXJnZXQubm9kZV07XHJcbiAgICAgICAgaWYgKCFnbHRmTm9kZSlcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBsZXQgbm9kZTogR2VuZXJhbCA9IGFuaW1hdGlvblN0cnVjdHVyZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGlOb2RlIG9mIGdsdGZOb2RlLnBhdGgpIHtcclxuICAgICAgICAgIGNvbnN0IGNoaWxkTmFtZTogc3RyaW5nID0gdGhpcy4jZ2x0Zi5ub2Rlc1tpTm9kZV0ubmFtZTtcclxuICAgICAgICAgIC8vIG5vZGUuY2hpbGRyZW5bY2hpbGROYW1lXVxyXG4gICAgICAgICAgbm9kZSA9IChub2RlLmNoaWxkcmVuID8/PSB7fSlbY2hpbGROYW1lXSA/Pz0ge307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBub2RlLmNvbXBvbmVudHMuQ29tcG9uZW50VHJhbnNmb3JtWzBdLm10eExvY2FsXHJcbiAgICAgICAgbGV0IG10eExvY2FsOiBBbmltYXRpb25TZXF1ZW5jZU1hdHJpeDR4NCA9IDxBbmltYXRpb25TZXF1ZW5jZU1hdHJpeDR4ND4oKCgobm9kZS5jb21wb25lbnRzID8/PSB7fSkuQ29tcG9uZW50VHJhbnNmb3JtID8/PSBbXSlbMF0gPz89IHt9KS5tdHhMb2NhbCA/Pz0ge30pO1xyXG4gICAgICAgIG10eExvY2FsW3RvSW50ZXJuVHJhbnNmb3JtYXRpb25bZ2x0ZkNoYW5uZWwudGFyZ2V0LnBhdGhdXSA9XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLmdldEFuaW1hdGlvblNlcXVlbmNlVmVjdG9yKGdsdGZBbmltYXRpb24uc2FtcGxlcnNbZ2x0ZkNoYW5uZWwuc2FtcGxlcl0sIGdsdGZDaGFubmVsLnRhcmdldC5wYXRoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYW5pbWF0aW9uOiBBbmltYXRpb24gPSBfYW5pbWF0aW9uID8/IG5ldyBBbmltYXRpb25HTFRGKCk7XHJcbiAgICAgIGFuaW1hdGlvbi5hbmltYXRpb25TdHJ1Y3R1cmUgPSBhbmltYXRpb25TdHJ1Y3R1cmU7XHJcbiAgICAgIGFuaW1hdGlvbi5jbGVhckNhY2hlKCk7XHJcbiAgICAgIGFuaW1hdGlvbi5uYW1lID0gZ2x0ZkFuaW1hdGlvbi5uYW1lO1xyXG4gICAgICBhbmltYXRpb24uY2FsY3VsYXRlVG90YWxUaW1lKCk7XHJcbiAgICAgIGlmIChhbmltYXRpb24gaW5zdGFuY2VvZiBBbmltYXRpb25HTFRGKVxyXG4gICAgICAgIGFuaW1hdGlvbi51cmwgPSB0aGlzLiN1cmw7XHJcbiAgICAgIGlmICghX2FuaW1hdGlvbikge1xyXG4gICAgICAgIFByb2plY3QuZGVyZWdpc3RlcihhbmltYXRpb24pO1xyXG4gICAgICAgIHRoaXMuI3Jlc291cmNlc1tpZF0gPSBhbmltYXRpb247XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhbmltYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB7QGxpbmsgTWVzaEdMVEZ9IHdpdGggdGhlIGdpdmVuIG5hbWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRNZXNoKF9uYW1lOiBzdHJpbmcsIF9pUHJpbWl0aXZlPzogbnVtYmVyKTogUHJvbWlzZTxNZXNoPjtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIE1lc2hHTFRGfSBmb3IgdGhlIGdpdmVuIG1lc2ggaW5kZXggYW5kIHByaW1pdGl2ZSBpbmRleC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldE1lc2goX2lNZXNoOiBudW1iZXIsIF9pUHJpbWl0aXZlPzogbnVtYmVyKTogUHJvbWlzZTxNZXNoPjtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSBtZXNoIGZyb20gdGhlIGdsVEYgZmlsZSBpbnRvIHRoZSBnaXZlbiB7QGxpbmsgTWVzaH1cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRNZXNoPFQgZXh0ZW5kcyBNZXNoPihfaU1lc2g6IG51bWJlciB8IHN0cmluZywgX2lQcmltaXRpdmU6IG51bWJlciwgX21lc2g6IFQpOiBQcm9taXNlPFQ+O1xyXG4gICAgcHVibGljIGFzeW5jIGdldE1lc2goX2lNZXNoOiBudW1iZXIgfCBzdHJpbmcsIF9pUHJpbWl0aXZlOiBudW1iZXIgPSAwLCBfbWVzaD86IE1lc2gpOiBQcm9taXNlPE1lc2g+IHtcclxuICAgICAgX2lNZXNoID0gdGhpcy5nZXRJbmRleChfaU1lc2gsIHRoaXMuI2dsdGYubWVzaGVzKTtcclxuXHJcbiAgICAgIGlmIChfaU1lc2ggPT0gLTEpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICBjb25zdCBpZDogc3RyaW5nID0gYCR7TWVzaEdMVEYubmFtZX18JHtfaU1lc2h9fCR7X2lQcmltaXRpdmV9YDtcclxuXHJcbiAgICAgIGlmICghX21lc2ggJiYgdGhpcy4jcmVzb3VyY2VzW2lkXSlcclxuICAgICAgICByZXR1cm4gPE1lc2hHTFRGPnRoaXMuI3Jlc291cmNlc1tpZF07XHJcblxyXG4gICAgICBjb25zdCBnbHRmTWVzaDogR0xURi5NZXNoID0gdGhpcy4jZ2x0Zi5tZXNoZXNbX2lNZXNoXTtcclxuICAgICAgY29uc3QgZ2x0ZlByaW1pdGl2ZTogR0xURi5NZXNoUHJpbWl0aXZlID0gZ2x0Zk1lc2gucHJpbWl0aXZlc1tfaVByaW1pdGl2ZV07XHJcblxyXG4gICAgICBpZiAoZ2x0ZlByaW1pdGl2ZS5pbmRpY2VzID09IHVuZGVmaW5lZClcclxuICAgICAgICBEZWJ1Zy53YXJuKGAke3RoaXN9OiBNZXNoIHdpdGggaW5kZXggJHtfaU1lc2h9IHByaW1pdGl2ZSAke19pUHJpbWl0aXZlfSBoYXMgbm8gaW5kaWNlcy4gRlVER0UgZG9lcyBub3Qgc3VwcG9ydCBub24taW5kZXhlZCBtZXNoZXMuYCk7XHJcblxyXG4gICAgICBpZiAoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLlBPU0lUSU9OID09IHVuZGVmaW5lZClcclxuICAgICAgICBEZWJ1Zy53YXJuKGAke3RoaXN9OiBNZXNoIHdpdGggaW5kZXggJHtfaU1lc2h9IHByaW1pdGl2ZSAke19pUHJpbWl0aXZlfSBoYXMgbm8gcG9zaXRpb24gYXR0cmlidXRlLiBQcmltaXRpdmUgd2lsbCBiZSBpZ25vcmVkLmApO1xyXG5cclxuICAgICAgaWYgKGdsdGZQcmltaXRpdmUubW9kZSAhPSB1bmRlZmluZWQgJiYgZ2x0ZlByaW1pdGl2ZS5tb2RlICE9IEdMVEYuTUVTSF9QUklNSVRJVkVfTU9ERS5UUklBTkdMRVMpXHJcbiAgICAgICAgRGVidWcud2FybihgJHt0aGlzfTogTWVzaCB3aXRoIGluZGV4ICR7X2lNZXNofSBwcmltaXRpdmUgJHtfaVByaW1pdGl2ZX0gaGFzIHRvcG9sb2d5IHR5cGUgbW9kZSAke0dMVEYuTUVTSF9QUklNSVRJVkVfTU9ERVtnbHRmUHJpbWl0aXZlLm1vZGVdfS4gRlVER0Ugb25seSBzdXBwb3J0cyAke0dMVEYuTUVTSF9QUklNSVRJVkVfTU9ERVs0XX0uYCk7XHJcblxyXG4gICAgICBjaGVja01heFN1cHBvcnQodGhpcywgXCJURVhDT09SRFwiLCAyKTtcclxuICAgICAgY2hlY2tNYXhTdXBwb3J0KHRoaXMsIFwiQ09MT1JcIiwgMSk7XHJcbiAgICAgIGNoZWNrTWF4U3VwcG9ydCh0aGlzLCBcIkpPSU5UU1wiLCAxKTtcclxuICAgICAgY2hlY2tNYXhTdXBwb3J0KHRoaXMsIFwiV0VJR0hUU1wiLCAxKTtcclxuXHJcbiAgICAgIGxldCBwb3NpdGlvbnM6IEZsb2F0MzJBcnJheSwgaW5kaWNlczogVWludDE2QXJyYXk7XHJcbiAgICAgIGxldCBub3JtYWxzOiBGbG9hdDMyQXJyYXksIHRhbmdlbnRzOiBGbG9hdDMyQXJyYXk7XHJcbiAgICAgIGxldCBjb2xvcnM6IEZsb2F0MzJBcnJheSwgdGV4dHVyZVVWczogRmxvYXQzMkFycmF5O1xyXG4gICAgICBsZXQgYm9uZXM6IFVpbnQ4QXJyYXksIHdlaWdodHM6IEZsb2F0MzJBcnJheTtcclxuXHJcbiAgICAgIGlmIChnbHRmUHJpbWl0aXZlLmluZGljZXMgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaW5kaWNlcyA9IGF3YWl0IHRoaXMuZ2V0VmVydGV4SW5kaWNlcyhnbHRmUHJpbWl0aXZlLmluZGljZXMpO1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAgICAgICBjb25zdCB0ZW1wOiBudW1iZXIgPSBpbmRpY2VzW2kgKyAyXTtcclxuICAgICAgICAgIGluZGljZXNbaSArIDJdID0gaW5kaWNlc1tpICsgMF07XHJcbiAgICAgICAgICBpbmRpY2VzW2kgKyAwXSA9IGluZGljZXNbaSArIDFdO1xyXG4gICAgICAgICAgaW5kaWNlc1tpICsgMV0gPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBEZWJ1Zy53YXJuKGAke3RoaXN9OiBNZXNoIHdpdGggaW5kZXggJHtfaU1lc2h9IHByaW1pdGl2ZSAke19pUHJpbWl0aXZlfSBoYXMgbm8gaW5kaWNlcy4gRlVER0UgZG9lcyBub3Qgc3VwcG9ydCBub24taW5kZXhlZCBtZXNoZXMuYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuUE9TSVRJT04gIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHBvc2l0aW9ucyA9IGF3YWl0IHRoaXMuZ2V0RmxvYXQzMkFycmF5KGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcy5QT1NJVElPTik7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBEZWJ1Zy53YXJuKGAke3RoaXN9OiBNZXNoIHdpdGggaW5kZXggJHtfaU1lc2h9IHByaW1pdGl2ZSAke19pUHJpbWl0aXZlfSBoYXMgbm8gcG9zaXRpb24gYXR0cmlidXRlLiBQcmltaXRpdmUgd2lsbCBiZSBpZ25vcmVkLmApO1xyXG5cclxuICAgICAgaWYgKGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcy5OT1JNQUwgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIG5vcm1hbHMgPSBhd2FpdCB0aGlzLmdldEZsb2F0MzJBcnJheShnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuTk9STUFMKTtcclxuXHJcbiAgICAgIGlmIChnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuVEFOR0VOVCAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGFuZ2VudHMgPSBhd2FpdCB0aGlzLmdldEZsb2F0MzJBcnJheShnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuVEFOR0VOVCk7XHJcblxyXG4gICAgICBpZiAoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLlRFWENPT1JEXzEgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRleHR1cmVVVnMgPSBhd2FpdCB0aGlzLmdldEZsb2F0MzJBcnJheShnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuVEVYQ09PUkRfMSk7XHJcbiAgICAgIGVsc2UgaWYgKGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcy5URVhDT09SRF8wICE9IHVuZGVmaW5lZClcclxuICAgICAgICB0ZXh0dXJlVVZzID0gYXdhaXQgdGhpcy5nZXRGbG9hdDMyQXJyYXkoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLlRFWENPT1JEXzApO1xyXG5cclxuICAgICAgaWYgKGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcy5DT0xPUl8wICE9IHVuZGVmaW5lZClcclxuICAgICAgICBjb2xvcnMgPSBhd2FpdCB0aGlzLmdldFZlcnRleENvbG9ycyhnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuQ09MT1JfMCk7XHJcblxyXG4gICAgICBpZiAoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLkpPSU5UU18wICE9IHVuZGVmaW5lZCAmJiBnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuV0VJR0hUU18wICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGJvbmVzID0gYXdhaXQgdGhpcy5nZXRCb25lSW5kaWNlcyhnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuSk9JTlRTXzApO1xyXG4gICAgICAgIHdlaWdodHMgPSBhd2FpdCB0aGlzLmdldEZsb2F0MzJBcnJheShnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuV0VJR0hUU18wKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbWVzaDogTWVzaCA9IF9tZXNoID8/IG5ldyBNZXNoR0xURigpO1xyXG4gICAgICBtZXNoLm5hbWUgPSBnbHRmTWVzaC5uYW1lO1xyXG4gICAgICBpZiAobWVzaCBpbnN0YW5jZW9mIE1lc2hHTFRGKSB7XHJcbiAgICAgICAgbWVzaC5pUHJpbWl0aXZlID0gX2lQcmltaXRpdmU7XHJcbiAgICAgICAgbWVzaC51cmwgPSB0aGlzLiN1cmw7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF9tZXNoKSB7XHJcbiAgICAgICAgX21lc2guY2xlYXIoKTtcclxuICAgICAgICBfbWVzaC5mYWNlcyA9IFtdO1xyXG4gICAgICAgIF9tZXNoLnZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICAvLyBDcmVhdGUgbWVzaCB2ZXJ0aWNlcyBhbmQgZmFjZXMgc28gdGhhdCBub3JtYWxzIGFuZCB0YW5nZW50cyBjYW4gYmUgY2FsY3VsYXRlZCBpZiBtaXNzaW5nLiBJZiB0aGV5IGFyZSBub3QgbWlzc2luZyB0aGlzIGNvdWxkIGJlIG9taXR0ZWQuXHJcbiAgICAgIGZvciAobGV0IGlWZWN0b3IyOiBudW1iZXIgPSAwLCBpVmVjdG9yMzogbnVtYmVyID0gMCwgaVZlY3RvcjQ6IG51bWJlciA9IDA7IGlWZWN0b3IzIDwgcG9zaXRpb25zPy5sZW5ndGg7IGlWZWN0b3IyICs9IDIsIGlWZWN0b3IzICs9IDMsIGlWZWN0b3I0ICs9IDQpIHtcclxuICAgICAgICBtZXNoLnZlcnRpY2VzLnB1c2goXHJcbiAgICAgICAgICBuZXcgVmVydGV4KFxyXG4gICAgICAgICAgICBuZXcgVmVjdG9yMyhwb3NpdGlvbnNbaVZlY3RvcjMgKyAwXSwgcG9zaXRpb25zW2lWZWN0b3IzICsgMV0sIHBvc2l0aW9uc1tpVmVjdG9yMyArIDJdKSxcclxuICAgICAgICAgICAgdGV4dHVyZVVWcyA/XHJcbiAgICAgICAgICAgICAgbmV3IFZlY3RvcjIodGV4dHVyZVVWc1tpVmVjdG9yMiArIDBdLCB0ZXh0dXJlVVZzW2lWZWN0b3IyICsgMV0pIDpcclxuICAgICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIG5vcm1hbHMgP1xyXG4gICAgICAgICAgICAgIG5ldyBWZWN0b3IzKG5vcm1hbHNbaVZlY3RvcjMgKyAwXSwgbm9ybWFsc1tpVmVjdG9yMyArIDFdLCBub3JtYWxzW2lWZWN0b3IzICsgMl0pIDpcclxuICAgICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHRhbmdlbnRzID9cclxuICAgICAgICAgICAgICBuZXcgVmVjdG9yNCh0YW5nZW50c1tpVmVjdG9yNCArIDBdLCB0YW5nZW50c1tpVmVjdG9yNCArIDFdLCB0YW5nZW50c1tpVmVjdG9yNCArIDJdLCB0YW5nZW50c1tpVmVjdG9yNCArIDNdKSA6XHJcbiAgICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjb2xvcnMgP1xyXG4gICAgICAgICAgICAgIG5ldyBDb2xvcihjb2xvcnNbaVZlY3RvcjQgKyAwXSwgY29sb3JzW2lWZWN0b3I0ICsgMV0sIGNvbG9yc1tpVmVjdG9yNCArIDJdLCBjb2xvcnNbaVZlY3RvcjQgKyAzXSkgOlxyXG4gICAgICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYm9uZXMgJiYgd2VpZ2h0cyA/XHJcbiAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgeyBpbmRleDogYm9uZXNbaVZlY3RvcjQgKyAwXSwgd2VpZ2h0OiB3ZWlnaHRzW2lWZWN0b3I0ICsgMF0gfSxcclxuICAgICAgICAgICAgICAgIHsgaW5kZXg6IGJvbmVzW2lWZWN0b3I0ICsgMV0sIHdlaWdodDogd2VpZ2h0c1tpVmVjdG9yNCArIDFdIH0sXHJcbiAgICAgICAgICAgICAgICB7IGluZGV4OiBib25lc1tpVmVjdG9yNCArIDJdLCB3ZWlnaHQ6IHdlaWdodHNbaVZlY3RvcjQgKyAyXSB9LFxyXG4gICAgICAgICAgICAgICAgeyBpbmRleDogYm9uZXNbaVZlY3RvcjQgKyAzXSwgd2VpZ2h0OiB3ZWlnaHRzW2lWZWN0b3I0ICsgM10gfVxyXG4gICAgICAgICAgICAgIF0gOlxyXG4gICAgICAgICAgICAgIHVuZGVmaW5lZFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IGlGYWNlVmVydGV4SW5kZXg6IG51bWJlciA9IDA7IGlGYWNlVmVydGV4SW5kZXggPCBpbmRpY2VzPy5sZW5ndGg7IGlGYWNlVmVydGV4SW5kZXggKz0gMykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBtZXNoLmZhY2VzLnB1c2gobmV3IEZhY2UoXHJcbiAgICAgICAgICAgIG1lc2gudmVydGljZXMsXHJcbiAgICAgICAgICAgIGluZGljZXNbaUZhY2VWZXJ0ZXhJbmRleCArIDBdLFxyXG4gICAgICAgICAgICBpbmRpY2VzW2lGYWNlVmVydGV4SW5kZXggKyAxXSxcclxuICAgICAgICAgICAgaW5kaWNlc1tpRmFjZVZlcnRleEluZGV4ICsgMl1cclxuICAgICAgICAgICkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKF9lOiB1bmtub3duKSB7XHJcbiAgICAgICAgICBEZWJ1Zy5mdWRnZShcIkZhY2UgZXhjbHVkZWRcIiwgKDxFcnJvcj5fZSkubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgbWVzaC5yZW5kZXJNZXNoLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcclxuICAgICAgbWVzaC5yZW5kZXJNZXNoLmluZGljZXMgPSBpbmRpY2VzO1xyXG4gICAgICBtZXNoLnJlbmRlck1lc2gubm9ybWFscyA9IG5vcm1hbHM7XHJcbiAgICAgIG1lc2gucmVuZGVyTWVzaC50YW5nZW50cyA9IHRhbmdlbnRzO1xyXG4gICAgICBtZXNoLnJlbmRlck1lc2gudGV4dHVyZVVWcyA9IHRleHR1cmVVVnM7XHJcbiAgICAgIG1lc2gucmVuZGVyTWVzaC5jb2xvcnMgPSBjb2xvcnM7XHJcbiAgICAgIG1lc2gucmVuZGVyTWVzaC5ib25lcyA9IGJvbmVzO1xyXG4gICAgICBtZXNoLnJlbmRlck1lc2gud2VpZ2h0cyA9IHdlaWdodHM7XHJcblxyXG4gICAgICBpZiAoIV9tZXNoKSB7XHJcbiAgICAgICAgUHJvamVjdC5kZXJlZ2lzdGVyKG1lc2gpO1xyXG4gICAgICAgIC8vIG1lc2guaWRSZXNvdXJjZSA9IGlkO1xyXG4gICAgICAgIHRoaXMuI3Jlc291cmNlc1tpZF0gPSBtZXNoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbWVzaDtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNoZWNrTWF4U3VwcG9ydChfbG9hZGVyOiBHTFRGTG9hZGVyLCBfY2hlY2s6IHN0cmluZywgX21heDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcykuZmlsdGVyKChfa2V5OiBzdHJpbmcpID0+IF9rZXkuc3RhcnRzV2l0aChfY2hlY2spKS5sZW5ndGggPiBfbWF4KVxyXG4gICAgICAgICAgRGVidWcud2FybihgJHtfbG9hZGVyfTogTWVzaCB3aXRoIGluZGV4ICR7X2lNZXNofSBwcmltaXRpdmUgJHtfaVByaW1pdGl2ZX0gaGFzIG1vcmUgdGhhbiAke19tYXh9IHNldHMgb2YgJyR7X2NoZWNrfScgYXNzb2NpYXRlZCB3aXRoIGl0LiBGVUdERSBvbmx5IHN1cHBvcnRzIHVwIHRvICR7X21heH0gJHtfY2hlY2t9IHNldHMgcGVyIHByaW1pdGl2ZS5gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3Qge0BsaW5rIE1hdGVyaWFsR0xURn0gd2l0aCB0aGUgZ2l2ZW4gbWF0ZXJpYWwgbmFtZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldE1hdGVyaWFsKF9uYW1lOiBzdHJpbmcpOiBQcm9taXNlPE1hdGVyaWFsPjtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIE1hdGVyaWFsfSBmb3IgdGhlIGdpdmVuIG1hdGVyaWFsIGluZGV4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWF0ZXJpYWwoX2lNYXRlcmlhbDogbnVtYmVyKTogUHJvbWlzZTxNYXRlcmlhbD47XHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgbWF0ZXJpYWwgZnJvbSB0aGUgZ2xURiBmaWxlIGludG8gdGhlIGdpdmVuIHtAbGluayBNYXRlcmlhbH0uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldE1hdGVyaWFsPFQgZXh0ZW5kcyBNYXRlcmlhbD4oX2lNYXRlcmlhbDogbnVtYmVyIHwgc3RyaW5nLCBfbWF0ZXJpYWw/OiBULCBfc2tpbj86IGJvb2xlYW4sIF9mbGF0PzogYm9vbGVhbik6IFByb21pc2U8VD47XHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWF0ZXJpYWwoX2lNYXRlcmlhbDogbnVtYmVyIHwgc3RyaW5nLCBfbWF0ZXJpYWw/OiBNYXRlcmlhbCwgX3NraW46IGJvb2xlYW4gPSBmYWxzZSwgX2ZsYXQ6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8TWF0ZXJpYWw+IHtcclxuICAgICAgX2lNYXRlcmlhbCA9IHRoaXMuZ2V0SW5kZXgoX2lNYXRlcmlhbCwgdGhpcy4jZ2x0Zi5tYXRlcmlhbHMpO1xyXG5cclxuICAgICAgaWYgKF9pTWF0ZXJpYWwgPT0gLTEpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICBjb25zdCBpZDogc3RyaW5nID0gYCR7TWF0ZXJpYWwubmFtZX18JHtfaU1hdGVyaWFsfWA7XHJcblxyXG4gICAgICBpZiAodGhpcy4jcmVzb3VyY2VzW2lkXSAmJiAhX21hdGVyaWFsKVxyXG4gICAgICAgIHJldHVybiA8TWF0ZXJpYWw+dGhpcy4jcmVzb3VyY2VzW2lkXTtcclxuXHJcbiAgICAgIC8vIFRPRE86IGluIHRoZSBmdXR1cmUgY3JlYXRlIGFuIGFwcHJvcHJpYXRlIHNoYWRlciBiYXNlZCBvbiB0aGUgZ2xURiBtYXRlcmlhbCBwcm9wZXJ0aWVzXHJcbiAgICAgIGNvbnN0IGdsdGZNYXRlcmlhbDogR0xURi5NYXRlcmlhbCA9IHRoaXMuI2dsdGYubWF0ZXJpYWxzW19pTWF0ZXJpYWxdO1xyXG5cclxuICAgICAgaWYgKCFnbHRmTWF0ZXJpYWwpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXN9OiBDb3VsZG4ndCBmaW5kIG1hdGVyaWFsIHdpdGggaW5kZXggJHtfaU1hdGVyaWFsfS5gKTtcclxuXHJcbiAgICAgIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBvdGhlciBnbFRGIG1hdGVyaWFsIHByb3BlcnRpZXM6IGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvZ2xURi9zcGVjcy8yLjAvZ2xURi0yLjAuaHRtbCNyZWZlcmVuY2UtbWF0ZXJpYWxcclxuICAgICAgLy8gZS5nLiBvY2NsdXNpb24gYW5kIGVtaXNzaXZlIHRleHR1cmVzOyBkb3VibGVTaWRlZFxyXG4gICAgICBjb25zdCBnbHRmQmFzZUNvbG9yRmFjdG9yOiBudW1iZXJbXSA9IGdsdGZNYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcz8uYmFzZUNvbG9yRmFjdG9yID8/IFsxLCAxLCAxLCAxXTtcclxuICAgICAgY29uc3QgZ2x0Zk1ldGFsbGljRmFjdG9yOiBudW1iZXIgPSBnbHRmTWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3M/Lm1ldGFsbGljRmFjdG9yID8/IDE7XHJcbiAgICAgIGNvbnN0IGdsdGZSb3VnaG5lc3NGYWN0b3I6IG51bWJlciA9IGdsdGZNYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcz8ucm91Z2huZXNzRmFjdG9yID8/IDE7XHJcbiAgICAgIGNvbnN0IGdsdGZFbWlzc2l2ZUZhY3RvcjogbnVtYmVyW10gPSBnbHRmTWF0ZXJpYWwuZW1pc3NpdmVGYWN0b3IgPz8gWzAsIDAsIDBdO1xyXG5cclxuICAgICAgY29uc3QgZ2x0ZkJhc2VDb2xvclRleHR1cmU6IEdMVEYuVGV4dHVyZUluZm8gPSBnbHRmTWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3M/LmJhc2VDb2xvclRleHR1cmU7XHJcbiAgICAgIGNvbnN0IGdsdGZOb3JtYWxUZXh0dXJlOiBHTFRGLk1hdGVyaWFsTm9ybWFsVGV4dHVyZUluZm8gPSBnbHRmTWF0ZXJpYWwubm9ybWFsVGV4dHVyZTtcclxuXHJcbiAgICAgIC8vIFRoZSBkaWZmdXNlIGNvbnRyaWJ1dGlvbiBpbiB0aGUgUGhvbmcgc2hhZGluZyBtb2RlbC4gUmVwcmVzZW50cyBob3cgbXVjaCBsaWdodCBpcyBzY2F0dGVyZWQgaW4gZGlmZmVyZW50IGRpcmVjdGlvbnMgZHVlIHRvIHRoZSBtYXRlcmlhbCdzIHN1cmZhY2UgcHJvcGVydGllcy5cclxuICAgICAgY29uc3QgZGlmZnVzZTogbnVtYmVyID0gMTtcclxuICAgICAgLy8gVGhlIHNoaW5pbmVzcyBvZiB0aGUgbWF0ZXJpYWwuIEluZmx1ZW5jZXMgdGhlIHNoYXJwbmVzcyBvciBicm9hZG5lc3Mgb2YgdGhlIHNwZWN1bGFyIGhpZ2hsaWdodC4gSGlnaGVyIHNwZWN1bGFyIHZhbHVlcyByZXN1bHQgaW4gYSBzaGFycGVyIGFuZCBtb3JlIGNvbmNlbnRyYXRlZCBzcGVjdWxhciBoaWdobGlnaHQuXHJcbiAgICAgIGNvbnN0IHNwZWN1bGFyOiBudW1iZXIgPSAxLjggKiAoMSAtIGdsdGZSb3VnaG5lc3NGYWN0b3IpICsgMC42ICogZ2x0Zk1ldGFsbGljRmFjdG9yO1xyXG4gICAgICAvLyBUaGUgc3RyZW5ndGgvaW50ZW5zaXR5IG9mIHRoZSBzcGVjdWxhciByZWZsZWN0aW9uXHJcbiAgICAgIGNvbnN0IGludGVuc2l0eTogbnVtYmVyID0gMC43ICogKDEgLSBnbHRmUm91Z2huZXNzRmFjdG9yKSArIGdsdGZNZXRhbGxpY0ZhY3RvcjtcclxuICAgICAgLy8gSW5mbHVlbmNlcyBob3cgbXVjaCB0aGUgbWF0ZXJpYWwncyBjb2xvciBhZmZlY3RzIHRoZSBzcGVjdWxhciByZWZsZWN0aW9uLiBXaGVuIG1ldGFsbGljIGlzIGhpZ2hlciwgdGhlIHNwZWN1bGFyIHJlZmxlY3Rpb24gdGFrZXMgb24gdGhlIGNvbG9yIG9mIHRoZSBtYXRlcmlhbCwgY3JlYXRpbmcgYSBtZXRhbGxpYyBhcHBlYXJhbmNlLiBSYW5nZSBmcm9tIDAuMCB0byAxLjAuXHJcbiAgICAgIGNvbnN0IG1ldGFsbGljOiBudW1iZXIgPSBnbHRmTWV0YWxsaWNGYWN0b3I7XHJcblxyXG4gICAgICBjb25zdCBpc0xpdDogYm9vbGVhbiA9IGdsdGZFbWlzc2l2ZUZhY3RvclswXSA+IDAgfHwgZ2x0ZkVtaXNzaXZlRmFjdG9yWzFdID4gMCB8fCBnbHRmRW1pc3NpdmVGYWN0b3JbMl0gPiAwO1xyXG4gICAgICBjb25zdCBjb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoLi4uZ2x0ZkJhc2VDb2xvckZhY3Rvcik7XHJcbiAgICAgIGlmIChpc0xpdClcclxuICAgICAgICBjb2xvci5hZGQobmV3IENvbG9yKC4uLmdsdGZFbWlzc2l2ZUZhY3RvciwgMCkpO1xyXG4gICAgICBjb25zdCBjb2F0OiBDb2F0ID0gZ2x0ZkJhc2VDb2xvclRleHR1cmUgP1xyXG4gICAgICAgIGlzTGl0ID8gbmV3IENvYXRUZXh0dXJlZChjb2xvciwgYXdhaXQgdGhpcy5nZXRUZXh0dXJlKGdsdGZCYXNlQ29sb3JUZXh0dXJlLmluZGV4KSkgOlxyXG4gICAgICAgICAgZ2x0Zk5vcm1hbFRleHR1cmUgP1xyXG4gICAgICAgICAgICBuZXcgQ29hdFJlbWlzc2l2ZVRleHR1cmVkTm9ybWFscyhjb2xvciwgYXdhaXQgdGhpcy5nZXRUZXh0dXJlKGdsdGZCYXNlQ29sb3JUZXh0dXJlLmluZGV4KSwgYXdhaXQgdGhpcy5nZXRUZXh0dXJlKGdsdGZOb3JtYWxUZXh0dXJlLmluZGV4KSwgZGlmZnVzZSwgc3BlY3VsYXIsIGludGVuc2l0eSwgbWV0YWxsaWMpIDpcclxuICAgICAgICAgICAgbmV3IENvYXRSZW1pc3NpdmVUZXh0dXJlZChjb2xvciwgYXdhaXQgdGhpcy5nZXRUZXh0dXJlKGdsdGZCYXNlQ29sb3JUZXh0dXJlLmluZGV4KSwgZGlmZnVzZSwgc3BlY3VsYXIsIGludGVuc2l0eSwgbWV0YWxsaWMpIDpcclxuICAgICAgICBpc0xpdCA/IG5ldyBDb2F0Q29sb3JlZChjb2xvcikgOiBuZXcgQ29hdFJlbWlzc2l2ZShjb2xvciwgZGlmZnVzZSwgc3BlY3VsYXIsIGludGVuc2l0eSwgbWV0YWxsaWMpO1xyXG5cclxuICAgICAgaWYgKGdsdGZNYXRlcmlhbC5hbHBoYUN1dG9mZiAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgY29hdC5hbHBoYUNsaXAgPSBnbHRmTWF0ZXJpYWwuYWxwaGFDdXRvZmY7XHJcblxyXG4gICAgICBsZXQgc2hhZGVyOiB0eXBlb2YgU2hhZGVyO1xyXG4gICAgICBpZiAoX2ZsYXQpIHsgLy8gVE9ETzogbWFrZSBmbGF0IGEgZmxhZyBpbiB0aGUgbWF0ZXJpYWwgc28gdGhhdCB3ZSBjYW4gaGF2ZSBmbGF0IG1lc2ggd2l0aCBwaG9uZyBzaGFkaW5nIGdyYWRpZW50c1xyXG4gICAgICAgIHNoYWRlciA9IGdsdGZCYXNlQ29sb3JUZXh0dXJlID9cclxuICAgICAgICAgIChfc2tpbiA/IFNoYWRlckZsYXRUZXh0dXJlZFNraW4gOiBTaGFkZXJGbGF0VGV4dHVyZWQpIDpcclxuICAgICAgICAgIChfc2tpbiA/IFNoYWRlckZsYXRTa2luIDogU2hhZGVyRmxhdCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNMaXQpIHtcclxuICAgICAgICBzaGFkZXIgPSBnbHRmQmFzZUNvbG9yVGV4dHVyZSA/XHJcbiAgICAgICAgICAoX3NraW4gPyBTaGFkZXJMaXRUZXh0dXJlZFNraW4gOiBTaGFkZXJMaXRUZXh0dXJlZCkgOlxyXG4gICAgICAgICAgKF9za2luID8gU2hhZGVyTGl0U2tpbiA6IFNoYWRlckxpdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2hhZGVyID0gZ2x0ZkJhc2VDb2xvclRleHR1cmUgP1xyXG4gICAgICAgICAgZ2x0Zk5vcm1hbFRleHR1cmUgP1xyXG4gICAgICAgICAgICAoX3NraW4gPyBTaGFkZXJQaG9uZ1RleHR1cmVkTm9ybWFsc1NraW4gOiBTaGFkZXJQaG9uZ1RleHR1cmVkTm9ybWFscykgOlxyXG4gICAgICAgICAgICAoX3NraW4gPyBTaGFkZXJQaG9uZ1RleHR1cmVkU2tpbiA6IFNoYWRlclBob25nVGV4dHVyZWQpIDpcclxuICAgICAgICAgIChfc2tpbiA/IFNoYWRlclBob25nU2tpbiA6IFNoYWRlclBob25nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbWF0ZXJpYWw6IE1hdGVyaWFsID0gX21hdGVyaWFsID8/IG5ldyBNYXRlcmlhbEdMVEYoZ2x0Zk1hdGVyaWFsLm5hbWUpO1xyXG4gICAgICBtYXRlcmlhbC5uYW1lID0gZ2x0Zk1hdGVyaWFsLm5hbWU7XHJcbiAgICAgIG1hdGVyaWFsLmNvYXQgPSBjb2F0O1xyXG5cclxuICAgICAgUmVmbGVjdC5zZXQobWF0ZXJpYWwsIFwic2hhZGVyVHlwZVwiLCBzaGFkZXIpO1xyXG4gICAgICAvLyBtYXRlcmlhbC5zZXRTaGFkZXIoc2hhZGVyKTtcclxuICAgICAgaWYgKG1hdGVyaWFsIGluc3RhbmNlb2YgTWF0ZXJpYWxHTFRGKVxyXG4gICAgICAgIG1hdGVyaWFsLnVybCA9IHRoaXMuI3VybDtcclxuXHJcbiAgICAgIGlmICghX21hdGVyaWFsKSB7XHJcbiAgICAgICAgUHJvamVjdC5kZXJlZ2lzdGVyKG1hdGVyaWFsKTtcclxuICAgICAgICB0aGlzLiNyZXNvdXJjZXNbaWRdID0gbWF0ZXJpYWw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtYXRlcmlhbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBUZXh0dXJlfSBmb3IgdGhlIGdpdmVuIHRleHR1cmUgaW5kZXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRUZXh0dXJlKF9pVGV4dHVyZTogbnVtYmVyKTogUHJvbWlzZTxUZXh0dXJlPiB7XHJcbiAgICAgIGNvbnN0IGlkOiBzdHJpbmcgPSBgJHtUZXh0dXJlLm5hbWV9fCR7X2lUZXh0dXJlfWA7XHJcblxyXG4gICAgICBpZiAodGhpcy4jcmVzb3VyY2VzW2lkXSlcclxuICAgICAgICByZXR1cm4gPFRleHR1cmU+dGhpcy4jcmVzb3VyY2VzW2lkXTtcclxuXHJcbiAgICAgIGNvbnN0IGdsdGZUZXh0dXJlOiBHTFRGLlRleHR1cmUgPSB0aGlzLiNnbHRmLnRleHR1cmVzW19pVGV4dHVyZV07XHJcbiAgICAgIGNvbnN0IGdsdGZTYW1wbGVyOiBHTFRGLlNhbXBsZXIgPSB0aGlzLiNnbHRmLnNhbXBsZXJzPy5bZ2x0ZlRleHR1cmUuc2FtcGxlcl07XHJcbiAgICAgIGNvbnN0IGdsdGZJbWFnZTogR0xURi5JbWFnZSA9IHRoaXMuI2dsdGYuaW1hZ2VzPy5bZ2x0ZlRleHR1cmUuc291cmNlXTtcclxuXHJcbiAgICAgIGlmIChnbHRmSW1hZ2UgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgRGVidWcud2FybihgJHt0aGlzfTogVGV4dHVyZSB3aXRoIGluZGV4ICR7X2lUZXh0dXJlfSBoYXMgbm8gaW1hZ2UuYCk7XHJcbiAgICAgICAgcmV0dXJuIFRleHR1cmVEZWZhdWx0LmNvbG9yO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgdXJsOiBzdHJpbmcgPSBuZXcgVVJMKGdsdGZJbWFnZS51cmksIG5ldyBVUkwodGhpcy4jdXJsLCBQcm9qZWN0LmJhc2VVUkwpKS50b1N0cmluZygpO1xyXG5cclxuICAgICAgaWYgKCFnbHRmSW1hZ2UudXJpICYmIGdsdGZJbWFnZS5idWZmZXJWaWV3KSB7XHJcbiAgICAgICAgLy8gVE9ETzogdGhpcyBpcyBkdXBsaWNhdGUgY29kZSBmcm9tIGdldEJ1ZmZlckRhdGEsIG1heWJlIHJlZmFjdG9yIGdldEJ1ZmZlckRhdGEgdG8gaGFuZGxlIGJ1ZmZlclZpZXdJbmRleCBpbnB1dFxyXG4gICAgICAgIGNvbnN0IGdsdGZCdWZmZXJWaWV3OiBHTFRGLkJ1ZmZlclZpZXcgPSB0aGlzLiNnbHRmLmJ1ZmZlclZpZXdzW2dsdGZJbWFnZS5idWZmZXJWaWV3XTtcclxuXHJcbiAgICAgICAgY29uc3QgYnVmZmVyOiBBcnJheUJ1ZmZlciA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyKGdsdGZCdWZmZXJWaWV3LmJ1ZmZlcik7XHJcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldDogbnVtYmVyID0gZ2x0ZkJ1ZmZlclZpZXcuYnl0ZU9mZnNldCB8fCAwO1xyXG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGg6IG51bWJlciA9IGdsdGZCdWZmZXJWaWV3LmJ5dGVMZW5ndGggfHwgMDtcclxuXHJcbiAgICAgICAgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihcclxuICAgICAgICAgIFtuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggLyBVaW50OEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKV0sXHJcbiAgICAgICAgICB7IHR5cGU6IGdsdGZJbWFnZS5taW1lVHlwZSB9XHJcbiAgICAgICAgKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHRleHR1cmU6IFRleHR1cmVJbWFnZSA9IG5ldyBUZXh0dXJlSW1hZ2UoKTtcclxuICAgICAgYXdhaXQgdGV4dHVyZS5sb2FkKHVybCk7XHJcblxyXG4gICAgICBpZiAoZ2x0ZlNhbXBsZXIpIHtcclxuICAgICAgICBnbHRmU2FtcGxlci5tYWdGaWx0ZXIgPSBnbHRmU2FtcGxlci5tYWdGaWx0ZXIgPz8gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUOyAvLyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgZ2x0ZlNhbXBsZXIubWluRmlsdGVyID0gZ2x0ZlNhbXBsZXIubWluRmlsdGVyID8/IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVDsgLy8gZGVmYXVsdCB2YWx1ZVxyXG5cclxuICAgICAgICBpZiAoZ2x0ZlNhbXBsZXIubWFnRmlsdGVyID09IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCAmJiBnbHRmU2FtcGxlci5taW5GaWx0ZXIgPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUKVxyXG4gICAgICAgICAgdGV4dHVyZS5taXBtYXAgPSBNSVBNQVAuQ1JJU1A7XHJcbiAgICAgICAgZWxzZSBpZiAoZ2x0ZlNhbXBsZXIubWFnRmlsdGVyID09IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCAmJiBnbHRmU2FtcGxlci5taW5GaWx0ZXIgPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUX01JUE1BUF9MSU5FQVIpXHJcbiAgICAgICAgICB0ZXh0dXJlLm1pcG1hcCA9IE1JUE1BUC5NRURJVU07XHJcbiAgICAgICAgZWxzZSBpZiAoZ2x0ZlNhbXBsZXIubWFnRmlsdGVyID09IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTElORUFSICYmIGdsdGZTYW1wbGVyLm1pbkZpbHRlciA9PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkxJTkVBUl9NSVBNQVBfTElORUFSKVxyXG4gICAgICAgICAgdGV4dHVyZS5taXBtYXAgPSBNSVBNQVAuQkxVUlJZO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIERlYnVnLndhcm4oYCR7dGhpc306IFRleHR1cmUgd2l0aCBpbmRleCAke19pVGV4dHVyZX0gaGFzIGEgbWFnRmlsdGVyIGFuZCBtaW5GaWx0ZXIgb2YgJyR7Z2V0V2ViR0xQYXJhbWV0ZXJOYW1lKGdsdGZTYW1wbGVyLm1hZ0ZpbHRlcil9JyBhbmQgJyR7Z2V0V2ViR0xQYXJhbWV0ZXJOYW1lKGdsdGZTYW1wbGVyLm1pbkZpbHRlcil9JyByZXNwZWN0aXZlbHkuIEZVREdFIG9ubHkgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBjb21iaW5hdGlvbnM6IE5FQVJFU1QgYW5kIE5FQVJFU1QgfCBORUFSRVNUIGFuZCBORUFSRVNUX01JUE1BUF9MSU5FQVIgfCBMSU5FQVIgYW5kIExJTkVBUl9NSVBNQVBfTElORUFSLmApO1xyXG5cclxuICAgICAgICBnbHRmU2FtcGxlci53cmFwUyA9IGdsdGZTYW1wbGVyLndyYXBTID8/IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkVQRUFUOyAvLyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgZ2x0ZlNhbXBsZXIud3JhcFQgPSBnbHRmU2FtcGxlci53cmFwVCA/PyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJFUEVBVDsgLy8gZGVmYXVsdCB2YWx1ZVxyXG5cclxuICAgICAgICBpZiAoZ2x0ZlNhbXBsZXIud3JhcFMgPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SRVBFQVQgJiYgZ2x0ZlNhbXBsZXIud3JhcFQgPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SRVBFQVQpXHJcbiAgICAgICAgICB0ZXh0dXJlLndyYXAgPSBXUkFQLlJFUEVBVDtcclxuICAgICAgICBlbHNlIGlmIChnbHRmU2FtcGxlci53cmFwUyA9PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNMQU1QX1RPX0VER0UgJiYgZ2x0ZlNhbXBsZXIud3JhcFQgPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKVxyXG4gICAgICAgICAgdGV4dHVyZS53cmFwID0gV1JBUC5DTEFNUDtcclxuICAgICAgICBlbHNlIGlmIChnbHRmU2FtcGxlci53cmFwUyA9PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1JUlJPUkVEX1JFUEVBVCAmJiBnbHRmU2FtcGxlci53cmFwVCA9PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1JUlJPUkVEX1JFUEVBVClcclxuICAgICAgICAgIHRleHR1cmUud3JhcCA9IFdSQVAuTUlSUk9SO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIERlYnVnLndhcm4oYCR7dGhpc306IFRleHR1cmUgd2l0aCBpbmRleCAke19pVGV4dHVyZX0gaGFzIGEgd3JhcFMgYW5kIHdyYXBUIG9mICcke2dldFdlYkdMUGFyYW1ldGVyTmFtZShnbHRmU2FtcGxlci53cmFwUyl9JyBhbmQgJyR7Z2V0V2ViR0xQYXJhbWV0ZXJOYW1lKGdsdGZTYW1wbGVyLndyYXBUKX0nIHJlc3BlY3RpdmVseS4gRlVER0Ugb25seSBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIGNvbWJpbmF0aW9uczogUkVQRUFUIGFuZCBSRVBFQVQgfCBDTEFNUF9UT19FREdFIGFuZCBDTEFNUF9UT19FREdFIHwgTUlSUk9SRURfUkVQRUFUIGFuZCBNSVJST1JFRF9SRVBFQVQuYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFByb2plY3QuZGVyZWdpc3Rlcih0ZXh0dXJlKTtcclxuICAgICAgdGhpcy4jcmVzb3VyY2VzW2lkXSA9IHRleHR1cmU7XHJcblxyXG4gICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyB0aGUgZmlyc3Qge0BsaW5rIENvbXBvbmVudFNrZWxldG9ufSB3aXRoIHRoZSBnaXZlbiBza2VsZXRvbiBuYW1lLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRTa2VsZXRvbihfbmFtZTogc3RyaW5nKTogUHJvbWlzZTxDb21wb25lbnRTa2VsZXRvbj4ge1xyXG4gICAgICBjb25zdCBpU2tlbGV0b246IG51bWJlciA9IHRoaXMuI2dsdGYuc2tpbnMuZmluZEluZGV4KF9za2VsZXRvbiA9PiBfc2tlbGV0b24ubmFtZSA9PSBfbmFtZSk7XHJcbiAgICAgIGlmIChpU2tlbGV0b24gPT0gLTEpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXN9OiBDb3VsZG4ndCBmaW5kIG5hbWUgJyR7X25hbWV9JyBpbiBnbFRGIHNraW5zLmApO1xyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRTa2VsZXRvbkJ5SW5kZXgoaVNrZWxldG9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBDb21wb25lbnRTa2VsZXRvbn0gZm9yIHRoZSBnaXZlbiBza2VsZXRvbiBpbmRleC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldFNrZWxldG9uQnlJbmRleChfaVNrZWxldG9uOiBudW1iZXIpOiBQcm9taXNlPENvbXBvbmVudFNrZWxldG9uPiB7XHJcbiAgICAgIGlmICghdGhpcy4jc2tlbGV0b25zKVxyXG4gICAgICAgIHRoaXMuI3NrZWxldG9ucyA9IFtdO1xyXG4gICAgICBpZiAoIXRoaXMuI3NrZWxldG9uc1tfaVNrZWxldG9uXSkge1xyXG4gICAgICAgIGNvbnN0IGdsdGZTa2luOiBHTFRGLlNraW4gPSB0aGlzLiNnbHRmLnNraW5zW19pU2tlbGV0b25dO1xyXG4gICAgICAgIGNvbnN0IGJvbmVzOiBOb2RlW10gPSBbXTtcclxuXHJcbiAgICAgICAgLy8gY29udmVydCBmbG9hdCBhcnJheSB0byBhcnJheSBvZiBtYXRyaWNlcyBhbmQgcmVnaXN0ZXIgYm9uZXNcclxuICAgICAgICBsZXQgbXR4RGF0YTogRmxvYXQzMkFycmF5O1xyXG4gICAgICAgIGlmIChnbHRmU2tpbi5pbnZlcnNlQmluZE1hdHJpY2VzICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgIG10eERhdGEgPSBhd2FpdCB0aGlzLmdldEZsb2F0MzJBcnJheShnbHRmU2tpbi5pbnZlcnNlQmluZE1hdHJpY2VzKTtcclxuICAgICAgICBjb25zdCBtdHhEYXRhU3BhbjogbnVtYmVyID0gMTY7IC8vIHNpemUgb2YgbWF0cml4XHJcblxyXG4gICAgICAgIGNvbnN0IG10eEJpbmRJbnZlcnNlczogTWF0cml4NHg0W10gPSBbXTtcclxuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgam9pbnRzIGFuZCBnZXQgY29ycmVzcG9uZGluZyBtYXRyaXggZnJvbSBmbG9hdCBhcnJheVxyXG4gICAgICAgIGZvciAobGV0IGlCb25lOiBudW1iZXIgPSAwOyBpQm9uZSA8IGdsdGZTa2luLmpvaW50cy5sZW5ndGg7IGlCb25lKyspIHtcclxuICAgICAgICAgIGxldCBtdHhCaW5kSW52ZXJzZTogTWF0cml4NHg0O1xyXG4gICAgICAgICAgaWYgKG10eERhdGEpIHtcclxuICAgICAgICAgICAgbXR4QmluZEludmVyc2UgPSBuZXcgTWF0cml4NHg0KCk7XHJcbiAgICAgICAgICAgIG10eEJpbmRJbnZlcnNlLnNldChtdHhEYXRhLnN1YmFycmF5KGlCb25lICogbXR4RGF0YVNwYW4sIGlCb25lICogbXR4RGF0YVNwYW4gKyBtdHhEYXRhU3BhbikpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJvbmVzLnB1c2goYXdhaXQgdGhpcy5nZXROb2RlQnlJbmRleChnbHRmU2tpbi5qb2ludHNbaUJvbmVdKSk7XHJcbiAgICAgICAgICBtdHhCaW5kSW52ZXJzZXMucHVzaChtdHhCaW5kSW52ZXJzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLiNza2VsZXRvbnNbX2lTa2VsZXRvbl0gPSBuZXcgQ29tcG9uZW50U2tlbGV0b24oYm9uZXMsIG10eEJpbmRJbnZlcnNlcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLiNza2VsZXRvbnNbX2lTa2VsZXRvbl07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgJHtHTFRGTG9hZGVyLm5hbWV9IHwgJHt0aGlzLiN1cmx9YDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldEluZGV4KF9uYW1lT3JJbmRleDogc3RyaW5nIHwgbnVtYmVyLCBfYXJyYXk6IHsgbmFtZT86IHN0cmluZyB9W10pOiBudW1iZXIge1xyXG4gICAgICBsZXQgaW5kZXg6IG51bWJlciA9XHJcbiAgICAgICAgdHlwZW9mIF9uYW1lT3JJbmRleCA9PSBcIm51bWJlclwiID9cclxuICAgICAgICAgIF9uYW1lT3JJbmRleCA6XHJcbiAgICAgICAgICBfYXJyYXkuZmluZEluZGV4KF9vYmplY3QgPT4gX29iamVjdC5uYW1lID09IF9uYW1lT3JJbmRleCk7XHJcbiAgICAgIGlmIChpbmRleCA9PSAtMSkge1xyXG4gICAgICAgIGxldCBhcnJheU5hbWU6IHN0cmluZyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuI2dsdGYpLmZpbmQoKFtfa2V5LCBfdmFsdWVdKSA9PiBfdmFsdWUgPT0gX2FycmF5KT8uWzBdO1xyXG4gICAgICAgIERlYnVnLmVycm9yKGAke3RoaXN9OiBDb3VsZG4ndCBmaW5kIG5hbWUgJyR7X25hbWVPckluZGV4fScgaW4gZ2xURiAke2FycmF5TmFtZX0uYCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHtAbGluayBVaW50OEFycmF5fSBmb3IgdGhlIGdpdmVuIGFjY2Vzc29yIGluZGV4LlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0Qm9uZUluZGljZXMoX2lBY2Nlc3NvcjogbnVtYmVyKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XHJcbiAgICAgIGNvbnN0IGFycmF5OiBUeXBlZEFycmF5ID0gYXdhaXQgdGhpcy5nZXRCdWZmZXJEYXRhKF9pQWNjZXNzb3IpO1xyXG4gICAgICBjb25zdCBjb21wb25lbnRUeXBlOiBHTFRGLkNPTVBPTkVOVF9UWVBFID0gdGhpcy4jZ2x0Zi5hY2Nlc3NvcnNbX2lBY2Nlc3Nvcl0/LmNvbXBvbmVudFR5cGU7XHJcblxyXG4gICAgICBpZiAoY29tcG9uZW50VHlwZSA9PSBHTFRGLkNPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX0JZVEUpXHJcbiAgICAgICAgcmV0dXJuIGFycmF5IGFzIFVpbnQ4QXJyYXk7XHJcblxyXG4gICAgICBpZiAoY29tcG9uZW50VHlwZSA9PSBHTFRGLkNPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX1NIT1JUKSB7XHJcbiAgICAgICAgRGVidWcubG9nKGAke3RoaXN9OiBCb25lIGluZGljZXMgYXJlIHN0b3JlZCBhcyAnJHtHTFRGLkNPTVBPTkVOVF9UWVBFW0dMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfU0hPUlRdfScuIEZVREdFIHdpbGwgY29udmVydCB0aGVtIHRvICcke0dMVEYuQ09NUE9ORU5UX1RZUEVbR0xURi5DT01QT05FTlRfVFlQRS5VTlNJR05FRF9CWVRFXX0nLiBGVURHRSBvbmx5IHN1cHBvcnRzIHNrZWxldG9ucyB3aXRoIHVwIHRvIDI1NiBib25lcywgc28gbWFrZSBzdXJlIHlvdXIgc2tlbGV0b24gaGFzIG5vIG1vcmUgdGhhbiAyNTYgYm9uZXMuYCk7XHJcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhcnJheSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzfTogSW52YWxpZCBjb21wb25lbnQgdHlwZSAnJHtHTFRGLkNPTVBPTkVOVF9UWVBFW2NvbXBvbmVudFR5cGVdfScgZm9yIGJvbmUgaW5kaWNlcy4gRXhwZWN0ZWQgJyR7R0xURi5DT01QT05FTlRfVFlQRVtHTFRGLkNPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX0JZVEVdfScgb3IgJyR7R0xURi5DT01QT05FTlRfVFlQRVtHTFRGLkNPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX1NIT1JUXX0nLmApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHtAbGluayBGbG9hdDMyQXJyYXl9IGZvciB0aGUgZ2l2ZW4gYWNjZXNzb3IgaW5kZXguXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRGbG9hdDMyQXJyYXkoX2lBY2Nlc3NvcjogbnVtYmVyKTogUHJvbWlzZTxGbG9hdDMyQXJyYXk+IHtcclxuICAgICAgY29uc3QgYXJyYXk6IFR5cGVkQXJyYXkgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlckRhdGEoX2lBY2Nlc3Nvcik7XHJcbiAgICAgIGNvbnN0IGdsdGZBY2Nlc3NvcjogR0xURi5BY2Nlc3NvciA9IHRoaXMuI2dsdGYuYWNjZXNzb3JzW19pQWNjZXNzb3JdO1xyXG5cclxuICAgICAgaWYgKGdsdGZBY2Nlc3Nvci5jb21wb25lbnRUeXBlID09IEdMVEYuQ09NUE9ORU5UX1RZUEUuRkxPQVQpXHJcbiAgICAgICAgcmV0dXJuIGFycmF5IGFzIEZsb2F0MzJBcnJheTtcclxuXHJcbiAgICAgIGlmIChnbHRmQWNjZXNzb3Iubm9ybWFsaXplZCkge1xyXG4gICAgICAgIHN3aXRjaCAoZ2x0ZkFjY2Vzc29yLmNvbXBvbmVudFR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgR0xURi5DT01QT05FTlRfVFlQRS5CWVRFOlxyXG4gICAgICAgICAgICByZXR1cm4gRmxvYXQzMkFycmF5LmZyb20oYXJyYXksIF92YWx1ZSA9PiBNYXRoLm1heChfdmFsdWUgLyAxMjcsIC0xKSk7XHJcbiAgICAgICAgICBjYXNlIEdMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfQllURTpcclxuICAgICAgICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKGFycmF5LCBfdmFsdWUgPT4gX3ZhbHVlIC8gMjU1KTtcclxuICAgICAgICAgIGNhc2UgR0xURi5DT01QT05FTlRfVFlQRS5TSE9SVDpcclxuICAgICAgICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKGFycmF5LCBfdmFsdWUgPT4gTWF0aC5tYXgoX3ZhbHVlIC8gMzI3NjcsIC0xKSk7XHJcbiAgICAgICAgICBjYXNlIEdMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfU0hPUlQ6XHJcbiAgICAgICAgICAgIHJldHVybiBGbG9hdDMyQXJyYXkuZnJvbShhcnJheSwgX3ZhbHVlID0+IF92YWx1ZSAvIDY1NTM1KTtcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzfTogSW52YWxpZCBjb21wb25lbnQgdHlwZSAnJHtHTFRGLkNPTVBPTkVOVF9UWVBFW2dsdGZBY2Nlc3Nvci5jb21wb25lbnRUeXBlXX0nIGZvciBub3JtYWxpemVkIGFjY2Vzc29yLmApO1xyXG4gICAgICAgICAgLy8gaHR0cHM6Ly9yZWdpc3RyeS5raHJvbm9zLm9yZy9nbFRGL3NwZWNzLzIuMC9nbFRGLTIuMC5odG1sI19hY2Nlc3Nvcl9ub3JtYWxpemVkXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBEZWJ1Zy53YXJuKGAke3RoaXN9OiBFeHBlY3RlZCBjb21wb25lbnQgdHlwZSAnJHtHTFRGLkNPTVBPTkVOVF9UWVBFW0dMVEYuQ09NUE9ORU5UX1RZUEUuRkxPQVRdfScgYnV0IHdhcyAnJHtHTFRGLkNPTVBPTkVOVF9UWVBFW2dsdGZBY2Nlc3Nvcj8uY29tcG9uZW50VHlwZV19Jy5gKTtcclxuICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKGFycmF5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgVWludDE2QXJyYXl9IGZvciB0aGUgZ2l2ZW4gYWNjZXNzb3IgaW5kZXguIE9ubHkgdXNlZCB0byBnZXQgdGhlIHZlcnRleCBpbmRpY2VzLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0VmVydGV4SW5kaWNlcyhfaUFjY2Vzc29yOiBudW1iZXIpOiBQcm9taXNlPFVpbnQxNkFycmF5PiB7XHJcbiAgICAgIGNvbnN0IGFycmF5OiBUeXBlZEFycmF5ID0gYXdhaXQgdGhpcy5nZXRCdWZmZXJEYXRhKF9pQWNjZXNzb3IpO1xyXG4gICAgICBjb25zdCBnbHRmQWNjZXNzb3I6IEdMVEYuQWNjZXNzb3IgPSB0aGlzLiNnbHRmLmFjY2Vzc29yc1tfaUFjY2Vzc29yXTtcclxuXHJcbiAgICAgIGlmIChnbHRmQWNjZXNzb3IuY29tcG9uZW50VHlwZSA9PSBHTFRGLkNPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX1NIT1JUKVxyXG4gICAgICAgIHJldHVybiBhcnJheSBhcyBVaW50MTZBcnJheTtcclxuXHJcbiAgICAgIGlmIChnbHRmQWNjZXNzb3IuY291bnQgPiA2NTUzNSAmJiBnbHRmQWNjZXNzb3IudHlwZSA9PSBcIlNDQUxBUlwiKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzfTogRmlsZSBpbmNsdWRlcyBhIG1lc2ggd2l0aCBtb3JlIHRoYW4gNjU1MzUgdmVydGljZXMuIEZVREdFIGRvZXMgbm90IHN1cHBvcnQgbWVzaGVzIHdpdGggbW9yZSB0aGFuIDY1NTM1IHZlcnRpY2VzLmApO1xyXG5cclxuICAgICAgaWYgKGdsdGZBY2Nlc3Nvci5jb21wb25lbnRUeXBlID09IEdMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfQllURSB8fCBnbHRmQWNjZXNzb3IuY29tcG9uZW50VHlwZSA9PSBHTFRGLkNPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX0lOVClcclxuICAgICAgICByZXR1cm4gVWludDE2QXJyYXkuZnJvbShhcnJheSk7XHJcblxyXG4gICAgICBEZWJ1Zy53YXJuKGAke3RoaXN9OiBFeHBlY3RlZCBhbiB1bnNpZ25lZCBpbnRlZ2VyIGNvbXBvbmVudCB0eXBlIGJ1dCB3YXMgJyR7R0xURi5DT01QT05FTlRfVFlQRVt0aGlzLiNnbHRmLmFjY2Vzc29yc1tfaUFjY2Vzc29yXT8uY29tcG9uZW50VHlwZV19Jy5gKTtcclxuICAgICAgcmV0dXJuIFVpbnQxNkFycmF5LmZyb20oYXJyYXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEge0BsaW5rIEZsb2F0MzJBcnJheX0gZm9yIHRoZSBnaXZlbiBhY2Nlc3NvciBpbmRleC4gVGhlIGFycmF5IGNvbnRhaW5zIHRoZSB2ZXJ0ZXggY29sb3JzIGluIFJHQkEgZm9ybWF0LlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0VmVydGV4Q29sb3JzKF9pQWNjZXNzb3I6IG51bWJlcik6IFByb21pc2U8RmxvYXQzMkFycmF5PiB7XHJcbiAgICAgIGNvbnN0IGFycmF5OiBGbG9hdDMyQXJyYXkgPSBhd2FpdCB0aGlzLmdldEZsb2F0MzJBcnJheShfaUFjY2Vzc29yKTtcclxuICAgICAgY29uc3QgZ2x0ZkFjY2Vzc29yOiBHTFRGLkFjY2Vzc29yID0gdGhpcy4jZ2x0Zi5hY2Nlc3NvcnNbX2lBY2Nlc3Nvcl07XHJcblxyXG4gICAgICBpZiAoZ2x0ZkFjY2Vzc29yLnR5cGUgPT0gR0xURi5BQ0NFU1NPUl9UWVBFLlZFQzMpIHtcclxuICAgICAgICBjb25zdCByZ2JhQXJyYXk6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkubGVuZ3RoICogNCAvIDMpO1xyXG4gICAgICAgIGZvciAobGV0IGlWZWMzOiBudW1iZXIgPSAwLCBpVmVjNDogbnVtYmVyID0gMDsgaVZlYzMgPCBhcnJheS5sZW5ndGg7IGlWZWMzICs9IDMsIGlWZWM0ICs9IDQpIHtcclxuICAgICAgICAgIHJnYmFBcnJheVtpVmVjNF0gPSBhcnJheVtpVmVjM107XHJcbiAgICAgICAgICByZ2JhQXJyYXlbaVZlYzQgKyAxXSA9IGFycmF5W2lWZWMzICsgMV07XHJcbiAgICAgICAgICByZ2JhQXJyYXlbaVZlYzQgKyAyXSA9IGFycmF5W2lWZWMzICsgMl07XHJcbiAgICAgICAgICByZ2JhQXJyYXlbaVZlYzQgKyAzXSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZ2JhQXJyYXk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGdldEJ1ZmZlckRhdGEoX2lBY2Nlc3NvcjogbnVtYmVyKTogUHJvbWlzZTxUeXBlZEFycmF5PiB7XHJcbiAgICAgIGNvbnN0IGdsdGZBY2Nlc3NvcjogR0xURi5BY2Nlc3NvciA9IHRoaXMuI2dsdGYuYWNjZXNzb3JzW19pQWNjZXNzb3JdO1xyXG4gICAgICBpZiAoIWdsdGZBY2Nlc3NvcilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc306IENvdWxkbid0IGZpbmQgYWNjZXNzb3Igd2l0aCBpbmRleCAke19pQWNjZXNzb3J9LmApO1xyXG5cclxuICAgICAgbGV0IGFycmF5OiBUeXBlZEFycmF5O1xyXG4gICAgICBjb25zdCBjb21wb25lbnRUeXBlOiBHTFRGLkNPTVBPTkVOVF9UWVBFID0gZ2x0ZkFjY2Vzc29yLmNvbXBvbmVudFR5cGU7XHJcbiAgICAgIGNvbnN0IGFjY2Vzc29yVHlwZTogR0xURi5BQ0NFU1NPUl9UWVBFID0gZ2x0ZkFjY2Vzc29yLnR5cGU7XHJcblxyXG4gICAgICBpZiAoZ2x0ZkFjY2Vzc29yLmJ1ZmZlclZpZXcgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIGFycmF5ID0gYXdhaXQgdGhpcy5nZXRCdWZmZXJWaWV3RGF0YSh0aGlzLiNnbHRmLmJ1ZmZlclZpZXdzW2dsdGZBY2Nlc3Nvci5idWZmZXJWaWV3XSwgZ2x0ZkFjY2Vzc29yLmJ5dGVPZmZzZXQsIGNvbXBvbmVudFR5cGUsIGFjY2Vzc29yVHlwZSk7XHJcblxyXG4gICAgICBpZiAoZ2x0ZkFjY2Vzc29yLnNwYXJzZSkge1xyXG4gICAgICAgIGNvbnN0IGdsdGZCdWZmZXJWaWV3SW5kaWNlczogR0xURi5CdWZmZXJWaWV3ID0gdGhpcy4jZ2x0Zi5idWZmZXJWaWV3c1tnbHRmQWNjZXNzb3Iuc3BhcnNlLmluZGljZXMuYnVmZmVyVmlld107XHJcbiAgICAgICAgY29uc3QgZ2x0ZkJ1ZmZlclZpZXdWYWx1ZXM6IEdMVEYuQnVmZmVyVmlldyA9IHRoaXMuI2dsdGYuYnVmZmVyVmlld3NbZ2x0ZkFjY2Vzc29yLnNwYXJzZS52YWx1ZXMuYnVmZmVyVmlld107XHJcblxyXG4gICAgICAgIGlmICghZ2x0ZkJ1ZmZlclZpZXdJbmRpY2VzIHx8ICFnbHRmQnVmZmVyVmlld1ZhbHVlcylcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzfTogQ291bGRuJ3QgZmluZCBidWZmZXIgdmlld3MgZm9yIHNwYXJzZSBpbmRpY2VzIG9yIHZhbHVlcyBvZiBhY2Nlc3NvciB3aXRoIGluZGV4ICR7X2lBY2Nlc3Nvcn0uYCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGFycmF5SW5kaWNlczogVHlwZWRBcnJheSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyVmlld0RhdGEoZ2x0ZkJ1ZmZlclZpZXdJbmRpY2VzLCBnbHRmQWNjZXNzb3Iuc3BhcnNlLmluZGljZXMuYnl0ZU9mZnNldCwgZ2x0ZkFjY2Vzc29yLnNwYXJzZS5pbmRpY2VzLmNvbXBvbmVudFR5cGUsIEdMVEYuQUNDRVNTT1JfVFlQRS5TQ0FMQVIpO1xyXG4gICAgICAgIGNvbnN0IGFycmF5VmFsdWVzOiBUeXBlZEFycmF5ID0gYXdhaXQgdGhpcy5nZXRCdWZmZXJWaWV3RGF0YShnbHRmQnVmZmVyVmlld1ZhbHVlcywgZ2x0ZkFjY2Vzc29yLnNwYXJzZS52YWx1ZXMuYnl0ZU9mZnNldCwgY29tcG9uZW50VHlwZSwgYWNjZXNzb3JUeXBlKTtcclxuXHJcbiAgICAgICAgY29uc3QgYWNjZXNzb3JUeXBlTGVuZ3RoOiBudW1iZXIgPSB0b0FjY2Vzc29yVHlwZUxlbmd0aFtnbHRmQWNjZXNzb3IudHlwZV07XHJcbiAgICAgICAgaWYgKGdsdGZBY2Nlc3Nvci5idWZmZXJWaWV3ID09IHVuZGVmaW5lZClcclxuICAgICAgICAgIGFycmF5ID0gbmV3IHRvQXJyYXlDb25zdHJ1Y3RvcltnbHRmQWNjZXNzb3IuY29tcG9uZW50VHlwZV0oZ2x0ZkFjY2Vzc29yLmNvdW50ICogYWNjZXNzb3JUeXBlTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGdsdGZBY2Nlc3Nvci5zcGFyc2UuY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgYXJyYXkuc2V0KGFycmF5VmFsdWVzLnNsaWNlKGkgKiBhY2Nlc3NvclR5cGVMZW5ndGgsIChpICsgMSkgKiBhY2Nlc3NvclR5cGVMZW5ndGgpLCBhcnJheUluZGljZXNbaV0gKiBhY2Nlc3NvclR5cGVMZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0QnVmZmVyVmlld0RhdGEoX2J1ZmZlclZpZXc6IEdMVEYuQnVmZmVyVmlldywgX2J5dGVPZmZzZXQ6IG51bWJlciwgX2NvbXBvbmVudFR5cGU6IEdMVEYuQ09NUE9ORU5UX1RZUEUsIF9hY2Nlc3NvclR5cGU6IEdMVEYuQUNDRVNTT1JfVFlQRSk6IFByb21pc2U8VHlwZWRBcnJheT4ge1xyXG4gICAgICBjb25zdCBidWZmZXI6IEFycmF5QnVmZmVyID0gYXdhaXQgdGhpcy5nZXRCdWZmZXIoX2J1ZmZlclZpZXcuYnVmZmVyKTtcclxuICAgICAgY29uc3QgYnl0ZU9mZnNldDogbnVtYmVyID0gKF9idWZmZXJWaWV3LmJ5dGVPZmZzZXQgPz8gMCkgKyAoX2J5dGVPZmZzZXQgPz8gMCk7XHJcbiAgICAgIGNvbnN0IGJ5dGVMZW5ndGg6IG51bWJlciA9IF9idWZmZXJWaWV3LmJ5dGVMZW5ndGggPz8gMDtcclxuICAgICAgY29uc3QgYnl0ZVN0cmlkZTogbnVtYmVyID0gX2J1ZmZlclZpZXcuYnl0ZVN0cmlkZTtcclxuXHJcbiAgICAgIGNvbnN0IGFycmF5Q29uc3RydWN0b3I6IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHRvQXJyYXlDb25zdHJ1Y3RvcltfY29tcG9uZW50VHlwZV07XHJcbiAgICAgIC8vQHRzLWlnbm9yZSBiZWNhdXNlIHRoZSBUeXBlZEFycmF5Q29uc3RydWN0b3IgdHlwZSBpcyBub3QgYXNzaWduYWJsZSB0byB0aGUgVHlwZWRBcnJheSB0eXBlXHJcbiAgICAgIGNvbnN0IGFycmF5OiBUeXBlZEFycmF5ID0gbmV3IGFycmF5Q29uc3RydWN0b3IoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIC8gYXJyYXlDb25zdHJ1Y3Rvci5CWVRFU19QRVJfRUxFTUVOVCk7XHJcblxyXG4gICAgICBpZiAoYnl0ZVN0cmlkZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIGNyZWF0aW5nIG5ldyBidWZmZXJzIG1heWJlIHJhdGhlciBwYXNzIHN0cmlkZSBpbnRvIHRoZSByZW5kZXIgbWVzaD8gYW5kIHNldCBpdCB3aGVuIGRhdGEgaXMgcGFzc2VkIHRvIHRoZSBncHU/XHJcbiAgICAgICAgY29uc3QgbkNvbXBvbmVudHNQZXJFbGVtZW50OiBudW1iZXIgPSB0b0FjY2Vzc29yVHlwZUxlbmd0aFtfYWNjZXNzb3JUeXBlXTsgLy8gYW1vdW50IG9mIGNvbXBvbmVudHMgcGVyIGVsZW1lbnQgb2YgdGhlIGFjY2Vzc29yIHR5cGUsIGUuZy4gMyBmb3IgVkVDM1xyXG4gICAgICAgIGNvbnN0IG5FbGVtZW50czogbnVtYmVyID0gYnl0ZUxlbmd0aCAvIGJ5dGVTdHJpZGU7IC8vIGFtb3VudCBvZiBlbGVtZW50cywgZS5nLiBuKlZFQzMgXHJcbiAgICAgICAgY29uc3Qgc3RyaWRlOiBudW1iZXIgPSBieXRlU3RyaWRlIC8gYXJyYXlDb25zdHJ1Y3Rvci5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICBjb25zdCBuZXdBcnJheTogVHlwZWRBcnJheSA9IG5ldyBhcnJheUNvbnN0cnVjdG9yKG5FbGVtZW50cyAqIG5Db21wb25lbnRzUGVyRWxlbWVudCk7XHJcbiAgICAgICAgZm9yIChsZXQgaU5ld0VsZW1lbnQ6IG51bWJlciA9IDA7IGlOZXdFbGVtZW50IDwgbkVsZW1lbnRzOyBpTmV3RWxlbWVudCsrKSB7XHJcbiAgICAgICAgICBjb25zdCBpRWxlbWVudDogbnVtYmVyID0gaU5ld0VsZW1lbnQgKiBzdHJpZGU7XHJcbiAgICAgICAgICAvLyBUT0RPOiBjaGVjayBpZiBsb29wIGlzIGZhc3RlciB0aGFuIHNldCArIHNsaWNlXHJcbiAgICAgICAgICBmb3IgKGxldCBpQ29tcG9uZW50OiBudW1iZXIgPSAwOyBpQ29tcG9uZW50IDwgbkNvbXBvbmVudHNQZXJFbGVtZW50OyBpQ29tcG9uZW50KyspXHJcbiAgICAgICAgICAgIG5ld0FycmF5W2lOZXdFbGVtZW50ICogbkNvbXBvbmVudHNQZXJFbGVtZW50ICsgaUNvbXBvbmVudF0gPSBhcnJheVtpRWxlbWVudCArIGlDb21wb25lbnRdO1xyXG4gICAgICAgICAgLy8gbmV3QXJyYXkuc2V0KGFycmF5LnNsaWNlKGlFbGVtZW50LCBpRWxlbWVudCArIG5Db21wb25lbnRzUGVyRWxlbWVudCksIGlOZXdFbGVtZW50ICogbkNvbXBvbmVudHNQZXJFbGVtZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdBcnJheTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0QnVmZmVyKF9pQnVmZmVyOiBudW1iZXIpOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XHJcbiAgICAgIGNvbnN0IGdsdGZCdWZmZXI6IEdMVEYuQnVmZmVyID0gdGhpcy4jZ2x0Zi5idWZmZXJzW19pQnVmZmVyXTtcclxuICAgICAgaWYgKCFnbHRmQnVmZmVyKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzfTogQ291bGRuJ3QgZmluZCBidWZmZXIgd2l0aCBpbmRleCAke19pQnVmZmVyfS5gKTtcclxuXHJcbiAgICAgIGlmICghdGhpcy4jYnVmZmVycylcclxuICAgICAgICB0aGlzLiNidWZmZXJzID0gW107XHJcbiAgICAgIGlmICghdGhpcy4jYnVmZmVyc1tfaUJ1ZmZlcl0pIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZTogUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChuZXcgVVJMKGdsdGZCdWZmZXIudXJpLCBuZXcgVVJMKHRoaXMuI3VybCwgUHJvamVjdC5iYXNlVVJMKSkpO1xyXG4gICAgICAgIHRoaXMuI2J1ZmZlcnNbX2lCdWZmZXJdID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuI2J1ZmZlcnNbX2lCdWZmZXJdO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0QW5pbWF0aW9uU2VxdWVuY2VWZWN0b3IoX3NhbXBsZXI6IEdMVEYuQW5pbWF0aW9uU2FtcGxlciwgX3RyYW5zZm9ybWF0aW9uVHlwZTogR0xURi5BbmltYXRpb25DaGFubmVsVGFyZ2V0W1wicGF0aFwiXSk6IFByb21pc2U8QW5pbWF0aW9uU2VxdWVuY2VWZWN0b3IzIHwgQW5pbWF0aW9uU2VxdWVuY2VWZWN0b3I0PiB7XHJcbiAgICAgIGNvbnN0IGlucHV0OiBGbG9hdDMyQXJyYXkgPSBhd2FpdCB0aGlzLmdldEZsb2F0MzJBcnJheShfc2FtcGxlci5pbnB1dCk7XHJcbiAgICAgIGNvbnN0IG91dHB1dDogRmxvYXQzMkFycmF5ID0gYXdhaXQgdGhpcy5nZXRGbG9hdDMyQXJyYXkoX3NhbXBsZXIub3V0cHV0KTtcclxuXHJcbiAgICAgIGNvbnN0IG1pbGxpc1BlclNlY29uZDogbnVtYmVyID0gMTAwMDtcclxuICAgICAgY29uc3QgaXNSb3RhdGlvbjogYm9vbGVhbiA9IF90cmFuc2Zvcm1hdGlvblR5cGUgPT0gXCJyb3RhdGlvblwiO1xyXG4gICAgICBjb25zdCB2ZWN0b3JMZW5ndGg6IG51bWJlciA9IGlzUm90YXRpb24gPyA0IDogMzsgLy8gcm90YXRpb24gaXMgc3RvcmVkIGFzIHF1YXRlcm5pb25cclxuICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbjogQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04gPSB0aGlzLnRvSW50ZXJuSW50ZXJwb2xhdGlvbihfc2FtcGxlci5pbnRlcnBvbGF0aW9uKTtcclxuICAgICAgY29uc3QgaXNDdWJpYzogdHJ1ZSB8IHVuZGVmaW5lZCA9IGludGVycG9sYXRpb24gPT0gQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04uQ1VCSUMgPyB0cnVlIDogdW5kZWZpbmVkO1xyXG4gICAgICBjb25zdCB2ZWN0b3JzUGVySW5wdXQ6IG51bWJlciA9IGlzQ3ViaWMgPyAzIDogMTsgLy8gY3ViaWMgaW50ZXJwb2xhdGlvbiB1c2VzIDMgdmFsdWVzIHBlciBpbnB1dDogaW4tdGFuZ2VudCwgcHJvcGVydHkgdmFsdWUgYW5kIG91dC10YW5nZW50LiBodHRwczovL3JlZ2lzdHJ5Lmtocm9ub3Mub3JnL2dsVEYvc3BlY3MvMi4wL2dsVEYtMi4wLmh0bWwjaW50ZXJwb2xhdGlvbi1jdWJpY1xyXG5cclxuICAgICAgLy8gdXNlZCBvbmx5IGZvciByb3RhdGlvbiBpbnRlcnBvbGF0aW9uXHJcbiAgICAgIGxldCBsYXN0Um90YXRpb246IFF1YXRlcm5pb247XHJcbiAgICAgIGxldCBuZXh0Um90YXRpb246IFF1YXRlcm5pb247XHJcblxyXG4gICAgICBjb25zdCBzZXF1ZW5jZXM6IHsgeDogQW5pbWF0aW9uS2V5W107IHk6IEFuaW1hdGlvbktleVtdOyB6OiBBbmltYXRpb25LZXlbXTsgdz86IEFuaW1hdGlvbktleVtdIH0gPSB7IHg6IFtdLCB5OiBbXSwgejogW10gfTtcclxuICAgICAgaWYgKGlzUm90YXRpb24pIHtcclxuICAgICAgICBzZXF1ZW5jZXMudyA9IFtdO1xyXG4gICAgICAgIGxhc3RSb3RhdGlvbiA9IFJlY3ljbGVyLmdldChRdWF0ZXJuaW9uKTtcclxuICAgICAgICBuZXh0Um90YXRpb24gPSBSZWN5Y2xlci5nZXQoUXVhdGVybmlvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IGlJbnB1dDogbnVtYmVyID0gMDsgaUlucHV0IDwgaW5wdXQubGVuZ3RoOyBpSW5wdXQrKykge1xyXG4gICAgICAgIGNvbnN0IGlPdXRwdXQ6IG51bWJlciA9IGlJbnB1dCAqIHZlY3RvcnNQZXJJbnB1dCAqIHZlY3Rvckxlbmd0aCArIChpc0N1YmljID8gdmVjdG9yTGVuZ3RoIDogMCk7XHJcbiAgICAgICAgY29uc3QgaU91dHB1dFNsb3BlSW46IG51bWJlciA9IGlPdXRwdXQgLSB2ZWN0b3JMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgaU91dHB1dFNsb3BlT3V0OiBudW1iZXIgPSBpT3V0cHV0ICsgdmVjdG9yTGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHRpbWU6IG51bWJlciA9IG1pbGxpc1BlclNlY29uZCAqIGlucHV0W2lJbnB1dF07XHJcblxyXG4gICAgICAgIGlmIChpc1JvdGF0aW9uKSB7XHJcbiAgICAgICAgICAvLyBUYWtlIHRoZSBzaG9ydGVzdCBwYXRoIGJldHdlZW4gdHdvIHJvdGF0aW9ucywgaS5lLiBpZiB0aGUgZG90IHByb2R1Y3QgaXMgbmVnYXRpdmUgdGhlbiB0aGUgbmV4dCBxdWF0ZXJuaW9uIG5lZWRzIHRvIGJlIG5lZ2F0ZWQuXHJcbiAgICAgICAgICAvLyBxIGFuZCAtcSByZXByZXNlbnQgdGhlIHNhbWUgcm90YXRpb24gYnV0IGludGVycG9sYXRpb24gd2lsbCB0YWtlIGVpdGhlciB0aGUgbG9uZyB3YXkgb3IgdGhlIHNob3J0IHdheSBhcm91bmQgdGhlIHNwaGVyZSBkZXBlbmRpbmcgb24gd2hpY2ggd2UgdXNlLlxyXG4gICAgICAgICAgbmV4dFJvdGF0aW9uLnNldChvdXRwdXRbaU91dHB1dCArIDBdLCBvdXRwdXRbaU91dHB1dCArIDFdLCBvdXRwdXRbaU91dHB1dCArIDJdLCBvdXRwdXRbaU91dHB1dCArIDNdKTtcclxuICAgICAgICAgIGlmIChRdWF0ZXJuaW9uLkRPVChsYXN0Um90YXRpb24sIG5leHRSb3RhdGlvbikgPCAwKVxyXG4gICAgICAgICAgICBuZXh0Um90YXRpb24ubmVnYXRlKCk7XHJcbiAgICAgICAgICBvdXRwdXRbaU91dHB1dCArIDBdID0gbmV4dFJvdGF0aW9uLng7XHJcbiAgICAgICAgICBvdXRwdXRbaU91dHB1dCArIDFdID0gbmV4dFJvdGF0aW9uLnk7XHJcbiAgICAgICAgICBvdXRwdXRbaU91dHB1dCArIDJdID0gbmV4dFJvdGF0aW9uLno7XHJcbiAgICAgICAgICBvdXRwdXRbaU91dHB1dCArIDNdID0gbmV4dFJvdGF0aW9uLnc7XHJcbiAgICAgICAgICBsYXN0Um90YXRpb24uc2V0KG5leHRSb3RhdGlvbi54LCBuZXh0Um90YXRpb24ueSwgbmV4dFJvdGF0aW9uLnosIG5leHRSb3RhdGlvbi53KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlcXVlbmNlcy54LnB1c2gobmV3IEFuaW1hdGlvbktleSh0aW1lLCBvdXRwdXRbaU91dHB1dCArIDBdLCBpbnRlcnBvbGF0aW9uLCBpc0N1YmljICYmIG91dHB1dFtpT3V0cHV0U2xvcGVJbiArIDBdIC8gbWlsbGlzUGVyU2Vjb25kLCBpc0N1YmljICYmIG91dHB1dFtpT3V0cHV0U2xvcGVPdXQgKyAwXSAvIG1pbGxpc1BlclNlY29uZCkpO1xyXG4gICAgICAgIHNlcXVlbmNlcy55LnB1c2gobmV3IEFuaW1hdGlvbktleSh0aW1lLCBvdXRwdXRbaU91dHB1dCArIDFdLCBpbnRlcnBvbGF0aW9uLCBpc0N1YmljICYmIG91dHB1dFtpT3V0cHV0U2xvcGVJbiArIDFdIC8gbWlsbGlzUGVyU2Vjb25kLCBpc0N1YmljICYmIG91dHB1dFtpT3V0cHV0U2xvcGVPdXQgKyAxXSAvIG1pbGxpc1BlclNlY29uZCkpO1xyXG4gICAgICAgIHNlcXVlbmNlcy56LnB1c2gobmV3IEFuaW1hdGlvbktleSh0aW1lLCBvdXRwdXRbaU91dHB1dCArIDJdLCBpbnRlcnBvbGF0aW9uLCBpc0N1YmljICYmIG91dHB1dFtpT3V0cHV0U2xvcGVJbiArIDJdIC8gbWlsbGlzUGVyU2Vjb25kLCBpc0N1YmljICYmIG91dHB1dFtpT3V0cHV0U2xvcGVPdXQgKyAyXSAvIG1pbGxpc1BlclNlY29uZCkpO1xyXG4gICAgICAgIGlmIChpc1JvdGF0aW9uKVxyXG4gICAgICAgICAgc2VxdWVuY2VzLncucHVzaChuZXcgQW5pbWF0aW9uS2V5KHRpbWUsIG91dHB1dFtpT3V0cHV0ICsgM10sIGludGVycG9sYXRpb24sIGlzQ3ViaWMgJiYgb3V0cHV0W2lPdXRwdXRTbG9wZUluICsgM10gLyBtaWxsaXNQZXJTZWNvbmQsIGlzQ3ViaWMgJiYgb3V0cHV0W2lPdXRwdXRTbG9wZU91dCArIDNdIC8gbWlsbGlzUGVyU2Vjb25kKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc1JvdGF0aW9uKSB7XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUobGFzdFJvdGF0aW9uKTtcclxuICAgICAgICBSZWN5Y2xlci5zdG9yZShuZXh0Um90YXRpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHNlcXVlbmNlcykubWFwKChbX2tleSwgX3ZhbHVlXSkgPT4gW19rZXksIG5ldyBBbmltYXRpb25TZXF1ZW5jZShfdmFsdWUpXSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdG9JbnRlcm5JbnRlcnBvbGF0aW9uKF9pbnRlcnBvbGF0aW9uOiBHTFRGLkFuaW1hdGlvblNhbXBsZXJbXCJpbnRlcnBvbGF0aW9uXCJdKTogQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04ge1xyXG4gICAgICBzd2l0Y2ggKF9pbnRlcnBvbGF0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBcIkxJTkVBUlwiOlxyXG4gICAgICAgICAgcmV0dXJuIEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkxJTkVBUjtcclxuICAgICAgICBjYXNlIFwiU1RFUFwiOlxyXG4gICAgICAgICAgcmV0dXJuIEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkNPTlNUQU5UO1xyXG4gICAgICAgIGNhc2UgXCJDVUJJQ1NQTElORVwiOlxyXG4gICAgICAgICAgcmV0dXJuIEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkNVQklDO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBpZiAoX2ludGVycG9sYXRpb24gIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBEZWJ1Zy53YXJuKGAke3RoaXN9OiBVbmtub3duIGludGVycG9sYXRpb24gdHlwZSAke19pbnRlcnBvbGF0aW9ufS5gKTtcclxuICAgICAgICAgIHJldHVybiBBTklNQVRJT05fSU5URVJQT0xBVElPTi5MSU5FQVI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFdlYkdMUGFyYW1ldGVyTmFtZShfdmFsdWU6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuZmluZChfa2V5ID0+IFJlZmxlY3QuZ2V0KFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsIF9rZXkpID09IF92YWx1ZSk7XHJcbiAgfVxyXG5cclxuICB0eXBlIFR5cGVkQXJyYXkgPSBVaW50OEFycmF5IHwgVWludDE2QXJyYXkgfCBVaW50MzJBcnJheSB8IEludDhBcnJheSB8IEludDE2QXJyYXkgfCBGbG9hdDMyQXJyYXk7XHJcbiAgdHlwZSBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBVaW50OEFycmF5Q29uc3RydWN0b3IgfCBVaW50MTZBcnJheUNvbnN0cnVjdG9yIHwgVWludDMyQXJyYXlDb25zdHJ1Y3RvciB8IEludDhBcnJheUNvbnN0cnVjdG9yIHwgSW50MTZBcnJheUNvbnN0cnVjdG9yIHwgRmxvYXQzMkFycmF5Q29uc3RydWN0b3I7XHJcblxyXG4gIGNvbnN0IHRvSW50ZXJuVHJhbnNmb3JtYXRpb246IFJlY29yZDxHTFRGLkFuaW1hdGlvbkNoYW5uZWxUYXJnZXRbXCJwYXRoXCJdLCBzdHJpbmc+ID0ge1xyXG4gICAgXCJ0cmFuc2xhdGlvblwiOiBcInRyYW5zbGF0aW9uXCIsXHJcbiAgICBcInJvdGF0aW9uXCI6IFwicm90YXRpb25cIixcclxuICAgIFwic2NhbGVcIjogXCJzY2FsaW5nXCIsXHJcbiAgICBcIndlaWdodHNcIjogXCJ3ZWlnaHRzXCJcclxuICB9O1xyXG5cclxuICAvLyBudW1iZXIgb2YgY29tcG9uZW50cyBkZWZpbmVkIGJ5ICd0eXBlJ1xyXG4gIGNvbnN0IHRvQWNjZXNzb3JUeXBlTGVuZ3RoOiBSZWNvcmQ8R0xURi5BQ0NFU1NPUl9UWVBFLCBudW1iZXI+ID0ge1xyXG4gICAgXCJTQ0FMQVJcIjogMSxcclxuICAgIFwiVkVDMlwiOiAyLFxyXG4gICAgXCJWRUMzXCI6IDMsXHJcbiAgICBcIlZFQzRcIjogNCxcclxuICAgIFwiTUFUMlwiOiA0LFxyXG4gICAgXCJNQVQzXCI6IDksXHJcbiAgICBcIk1BVDRcIjogMTZcclxuICB9O1xyXG5cclxuICBjb25zdCB0b0FycmF5Q29uc3RydWN0b3I6IFJlY29yZDxHTFRGLkNPTVBPTkVOVF9UWVBFLCBUeXBlZEFycmF5Q29uc3RydWN0b3I+ID0ge1xyXG4gICAgW0dMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfQllURV06IFVpbnQ4QXJyYXksXHJcbiAgICBbR0xURi5DT01QT05FTlRfVFlQRS5CWVRFXTogSW50OEFycmF5LFxyXG4gICAgW0dMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfU0hPUlRdOiBVaW50MTZBcnJheSxcclxuICAgIFtHTFRGLkNPTVBPTkVOVF9UWVBFLlNIT1JUXTogSW50MTZBcnJheSxcclxuICAgIFtHTFRGLkNPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX0lOVF06IFVpbnQzMkFycmF5LFxyXG4gICAgW0dMVEYuQ09NUE9ORU5UX1RZUEUuRkxPQVRdOiBGbG9hdDMyQXJyYXlcclxuICB9O1xyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCBsZXQgc2hhZGVyU291cmNlczoge1tzb3VyY2U6IHN0cmluZ106IHN0cmluZ30gPSB7fTtcbiAgc2hhZGVyU291cmNlc1tcIlNoYWRlckFtYmllbnRPY2NsdXNpb24uZnJhZ1wiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYW1iaWVudCBvY2NsdXNpb24gZm9yIGEgZ2l2ZW4gZnJhZ21lbnRcclxuICogQGF1dGhvcnMgUm9sYW5kIEhlZXIsIEhGVSwgMjAyMyB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xyXG4gKiBhZGFwdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vdHNoZXJpZi93ZWJnbDJleGFtcGxlcy9ibG9iL2RhMTE1M2ExNWViYzA5YmIxMzQ5OGU1ZjczMmVmMjAzNjUwNzc0MGMvc3Nhby5odG1sXHJcbiAqIHNlZSBoZXJlIGZvciBhbiBpbiBkZXB0aCBleHBsYW5hdGlvbjogXHJcbiovXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5wcmVjaXNpb24gaGlnaHAgaW50O1xyXG5cclxuY29uc3QgZmxvYXQgc2luNDUgPSAwLjcwNzEwNzsgLy8gNDUgZGVncmVlcyBpbiByYWRpYW5zXHJcbmNvbnN0IHZlYzIga2VybmVsWzRdID0gdmVjMls0XSh2ZWMyKDAuMCwgMS4wKSwgdmVjMigxLjAsIDAuMCksIHZlYzIoMC4wLCAtMS4wKSwgdmVjMigtMS4wLCAwLjApKTtcclxuXHJcbnVuaWZvcm0gZmxvYXQgdV9mTmVhcjtcclxudW5pZm9ybSBmbG9hdCB1X2ZGYXI7XHJcbnVuaWZvcm0gZmxvYXQgdV9mU2FtcGxlUmFkaXVzO1xyXG51bmlmb3JtIGZsb2F0IHVfZkJpYXM7XHJcbnVuaWZvcm0gZmxvYXQgdV9mQXR0ZW51YXRpb25Db25zdGFudDtcclxudW5pZm9ybSBmbG9hdCB1X2ZBdHRlbnVhdGlvbkxpbmVhcjtcclxudW5pZm9ybSBmbG9hdCB1X2ZBdHRlbnVhdGlvblF1YWRyYXRpYztcclxudW5pZm9ybSB2ZWMyIHVfdmN0UmVzb2x1dGlvbjtcclxudW5pZm9ybSB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG4vLyB1bmlmb3JtIG1hdDQgdV9tdHhWaWV3UHJvamVjdGlvbkludmVyc2U7XHJcblxyXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleFBvc2l0aW9uO1xyXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleE5vcm1hbDtcclxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhOb2lzZTtcclxuLy8gdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhEZXB0aDtcclxuXHJcbmluIHZlYzIgdl92Y3RUZXh0dXJlO1xyXG5vdXQgdmVjNCB2Y3RGcmFnO1xyXG5cclxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBGb2cge1xyXG4gIGJvb2wgdV9iRm9nQWN0aXZlO1xyXG4gIGZsb2F0IHVfZkZvZ05lYXI7XHJcbiAgZmxvYXQgdV9mRm9nRmFyO1xyXG4gIGZsb2F0IHBhZGluZztcclxuICB2ZWM0IHVfdmN0Rm9nQ29sb3I7XHJcbn07XHJcblxyXG4vLyBUaGlzIGZ1bmN0aW9uIGNvdWxkIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBmcm9tIHRoZSBkZXB0aCB0ZXh0dXJlLCBidXQgbW9iaWxlIGRldmljZXMgc2VlbXMgdG8gbGFjayBpbiBwcmVjaXNpb24gdG8gZG8gdGhpc1xyXG4vLyB2ZWMzIGdldFBvc2l0aW9uKHZlYzIgX3ZjdFRleHR1cmUpIHtcclxuLy8gICBmbG9hdCBmRGVwdGggPSB0ZXh0dXJlKHVfdGV4RGVwdGgsIF92Y3RUZXh0dXJlKS5yO1xyXG4vLyAgIHZlYzQgY2xpcFNwYWNlUG9zaXRpb24gPSB2ZWM0KF92Y3RUZXh0dXJlICogMi4wIC0gMS4wLCBmRGVwdGggKiAyLjAgLSAxLjAsIDEuMCk7XHJcbi8vICAgdmVjNCB3b3JsZFNwYWNlUG9zaXRpb24gPSB1X210eFZpZXdQcm9qZWN0aW9uSW52ZXJzZSAqIGNsaXBTcGFjZVBvc2l0aW9uO1xyXG4vLyAgIHJldHVybiB3b3JsZFNwYWNlUG9zaXRpb24ueHl6IC8gd29ybGRTcGFjZVBvc2l0aW9uLnc7XHJcbi8vIH1cclxuXHJcbmZsb2F0IGdldE9jY2x1c2lvbih2ZWMzIF92Y3RQb3NpdGlvbiwgdmVjMyBfdmN0Tm9ybWFsLCB2ZWMyIF92Y3RUZXh0dXJlKSB7XHJcbiAgdmVjMyB2Y3RPY2NsdWRlciA9IHRleHR1cmUodV90ZXhQb3NpdGlvbiwgX3ZjdFRleHR1cmUpLnh5ejtcclxuXHJcbiAgaWYgKHZjdE9jY2x1ZGVyLnggPT0gMC4wICYmIHZjdE9jY2x1ZGVyLnkgPT0gMC4wICYmIHZjdE9jY2x1ZGVyLnogPT0gMC4wKSAvLyBubyBvY2NsdWRlciBhdCB0aGlzIHBvc2l0aW9uXHJcbiAgICByZXR1cm4gMC4wO1xyXG5cclxuICB2ZWMzIHZjdERpc3RhbmNlID0gdmN0T2NjbHVkZXIgLSBfdmN0UG9zaXRpb247XHJcbiAgZmxvYXQgZkludGVuc2l0eSA9IG1heChkb3QoX3ZjdE5vcm1hbCwgbm9ybWFsaXplKHZjdERpc3RhbmNlKSkgLSB1X2ZCaWFzLCAwLjApO1xyXG5cclxuICBmbG9hdCBmRGlzdGFuY2UgPSBsZW5ndGgodmN0RGlzdGFuY2UpO1xyXG4gIGZsb2F0IGZBdHRlbnVhdGlvbiA9IDEuMCAvICh1X2ZBdHRlbnVhdGlvbkNvbnN0YW50ICsgdV9mQXR0ZW51YXRpb25MaW5lYXIgKiBmRGlzdGFuY2UgKyB1X2ZBdHRlbnVhdGlvblF1YWRyYXRpYyAqIGZEaXN0YW5jZSAqIGZEaXN0YW5jZSk7XHJcblxyXG4gIHJldHVybiBmSW50ZW5zaXR5ICogZkF0dGVudWF0aW9uO1xyXG59XHJcblxyXG5mbG9hdCBnZXRGb2codmVjMyBfdmN0UG9zaXRpb24pIHtcclxuICBmbG9hdCBmRGlzdGFuY2UgPSBsZW5ndGgoX3ZjdFBvc2l0aW9uIC0gdV92Y3RDYW1lcmEpOyAvLyBtYXliZSB1c2Ugei1kZXB0aCBpbnN0ZWFkIG9mIGV1Y2xpZGVhbiBkZXB0aFxyXG4gIGZsb2F0IGZGb2cgPSBjbGFtcCgoZkRpc3RhbmNlIC0gdV9mRm9nTmVhcikgLyAodV9mRm9nRmFyIC0gdV9mRm9nTmVhciksIDAuMCwgMS4wKTtcclxuICBmRm9nID0gLXBvdyhmRm9nLCAyLjApICsgKDIuMCAqIGZGb2cpOyAvLyBsZXRzIGZvZyBhcHBlYXIgcXVpY2tlciBhbmQgZmFsbCBvZmYgc2xvd2VyIHJlc3VsdHMgaW4gYSBtb3JlIGdyYWR1YWwgZmFsbG9mZlxyXG4gIHJldHVybiBmRm9nICogdV92Y3RGb2dDb2xvci5hO1xyXG59XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgdmVjMyB2Y3RQb3NpdGlvbiA9IHRleHR1cmUodV90ZXhQb3NpdGlvbiwgdl92Y3RUZXh0dXJlKS54eXo7XHJcbiAgdmVjMyB2Y3ROb3JtYWwgPSB0ZXh0dXJlKHVfdGV4Tm9ybWFsLCB2X3ZjdFRleHR1cmUpLnh5ejtcclxuICB2ZWMyIHZjdFJhbmRvbSA9IG5vcm1hbGl6ZSh0ZXh0dXJlKHVfdGV4Tm9pc2UsIHZfdmN0VGV4dHVyZSkueHkgKiAyLjAgLSAxLjApO1xyXG4gIGZsb2F0IGZEZXB0aCA9IChsZW5ndGgodmN0UG9zaXRpb24gLSB1X3ZjdENhbWVyYSkgLSB1X2ZOZWFyKSAvICh1X2ZGYXIgLSB1X2ZOZWFyKTsgLy8gbGluZWFyIGV1Y2xpZGVhbiBkZXB0aCBpbiByYW5nZSBbMCwxXSwgd2hlbiBjaGFuZ2luZyB0byB2aWV3IHNwYWNlLCBkb24ndCBzdWJ0cmFjdCBjYW1lcmEgcG9zaXRpb25cclxuICBmbG9hdCBmS2VybmVsUmFkaXVzID0gdV9mU2FtcGxlUmFkaXVzICogKDEuMCAtIGZEZXB0aCk7XHJcblxyXG4gIGZsb2F0IGZPY2NsdXNpb24gPSAwLjA7XHJcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCA0OyArK2kpIHtcclxuICAgIHZlYzIgdmN0SzEgPSByZWZsZWN0KGtlcm5lbFtpXSwgdmN0UmFuZG9tKTtcclxuICAgIHZlYzIgdmN0SzIgPSB2ZWMyKHZjdEsxLnggKiBzaW40NSAtIHZjdEsxLnkgKiBzaW40NSwgdmN0SzEueCAqIHNpbjQ1ICsgdmN0SzEueSAqIHNpbjQ1KTtcclxuXHJcbiAgICB2Y3RLMSAvPSB1X3ZjdFJlc29sdXRpb247XHJcbiAgICB2Y3RLMiAvPSB1X3ZjdFJlc29sdXRpb247XHJcblxyXG4gICAgdmN0SzEgKj0gZktlcm5lbFJhZGl1cztcclxuICAgIHZjdEsyICo9IGZLZXJuZWxSYWRpdXM7XHJcblxyXG4gICAgZk9jY2x1c2lvbiArPSBnZXRPY2NsdXNpb24odmN0UG9zaXRpb24sIHZjdE5vcm1hbCwgdl92Y3RUZXh0dXJlICsgdmN0SzEpO1xyXG4gICAgZk9jY2x1c2lvbiArPSBnZXRPY2NsdXNpb24odmN0UG9zaXRpb24sIHZjdE5vcm1hbCwgdl92Y3RUZXh0dXJlICsgdmN0SzIgKiAwLjc1KTtcclxuICAgIGZPY2NsdXNpb24gKz0gZ2V0T2NjbHVzaW9uKHZjdFBvc2l0aW9uLCB2Y3ROb3JtYWwsIHZfdmN0VGV4dHVyZSArIHZjdEsxICogMC41KTtcclxuICAgIGZPY2NsdXNpb24gKz0gZ2V0T2NjbHVzaW9uKHZjdFBvc2l0aW9uLCB2Y3ROb3JtYWwsIHZfdmN0VGV4dHVyZSArIHZjdEsyICogMC4yNSk7XHJcbiAgfVxyXG5cclxuICBmT2NjbHVzaW9uID0gY2xhbXAoZk9jY2x1c2lvbiAvIDE2LjAsIDAuMCwgMS4wKTtcclxuXHJcbiAgaWYgKHVfYkZvZ0FjdGl2ZSAmJiBmT2NjbHVzaW9uID4gMC4wKSAvLyBjb3JyZWN0IG9jY2x1c2lvbiBieSBmb2cgZmFjdG9yXHJcbiAgICBmT2NjbHVzaW9uID0gbWl4KGZPY2NsdXNpb24sIDAuMCwgZ2V0Rm9nKHZjdFBvc2l0aW9uKSk7XHJcbiAgXHJcbiAgdmN0RnJhZy5yZ2IgPSB2ZWMzKGZPY2NsdXNpb24pO1xyXG4gIHZjdEZyYWcuYSA9IDEuMDtcclxufWA7XG4gIHNoYWRlclNvdXJjZXNbXCJTaGFkZXJCbG9vbS5mcmFnXCJdID0gLypnbHNsKi8gYCN2ZXJzaW9uIDMwMCBlc1xyXG4vKipcclxuICogRXh0cmFjdHMgY29sb3JzLCBkb3duc2FtcGxlcyBhbmQgdXBzYW1wbGVzIGEgdGV4dHVyZVxyXG4gKiBBZGFwdGlvbiBvZiB0aGUgXCJkdWFsIGZpbHRlcmluZyBrYXdhc2VcIiBtZXRob2QgZGVzY3JpYmVkIGluIFNJR0dSQVBIIDIwMTUgYnkgTWFyaXVzIEJqw7hyZ2VcclxuICogaHR0cHM6Ly9jb21tdW5pdHkuYXJtLmNvbS9jZnMtZmlsZS9fX2tleS9jb21tdW5pdHlzZXJ2ZXItYmxvZ3MtY29tcG9uZW50cy13ZWJsb2dmaWxlcy8wMC0wMC0wMC0yMC02Ni9zaWdncmFwaDIwMTVfMkQwMF9tbWdfMkQwMF9tYXJpdXNfMkQwMF9ub3Rlcy5wZGZcclxuICogQGF1dGhvcnMgUm9sYW5kIEhlZXIsIEhGVSwgMjAyMyB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIzIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXHJcbiAqL1xyXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxucHJlY2lzaW9uIGhpZ2hwIGludDtcclxuXHJcbnVuaWZvcm0gaW50IHVfaU1vZGU7IC8vIDA6IGV4dHJhY3QsIDE6IGRvd25zYW1wbGUsIDI6IHVwc2FtcGxlLCAzOiBhcHBseVxyXG51bmlmb3JtIGZsb2F0IHVfZlRocmVzaG9sZDtcclxudW5pZm9ybSBmbG9hdCB1X2ZJbnRlbnNpdHk7XHJcbnVuaWZvcm0gZmxvYXQgdV9mSGlnaGxpZ2h0RGVzYXR1cmF0aW9uO1xyXG51bmlmb3JtIHZlYzIgdV92Y3RUZXhlbDtcclxuXHJcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4U291cmNlO1xyXG5cclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG4vLyBvbGQgZ2F1c3NpYW4gYmx1clxyXG4vLyBmbGF0IGluIHZlYzJbOV0gdl92Y3RPZmZzZXRzO1xyXG4vLyBjb25zdCBmbG9hdCBnYXVzc2lhbktlcm5lbFs5XSA9IGZsb2F0W10oMC4wNDUsIDAuMTIyLCAwLjA0NSwgMC4xMjIsIDAuMzMyLCAwLjEyMiwgMC4wNDUsIDAuMTIyLCAwLjA0NSk7XHJcbi8vIHZlYzQgZG93bnNhbXBsZSh2ZWMyIF92Y3RUZXh0dXJlKSB7XHJcbi8vICAgdmVjNCB2Y3RDb2xvciA9IHZlYzQoMC4wKTtcclxuLy8gICBmb3IgKGludCBpID0gMDsgaSA8IDk7IGkrKykgXHJcbi8vICAgICB2Y3RDb2xvciArPSB0ZXh0dXJlKHVfdGV4U291cmNlLCB2X3ZjdFRleHR1cmUgKyB2X3ZjdE9mZnNldHNbaV0pICogZ2F1c3NpYW5LZXJuZWxbaV07XHJcbi8vICAgcmV0dXJuIHZjdENvbG9yO1xyXG4vLyB9XHJcbi8vIHZlYzQgdXBzYW1wbGUodmVjMiBfdmN0VGV4dHVyZSkge1xyXG4vLyAgIHZlYzQgdmN0Q29sb3IgPSB2ZWM0KDAuMCk7XHJcbi8vICAgZm9yIChpbnQgaSA9IDA7IGkgPCA5OyBpKyspIFxyXG4vLyAgICAgdmN0Q29sb3IgKz0gdGV4dHVyZSh1X3RleFNvdXJjZSwgX3ZjdFRleHR1cmUgKyB2X3ZjdE9mZnNldHNbaV0pICogZ2F1c3NpYW5LZXJuZWxbaV07XHJcbi8vICAgcmV0dXJuIHZjdENvbG9yO1xyXG4vLyB9XHJcblxyXG4vLyB2ZWMzIGV4dHJhY3QodmVjMiBfdmN0VGV4dHVyZSkge1xyXG4vLyAgIHZlYzMgdmN0Q29sb3IgPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSkucmdiO1xyXG4vLyAgIGlmKGFueShncmVhdGVyVGhhbih2Y3RDb2xvciwgdmVjMyh1X2ZUaHJlc2hvbGQpKSkpXHJcbi8vICAgICByZXR1cm4gdmN0Q29sb3I7XHJcbi8vICAgZGlzY2FyZDtcclxuLy8gfVxyXG5cclxuLy8gdmVjMyBleHRyYWN0KHZlYzIgX3ZjdFRleHR1cmUpIHtcclxuLy8gICB2ZWMzIHZjdENvbG9yID0gdGV4dHVyZSh1X3RleFNvdXJjZSwgX3ZjdFRleHR1cmUpLnJnYjtcclxuLy8gICBmbG9hdCBsdW1pbmFuY2UgPSBkb3QodmN0Q29sb3IsIHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCkpO1xyXG4vLyAgIGlmKGx1bWluYW5jZSA+IHVfZlRocmVzaG9sZClcclxuLy8gICAgIHJldHVybiB2Y3RDb2xvcjtcclxuLy8gICBkaXNjYXJkO1xyXG4vLyB9XHJcblxyXG4vLyBvbGQgZXh0cmFjdGlvbiB3aXRoIGF2ZXJhZ2UgYnJpZ2h0bmVzc1xyXG52ZWMzIGV4dHJhY3QodmVjMiBfdmN0VGV4dHVyZSkge1xyXG4gIHZlYzMgdmN0Q29sb3IgPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSkucmdiO1xyXG4gIGZsb2F0IGZUaHJlc2hvbGQgPSB1X2ZUaHJlc2hvbGQ7XHJcbiAgaWYoZlRocmVzaG9sZCA+PSAxLjApXHJcbiAgICBmVGhyZXNob2xkID0gMC45OTk5OTk7XHJcblxyXG4gIHZjdENvbG9yID0gdmN0Q29sb3IgLSBmVGhyZXNob2xkO1xyXG4gIHZjdENvbG9yID0gdmN0Q29sb3IgLyAoMS4wIC0gZlRocmVzaG9sZCk7IC8vIG5lZ2F0aXZlIHZhbHVlcyBtaWdodCByZWNlaXZlIHZhbHVlcyBhYm92ZSAxLjAuLi5cclxuICBcclxuICBmbG9hdCBhdmVyYWdlQnJpZ2h0bmVzcyA9ICgoKHZjdENvbG9yLnIgKyB2Y3RDb2xvci5nICsgdmN0Q29sb3IuYikgLyAzLjApICogMC4yKSArIDAuODsgLy90aGUgZWZmZWN0IGlzIHJlZHVjZWQgYnkgZmlyc3Qgc2V0dGluZyBpdCB0byBhIDAuMC0wLjIgcmFuZ2UgYW5kIHRoZW4gYWRkaW5nIDAuOFxyXG4gIHZjdENvbG9yID0gY2xhbXAodmN0Q29sb3IsIDAuMCwgMS4wKSAqIGNsYW1wKGF2ZXJhZ2VCcmlnaHRuZXNzLCAwLjAsIDEuMCk7XHJcbiAgcmV0dXJuIHZjdENvbG9yO1xyXG59XHJcblxyXG52ZWM0IGRvd25zYW1wbGUodmVjMiBfdmN0VGV4dHVyZSkge1xyXG4gIHZlYzQgc3VtID0gdGV4dHVyZSh1X3RleFNvdXJjZSwgX3ZjdFRleHR1cmUpICogNC4wO1xyXG4gIHN1bSArPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSAtIHVfdmN0VGV4ZWwueHkpO1xyXG4gIHN1bSArPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSArIHVfdmN0VGV4ZWwueHkpO1xyXG4gIHN1bSArPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSArIHZlYzIodV92Y3RUZXhlbC54LCAtdV92Y3RUZXhlbC55KSk7XHJcbiAgc3VtICs9IHRleHR1cmUodV90ZXhTb3VyY2UsIF92Y3RUZXh0dXJlIC0gdmVjMih1X3ZjdFRleGVsLngsIC11X3ZjdFRleGVsLnkpKTtcclxuXHJcbiAgcmV0dXJuIHN1bSAvIDguMDtcclxufVxyXG5cclxudmVjNCB1cHNhbXBsZSh2ZWMyIF92Y3RUZXh0dXJlKSB7XHJcbiAgdmVjNCBzdW0gPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSArIHZlYzIoLXVfdmN0VGV4ZWwueCAqIDIuMCwgMC4wKSk7XHJcbiAgc3VtICs9IHRleHR1cmUodV90ZXhTb3VyY2UsIF92Y3RUZXh0dXJlICsgdmVjMigtdV92Y3RUZXhlbC54LCB1X3ZjdFRleGVsLnkpKSAqIDIuMDtcclxuICBzdW0gKz0gdGV4dHVyZSh1X3RleFNvdXJjZSwgX3ZjdFRleHR1cmUgKyB2ZWMyKDAuMCwgdV92Y3RUZXhlbC55ICogMi4wKSk7XHJcbiAgc3VtICs9IHRleHR1cmUodV90ZXhTb3VyY2UsIF92Y3RUZXh0dXJlICsgdmVjMih1X3ZjdFRleGVsLngsIHVfdmN0VGV4ZWwueSkpICogMi4wO1xyXG4gIHN1bSArPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSArIHZlYzIodV92Y3RUZXhlbC54ICogMi4wLCAwLjApKTtcclxuICBzdW0gKz0gdGV4dHVyZSh1X3RleFNvdXJjZSwgX3ZjdFRleHR1cmUgKyB2ZWMyKHVfdmN0VGV4ZWwueCwgLXVfdmN0VGV4ZWwueSkpICogMi4wO1xyXG4gIHN1bSArPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSArIHZlYzIoMC4wLCAtdV92Y3RUZXhlbC55ICogMi4wKSk7XHJcbiAgc3VtICs9IHRleHR1cmUodV90ZXhTb3VyY2UsIF92Y3RUZXh0dXJlICsgdmVjMigtdV92Y3RUZXhlbC54LCAtdV92Y3RUZXhlbC55KSkgKiAyLjA7XHJcbiAgcmV0dXJuIHN1bSAvIDEyLjA7XHJcbn1cclxuXHJcbnZlYzMgYXBwbHkodmVjMiBfdmN0VGV4dHVyZSkge1xyXG4gIHZlYzMgdmN0Qmxvb20gPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSkucmdiO1xyXG4gIGlmICh2Y3RCbG9vbS5yID49IDEuMCB8fCB2Y3RCbG9vbS5nID49IDEuMCB8fCB2Y3RCbG9vbS5iID49IDEuMCkgLy8gbWF5YmUgdXNlIHRocmVzaG9sZCBpbnN0ZWFkIG9mIDEuMD9cclxuICAgIHZjdEJsb29tID0gbWl4KHZjdEJsb29tLCB2ZWMzKDEuMCksIHVfZkhpZ2hsaWdodERlc2F0dXJhdGlvbik7XHJcbiAgdmN0Qmxvb20gPSBjbGFtcCh2Y3RCbG9vbSAqIHVfZkludGVuc2l0eSwgMC4wLCAxLjApO1xyXG4gIHJldHVybiB2Y3RCbG9vbTtcclxufVxyXG5cclxudm9pZCBtYWluKCkge1xyXG4gIHN3aXRjaCh1X2lNb2RlKSB7XHJcbiAgICBjYXNlIDA6XHJcbiAgICAgIHZjdEZyYWcucmdiID0gZXh0cmFjdCh2X3ZjdFRleHR1cmUpO1xyXG4gICAgICB2Y3RGcmFnLmEgPSAxLjA7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgMTpcclxuICAgICAgdmN0RnJhZyA9IGRvd25zYW1wbGUodl92Y3RUZXh0dXJlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAyOlxyXG4gICAgICB2Y3RGcmFnID0gdXBzYW1wbGUodl92Y3RUZXh0dXJlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAzOlxyXG4gICAgICB2Y3RGcmFnLnJnYiA9IGFwcGx5KHZfdmN0VGV4dHVyZSk7XHJcbiAgICAgIHZjdEZyYWcuYSA9IDEuMDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdmN0RnJhZyA9IHRleHR1cmUodV90ZXhTb3VyY2UsIHZfdmN0VGV4dHVyZSk7XHJcbiAgICAgIHJldHVybjtcclxuICB9XHJcbn1gO1xuICBzaGFkZXJTb3VyY2VzW1wiU2hhZGVyR2l6bW8uZnJhZ1wiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogLi4uXHJcbiogQGF1dGhvcnMgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXHJcbiovXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5wcmVjaXNpb24gaGlnaHAgaW50O1xyXG5cclxudW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XHJcblxyXG5vdXQgdmVjNCB2Y3RGcmFnO1xyXG5cclxuLy8gdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhEZXB0aFN0ZW5jaWw7XHJcbiNpZiBkZWZpbmVkKFRFWFRVUkUpXHJcblxyXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4Q29sb3I7XHJcbiAgaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbiAgXHJcbiNlbmRpZlxyXG5cclxuLy8gLy8gNHg0IEJheWVyIG1hdHJpeCBmb3IgZGl0aGVyaW5nXHJcbi8vIGNvbnN0IGZsb2F0IG10eERpdGhlclsxNl0gPSBmbG9hdFtdKFxyXG4vLyAgIDEuMCAvIDE3LjAsICA5LjAgLyAxNy4wLCAgMy4wIC8gMTcuMCwgMTEuMCAvIDE3LjAsXHJcbi8vICAgMTMuMCAvIDE3LjAsICA1LjAgLyAxNy4wLCAxNS4wIC8gMTcuMCwgIDcuMCAvIDE3LjAsXHJcbi8vICAgNC4wIC8gMTcuMCwgMTIuMCAvIDE3LjAsICAyLjAgLyAxNy4wLCAxMC4wIC8gMTcuMCxcclxuLy8gICAxNi4wIC8gMTcuMCwgIDguMCAvIDE3LjAsIDE0LjAgLyAxNy4wLCAgNi4wIC8gMTcuMFxyXG4vLyApO1xyXG5cclxudm9pZCBtYWluKCkge1xyXG4gIHZjdEZyYWcgPSB1X3ZjdENvbG9yO1xyXG5cclxuICAjaWYgZGVmaW5lZChURVhUVVJFKVxyXG5cclxuICAgICAgdmN0RnJhZyAqPSB0ZXh0dXJlKHVfdGV4Q29sb3IsIHZfdmN0VGV4dHVyZSk7XHJcblxyXG4gICNlbmRpZlxyXG5cclxuICAvLyBpbnQgeCA9IGludChnbF9GcmFnQ29vcmQueCkgJSA0O1xyXG4gIC8vIGludCB5ID0gaW50KGdsX0ZyYWdDb29yZC55KSAlIDQ7XHJcbiAgLy8gaW50IGluZGV4ID0geSAqIDQgKyB4O1xyXG4gIC8vIC8vIERpc2NhcmQgdGhlIGZyYWdtZW50IGlmIGl0cyBhbHBoYSBpcyBsZXNzIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgaW4gdGhlIGRpdGhlcmluZyBtYXRyaXhcclxuICAvLyBpZiAodmN0RnJhZy5hIDwgbXR4RGl0aGVyW2luZGV4XSkgXHJcbiAgLy8gICBkaXNjYXJkO1xyXG5cclxuICAvLyAvLyBEaXNjYXJkIHRoZSBmcmFnbWVudCBpZiBpdHMgYWxwaGEgaXMgMFxyXG4gIC8vIGlmICh2Y3RGcmFnLmEgPT0gMC4wKVxyXG4gIC8vICAgZGlzY2FyZDtcclxuXHJcbiAgLy8gLy8gQ3JlYXRlIGEgY2hlY2tlcmJvYXJkIHBhdHRlcm4gZm9yIGFscGhhIHZhbHVlcyBsZXNzIHRoYW4gMC41XHJcbiAgLy8gZWxzZSBpZiAodmN0RnJhZy5hIDwgMC41ICYmICgoeCArIHkpICUgMiA9PSAwKSlcclxuICAvLyAgIGRpc2NhcmQ7XHJcblxyXG4gIC8vIHZjdEZyYWcuYSA9IDEuMDtcclxuXHJcbiAgaWYgKHZjdEZyYWcuYSA8IDAuMDEpXHJcbiAgICBkaXNjYXJkO1xyXG59YDtcbiAgc2hhZGVyU291cmNlc1tcIlNoYWRlckdpem1vLnZlcnRcIl0gPSAvKmdsc2wqLyBgI3ZlcnNpb24gMzAwIGVzXHJcbi8qKlxyXG4qIC4uLlxyXG4qIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xyXG4qL1xyXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxucHJlY2lzaW9uIGhpZ2hwIGludDtcclxuXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkOyAvLyB1X210eE1vZGVsXHJcblxyXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENhbWVyYSB7XHJcbiAgbWF0NCB1X210eFdvcmxkVG9DYW1lcmE7IC8vIHVfbXR4Vmlld1xyXG4gIG1hdDQgdV9tdHhQcm9qZWN0aW9uOyBcclxuICBtYXQ0IHVfbXR4V29ybGRUb1ZpZXc7IC8vIHVfbXR4Vmlld1Byb2plY3Rpb25cclxuICB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG59O1xyXG5cclxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjMyBhX3ZjdFBvc2l0aW9uO1xyXG5cclxuI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuXHJcbiAgbGF5b3V0KGxvY2F0aW9uID0gMikgaW4gdmVjMiBhX3ZjdFRleHR1cmU7XHJcbiAgb3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG5cclxuI2VuZGlmXHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgZ2xfUG9zaXRpb24gPSB1X210eFdvcmxkVG9WaWV3ICogdV9tdHhNZXNoVG9Xb3JsZCAqIHZlYzQoYV92Y3RQb3NpdGlvbiwgMS4wKTtcclxuXHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuXHJcbiAgICB2X3ZjdFRleHR1cmUgPSBhX3ZjdFRleHR1cmU7XHJcblxyXG4gICNlbmRpZlxyXG59YDtcbiAgc2hhZGVyU291cmNlc1tcIlNoYWRlck91dGxpbmUuZnJhZ1wiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNVxyXG4gKi9cclxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbnByZWNpc2lvbiBoaWdocCBpbnQ7XHJcblxyXG51bmlmb3JtIHZlYzIgdV92Y3RUZXhlbDtcclxudW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XHJcbnVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yT2NjbHVkZWQ7XHJcblxyXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleERlcHRoT3V0bGluZTtcclxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhEZXB0aFNjZW5lO1xyXG5cclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG5mbG9hdCBnZXREZXB0aCh2ZWMyIF92Y3RUZXh0dXJlKSB7XHJcbiAgcmV0dXJuIHRleHR1cmUodV90ZXhEZXB0aE91dGxpbmUsIF92Y3RUZXh0dXJlKS5yO1xyXG59XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgZmxvYXQgZkRlcHRoID0gZ2V0RGVwdGgodl92Y3RUZXh0dXJlKTtcclxuXHJcbiAgaWYgKGZEZXB0aCAhPSAxLjApXHJcbiAgICBkaXNjYXJkO1xyXG5cclxuICBmbG9hdCBmRGVwdGhUb3AgPSBnZXREZXB0aCh2X3ZjdFRleHR1cmUgKyB2ZWMyKDAsIHVfdmN0VGV4ZWwueSkpO1xyXG4gIGZsb2F0IGZEZXB0aFJpZ2h0ID0gZ2V0RGVwdGgodl92Y3RUZXh0dXJlICsgdmVjMih1X3ZjdFRleGVsLngsIDApKTtcclxuICBmbG9hdCBmRGVwdGhCb3R0b20gPSBnZXREZXB0aCh2X3ZjdFRleHR1cmUgKyB2ZWMyKDAsIC11X3ZjdFRleGVsLnkpKTtcclxuICBmbG9hdCBmRGVwdGhMZWZ0ID0gZ2V0RGVwdGgodl92Y3RUZXh0dXJlICsgdmVjMigtdV92Y3RUZXhlbC54LCAwKSk7XHJcblxyXG4gIGZsb2F0IGZEZXB0aE1pbiA9IG1pbihtaW4oZkRlcHRoVG9wLCBmRGVwdGhSaWdodCksIG1pbihmRGVwdGhCb3R0b20sIGZEZXB0aExlZnQpKTtcclxuICBmbG9hdCBmRGVwdGhEZWx0YSA9IGFicyhmRGVwdGggLSBmRGVwdGhNaW4pO1xyXG5cclxuICBpZiAoZkRlcHRoRGVsdGEgPT0gMC4wKVxyXG4gICAgZGlzY2FyZDtcclxuXHJcbiAgZmxvYXQgZkRlcHRoU2NlbmUgPSB0ZXh0dXJlKHVfdGV4RGVwdGhTY2VuZSwgdl92Y3RUZXh0dXJlKS5yO1xyXG4gIGlmIChmRGVwdGhNaW4gPCBmRGVwdGhTY2VuZSlcclxuICAgIHZjdEZyYWcgPSB1X3ZjdENvbG9yO1xyXG4gIGVsc2VcclxuICAgIHZjdEZyYWcgPSB1X3ZjdENvbG9yT2NjbHVkZWQ7XHJcbn1gO1xuICBzaGFkZXJTb3VyY2VzW1wiU2hhZGVyUGhvbmcuZnJhZ1wiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogUGhvbmcgc2hhZGluZ1xyXG4qIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIyIHwgUm9sYW5kIEhlZXIsIEhGVSwgMjAyMyB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xyXG4qL1xyXG5cclxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbnByZWNpc2lvbiBoaWdocCBpbnQ7XHJcblxyXG51bmlmb3JtIHZlYzQgdV92Y3RDb2xvcjtcclxudW5pZm9ybSBmbG9hdCB1X2ZEaWZmdXNlO1xyXG51bmlmb3JtIGZsb2F0IHVfZlNwZWN1bGFyO1xyXG51bmlmb3JtIGZsb2F0IHVfZkludGVuc2l0eTtcclxudW5pZm9ybSBmbG9hdCB1X2ZNZXRhbGxpYztcclxudW5pZm9ybSB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG5cclxudW5pZm9ybSBib29sIHVfYkZvZztcclxudW5pZm9ybSB2ZWM0IHVfdmN0Rm9nQ29sb3I7XHJcbnVuaWZvcm0gZmxvYXQgdV9mRm9nTmVhcjtcclxudW5pZm9ybSBmbG9hdCB1X2ZGb2dGYXI7XHJcblxyXG5pbiB2ZWM0IHZfdmN0Q29sb3I7XHJcbmluIHZlYzMgdl92Y3RQb3NpdGlvbjtcclxuXHJcbmxheW91dChsb2NhdGlvbiA9IDApIG91dCB2ZWM0IHZjdEZyYWc7XHJcbmxheW91dChsb2NhdGlvbiA9IDEpIG91dCB2ZWM0IHZjdEZyYWdQb3NpdGlvbjtcclxubGF5b3V0KGxvY2F0aW9uID0gMikgb3V0IHZlYzQgdmN0RnJhZ05vcm1hbDtcclxuXHJcbiNpZmRlZiBQSE9OR1xyXG5cclxuICBpbiB2ZWMzIHZfdmN0Tm9ybWFsO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWZkZWYgRkxBVFxyXG5cclxuICBmbGF0IGluIHZlYzMgdl92Y3RQb3NpdGlvbkZsYXQ7XHJcblxyXG4jZW5kaWZcclxuXHJcbnN0cnVjdCBMaWdodCB7XHJcbiAgdmVjNCB2Y3RDb2xvcjtcclxuICBtYXQ0IG10eFNoYXBlO1xyXG4gIG1hdDQgbXR4U2hhcGVJbnZlcnNlO1xyXG59O1xyXG5cclxuY29uc3QgdWludCBNQVhfTElHSFRTX0RJUkVDVElPTkFMID0gMTV1O1xyXG5jb25zdCB1aW50IE1BWF9MSUdIVFNfUE9JTlQgPSAxMDB1O1xyXG5jb25zdCB1aW50IE1BWF9MSUdIVFNfU1BPVCA9IDEwMHU7XHJcblxyXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIExpZ2h0cyB7XHJcbiAgdWludCB1X25MaWdodHNEaXJlY3Rpb25hbDtcclxuICB1aW50IHVfbkxpZ2h0c1BvaW50O1xyXG4gIHVpbnQgdV9uTGlnaHRzU3BvdDtcclxuICB1aW50IHBhZGRpbmc7IC8vIEFkZCBwYWRkaW5nIHRvIGFsaWduIHRvIDE2IGJ5dGVzXHJcbiAgTGlnaHQgdV9hbWJpZW50O1xyXG4gIExpZ2h0IHVfZGlyZWN0aW9uYWxbTUFYX0xJR0hUU19ESVJFQ1RJT05BTF07XHJcbiAgTGlnaHQgdV9wb2ludFtNQVhfTElHSFRTX1BPSU5UXTtcclxuICBMaWdodCB1X3Nwb3RbTUFYX0xJR0hUU19TUE9UXTtcclxufTtcclxuXHJcbi8vIFRFWFRVUkU6IGlucHV0IFVWcyBhbmQgdGV4dHVyZVxyXG4jaWZkZWYgVEVYVFVSRVxyXG5cclxuICBpbiB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleENvbG9yO1xyXG5cclxuI2VuZGlmXHJcblxyXG4vLyBOT1JNQUxNQVA6IGlucHV0IFVWcyBhbmQgdGV4dHVyZVxyXG4jaWZkZWYgTk9STUFMTUFQXHJcblxyXG4gIGluIHZlYzMgdl92Y3RUYW5nZW50O1xyXG4gIGluIHZlYzMgdl92Y3RCaXRhbmdlbnQ7XHJcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhOb3JtYWw7XHJcblxyXG4jZW5kaWZcclxuXHJcbi8vIFJldHVybnMgYSB2ZWN0b3IgZm9yIHZpc3VhbGl6aW5nIG9uIG1vZGVsLiBHcmVhdCBmb3IgZGVidWdnaW5nXHJcbnZlYzQgc2hvd1ZlY3RvckFzQ29sb3IodmVjMyBfdmVjdG9yLCBib29sIF9jbGFtcCkge1xyXG4gIGlmKF9jbGFtcCkge1xyXG4gICAgX3ZlY3RvciAqPSAwLjU7XHJcbiAgICBfdmVjdG9yICs9IDAuNTtcclxuICB9XHJcbiAgcmV0dXJuIHZlYzQoX3ZlY3Rvci54LCBfdmVjdG9yLnksIF92ZWN0b3IueiwgMSk7XHJcbn1cclxuXHJcbnZvaWQgaWxsdW1pbmF0ZURpcmVjdGVkKHZlYzMgX3ZjdERpcmVjdGlvbiwgdmVjMyBfdmN0VmlldywgdmVjMyBfdmN0Tm9ybWFsLCB2ZWMzIF92Y3RDb2xvciwgaW5vdXQgdmVjMyBfdmN0RGlmZnVzZSwgaW5vdXQgdmVjMyBfdmN0U3BlY3VsYXIpIHtcclxuICB2ZWMzIHZjdERpcmVjdGlvbiA9IG5vcm1hbGl6ZShfdmN0RGlyZWN0aW9uKTtcclxuICBmbG9hdCBmSWxsdW1pbmF0aW9uID0gLWRvdChfdmN0Tm9ybWFsLCB2Y3REaXJlY3Rpb24pO1xyXG4gIGlmKGZJbGx1bWluYXRpb24gPiAwLjApIHtcclxuICAgIF92Y3REaWZmdXNlICs9IHVfZkRpZmZ1c2UgKiBmSWxsdW1pbmF0aW9uICogX3ZjdENvbG9yO1xyXG5cclxuICAgIGlmKHVfZlNwZWN1bGFyIDw9IDAuMClcclxuICAgICAgcmV0dXJuO1xyXG4gICAgICBcclxuICAgIC8vQkxJTk4tUGhvbmcgU2hhZGluZ1xyXG4gICAgdmVjMyBoYWxmd2F5RGlyID0gbm9ybWFsaXplKC12Y3REaXJlY3Rpb24gLSBfdmN0Vmlldyk7XHJcbiAgICBmbG9hdCBmYWN0b3IgPSBtYXgoZG90KC12Y3REaXJlY3Rpb24sIF92Y3ROb3JtYWwpLCAwLjApOyAvL0ZhY3RvciBmb3Igc21vb3RoaW5nIG91dCB0cmFuc2l0aW9uIGZyb20gc3VyZmFjZSBmYWNpbmcgdGhlIGxpZ2h0c291cmNlIHRvIHN1cmZhY2UgZmFjaW5nIGF3YXkgZnJvbSB0aGUgbGlnaHRzb3VyY2VcclxuICAgIGZhY3RvciA9IDEuMCAtIChwb3coZmFjdG9yIC0gMS4wLCA4LjApKTsgICAgICAgICAgICAgICAgIC8vVGhlIGZhY3RvciBpcyBhbHRlcmVkIGluIG9yZGVyIHRvIGNsZWFybHkgc2VlIHRoZSBzcGVjdWxhciBoaWdobGlnaHQgZXZlbiBhdCBzdGVlcCBhbmdsZXMsIHdoaWxlIHN0aWxsIHByZXZlbnRpbmcgYXJ0aWZhY3RzXHJcblxyXG4gICAgX3ZjdFNwZWN1bGFyICs9IHBvdyhtYXgoZG90KF92Y3ROb3JtYWwsIGhhbGZ3YXlEaXIpLCAwLjApLCBleHAyKHVfZlNwZWN1bGFyICogNS4wKSkgKiB1X2ZTcGVjdWxhciAqIHVfZkludGVuc2l0eSAqIGZhY3RvciAqIF92Y3RDb2xvcjtcclxuICB9XHJcbn1cclxuXHJcbmZsb2F0IGdldEZvZyh2ZWMzIF92Y3RQb3NpdGlvbikge1xyXG4gIGZsb2F0IGZEaXN0YW5jZSA9IGxlbmd0aChfdmN0UG9zaXRpb24gLSB1X3ZjdENhbWVyYSk7IC8vIG1heWJlIHVzZSB6LWRlcHRoIGluc3RlYWQgb2YgZXVjbGlkZWFuIGRlcHRoXHJcbiAgZmxvYXQgZkZvZyA9IGNsYW1wKChmRGlzdGFuY2UgLSB1X2ZGb2dOZWFyKSAvICh1X2ZGb2dGYXIgLSB1X2ZGb2dOZWFyKSwgMC4wLCAxLjApO1xyXG4gIGZGb2cgPSAtcG93KGZGb2csIDIuMCkgKyAoMi4wICogZkZvZyk7IC8vIGxldHMgZm9nIGFwcGVhciBxdWlja2VyIGFuZCBmYWxsIG9mZiBzbG93ZXIgcmVzdWx0cyBpbiBhIG1vcmUgZ3JhZHVhbCBmYWxsb2ZmXHJcbiAgcmV0dXJuIGZGb2c7XHJcbn1cclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICAjaWYgZGVmaW5lZChQSE9ORykgJiYgIWRlZmluZWQoRkxBVClcclxuXHJcbiAgICAjaWZkZWYgTk9STUFMTUFQXHJcblxyXG4gICAgICBtYXQzIG10eFRCTiA9IG1hdDMobm9ybWFsaXplKHZfdmN0VGFuZ2VudCksIG5vcm1hbGl6ZSh2X3ZjdEJpdGFuZ2VudCksIG5vcm1hbGl6ZSh2X3ZjdE5vcm1hbCkpO1xyXG4gICAgICB2ZWMzIHZjdE5vcm1hbCA9IHRleHR1cmUodV90ZXhOb3JtYWwsIHZfdmN0VGV4dHVyZSkueHl6ICogMi4wIC0gMS4wO1xyXG4gICAgICB2Y3ROb3JtYWwgPSBub3JtYWxpemUobXR4VEJOICogdmN0Tm9ybWFsKTtcclxuXHJcbiAgICAjZWxzZVxyXG5cclxuICAgICAgdmVjMyB2Y3ROb3JtYWwgPSBub3JtYWxpemUodl92Y3ROb3JtYWwpO1xyXG5cclxuICAgICNlbmRpZlxyXG5cclxuICAgIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZSh2X3ZjdFBvc2l0aW9uIC0gdV92Y3RDYW1lcmEpO1xyXG4gICAgdmVjMyB2Y3RQb3NpdGlvbiA9IHZfdmN0UG9zaXRpb247XHJcblxyXG4gICNlbmRpZlxyXG5cclxuICAjaWZkZWYgRkxBVFxyXG5cclxuICAgIHZlYzMgdmN0RmR4ID0gZEZkeCh2X3ZjdFBvc2l0aW9uKTtcclxuICAgIHZlYzMgdmN0RmR5ID0gZEZkeSh2X3ZjdFBvc2l0aW9uKTtcclxuICAgIHZlYzMgdmN0Tm9ybWFsID0gbm9ybWFsaXplKGNyb3NzKHZjdEZkeCwgdmN0RmR5KSk7XHJcbiAgICB2ZWMzIHZjdFZpZXcgPSBub3JtYWxpemUodl92Y3RQb3NpdGlvbkZsYXQgLSB1X3ZjdENhbWVyYSk7XHJcbiAgICB2ZWMzIHZjdFBvc2l0aW9uID0gdl92Y3RQb3NpdGlvbkZsYXQ7XHJcblxyXG4gICNlbmRpZlxyXG5cclxuICB2ZWMzIHZjdERpZmZ1c2UgPSB1X2ZEaWZmdXNlICogdV9hbWJpZW50LnZjdENvbG9yLnJnYjtcclxuICB2ZWMzIHZjdFNwZWN1bGFyID0gdmVjMygwLCAwLCAwKTtcclxuXHJcbiAgLy8gY2FsY3VsYXRlIGRpcmVjdGlvbmFsIGxpZ2h0IGVmZmVjdFxyXG4gIGZvcih1aW50IGkgPSAwdTsgaSA8IHVfbkxpZ2h0c0RpcmVjdGlvbmFsOyBpKyspIHtcclxuICAgIHZlYzMgdmN0RGlyZWN0aW9uID0gdmVjMyh1X2RpcmVjdGlvbmFsW2ldLm10eFNoYXBlICogdmVjNCgwLjAsIDAuMCwgMS4wLCAxLjApKTtcclxuICAgIGlsbHVtaW5hdGVEaXJlY3RlZCh2Y3REaXJlY3Rpb24sIHZjdFZpZXcsIHZjdE5vcm1hbCwgdV9kaXJlY3Rpb25hbFtpXS52Y3RDb2xvci5yZ2IsIHZjdERpZmZ1c2UsIHZjdFNwZWN1bGFyKTtcclxuICB9XHJcblxyXG4gIC8vIGNhbGN1bGF0ZSBwb2ludCBsaWdodCBlZmZlY3RcclxuICBmb3IodWludCBpID0gMHU7IGkgPCB1X25MaWdodHNQb2ludDsgaSsrKSB7XHJcbiAgICB2ZWMzIHZjdFBvc2l0aW9uTGlnaHQgPSB2ZWMzKHVfcG9pbnRbaV0ubXR4U2hhcGUgKiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCkpO1xyXG4gICAgdmVjMyB2Y3REaXJlY3Rpb24gPSB2Y3RQb3NpdGlvbiAtIHZjdFBvc2l0aW9uTGlnaHQ7XHJcbiAgICBmbG9hdCBmSW50ZW5zaXR5ID0gMS4wIC0gbGVuZ3RoKG1hdDModV9wb2ludFtpXS5tdHhTaGFwZUludmVyc2UpICogdmN0RGlyZWN0aW9uKTtcclxuICAgIGlmKGZJbnRlbnNpdHkgPCAwLjApXHJcbiAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgIGlsbHVtaW5hdGVEaXJlY3RlZCh2Y3REaXJlY3Rpb24sIHZjdFZpZXcsIHZjdE5vcm1hbCwgdV9wb2ludFtpXS52Y3RDb2xvci5yZ2IgKiBmSW50ZW5zaXR5LCB2Y3REaWZmdXNlLCB2Y3RTcGVjdWxhcik7XHJcbiAgfVxyXG5cclxuICAvLyBjYWxjdWxhdGUgc3BvdCBsaWdodCBlZmZlY3RcclxuICBmb3IodWludCBpID0gMHU7IGkgPCB1X25MaWdodHNTcG90OyBpKyspIHtcclxuICAgIHZlYzMgdmN0UG9zaXRpb25MaWdodCA9IHZlYzModV9zcG90W2ldLm10eFNoYXBlICogdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApKTtcclxuICAgIHZlYzMgdmN0RGlyZWN0aW9uID0gdmN0UG9zaXRpb24gLSB2Y3RQb3NpdGlvbkxpZ2h0O1xyXG4gICAgdmVjMyB2Y3REaXJlY3Rpb25JbnZlcnRlZCA9IG1hdDModV9zcG90W2ldLm10eFNoYXBlSW52ZXJzZSkgKiB2Y3REaXJlY3Rpb247XHJcbiAgICBpZih2Y3REaXJlY3Rpb25JbnZlcnRlZC56IDw9IDAuMClcclxuICAgICAgY29udGludWU7XHJcblxyXG4gICAgZmxvYXQgZkludGVuc2l0eSA9IDEuMCAtIG1pbigxLjAsIDIuMCAqIGxlbmd0aCh2Y3REaXJlY3Rpb25JbnZlcnRlZC54eSkgLyB2Y3REaXJlY3Rpb25JbnZlcnRlZC56KTsgICAgLy9Db25lc2hhcGUgdGhhdCBpcyBicmlnaHRlc3QgaW4gdGhlIGNlbnRlci4gUG9zc2libGUgVE9ETzogXCJWYXJpYWJsZSBTcG90bGlnaHRzb2Z0bmVzc1wiXHJcbiAgICBmSW50ZW5zaXR5ICo9IDEuMCAtIHBvdyh2Y3REaXJlY3Rpb25JbnZlcnRlZC56LCAyLjApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1ByZXZlbnRzIGhhcnNoIGxpZ2h0aW5nIGFydGlmYWN0cyBhdCBib3VuZGFyeSBvZiB0aGUgZ2l2ZW4gc3BvdGxpZ2h0XHJcbiAgICBpZihmSW50ZW5zaXR5IDwgMC4wKVxyXG4gICAgICBjb250aW51ZTtcclxuXHJcbiAgICBpbGx1bWluYXRlRGlyZWN0ZWQodmN0RGlyZWN0aW9uLCB2Y3RWaWV3LCB2Y3ROb3JtYWwsIHVfc3BvdFtpXS52Y3RDb2xvci5yZ2IgKiBmSW50ZW5zaXR5LCB2Y3REaWZmdXNlLCB2Y3RTcGVjdWxhcik7XHJcbiAgfVxyXG5cclxuICB2Y3RGcmFnLnJnYiA9IHZjdERpZmZ1c2UgKyB2Y3RTcGVjdWxhciAqIHVfZk1ldGFsbGljO1xyXG4gIHZjdEZyYWcuYSA9IDEuMDtcclxuXHJcbiAgI2lmZGVmIFRFWFRVUkVcclxuXHJcbiAgICB2ZWM0IHZjdENvbG9yVGV4dHVyZSA9IHRleHR1cmUodV90ZXhDb2xvciwgdl92Y3RUZXh0dXJlKTtcclxuICAgIHZjdEZyYWcgKj0gdmN0Q29sb3JUZXh0dXJlO1xyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgdmN0RnJhZyAqPSB1X3ZjdENvbG9yICogdl92Y3RDb2xvcjtcclxuICB2Y3RGcmFnLnJnYiArPSB2Y3RTcGVjdWxhciAqICgxLjAgLSB1X2ZNZXRhbGxpYyk7XHJcblxyXG4gIHZjdEZyYWdQb3NpdGlvbiA9IHZlYzQodl92Y3RQb3NpdGlvbiwgMS4wKTsgLy8gZG9uJ3QgdXNlIGZsYXQgaGVyZSwgYmVjYXVzZSB3ZSB3YW50IHRvIGludGVycG9sYXRlIHRoZSBwb3NpdGlvblxyXG4gIHZjdEZyYWdOb3JtYWwgPSB2ZWM0KHZjdE5vcm1hbCwgMS4wKTtcclxuXHJcbiAgaWYgKHVfYkZvZykgXHJcbiAgICB2Y3RGcmFnLnJnYiA9IG1peCh2Y3RGcmFnLnJnYiwgdV92Y3RGb2dDb2xvci5yZ2IsIGdldEZvZyh2Y3RQb3NpdGlvbikgKiB1X3ZjdEZvZ0NvbG9yLmEpO1xyXG5cclxuICB2Y3RGcmFnLnJnYiAqPSB2Y3RGcmFnLmE7XHJcblxyXG4gIGlmKHZjdEZyYWcuYSA8IDAuMDEpXHJcbiAgICBkaXNjYXJkO1xyXG59YDtcbiAgc2hhZGVyU291cmNlc1tcIlNoYWRlclBpY2suZnJhZ1wiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogUmVuZGVycyBmb3IgUmF5Y2FzdGluZ1xyXG4qIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiovXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5wcmVjaXNpb24gaGlnaHAgaW50O1xyXG5cclxudW5pZm9ybSBpbnQgdV9pZDtcclxudW5pZm9ybSB2ZWMyIHVfdmN0U2l6ZTtcclxudW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XHJcbm91dCBpdmVjNCB2Y3RGcmFnO1xyXG5cclxuI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuXHJcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhDb2xvcjtcclxuICBpbiB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuXHJcbiNlbmRpZlxyXG5cclxudm9pZCBtYWluKCkge1xyXG4gIGludCBwaXhlbCA9IGludCh0cnVuYyhnbF9GcmFnQ29vcmQueCkgKyB1X3ZjdFNpemUueCAqIHRydW5jKGdsX0ZyYWdDb29yZC55KSk7XHJcblxyXG4gIGlmIChwaXhlbCAhPSB1X2lkKVxyXG4gICAgZGlzY2FyZDtcclxuICBcclxuICB2ZWM0IHZjdENvbG9yID0gdV92Y3RDb2xvcjtcclxuICBcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKVxyXG5cclxuICAgIHZjdENvbG9yICo9IHRleHR1cmUodV90ZXhDb2xvciwgdl92Y3RUZXh0dXJlKTtcclxuXHJcbiAgI2VuZGlmXHJcblxyXG4gIHVpbnQgaWNvbG9yID0gdWludCh2Y3RDb2xvci5yICogMjU1LjApIDw8IDI0IHwgdWludCh2Y3RDb2xvci5nICogMjU1LjApIDw8IDE2IHwgdWludCh2Y3RDb2xvci5iICogMjU1LjApIDw8IDggfCB1aW50KHZjdENvbG9yLmEgKiAyNTUuMCk7XHJcbiAgXHJcbiAgdmN0RnJhZyA9IGl2ZWM0KGZsb2F0Qml0c1RvSW50KGdsX0ZyYWdDb29yZC56KSwgaWNvbG9yLCAwLCAwKTtcclxuXHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuXHJcbiAgICB2Y3RGcmFnLmIgPSBmbG9hdEJpdHNUb0ludCh2X3ZjdFRleHR1cmUueCk7XHJcbiAgICB2Y3RGcmFnLmEgPSBmbG9hdEJpdHNUb0ludCh2X3ZjdFRleHR1cmUueSk7XHJcblxyXG4gICNlbmRpZlxyXG59YDtcbiAgc2hhZGVyU291cmNlc1tcIlNoYWRlclBpY2sudmVydFwiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogUmVuZGVycyBmb3IgUmF5Y2FzdGluZ1xyXG4qIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiovXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkOyAvLyB1X210eE1vZGVsXHJcblxyXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENhbWVyYSB7XHJcbiAgbWF0NCB1X210eFdvcmxkVG9DYW1lcmE7IC8vIHVfbXR4Vmlld1xyXG4gIG1hdDQgdV9tdHhQcm9qZWN0aW9uOyBcclxuICBtYXQ0IHVfbXR4V29ybGRUb1ZpZXc7IC8vIHVfbXR4Vmlld1Byb2plY3Rpb25cclxuICB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG59O1xyXG5cclxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjMyBhX3ZjdFBvc2l0aW9uO1xyXG5cclxuI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuXHJcbiAgbGF5b3V0KGxvY2F0aW9uID0gMikgaW4gdmVjMiBhX3ZjdFRleHR1cmU7XHJcbiAgb3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG5cclxuI2VuZGlmXHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgZ2xfUG9zaXRpb24gPSB1X210eFdvcmxkVG9WaWV3ICogdV9tdHhNZXNoVG9Xb3JsZCAqIHZlYzQoYV92Y3RQb3NpdGlvbiwgMS4wKTtcclxuXHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuXHJcbiAgICB2X3ZjdFRleHR1cmUgPSBhX3ZjdFRleHR1cmU7XHJcblxyXG4gICNlbmRpZlxyXG59YDtcbiAgc2hhZGVyU291cmNlc1tcIlNoYWRlclNjcmVlbi52ZXJ0XCJdID0gLypnbHNsKi8gYCN2ZXJzaW9uIDMwMCBlc1xyXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxucHJlY2lzaW9uIGhpZ2hwIGludDtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBmdWxsc2NyZWVuIHRyaWFuZ2xlIHdoaWNoIGNvdGFpbnMgdGhlIHNjcmVlbiBxdWFkIGFuZCBzZXRzIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFjY29yZGluZ2x5LlxyXG4gKiBAYXV0aG9ycyBSb2xhbmQgSGVlciwgSEZVLCAyMDIzIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjMgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjNcclxuICpcclxuICogIDIgIDMgLlxyXG4gKiAgICAgICAuICAuXHJcbiAqICAgICAgIC4gICAgIC4gIFxyXG4gKiAgICAgICAuICAgICAgICAuXHJcbiAqICAxICAxIC4uLi4uLi4uLi4gIC5cclxuICogICAgICAgLiBzY3JlZW4gLiAgICAgLlxyXG4gKiAgICAgICAuICBxdWFkICAuICAgICAgICAuXHJcbiAqICAwIC0xIC4uLi4uLi4uLi4gIC4gIC4gIC4gIC5cclxuICogICAgcCAtMSAgICAgICAgMSAgICAgICAgICAgM1xyXG4gKiAgdCAgICAwICAgICAgICAxICAgICAgICAgICAyXHJcbiAqICBcclxuICogIHAgPT0gcG9zdGlvblxyXG4gKiAgdCA9PSB0ZXh0dXJlIGNvb3JkaW5hdGVcclxuICovXHJcblxyXG4vLyB1bmlmb3JtIHZlYzIgdV92Y3RSZXNvbHV0aW9uO1xyXG5cclxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG5cclxuLy8gI2lmZGVmIFNBTVBMRVxyXG5cclxuLy8gICBmbGF0IG91dCB2ZWMyWzldIHZfdmN0T2Zmc2V0cztcclxuXHJcbi8vICNlbmRpZlxyXG5cclxudm9pZCBtYWluKCkge1xyXG4gIGZsb2F0IHggPSBmbG9hdCgoZ2xfVmVydGV4SUQgJSAyKSAqIDQpOyAvLyAwLCA0LCAwXHJcbiAgZmxvYXQgeSA9IGZsb2F0KChnbF9WZXJ0ZXhJRCAvIDIpICogNCk7IC8vIDAsIDAsIDRcclxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoeCAtIDEuMCwgeSAtIDEuMCwgMC4wLCAxLjApOyAvLyAoLTEsIC0xKSwgKDMsIC0xKSwgKC0xLCAzKVxyXG4gIHZfdmN0VGV4dHVyZSA9IHZlYzIoeCAvIDIuMCwgeSAvIDIuMCk7ICAvLyAoMCwgMCksICgyLCAwKSwgKDAsIDIpIC0+IGludGVycG9sYXRpb24gd2lsbCB5aWVsZCAoMCwgMCksICgxLCAwKSwgKDAsIDEpIGFzIHRoZSBwb3NpdGlvbnMgYXJlIGRvdWJsZSB0aGUgc2l6ZSBvZiB0aGUgc2NyZWVuXHJcblxyXG4gIC8vICNpZmRlZiBTQU1QTEVcclxuXHJcbiAgLy8gICB2ZWMyIG9mZnNldCA9IHZlYzIoMS4wIC8gdV92Y3RSZXNvbHV0aW9uLngsIDEuMCAvIHVfdmN0UmVzb2x1dGlvbi55KTtcclxuICAvLyAgIHZfdmN0T2Zmc2V0cyA9IHZlYzJbXShcclxuICAvLyAgICAgdmVjMigtb2Zmc2V0LngsIG9mZnNldC55KSwgIHZlYzIoMC4wLCBvZmZzZXQueSksICB2ZWMyKG9mZnNldC54LCBvZmZzZXQueSksXHJcbiAgLy8gICAgIHZlYzIoLW9mZnNldC54LCAwLjApLCAgICAgICB2ZWMyKDAuMCwgMC4wKSwgICAgICAgdmVjMihvZmZzZXQueCwgMC4wKSxcclxuICAvLyAgICAgdmVjMigtb2Zmc2V0LngsIC1vZmZzZXQueSksIHZlYzIoMC4wLCAtb2Zmc2V0LnkpLCAgdmVjMihvZmZzZXQueCwgLW9mZnNldC55KVxyXG4gIC8vICAgKTtcclxuXHJcbiAgLy8gI2VuZGlmXHJcbn1gO1xuICBzaGFkZXJTb3VyY2VzW1wiU2hhZGVyVW5pdmVyc2FsLmZyYWdcIl0gPSAvKmdsc2wqLyBgI3ZlcnNpb24gMzAwIGVzXHJcbi8qKlxyXG4qIFVuaXZlcnNhbCBTaGFkZXIgYXMgYmFzZSBmb3IgbWFueSBvdGhlcnMuIENvbnRyb2xsZWQgYnkgY29tcGlsZXIgZGlyZWN0aXZlc1xyXG4qIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXHJcbiovXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5wcmVjaXNpb24gaGlnaHAgaW50O1xyXG5cclxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBOb2RlIHtcclxuICB1bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9Xb3JsZDsgLy8gdV9tdHhNb2RlbFxyXG4gIHVuaWZvcm0gbWF0MyB1X210eFBpdm90OyAvLyB0ZXh0dXJlIHBpdm90IG1hdHJpeFxyXG4gIHVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yUHJpbWFyeTsgLy8gY29tcG9uZW50IG1hdGVyaWFsIGNvbG9yXHJcblxyXG4gIHVuaWZvcm0gaW50IHVfaUJsZW5kTW9kZTtcclxuICB1bmlmb3JtIGZsb2F0IHVfZlBhcnRpY2xlU3lzdGVtRHVyYXRpb247XHJcbiAgdW5pZm9ybSBmbG9hdCB1X2ZQYXJ0aWNsZVN5c3RlbVNpemU7XHJcbiAgdW5pZm9ybSBmbG9hdCB1X2ZQYXJ0aWNsZVN5c3RlbVRpbWU7XHJcblxyXG4gIHVuaWZvcm0gYm9vbCB1X2JGYWNlQ2FtZXJhQWN0aXZlO1xyXG4gIHVuaWZvcm0gYm9vbCB1X2JGYWNlQ2FtZXJhUmVzdHJpY3Q7XHJcbn07XHJcblxyXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENhbWVyYSB7XHJcbiAgbWF0NCB1X210eFdvcmxkVG9DYW1lcmE7IC8vIHVfbXR4Vmlld1xyXG4gIG1hdDQgdV9tdHhQcm9qZWN0aW9uOyBcclxuICBtYXQ0IHVfbXR4V29ybGRUb1ZpZXc7IC8vIHVfbXR4Vmlld1Byb2plY3Rpb25cclxuICB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG59O1xyXG5cclxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBNYXRlcmlhbCB7XHJcbiAgdW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XHJcblxyXG4gIHVuaWZvcm0gZmxvYXQgdV9mRGlmZnVzZTtcclxuICB1bmlmb3JtIGZsb2F0IHVfZlNwZWN1bGFyO1xyXG4gIHVuaWZvcm0gZmxvYXQgdV9mSW50ZW5zaXR5O1xyXG4gIHVuaWZvcm0gZmxvYXQgdV9mTWV0YWxsaWM7XHJcblxyXG4gIHVuaWZvcm0gZmxvYXQgdV9mQWxwaGFDbGlwO1xyXG59O1xyXG5cclxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBGb2cge1xyXG4gIGJvb2wgdV9iRm9nQWN0aXZlO1xyXG4gIGZsb2F0IHVfZkZvZ05lYXI7XHJcbiAgZmxvYXQgdV9mRm9nRmFyO1xyXG4gIGZsb2F0IGZvZ1BhZGRpbmc7IC8vIGFkZCBwYWRkaW5nIHRvIGFsaWduIHRvIDE2IGJ5dGVzXHJcbiAgdmVjNCB1X3ZjdEZvZ0NvbG9yO1xyXG59O1xyXG5cclxuaW4gdmVjMyB2X3ZjdFBvc2l0aW9uO1xyXG5pbiB2ZWM0IHZfdmN0Q29sb3I7XHJcblxyXG5sYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgdmVjNCB2Y3RGcmFnO1xyXG5sYXlvdXQobG9jYXRpb24gPSAxKSBvdXQgdmVjNCB2Y3RGcmFnUG9zaXRpb247IC8vIFRPRE86IG1ha2UgdGhlc2Ugb3B0aW9uYWw/XHJcbmxheW91dChsb2NhdGlvbiA9IDIpIG91dCB2ZWM0IHZjdEZyYWdOb3JtYWw7XHJcblxyXG4jaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKEdPVVJBVUQpIHx8IGRlZmluZWQoUEhPTkcpXHJcblxyXG4gIGluIHZlYzMgdl92Y3ROb3JtYWw7XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZiBkZWZpbmVkKEZMQVQpXHJcblxyXG4gIGZsYXQgaW4gdmVjMyB2X3ZjdFBvc2l0aW9uRmxhdDtcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmIGRlZmluZWQoR09VUkFVRClcclxuXHJcbiAgaW4gdmVjMyB2X3ZjdERpZmZ1c2U7XHJcbiAgaW4gdmVjMyB2X3ZjdFNwZWN1bGFyO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWYgZGVmaW5lZChUT09OKVxyXG5cclxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleFRvb247XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZiBkZWZpbmVkKFBIT05HKSB8fCBkZWZpbmVkKEZMQVQpXHJcblxyXG4gIHN0cnVjdCBMaWdodCB7XHJcbiAgICB2ZWM0IHZjdENvbG9yO1xyXG4gICAgbWF0NCBtdHhTaGFwZTtcclxuICAgIG1hdDQgbXR4U2hhcGVJbnZlcnNlO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHVpbnQgTUFYX0xJR0hUU19ESVJFQ1RJT05BTCA9IDE1dTtcclxuICBjb25zdCB1aW50IE1BWF9MSUdIVFNfUE9JTlQgPSAxMDB1O1xyXG4gIGNvbnN0IHVpbnQgTUFYX0xJR0hUU19TUE9UID0gMTAwdTtcclxuXHJcbiAgbGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBMaWdodHMge1xyXG4gICAgdWludCB1X25MaWdodHNEaXJlY3Rpb25hbDtcclxuICAgIHVpbnQgdV9uTGlnaHRzUG9pbnQ7XHJcbiAgICB1aW50IHVfbkxpZ2h0c1Nwb3Q7XHJcbiAgICB1aW50IGxpZ3Roc1BhZGRpbmc7IC8vIEFkZCBwYWRkaW5nIHRvIGFsaWduIHRvIDE2IGJ5dGVzXHJcbiAgICBMaWdodCB1X2FtYmllbnQ7XHJcbiAgICBMaWdodCB1X2RpcmVjdGlvbmFsW01BWF9MSUdIVFNfRElSRUNUSU9OQUxdO1xyXG4gICAgTGlnaHQgdV9wb2ludFtNQVhfTElHSFRTX1BPSU5UXTtcclxuICAgIExpZ2h0IHVfc3BvdFtNQVhfTElHSFRTX1NQT1RdO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIF92Y3RMaWdodDogZGlyZWN0aW9uIGZyb20gcG9zaXRpb24gdG8gbGlnaHRcclxuICAgKiBfdmN0VmlldzogZGlyZWN0aW9uIGZyb20gcG9zaXRpb24gdG8gY2FtZXJhXHJcbiAgICogX3ZjdE5vcm1hbDogc3VyZmFjZSBub3JtYWwgYXQgcG9zaXRpb25cclxuICAgKiBfdmN0Q29sb3I6IGNvbG9yIG9mIHRoZSBsaWdodFxyXG4gICAqL1xyXG4gIHZvaWQgaWxsdW1pbmF0ZURpcmVjdGVkKHZlYzMgX3ZjdExpZ2h0RGlyZWN0aW9uLCB2ZWMzIF92Y3RWaWV3RGlyZWN0aW9uLCB2ZWMzIF92Y3ROb3JtYWwsIHZlYzMgX3ZjdENvbG9yLCBpbm91dCB2ZWMzIF92Y3REaWZmdXNlLCBpbm91dCB2ZWMzIF92Y3RTcGVjdWxhcikge1xyXG4gICAgdmVjMyB2Y3RMaWdodERpcmVjdGlvbiA9IG5vcm1hbGl6ZShfdmN0TGlnaHREaXJlY3Rpb24pO1xyXG5cclxuICAgIGZsb2F0IGZEaWZmdXNlID0gZG90KF92Y3ROb3JtYWwsIHZjdExpZ2h0RGlyZWN0aW9uKTtcclxuXHJcbiAgICBpZihmRGlmZnVzZSA+IDAuMCkge1xyXG5cclxuICAgICAgI2lmIGRlZmluZWQoVE9PTilcclxuICAgICAgXHJcbiAgICAgICAgZkRpZmZ1c2UgPSB0ZXh0dXJlKHVfdGV4VG9vbiwgdmVjMihmRGlmZnVzZSwgMCkpLnI7XHJcblxyXG4gICAgICAjZW5kaWZcclxuXHJcbiAgICAgIF92Y3REaWZmdXNlICs9IHVfZkRpZmZ1c2UgKiBmRGlmZnVzZSAqIF92Y3RDb2xvcjtcclxuXHJcbiAgICAgIGlmKHVfZlNwZWN1bGFyIDw9IDAuMCB8fCB1X2ZJbnRlbnNpdHkgPD0gMC4wKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgXHJcbiAgICAgIC8vQkxJTk4tUGhvbmcgU2hhZGluZ1xyXG4gICAgICB2ZWMzIGhhbGZ3YXlEaXIgPSBub3JtYWxpemUodmN0TGlnaHREaXJlY3Rpb24gKyBfdmN0Vmlld0RpcmVjdGlvbik7XHJcbiAgICAgIGZsb2F0IGZhY3RvciA9IGZEaWZmdXNlOyAgICAgICAgICAgICAgICAgIC8vIEZhY3RvciBmb3Igc21vb3RoaW5nIG91dCB0cmFuc2l0aW9uIGZyb20gc3VyZmFjZSBmYWNpbmcgdGhlIGxpZ2h0c291cmNlIHRvIHN1cmZhY2UgZmFjaW5nIGF3YXkgZnJvbSB0aGUgbGlnaHRzb3VyY2VcclxuICAgICAgZmFjdG9yID0gMS4wIC0gKHBvdyhmYWN0b3IgLSAxLjAsIDguMCkpOyAgLy8gVGhlIGZhY3RvciBpcyBhbHRlcmVkIGluIG9yZGVyIHRvIGNsZWFybHkgc2VlIHRoZSBzcGVjdWxhciBoaWdobGlnaHQgZXZlbiBhdCBzdGVlcCBhbmdsZXMsIHdoaWxlIHN0aWxsIHByZXZlbnRpbmcgYXJ0aWZhY3RzXHJcblxyXG4gICAgICBmbG9hdCBmU3BlY3VsYXIgPSBwb3cobWF4KGRvdChfdmN0Tm9ybWFsLCBoYWxmd2F5RGlyKSwgMC4wKSwgZXhwMih1X2ZTcGVjdWxhciAqIDUuMCkpICogZmFjdG9yOyAvLyBUT0RPOiByZW1vdmUgbWFnaWMgbnVtYmVycz9cclxuXHJcbiAgICAgICNpZiBkZWZpbmVkKFRPT04pXHJcbiAgICAgICAgXHJcbiAgICAgICAgZlNwZWN1bGFyID0gdGV4dHVyZSh1X3RleFRvb24sIHZlYzIoZlNwZWN1bGFyLCAwLjApKS5nICogZkRpZmZ1c2U7XHJcblxyXG4gICAgICAjZW5kaWZcclxuXHJcbiAgICAgIF92Y3RTcGVjdWxhciArPSBmU3BlY3VsYXIgKiB1X2ZJbnRlbnNpdHkgKiBfdmN0Q29sb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuI2VuZGlmXHJcblxyXG4jaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuXHJcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhDb2xvcjtcclxuICBpbiB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmIGRlZmluZWQoTk9STUFMTUFQKVxyXG5cclxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleE5vcm1hbDtcclxuICBpbiB2ZWMzIHZfdmN0VGFuZ2VudDtcclxuICBpbiB2ZWMzIHZfdmN0Qml0YW5nZW50O1xyXG5cclxuI2VuZGlmXHJcblxyXG5mbG9hdCBnZXRGb2codmVjMyBfdmN0UG9zaXRpb24pIHtcclxuICBmbG9hdCBmRGlzdGFuY2UgPSBsZW5ndGgoX3ZjdFBvc2l0aW9uIC0gdV92Y3RDYW1lcmEpOyAvLyBtYXliZSB1c2Ugei1kZXB0aCBpbnN0ZWFkIG9mIGV1Y2xpZGVhbiBkZXB0aFxyXG4gIGZsb2F0IGZGb2cgPSBjbGFtcCgoZkRpc3RhbmNlIC0gdV9mRm9nTmVhcikgLyAodV9mRm9nRmFyIC0gdV9mRm9nTmVhciksIDAuMCwgMS4wKTtcclxuICBmRm9nID0gLXBvdyhmRm9nLCAyLjApICsgKDIuMCAqIGZGb2cpOyAvLyBsZXRzIGZvZyBhcHBlYXIgcXVpY2tlciBhbmQgZmFsbCBvZmYgc2xvd2VyIHJlc3VsdHMgaW4gYSBtb3JlIGdyYWR1YWwgZmFsbG9mZlxyXG4gIHJldHVybiBmRm9nICogdV92Y3RGb2dDb2xvci5hO1xyXG59XHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG4gICNpZiBkZWZpbmVkKEZMQVQpXHJcblxyXG4gICAgdmVjMyB2Y3RGZHggPSBkRmR4KHZfdmN0UG9zaXRpb24pO1xyXG4gICAgdmVjMyB2Y3RGZHkgPSBkRmR5KHZfdmN0UG9zaXRpb24pO1xyXG4gICAgdmVjMyB2Y3ROb3JtYWwgPSBub3JtYWxpemUoY3Jvc3ModmN0RmR4LCB2Y3RGZHkpKTtcclxuICAgIHZlYzMgdmN0Vmlld0RpcmVjdGlvbiA9IG5vcm1hbGl6ZSh1X3ZjdENhbWVyYSAtIHZfdmN0UG9zaXRpb25GbGF0KTtcclxuICAgIHZlYzMgdmN0UG9zaXRpb24gPSB2X3ZjdFBvc2l0aW9uRmxhdDtcclxuXHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiAoZGVmaW5lZChQSE9ORykgfHwgZGVmaW5lZChHT1VSQVVEKSkgJiYgIWRlZmluZWQoTk9STUFMTUFQKVxyXG5cclxuICAgIHZlYzMgdmN0Tm9ybWFsID0gbm9ybWFsaXplKHZfdmN0Tm9ybWFsKTtcclxuXHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKFBIT05HKVxyXG5cclxuICAgIHZlYzMgdmN0Vmlld0RpcmVjdGlvbiA9IG5vcm1hbGl6ZSh1X3ZjdENhbWVyYSAtIHZfdmN0UG9zaXRpb24pO1xyXG4gICAgdmVjMyB2Y3RQb3NpdGlvbiA9IHZfdmN0UG9zaXRpb247XHJcblxyXG4gICNlbmRpZlxyXG5cclxuICAjaWYgZGVmaW5lZChOT1JNQUxNQVApXHJcblxyXG4gICAgbWF0MyBtdHhUQk4gPSBtYXQzKG5vcm1hbGl6ZSh2X3ZjdFRhbmdlbnQpLCBub3JtYWxpemUodl92Y3RCaXRhbmdlbnQpLCBub3JtYWxpemUodl92Y3ROb3JtYWwpKTtcclxuICAgIHZlYzMgdmN0Tm9ybWFsID0gdGV4dHVyZSh1X3RleE5vcm1hbCwgdl92Y3RUZXh0dXJlKS54eXogKiAyLjAgLSAxLjA7XHJcbiAgICB2Y3ROb3JtYWwgPSBub3JtYWxpemUobXR4VEJOICogdmN0Tm9ybWFsKTtcclxuXHJcbiAgI2VuZGlmXHJcbiAgXHJcbiAgI2lmIGRlZmluZWQoRkxBVCkgfHwgZGVmaW5lZChQSE9ORylcclxuXHJcbiAgICB2ZWMzIHZjdERpZmZ1c2UgPSB1X2ZEaWZmdXNlICogdV9hbWJpZW50LnZjdENvbG9yLnJnYjtcclxuICAgIHZlYzMgdmN0U3BlY3VsYXIgPSB2ZWMzKDAsIDAsIDApO1xyXG5cclxuICAgIC8vIGRpcmVjdGlvbmFsIGxpZ2h0c1xyXG4gICAgZm9yKHVpbnQgaSA9IDB1OyBpIDwgdV9uTGlnaHRzRGlyZWN0aW9uYWw7IGkrKykge1xyXG4gICAgICB2ZWMzIHZjdExpZ2h0RGlyZWN0aW9uID0gdmVjMyh1X2RpcmVjdGlvbmFsW2ldLm10eFNoYXBlICogdmVjNCgwLjAsIDAuMCwgLTEuMCwgMS4wKSk7XHJcbiAgICAgIGlsbHVtaW5hdGVEaXJlY3RlZCh2Y3RMaWdodERpcmVjdGlvbiwgdmN0Vmlld0RpcmVjdGlvbiwgdmN0Tm9ybWFsLCB1X2RpcmVjdGlvbmFsW2ldLnZjdENvbG9yLnJnYiwgdmN0RGlmZnVzZSwgdmN0U3BlY3VsYXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHBvaW50IGxpZ2h0c1xyXG4gICAgZm9yKHVpbnQgaSA9IDB1OyBpIDwgdV9uTGlnaHRzUG9pbnQ7IGkrKykge1xyXG4gICAgICB2ZWMzIHZjdExpZ2h0UG9zaXRpb24gPSB2ZWMzKHVfcG9pbnRbaV0ubXR4U2hhcGUgKiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCkpO1xyXG4gICAgICB2ZWMzIHZjdExpZ2h0RGlyZWN0aW9uID0gdmN0TGlnaHRQb3NpdGlvbiAtIHZjdFBvc2l0aW9uO1xyXG4gICAgICBmbG9hdCBmSW50ZW5zaXR5ID0gMS4wIC0gbGVuZ3RoKG1hdDModV9wb2ludFtpXS5tdHhTaGFwZUludmVyc2UpICogdmN0TGlnaHREaXJlY3Rpb24pO1xyXG4gICAgICBpZihmSW50ZW5zaXR5IDwgMC4wKVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgaWxsdW1pbmF0ZURpcmVjdGVkKHZjdExpZ2h0RGlyZWN0aW9uLCB2Y3RWaWV3RGlyZWN0aW9uLCB2Y3ROb3JtYWwsIHVfcG9pbnRbaV0udmN0Q29sb3IucmdiICogZkludGVuc2l0eSwgdmN0RGlmZnVzZSwgdmN0U3BlY3VsYXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNwb3QgbGlnaHRzXHJcbiAgICBmb3IodWludCBpID0gMHU7IGkgPCB1X25MaWdodHNTcG90OyBpKyspIHtcclxuICAgICAgdmVjMyB2Y3RMaWdodFBvc2l0aW9uID0gdmVjMyh1X3Nwb3RbaV0ubXR4U2hhcGUgKiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCkpO1xyXG4gICAgICB2ZWMzIHZjdExpZ2h0RGlyZWN0aW9uID0gdmN0TGlnaHRQb3NpdGlvbiAtIHZjdFBvc2l0aW9uO1xyXG4gICAgICB2ZWMzIHZjdExpZ2h0RGlyZWN0aW9uSW52ZXJ0ZWQgPSBtYXQzKHVfc3BvdFtpXS5tdHhTaGFwZUludmVyc2UpICogLXZjdExpZ2h0RGlyZWN0aW9uO1xyXG4gICAgICBpZih2Y3RMaWdodERpcmVjdGlvbkludmVydGVkLnogPD0gMC4wKVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgZmxvYXQgZkludGVuc2l0eSA9IDEuMCAtIG1pbigxLjAsIDIuMCAqIGxlbmd0aCh2Y3RMaWdodERpcmVjdGlvbkludmVydGVkLnh5KSAvIHZjdExpZ2h0RGlyZWN0aW9uSW52ZXJ0ZWQueik7ICAgIC8vIENvbmVzaGFwZSB0aGF0IGlzIGJyaWdodGVzdCBpbiB0aGUgY2VudGVyLiBQb3NzaWJsZSBUT0RPOiBcIlZhcmlhYmxlIFNwb3RsaWdodHNvZnRuZXNzXCJcclxuICAgICAgZkludGVuc2l0eSAqPSAxLjAgLSBwb3codmN0TGlnaHREaXJlY3Rpb25JbnZlcnRlZC56LCAyLjApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnRzIGhhcnNoIGxpZ2h0aW5nIGFydGlmYWN0cyBhdCBib3VuZGFyeSBvZiB0aGUgZ2l2ZW4gc3BvdGxpZ2h0XHJcbiAgICAgIGlmKGZJbnRlbnNpdHkgPCAwLjApXHJcbiAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICBpbGx1bWluYXRlRGlyZWN0ZWQodmN0TGlnaHREaXJlY3Rpb24sIHZjdFZpZXdEaXJlY3Rpb24sIHZjdE5vcm1hbCwgdV9zcG90W2ldLnZjdENvbG9yLnJnYiAqIGZJbnRlbnNpdHksIHZjdERpZmZ1c2UsIHZjdFNwZWN1bGFyKTtcclxuICAgIH1cclxuXHJcbiAgI2VuZGlmXHJcblxyXG4gIHZlYzQgdmN0Q29sb3IgPSB1X3ZjdENvbG9yICogdV92Y3RDb2xvclByaW1hcnkgKiB2X3ZjdENvbG9yO1xyXG5cclxuICAjaWYgZGVmaW5lZChHT1VSQVVEKVxyXG5cclxuICAgIHZlYzMgdmN0RGlmZnVzZSA9IHZfdmN0RGlmZnVzZTtcclxuICAgIHZlYzMgdmN0U3BlY3VsYXIgPSB2X3ZjdFNwZWN1bGFyO1xyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoRkxBVCkgfHwgZGVmaW5lZChHT1VSQVVEKSB8fCBkZWZpbmVkKFBIT05HKVxyXG5cclxuICAgIHZjdEZyYWcucmdiID0gdmN0RGlmZnVzZSArIHZjdFNwZWN1bGFyICogdV9mTWV0YWxsaWM7XHJcbiAgICB2Y3RGcmFnLmEgPSAxLjA7XHJcblxyXG4gICNlbHNlXHJcblxyXG4gICAgLy8gTUlOSU1BTDogc2V0IHRoZSBiYXNlIGNvbG9yXHJcbiAgICB2Y3RGcmFnID0gdmN0Q29sb3I7XHJcblxyXG4gICNlbmRpZlxyXG5cclxuICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE1BVENBUClcclxuICAgIFxyXG4gICAgLy8gVEVYVFVSRTogbXVsdGlwbHkgd2l0aCB0ZXhlbCBjb2xvclxyXG4gICAgdmVjNCB2Y3RDb2xvclRleHR1cmUgPSB0ZXh0dXJlKHVfdGV4Q29sb3IsIHZfdmN0VGV4dHVyZSk7IC8vIGhhcyBwcmVtdWx0aXBsaWVkIGFscGhhIGJ5IHdlYmdsIGZvciBjb3JyZWN0IGZpbHRlcmluZ1xyXG4gICAgaWYgKHZjdENvbG9yVGV4dHVyZS5hID4gMC4wKSAvLyB1bnByZW11bHRpcGx5IGFscGhhXHJcbiAgICAgIHZjdENvbG9yVGV4dHVyZS5yZ2IgLz0gdmN0Q29sb3JUZXh0dXJlLmE7IFxyXG4gICAgdmN0RnJhZyAqPSB2Y3RDb2xvclRleHR1cmU7XHJcblxyXG4gICNlbmRpZlxyXG5cclxuICAjaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKEdPVVJBVUQpIHx8IGRlZmluZWQoUEhPTkcpXHJcblxyXG4gICAgdmN0RnJhZyAqPSB2Y3RDb2xvcjtcclxuICAgIHZjdEZyYWcucmdiICs9IHZjdFNwZWN1bGFyICogKDEuMCAtIHVfZk1ldGFsbGljKTtcclxuXHJcbiAgICB2Y3RGcmFnUG9zaXRpb24gPSB2ZWM0KHZfdmN0UG9zaXRpb24sIDEuMCk7XHJcbiAgICB2Y3RGcmFnTm9ybWFsID0gdmVjNCh2Y3ROb3JtYWwsIDEuMCk7XHJcbiAgXHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiAhZGVmaW5lZChQSE9ORykgJiYgIWRlZmluZWQoRkxBVCkgJiYgIWRlZmluZWQoR09VUkFVRCkgLy8gTUlOSU1BTFxyXG5cclxuICAgIHZjdEZyYWdQb3NpdGlvbiA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTsgLy8gKDAsIDAsIDApIHdpbGwgdHJlYXQgb2NjbHVkZXJzIGFzIG5vbiBleGlzdGluZyBpbiBzc2FvXHJcbiAgICB2Y3RGcmFnTm9ybWFsID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApOyAvLyAoMCwgMCwgMCkgbm9ybWFsIHdpbGwgeWllbGQgbm90IG9jY2x1c2lvbiBpbiBzc2FvXHJcbiAgXHJcbiAgI2VuZGlmXHJcblxyXG4gIC8vIGRpc2NhcmQgcGl4ZWwgYWxsdG9nZXRoZXIgd2hlbiB0cmFuc3BhcmVudDogZG9uJ3Qgc2hvdyBpbiBaLUJ1ZmZlclxyXG4gIGlmKHZjdEZyYWcuYSA8IHVfZkFscGhhQ2xpcClcclxuICAgIGRpc2NhcmQ7XHJcblxyXG4gIGlmICh1X2JGb2dBY3RpdmUpIHtcclxuICAgIGZsb2F0IGZGb2cgPSBnZXRGb2codl92Y3RQb3NpdGlvbik7XHJcbiAgICB2Y3RGcmFnLnJnYiA9IG1peCh2Y3RGcmFnLnJnYiwgdV92Y3RGb2dDb2xvci5yZ2IsIGZGb2cpO1xyXG5cclxuICAgICNpZiBkZWZpbmVkKFBBUlRJQ0xFKVxyXG5cclxuICAgICAgaWYgKHVfaUJsZW5kTW9kZSA9PSAyIHx8IHVfaUJsZW5kTW9kZSA9PSAzIHx8IHVfaUJsZW5kTW9kZSA9PSA0KSAgLy8gZm9yIGJsZW5kIGFkZGl0aXZlLCBzdWJ0cmFjdGl2ZSwgbW9kdWxhdGVcclxuICAgICAgICB2Y3RGcmFnLmEgPSBtaXgodmN0RnJhZy5hLCAwLjAsIGZGb2cpOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFkZSBvdXQgcGFydGljbGUgd2hlbiBpbiBmb2cgdG8gbWFrZSBpdCBkaXNhcHBlYXIgY29tcGxldGVseVxyXG5cclxuICAgICNlbmRpZlxyXG4gIH1cclxufWA7XG4gIHNoYWRlclNvdXJjZXNbXCJTaGFkZXJVbml2ZXJzYWwudmVydFwiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogVW5pdmVyc2FsIFNoYWRlciBhcyBiYXNlIGZvciBtYW55IG90aGVycy4gQ29udHJvbGxlZCBieSBjb21waWxlciBkaXJlY3RpdmVzXHJcbiogQGF1dGhvcnMgMjAyMSwgTHVpcyBLZWNrLCBIRlUsIDIwMjEgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMSB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xyXG4qL1xyXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxucHJlY2lzaW9uIGhpZ2hwIGludDtcclxuXHJcbmxheW91dChzdGQxNDApIHVuaWZvcm0gTm9kZSB7XHJcbiAgdW5pZm9ybSBtYXQ0IHVfbXR4TWVzaFRvV29ybGQ7IC8vIHVfbXR4TW9kZWxcclxuICB1bmlmb3JtIG1hdDMgdV9tdHhQaXZvdDsgLy8gdGV4dHVyZSBwaXZvdCBtYXRyaXhcclxuICB1bmlmb3JtIHZlYzQgdV92Y3RDb2xvclByaW1hcnk7IC8vIGNvbXBvbmVudCBtYXRlcmlhbCBjb2xvclxyXG5cclxuICB1bmlmb3JtIGludCB1X2lCbGVuZE1vZGU7XHJcbiAgdW5pZm9ybSBmbG9hdCB1X2ZQYXJ0aWNsZVN5c3RlbUR1cmF0aW9uO1xyXG4gIHVuaWZvcm0gZmxvYXQgdV9mUGFydGljbGVTeXN0ZW1TaXplO1xyXG4gIHVuaWZvcm0gZmxvYXQgdV9mUGFydGljbGVTeXN0ZW1UaW1lO1xyXG5cclxuICB1bmlmb3JtIGJvb2wgdV9iRmFjZUNhbWVyYUFjdGl2ZTtcclxuICB1bmlmb3JtIGJvb2wgdV9iRmFjZUNhbWVyYVJlc3RyaWN0O1xyXG59O1xyXG5cclxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDYW1lcmEge1xyXG4gIG1hdDQgdV9tdHhXb3JsZFRvQ2FtZXJhOyAvLyB1X210eFZpZXdcclxuICBtYXQ0IHVfbXR4UHJvamVjdGlvbjsgXHJcbiAgbWF0NCB1X210eFdvcmxkVG9WaWV3OyAvLyB1X210eFZpZXdQcm9qZWN0aW9uXHJcbiAgdmVjMyB1X3ZjdENhbWVyYTtcclxufTtcclxuXHJcbmxheW91dChzdGQxNDApIHVuaWZvcm0gTWF0ZXJpYWwge1xyXG4gIHVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yO1xyXG5cclxuICB1bmlmb3JtIGZsb2F0IHVfZkRpZmZ1c2U7XHJcbiAgdW5pZm9ybSBmbG9hdCB1X2ZTcGVjdWxhcjtcclxuICB1bmlmb3JtIGZsb2F0IHVfZkludGVuc2l0eTtcclxuICB1bmlmb3JtIGZsb2F0IHVfZk1ldGFsbGljO1xyXG5cclxuICB1bmlmb3JtIGZsb2F0IHVfZkFscGhhQ2xpcDtcclxufTtcclxuXHJcbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzMgYV92Y3RQb3NpdGlvbjtcclxubGF5b3V0KGxvY2F0aW9uID0gMykgaW4gdmVjNCBhX3ZjdENvbG9yOyAvLyBUT0RPOiB0aGluayBhYm91dCBtYWtpbmcgdmVydGV4IGNvbG9yIG9wdGlvbmFsXHJcblxyXG5vdXQgdmVjMyB2X3ZjdFBvc2l0aW9uO1xyXG5vdXQgdmVjNCB2X3ZjdENvbG9yO1xyXG5cclxuI2lmIGRlZmluZWQoRkxBVCkgfHwgZGVmaW5lZChHT1VSQVVEKSB8fCBkZWZpbmVkKFBIT05HKVxyXG5cclxuICBsYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWMzIGFfdmN0Tm9ybWFsO1xyXG4gIG91dCB2ZWMzIHZfdmN0Tm9ybWFsO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWYgZGVmaW5lZChGTEFUKVxyXG5cclxuICBmbGF0IG91dCB2ZWMzIHZfdmN0UG9zaXRpb25GbGF0O1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWYgZGVmaW5lZChHT1VSQVVEKVxyXG5cclxuICBvdXQgdmVjMyB2X3ZjdERpZmZ1c2U7XHJcbiAgb3V0IHZlYzMgdl92Y3RTcGVjdWxhcjtcclxuXHJcbiAgc3RydWN0IExpZ2h0IHtcclxuICAgIHZlYzQgdmN0Q29sb3I7XHJcbiAgICBtYXQ0IG10eFNoYXBlO1xyXG4gICAgbWF0NCBtdHhTaGFwZUludmVyc2U7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgdWludCBNQVhfTElHSFRTX0RJUkVDVElPTkFMID0gMTV1O1xyXG4gIGNvbnN0IHVpbnQgTUFYX0xJR0hUU19QT0lOVCA9IDEwMHU7XHJcbiAgY29uc3QgdWludCBNQVhfTElHSFRTX1NQT1QgPSAxMDB1O1xyXG5cclxuICBsYXlvdXQoc3RkMTQwKSB1bmlmb3JtIExpZ2h0cyB7XHJcbiAgICB1aW50IHVfbkxpZ2h0c0RpcmVjdGlvbmFsO1xyXG4gICAgdWludCB1X25MaWdodHNQb2ludDtcclxuICAgIHVpbnQgdV9uTGlnaHRzU3BvdDtcclxuICAgIHVpbnQgbGlndGhzUGFkZGluZzsgLy8gQWRkIHBhZGRpbmcgdG8gYWxpZ24gdG8gMTYgYnl0ZXNcclxuICAgIExpZ2h0IHVfYW1iaWVudDtcclxuICAgIExpZ2h0IHVfZGlyZWN0aW9uYWxbTUFYX0xJR0hUU19ESVJFQ1RJT05BTF07XHJcbiAgICBMaWdodCB1X3BvaW50W01BWF9MSUdIVFNfUE9JTlRdO1xyXG4gICAgTGlnaHQgdV9zcG90W01BWF9MSUdIVFNfU1BPVF07XHJcbiAgfTtcclxuXHJcbiAgdm9pZCBpbGx1bWluYXRlRGlyZWN0ZWQodmVjMyBfdmN0RGlyZWN0aW9uLCB2ZWMzIF92Y3RWaWV3LCB2ZWMzIF92Y3ROb3JtYWwsIHZlYzMgX3ZjdENvbG9yLCBpbm91dCB2ZWMzIF92Y3REaWZmdXNlLCBpbm91dCB2ZWMzIF92Y3RTcGVjdWxhcikge1xyXG4gICAgdmVjMyB2Y3REaXJlY3Rpb24gPSBub3JtYWxpemUoX3ZjdERpcmVjdGlvbik7XHJcbiAgICBmbG9hdCBmSWxsdW1pbmF0aW9uID0gLWRvdChfdmN0Tm9ybWFsLCB2Y3REaXJlY3Rpb24pO1xyXG4gICAgaWYoZklsbHVtaW5hdGlvbiA+IDAuMCkge1xyXG4gICAgICBfdmN0RGlmZnVzZSArPSB1X2ZEaWZmdXNlICogZklsbHVtaW5hdGlvbiAqIF92Y3RDb2xvcjtcclxuXHJcbiAgICAgIGlmKHVfZlNwZWN1bGFyIDw9IDAuMClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAvL0JMSU5OXHJcbiAgICAgIHZlYzMgaGFsZndheURpciA9IG5vcm1hbGl6ZSgtdmN0RGlyZWN0aW9uIC0gX3ZjdFZpZXcpO1xyXG4gICAgICBmbG9hdCBmYWN0b3IgPSBtYXgoZG90KC12Y3REaXJlY3Rpb24sIF92Y3ROb3JtYWwpLCAwLjApOyAvL0ZhY3RvciBmb3Igc21vb3RoaW5nIG91dCB0cmFuc2l0aW9uIGZyb20gc3VyZmFjZSBmYWNpbmcgdGhlIGxpZ2h0c291cmNlIHRvIHN1cmZhY2UgZmFjaW5nIGF3YXkgZnJvbSB0aGUgbGlnaHRzb3VyY2VcclxuICAgICAgZmFjdG9yID0gMS4wIC0gKHBvdyhmYWN0b3IgLSAxLjAsIDguMCkpOyAgICAgICAgICAgICAgICAgLy9UaGUgZmFjdG9yIGlzIGFsdGVyZWQgaW4gb3JkZXIgdG8gY2xlYXJseSBzZWUgdGhlIHNwZWN1bGFyIGhpZ2hsaWdodCBldmVuIGF0IHN0ZWVwIGFuZ2xlcywgd2hpbGUgc3RpbGwgcHJldmVudGluZyBhcnRpZmFjdHNcclxuXHJcbiAgICAgIF92Y3RTcGVjdWxhciArPSBwb3cobWF4KGRvdChfdmN0Tm9ybWFsLCBoYWxmd2F5RGlyKSwgMC4wKSwgZXhwMih1X2ZTcGVjdWxhciAqIDUuMCkpICogdV9mU3BlY3VsYXIgKiB1X2ZJbnRlbnNpdHkgKiBmYWN0b3IgKiBfdmN0Q29sb3I7XHJcblxyXG4gICAgICAvL1BIT05HIChvbGQpXHJcbiAgICAgIC8vIHZlYzMgdmN0UmVmbGVjdGlvbiA9IG5vcm1hbGl6ZShyZWZsZWN0KC12Y3REaXJlY3Rpb24sIF92Y3ROb3JtYWwpKTtcclxuICAgICAgLy8gZmxvYXQgZkhpdENhbWVyYSA9IGRvdCh2Y3RSZWZsZWN0aW9uLCBfdmN0Vmlldyk7XHJcbiAgICAgIC8vIF92Y3RTcGVjdWxhciArPSBwb3cobWF4KGZIaXRDYW1lcmEsIDAuMCksIHVfZlNwZWN1bGFyICogMTAuMCkgKiB1X2ZTcGVjdWxhciAqIF92Y3RDb2xvcjsgLy8gMTAuMCA9IG1hZ2ljIG51bWJlciwgbG9va3MgZ29vZC4uLiBcclxuICAgIH1cclxuICB9XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTk9STUFMTUFQKVxyXG5cclxuICBsYXlvdXQobG9jYXRpb24gPSAyKSBpbiB2ZWMyIGFfdmN0VGV4dHVyZTtcclxuICBvdXQgdmVjMiB2X3ZjdFRleHR1cmU7XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZiBkZWZpbmVkKE5PUk1BTE1BUClcclxuXHJcbiAgbGF5b3V0KGxvY2F0aW9uID0gNCkgaW4gdmVjNCBhX3ZjdFRhbmdlbnQ7XHJcbiAgb3V0IHZlYzMgdl92Y3RUYW5nZW50O1xyXG4gIG91dCB2ZWMzIHZfdmN0Qml0YW5nZW50O1xyXG5cclxuI2VuZGlmXHJcblxyXG4vLyBNQVRDQVA6IG9mZmVyIGJ1ZmZlcnMgZm9yIFVWcyBhbmQgcGl2b3QgbWF0cml4XHJcbiNpZiBkZWZpbmVkKE1BVENBUCkgLy8gTWF0Q2FwLXNoYWRlciBnZW5lcmF0ZXMgdGV4dHVyZSBjb29yZGluYXRlcyBmcm9tIHN1cmZhY2Ugbm9ybWFsc1xyXG5cclxuICBsYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWMzIGFfdmN0Tm9ybWFsO1xyXG4gIG91dCB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmIGRlZmluZWQoU0tJTilcclxuXHJcbiAgLy8gQm9uZXMgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iL2Rldi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5pbmdfcGFyc192ZXJ0ZXguZ2xzbC5qc1xyXG4gIGxheW91dChsb2NhdGlvbiA9IDUpIGluIHV2ZWM0IGFfdmN0Qm9uZXM7XHJcbiAgbGF5b3V0KGxvY2F0aW9uID0gNikgaW4gdmVjNCBhX3ZjdFdlaWdodHM7XHJcblxyXG4gIGNvbnN0IHVpbnQgTUFYX0JPTkVTID0gMjU2dTsgLy8gQ0FVVElPTjogdGhpcyBudW1iZXIgbXVzdCBiZSB0aGUgc2FtZSBhcyBpbiBSZW5kZXJJbmplY3RvclNrZWxldG9uSW5zdGFuY2Ugd2hlcmUgdGhlIGNvcnJlc3BvbmRpbmcgYnVmZmVycyBhcmUgY3JlYXRlZFxyXG4gIGxheW91dChzdGQxNDApIHVuaWZvcm0gU2tpbiB7XHJcbiAgICBtYXQ0IHVfbXR4Qm9uZXNbTUFYX0JPTkVTXTtcclxuICB9O1xyXG5cclxuI2VuZGlmXHJcblxyXG5cclxuXHJcbiNpZiBkZWZpbmVkKFBBUlRJQ0xFKVxyXG5cclxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X3BhcnRpY2xlU3lzdGVtUmFuZG9tTnVtYmVycztcclxuXHJcbiAgZmxvYXQgZmV0Y2hSYW5kb21OdW1iZXIoaW50IF9pT2Zmc2V0LCBpbnQgX2lQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNTaXplLCBpbnQgX2lQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNMZW5ndGgpIHtcclxuICAgIF9pT2Zmc2V0ID0gZ2xfSW5zdGFuY2VJRCArIF9pT2Zmc2V0ICUgX2lQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNMZW5ndGg7XHJcbiAgICByZXR1cm4gdGV4ZWxGZXRjaCh1X3BhcnRpY2xlU3lzdGVtUmFuZG9tTnVtYmVycywgaXZlYzIoX2lPZmZzZXQgJSBfaVBhcnRpY2xlU3lzdGVtUmFuZG9tTnVtYmVyc1NpemUsIF9pT2Zmc2V0IC8gX2lQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNTaXplKSwgMCkucjtcclxuICB9XHJcblxyXG4jZW5kaWZcclxuXHJcbm1hdDQgbG9va0F0Q2FtZXJhKG1hdDQgX210eFdvcmxkLCBib29sIF9iUmVzdHJpY3QpIHtcclxuICB2ZWMzIHZjdFVwID0gdmVjMygwLjAsIDEuMCwgMC4wKTtcclxuXHJcbiAgdmVjMyB2Y3RQb3NpdGlvbiA9IF9tdHhXb3JsZFszXS54eXo7XHJcblxyXG4gIC8vIHZlYzMgekF4aXMgPSBub3JtYWxpemUodV92Y3RDYW1lcmEgLSB2Y3RQb3NpdGlvbik7IC8vIGxvb2sgYXQgY2FtZXJhIHBvc2l0aW9uXHJcbiAgdmVjMyB6QXhpcyA9IG5vcm1hbGl6ZSgtdmVjMyh1X210eFdvcmxkVG9DYW1lcmFbMF0ueiwgdV9tdHhXb3JsZFRvQ2FtZXJhWzFdLnosIHVfbXR4V29ybGRUb0NhbWVyYVsyXS56KSk7IC8vIGxvb2sgaW4gY2FtZXJhIGRpcmVjdGlvblxyXG5cclxuICB2ZWMzIHhBeGlzID0gbm9ybWFsaXplKGNyb3NzKHZjdFVwLCB6QXhpcykpO1xyXG4gIHZlYzMgeUF4aXMgPSBfYlJlc3RyaWN0ID8gdmN0VXAgOiBub3JtYWxpemUoY3Jvc3MoekF4aXMsIHhBeGlzKSk7XHJcbiAgekF4aXMgPSBfYlJlc3RyaWN0ID8gbm9ybWFsaXplKGNyb3NzKHhBeGlzLCB2Y3RVcCkpIDogekF4aXM7XHJcblxyXG4gIHZlYzMgdmN0U2NhbGUgPSB2ZWMzKGxlbmd0aChfbXR4V29ybGRbMF0ueHl6KSwgbGVuZ3RoKF9tdHhXb3JsZFsxXS54eXopLCBsZW5ndGgoX210eFdvcmxkWzJdLnh5eikpO1xyXG5cclxuICBtYXQ0IGJpbGxib2FyZE1hdHJpeCA9IG1hdDQoXHJcbiAgICB2ZWM0KHhBeGlzICogdmN0U2NhbGUueCwgMC4wKSxcclxuICAgIHZlYzQoeUF4aXMgKiB2Y3RTY2FsZS55LCAwLjApLFxyXG4gICAgdmVjNCh6QXhpcyAqIHZjdFNjYWxlLnosIDAuMCksXHJcbiAgICB2ZWM0KHZjdFBvc2l0aW9uLCAxLjApXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIGJpbGxib2FyZE1hdHJpeDtcclxufVxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuICB2ZWM0IHZjdFBvc2l0aW9uID0gdmVjNChhX3ZjdFBvc2l0aW9uLCAxLjApO1xyXG4gIG1hdDQgbXR4TWVzaFRvV29ybGQgPSB1X210eE1lc2hUb1dvcmxkO1xyXG5cclxuICAvLyBpZiAodV9iQmlsbGJvYXJkQWN0aXZlKSBcclxuICAvLyAgIG10eE1lc2hUb1dvcmxkID0gbG9va0F0Q2FtZXJhKG10eE1lc2hUb1dvcmxkLCB1X2JCaWxsYm9hcmRSZXN0cmljdCk7XHJcblxyXG4gICNpZiBkZWZpbmVkKFBBUlRJQ0xFKVxyXG4gIFxyXG4gICAgZmxvYXQgZlBhcnRpY2xlSWQgPSBmbG9hdChnbF9JbnN0YW5jZUlEKTtcclxuICAgIGludCBpUGFydGljbGVTeXN0ZW1SYW5kb21OdW1iZXJzU2l6ZSA9IHRleHR1cmVTaXplKHVfcGFydGljbGVTeXN0ZW1SYW5kb21OdW1iZXJzLCAwKS54OyAvLyB0aGUgZGltZW5zaW9uIG9mIHRoZSBxdWFkcmF0aWMgdGV4dHVyZVxyXG4gICAgaW50IGlQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNMZW5ndGggPSBpUGFydGljbGVTeXN0ZW1SYW5kb21OdW1iZXJzU2l6ZSAqIGlQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNTaXplOyAvLyB0aGUgdG90YWwgbnVtYmVyIG9mIHRleGVscyBpbiB0aGUgdGV4dHVyZVxyXG4gICAgLyokdmFyaWFibGVzKi9cclxuICAgIC8qJG10eExvY2FsKi9cclxuICAgIC8qJG10eFdvcmxkKi9cclxuICAgIG10eE1lc2hUb1dvcmxkID0gLyokbXR4V29ybGQqLyBtdHhNZXNoVG9Xb3JsZCAvKiRtdHhMb2NhbCovO1xyXG4gICAgaWYodV9iRmFjZUNhbWVyYUFjdGl2ZSkgXHJcbiAgICAgIG10eE1lc2hUb1dvcmxkID0gbG9va0F0Q2FtZXJhKG10eE1lc2hUb1dvcmxkLCB1X2JGYWNlQ2FtZXJhUmVzdHJpY3QpO1xyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoU0tJTilcclxuXHJcbiAgICBtdHhNZXNoVG9Xb3JsZCA9IGFfdmN0V2VpZ2h0cy54ICogdV9tdHhCb25lc1thX3ZjdEJvbmVzLnhdICtcclxuICAgICAgYV92Y3RXZWlnaHRzLnkgKiB1X210eEJvbmVzW2FfdmN0Qm9uZXMueV0gK1xyXG4gICAgICBhX3ZjdFdlaWdodHMueiAqIHVfbXR4Qm9uZXNbYV92Y3RCb25lcy56XSArXHJcbiAgICAgIGFfdmN0V2VpZ2h0cy53ICogdV9tdHhCb25lc1thX3ZjdEJvbmVzLnddO1xyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgbWF0NCBtdHhNZXNoVG9WaWV3ID0gdV9tdHhXb3JsZFRvVmlldyAqIG10eE1lc2hUb1dvcmxkO1xyXG5cclxuICAjaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKEdPVVJBVUQpIHx8IGRlZmluZWQoUEhPTkcpIHx8IGRlZmluZWQoTUFUQ0FQKSAvLyBvbmx5IHRoZXNlIHdvcmsgd2l0aCBwYXJ0aWNsZSBhbmQgc2tpbm5pbmdcclxuXHJcbiAgICBtYXQ0IG10eE5vcm1hbE1lc2hUb1dvcmxkID0gdHJhbnNwb3NlKGludmVyc2UobXR4TWVzaFRvV29ybGQpKTtcclxuXHJcbiAgI2VuZGlmXHJcblxyXG4gIGdsX1Bvc2l0aW9uID0gbXR4TWVzaFRvVmlldyAqIHZjdFBvc2l0aW9uOyBcclxuICB2Y3RQb3NpdGlvbiA9IG10eE1lc2hUb1dvcmxkICogdmN0UG9zaXRpb247XHJcblxyXG4gIHZfdmN0Q29sb3IgPSBhX3ZjdENvbG9yO1xyXG4gIHZfdmN0UG9zaXRpb24gPSB2Y3RQb3NpdGlvbi54eXo7XHJcblxyXG4gICNpZiBkZWZpbmVkKFBBUlRJQ0xFX0NPTE9SKVxyXG5cclxuICAgIHZfdmN0Q29sb3IgKj0gLyokY29sb3IqLztcclxuXHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKEZMQVQpXHJcblxyXG4gICAgdl92Y3RQb3NpdGlvbkZsYXQgPSB2X3ZjdFBvc2l0aW9uO1xyXG4gICAgXHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKEZMQVQpIHx8IGRlZmluZWQoR09VUkFVRCkgfHwgZGVmaW5lZChQSE9ORylcclxuXHJcbiAgICB2X3ZjdE5vcm1hbCA9IG1hdDMobXR4Tm9ybWFsTWVzaFRvV29ybGQpICogYV92Y3ROb3JtYWw7IC8vIHVubm9ybWFsaXplZCBhcyBpdCBtdXN0IGJlIG5vcm1hbGl6ZWQgaW4gdGhlIGZyYWdtZW50IHNoYWRlciBhbnl3YXlcclxuXHJcbiAgI2VuZGlmIFxyXG5cclxuICAjaWYgZGVmaW5lZChOT1JNQUxNQVApXHJcblxyXG4gICAgdl92Y3RUYW5nZW50ID0gbWF0MyhtdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiBhX3ZjdFRhbmdlbnQueHl6O1xyXG4gICAgdl92Y3RCaXRhbmdlbnQgPSBjcm9zcyh2X3ZjdE5vcm1hbCwgdl92Y3RUYW5nZW50KSAqIGFfdmN0VGFuZ2VudC53O1xyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoR09VUkFVRClcclxuICBcclxuICAgIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZSh2Y3RQb3NpdGlvbi54eXogLSB1X3ZjdENhbWVyYSk7XHJcbiAgICB2ZWMzIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZSh2X3ZjdE5vcm1hbCk7XHJcbiAgICB2X3ZjdERpZmZ1c2UgPSB1X2ZEaWZmdXNlICogdV9hbWJpZW50LnZjdENvbG9yLnJnYjtcclxuICAgIHZfdmN0U3BlY3VsYXIgPSB2ZWMzKDAsIDAsIDApO1xyXG5cclxuICAgIC8vIGNhbGN1bGF0ZSBkaXJlY3Rpb25hbCBsaWdodCBlZmZlY3RcclxuICAgIGZvcih1aW50IGkgPSAwdTsgaSA8IHVfbkxpZ2h0c0RpcmVjdGlvbmFsOyBpICsrKSB7XHJcbiAgICAgIHZlYzMgdmN0RGlyZWN0aW9uID0gdmVjMyh1X2RpcmVjdGlvbmFsW2ldLm10eFNoYXBlICogdmVjNCgwLjAsIDAuMCwgMS4wLCAxLjApKTtcclxuICAgICAgaWxsdW1pbmF0ZURpcmVjdGVkKHZjdERpcmVjdGlvbiwgdmN0VmlldywgdmN0Tm9ybWFsLCB1X2RpcmVjdGlvbmFsW2ldLnZjdENvbG9yLnJnYiwgdl92Y3REaWZmdXNlLCB2X3ZjdFNwZWN1bGFyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgcG9pbnQgbGlnaHQgZWZmZWN0XHJcbiAgICBmb3IodWludCBpID0gMHU7aSA8IHVfbkxpZ2h0c1BvaW50O2kgKyspIHtcclxuICAgICAgdmVjMyB2Y3RQb3NpdGlvbkxpZ2h0ID0gdmVjMyh1X3BvaW50W2ldLm10eFNoYXBlICogdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApKTtcclxuICAgICAgdmVjMyB2Y3REaXJlY3Rpb24gPSB2Y3RQb3NpdGlvbi54eXogLSB2Y3RQb3NpdGlvbkxpZ2h0O1xyXG4gICAgICBmbG9hdCBmSW50ZW5zaXR5ID0gMS4wIC0gbGVuZ3RoKG1hdDModV9wb2ludFtpXS5tdHhTaGFwZUludmVyc2UpICogdmN0RGlyZWN0aW9uKTtcclxuICAgICAgaWYoZkludGVuc2l0eSA8IDAuMCkgY29udGludWU7XHJcblxyXG4gICAgICBpbGx1bWluYXRlRGlyZWN0ZWQodmN0RGlyZWN0aW9uLCB2Y3RWaWV3LCB2Y3ROb3JtYWwsIHVfcG9pbnRbaV0udmN0Q29sb3IucmdiICogZkludGVuc2l0eSwgdl92Y3REaWZmdXNlLCB2X3ZjdFNwZWN1bGFyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgc3BvdCBsaWdodCBlZmZlY3RcclxuICAgIGZvcih1aW50IGkgPSAwdTtpIDwgdV9uTGlnaHRzU3BvdDtpICsrKSB7XHJcbiAgICAgIHZlYzMgdmN0UG9zaXRpb25MaWdodCA9IHZlYzModV9zcG90W2ldLm10eFNoYXBlICogdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApKTtcclxuICAgICAgdmVjMyB2Y3REaXJlY3Rpb24gPSB2Y3RQb3NpdGlvbi54eXogLSB2Y3RQb3NpdGlvbkxpZ2h0O1xyXG4gICAgICB2ZWMzIHZjdERpcmVjdGlvbkludmVydGVkID0gbWF0Myh1X3Nwb3RbaV0ubXR4U2hhcGVJbnZlcnNlKSAqIHZjdERpcmVjdGlvbjtcclxuICAgICAgaWYodmN0RGlyZWN0aW9uSW52ZXJ0ZWQueiA8PSAwLjApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgZmxvYXQgZkludGVuc2l0eSA9IDEuMCAtIG1pbigxLjAsIDIuMCAqIGxlbmd0aCh2Y3REaXJlY3Rpb25JbnZlcnRlZC54eSkgLyB2Y3REaXJlY3Rpb25JbnZlcnRlZC56KTsgICAgLy9Db25lc2hhcGUgdGhhdCBpcyBicmlnaHRlc3QgaW4gdGhlIGNlbnRlci4gUG9zc2libGUgVE9ETzogXCJWYXJpYWJsZSBTcG90bGlnaHRzb2Z0bmVzc1wiXHJcbiAgICAgIGZJbnRlbnNpdHkgKj0gMS4wIC0gcG93KHZjdERpcmVjdGlvbkludmVydGVkLnosIDIuMCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vUHJldmVudHMgaGFyc2ggbGlnaHRpbmcgYXJ0aWZhY3RzIGF0IGJvdW5kYXJ5IG9mIHRoZSBnaXZlbiBzcG90bGlnaHRcclxuICAgICAgaWYoZkludGVuc2l0eSA8IDAuMCkgY29udGludWU7XHJcblxyXG4gICAgICBpbGx1bWluYXRlRGlyZWN0ZWQodmN0RGlyZWN0aW9uLCB2Y3RWaWV3LCB2Y3ROb3JtYWwsIHVfc3BvdFtpXS52Y3RDb2xvci5yZ2IgKiBmSW50ZW5zaXR5LCB2X3ZjdERpZmZ1c2UsIHZfdmN0U3BlY3VsYXIpO1xyXG4gICAgfVxyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgICAvLyBURVhUVVJFOiB0cmFuc2Zvcm0gVVZzXHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSkgfHwgZGVmaW5lZChOT1JNQUxNQVApXHJcblxyXG4gICAgdl92Y3RUZXh0dXJlID0gdmVjMih1X210eFBpdm90ICogdmVjMyhhX3ZjdFRleHR1cmUsIDEuMCkpLnh5O1xyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoTUFUQ0FQKVxyXG5cclxuICAgIHZlYzQgdmN0VmVydGV4SW5DYW1lcmEgPSBub3JtYWxpemUodV9tdHhXb3JsZFRvQ2FtZXJhICogdmN0UG9zaXRpb24pO1xyXG4gICAgdmN0VmVydGV4SW5DYW1lcmEueHkgKj0gLSAxLjA7XHJcbiAgICBtYXQ0IG10eF9Sb3RYID0gbWF0NCgxLCAwLCAwLCAwLCAwLCB2Y3RWZXJ0ZXhJbkNhbWVyYS56LCB2Y3RWZXJ0ZXhJbkNhbWVyYS55LCAwLCAwLCAtIHZjdFZlcnRleEluQ2FtZXJhLnksIHZjdFZlcnRleEluQ2FtZXJhLnosIDAsIDAsIDAsIDAsIDEpO1xyXG4gICAgbWF0NCBtdHhfUm90WSA9IG1hdDQodmN0VmVydGV4SW5DYW1lcmEueiwgMCwgLSB2Y3RWZXJ0ZXhJbkNhbWVyYS54LCAwLCAwLCAxLCAwLCAwLCB2Y3RWZXJ0ZXhJbkNhbWVyYS54LCAwLCB2Y3RWZXJ0ZXhJbkNhbWVyYS56LCAwLCAwLCAwLCAwLCAxKTtcclxuXHJcbiAgICB2ZWMzIHZjdE5vcm1hbCA9IG1hdDMobXR4Tm9ybWFsTWVzaFRvV29ybGQpICogYV92Y3ROb3JtYWw7XHJcblxyXG4gICAgLy8gYWRkcyBjb3JyZWN0aW9uIGZvciB0aGluZ3MgYmVpbmcgZmFyIGFuZCB0byB0aGUgc2lkZSwgYnV0IGRpc3RvcnRpb24gZm9yIHRoaW5ncyBiZWluZyBjbG9zZVxyXG4gICAgdmN0Tm9ybWFsID0gbWF0MyhtdHhfUm90WCAqIG10eF9Sb3RZKSAqIHZjdE5vcm1hbDtcclxuXHJcbiAgICB2ZWMzIHZjdFJlZmxlY3Rpb24gPSBub3JtYWxpemUobWF0Myh1X210eFdvcmxkVG9DYW1lcmEpICogbm9ybWFsaXplKHZjdE5vcm1hbCkpO1xyXG4gICAgdmN0UmVmbGVjdGlvbi55ID0gLSB2Y3RSZWZsZWN0aW9uLnk7XHJcblxyXG4gICAgdl92Y3RUZXh0dXJlID0gMC41ICogdmN0UmVmbGVjdGlvbi54eSArIDAuNTtcclxuXHJcbiAgI2VuZGlmXHJcbn1gO1xuXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9Db2F0L0NvYXQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBJbnRlcmZhY2UgdG8gYWNjZXNzIGRhdGEgZnJvbSBhIFdlYkdsIHNoYWRlcnByb2dyYW0uIFxyXG4gICAqIFRoaXMgc2hvdWxkIGFsd2F5cyBtaXJyb3IgdGhlIChzdGF0aWMpIGludGVyZmFjZSBvZiB7QGxpbmsgU2hhZGVyfS4gSXQgZXhwb3NlcyB0aGUgc3RhdGljIG1lbWJlcnMgb2YgU2hhZGVyIGluIGFuIGluc3RhbmNlLWJhc2VkIHdheS4gZS5nLjpcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogbGV0IHNoYWRlcjogU2hhZGVySW50ZXJmYWNlO1xyXG4gICAqIGBgYFxyXG4gICAqIGNhbiB0YWtlIHZhbHVlcyBvZiB0eXBlIFxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiB0eXBlb2YgU2hhZGVyIHwgU2hhZGVySW50ZWZhY2VcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIFNoYWRlckludGVyZmFjZSB7XHJcbiAgICBkZWZpbmU6IHN0cmluZ1tdO1xyXG4gICAgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xyXG4gICAgdW5pZm9ybXM6IHsgW25hbWU6IHN0cmluZ106IFdlYkdMVW5pZm9ybUxvY2F0aW9uIH07XHJcbiAgICAvKiogUmV0dXJucyB0aGUgdmVydGV4IHNoYWRlciBzb3VyY2UgY29kZSBmb3IgdGhlIHJlbmRlciBlbmdpbmUgKi9cclxuICAgIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmc7XHJcbiAgICAvKiogUmV0dXJucyB0aGUgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZSBjb2RlIGZvciB0aGUgcmVuZGVyIGVuZ2luZSAqL1xyXG4gICAgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nO1xyXG4gICAgLyoqIEBpbnRlcm5hbCBJbmplY3RlZCBieSBkZWNvcmF0b3IuIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uICovXHJcbiAgICBkZWxldGVQcm9ncmFtKHRoaXM6IFNoYWRlckludGVyZmFjZSk6IHZvaWQ7XHJcbiAgICAvKiogQGludGVybmFsIEluamVjdGVkIGJ5IGRlY29yYXRvci4gVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS4gKi9cclxuICAgIHVzZVByb2dyYW0odGhpczogU2hhZGVySW50ZXJmYWNlKTogdm9pZDtcclxuICAgIC8qKiBAaW50ZXJuYWwgSW5qZWN0ZWQgYnkgZGVjb3JhdG9yLiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLiAqL1xyXG4gICAgY3JlYXRlUHJvZ3JhbSh0aGlzOiBTaGFkZXJJbnRlcmZhY2UpOiB2b2lkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhdGljIHN1cGVyY2xhc3MgZm9yIHRoZSByZXByZXNlbnRhdGlvbiBvZiBXZWJHbCBzaGFkZXJwcm9ncmFtcy4gXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIC8vIFRPRE86IGRlZmluZSB1bmlmb3JtcyBhcyBsYXlvdXQgYW5kIHVzZSB0aG9zZSBjb25zaXN0ZW50bHkgaW4gc2hhZGVyc1xyXG4gIEBSZW5kZXJJbmplY3RvclNoYWRlci5kZWNvcmF0ZVxyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXIge1xyXG4gICAgLyoqIHJlZmVycyBiYWNrIHRvIHRoaXMgY2xhc3MgZnJvbSBhbnkgc3ViY2xhc3MgZS5nLiBpbiBvcmRlciB0byBmaW5kIGNvbXBhdGlibGUgb3RoZXIgcmVzb3VyY2VzKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgYmFzZUNsYXNzOiB0eXBlb2YgU2hhZGVyID0gU2hhZGVyO1xyXG4gICAgLyoqIGxpc3Qgb2YgYWxsIHRoZSBzdWJjbGFzc2VzIGRlcml2ZWQgZnJvbSB0aGlzIGNsYXNzLCBpZiB0aGV5IHJlZ2lzdGVyZWQgcHJvcGVybHkqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBzdWJjbGFzc2VzOiB0eXBlb2YgU2hhZGVyW10gPSBbXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW107XHJcbiAgICAvLyBwdWJsaWMgc3RhdGljIHZlcnRleFNoYWRlclNvdXJjZTogc3RyaW5nO1xyXG4gICAgLy8gcHVibGljIHN0YXRpYyBmcmFnbWVudFNoYWRlclNvdXJjZTogc3RyaW5nO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xyXG4gICAgcHVibGljIHN0YXRpYyB1bmlmb3JtczogeyBbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfTtcclxuXHJcbiAgICAvKiogVGhlIHR5cGUgb2YgY29hdCB0aGF0IGNhbiBiZSB1c2VkIHdpdGggdGhpcyBzaGFkZXIgdG8gY3JlYXRlIGEgbWF0ZXJpYWwgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0Q29sb3JlZDsgfVxyXG4gICAgLyoqIFJldHVybnMgdGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGNvZGUgZm9yIHRoZSByZW5kZXIgZW5naW5lICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJVbml2ZXJzYWwudmVydFwiXSwgdGhpcy5kZWZpbmUpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgdGhlIGZyYWdtZW50IHNoYWRlciBzb3VyY2UgY29kZSBmb3IgdGhlIHJlbmRlciBlbmdpbmUgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0RGVmaW5lcyhzaGFkZXJTb3VyY2VzW1wiU2hhZGVyVW5pdmVyc2FsLmZyYWdcIl0sIHRoaXMuZGVmaW5lKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yU2hhZGVyfS4gVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS4gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZXRlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yU2hhZGVyfS4gVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS4gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgdXNlUHJvZ3JhbSh0aGlzOiB0eXBlb2YgU2hhZGVyKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yU2hhZGVyfS4gVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS4gKi8gLy8gVE9ETzogbWF5YmUgZG9uJ3QgZmxhZyB0aGlzIGFzIGludGVybmFsLCBzbyBzaGFkZXJzIGNhbiBiZSBwcmVjb21waWxlZCBpbiBmdXR1cmUgRlVER0UgYXBwcy4gT3IgY3JlYXRlIGFuIEFQSSB0byBwcmVjb21waWxlIHNoYWRlcnMsIGxvYWQgdGV4dHVyZXMgZXRjLlxyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVQcm9ncmFtKHRoaXM6IHR5cGVvZiBTaGFkZXIpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBkZWNvcmF0b3IgKi8gfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViY2xhc3M6IHR5cGVvZiBTaGFkZXIpOiBudW1iZXIgeyByZXR1cm4gU2hhZGVyLnN1YmNsYXNzZXMucHVzaChfc3ViY2xhc3MpIC0gMTsgfVxyXG5cclxuICAgIC8vIHJlcGxhY2UgdGhlIG1hbmRhdG9yeSBoZWFkZXIgb2YgdGhlIHNoYWRlciB3aXRoIGl0c2VsZiBwbHVzIHRoZSBkZWZpbml0aW9ucyBnaXZlblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBpbnNlcnREZWZpbmVzKF9zaGFkZXI6IHN0cmluZywgX2RlZmluZXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcclxuICAgICAgaWYgKCFfZGVmaW5lcylcclxuICAgICAgICByZXR1cm4gX3NoYWRlcjtcclxuXHJcbiAgICAgIGxldCBjb2RlOiBzdHJpbmcgPSBcIiN2ZXJzaW9uIDMwMCBlc1xcblwiO1xyXG4gICAgICBmb3IgKGxldCBkZWZpbmUgb2YgX2RlZmluZXMpXHJcbiAgICAgICAgY29kZSArPSBgI2RlZmluZSAke2RlZmluZX1cXG5gO1xyXG5cclxuICAgICAgcmV0dXJuIF9zaGFkZXIucmVwbGFjZShcIiN2ZXJzaW9uIDMwMCBlc1wiLCBjb2RlKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyQW1iaWVudE9jY2x1c2lvbiBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJTY3JlZW4udmVydFwiXSwgdGhpcy5kZWZpbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0RGVmaW5lcyhzaGFkZXJTb3VyY2VzW1wiU2hhZGVyQW1iaWVudE9jY2x1c2lvbi5mcmFnXCJdLCB0aGlzLmRlZmluZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckJsb29tIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlclNjcmVlbi52ZXJ0XCJdLCB0aGlzLmRlZmluZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJCbG9vbS5mcmFnXCJdLCB0aGlzLmRlZmluZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckZsYXQgZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckZsYXQpO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJGTEFUXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmU7IH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyRmxhdFNraW4gZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckZsYXRTa2luKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiRkxBVFwiLFxyXG4gICAgICBcIlNLSU5cIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZTsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJGbGF0VGV4dHVyZWQgZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckZsYXRUZXh0dXJlZCk7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xyXG4gICAgICBcIkZMQVRcIixcclxuICAgICAgXCJURVhUVVJFXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmVUZXh0dXJlZDsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJGbGF0VGV4dHVyZWRTa2luIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJGbGF0VGV4dHVyZWRTa2luKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiRkxBVFwiLFxyXG4gICAgICBcIlRFWFRVUkVcIixcclxuICAgICAgXCJTS0lOXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmVUZXh0dXJlZDsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJHaXptbyBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJHaXptby52ZXJ0XCJdLCB0aGlzLmRlZmluZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJHaXptby5mcmFnXCJdLCB0aGlzLmRlZmluZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckdpem1vVGV4dHVyZWQgZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1wiVEVYVFVSRVwiXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJHaXptby52ZXJ0XCJdLCB0aGlzLmRlZmluZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJHaXptby5mcmFnXCJdLCB0aGlzLmRlZmluZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckdvdXJhdWQgZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckdvdXJhdWQpO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJHT1VSQVVEXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmU7IH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyR291cmF1ZFNraW4gZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckdvdXJhdWRTa2luKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiR09VUkFVRFwiLFxyXG4gICAgICBcIlNLSU5cIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZTsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJHb3VyYXVkVGV4dHVyZWQgZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckdvdXJhdWRUZXh0dXJlZCk7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xyXG4gICAgICBcIkdPVVJBVURcIixcclxuICAgICAgXCJURVhUVVJFXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmVUZXh0dXJlZDsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJHb3VyYXVkVGV4dHVyZWRTa2luIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJHb3VyYXVkVGV4dHVyZWRTa2luKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiR09VUkFVRFwiLFxyXG4gICAgICBcIlRFWFRVUkVcIixcclxuICAgICAgXCJTS0lOXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmVUZXh0dXJlZDsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJMaXQgZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckxpdCk7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXTtcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyTGl0U2tpbiBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyTGl0U2tpbik7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiU0tJTlwiXHJcbiAgICBdO1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJMaXRUZXh0dXJlZCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyTGl0VGV4dHVyZWQpO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJURVhUVVJFXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRUZXh0dXJlZDsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJMaXRUZXh0dXJlZFNraW4gZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckxpdFRleHR1cmVkU2tpbik7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xyXG4gICAgICBcIlRFWFRVUkVcIixcclxuICAgICAgXCJTS0lOXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRUZXh0dXJlZDsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJNYXRDYXAgZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlck1hdENhcCk7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xyXG4gICAgICBcIk1BVENBUFwiXHJcbiAgICBdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0VGV4dHVyZWQ7IH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyT3V0bGluZSBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJTY3JlZW4udmVydFwiXSwgdGhpcy5kZWZpbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0RGVmaW5lcyhzaGFkZXJTb3VyY2VzW1wiU2hhZGVyT3V0bGluZS5mcmFnXCJdLCB0aGlzLmRlZmluZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlclBob25nIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJQaG9uZyk7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xyXG4gICAgICBcIlBIT05HXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmU7IH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyUGhvbmdTa2luIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJQaG9uZ1NraW4pO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJQSE9OR1wiLFxyXG4gICAgICBcIlNLSU5cIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZTsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJQaG9uZ1RleHR1cmVkIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJQaG9uZ1RleHR1cmVkKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiUEhPTkdcIixcclxuICAgICAgXCJURVhUVVJFXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmVUZXh0dXJlZDsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJQaG9uZ1RleHR1cmVkTm9ybWFscyBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyUGhvbmdUZXh0dXJlZE5vcm1hbHMpO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJQSE9OR1wiLFxyXG4gICAgICBcIlRFWFRVUkVcIixcclxuICAgICAgXCJOT1JNQUxNQVBcIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZVRleHR1cmVkTm9ybWFsczsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJQaG9uZ1RleHR1cmVkTm9ybWFsc1NraW4gZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlclBob25nVGV4dHVyZWROb3JtYWxzU2tpbik7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xyXG4gICAgICBcIlBIT05HXCIsXHJcbiAgICAgIFwiVEVYVFVSRVwiLFxyXG4gICAgICBcIk5PUk1BTE1BUFwiLFxyXG4gICAgICBcIlNLSU5cIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZVRleHR1cmVkTm9ybWFsczsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJQaG9uZ1RleHR1cmVkU2tpbiBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyUGhvbmdUZXh0dXJlZFNraW4pO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJQSE9OR1wiLFxyXG4gICAgICBcIlRFWFRVUkVcIixcclxuICAgICAgXCJTS0lOXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRSZW1pc3NpdmVUZXh0dXJlZDsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJQaWNrIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJQaWNrLnZlcnRcIl0sIHRoaXMuZGVmaW5lKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlclBpY2suZnJhZ1wiXSwgdGhpcy5kZWZpbmUpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJQaWNrVGV4dHVyZWQgZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1wiVEVYVFVSRVwiXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJQaWNrLnZlcnRcIl0sIHRoaXMuZGVmaW5lKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlclBpY2suZnJhZ1wiXSwgdGhpcy5kZWZpbmUpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJUb29uIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJUb29uKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiUEhPTkdcIixcclxuICAgICAgXCJUT09OXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRUb29uOyB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyVG9vblNraW4gZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlclRvb25Ta2luKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiUEhPTkdcIixcclxuICAgICAgXCJUT09OXCIsXHJcbiAgICAgIFwiU0tJTlwiXHJcbiAgICBdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0VG9vbjsgfVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlclRvb25UZXh0dXJlZCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyVG9vblRleHR1cmVkKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiUEhPTkdcIixcclxuICAgICAgXCJUT09OXCIsXHJcbiAgICAgIFwiVEVYVFVSRVwiXHJcbiAgICBdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0VG9vblRleHR1cmVkOyB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyVG9vblRleHR1cmVkU2tpbiBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyVG9vblRleHR1cmVkU2tpbik7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xyXG4gICAgICBcIlBIT05HXCIsXHJcbiAgICAgIFwiVE9PTlwiLFxyXG4gICAgICBcIlRFWFRVUkVcIixcclxuICAgICAgXCJTS0lOXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRUb29uVGV4dHVyZWQ7IH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgY2xhc3MgVGV4dHVyZURlZmF1bHQgZXh0ZW5kcyBUZXh0dXJlQmFzZTY0IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgY29sb3I6IFRleHR1cmVCYXNlNjQgPSBuZXcgVGV4dHVyZURlZmF1bHQoXCJUZXh0dXJlRGVmYXVsdFwiLCBUZXh0dXJlRGVmYXVsdC5nZXRDb2xvcigpLCBNSVBNQVAuTUVESVVNKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgbm9ybWFsOiBUZXh0dXJlQmFzZTY0ID0gbmV3IFRleHR1cmVEZWZhdWx0KFwiVGV4dHVyZU5vcm1hbERlZmF1bHRcIiwgVGV4dHVyZURlZmF1bHQuZ2V0Tm9ybWFsKCksIE1JUE1BUC5NRURJVU0pO1xyXG4gICAgcHVibGljIHN0YXRpYyB0b29uOiBUZXh0dXJlQmFzZTY0ID0gbmV3IFRleHR1cmVEZWZhdWx0KFwiVGV4dHVyZVRvb25EZWZhdWx0XCIsIFRleHR1cmVEZWZhdWx0LmdldFRvb24oKSwgTUlQTUFQLlNNT09USCwgV1JBUC5DTEFNUCk7XHJcblxyXG4gICAgLy8gVE9ETzogbWF5YmUgbWFrZSB0aGVzZSBsYXp5XHJcbiAgICBwdWJsaWMgc3RhdGljIGljb25MaWdodDogVGV4dHVyZUJhc2U2NCA9IG5ldyBUZXh0dXJlRGVmYXVsdChcIkljb25EZWZhdWx0TGlnaHRcIiwgVGV4dHVyZURlZmF1bHQuZ2V0SWNvbkxpZ2h0KCksIE1JUE1BUC5CTFVSUlksIFdSQVAuQ0xBTVAsIDI1NiwgMjU2KTtcclxuICAgIHB1YmxpYyBzdGF0aWMgaWNvbkNhbWVyYTogVGV4dHVyZUJhc2U2NCA9IG5ldyBUZXh0dXJlRGVmYXVsdChcIkljb25EZWZhdWx0Q2FtZXJhXCIsIFRleHR1cmVEZWZhdWx0LmdldEljb25DYW1lcmEoKSwgTUlQTUFQLkJMVVJSWSwgV1JBUC5DTEFNUCwgMjU2LCAyNTYpO1xyXG4gICAgcHVibGljIHN0YXRpYyBpY29uQXVkaW86IFRleHR1cmVCYXNlNjQgPSBuZXcgVGV4dHVyZURlZmF1bHQoXCJJY29uRGVmYXVsdEF1ZGlvXCIsIFRleHR1cmVEZWZhdWx0LmdldEljb25BdWRpbygpLCBNSVBNQVAuQkxVUlJZLCBXUkFQLkNMQU1QLCAyNTYsIDI1Nik7XHJcbiAgICAvLyBwdWJsaWMgc3RhdGljIGljb25QYXJ0aWNsZXM6IFRleHR1cmVCYXNlNjQgPSBuZXcgVGV4dHVyZURlZmF1bHQoXCJJY29uRGVmYXVsdFBhcnRpY2xlXCIsIFRleHR1cmVEZWZhdWx0LmdldEljb25QYXJ0aWNsZXMoKSwgTUlQTUFQLkJMVVJSWSwgMjU2LCAyNTYpO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldENvbG9yKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBWkFBQUFHUUNBWUFBQUNBdnpiTUFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQURXTFNVUkJWSGhlN2QwSG5GVGx2Zi94SDl1WFpZR2w5eXJTUkpwRVVleFlzSkliYThSZTQ5OFdOY1pFYis0MWVwT0lzV3MwTml5eG0yZzBkdXdhZXdPN29xSkNBR25TdDdILzgzMDRCNGRsZHBrNVozYjN6TzduemV1ODVwd3pNOHZNczdQUGIzNVBPNjFxUEJaanJWcTE4dmZpS2ViRlIvbEZSUGxGUS9sRkUvZnl5L0Z2QVFCSUN3RUVBQkFLQVFRQUVBcDlJQkhSaGhvTjVSY041UmROU3lnLy9ZekN3a0pyM2JxMU8xNjllclhiTW9FQUVoRi93TkZRZnRGUWZ0RTA5L0xMemMyMUxsMjYyRTkrOGhNYlAzNjhWVmRYMit1dnYyN1RwMDkzUVNUcSt5ZUFSTVFmY0RTVVh6U1VYelROdGZ4eWNuS3NwS1RFQmcwYVpFY2VlYVFkZXVpaHRtTEZDdnZzczg5czNyeDU5dmpqajl2RER6OGNPUk9KSEVDcXFxcHM5dXpadG16Wk1sdTVjcVZMbGRxMWEyZDkrL1oxKzFIeEFZeUc4b3VHOG91Rzhvc21UUG5sNStkYjkrN2RiZmZkZDdkVFR6M1YxY1h2dnZ1dXZmenl5eTREa1ZXclZ0bU5OOTVvUzVZc2NjZGhoUTRnNWVYbDl1eXp6OXFNR1ROc3pabzEvdGtmS1FJcSt1Mjk5OTVXV2xycW4wMGZIOEJvS0w5b0tMOW9LTDlvMGlrL1BiWk5temEyeFJaYjJISEhIV2VUSjArMmhRc1gycE5QUG1tTEZ5LzJIN1hPZi83ekg3djExbHRkUFI1RnFBQ3lZTUVDdStlZWUxS0tYbXZYcnJYOTl0dlBSbzhlN1lKS3V2Z0FSa1A1UlJPVW56NjcraUtVbDVkbmxaV1Z0bno1OGxpOGRqNS8wVFNuOGxPVDFiNzc3bXNYWEhDQmRlN2MyVjU3N1RWNzg4MDNrNzdIYjcvOTF1NjQ0dzZycUtqd3o0U1RkZ0JSdHFIVUo0aG9DaENmZlBLSmZmWFZWNjQ5clgzNzlqWmd3QUMzQlpRdVRabzB5YmJiYmp1WFhxV0REMkEwbEY4MFFmbDE3TmpSampubUdPdlVxWk45ODgwMzlzQUREN2d2VWszOSt2bjhSZE9jeXE5cjE2NDJkZXBVMjNycnJlM1JSeDkxWDNKRWRiU2FzSXFMaTIzWXNHSHVYS1lDU05vcGdYcnZnK0NoL28vNzdydlB2Vmk5K0ovLy9PZDI5TkZIMjlDaFE5MExER2o0bU5JbEJabTQvOExRc3N5Y09kTTF4Yjc2NnF0Sm0ySkYyVWZQbmozdDE3Lyt0VTJZTU1GMjNYVlhPL2JZWTExUVFmTTFmLzU4dSttbW0xemZnZnA0NDA3MXNWNnpQc3RCOEZBOXJDLzhUejMxbE9zWHliUzBNcEFmZnZqQnJyNzY2dlVkTVVFZmlGS20vZmZmMzhyS3l0YW4rTXBHVlBqQlkvWEhxZXpqckxQT2NwM3NxZUliVERTVVgvMys4SWMvdU0rcjZFdlFUMy82VXpmc01TZzMzU3FBcUYzNW1XZWVzV3V2dmRhZGw0Y2Vlc2plZSs4OS82aHA4UG1McHI3eTA2aWxLNis4MGxYTTByOS9meHM1Y3FUN2dseFFVT0RPTmJSMHlpLzRvblBFRVVlNFk0MjBldWVkZDl4Z3BxT09Pc3AyM0hGSE53cExtaVFEK2VDRER6Ym94WC83N2JkZHhuSGdnUWRhbno1OXJHM2J0aTdiVUlEbzFxMmI2MEFQRkJVVjJYUFBQUmVMdEI5SVJuOVFMNzMwVXNvZGk3VTdKdEc4cUVONmwxMTI4WS9NdnY3NmEvdm5QLzlwZi83em4rM0JCeCswTDcvOE1sWjFtWnFxNXM2ZDZ6N0grcUtqWml2UisxRGdDeVlTWmxKYUFlU0xMNzd3OTh3Ky8veHo5OElVN2ZUTkxWbWtIREZpeEFZZDUzcTgzbFRVbm4rZ0lTakQxbEQwVkN1RjRNc1VtaS8xSjZoeldwK0pZRlBHcXFaUFZkU1hYbnFweTB3MTJpa085SmxVZHJGMDZkTDFuMk5OSm15b2pDbmxBS0lYODkxMzMvbEg1aUtkMm9QVnJwWVlKQktwT1V1akFRTHFnSHpycmJmcWJHc0dnRGhSM1RadTNMaU42cmlnY3RZWGpsZGVlY1Y5NDcvKyt1dnRqVGZlY0swelRTbDRiWTBoNVFDaWIyZEJXNkJvQ0srRzVxcG52ejdLVGdKcTJ2cjAwMC9KUUFCa0RUWC8xRmNwQi9lcEExdjlEbXJpdXZ2dXUrM2pqejl1OWxscXlnR2s5cHdQUlZrTjFkM1VzRndONncyb2owUkRJSU5PU3dDSU85Vmg2VXlHVmtCUkUvKzk5OTVyRjE5OGNTejdTeklsNVFCU095MVQ3NzBLVnUxcjlVa01NTnBYbEtidEdFQTI2ZDI3ZDUxTjlja29XS2hmV0YrV1AvendROWRmY3RWVlY3bEJHbXJOYVM1U0hzYXI0WW9hZ1JDNC9QTEwzV0pjMjI2N3JldnJxSXRXZm56aWlTZjhJN01ycnJqQ0RTM1RrTGhVMU82Y1YyZVFSbnpGeFdPUFBlYnZ4ZE5lZSszbDc4VlRVNVdmdnN6MDZ0WExUYndLTW1MTmFkS293ajMzM0hQOU9tNHFQMVVjbTIrK3VkMTIyMjF1R0h0QTQrczE4a1dkckUyRnoxODBxWmFmUnB4cUNHelVMQ0tvejNyMDZPRzZBRFE4dkw0MUE5TVp4bHNYRFV2WGNIWDFRUWZEempNMWpEZmxBS0lwOFltRnJYYStGMTU0d1VhTkdsVnZaRmF3ZU9TUlIveWpkWUZISFUzNmcweEY3UUpVbjhvdmZ2RUwvd2dJcDBPSERpNVk2RnRoRUVEVTVEQjgrSEFiUEhqd0JwbXpQb1A2STV3eVpZb2JkUk80NVpaYjNFQ1NWRC9MUUcyYTN2Q3JYLzJxempxMDJRU1Eyb0hnc3NzdWN6TWVOYW1tdmpkWk8vQmNjc2tsYm8wV1JkNVUxUDdaYWpaTG5GL1MxUFJ0TmM0U3M3ODRhcXJ5VTMvY2JydnQ1cjdRQkFGRTY3dHAzUC9Zc1dQWEQzdFUrZW1QV3hPMHpqMzNYSmRCQnpSUmRyUE5OblAzTlJVK2Y5R2tXbjZMRmkxeVEyTXpTYXZrYW9TWHZyVFVwZGtFRU0wNFYyZFFRRE0wbFlFb0VOVDNKaFZrTkkxZTFQZWhBS0kzb1c5NXFjaEVBVGFrRkl1dnlWQis5VXVjaWY3M3YvL2RyWlJ3MEVFSHJSOWRxUEpUUDUrYUcxUVpYblBOTmU2OHFBbHJ6cHc1L2xIVDRQTVhUYXJscCtaNjFWdGh5MXVmSWRWL1dxMWp6Smd4dHVXV1c3b3ZNWnVTaWZKcnlBQ1NjcTlRN1lrb210V29QN3hORldqaWtOMWdPWlBFNWdHZ0tTWDIzNmt2UTBQVkV6L1QrZ1BXOEhObEplbDBvcUo1MFVXWTFOK1ZqcUR5VngrSGdvYVdXRC90dE5OY3MyY3F3U01icFB3WFVYc1ltMmFWYThHdVRSVnE0aUprV3ZwQlAyZFRJN2VBeHBMWWdha0FvaEV5aWFNRTlZMVJGK1pSODFWY1podWpjZWxMaFFKSU90bUFIanR3NEVDM3pKUDZPRFNZb0NtYk9odEt5Z0VrY1Q2SDZQajc3Ny9mWUhKaE1vbnJCV2t1aVVhKzFEZHFDMmhNaVN2cXFqOURRU0x4TTYzbXJELzk2VTh1KzBoc3drWExvVGtkbTJwcENZS0xWdVpRc0ZEUU9PeXd3OXp5NmMzNUMzUEtBVVJ0d29tTGNhbWd0TFJKZlFGRVRWeGE4aVNnOW1JTndhVUpDM0doanN5QVB0TWFxcGs0NSttUGYveWphNFpWQjN2VTYwY2pPMmtxUXJMc0kyalNWTDJvenZDVFRqckpUampoQkxlL3FSVTZHb3RlZHpxWlU3cFNEaUFxck1TNUc1cUZycW42OWExcnBkbVhRUWVsYURWTGRSNXA2Qm9RQjFxbUlwRkd4R2craUJiTDB3U3dwNTkrZW4zd1VJZGpwa2ZpSU43MEpYbjI3Tm5yTTVDZ1FsWXJpaGFMMVdLeVo1OTl0cnRnWHVLeVRVMUJyMHRkQzVyMHFDL3F3YWFtczJSemxkU3ZyZnYwZUhXd2g1RnlBSkVoUTRiNGUrdUdRZW9DVVhVdEhLWUMxeUpqQWYwUzFMNDhmdno0MkVSblFKL2piYmJaeGo5YTkwVkovWGIvK01jLzNGVUhQL3JvSS9kWjFxSjV0OTkrZTFaY1dBaVpvZjVkamI1S3BDL1J1dGI0T2VlYzQyNTEzSkRmOE5PaFRFaVh0TDN6emp2ZG5LWmd1K0dHRzJ5SEhYYlk0SFVHQ1lFV2dOVGp6ei8vZkxmd2JicnZKYTBBb2prZmlmMFhta1NvSWJxMVUzdjl3V21KWXcwVkMyanVoeDZ2U1ZjMFlTRk9KazZjNkVaYUpjdW1WWWtvRzlId1hWM0xSa01pQXl6SjA3eHAzVDcxODJyU3FUNGp2L3psTCszd3d3OTNyU2h4ck1QVXNxTTZWdjNUR3E2clMyZG8vcDRtYm1zVkVWMTZQS0Jnb1N0cnFwVkkxM2xTUDgzSko1K2M5cW9LYVYyUlVQU0NGSldEU0tVbUtuVSticlhWVmk0Q3FxTmNMejV4NlhjZGF3eTlKaDhxNVV2blJjWWx1dGNsemVKcmRKUmZhblQxT2EyZ3FtOXNDZ3o2b3FTTVdYOTB3ZVZCZFU3emw5Uk1vTTkzVTg4QkVUNS8wZFJYZnJwUDlaa0NTRk5KcC94VXJ5b3Iwa1RyNE1xRDZkSThQV1hicVVvN2dJald2bGRrVHVYTmFRU0RMdjI1eHg1N3VGbS9hbTlMcDFDb0FLT2gvRktuSUtMaG1sbzlZZGFzV2E2NVNrdjJKTDVHcGY0cVU1MUxkMTVBUStEekYwMXpLejk5dVRuNDRJUGRhRmYxMmFYei9qUmlWczFkNlFnVlFOVHZvV3dpU08rU1VXZWovaEMxQ0prV1hOVGpOV3M5M1NGdGZBQ2pvZnpTcHlaWlpkWUtFSm9IRW1kOC9xSnBidVdueHlzVFVYTlc3VGxObTZLeVNMYzhRZ1VRMGJleko1OTgwaTBvcHpSUHpWZDY4Zm9XcDBpbUZGL1hSVC9ra0VQY29uVWF0UlZtL2djZndHZ292MmdvdjJnb3YyamlYbjZoQTRqb201cUNoWWJ6NmtxRFN2ODFMMFNUc3pSOFRCMDY2blRVU0pkZ3pIUzYrQUJHUS9sRlEvbEZRL2xGMDZ3RFNFRHB2dHJiRkR6MDQ5Uk1wVkVLV2lZaWFnSHdBWXlHOG91RzhvdUc4b3NtN3VXWGtRRFNrUGdBUmtQNVJVUDVSVVA1UlJQMzhndlhyZ1FBYVBFSUlBQ0FVQWdnQUlCUTFNQVc3MGJBZGE4UklZMGRPemJ1djk5WWUrdnR0LzA5aE5FcTVuME1jUmYzMGlNREFRQ0VRZ0FCQUlSQ0FBRUFoRUlBQVFDRVFnQUJBSVJDQUFFQWhKS1JBS0tyRE9wS1hWdHZ2YlYvQmdEUTNHVWtnT2h5b0FNSERneDlZWFlBUVBhaENRc0FFRXBHQWtqY1Y3UUVBR1FlR1FnQUlCUUNDQUFnRkFJSUFDQ1VqQWFRdUY4OUN3Q1FPV1FnQUlCUUNDQUFnRkF5RWtBWXhnc0FMUThaQ0FBZ0ZBSUlBQ0NVakFZUVJtRUJRTXRCQmdJQUNJVUFBZ0FJaFFBQ0FBZ2xJd0dFWWJ3QTBQS1FnUUFBUWlHQUFBQkN5V2dBWVJndkFMUWNaQ0FBZ0ZBSUlBQ0FVQWdnQUlCUU1oSkFHTVlMQUMwUEdRZ0FJQlFDQ0FBZ2xJd0dFSWJ4QWtETFFRWUNBQWlGQUFJQUNJVUFBZ0FJSlNNQmhHRzhBTkR5a0lFQUFFTEpVZllRZFpzMmJacjdZVWNkZFZUUys2TnNBTkJTYVdScm5MZU1aQ0Q2UVFDQWxvVW1MQUJBS0FRUUFFQW9HUTBnOUZrQVFNdEJCZ0lBQ0lVQUFnQUloUUFDQUFnbEl3R0VZYndBMFBLUWdRQUFRaUdBQUFCQ3lXZ0FZUmd2QUxRY1pDQUFnRkFJSUFDQVVBZ2dBSUJRTWhKQUdNWUxBQzBQR1FnQUlCUUNDQUFnbEl3R0VJYnhBa0RMUVFZQ0FBaUZBQUlBQ0lVQUFnQUlKU01CaEdHOEFORHlrSUVBQUVJaGdBQUFRc2xvQUdFWUx3QzBIR1FnQUlCUUNDQUFnRkF5RWtBWWhRVUFMUThaQ0FBZ0ZBSUlBQ0FVQWdnQUlKU01CaENHOFFKQXkwRUdBZ0FJaFFBQ0FBZ2xJd0dFWWJ3QTBQS1FnUUFBUWlHQUFBQkNJWUFBQUVMSmFBQmhHQzhBdEJ6cS9ZNWM2dzhiTnN3T091Z2crL0RERCszKysrLzN6MmFHRjVSMjluY1J3b2tubnZpY3Y0c1FidmpyRGY0ZXdxaHB4WmZLU0dKZWZEUmhBUUJDeVVnQUNacXVHTTRMQUMwSEdRZ0FJQlFDQ0FBZ0ZBSUlBQ0FVQWdnQUlCUUNDQUFnRkFJSUFDQ1VqQVFRaHZFQ1FNdERCZ0lBQ0lVQUFnQUloUUFDQUFpRkFBSUFDSVVBQWdBSWhRQUNBQWdsSXdHRVlid0EwUEtRZ1FBQVFpR0FBQUJDSVlBQUFFSWhnQUFBUWlHQUFBQkNJWUFBQUVMSlNBQmhHQzhBdER4a0lBQ0FVQWdnQUlCUUNDQUFnRkFJSUFDQVVBZ2dBSUJRTWhKQUdJVUZBQzBQR1FnQUlCUUNDQUFnRkFJSUFDQVVBZ2dBSUJRQ0NBQWdGQUlJQUNDVWpBUVFodkVDUU10REJnSUFDSVVBQWdBSWhRQUNBQWdsUi8wWFViZkhIMy9jL2JBOTk5d3o2ZjFSTmdCb3FkU3ZIT2VOREFRQUVBb0JCQUFRQ2dFRUFCQUtBUVFBRUFvQkJBQVFDZ0VFQUJCS1JnS0lobk1KdzI0Qm9PVWdBd0VBaEVJQUFRQ0VRZ0FCQUlSQ0FBRUFoRUlBQVFDRWtwRUF3aWdzQUdoNXlFQUFBS0VRUUFBQW9SQkFBQUNoRUVBQUFLRVFRQUFBb1JCQUFBQ2haQ1NBTUl3WEFGb2VNaEFBUUNnRUVBQkFLQVFRQUVBb0JCQUFRQ2dFRUFCQUtBUVFBRUFvR1FrZ0RPTUZnSmFIREFRQUVFcEdBa2h1YnE2N3JhNnVkcmNBZ09ZdjVRQ3lZc1VLdStPT08rekdHMiswZSs2NXg1WXZYKzdmVTc4MzNuakRwazJiWmpmZmZMTjkvUEhIL2xrQVFMWkxPWUFveTVnOWU3Yk5uVHZYUHYzMFU3dnd3Z3Z0ODg4L3Q3VnIxL3FQMkpneWttZWZmZGErK2VZYisrNjc3K3lxcTY3eTd3RUFaTHVVQTBoeGNiSDE3OS9mUHpKYnZYcTEzWC8vL1M0ekNRU2Q2WUV2dnZqQ3lzdkwzYjZDeWNNUFArejJBUURaTDYwK2tGR2pSdmw3WnAwNmRiTG5ubnV1M3Fhc21UTm4rbnRtWDM3NXBTMWJ0c3cvQWdCa3U3UUN5T0RCZzlkM21JdjJQL3ZzTTZ1cXF2TFAvRWpubElFRVB2cm9JeHMzYnB4L0JBRElkbWtGa0x5OFBCc3laSWgvdEM2Z1BQUE1NN1pxMVNyL3pJL1VQeEkwWDFWVVZMaGdNbW5TSkhjTUFNaCthUVVRR1RObWpMOW4xcUZEQjN2dHRkZldCNURFUHBBUFAvelEzelBYNlY1UVVHQVRKMDcwendBQXNsM2FBYVJmdjM1V1dGam9INW5ibnpWcmx1c2tWNUNReXNwSzE3UVZVRERaZnZ2dHJVZVBIdjRaQUVDMlN6dUE1T1RrMkpaYmJ1a2ZtV3ZTZXZIRkYxMmZoNXE0Uk1GRFFVUTBTa3ZEZVBmZWUyOHJMUzExNXdBQTJTL3RBQ0pqeDQ3MTk4emF0bTFyTTJiTWNQTkIyclJwNDg0bE5sK3A4N3lzck15MjIyNDdOeFFZQU5BOHFOTWlyUlVRMjdkdmI2ZWNjb29MSEVIZng1dHZ2bW05ZXZXeW5YYmF5WGJmZlhlNzdycnIxby9NdXVHR0cyeisvUG1obHptcHFhbTV3TjlGQ0Y3NS80Ky9peEJPUFBFRWZ3OWgxTlJzT0RjTTZZcjNBclZwWnlCcWtwbytmYm9OSHo3Y1AyTTJkT2hRTjB1OVQ1OCticjVIRUR5Ky8vNTdOM09kTmJJQW9QbEpPNEFvT0doWmtzUWxUTlIwdFdUSkVtdlhycDBiY1JYUVJNTGFzOU1CQU0xRHFENFF6U2gvNnFtbjNHejBRUGZ1M2UyRER6NndyNy8rMmgzcjJpRHFHd0VBTkUraEFvaWFzVFR5YXRDZ1FmNFpzODAzMzl5dHZCczBYNmxKYStuU3BWeGtDZ0NhcVZBQlJNMVhDeFlzc0lVTEY2NXZvbXJkdXJYbDUrZTdmVkUya3Jqc0NRQ2dlUWtWUUNSb3h1clpzNmQvWnQyS3ZhSXNSRU41eVQ0QW9Qa0tIVUEwaEZmTldJbXowZ09hU0tqbDN1dTdWZ2dBSUx1RkRpREtMdFRQY2RGRkY3bkZFb05nb2Y0UjlZVm94bm95ZFowSEFHU1h0Q2NTMXFaK2poRWpScmlBb2lHOGE5YXM4ZTlKVG85UFoxNkk5M09aU0JnQkV3bWpZU0poTkV3a2pLcVpUU1NzVGNGQW82MDBBMzJmZmZieHo5YU5TWVVBMER5a0ZFRFV6NkhPY2kxWDByVnIxL1dMSmdZVUZFcEtTdHhFd29DYXFyVGN1NTZqVlhnMVNnc0EwSHlrRkVCMFlhZzVjK2E0R2VoYTF5cVk2MUVmOVlrc1hyellQVWZMbVNTNzZCUUFJSHZSb3cwQUNDVWpBWVQ1SGdEUThwQ0JBQUJDSVlBQUFFSWhnQUFBUXNsb0FPSGFId0RRY3BDQkFBQkNJWUFBQUVMSlNBQmhHQzhBdER4a0lBQ0FVQWdnQUlCUUNDQUFnRkF5R2tBWXhnc0FMUWNaQ0FBZ0ZBSUlBQ0NVakFRUWh2RUNRTXREQmdJQUNJVUFBZ0FJaFFBQ0FBZ2xvd0dFWWJ3QTBIS1FnUUFBUWlHQUFBQkN5VWdBWVJndkFMUThaQ0FBZ0ZBSUlBQ0FVRExhaE1Vb0xBQm9PY2hBQUFDaDVDaDdpTHE5ODg0NzdvZU5IajA2NmYxUk5nQm9xZFNxRStlTkRBUUFFRXBHQW9naWtaQXhBRURMUVFZQ0FBaUZBQUlBQ0lVQUFnQUloUUFDQUFpRkFBSUFDSVVBQWdBSUpTTUJoR0c4QU5EeWtJRUFBRUloZ0FBQVFpR0FBQUJDSVlBQUFFSWhnQUFBUWlHQUFBQkN5VWdBWVJndkFMUThaQ0FBZ0ZBSUlBQ0FVQWdnQUlCUUNDQUFnRkFJSUFDQVVESVNRQmlGQlFBdER4a0lBQ0FVQWdnQUlCUUNDQUFnbEl6MmdRQUFXZzR5RUFCQUtBUVFBRUFvR1EwZ0RPTUZnSmFEREFRQUVBb0JCQUFRQ2dFRUFCQktSZ0lJdzNnQm9PVWhBd0VBaEVJQUFRQ0VrdEVBd2pCZUFHZzV5RUFBQUtFUVFBQUFvV1FrZ0RBS0N3QmFIdFg4a1RzdU9uYnNhS2VlZXFvdFdyVElycjc2YXY5c1p0VFUxTHpnN3lLRXQ5OStlMGQvRnlHTUhUdlczMXVuOXBlbDJ2MStUWDEvYmJVZlgxdERQeC9ORzAxWUFJQlFDQ0FBV2h4bFRtNWJ1M2I5UHRLWGtRQkM0UU9JTTlWUlZaV1Z0bURlZDNiam44Nnh2WVlVZUZ1KzdUWFV2L1cyc3cvYnlUNTY5MVdycUNpM3RWNWd3YWFSZ1FEMVVCOUE0aFo4V3cyMnByNGZkVk1RV0xKb2diM3k5RU4yMGo0amJkOHRpdTNJSGZ2WlA2WmQ1dDI3Y2RsOStOYkxkdFloMjl2K0kwcnNvSzI3MkQ5dnY4WVd6WjlyMWRWVi9pTlFHd0VFUUxPaG9QSDE1eC9hdlgrOTJBV0JuMi9id3k0NjVRRDc1b3VQL0Vla1p1V3lwWGI5LzUxaFUzYm9ZejhiMjlGdW52b2JtL1h4ZTE0d3FmWWZBY2xvRTVhK0lRRkFZMUkveGdkZTluRG5OUmZaejhhVTJTKzhiT1BXeTg1elFTQVR5bGV2dEFkdXZzUk9tYnlWKy9sL3UvcjM5c0diTC9uM3RteGtJQUN5UnRCMHQzWnR0YzE4ODBXYmR1bDV0dCtJRXZ2VllUdDVGZnYvMmhxdnNtOUk1V3RXZVlIcTkvYXJLVHZidnQ3L2UrYzFGOXBuTTk5eW1VOUxiRkpVeWhENVhaZVZsZG5wcDU5dWl4Y3Z0cXV1dXNvL214bmVMNFY1SUJFd0R5U2F1TThEMlpUYXo2OXRVeit2b1orZkt2MmM2cW9xbS8zRlJ6Yjl3ZHZ0eVFlbTJlcVZ5L3g3bTE1WnAyNjI2K1REYmU5RFQ3RE8zWHRiVGs1dTJyK3JiRVFHQWlDV2dxQXg1K3ZQN2RvTFRyVmpkeDlpcDB3ZWF3L2RkbVdzZ29jc1dUalBIcmpwRWp0NjEwRjIrcysyc1R1dnZjZ1dmei9QMWxaWFp5eUl4aEVCQkVDc3FLUDZoeVVMN2I0YnB0cnBCNHkzNC9ZWWFvL2VmYjB0bUR2YmYwUzhxYlA5enFzdnNDTjI2bWZuSHJXN1BmK3ZlMnpsOGgrYVpTQWhnQUNJaFZVcmx0a0xqOTFuWngyNmcwM1p2cmZyQ0ovMThidit2UTBuSjZlVjVlWGx1dmI4VEZMMk5QT05GMnpxMlllN3pPU0NYMHkyVDk5L3c4clhyUFlma2YxVVpwSERJbjBnOFVVZlNEUmJiYldWdjdkTzdXK1I2ZlpaTlBUOXRkVitmRzFOL1h6TnNWZ3c1eHU3NjlxTDdNMFhIbk9aUjBNb0xDaXdmbjE3MkU0VHhsbEpTWkU3cDVkZVhGeHNuVHVWV1Y1dXJwVlhWTmlzcjc2MUJ4NmFidk1YTEhLUHlUU1ZsL3BJZHZ1dm8yM1BnNDZ4amwxNmJMSU00MHl2dlA3ZmNBcmF0Mjl2WjV4eGhpMVpzc1N1dlBKSy8yeG1lQjlBQWtnRUJKQm9DQ0FOOC96S2luSTM5UGE2QzArM09iTS9kMzBGRGFWM3o2NzIyN09QZDRGaVU2OVgxSVEyNDhQUDdmSnI3N0NWS3hzdVc4Z3ZLTFMrZzRiYktmOTdyVzAyYkxUbDV1WDU5MlFQbXJBQU5DcjFaUnl6MjJENzdkRjcyTGRmZnRLZ3dTTS9QOC9PK2VVeDFxVnpoNVNDaCtSNjJjaW9FWVB0N0ZPUDlNODBEQVhSTHo1OHg4NDRjRnM3WXVmKzl2RjdyL24zWkE4Q0NJQkdOZlBaaDJ6TjkzUDhvNGJWeXZ0WFZWVzF5VXlxTmdXYkZTdFgrVWNOcmNiV0xKcG5qMTc1Ry84NGV4QkFnSHFvNGtuY1ZMRWtibkc3di9aVysvRzF0MlRQU2R5U1BTZHhTL2FjeEMyWlpRdm5XWTgyaGRhM3BNQ0tjMVBMQ3NLcXFLeTBzMzU3cWQxMjF5UDIzc3hQYmVrUHl6ZTVVS0plOThMRlMrM08reDcxenpRY3ZmOStKZm5XeXlzUFZjWjFsVmxjNmJjWCtSWFRCeEpmOUlGRXd3V2xvajAvbVFjdU9jdGV1dit2L3BIWm1xcHFXN2lteWxaVnAvK3p3aWd1S3JSUld3NjJ6cDA2V052U0Vpc295SGZuU2xvWHU4NXpCWnIzUC9qTWYzVERLTWxyWlowSzg2d3dMOWMvWTlacnlHZzc2OVlYTENjbmU3N1hrNEVBYUZSVmxSWCszanBGWGlXcWIrQjl2Vy9pcFY3RjJ0QldyeW0zVjkrWVlROC85cno5N2Q1SDdaWTdIckpyYjd6WHBsNTVxOTEyOXlNTkdqemE1dWRZdnpZRjFyT2tjSVBnSVRWYTlUZEVRRzVLQkJBQWphcTZzdExmMjVBcTFPNWV4ZHJmcTJBN0ZHeFl1V1l6aGNST2hiazJvTFRBdXJVdXNJTGM1Tld1Um4rRnllaWFVa1lEeUtiU1hTRGI2RE9kdU9rUFBIRnI2dnV6VWUwTXBMWjhyNEx0V0pSbkEwc0xyWXQzbTYwVUFyc1ZlKytqYmFHVkZlWlozaWFhcHJKeDJSTXlFQUNOcXJxcS9nQWlDcGE1T2Eyc3ZWZnhidVpWd0QxYjUxdCtsbncvTGZaZWQrL1dlVGJBZTkxdEMvSXN4dy8rbTFLelZzT1pDU0FBVUtkV3JkS3JkbFFCbCtUbldqOHZJMUgvUVp1OEhOY3NGQ2Q2UjJYNU9kYS90TUI2ZTYrek9EOHZwYUN4Z1N4c3dNbElBTW5XVkJwQTQ4dk56L2YzMHFNS1dmMEgzYjFzUkJWMXA0SmNhNFErOTNvVmVEVm85K0k4Ny9VVVd1ZldCWllmWVFSVnVvRTFEckx2RlFPTktMRy9RWnNxc2NTdHFlL2YxRmI3K2JXM1pNOUozSkk5SjNGTDlwekVMWm5jdkhBQkpLQ2ZxLzZFc3FJOGw1WDA5Z0pLNjF6di8vUHZiMmlxTk50NldaQTYrL3UyS2JUU2dqelgzQlpWSys5bjFGVm1jVVVBQWRDb29nYVFnQ3BiTlc4VjUrZGF6NUlDZi9SV1RvUDFsUlI1Rlh4WEwyZ3ArK21xUGhrdkc4cGtoYjh1QXlHQUFFQ2RrZ1dRYmoyNjJlbm5uVzdIbjM2Y2pkbDZ0QlVVRlBqM3BNWmxKVzcwVnI2WEZSUllMNitDYjVNWFBTdFJFMWw3THlpcDc2VzN0N1V0eVBXeWpjd0dqb0FMSU5rVlB6SWJRTEl0L1FMUStKTDFnUnh3K00rOElOTFZCbXcrd05zL3dNNmZlcDV0dit2Mi9yMnBjMW1KVjhHMzlyS1M3cTBMM055TExrVzVWcFRta2ltYThLY2dwTURSMlF0SzZudlJ6MjdJT3E2VkFoTVpDTkI4QkpWR3NHMnFENkN4Nzg5R3lUS1E3ajI3KzN2cnlqemZDektUZnJxbi9mellRLzJ6NmRQUFViYlF2akRmZXZ0TlhKclFwNDd2Wk5wNVFhTmJVWjV0NWsvNFV4QlNNTkxQaWFwenQ4NjI1K1E5WFlDc1N5YituOFpHQUFIUXFKSUZrRVVMTjc2QWt5clVMVVp2WVdQSGI3Z2VXUmd1S0hsWlJBY3ZtK2hYV21RRHZTRFJvempmdW5tYk91RVZOTHA2UWFOdFlWN0cxNkthZk1oa08rTzhNMnpIM1hhd1kwODl4cjJuWkZybDVHWmRFTWxJU1dYck55RUFqUzlaQVBsazVpZiszb1pVb1U3Y2ExZi9LSE9VbWJRcHlIVjlHdXFFYjRnRkRQUHk4dXlZVTQ2Mm4wd1k1LzM4ZFlGQi84OUJSeDdvN3F2TlhWQ3FKUVlRQUVoVnNnRHl6T1BQdXJXZ2ttbFgxczdhbExieGo3SkRVWEdSbmZrL3Y3UkJRd2R0bEZXb2VhNW4zNTcrVWFKMXpaVFpoQUFDMUtOMm40UCt3Qk8zdU4xZmU2djkrTnBic3Vja2JzbWVrN2dsZTA3aWxreE9rZ0JTdnFiYzNuemxyYVRQMGYvVHRuMWIveWc3SEhiOFlWYldvY3cvMnBEZTQvSWZsdnRIMlkwQUFxQlJGUlMxOXZjMjlNOTcvMm16WjgzZUtJam9lRldqWFIwd09tVkxBd2ZWM1ZtK2N2bEtXN3h3c1grVTNUTGFCNkp2Q2dCUW42S1NVbjl2WTMrOS9BYWIvdWgwVzdsaTVmcDZaZmFYMzlqU3hVdmRmallZc3NWZ042czhHVjBOOFpFSC91VWZaVDh5RUFDTnFxaWsvdWFvWng5L3ppNzY5Zi9aZjUvK08vdmRMLy9IL25yWmoxY3ZqRDB2Ym96NnlTai9ZR1BQUGZHOHpYaDdobitVL1FnZ1FEMFMyL3UxNlZ0eDR0YlU5MmVqMGxhcnJYMUJsYmRYLzdYSjFhbGVXWkg4NGxOeGxadVR1OEdjbG9CK1Y3Ty9uTzJ5cTQydHRUS3ZQSWEzTC9lUHN3Y0JCRUNqcWx3NjE2c3NLMjE0dXdvcnpNbSthMkRVcDNwdHRjMzVkcTUvdEM1d3FObnFxVWVldHVzdnJaMUoxVmhwWHJXTjlBTEhNSzg4Y2x0bFh6a1FRQUEwcXZKbDZ5WU50aStzc1RFZEsyeEFTWVhsdW15a0dRUVM3eTFvTU1DeUg1YTV3TEZ3L2tLYmR1MnQ5dnlUei9zUGtCb3I4Z0xuMExibE5xS3N3dHFrdCt4WHJCQkFBRFNxdFFtWHRGVmZjL2VTdGJaVnAzTHIwN3JTV2pXRFFMSm93U0s3NUhlWDJNWC9QZFV1dStoeSsrS1RML3g3YWl5LzFWb2JWRnBob3p0VVdJY2lOVkg2ZC9teXJWa3lKMmhMamJMTm1UUEgvYkFlUFhva3ZUL0tCalNsNERPWStGbFVYMFJ3MjlUM0I3U2Y3RmpQUzN4dTdlTkFRejAvbWJYVkcxL1NOcy83S3R1N1RiVnQxYkhjdWhWVmVZRms0LzhqbTFSVlZkdXlwY3U4QXROUmpaZGgxZGlBTmhVMjFudC9YWXJYV3JLSjd6VmV4dUkvWWIyZ0hPTzZaU1FEMFE4Q21pTjl0bFZoeHZVMkc2MnRxcnRqdkNEWGJHRGJLdThiK2hwcmw2ZU85dXdPSkRuZTYrL3RaVlpqTzY2eGJsN2d5SzJueGwxYldlNEhrZXhCRXhaUWoxUXE4YWE4RFRZZEo1Nkx5M0V5TlFsTldIVXB6ak1iWGxacG84dldXRWx1OW5XMGV5VmdYUXZYQlk3ZUpkV1c3d1ZHcjFqcVZiUFdlNTkxbEZsY0VVQ0FlZ1NWWVZ4dnM5SGE2dFNHNW5wdjBWcm5tNDNzVUdGanZJeEVIYzk1K1huV3FVc242OUNwZy8rb09OSHZvOGJhNTFmWk9DOXdLSk5TUnFYM2tZcWFtdXpLUGlTakFTUmJQOUJBWGVxcnZPTnlHK3pIOFRpWitwcXdrdEdQVVVhaUVWdG4vdW80Ty9OM3Y3U3ovL2NzTy9hMFk5TytjbUhEcWJFMmVkVzJkYWMxYmtodUtobEhiV3ErOGtyUFA4b09aQ0JBUFlKS01hNjMyV2h0MWFhYnNKSnBYZGJCeW5yMmNlOWQyMmFEQjlxdkx6ckhpbG9YK1k5b0NtdmRYSTZ4WG9ZMHNrT2xHd3pndmJSd2FtakNBcHFWVkNyeHByd05OaDBubm92TGNUS3BObUhWVnJscXBadGJrYWgxU1dzNzRvVEQvYVBHRkV3Q3JMQXRPMVJZMGNhWDkwaGJ0bldnQ3dFRXFFZFFHY2IxTmh1bDI0UVZxS29vdHprejN2S1BmdFM1WTZrTmJSZDB0amUwR211YlgyVmJ0bC9qQWtlYmdzejlEbHdBeWJMZktRRUVxRWNxbFhoVDN3YjdjVHhPcGlaa0JpSXpIcm5YbHMzL2Nha1FaU1R2UFhTWGRTaXNjWjN0dzd4QTBycUJBb21HRlk5b1gyNWJ0SyswMGdicGVzbStMd1FwQlpBMWE5Yll5cFVyL2FQd0ZpMWFWT2RWeDRBNENpckZ1TjVtbzV5ODhMV3Z2cVgvZTlyVk52L3pqNnhpeldwNysvNWJiZW0zWDduN3ZDS3hNaStRak5vZ2tFUXRJelZWcmNzNE5LeTRyWmR4NlA5cENMb21lb1A5OEFhU1VnQjU5dGxuN1lvcnJyQlhYbmxsb3piSVZLeGF0Y29lZXVnaHUrYWFhK3lUVDVKZit4aUlvMVFxOGFhOERUWWRKNTZMeTNFeU9mblJPcjJyeXRmWW0zZmRhRTlkL0Z1Yi84bE0vK3lQdlA5K2ZTQlJ4dEJtL1lURVZJUEp1c2UyZFlGRDYxVXA0OUI3VzNkdlE4bkp6WGRsbDAxU0NpQURCdzYwcXFvcW16NTl1Z3NrTDcvOHNxMVlzY0svZDkyM05LbjlnVkhHOGNRVFQ3am52UC8rKys1eC9mdjM5KzhGNGkrb0RPTjZtNDF5Q3hwbjFKUlhSQzVqMk5JTEFDUEx5cTE5ZnJXL1JFcGQ1ZWFWcTdkcEhzY283L0ZiTkZMZ0NMVEtWVTk4ZGdXUVZ0NkhjSk9mUW1VZGwxeHlpV3ZLa3VERDI2bFRKK3ZidDY4VkZSVzU3S1N3c05ER2p4OXZpeGN2dHErKytzcVdMMTl1T1RrNTd2bTYzV3l6emV6UVF3OTFQeU1OTC9pM0NPSHR0OS9lMGQ5RkNHUEhqdDJvMG83YnJXaGY0bnFjNk0yclRyQ3ZucnJaUDJvOGVpbHJxczNtcmM2MTc5ZmtXV1dOWHFNMkxYSllZNTJMcXF4YmNiVVZOVkZMVXJ2K0kyMjNLOTcwTWhIdkJmaUNjb3lybERJUVZmNWJicm1sNWZwdkxQaFFMRnk0ME41OTkxMTc5ZFZYM2JFQ3pJc3Z2bWd6Wjg1MHdVT0NKaS8xZll3Y09kTHRBOWxDZjhENnZNZjFOaHRGYmNJS3l5c3lOeUd4ZjJtMWplbFlic1BhbFZ2WG9rcDNxK04rYmFyZC9YcGNVOGoxeXFWVnNsVVdZeXpsVnp0cTFLaWtIZUFLRUVHUTBJZGErOGsrMk1wT0JnOGU3QjhCMmFHK3lqc090OEdtNDhSemNUbE9wckJ0UjMrdjZXakNuL3BKTm10YjVXNGpUUURNRk8vL1Y5bGxrNVFEU1BmdTNhMWp4L1IvOGZvUUtYTkp6R0NBYkJGVWhuRzl6VVlkTmgvbjd5RlI2ODU5L0wzc2tWYStOSHIwYVBmQlRZY2VUL01Wc2xVcWxYaFQzd2I3Y1R4T3B0dVkzYTNYOWdmNlI5bWhiYmVlMW52MDF0WjNxKzBzdHdIVzMyby9ZTFNOTysxRy95aDdwQlZBbEVYb3c1RU9QYjVkdTNiV3MyZFAvd3lRUFlKS01hNjMyU2duTjgvR24zTzNiWEg0UlY0QnAxVUZOYnFpMG5ZMjd1ZkgyNFRqejdTUit4MWlJL1krd0hiNmY3LzE3ODJNbnR2OXpIYjk4OHVXMzdyVVA1TTkwdnJ0bFphV3VtRzQrdkNtU2gzd1lUSVhJQTVTcWNTYjhqYllkSng0TGk3SGRkRmpoaDM4Rzl2cEQ4OVlibkZtSzg3ODRoSnJsWUhtY21VZE81M3lHK3M2YUppcnh3S0ZyVXN5RnZpR1Q3bkF0djMxM1kwMnREblQwaTRGQllPZzB6d1YraEFwY3dHeVVWQVp4dlUyMjNVWnNZUHRmZE5uMW1YVVJQOU1OTnNjL2d2YjQ1eUxiTkp2cDlyNG8wNnhqZ00yOSs5Smo1cXBmbkxZQ1paWFVPaWYrVkg1cXBWZXhaYitoT3BFdVVVbHR2UEZMOWp3UTg1Zk53TTlTNlVkUUlZT0hacldHdnk5ZXZXeXNySXkvd2pJTHFsVTRrMTlHK3pIOFRnVlJlMjYySTYvZjl6R25QSlgvMHc0SGZvTXNFNSt3RkRHMExIdlFOdG15a2xlRnZGYkt5aEpMOHZwUFhxOEZkYnhuTXJ5MWY1ZU9GMUdUclI5Yi8zR09nK2Y0Si9KWG1rSGtMeThQQnMrZkxqN0JlbURzaW5LV0lCc0ZWU0tjYjF0TGpUL1liTTlqN1A5N3BocmVjVnQvYlBwNlRseTQ5RmRLcWMySFR2YjFsTk9UUG1idmg0M2VPYzkzWE9US1M1dDUrK2xiOXdadDlpT0Z6NXVCVzNhKzJleVc2aUdQTTBKVVROV1hRVWNVSkFaTm15WWZ3UmtuMVFxOGFhOERUWWRKNTZMeTNHNmlzcTYydVM3RjlqUWc4L3pqdExyTjYxdmRGVGJyajFzMkc3NytVZjFLKzNhUFduVDFZL1M3ODh0N1RYRTlyMWpqdldmZUtRTGxzMUZxSGZTcDA4Zk43S3FQdm9RRFJreXhDMXpBbVNyb0RLTTYyMXpsSk9YYjF0TXVjQW0zZmlwRlhWSWZmVG0zSm52K25zYlUzbDE3TDlaU3BWM2FlZnU3dkhKVkphdnNWZHV2dHcvMnJSV3VmbXVvM3lQYTk2M292WmQvYlBOUjZnQW9zTFZ2STY2Q2xuMDRXYnVCN0pkZlpWM1hHNkQvVGdlaDZYbnR1azJ3UGErWlpZTm1IU2lmN1orUzc3NzJ0YldjN21JVkpkTFg3Rm92bnNQaWJTTS9QZGZmVzVQWC9MZnRtTGhBdjlzL1VwN0Q3VkpmLzNFaG5uWlZFNWVYcVR5aUt2UXVaU0NRKzFDVHFUTVE0c25BdGtzcUJUamV0dWM2VDNtZXRuSTJKT3Z0WWxYdkdHdHU5Vy9rbmZscWhYMjluM1Q2aXlYdk1KQ3kwbWhIK1NIT2QvWWR6UGVzdXFxU3ZlemxzejUxcDY1OHZmMit1MS84UUtVbG9hdm43S09RZnVmN21VZDczbEJzSjk3SDgxVlNxdngxdVhHRzIrMHVYTi92RHBZUUV1V2pCczN6dmJZWXcvL1RDU3N4aHNCcS9GR0UvZlZlQU02bHVCY1hJNHpxV1p0dGIxMzh6bjIrYit1TWE5Mjk4OXVyUHV3VVRaOHo4bHVFbUNpbFlzWDJndlhYV3hycXpZZEJFVExxK2NYRmxtRkY1aFMxVzdBS052NjdEdXNuWmQ5QkdVUlJTWitSa09LMUpzelpzd1lmMjlEV3JxRXVSOW9EdlFIck1vd3JyY3RpWnFnUmgzM1o1dDQ2V3ZXdHQ4Vy90bU4vZWVqOTJ6NkZiKzNMMTUrMXFvcjExMCtWMDFicy83OVhNckJRMnE4SUpWcThOQUt3eU9PL3BQdGZ1VmIxcjdQTVBmN2FRa2laU0RsNWVVMmRlclVqU1lXZHVqUXdVNDk5VlQvS0RJeWtBaklRS0xoZWlDWk9jNDBOU1Y5OXRBVk51TzI4N3lEdW9OQ2JrR2h0ZTNleThxWC8yQ3J2QXlrSVhRY3RwMXRmZVp0MW1ZVFRXeGhCT1VZVjVFeUVDM1Jyb21GaVc5UyszVmxKa0MyMGVkWmxXQmNiMXNxcmFjMStML09za2szZkd4bG00MzF6MjZzdXFMY2xzeWUxU0RCUTlkMjMrYWN1MnlYaTU5dmtPQ1JEU0lGRUttOXdLTDJSNHdZNFI4QjJTMVpwUjJuMjJEVGNlSzV1QnczSlAwL3BkMEcySzZYL3R1Mk9mY2UxM25kV0hwdGY1RHQrN2U1MW1lSGc3M1hFYmthelZxUjM3bEdXaVhPOVJnd1lJQzFiUnR1SmlrUU4wRmxHTmRick10RytrdzQwUGEvYTRIMTJla3c3MHpETmZ2a0ZaZmF4Q3Zmc3ZGZTVsSFloaVdhSWdjUXpUYlh6SFI5b0xVeDl3UE5TU3FWZUZQZkJ2dHhQRzVNQlNWdGJadXpiN2M5L2pMVDhrczcrR2N6UTgxVlkwNjV6aWJmL2IxMUdNanE0b0dNNUY3Qm5CQUZFODArQjVxTG9GS002eTAyMXE3UFVOdi96bmsyK0lCZnU0by9FcStjMnc4Y2EvdmZ2ZEFHN25HOG15V1BIMlVrZ0hUcjFzMjZkdTNxK2o3U1dha1hpTHRVS3ZHbXZBMDJIU2VlaTh0eFU5R0V3WkZIL2NIMjh3Skp4MkVUWENCSWx5NHh1OHNsTDl0dVY3eSs3aG9qSVg1R2N4ZHBHRzhpRGVuVlNyME5jTjF6aHZGR3dERGVhTGJhYXF2MUZXTmNiMFg3RXJmanVKajMzalAyOWpVbjJjcDVYL3BuNnBiWHVxMWJ2MnJ6ZlUveDNrL1RkcEFINVJsWEdTc2REZWx0Z09BQk5DbFZoUG9qanZOdHNCL0g0N2pvTm1wWG0zVDlSMTVnK0wzbEZyWHh6OWJpdmQ1K0U0KzIvZjgyendidmQ1cDMyTFRCSXh0UVFrQTlna294cnJkSW5mb3ZoaDl5bnJ2bXlLRDl6L0RQcnJQWjNpZmI1SHNXMlUvT3VNbE5Qa1JxTXRhRTFZQm93b3FBSnF4b1dBc3IybkdjVmE1ZWJuTmUvYWYxbW5DQTVjWDBtdVJCZWNZVkdRaFFELzBCcXpLTTZ5M0N5eTh1dFg2N1RJbHQ4TWdHQ20reC9oVEcvWTlFZjhoeFJ2bEZRL2xGUS9sRkUvZnlJd01CQUlSQ0FBR0FGa0RaeklvVks5eFduNHFLQ2x1NmRLbFZwYkQwUFUxWUVaRUNSMFA1UlVQNVJkT2N5dS94eHgrM045NTR3enAzN213bm4zeXlmM2Fkano3NnlKNTg4a2xidG15Wk85WWxOL2JaWngvcjMvL0hWWVJYclZwbC8vclh2K3lUVHo1eC82K21aV2lacWttVEp0VTVSWU1NQkFDeTNILys4eDk3ODgwM3JheXN6R1VRaVdiUG5tMFBQUENBOWUzYjEwNDg4VVE3L1BERDNhVHZ1KysrMjM3NDRRZi9VV2IzM1hlZmUreUJCeDVvSjUxMGtrMllNRUdqT0czNjlPbitJellXT1lBb01uWHMyTkg2OU9uak5yMEJBRURqVUxidzZLT1AyckJodzZ4WHIxNysyUis5K09LTDFxNWRPNXM4ZWJKYmRrb3Jwdi8wcHorMXlzcEtlK2VkZDl4anZ2NzZheGM4ZHQ5OWQzZU5KeTFOdGROT085bWdRWVBzcmJmZXFyTTVLM1FBVWVwWFVsSmlXMnl4aFoxenpqbDJ6ejMzMkoxMzNtbW5uSEtLUzQvaW5ob0NRSFB3L3Z2djI0SUZDMXpsWDV1dUZxdmdNSERnUUxmWWJVQ0JSSmZkK082Nzc5enhsMSt1VytKRkFTUFI1cHR2N29LSGZuNHlvUUtJMHA4ZVBYcTRpSGJERFRlNHRFalI3SU1QUG5BWnlISEhIZWNpSGdDZzRXZ05RalV4N2JERERrbXZ3NlFPY3dVUnRSTFZwcnA2NWNxVmJsOTlJOFhGeGRhNmRXdDNIQWhhbE9ycWVFOHJnQ2lDNlVYcWtyWG5uMysrWFhIRkZhN0RSbTFwenozM25NMmZQOSs5RUwycDZ1cHEvMWtBZ0lhZ2VsZnJFSTRmUDk0L3M2RWdRT2d4dGVtY09zNUZqNnZyTWJKNjlXcDNXMXZLQVVUQlEyblBsQ2xUYk5xMGFYYnd3UWZidSsrKzY1cXRGRGdTNlVVcGlBQUFHc2IzMzMvdk9zNzMzSFBQVFM1a3F5d2ttY1RuMWZlbFAvSW9MR1VlUng1NXBGMTQ0WVV1bU54MjIyMzI3My8vMi8ybjZzUlpzMmFOLzhoMW5UcnBERDhEQUtSSHczTFYyZDJtVFJzM0NrdWJNZ1hWeWRwWG5SdzBTU1hXendHZFV6KzJxUG1xcnNkSThMamFVZzRndWxDVXJuLys0WWNmMnIzMzNydCsrTmVpUll0Y0U1Yk9Bd0FheDd4NTgxeWdVRDkwc0gzeHhSZXV2MEw3cjczMm1nc2dHdEMwY09GQy8xbnI2QXUrenJWdjM5NGRLd2lwSHp1WUp4SlEvUzUxOVdtbkhFQVVpVFJKWmNhTUdlNVlUVlJQUC8yMC9lVXZmN0hseTVmYnR0dHU2ODREQUJxZTVtcWNkdHBwRzJ5REJ3KzIwdEpTdDY5NUhQbjUrZGF6WjA4WFdCS0g0czZhTmN0MU5XaVVsV2lPaUh6NjZhZnVWaFJrVk45MzZ0VEpqYXhOSnVVQW9zaWtvYnFhMGZqdHQ5KzZ3UEhLSzYrNFRwYmpqei9lWlNjQWdNYWhyRUdqcEJJM3RSU3BpMEg3R2kwcjIyKy92ZXNrRDFxS1huLzlkWHZ3d1FkZG43YW1ZWWdDaVk0MW91dlZWMTkxajlQRXdybHo1OXJFaVJQZFk1TFJaSTJVT3l1VUNnV3BUdEJKcnVGaEYxMTBrWFh2M3QxMXFvdkdGcXVQUkkrTEt1NTlLYzFwS1lTbVFQbEZRL2xGMDl6S1R3RkFsZjRSUnh6aG4xbEhVeXhlZXVrbDF5UlZWRlRrQW9ZQ1ErS3dYVFY5UGZYVVV5NWJVZDNkcFVzWEYzeUdEQm5pUDJKamFRV1FaUFNmcUdOZDBZc0FFaitVWHpTVVh6U1VYelJ4TDcrVW03QUFBRWhFQUFHQVprN05VcGRmZnJucmVsQldjOHN0dDJSazVDd0JCQUNhT1ExeVVqLzE4ODgvN3haUVZFZTdGbCtNaWdBQ0FDM0FYbnZ0WmUrOTk1NWIvbVMvL2ZiTFNQOFBBUVFBV2dBTjhkV21tZXJCRU4rb0NDQUEwQUpvaU82SUVTTnM1TWlSN3VxRm1VQUFBWUJtVHRjRTBleHpMZnUrODg0N3U2a1d1blJ0VkFRUUFHam10Qmp1VVVjZDVacXd0SHJJMFVjZjdTN0ZFUlVCQkFDYUFmVnRMRm15WlAwMVBoSnBMU3ZOT3RjeVZOcTBYbGF5aTB5Smxvbi82cXV2YlBIaXhmNlp1cWtiUHRKVVIyYWlNNU0xQ3Nvdkdzb3ZtdVpVZmxvbFhjMVNXZ2RMaXlrbTBxVTNOUG9xV0ZCUm1jZysrK3pqK2tRQ0NoajMzMysvVytVM29FdmhIbmpnZ1Vrdk5pVmtJQUNRNVRSUlVDdnA2Z3Q5N2FDakJYQzFjdm8yMjJ4ajU1NTdycDE2NnFudWt1UVBQZlRRK21YZWRjRXBMWlpiVVZIaExsSCttOS84eGwyeVhOZEtmK0tKSjl4amtrazdnR2dDU3JEcEtsVzZyU3VLYitwK0FFQTBhcnBTSlQ5dTNEZ1hRR3BUOXFIK2psMTIyY1ZsRW1yTzJuZmZmVjNRQ0ZxTlB2LzhjOWQwdGZ2dXU3dldKR1VvR3EybHlZWmEwbDJCSlptVUE0Z0NnZGFGSHpWcTFBYWJsZ05PMXBhbUsxZ05IejdjdlFpbFFYbytBQ0N6ZE9Fb1hZbFFvNnRxVTVQVm5EbHpYQjJjK0VWZVFVUVhrOUlGcVdUMjdObnUvbjc5K3JuandJQUJBMXlnVVhCSkp1VmFYYjM0eHg1N3JFdUZIbnZzc2ZYYlhYZmRaVHZ1dUtPTGdnRk5VaGs2ZEtqZGZ2dnQ5c2dqajdpclkya3FQVUVFQURKSDEybDY0WVVYM05Mc1dxYTlOaTNSTHNHVkJ4UHBuSzRUSW5xY090bHI5M1VFVnlJTUhsZGJXaG1Jc29yMzMzL2Zyci8rZXJkZGQ5MTE3c0pTMTF4enpmb3JGWXBTb0QzMjJNTzFzZDEwMDAzMjRvc3YycFFwVTF6UFB3QWdNL1NGWHMxV2FnMUtKcWo0azNXQzYycUZ5bHhFajFPelZXM0I4NExIMVpaeUFGR0VVc2J4OGNjZisyZlNvelFvdUFnVkFDQ2FiNzc1eHEyb08yblNwQTJhcHhJRnJUNkpsN01OcUxOZFFVVDB1TG9lSThIamFrczVnS2dUUlIwdUR6endnQzFZc01CbXpwenBqbFBkTklSTTExVUhBRVNucFVtNmR1MXFQL3p3Z3h0cHBVMzdxcXUxdjNUcDB2VlhIRXhXOXlxclVLdVNGQmNYSjMxTU1LZEVWNkpOUm1FcnJZSGFTblBVMXBadU5xRU1KTXk4RU1hUlIwUDVSVVA1UlVQNVJWTmYrVjEyMldXMmZQbHkvMmhqdSs2NnF4dTYrOGMvL3RIMVNSOXd3QUgrUGV2cTQ2bFRwN3JMMVdxNHJpNkYrOG9ycjdqNUk1cEhFdEJsY0o5OTlsazc4OHd6azNaQnBCMUFHaHNmd0dnb3YyZ292MmdvdjJqU0xiKy8vLzN2YmlMMzZhZWY3cDh4TjZsYmt3TjFMdWhvVjUvMWd3OCthSWNjY29nTkhqell6VHpYb0NjRm5Ra1RKcmpIYUdDVStyaVZuUngzM0hIdVhHME1pd0tBWmt6elA5U3NOVzNhTkpkbGFDWGVoeDkrMkEzdDNYenp6ZDFqTkh5M2YvLytycXRCOTcvODhzdDI4ODAzdXlZeERZaXFDeGxJUkh3RGpJYnlpNGJ5aTZhNWxkK3JyNzdxNW16b2dsR0oxT0d1Q1lXTEZpMXlXWWdDeDdiYmJ1c21ld2ZVeGFBbUs2M2FxMzJON3RwdXUrM2NsUXpyUWdDSmlEL2dhQ2kvYUNpL2FDaS9hR2pDQWdDRVFnQUJBSVJnOXY4QjRoTU9wSStYbHRzQUFBQUFTVVZPUks1Q1lJST1cIjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXROb3JtYWwoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FJQUFBQ1FkMVBlQUFBRkRtbFVXSFJZVFV3NlkyOXRMbUZrYjJKbExuaHRjQUFBQUFBQVBEOTRjR0ZqYTJWMElHSmxaMmx1UFNMdnU3OGlJR2xrUFNKWE5VMHdUWEJEWldocFNIcHlaVk42VGxSamVtdGpPV1FpUHo0S1BIZzZlRzF3YldWMFlTQjRiV3h1Y3pwNFBTSmhaRzlpWlRwdWN6cHRaWFJoTHlJZ2VEcDRiWEIwYXowaVdFMVFJRU52Y21VZ05TNDFMakFpUGdvZ1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNEtJQ0E4Y21SbU9rUmxjMk55YVhCMGFXOXVJSEprWmpwaFltOTFkRDBpSWdvZ0lDQWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWdvZ0lDQWdlRzFzYm5NNmNHaHZkRzl6YUc5d1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM0JvYjNSdmMyaHZjQzh4TGpBdklnb2dJQ0FnZUcxc2JuTTZaWGhwWmowaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOWxlR2xtTHpFdU1DOGlDaUFnSUNCNGJXeHVjenAwYVdabVBTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM1JwWm1Zdk1TNHdMeUlLSUNBZ0lIaHRiRzV6T25odGNFMU5QU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2Ylcwdklnb2dJQ0FnZUcxc2JuTTZjM1JGZG5ROUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlVWMlpXNTBJeUlLSUNBZ2VHMXdPa055WldGMFpVUmhkR1U5SWpJd01qTXRNRFV0TURaVU1qSTZNamc2TURZck1ESXdNQ0lLSUNBZ2VHMXdPazF2WkdsbWVVUmhkR1U5SWpJd01qTXRNRFV0TURaVU1qSTZNekE2TWpFck1ESTZNREFpQ2lBZ0lIaHRjRHBOWlhSaFpHRjBZVVJoZEdVOUlqSXdNak10TURVdE1EWlVNakk2TXpBNk1qRXJNREk2TURBaUNpQWdJSEJvYjNSdmMyaHZjRHBFWVhSbFEzSmxZWFJsWkQwaU1qQXlNeTB3TlMwd05sUXlNam95T0Rvd05pc3dNakF3SWdvZ0lDQndhRzkwYjNOb2IzQTZRMjlzYjNKTmIyUmxQU0l6SWdvZ0lDQndhRzkwYjNOb2IzQTZTVU5EVUhKdlptbHNaVDBpYzFKSFFpQkpSVU0yTVRrMk5pMHlMakVpQ2lBZ0lHVjRhV1k2VUdsNFpXeFlSR2x0Wlc1emFXOXVQU0l4SWdvZ0lDQmxlR2xtT2xCcGVHVnNXVVJwYldWdWMybHZiajBpTVNJS0lDQWdaWGhwWmpwRGIyeHZjbE53WVdObFBTSXhJZ29nSUNCMGFXWm1Pa2x0WVdkbFYybGtkR2c5SWpFaUNpQWdJSFJwWm1ZNlNXMWhaMlZNWlc1bmRHZzlJakVpQ2lBZ0lIUnBabVk2VW1WemIyeDFkR2x2YmxWdWFYUTlJaklpQ2lBZ0lIUnBabVk2V0ZKbGMyOXNkWFJwYjI0OUlqY3lMekVpQ2lBZ0lIUnBabVk2V1ZKbGMyOXNkWFJwYjI0OUlqY3lMekVpUGdvZ0lDQThlRzF3VFUwNlNHbHpkRzl5ZVQ0S0lDQWdJRHh5WkdZNlUyVnhQZ29nSUNBZ0lEeHlaR1k2YkdrS0lDQWdJQ0FnYzNSRmRuUTZZV04wYVc5dVBTSndjbTlrZFdObFpDSUtJQ0FnSUNBZ2MzUkZkblE2YzI5bWRIZGhjbVZCWjJWdWREMGlRV1ptYVc1cGRIa2dVR2h2ZEc4Z01pQXlMakF1TkNJS0lDQWdJQ0FnYzNSRmRuUTZkMmhsYmowaU1qQXlNeTB3TlMwd05sUXlNam96TURveU1Tc3dNam93TUNJdlBnb2dJQ0FnUEM5eVpHWTZVMlZ4UGdvZ0lDQThMM2h0Y0UxTk9raHBjM1J2Y25rK0NpQWdQQzl5WkdZNlJHVnpZM0pwY0hScGIyNCtDaUE4TDNKa1pqcFNSRVkrQ2p3dmVEcDRiWEJ0WlhSaFBnbzhQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCswSWdWeEFBQUFZQnBRME5RYzFKSFFpQkpSVU0yTVRrMk5pMHlMakVBQUNpUmRaSFBLMFJSRk1jL00zN21SNk5ZS0JZdkRhdWhRWW1OeGNpdndtS01NdGpNdlBtbDVvM1hlMi9TWkt0c0ZTVTJmaTM0QzlncWE2V0lsR3haRXh2MG5PZXBrY3k1blhzKzkzdnZPZDE3TG5naldWVXp5NE9nNVN3alBCcFNacU56U3RVakZWVFNSQXUrbUdycWs5TWpFVXJhMncwZUoxNTFPclZLbi92WGFoTkpVd1ZQdGZDZ3FodVc4Smp3eExLbE83d3AzS1JtWWduaFkrR0FJUmNVdm5iMHVNdFBEcWRkL25EWWlJU0h3TnNncktSL2Nmd1hxeGxERTVhWDQ5ZXllZlhuUHM1TDZwSzVtV21KYmVLdG1JUVpKWVRDT01NTTBVYzNBekwzMFVrUFhiS2lSSDd3TzMrS0pjbFZaZFlwWUxCSW1nd1dBVkh6VWowcE1TVjZVa2FXZ3RQL3YzMDFVNzA5YnZXNkVGUTgyUFpMTzFSdHdPZTZiYi92Mi9ibkFaVGR3MW11bUwrMEIvMnZvcThYTmY4dStGYmg1THlveGJmZ2RBMmE3L1NZRWZ1V3lzUzlxUlE4SDBGOUZCb3ZvV2JlN2RuUFBvZTNFRm1ScjdxQTdSM29rUE8raFM4MjRXZlFneEdDY2dBQUFBbHdTRmx6QUFBTEV3QUFDeE1CQUpxY0dBQUFBQXhKUkVGVUNKbGphR2o0RHdBRGd3SUFWYmpXUHdBQUFBQkpSVTVFcmtKZ2dnPT1cIjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRUb29uKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBUDhBQUFBQkNBWUFBQUFSa0hpakFBQUJoR2xEUTFCSlEwTWdjSEp2Wm1sc1pRQUFLSkY5a1QxSXcwQWN4Vi9UU290VUJPMGc0cENoT3RsRlJSeExGWXRnb2JRVlduVXd1ZlFMbWpRa0tTNk9nbXZCd1kvRnFvT0xzNjRPcm9JZytBSGk3T0NrNkNJbC9pOHB0SWp4NExnZjcrNDk3dDRCUXF2R1ZETVFCMVROTWpMSmhKZ3ZySXJCVndRUlFCZ2hERW5NMUZQWnhSdzh4OWM5Zkh5OWkvRXM3M04vamdHbGFETEFKeExIbVc1WXhCdkVzNXVXem5tZk9NSXFra0o4VGp4cDBBV0pIN2t1dS96R3VleXd3RE1qUmk0elR4d2hGc3M5TFBjd3F4Z3E4UXh4VkZFMXloZnlMaXVjdHppcnRRYnIzSk8vTUZ6VVZySmNwem1HSkphUVFob2laRFJRUlEwV1lyUnFwSmpJMEg3Q3d6L3ErTlBra3NsVkJTUEhBdXBRSVRsKzhELzQzYTFabXA1eWs4SUpvTy9GdGovR2dlQXUwRzdhOXZleGJiZFBBUDh6Y0tWMS9mVVdNUGRKZXJPclJZK0F3VzNnNHJxcnlYdkE1UTR3OHFSTGh1UklmcHBDcVFTOG45RTNGWURoVzZCL3plMnRzNC9UQnlCSFhTM2ZBQWVId0VTWnN0YzkzaDNxN2UzZk01MytmZ0E0T1hLUHQvN0svZ0FBQUFaaVMwZEVBUDhBQUFBQU15ZDg4d0FBQUFsd1NGbHpBQUF1SXdBQUxpTUJlS1UvZGdBQUFBZDBTVTFGQitnSEJBd2RKMWo5V0JzQUFBQVpkRVZZZEVOdmJXMWxiblFBUTNKbFlYUmxaQ0IzYVhSb0lFZEpUVkJYZ1E0WEFBQUFWVWxFUVZRb3oyTmtZR0Q0enpBS2hoNWdaV0JnNEdCZ1lPQkVvMkZzS0orWGs0RkJpcE9CUVpvRFFrdHhNakNJc0RFd1NIRkFNUmVFNXNWbURoY1dPMWdZR0JnWUdNbElOdmowTUk3d1pFaXMvNmtiaGdDMDRRai93Ny9IWmdBQUFBQkpSVTVFcmtKZ2dnPT1cIjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRJY29uTGlnaHQoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQyUzRnhtbCB2ZXJzaW9uPScxLjAnIGVuY29kaW5nPSdVVEYtOCcgc3RhbmRhbG9uZT0nbm8nJTNGJTNFJTNDc3ZnIHZpZXdCb3g9JzAgMCAxNiAxNicgdmVyc2lvbj0nMS4xJyB3aWR0aD0nMTYnIGhlaWdodD0nMTYnIGlkPSdMaWdodCcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyUzRSUzQ3N0eWxlJTNFIC5zJTdCZmlsbDolMjNmZmY7c3Ryb2tlOiUyMzAwMDtzdHJva2Utd2lkdGg6LjFweDslN0QgJTNDL3N0eWxlJTNFJTNDcmVjdCBjbGFzcz0ncycgeD0nMC4xNzAzOTI5MycgeT0nMTAuMDAyNDQ4JyB3aWR0aD0nMy45MDAwNTY4JyBoZWlnaHQ9JzAuOTAwMDk5MzQnIGlkPSdOTkUnIHRyYW5zZm9ybT0ncm90YXRlKC02Ny41KScgLyUzRSUzQ3JlY3QgeD0nOC44Mjk1MDc4JyB5PScxMC4wMDI0NDcnIHdpZHRoPSczLjkwMDA1NjgnIGhlaWdodD0nMC45MDAwOTkzNCcgaWQ9J0VORScgdHJhbnNmb3JtPSdyb3RhdGUoLTIyLjUpJyBjbGFzcz0ncycgLyUzRSUzQ3JlY3QgeD0nMTQuOTUyNDY5JyB5PSczLjg3OTU3MTcnIHdpZHRoPSczLjkwMDAxMzknIGhlaWdodD0nMC45MDAwOTk4NycgaWQ9J0VTRScgdHJhbnNmb3JtPSdyb3RhdGUoMjIuNSknIGNsYXNzPSdzJyAvJTNFJTNDcmVjdCB4PScxNC45NTI0NycgeT0nLTQuNzc5NTQyOScgd2lkdGg9JzMuOTAwMDEzOScgaGVpZ2h0PScwLjkwMDA5OTg3JyBpZD0nU1NFJyB0cmFuc2Zvcm09J3JvdGF0ZSg2Ny41KScgY2xhc3M9J3MnIC8lM0UlM0NyZWN0IHg9Jy0xMi43Mjk1NjUnIHk9JzEwLjAwMjQ0Nycgd2lkdGg9JzMuOTAwMDEzOScgaGVpZ2h0PScwLjkwMDA5OTg3JyBpZD0nU1NXJyB0cmFuc2Zvcm09J3JvdGF0ZSgtNjcuNSknIGNsYXNzPSdzJyAvJTNFJTNDcmVjdCB4PSctNC4wNzA0NDk4JyB5PScxMC4wMDI0NDcnIHdpZHRoPSczLjkwMDAxMzknIGhlaWdodD0nMC45MDAwOTk4NycgaWQ9J1dTVycgdHJhbnNmb3JtPSdyb3RhdGUoLTIyLjUpJyBjbGFzcz0ncycgLyUzRSUzQ3JlY3QgeD0nMi4wNTI0Njg1JyB5PSczLjg3OTU3MTcnIHdpZHRoPSczLjkwMDAxMzknIGhlaWdodD0nMC45MDAwOTk4NycgaWQ9J1dOVycgdHJhbnNmb3JtPSdyb3RhdGUoMjIuNSknIGNsYXNzPSdzJyAvJTNFJTNDcmVjdCB4PScyLjA1MjQ2ODUnIHk9Jy00Ljc3OTU0MjknIHdpZHRoPSczLjkwMDAxMzknIGhlaWdodD0nMC45MDAwOTk4NycgaWQ9J05OVycgdHJhbnNmb3JtPSdyb3RhdGUoNjcuNSknIGNsYXNzPSdzJyAvJTNFJTNDZWxsaXBzZSBpZD0nQ0VOVEVSJyBjeD0nOC4wMDAwODInIGN5PSc4LjAwMDI1NzUnIHJ4PSczLjQ1MDA4MjMnIHJ5PSczLjQ1MDI1NzMnIGNsYXNzPSdzJyAvJTNFJTNDL3N2ZyUzRVwiO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldEljb25DYW1lcmEoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQyUzRnhtbCB2ZXJzaW9uPScxLjAnIGVuY29kaW5nPSdVVEYtOCcgc3RhbmRhbG9uZT0nbm8nJTNGJTNFJTNDc3ZnIGlkPSdDYW1lcmEnIHZpZXdCb3g9JzAgMCAxNiAxNicgdmVyc2lvbj0nMS4xJyB3aWR0aD0nMTYnIGhlaWdodD0nMTYnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyclM0UlM0NzdHlsZSBpZD0nc3R5bGUxJyUzRS5zJTdCZmlsbDolMjNmZmY7c3Ryb2tlOiUyMzAwMDtzdHJva2Utd2lkdGg6LjFweDslN0QgJTNDL3N0eWxlJTNFJTNDcGF0aCBjbGFzcz0ncycgZD0nTSAxMy44NTczMjIsOC44NzU1Mjk3IEggMTIuNDEzNDI0IEwgMTIuNDEzLDYuNzg3IGggLTEuNDI1MzExIGMgMC4yMjcwMjYsLTAuNDQ5NDY5MyAwLjM2MzI0MywtMC45NDUzOTE5IDAuMzYzMjQzLC0xLjQ4ODUwMDggMCwtMS43OTc4Nzc1IC0xLjQwNzU3MjcsLTMuMjQ5Mjg5MyAtMy4xNTExNDY2LC0zLjI0OTI4OTMgLTEuNzQzNTc0NiwwIC0zLjE1MTE0NzksMS40NTE0MTE4IC0zLjE1MTE0NzksMy4yNDkyODkzIHYgMC4wMjgwOTMgQyA0LjU3NjQxOTQsNS4wMzYzMTE4IDQuMDMxNTUyNCw0Ljg1ODM5NjggMy40NTAzNjA2LDQuODU4Mzk2OCAxLjcwNjc4NjMsNC44Njc3NTY3IDAuMjk5MjEyOTgsNi4zMTkxNzIzIDAuMjk5MjEyOTgsOC4xMDc2ODYgYyAwLDEuNzg4NTEzNSAxLjY2NTM4NTgyLDMuMzExNzg5IDMuNDI0NTg1MTIsMy4yNDkyODkgTCAzLjczMiwxMy45NzYgaCA4LjY4MSB2IC0yLjExMzM2OCBoIDEuNDQ0MzIyIHonIGlkPSdwYXRoMScgLyUzRSUzQ3JlY3QgY2xhc3M9J3MnIHg9JzEyLjgwMzkxJyB5PSc4LjM5Nzk2ODMnIHdpZHRoPScyLjg5Njg3NjYnIGhlaWdodD0nMy44ODYwMzc2JyByeD0nMCcgcnk9JzAnIGlkPSdyZWN0MScgLyUzRSUzQy9zdmclM0UlMEFcIjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRJY29uQXVkaW8oKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQyUzRnhtbCB2ZXJzaW9uPScxLjAnIGVuY29kaW5nPSdVVEYtOCcgc3RhbmRhbG9uZT0nbm8nJTNGJTNFJTNDc3ZnIGlkPSdBdWRpbycgdmlld0JveD0nMCAwIDE2IDE2JyB2ZXJzaW9uPScxLjEnIHdpZHRoPScxNicgaGVpZ2h0PScxNicgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyUzRSUzQ3N0eWxlJTNFLnMlN0JmaWxsOiUyM2ZmZjtzdHJva2U6JTIzMDAwO3N0cm9rZS13aWR0aDouMXB4OyU3RCAlM0Mvc3R5bGUlM0UlM0NwYXRoIGNsYXNzPSdzJyBkPSdNIDkuMTU2MzU4OCwxLjA4MDQwMDYgMy42NzI5MzQxLDQuNjQyMDE3IEggMC41NDM2NDk3MSB2IDYuNzg0MDMxIEggMy43NTkwNjEyIGwgNS4zOTcyOTc2LDMuNDkzNzc2IHonIGlkPSdwYXRoMScgLyUzRSUzQ3BhdGggY2xhc3M9J3MnIGQ9J20gMTMuMzQ3NTE4LDEzLjY3NjY0NSAtMC43NjUxNTcsLTAuNTYzNTY2IGMgNC4yMjc0ODUsLTUuNTYwNTI0MSAwLjIxMDQxOCwtOS44ODEyMDIgMC4wMzgyNSwtMTAuMDU5NjY0OCBsIDAuNjk4MjA0LC0wLjY0ODEwMTkgYyAwLjA0NzgyLDAuMDQ2OTY0IDQuNzUzNTMsNS4wNjI3MDc2IDAuMDM4MjUsMTEuMjcxMzMyNyB6JyBpZD0ncGF0aDInIC8lM0UlM0NwYXRoIGNsYXNzPSdzJyBkPSdtIDExLjMyMTg2OCwxMS43OTgwOSAtMC44MjI1NDEsLTAuNDc5MDMyIGMgMi4xNDI0MzQsLTMuNTc4NjQ3NCAwLjExNDc3MywtNi4zNTg5MSAwLjAyODY5LC02LjQ3MTYyMzIgbCAwLjc2NTE1NiwtMC41NjM1NjY2IGMgMC4xMDUyMDgsMC4xNDA4OTE1IDIuNTA1ODgzLDMuMzgxNDAwMSAwLjAyODY5LDcuNTA0ODI5OCB6JyBpZD0ncGF0aDMnIC8lM0UlM0Mvc3ZnJTNFJTBBXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgZ2V0SWNvblBhcnRpY2xlcygpOiBzdHJpbmcge1xyXG4gICAgLy8gICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sIHZlcnNpb249JzEuMCcgZW5jb2Rpbmc9J1VURi04JyUzRiUzRSUzQ3N2ZyBpZD0nUGFydGlrZWxfVjInIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgdmlld0JveD0nMCAwIDE2LjI4IDE2LjUyJyUzRSUzQ2RlZnMlM0UlM0NzdHlsZSUzRS5jbHMtMSU3QmZpbGw6JTIzZmZmO3N0cm9rZTolMjMwMDA7c3Ryb2tlLW1pdGVybGltaXQ6MTUuMTI7c3Ryb2tlLXdpZHRoOi4yNXB4OyU3RCUzQy9zdHlsZSUzRSUzQy9kZWZzJTNFJTNDY2lyY2xlIGNsYXNzPSdjbHMtMScgY3g9JzQuNzInIGN5PSc1LjQ3JyByPScyLjUyJy8lM0UlM0NjaXJjbGUgY2xhc3M9J2Nscy0xJyBjeD0nMTEuMjYnIGN5PSc4LjI4JyByPScxLjc1Jy8lM0UlM0NjaXJjbGUgY2xhc3M9J2Nscy0xJyBjeD0nNS45NScgY3k9JzEyLjA1JyByPScxLjI5Jy8lM0UlM0Mvc3ZnJTNFXCI7XHJcbiAgICAvLyB9XHJcbiAgfVxyXG59IiwiLy8gLzxyZWZlcmVuY2UgcGF0aD1cIi4uL0V2ZW50L0V2ZW50LnRzXCIvPlxyXG4vLyAvPHJlZmVyZW5jZSBwYXRoPVwiLi4vVGltZS9UaW1lLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHRoZSBtb2RlIGEgbG9vcCBydW5zIGluXHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gTE9PUF9NT0RFIHtcclxuICAgIC8qKiBMb29wIGN5Y2xlcyBjb250cm9sbGVkIGJ5IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKi9cclxuICAgIEZSQU1FX1JFUVVFU1QgPSBcImZyYW1lUmVxdWVzdFwiLFxyXG4gICAgLyoqIExvb3AgY3ljbGVzIGNvbnRyb2xsZWQgYnkgeHJTZXNzaW9uLnJlcXVlc3RBbmltYXRpb25GcmFtZSAqL1xyXG4gICAgRlJBTUVfUkVRVUVTVF9YUiA9IFwiZnJhbWVSZXF1ZXN0WFJcIixcclxuICAgIC8qKiBMb29wIGN5Y2xlcyB3aXRoIHRoZSBnaXZlbiBmcmFtZXJhdGUgaW4ge0BsaW5rIFRpbWUuZ2FtZX0gKi9cclxuICAgIFRJTUVfR0FNRSA9IFwidGltZUdhbWVcIixcclxuICAgIC8qKiBMb29wIGN5Y2xlcyB3aXRoIHRoZSBnaXZlbiBmcmFtZXJhdGUgaW4gcmVhbHRpbWUsIGluZGVwZW5kZW50IG9mIHtAbGluayBUaW1lLmdhbWV9ICovXHJcbiAgICBUSU1FX1JFQUwgPSBcInRpbWVSZWFsXCJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvcmUgbG9vcCBvZiBhIEZVREdFIGFwcGxpY2F0aW9uLiBJbml0aWFsaXplcyBhdXRvbWF0aWNhbGx5IGFuZCBtdXN0IGJlIHN0YXJ0ZWQgZXhwbGljaXRseS5cclxuICAgKiBJdCB0aGVuIGZpcmVzIHtAbGluayBFVkVOVC5MT09QX0ZSQU1FfSB0byBhbGwgYWRkZWQgbGlzdGVuZXJzIGF0IGVhY2ggZnJhbWVcclxuICAgKiBcclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIExvb3AgZXh0ZW5kcyBFdmVudFRhcmdldFN0YXRpYyB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyDGklRpbWVTdGFydEdhbWU6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyDGklRpbWVTdGFydFJlYWw6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyDGklRpbWVGcmFtZUdhbWU6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyDGklRpbWVGcmFtZVJlYWw6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyDGklRpbWVGcmFtZVN0YXJ0R2FtZTogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZUZyYW1lU3RhcnRSZWFsOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJUaW1lTGFzdEZyYW1lR2FtZUF2ZzogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZUxhc3RGcmFtZVJlYWxBdmc6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyDGkkZyYW1lczogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIHJ1bm5pbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgc3RhdGljIG1vZGU6IExPT1BfTU9ERSA9IExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaWRJbnRlcnZhbGw6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBpZFJlcXVlc3Q6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBmcHNEZXNpcmVkOiBudW1iZXIgPSAzMDtcclxuICAgIHByaXZhdGUgc3RhdGljIGZyYW1lc1RvQXZlcmFnZTogbnVtYmVyID0gMzA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBzeW5jV2l0aEFuaW1hdGlvbkZyYW1lOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIFRoZSBnYW1ldGltZSB0aGUgbG9vcCB3YXMgc3RhcnRlZCwgb3ZlcndyaXR0ZW4gYXQgZWFjaCBzdGFydCAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgdGltZVN0YXJ0R2FtZSgpOiBudW1iZXIgeyByZXR1cm4gTG9vcC7GklRpbWVTdGFydEdhbWU7IH1cclxuICAgIC8qKiBUaGUgcmVhbHRpbWUgdGhlIGxvb3Agd2FzIHN0YXJ0ZWQsIG92ZXJ3cml0dGVuIGF0IGVhY2ggc3RhcnQgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IHRpbWVTdGFydFJlYWwoKTogbnVtYmVyIHsgcmV0dXJuIExvb3AuxpJUaW1lU3RhcnRSZWFsOyB9XHJcbiAgICAvKiogVGhlIGdhbWV0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgbG9vcCBjeWNsZSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgdGltZUZyYW1lR2FtZSgpOiBudW1iZXIgeyByZXR1cm4gTG9vcC7GklRpbWVGcmFtZUdhbWU7IH1cclxuICAgIC8qKiBUaGUgcmVhbHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBsb29wIGN5Y2xlICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCB0aW1lRnJhbWVSZWFsKCk6IG51bWJlciB7IHJldHVybiBMb29wLsaSVGltZUZyYW1lUmVhbDsgfVxyXG4gICAgLyoqIFRoZSBnYW1ldGltZSB0aGUgbGFzdCBsb29wIGN5Y2xlIHN0YXJ0ZWQqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgdGltZUZyYW1lU3RhcnRHYW1lKCk6IG51bWJlciB7IHJldHVybiBMb29wLsaSVGltZUZyYW1lU3RhcnRHYW1lOyB9XHJcbiAgICAvKiogVGhlIHJlYWx0aW1lIHRoZSBsYXN0IGxvb3AgY3ljbGUgc3RhcnRlZCovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCB0aW1lRnJhbWVTdGFydFJlYWwoKTogbnVtYmVyIHsgcmV0dXJuIExvb3AuxpJUaW1lRnJhbWVTdGFydFJlYWw7IH1cclxuICAgIC8qKiBUaGUgYXZlcmFnZSBudW1iZXIgb2YgZnJhbWVzIHBlciBzZWNvbmQgaW4gZ2FtZXRpbWUgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGZwc0dhbWVBdmVyYWdlKCk6IG51bWJlciB7IHJldHVybiAxMDAwIC8gTG9vcC7GklRpbWVMYXN0RnJhbWVHYW1lQXZnOyB9XHJcbiAgICAvKiogVGhlIGF2ZXJhZ2UgbnVtYmVyIG9mIGZyYW1lcyBwZXIgc2Vjb25kIGluIHJlYWx0aW1lICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCBmcHNSZWFsQXZlcmFnZSgpOiBudW1iZXIgeyByZXR1cm4gMTAwMCAvIExvb3AuxpJUaW1lTGFzdEZyYW1lUmVhbEF2ZzsgfVxyXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgZnJhbWVzIHRyaWdnZXJlZCBzbyBmYXIgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGZyYW1lcygpOiBudW1iZXIgeyByZXR1cm4gTG9vcC7GkkZyYW1lczsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHRoZSBsb29wIHdpdGggdGhlIGdpdmVuIG1vZGUgYW5kIGZwcy4gIFxyXG4gICAgICogVGhlIGRlZmF1bHQgZm9yIF9tb2RlIGlzIEZSQU1FX1JFUVVFU1QsIHNlZSB7QGxpbmsgTE9PUF9NT0RFfSwgaG9va2luZyB0aGUgbG9vcCB0byB0aGUgYnJvd3NlcidzIGFuaW1hdGlvbiBmcmFtZS5cclxuICAgICAqIElzIG9ubHkgYXBwbGljYWJsZSBpbiBUSU1FLW1vZGVzLlxyXG4gICAgICogX3N5bmNXaXRoQW5pbWF0aW9uRnJhbWUgaXMgZXhwZXJpbWVudGFsIGFuZCBvbmx5IGFwcGxpY2FibGUgaW4gVElNRS1tb2RlcywgZGVmZXJyaW5nIHRoZSBsb29wLWN5Y2xlIHVudGlsIHRoZSBuZXh0IHBvc3NpYmxlIGFuaW1hdGlvbiBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzdGFydChfbW9kZTogTE9PUF9NT0RFID0gTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1QsIF9mcHM6IG51bWJlciA9IDYwLCBfc3luY1dpdGhBbmltYXRpb25GcmFtZTogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIExvb3Auc3RvcCgpO1xyXG5cclxuICAgICAgTG9vcC7GklRpbWVTdGFydEdhbWUgPSBUaW1lLmdhbWUuZ2V0KCk7XHJcbiAgICAgIExvb3AuxpJUaW1lU3RhcnRSZWFsID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIExvb3AuxpJUaW1lRnJhbWVTdGFydEdhbWUgPSBMb29wLsaSVGltZVN0YXJ0R2FtZTtcclxuICAgICAgTG9vcC7GklRpbWVGcmFtZVN0YXJ0UmVhbCA9IExvb3AuxpJUaW1lU3RhcnRSZWFsO1xyXG4gICAgICBMb29wLmZwc0Rlc2lyZWQgPSAoX21vZGUgPT0gTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1QpID8gNjAgOiBfZnBzO1xyXG4gICAgICBMb29wLmZyYW1lc1RvQXZlcmFnZSA9IExvb3AuZnBzRGVzaXJlZDtcclxuICAgICAgTG9vcC7GklRpbWVMYXN0RnJhbWVHYW1lQXZnID0gTG9vcC7GklRpbWVMYXN0RnJhbWVSZWFsQXZnID0gMTAwMCAvIExvb3AuZnBzRGVzaXJlZDtcclxuICAgICAgTG9vcC5tb2RlID0gX21vZGU7XHJcbiAgICAgIExvb3Auc3luY1dpdGhBbmltYXRpb25GcmFtZSA9IF9zeW5jV2l0aEFuaW1hdGlvbkZyYW1lO1xyXG5cclxuICAgICAgbGV0IGxvZzogc3RyaW5nID0gYExvb3Agc3RhcnRpbmcgaW4gbW9kZSAke0xvb3AubW9kZX1gO1xyXG4gICAgICBpZiAoTG9vcC5tb2RlICE9IExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUKVxyXG4gICAgICAgIGxvZyArPSBgIHdpdGggYXR0ZW1wdGVkICR7X2Zwc30gZnBzYDtcclxuICAgICAgRGVidWcuZnVkZ2UobG9nKTtcclxuXHJcbiAgICAgIHN3aXRjaCAoX21vZGUpIHtcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUOlxyXG4gICAgICAgICAgTG9vcC5sb29wRnJhbWUoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1RfWFI6XHJcbiAgICAgICAgICBMb29wLmxvb3BGcmFtZVhSKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5USU1FX1JFQUw6XHJcbiAgICAgICAgICBMb29wLmlkSW50ZXJ2YWxsID0gd2luZG93LnNldEludGVydmFsKExvb3AubG9vcFRpbWUsIDEwMDAgLyBMb29wLmZwc0Rlc2lyZWQpO1xyXG4gICAgICAgICAgTG9vcC5sb29wVGltZSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBMT09QX01PREUuVElNRV9HQU1FOlxyXG4gICAgICAgICAgTG9vcC5pZEludGVydmFsbCA9IFRpbWUuZ2FtZS5zZXRUaW1lcigxMDAwIC8gTG9vcC5mcHNEZXNpcmVkLCAwLCBMb29wLmxvb3BUaW1lKTtcclxuICAgICAgICAgIExvb3AubG9vcFRpbWUoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgTG9vcC5ydW5uaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIHRoZSBsb29wXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc3RvcCgpOiB2b2lkIHtcclxuICAgICAgaWYgKCFMb29wLnJ1bm5pbmcpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgc3dpdGNoIChMb29wLm1vZGUpIHtcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5GUkFNRV9SRVFVRVNUOlxyXG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKExvb3AuaWRSZXF1ZXN0KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1RfWFI6XHJcbiAgICAgICAgICBYUlZpZXdwb3J0LmRlZmF1bHQuc2Vzc2lvbi5jYW5jZWxBbmltYXRpb25GcmFtZShMb29wLmlkUmVxdWVzdCk7XHJcbiAgICAgICAgICBYUlZpZXdwb3J0LmRlZmF1bHQuc2Vzc2lvbiA9IG51bGw7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5USU1FX1JFQUw6XHJcbiAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChMb29wLmlkSW50ZXJ2YWxsKTtcclxuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShMb29wLmlkUmVxdWVzdCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5USU1FX0dBTUU6XHJcbiAgICAgICAgICBUaW1lLmdhbWUuZGVsZXRlVGltZXIoTG9vcC5pZEludGVydmFsbCk7XHJcbiAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoTG9vcC5pZFJlcXVlc3QpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBMb29wLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgRGVidWcuZnVkZ2UoXCJMb29wIHN0b3BwZWQhXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udGludWUgcnVubmluZyB0aGUgbG9vcFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNvbnRpbnVlKCk6IHZvaWQge1xyXG4gICAgICBpZiAoTG9vcC5ydW5uaW5nKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIExvb3Auc3RhcnQoTG9vcC5tb2RlLCBMb29wLmZwc0Rlc2lyZWQsIExvb3Auc3luY1dpdGhBbmltYXRpb25GcmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9vcCgpOiB2b2lkIHtcclxuICAgICAgUGVyZm9ybWFuY2VNb25pdG9yLnN0YXJ0RnJhbWUoKTtcclxuICAgICAgbGV0IHRpbWU6IG51bWJlcjtcclxuICAgICAgdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICBMb29wLsaSVGltZUZyYW1lUmVhbCA9IHRpbWUgLSBMb29wLsaSVGltZUZyYW1lU3RhcnRSZWFsO1xyXG4gICAgICBMb29wLsaSVGltZUZyYW1lU3RhcnRSZWFsID0gdGltZTtcclxuXHJcbiAgICAgIHRpbWUgPSBUaW1lLmdhbWUuZ2V0KCk7XHJcbiAgICAgIExvb3AuxpJUaW1lRnJhbWVHYW1lID0gdGltZSAtIExvb3AuxpJUaW1lRnJhbWVTdGFydEdhbWU7XHJcbiAgICAgIExvb3AuxpJUaW1lRnJhbWVTdGFydEdhbWUgPSB0aW1lO1xyXG5cclxuICAgICAgTG9vcC7GklRpbWVMYXN0RnJhbWVHYW1lQXZnID0gKChMb29wLmZyYW1lc1RvQXZlcmFnZSAtIDEpICogTG9vcC7GklRpbWVMYXN0RnJhbWVHYW1lQXZnICsgTG9vcC7GklRpbWVGcmFtZUdhbWUpIC8gTG9vcC5mcmFtZXNUb0F2ZXJhZ2U7XHJcbiAgICAgIExvb3AuxpJUaW1lTGFzdEZyYW1lUmVhbEF2ZyA9ICgoTG9vcC5mcmFtZXNUb0F2ZXJhZ2UgLSAxKSAqIExvb3AuxpJUaW1lTGFzdEZyYW1lUmVhbEF2ZyArIExvb3AuxpJUaW1lRnJhbWVSZWFsKSAvIExvb3AuZnJhbWVzVG9BdmVyYWdlO1xyXG5cclxuICAgICAgLy8gVE9ETzogY29uc2lkZXIgTG9vcEV2ZW50IHdoaWNoIGNvbnZleXMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aW1lRWxhcHNlZCBldGMuLi5cclxuICAgICAgTG9vcC7GkkZyYW1lcysrO1xyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50ID0gbmV3IEV2ZW50KEVWRU5ULkxPT1BfRlJBTUUpO1xyXG4gICAgICBMb29wLnRhcmdldFN0YXRpYy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgUGVyZm9ybWFuY2VNb25pdG9yLmVuZEZyYW1lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9vcEZyYW1lKCk6IHZvaWQge1xyXG4gICAgICBMb29wLmxvb3AoKTtcclxuICAgICAgTG9vcC5pZFJlcXVlc3QgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKExvb3AubG9vcEZyYW1lKTtcclxuICAgIH1cclxuICAgIHByaXZhdGUgc3RhdGljIGxvb3BGcmFtZVhSKF90aW1lOiBudW1iZXIgPSBudWxsLCBfeHJGcmFtZTogWFJGcmFtZSA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgTG9vcC5sb29wKCk7XHJcbiAgICAgIFhSVmlld3BvcnQuZGVmYXVsdC5kcmF3KHRydWUsIF94ckZyYW1lKTtcclxuICAgICAgTG9vcC5pZFJlcXVlc3QgPSBYUlZpZXdwb3J0LmRlZmF1bHQuc2Vzc2lvbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoTG9vcC5sb29wRnJhbWVYUik7XHJcbiAgICB9XHJcbiAgICBwcml2YXRlIHN0YXRpYyBsb29wVGltZSgpOiB2b2lkIHtcclxuICAgICAgaWYgKExvb3Auc3luY1dpdGhBbmltYXRpb25GcmFtZSlcclxuICAgICAgICBMb29wLmlkUmVxdWVzdCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoTG9vcC5sb29wKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIExvb3AubG9vcCgpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFRpbWVVbml0cyB7XHJcbiAgICBob3Vycz86IG51bWJlcjtcclxuICAgIG1pbnV0ZXM/OiBudW1iZXI7XHJcbiAgICBzZWNvbmRzPzogbnVtYmVyO1xyXG4gICAgdGVudGhzPzogbnVtYmVyO1xyXG4gICAgaHVuZHJlZHM/OiBudW1iZXI7XHJcbiAgICB0aG91c2FuZHM/OiBudW1iZXI7XHJcbiAgICBmcmFjdGlvbj86IG51bWJlcjtcclxuICAgIGFzSG91cnM/OiBudW1iZXI7XHJcbiAgICBhc01pbnV0ZXM/OiBudW1iZXI7XHJcbiAgICBhc1NlY29uZHM/OiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFRpbWVycyBleHRlbmRzIE9iamVjdCB7XHJcbiAgICBbaWQ6IG51bWJlcl06IFRpbWVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgZ2VuZXJhdGUgYSB0aW1lc3RhbXAgdGhhdCBjb3JyZWxhdGVzIHdpdGggdGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgc3RhcnQgb2YgdGhlIHByb2dyYW0gYnV0IGFsbG93cyBmb3IgcmVzZXR0aW5nIGFuZCBzY2FsaW5nLiAgXHJcbiAgICogU3VwcG9ydHMge0BsaW5rIFRpbWVyfXMgc2ltaWxhciB0byB3aW5kb3cuc2V0SW50ZXJ2YWwgYnV0IHdpdGggcmVzcGVjdCB0byB0aGUgc2NhbGVkIHRpbWUuXHJcbiAgICogQWxsIHRpbWUgdmFsdWVzIGFyZSBnaXZlbiBpbiBtaWxsaXNlY29uZHNcclxuICAgKiBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUaW1lIGV4dGVuZHMgRXZlbnRUYXJnZXRVbmlmaWVkIHtcclxuICAgIC8qKiBTdGFuZGFyZCBnYW1lIHRpbWUgc3RhcnRpbmcgYXV0b21hdGljYWxseSB3aXRoIHRoZSBhcHBsaWNhdGlvbiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBnYW1lOiBUaW1lID0gbmV3IFRpbWUoKTtcclxuICAgIHByaXZhdGUgc3RhcnQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgc2NhbGU6IG51bWJlcjtcclxuICAgIHByaXZhdGUgb2Zmc2V0OiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGxhc3RDYWxsVG9FbGFwc2VkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHRpbWVyczogVGltZXJzID0ge307XHJcbiAgICBwcml2YXRlIGlkVGltZXJBZGRlZExhc3Q6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIHRoaXMuc2NhbGUgPSAxLjA7XHJcbiAgICAgIHRoaXMub2Zmc2V0ID0gMC4wO1xyXG4gICAgICB0aGlzLmxhc3RDYWxsVG9FbGFwc2VkID0gMC4wO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyByZXByZXNlbnRpb25zIG9mIHRoZSB0aW1lIGdpdmVuIGluIG1pbGxpc2Vjb25kcyBpbiB2YXJpb3VzIGZvcm1hdHMgZGVmaW5lZCBpbiB7QGxpbmsgVGltZVVuaXRzfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFVuaXRzKF9taWxsaXNlY29uZHM6IG51bWJlcik6IFRpbWVVbml0cyB7XHJcbiAgICAgIGxldCB1bml0czogVGltZVVuaXRzID0ge307XHJcblxyXG4gICAgICB1bml0cy5hc1NlY29uZHMgPSBfbWlsbGlzZWNvbmRzIC8gMTAwMDtcclxuICAgICAgdW5pdHMuYXNNaW51dGVzID0gdW5pdHMuYXNTZWNvbmRzIC8gNjA7XHJcbiAgICAgIHVuaXRzLmFzSG91cnMgPSB1bml0cy5hc01pbnV0ZXMgLyA2MDtcclxuXHJcbiAgICAgIHVuaXRzLmhvdXJzID0gTWF0aC5mbG9vcih1bml0cy5hc0hvdXJzKTtcclxuICAgICAgdW5pdHMubWludXRlcyA9IE1hdGguZmxvb3IodW5pdHMuYXNNaW51dGVzKSAlIDYwO1xyXG4gICAgICB1bml0cy5zZWNvbmRzID0gTWF0aC5mbG9vcih1bml0cy5hc1NlY29uZHMpICUgNjA7XHJcblxyXG4gICAgICB1bml0cy5mcmFjdGlvbiA9IF9taWxsaXNlY29uZHMgJSAxMDAwO1xyXG4gICAgICB1bml0cy50aG91c2FuZHMgPSBfbWlsbGlzZWNvbmRzICUgMTA7XHJcbiAgICAgIHVuaXRzLmh1bmRyZWRzID0gX21pbGxpc2Vjb25kcyAlIDEwMCAtIHVuaXRzLnRob3VzYW5kcztcclxuICAgICAgdW5pdHMudGVudGhzID0gdW5pdHMuZnJhY3Rpb24gLSB1bml0cy5odW5kcmVkcyAtIHVuaXRzLnRob3VzYW5kcztcclxuXHJcbiAgICAgIHJldHVybiB1bml0cztcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0aW1lIGFuZCBzY2FsaW5nXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBzY2FsZWQgdGltZXN0YW1wIG9mIHRoaXMgaW5zdGFuY2UgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICsgdGhpcy5zY2FsZSAqIChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuc3RhcnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVtYWluaW5nIHRpbWUgdG8gdGhlIGdpdmVuIHBvaW50IG9mIHRpbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFJlbWFpbmRlcihfdG86IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBfdG8gLSB0aGlzLmdldCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogKFJlLSkgU2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoaXMgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSBfdGltZSBUaGUgdGltZXN0YW1wIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCB0aW1lIChkZWZhdWx0IDAuMClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldChfdGltZTogbnVtYmVyID0gMCk6IHZvaWQge1xyXG4gICAgICB0aGlzLm9mZnNldCA9IF90aW1lO1xyXG4gICAgICB0aGlzLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIHRoaXMuZ2V0RWxhcHNlZFNpbmNlUHJldmlvdXNDYWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzY2FsaW5nIG9mIHRoaXMgdGltZSwgYWxsb3dpbmcgZm9yIHNsb3dtb3Rpb24gKDwxKSBvciBmYXN0Zm9yd2FyZCAoPjEpIFxyXG4gICAgICogQHBhcmFtIF9zY2FsZSBUaGUgZGVzaXJlZCBzY2FsaW5nIChkZWZhdWx0IDEuMClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNjYWxlKF9zY2FsZTogbnVtYmVyID0gMS4wKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0KHRoaXMuZ2V0KCkpO1xyXG4gICAgICB0aGlzLnNjYWxlID0gX3NjYWxlO1xyXG4gICAgICAvL1RPRE86IGNhdGNoIHNjYWxlPTBcclxuICAgICAgdGhpcy5yZXNjYWxlQWxsVGltZXJzKCk7XHJcbiAgICAgIHRoaXMuZ2V0RWxhcHNlZFNpbmNlUHJldmlvdXNDYWxsKCk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuVElNRV9TQ0FMRUQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBzY2FsaW5nIG9mIHRoaXMgdGltZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U2NhbGUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG9mZnNldCBvZiB0aGlzIHRpbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE9mZnNldCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHNjYWxlZCB0aW1lIGluIG1pbGxpc2Vjb25kcyBwYXNzZWQgc2luY2UgdGhlIGxhc3QgY2FsbCB0byB0aGlzIG1ldGhvZFxyXG4gICAgICogQXV0b21hdGljYWxseSByZXNldCBhdCBldmVyeSBjYWxsIHRvIHNldCguLi4pIGFuZCBzZXRTY2FsZSguLi4pXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRFbGFwc2VkU2luY2VQcmV2aW91c0NhbGwoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IGN1cnJlbnQ6IG51bWJlciA9IHRoaXMuZ2V0KCk7XHJcbiAgICAgIGxldCBlbGFwc2VkOiBudW1iZXIgPSBjdXJyZW50IC0gdGhpcy5sYXN0Q2FsbFRvRWxhcHNlZDtcclxuICAgICAgdGhpcy5sYXN0Q2FsbFRvRWxhcHNlZCA9IGN1cnJlbnQ7XHJcbiAgICAgIHJldHVybiBlbGFwc2VkO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUaW1lcnNcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIFByb21pc2U8dm9pZD4gdG8gYmUgcmVzb2x2ZWQgYWZ0ZXIgdGhlIHRpbWUgZ2l2ZW4uIFRvIGJlIHVzZWQgd2l0aCBhc3luYy9hd2FpdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVsYXkoX2xhcHNlOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKF9yZXNvbHZlID0+IHRoaXMuc2V0VGltZXIoX2xhcHNlLCAxLCAoKSA9PiBfcmVzb2x2ZSgpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogZXhhbWluZSBpZiB3ZWItd29ya2VycyB3b3VsZCBlbmhhbmNlIHBlcmZvcm1hbmNlIGhlcmUhXHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIGFuZCBkZWxldGVzIGFsbCB7QGxpbmsgVGltZXJ9cyBhdHRhY2hlZC4gU2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgdGhpcyBUaW1lLW9iamVjdCBsZWF2ZXMgc2NvcGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNsZWFyQWxsVGltZXJzKCk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnRpbWVycykge1xyXG4gICAgICAgIHRoaXMuZGVsZXRlVGltZXIoTnVtYmVyKGlkKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMge0BsaW5rIFRpbWVyfSBmb3VuZCB1c2luZyB0aGUgaW50ZXJuYWwgaWQgb2YgdGhlIGNvbm5lY3RlZCBpbnRlcnZhbC1vYmplY3RcclxuICAgICAqIEBwYXJhbSBfaWQgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWxldGVUaW1lckJ5SXRzSW50ZXJuYWxJZChfaWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnRpbWVycykge1xyXG4gICAgICAgIGxldCB0aW1lcjogVGltZXIgPSB0aGlzLnRpbWVyc1tpZF07XHJcbiAgICAgICAgaWYgKHRpbWVyLmlkID09IF9pZCkge1xyXG4gICAgICAgICAgdGltZXIuY2xlYXIoKTtcclxuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRpbWVyc1tpZF07XHJcbiAgICAgICAgICAvLyBUT0RPOiBjaGVjayBpZiBhbiBlYXJseSBvdXQgaXMgT0sgaGVyZS4uLiBzaG91bGQgYmUhXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YWxscyBhIHRpbWVyIGF0IHRoaXMgdGltZSBvYmplY3RcclxuICAgICAqIEBwYXJhbSBfbGFwc2UgVGhlIG9iamVjdC10aW1lIHRvIGVsYXBzZSBiZXR3ZWVuIHRoZSBjYWxscyB0byBfY2FsbGJhY2tcclxuICAgICAqIEBwYXJhbSBfY291bnQgVGhlIG51bWJlciBvZiBjYWxscyBkZXNpcmVkLCAwID0gSW5maW5pdGVcclxuICAgICAqIEBwYXJhbSBfaGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gY2FsbCBlYWNoIHRoZSBnaXZlbiBsYXBzZSBoYXMgZWxhcHNlZFxyXG4gICAgICogQHBhcmFtIF9hcmd1bWVudHMgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gY2FsbGJhY2sgZnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFRpbWVyKF9sYXBzZTogbnVtYmVyLCBfY291bnQ6IG51bWJlciwgX2hhbmRsZXI6IFRpbWVySGFuZGxlciwgLi4uX2FyZ3VtZW50czogT2JqZWN0W10pOiBudW1iZXIge1xyXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLXVudXNlZC1leHByZXNzaW9uXHJcbiAgICAgIG5ldyBUaW1lcih0aGlzLCBfbGFwc2UsIF9jb3VudCwgX2hhbmRsZXIsIC4uLl9hcmd1bWVudHMpO1xyXG4gICAgICAvL3RoaXMuYWRkVGltZXIodGltZXIpO1xyXG4gICAgICByZXR1cm4gdGhpcy5pZFRpbWVyQWRkZWRMYXN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGludGVybmFsbHkgYnkge0BsaW5rIFRpbWV9IGFuZCB7QGxpbmsgVGltZXJ9IGFuZCBtdXN0IG5vdCBiZSBjYWxsZWQgb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRUaW1lcihfdGltZXI6IFRpbWVyKTogbnVtYmVyIHtcclxuICAgICAgdGhpcy50aW1lcnNbKyt0aGlzLmlkVGltZXJBZGRlZExhc3RdID0gX3RpbWVyO1xyXG4gICAgICByZXR1cm4gdGhpcy5pZFRpbWVyQWRkZWRMYXN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgdGltZXIgd2l0aCB0aGUgaWQgZ2l2ZW4gYnkgdGhpcyB0aW1lIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVsZXRlVGltZXIoX2lkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IHRpbWVyOiBUaW1lciA9IHRoaXMudGltZXJzW19pZF07XHJcbiAgICAgIGlmICghdGltZXIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB0aW1lci5jbGVhcigpO1xyXG4gICAgICBkZWxldGUgdGhpcy50aW1lcnNbX2lkXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHRpbWVyIHdpdGggdGhlIGdpdmVuIGlkIG9yIG51bGwgaWYgbm90IGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VGltZXIoX2lkOiBudW1iZXIpOiBUaW1lciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWVyc1tfaWRdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGxpc3Qgb2YgdGltZXJzIGN1cnJlbnRseSBpbnN0YWxsZWQgb24gdGhpcyB0aW1lIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VGltZXJzKCk6IFRpbWVycyB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFRpbWVycyA9IHt9O1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHRoaXMudGltZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUge0BsaW5rIFRpbWVyc30gaW5zdGFsbGVkIHRvIHRoaXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGhhc1RpbWVycygpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIChPYmplY3Qua2V5cyh0aGlzLnRpbWVycykubGVuZ3RoID4gMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNyZWF0ZXMge0BsaW5rIFRpbWVyfXMgd2hlbiBzY2FsaW5nIGNoYW5nZXNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZXNjYWxlQWxsVGltZXJzKCk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnRpbWVycykge1xyXG4gICAgICAgIGxldCB0aW1lcjogVGltZXIgPSB0aGlzLnRpbWVyc1tpZF07XHJcbiAgICAgICAgdGltZXIuY2xlYXIoKTtcclxuICAgICAgICBkZWxldGUgdGhpcy50aW1lcnNbaWRdO1xyXG4gICAgICAgIGlmICghdGhpcy5zY2FsZSlcclxuICAgICAgICAgIC8vIFRpbWUgaGFzIHN0b3BwZWQsIG5vIG5lZWQgdG8gcmVwbGFjZSBjbGVhcmVkIHRpbWVyc1xyXG4gICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgIC8qIHRoaXMudGltZXJzW2lkXSA9ICAqL1xyXG4gICAgICAgIHRpbWVyID0gdGltZXIuaW5zdGFsbENvcHkoKTsgLy8gdGhlIHRpbWVyIGlzIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhpcyB0aW1lIGluc3RhbmNlXHJcbiAgICAgICAgZGVsZXRlIHRoaXMudGltZXJzW3RoaXMuaWRUaW1lckFkZGVkTGFzdF07IC8vIHJlbW92ZSB0aGUgY29weSBhZ2FpbiAuLi5cclxuICAgICAgICB0aGlzLnRpbWVyc1tpZF0gPSB0aW1lcjsgLy8gLi4uIGFuZCBwbGFjZSBpdCBhdCB0aGUgaWQgb2YgdGhlIG9yaWdpbmFsXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgLy8jZW5kcmVnaW9uXHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBEZWZpbmVzIHRoZSBzaWduYXR1cmUgb2YgaGFuZGxlciBmdW5jdGlvbnMgZm9yIHtAbGluayBFdmVudFRpbWVyfXMsIHZlcnkgc2ltaWxhciB0byB1c3VhbCBldmVudCBoYW5kbGVyXHJcbiAgICovXHJcbiAgZXhwb3J0IHR5cGUgVGltZXJIYW5kbGVyID0gKF9ldmVudDogRXZlbnRUaW1lcikgPT4gdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogQSB7QGxpbmsgVGltZXJ9LWluc3RhbmNlIGludGVybmFsbHkgdXNlcyB3aW5kb3cuc2V0SW50ZXJ2YWwgdG8gY2FsbCBhIGdpdmVuIGhhbmRsZXIgd2l0aCBhIGdpdmVuIGZyZXF1ZW5jeSBhIGdpdmVuIG51bWJlciBvZiB0aW1lcyxcclxuICAgKiBwYXNzaW5nIGFuIHtAbGluayBFdmVudFRpbWVyfS1pbnN0YW5jZSB3aXRoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYW5kIGdpdmVuIGFyZ3VtZW50cy4gXHJcbiAgICogVGhlIGZyZXF1ZW5jeSBzY2FsZXMgd2l0aCB0aGUge0BsaW5rIFRpbWV9LWluc3RhbmNlIHRoZSB7QGxpbmsgVGltZXJ9LWluc3RhbmNlIGlzIGF0dGFjaGVkIHRvLlxyXG4gICAqIFxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVGltZXIge1xyXG4gICAgcHVibGljIGFjdGl2ZTogYm9vbGVhbjtcclxuICAgIHB1YmxpYyBjb3VudDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBoYW5kbGVyOiBUaW1lckhhbmRsZXI7XHJcbiAgICBwcml2YXRlIHRpbWU6IFRpbWU7XHJcbiAgICBwcml2YXRlIGVsYXBzZTogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBldmVudDogRXZlbnRUaW1lcjtcclxuICAgIHByaXZhdGUgdGltZW91dFJlYWw6IG51bWJlcjtcclxuICAgIHByaXZhdGUgaWRXaW5kb3c6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSB7QGxpbmsgVGltZXJ9IGluc3RhbmNlLlxyXG4gICAgICogQHBhcmFtIF90aW1lIFRoZSB7QGxpbmsgVGltZX0gaW5zdGFuY2UsIHRoZSB0aW1lciBhdHRhY2hlcyB0b1xyXG4gICAgICogQHBhcmFtIF9lbGFwc2UgVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIGVsYXBzZSwgdG8gdGhlIG5leHQgY2FsbCBvZiBfaGFuZGxlciwgbWVhc3VyZWQgaW4gX3RpbWVcclxuICAgICAqIEBwYXJhbSBfY291bnQgVGhlIGRlc2lyZWQgbnVtYmVyIG9mIGNhbGxzIHRvIF9oYW5kbGVyLCBUaW1lciBkZWluc3RhbGxzIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgbGFzdCBjYWxsLiBQYXNzaW5nIDAgaW52b2tlcyBpbmZpbml0ZSBjYWxsc1xyXG4gICAgICogQHBhcmFtIF9oYW5kbGVyIFRoZSB7QGxpbmsgVGltZXJIYW5kbGVyfSBpbnN0YW5jZSB0byBjYWxsXHJcbiAgICAgKiBAcGFyYW0gX2FyZ3VtZW50cyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIHRvIF9oYW5kbGVyXHJcbiAgICAgKiBcclxuICAgICAqIFRPRE86IGZvciBwcm9wZXIgaGFuZGxpbmcgYW5kIGRlbGV0aW9uLCB1c2UgVGltZS5zZXRUaW1lciBpbnN0ZWFkIG9mIGluc3RhbnRpYXRpbmcgdGltZXJzIHlvdXJzZWxmLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3RpbWU6IFRpbWUsIF9lbGFwc2U6IG51bWJlciwgX2NvdW50OiBudW1iZXIsIF9oYW5kbGVyOiBUaW1lckhhbmRsZXIsIC4uLl9hcmd1bWVudHM6IE9iamVjdFtdKSB7XHJcbiAgICAgIHRoaXMudGltZSA9IF90aW1lO1xyXG4gICAgICB0aGlzLmVsYXBzZSA9IF9lbGFwc2U7XHJcbiAgICAgIHRoaXMuZXZlbnQgPSBuZXcgRXZlbnRUaW1lcih0aGlzLCAuLi5fYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy5oYW5kbGVyID0gX2hhbmRsZXI7XHJcbiAgICAgIHRoaXMuY291bnQgPSBfY291bnQ7XHJcblxyXG4gICAgICBsZXQgc2NhbGU6IG51bWJlciA9IE1hdGguYWJzKF90aW1lLmdldFNjYWxlKCkpO1xyXG5cclxuICAgICAgaWYgKCFzY2FsZSkge1xyXG4gICAgICAgIC8vIFRpbWUgaXMgc3RvcHBlZCwgdGltZXIgd29uJ3QgYmUgYWN0aXZlXHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMudGltZW91dFJlYWwgPSB0aGlzLmVsYXBzZSAvIHNjYWxlO1xyXG5cclxuICAgICAgbGV0IGNhbGxiYWNrOiBGdW5jdGlvbiA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLmV2ZW50LmNvdW50ID0gdGhpcy5jb3VudDtcclxuICAgICAgICB0aGlzLmV2ZW50Lmxhc3RDYWxsID0gKHRoaXMuY291bnQgPT0gMSk7XHJcbiAgICAgICAgX2hhbmRsZXIodGhpcy5ldmVudCk7XHJcbiAgICAgICAgdGhpcy5ldmVudC5maXJzdENhbGwgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPiAwKVxyXG4gICAgICAgICAgaWYgKC0tdGhpcy5jb3VudCA9PSAwKVxyXG4gICAgICAgICAgICBfdGltZS5kZWxldGVUaW1lckJ5SXRzSW50ZXJuYWxJZCh0aGlzLmlkV2luZG93KTtcclxuXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmlkV2luZG93ID0gd2luZG93LnNldEludGVydmFsKGNhbGxiYWNrLCB0aGlzLnRpbWVvdXRSZWFsLCAuLi5fYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICBfdGltZS5hZGRUaW1lcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHdpbmRvdy1pZCBvZiB0aGUgdGltZXIsIHdoaWNoIHdhcyByZXR1cm5lZCBieSBzZXRJbnRlcnZhbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGlkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmlkV2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdGltZS1pbnRlcnZhbGwgZm9yIGNhbGxzIHRvIHRoZSBoYW5kbGVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbGFwc2UoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWxhcHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNoZXMgYSBjb3B5IG9mIHRoaXMgYXQgaXRzIGN1cnJlbnQgc3RhdGUgdG8gdGhlIHNhbWUge0BsaW5rIFRpbWV9LWluc3RhbmNlLiBVc2VkIGludGVybmFsbHkgd2hlbiByZXNjYWxpbmcge0BsaW5rIFRpbWV9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnN0YWxsQ29weSgpOiBUaW1lciB7XHJcbiAgICAgIHJldHVybiBuZXcgVGltZXIodGhpcy50aW1lLCB0aGlzLmVsYXBzZSwgdGhpcy5jb3VudCwgdGhpcy5oYW5kbGVyLCB0aGlzLmV2ZW50LmFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIHRpbWVyLCByZW1vdmluZyBpdCBmcm9tIHRoZSBpbnRlcnZhbC10aW1lcnMgaGFuZGxlZCBieSB3aW5kb3dcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICAvLyBpZiAodGhpcy50eXBlID09IFRJTUVSX1RZUEUuVElNRU9VVCkge1xyXG4gICAgICAvLyAgICAgaWYgKHRoaXMuYWN0aXZlKVxyXG4gICAgICAvLyAgICAgICAgIC8vIHNhdmUgcmVtYWluaW5nIHRpbWUgdG8gdGltZW91dCBhcyBuZXcgdGltZW91dCBmb3IgcmVzdGFydFxyXG4gICAgICAvLyAgICAgICAgIHRoaXMudGltZW91dCA9IHRoaXMudGltZW91dCAqICgxIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5zdGFydFRpbWVSZWFsKSAvIHRoaXMudGltZW91dFJlYWwpO1xyXG4gICAgICAvLyAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmlkKTtcclxuICAgICAgLy8gfVxyXG4gICAgICAvLyBlbHNlXHJcbiAgICAgIC8vIFRPRE86IHJldXNpbmcgdGltZXIgc3RhcnRzIGludGVydmFsIGFuZXcuIFNob3VsZCBiZSByZW1haW5pbmcgaW50ZXJ2YWwgYXMgdGltZW91dCwgdGhlbiBzdGFydGluZyBpbnRlcnZhbCBhbmV3IFxyXG4gICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmlkV2luZG93KTtcclxuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbn0iXX0=