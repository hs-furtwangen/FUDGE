"use strict";
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var FudgeCore;
(function (FudgeCore) {
    class PerformanceMonitor {
        static {
            window.addEventListener("load", () => PerformanceMonitor.display = document.body.appendChild(new PerformanceDisplay()));
        }
        static { this.measurements = {}; }
        static { this.framesToAverage = 60; }
        static startMeasure(_label) {
            if (!this.measurements[_label]) {
                this.measurements[_label] = {
                    frameTimeMin: Number.MAX_VALUE,
                    frameTimeMax: -Number.MAX_VALUE,
                    frameTimeAvg: 0,
                    callsPerFrame: 0,
                    time: 0,
                    calls: 0
                };
            }
            this.measurements[_label].start = performance.now();
        }
        static endMeasure(_label) {
            const measurement = this.measurements[_label];
            if (!measurement?.start)
                return 0;
            const duration = performance.now() - measurement.start;
            measurement.time += duration;
            measurement.calls++;
            return duration;
        }
        static startFrame() {
            PerformanceMonitor.startMeasure("Frame");
            for (const label in this.measurements) {
                this.measurements[label].time = 0;
                this.measurements[label].calls = 0;
            }
        }
        static endFrame() {
            PerformanceMonitor.endMeasure("Frame");
            for (const label in this.measurements) {
                const measurement = this.measurements[label];
                if (measurement.calls > 0) {
                    const frameTotal = measurement.time;
                    measurement.frameTimeMin = Math.min(measurement.frameTimeMin, frameTotal);
                    measurement.frameTimeMax = Math.max(measurement.frameTimeMax, frameTotal);
                    measurement.frameTimeAvg = ((this.framesToAverage - 1) * measurement.frameTimeAvg + frameTotal) / this.framesToAverage;
                    measurement.callsPerFrame = measurement.calls;
                }
            }
            let longestString = Object.keys(PerformanceMonitor.measurements).reduce((_a, _b) => _a.length > _b.length ? _a : _b).length;
            let text = `${"Performance Monitor".padEnd(longestString)} |  time  |  calls\n`;
            for (let key in PerformanceMonitor.measurements) {
                let measurement = PerformanceMonitor.measurements[key];
                let avg = measurement.frameTimeAvg.toFixed(2).padStart(4);
                let calls = measurement.callsPerFrame.toString().padStart(3);
                text += `${key.padEnd(longestString)} | ${avg}ms | ${calls}cpf\n`;
            }
            this.display.textContent = text;
        }
    }
    FudgeCore.PerformanceMonitor = PerformanceMonitor;
    class PerformanceDisplay extends HTMLPreElement {
        constructor() {
            super();
            this.style.cssText = `
      font-family: Consolas, "Courier New", monospace;
      font-weight: bold;
      color: yellow;
      text-shadow: -1px -1px 0 black, 1px -1px 0 black, -1px 1px 0 black, 1px 1px 0 black;
      padding: 0.2rem;
      margin: 0;
      background: rgba(0, 0, 0, 0.7);
      width: min-content;
      position: absolute;
      left: 0;
      top: 0;
      z-index: 1000;
      pointer-events: none;`;
        }
    }
    FudgeCore.PerformanceDisplay = PerformanceDisplay;
    customElements.define("ui-performance", PerformanceDisplay, { extends: "pre" });
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for the different DebugTargets, mainly for technical purpose of inheritance
     */
    class DebugTarget {
        /**
         * Merge the given message and arguments into a single string, separated by ', '
         */
        static mergeArguments(_message, ..._args) {
            let out = _message.toString(); //JSON.stringify(_message);
            for (let arg of _args)
                if (arg instanceof Number)
                    out += ", " + arg.toPrecision(2).toString(); //JSON.stringify(arg, null, 2);
                else
                    out += ", " + arg.toString(); //JSON.stringify(arg, null, 2);
            return out;
        }
    }
    FudgeCore.DebugTarget = DebugTarget;
})(FudgeCore || (FudgeCore = {}));
// <reference path="DebugAlert.ts"/>
var FudgeCore;
// <reference path="DebugAlert.ts"/>
(function (FudgeCore) {
    /**
     * The filters corresponding to debug activities, more to come
     */
    let DEBUG_FILTER;
    (function (DEBUG_FILTER) {
        DEBUG_FILTER[DEBUG_FILTER["NONE"] = 0] = "NONE";
        DEBUG_FILTER[DEBUG_FILTER["INFO"] = 1] = "INFO";
        DEBUG_FILTER[DEBUG_FILTER["LOG"] = 2] = "LOG";
        DEBUG_FILTER[DEBUG_FILTER["WARN"] = 4] = "WARN";
        DEBUG_FILTER[DEBUG_FILTER["ERROR"] = 8] = "ERROR";
        DEBUG_FILTER[DEBUG_FILTER["FUDGE"] = 16] = "FUDGE";
        DEBUG_FILTER[DEBUG_FILTER["CLEAR"] = 256] = "CLEAR";
        DEBUG_FILTER[DEBUG_FILTER["GROUP"] = 257] = "GROUP";
        DEBUG_FILTER[DEBUG_FILTER["GROUPCOLLAPSED"] = 258] = "GROUPCOLLAPSED";
        DEBUG_FILTER[DEBUG_FILTER["GROUPEND"] = 260] = "GROUPEND";
        DEBUG_FILTER[DEBUG_FILTER["SOURCE"] = 512] = "SOURCE";
        DEBUG_FILTER[DEBUG_FILTER["MESSAGES"] = 31] = "MESSAGES";
        DEBUG_FILTER[DEBUG_FILTER["FORMAT"] = 263] = "FORMAT";
        DEBUG_FILTER[DEBUG_FILTER["ALL"] = 287] = "ALL";
    })(DEBUG_FILTER = FudgeCore.DEBUG_FILTER || (FudgeCore.DEBUG_FILTER = {}));
    FudgeCore.DEBUG_SYMBOL = {
        [DEBUG_FILTER.INFO]: "‚úì",
        [DEBUG_FILTER.LOG]: "‚úé",
        [DEBUG_FILTER.WARN]: "‚ö†",
        [DEBUG_FILTER.ERROR]: "‚ùå",
        [DEBUG_FILTER.FUDGE]: "üé≤",
        [DEBUG_FILTER.SOURCE]: "üîó"
    };
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the standard-console
     */
    class DebugConsole extends FudgeCore.DebugTarget {
        static { this.delegates = {
            [FudgeCore.DEBUG_FILTER.INFO]: console.info,
            [FudgeCore.DEBUG_FILTER.LOG]: console.log,
            [FudgeCore.DEBUG_FILTER.WARN]: console.warn,
            [FudgeCore.DEBUG_FILTER.ERROR]: console.error,
            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugConsole.fudge,
            [FudgeCore.DEBUG_FILTER.CLEAR]: console.clear,
            [FudgeCore.DEBUG_FILTER.GROUP]: console.group,
            [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: console.groupCollapsed,
            [FudgeCore.DEBUG_FILTER.GROUPEND]: console.groupEnd,
            [FudgeCore.DEBUG_FILTER.SOURCE]: DebugConsole.source
        }; }
        /**
         * Should be used to display uncritical state information of FUDGE, only visible in browser's verbose mode
         */
        static fudge(_message, ..._args) {
            console.debug(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE], _message, ..._args);
        }
        /**
         * Displays an extra line with information about the source of the debug message
         */
        static source(_message, ..._args) {
            console.log(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE], _message, ..._args);
        }
    }
    FudgeCore.DebugConsole = DebugConsole;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
/// <reference path="DebugInterfaces.ts"/>
/// <reference path="DebugConsole.ts"/>
(function (FudgeCore) {
    /**
     * The Debug-Class offers functions known from the console-object and additions,
     * routing the information to various {@link DebugTarget}s that can be easily defined by the developers and registerd by users
     * Override functions in subclasses of {@link DebugTarget} and register them as their delegates
     */
    class Debug {
        /**
         * For each set filter, this associative array keeps references to the registered delegate functions of the chosen {@link DebugTarget}s
         */
        static { this.delegates = Debug.setupConsole(); }
        /**
         * De- / Activate a filter for the given DebugTarget.
         */
        static setFilter(_target, _filter) {
            for (let filter in Debug.delegates)
                Debug.delegates[filter].delete(_target);
            for (let filter in FudgeCore.DEBUG_FILTER) {
                let parsed = parseInt(filter);
                if (isNaN(parsed))
                    break;
                if ([FudgeCore.DEBUG_FILTER.MESSAGES, FudgeCore.DEBUG_FILTER.FORMAT, FudgeCore.DEBUG_FILTER.ALL].indexOf(parsed) != -1)
                    // dont delegate combos... 
                    continue;
                if (_filter & parsed)
                    Debug.delegates[parsed].set(_target, _target.delegates[parsed]);
            }
        }
        /**
         * Get the filter(s) for the given DebugTarget.
         */
        static getFilter(_target) {
            let result = 0;
            for (let filter in _target.delegates)
                result |= parseInt(filter);
            return result;
        }
        /**
         * Add a filter to the given DebugTarget.
         */
        static addFilter(_target, _filter) {
            let current = Debug.getFilter(_target);
            Debug.setFilter(_target, current | _filter);
        }
        /**
         * Remove a filter from the given DebugTarget.
         */
        static removeFilter(_target, _filter) {
            let current = Debug.getFilter(_target);
            Debug.setFilter(_target, current ^ _filter);
        }
        /**
         * Info(...) displays additional information with low priority
         */
        static info(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.INFO, _message, _args);
        }
        /**
         * Displays information with medium priority
         */
        static log(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.LOG, _message, _args);
        }
        /**
         * Displays information about non-conformities in usage, which is emphasized e.g. by color
         */
        static warn(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.WARN, _message, _args);
        }
        /**
         * Displays critical information about failures, which is emphasized e.g. by color
         */
        static error(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.ERROR, _message, _args);
        }
        /**
         * Displays messages from FUDGE
         */
        static fudge(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.FUDGE, _message, _args);
        }
        /**
         * Clears the output and removes previous messages if possible
         */
        static clear() {
            Debug.delegate(FudgeCore.DEBUG_FILTER.CLEAR, null, null);
        }
        /**
         * Opens a new group for messages
         */
        static group(_name) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUP, _name, null);
        }
        /**
         * Opens a new group for messages that is collapsed at first
         */
        static groupCollapsed(_name) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, _name, null);
        }
        /**
         * Closes the youngest group
         */
        static groupEnd() {
            Debug.delegate(FudgeCore.DEBUG_FILTER.GROUPEND, null, null);
        }
        /**
         * Log a branch of the node hierarchy
         */
        static branch(_branch) {
            if (_branch.nChildren > 0)
                Debug.group(_branch.name);
            else
                Debug.fudge(_branch.name);
            for (let child of _branch.getChildren())
                Debug.branch(child);
            if (_branch.nChildren > 0)
                Debug.groupEnd();
        }
        /**
         * Displays messages about the source of the debug call
         */
        static source(_message, ..._args) {
            Debug.delegate(FudgeCore.DEBUG_FILTER.SOURCE, _message, _args);
        }
        /**
         * Lookup all delegates registered to the filter and call them using the given arguments
         */
        static delegate(_filter, _message, _args) {
            if (_filter == FudgeCore.DEBUG_FILTER.LOG || _filter == FudgeCore.DEBUG_FILTER.WARN || _filter == FudgeCore.DEBUG_FILTER.ERROR) {
                if (Debug.delegates[FudgeCore.DEBUG_FILTER.SOURCE])
                    for (let delegate of Debug.delegates[FudgeCore.DEBUG_FILTER.SOURCE].values())
                        if (delegate) {
                            let trace = new Error("Test").stack.split("\n");
                            delegate(trace[3]);
                        }
            }
            let delegates = Debug.delegates[_filter];
            for (let delegate of delegates.values())
                if (delegate)
                    if (_args && _args.length > 0)
                        delegate(_message, ..._args);
                    else
                        delegate(_message);
        }
        /**
         * setup routing to standard console
         */
        static setupConsole() {
            let result = {};
            let filters = [
                FudgeCore.DEBUG_FILTER.INFO, FudgeCore.DEBUG_FILTER.LOG, FudgeCore.DEBUG_FILTER.WARN, FudgeCore.DEBUG_FILTER.ERROR, FudgeCore.DEBUG_FILTER.FUDGE,
                FudgeCore.DEBUG_FILTER.CLEAR, FudgeCore.DEBUG_FILTER.GROUP, FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED, FudgeCore.DEBUG_FILTER.GROUPEND,
                FudgeCore.DEBUG_FILTER.SOURCE
            ];
            for (let filter of filters)
                result[filter] = new Map([[FudgeCore.DebugConsole, FudgeCore.DebugConsole.delegates[filter]]]);
            result[FudgeCore.DEBUG_FILTER.SOURCE].delete(FudgeCore.DebugConsole);
            return result;
        }
    }
    FudgeCore.Debug = Debug;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Extends EventTarget to work with {@link EventListenerUnified} and {@link EventUnified} */
    class EventTargetUnified extends EventTarget {
        /**
         * See {@link EventTarget.addEventListener} for reference. Works with {@link EventListenerUnified} and {@link EventUnified}
         */
        addEventListener(_type, _handler, _options) {
            super.addEventListener(_type, _handler, _options);
        }
        /**
         * See {@link EventTarget.removeEventListener} for reference. Works with {@link EventListenerUnified} and {@link EventUnified}
         */
        removeEventListener(_type, _handler, _options) {
            super.removeEventListener(_type, _handler, _options);
        }
        /**
         * See {@link EventTarget.dispatchEvent} for reference. Works with with {@link EventUnified}
         */
        dispatchEvent(_event) {
            return super.dispatchEvent(_event);
        }
    }
    FudgeCore.EventTargetUnified = EventTargetUnified;
    /**
     * Base class for EventTarget singletons, which are fixed entities in the structure of FUDGE, such as the core loop
     */
    class EventTargetStatic extends EventTargetUnified {
        static { this.targetStatic = new EventTargetStatic(); }
        constructor() {
            super();
        }
        /**
         * Add an event listener to {@link targetStatic}.
         */
        static addEventListener(_type, _handler, _options) {
            EventTargetStatic.targetStatic.addEventListener(_type, _handler);
        }
        /**
         * Remove an event listener from {@link targetStatic}.
         */
        static removeEventListener(_type, _handler, _options) {
            EventTargetStatic.targetStatic.removeEventListener(_type, _handler);
        }
        /**
         * Dispatch an event on {@link targetStatic}.
         */
        static dispatchEvent(_event) {
            EventTargetStatic.targetStatic.dispatchEvent(_event);
            return true;
        }
    }
    FudgeCore.EventTargetStatic = EventTargetStatic;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A subclass of {@link Event} that can be (re)used via {@link RecyclableEvent.get} and {@link RecyclableEvent.store} to avoid garbage collection.
     * If dispatched repeatedly without recycling through get/store, call {@link recycle} manually before each dispatch.
     * Exposes some readonly properties of the event class as writable properties for the event system.
     *
     * **Example get/store**:
     * ```typescript
     * import f = FudgeCore;
     * const node: f.Node = new f.Node("Node");
     * const event: f.RecyclableEvent = f.RecyclableEvent.get("myevent", true); // get event from depot
     * node.dispatchEvent(event);
     * f.RecyclableEvent.store(event); // store event in depot for reuse
     * ```
     *
     * **Example manual recycle**:
     * ```typescript
     * import f = FudgeCore;
     * const node: f.Node = new f.Node("Node");
     * const event: f.RecyclableEvent = f.RecyclableEvent.get("myevent", true); // get event and cache it
     *
     * // called repeatedly, e.g. in a loop
     * function update(): void {
     *   node.dispatchEvent(event.recycle()); // recycle the event before each dispatch
     * }
     * ```
     * @author Jonas Plotzky, HFU, 2025
     */
    class RecyclableEvent extends Event {
        static #depot = {};
        static #init = {};
        #target;
        #currentTarget;
        #eventPhase;
        constructor(_type, _bubbles = false, _cancelable = false) {
            RecyclableEvent.#init.bubbles = _bubbles;
            RecyclableEvent.#init.cancelable = _cancelable;
            super(_type, RecyclableEvent.#init);
            this.path = []; // for now use array, if constant resizing becomes a mermory problem find a better solution
        }
        /**
         * Fetches an event of the requested type and initialization from the depot. If the depot for the requested type is empty it returns a new instance.
         * Use {@link RecyclableEvent.store} after dispatching the event to store it for reuse.
         */
        static get(_type, _bubbles = false, _cancelable = false) {
            return RecyclableEvent.#depot[`${_type}${_bubbles}${_cancelable}`]?.pop()?.recycle() ?? new RecyclableEvent(_type, _bubbles, _cancelable);
        }
        /**
         * Stores the event in the depot for later reuse.
         */
        static store(_event) {
            (RecyclableEvent.#depot[`${_event.type}${_event.bubbles}${_event.cancelable}`] ??= new FudgeCore.RecycableArray()).push(_event);
        }
        /**
         * Emptys the depot of a given type, leaving the events for the garbage collector.
         */
        static dump(_type, _bubbles = false, _cancelable = false) {
            delete RecyclableEvent.#depot[`${_type}${_bubbles}${_cancelable}`];
        }
        /**
         * Emptys all depots, leaving all events to the garbage collector.
         */
        static dumpAll() {
            RecyclableEvent.#depot = {};
        }
        static [Symbol.hasInstance](_instance) {
            return _instance.isRecyclableEvent;
        }
        /**
         * Flag for fast type checking.
         */
        get isRecyclableEvent() {
            return true;
        }
        get target() {
            return this.#target ?? super.target;
        }
        get currentTarget() {
            return this.#currentTarget ?? super.currentTarget;
        }
        get eventPhase() {
            return this.#eventPhase ?? super.eventPhase;
        }
        /**
         * Set the target of the event. Used by the event system.
         * @returns A reference to this event.
         */
        setTarget(_target) {
            this.#target = _target;
            return this;
        }
        /**
         * Set the current target of the event. Used by the event system.
         * @returns A reference to this event.
         */
        setCurrentTarget(_currentTarget) {
            this.#currentTarget = _currentTarget;
            return this;
        }
        /**
         * Set the event phase of the event. Used by the event system.
         * @returns A reference to this event.
         */
        setEventPhase(_eventPhase) {
            this.#eventPhase = _eventPhase;
            return this;
        }
        /**
         * Reset the event to default values. Used by the event system.
         * @returns A reference to this event.
         */
        recycle() {
            this.#target = null;
            this.#currentTarget = null;
            this.#eventPhase = null;
            this.path.length = 0;
            return this;
        }
    }
    FudgeCore.RecyclableEvent = RecyclableEvent;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // export interface MutatorForComponent extends Mutator { readonly forUserComponent: null; }
    /**
     * Collect applicable attributes of the instance and copies of their values in a Mutator-object
     */
    function getMutatorOfArbitrary(_object) {
        let mutator = {};
        let attributes = Reflect.ownKeys(Reflect.getPrototypeOf(_object));
        for (let attribute of attributes) {
            let value = Reflect.get(_object, attribute);
            if (value instanceof Function)
                continue;
            // if (value instanceof Object && !(value instanceof Mutable))
            //   continue;
            mutator[attribute.toString()] = value;
        }
        return mutator;
    }
    FudgeCore.getMutatorOfArbitrary = getMutatorOfArbitrary;
    // @ts-ignore - as of now we need to polyfill the symbol to make decorator metadata work, see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html#decorator-metadata
    Symbol.metadata ??= Symbol("Symbol.metadata");
    function type(_constructor) {
        return (_value, _context) => {
            let meta = _context.metadata;
            if (!Object.hasOwn(meta, "attributeTypes"))
                meta.attributeTypes = { ...meta.attributeTypes };
            meta.attributeTypes[_context.name] = _constructor;
        };
    }
    FudgeCore.type = type;
    function enumerate(_value, _context) {
        // _context.addInitializer(function (this: unknown) { // this is run per instance... ideally we would want to run this once per class
        //   const prototype: unknown = Object.getPrototypeOf(this);
        //   const descriptor: PropertyDescriptor = Object.getOwnPropertyDescriptor(prototype, _context.name);
        //   if (descriptor && descriptor.enumerable == false)
        //     Object.defineProperty(prototype, _context.name, { enumerable: true });
        // });
        let metadata = _context.metadata;
        if (_context.kind == "getter" || _context.kind == "accessor") {
            if (typeof _context.name != "string")
                return;
            if (!Object.hasOwn(metadata, "enumerateKeys"))
                metadata.enumerateKeys = [];
            metadata.enumerateKeys.push(_context.name);
            return;
        }
        if (_context.kind == "class") {
            if (metadata.enumerateKeys) {
                const descriptor = { enumerable: true };
                for (const key of metadata.enumerateKeys)
                    Object.defineProperty(_value.prototype, key, descriptor);
            }
            return;
        }
    }
    FudgeCore.enumerate = enumerate;
    /**
     * Base class for all types that are mutable using {@link Mutator}-objects, thus providing and using interfaces created at runtime.
     *
     * Mutables provide a {@link Mutator} built by collecting all their applicable enumerable properties. By default, this includes only primitive types and nested mutable objects.
     * Using the {@link type}-decorator can also include non-mutable objects, which will be displayed via their {@link toString} method in the editor.
     *
     * Subclasses can either reduce the standard {@link Mutator} built by this base class by deleting properties or implement an individual getMutator method.
     * The provided properties of the {@link Mutator} must match public properties or getters/setters of the object.
     * Otherwise, they will be ignored unless handled by an override of the mutate method in the subclass, and will throw errors in an automatically generated user interface for the object.
     */
    class Mutable extends FudgeCore.EventTargetUnified {
        /**
         * Decorator allows to attach {@link Mutable} functionality to existing classes.
         */
        // public static decorate(_constructor: Function): void {
        //   Object.defineProperty(_constructor.prototype, "useRenderData", {
        //     value: function getMutator(this: MutableForUserInterface): Mutator {
        //       return getMutatorOfArbitrary(this);
        //     }
        //   });
        // }
        static getMutatorFromPath(_mutator, _path) {
            let key = _path[0];
            let mutator = {};
            if (_mutator[key] == undefined) // if the path deviates from mutator structure, return the mutator
                return _mutator;
            mutator[key] = _mutator[key];
            if (_path.length > 1)
                mutator[key] = Mutable.getMutatorFromPath(mutator[key], _path.slice(1, _path.length));
            return mutator;
        }
        /**
         * Retrieves the type of this mutable subclass as the name of the runtime class
         * @returns The type of the mutable
         */
        get type() {
            return this.constructor.name;
        }
        /**
         * Collect applicable attributes of the instance and copies of their values in a Mutator-object.
         * By default, a mutator cannot be extended, since extensions are not available in the object the mutator belongs to.
         * A mutator may be reduced by the descendants of {@link Mutable} to contain only the properties needed.
         */
        getMutator(_extendable = false) {
            let mutator = {};
            // collect primitive and mutable attributes
            for (let attribute in this) {
                let value = this[attribute];
                if (value instanceof Function)
                    continue;
                if (value instanceof Object && !(value instanceof Mutable) && !(value instanceof FudgeCore.MutableArray) && !(value.hasOwnProperty("idResource")) && this.getMetaAttributeTypes()[attribute] == undefined)
                    continue;
                mutator[attribute] = value;
            }
            if (!_extendable)
                // mutator can be reduced but not extended!
                Object.preventExtensions(mutator);
            // delete unwanted attributes
            this.reduceMutator(mutator);
            // replace references to mutable objects with references to mutators
            for (let attribute in mutator) {
                let value = mutator[attribute];
                if (value instanceof Mutable)
                    mutator[attribute] = value.getMutator();
                if (value instanceof FudgeCore.MutableArray)
                    mutator[attribute] = value.map((_value) => _value.getMutator());
            }
            return mutator;
        }
        /**
         * Collect the attributes of the instance and their values applicable for animation.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForAnimation(_extendable = false) {
            return this.getMutator(_extendable);
        }
        /**
         * Collect the attributes of the instance and their values applicable for the user interface.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        getMutatorForUserInterface(_extendable = false) {
            return this.getMutator(_extendable); // TODO: both of these (this and getMutatorForAnimation) don't really work as they don't recursively call getMutatorForUserInterface on sub-mutable objects, maybe instead implement a reduceMutatorForUserInterface???
        }
        /**
         * Collect the attributes of the instance and their values applicable for indiviualization by the component.
         * Basic functionality is identical to {@link getMutator}, returned mutator should then be reduced by the subclassed instance
         */
        // public getMutatorForComponent(): MutatorForComponent {
        //     return <MutatorForComponent>this.getMutator();
        // }
        /**
         * Returns an associative array with the same attributes as the given mutator, but with the corresponding types as string-values.
         * Does not recurse into objects! This will return the decorated {@link Metadata meta-type} instead of the runtime-type of the object, if available.
         */
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            let metaTypes = this.getMetaAttributeTypes();
            for (let attribute in _mutator) {
                let metaType = metaTypes[attribute]; // constructor or enum
                let type;
                if (typeof metaType == "function")
                    type = metaType.name;
                else if (typeof metaType == "object")
                    type = metaType;
                let value = _mutator[attribute];
                if (value != undefined && type == undefined)
                    if (typeof value == "object")
                        type = this[attribute].constructor.name;
                    else if (typeof value == "function")
                        type = value.name;
                    else
                        type = value.constructor.name;
                types[attribute] = type;
            }
            return types;
        }
        /**
         * Retrieves the specified {@link Metadata.attributeTypes | attribute types} from the {@link Metadata | metadata} of this instance's class.
         */
        getMetaAttributeTypes() {
            return this.getMetadata().attributeTypes ??= {};
        }
        /**
         * Retrieves the {@link Metadata | metadata} of this instance's class.
         */
        getMetadata() {
            return this.constructor[Symbol.metadata] ??= {};
        }
        /**
         * Updates the values of the given mutator according to the current state of the instance
         * @param _mutator
         */
        updateMutator(_mutator) {
            for (let attribute in _mutator) {
                let value = Reflect.get(this, attribute);
                if (value instanceof Mutable)
                    value.updateMutator(_mutator[attribute]);
                else
                    _mutator[attribute] = value;
            }
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            await this.mutateBase(_mutator, _selection);
            if (_dispatchMutate)
                this.dispatchEvent(new CustomEvent("mutate" /* EVENT.MUTATE */, { bubbles: true, detail: { mutator: _mutator } }));
        }
        /**
         * Synchronous implementation of {@link mutate}.
         * Override {@link mutate} with a sync implementation and call this method from it to mutate synchronously.
         */
        mutateSync(_mutator, _dispatchMutate = true) {
            let mutator = _mutator;
            for (let attribute in mutator) {
                let mutant = Reflect.get(this, attribute);
                if (mutant instanceof FudgeCore.MutableArray || mutant instanceof Mutable)
                    mutant.mutate(mutator[attribute], null, false);
                else
                    Reflect.set(this, attribute, mutator[attribute]);
            }
            if (_dispatchMutate)
                this.dispatchEvent(new CustomEvent("mutate" /* EVENT.MUTATE */, { bubbles: true, detail: { mutator: _mutator } }));
        }
        ;
        /**
         * Base method for mutation, always available to subclasses. Do not overwrite in subclasses!
         */
        async mutateBase(_mutator, _selection) {
            let mutator = _mutator;
            if (_selection) { // TODO: this doesn't work as it does not recurse into objects
                mutator = {};
                for (let attribute of _selection) // reduce the mutator to the selection
                    if (typeof (_mutator[attribute]) !== "undefined")
                        mutator[attribute] = _mutator[attribute];
            }
            for (let attribute in mutator) {
                if (!Reflect.has(this, attribute))
                    continue;
                let mutant = Reflect.get(this, attribute);
                let value = mutator[attribute];
                if (mutant instanceof FudgeCore.MutableArray || mutant instanceof Mutable)
                    await mutant.mutate(value, null, false);
                else
                    Reflect.set(this, attribute, value);
            }
        }
    }
    FudgeCore.Mutable = Mutable;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Abstract class serving as a base for interface-like pure abstract classes that work with the "instanceof"-operator.
     *
     * **Usage**:
     * * Create a pure abstract class that extends {@link Implementable} that will serve as your interface. Specify the required attributes and methods within it as abstract.
     * * Use your abstract class via the `implements` keyword exactly how you would use a regular `interface`.
     * * Decorate the class that implements your abstract class using the static `YOUR_ABSTRACT_CLASS`.{@link register} method.
     * * Now you can use the `instanceof`-operator with your abstract class.
     *
     * **Example**:
     * ```typescript
     * import ∆í = FudgeCore;
     *
     * abstract class MyInterface extends ∆í.Implementable {
     *   public abstract myAttribute: string;
     *   public abstract myMethod(): void;
     * }
     *
     * @MyInterface.register
     * class MyClass implements MyInterface {
     *   public myAttribute: string;
     *   public myMethod(): void {}
     * }
     *
     * let myInstance: MyInterface = new MyClass();
     * console.log(myInstance instanceof MyInterface); // true
     * console.log(MyClass.prototype instanceof MyInterface); // true
     * ```
     */
    class Implementable {
        static register(_class, _context) {
            let meta = _context.metadata;
            if (!Object.hasOwn(meta, "implements"))
                meta.implements = new Set(meta.implements);
            let implement = this;
            while (implement != Implementable) {
                meta.implements.add(implement);
                implement = Object.getPrototypeOf(implement);
            }
        }
        static [Symbol.hasInstance](_instance) {
            let meta = _instance.constructor[Symbol.metadata];
            return meta?.implements?.has(this);
        }
    }
    FudgeCore.Implementable = Implementable;
    function serialize(_constructor, _context) {
        // decorate class
        if (_context) {
            let meta = _context.metadata;
            const prototype = _constructor.prototype;
            // make getters enumerable
            if (meta.enumerateKeys) {
                const descriptor = { enumerable: true };
                for (const key of meta.enumerateKeys)
                    Object.defineProperty(prototype, key, descriptor);
            }
            // override serialize and deserialize methods
            const originalSerialize = prototype.serialize;
            const originalDeserialize = prototype.deserialize;
            const serializables = meta.serializables;
            prototype.serialize = function () {
                const serialization = originalSerialize?.call(this) ?? {};
                for (const key in serializables) {
                    let value = Reflect.get(this, key);
                    if (value == null)
                        continue;
                    switch (serializables[key]) {
                        case "primitive":
                            serialization[key] = value;
                            break;
                        case "serializable":
                            serialization[key] = value.serialize();
                            break;
                        case "resource":
                            serialization[key] = value.idResource;
                            break;
                        case "node":
                            serialization[key] = FudgeCore.Node.PATH_FROM_TO(this, value);
                            break;
                    }
                }
                return serialization;
            };
            prototype.deserialize = async function (_serialization) {
                if (originalDeserialize)
                    await originalDeserialize.call(this, _serialization);
                for (const key in serializables) {
                    let value = _serialization[key];
                    if (value == null)
                        continue;
                    switch (serializables[key]) {
                        case "primitive":
                            Reflect.set(this, key, value);
                            break;
                        case "serializable":
                            await Reflect.get(this, key).deserialize(value);
                            break;
                        case "resource":
                            Reflect.set(this, key, FudgeCore.Project.resources[value] ?? await FudgeCore.Project.getResource(value)); // await is costly so first try to get resource directly
                            break;
                        case "node":
                            let instance = this;
                            const hndNodeDeserialized = () => {
                                const hndGraphDeserialized = (_event) => {
                                    Reflect.set(this, key, FudgeCore.Node.FIND(instance, value));
                                    instance.node.removeEventListener("graphDeserialized" /* EVENT.GRAPH_DESERIALIZED */, hndGraphDeserialized, true);
                                    instance.node.removeEventListener("graphInstantiated" /* EVENT.GRAPH_INSTANTIATED */, hndGraphDeserialized, true);
                                    instance.removeEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
                                };
                                instance.node.addEventListener("graphDeserialized" /* EVENT.GRAPH_DESERIALIZED */, hndGraphDeserialized, true);
                                instance.node.addEventListener("graphInstantiated" /* EVENT.GRAPH_INSTANTIATED */, hndGraphDeserialized, true);
                            };
                            instance.addEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
                    }
                }
                return this;
            };
            return;
        }
        // decorate property
        return (_value, _context) => {
            if (typeof _context.name != "string")
                return;
            let meta = _context.metadata;
            // add attribute type to metadata
            if (!Object.hasOwn(meta, "attributeTypes"))
                meta.attributeTypes = { ...meta.attributeTypes };
            meta.attributeTypes[_context.name] = _constructor;
            // determine serialization type and add to metadata
            let type;
            if (_constructor == String || _constructor == Number || _constructor == Boolean || typeof _constructor == "object") // primitive or enum
                type = "primitive";
            else if (_constructor == FudgeCore.Node)
                type = "node";
            else if (_constructor.prototype instanceof FudgeCore.SerializableResource)
                type = "resource";
            else if (_constructor.prototype.serialize && _constructor.prototype.deserialize)
                type = "serializable";
            if (!type)
                return;
            if (!Object.hasOwn(meta, "serializables"))
                meta.serializables = { ...meta.serializables };
            meta.serializables[_context.name] = type;
            if (_context.kind != "getter")
                return;
            // mark getter to be made enumerable
            if (!Object.hasOwn(meta, "enumerateKeys"))
                meta.enumerateKeys = [];
            meta.enumerateKeys.push(_context.name);
        };
    }
    FudgeCore.serialize = serialize;
    /**
     * Handles the external serialization and deserialization of {@link Serializable} objects. The internal process is handled by the objects themselves.
     * A {@link Serialization} object can be created from a {@link Serializable} object and a JSON-String may be created from that.
     * Vice versa, a JSON-String can be parsed to a {@link Serialization} which can be deserialized to a {@link Serializable} object.
     * ```text
     *  [Serializable] ‚Üí (serialize) ‚Üí [Serialization] ‚Üí (stringify) ‚Üí [String] ‚Üí (save or send)
     *                                        ‚Üì                            ‚Üì                  ‚Üì
     *                [Serializable] ‚Üê (deserialize) ‚Üê [Serialization] ‚Üê (parse) ‚Üê (load) ‚Üê [Medium]
     * ```
     * While the internal serialize/deserialize method1s of the objects care of the selection of information needed to recreate the object and its structure,
     * the {@link Serializer} keeps track of the namespaces and classes in order to recreate {@link Serializable} objects. The general structure of a {@link Serialization} is as follows
     * ```text
     * {
     *      namespaceName.className: {
     *          propertyName: propertyValue,
     *          ...,
     *          propertyNameOfReference: SerializationOfTheReferencedObject,
     *          ...,
     *          constructorNameOfSuperclass: SerializationOfSuperClass
     *      }
     * }
     * ```
     * Since the instance of the superclass is created automatically when an object is created,
     * the SerializationOfSuperClass omits the the namespaceName.className key and consists only of its value.
     * The constructorNameOfSuperclass is given instead as a property name in the serialization of the subclass.
     */
    class Serializer {
        /** In order for the Serializer to create class instances, it needs access to the appropriate namespaces */
        static { this.namespaces = { "∆í": FudgeCore }; }
        /**
         * Registers a namespace to the {@link Serializer}, to enable automatic instantiation of classes defined within
         */
        static registerNamespace(_namespace) {
            for (let name in Serializer.namespaces)
                if (Serializer.namespaces[name] == _namespace)
                    return name;
            let name = Serializer.findNamespaceIn(_namespace, window);
            if (!name)
                for (let parentName in Serializer.namespaces) {
                    name = Serializer.findNamespaceIn(_namespace, Serializer.namespaces[parentName]);
                    if (name) {
                        name = parentName + "." + name;
                        break;
                    }
                }
            if (!name)
                throw new Error("Namespace not found. Maybe parent namespace hasn't been registered before?");
            Serializer.namespaces[name] = _namespace;
            return name;
        }
        /**
         * Returns a javascript object representing the serializable FUDGE-object given,
         * including attached components, children, superclass-objects all information needed for reconstruction
         * @param _object An object to serialize, implementing the {@link Serializable} interface
         */
        static serialize(_object) {
            // TODO: save the namespace with the constructors name
            let path = this.getFullPath(_object);
            if (!path)
                throw new Error(`Namespace of serializable object of type ${_object.constructor.name} not found. Maybe the namespace hasn't been registered or the class not exported?`);
            return { [path]: _object.serialize() };
        }
        /**
         * Returns a FUDGE-object reconstructed from the information in the {@link Serialization} given,
         * including attached components, children, superclass-objects
         */
        static async deserialize(_serialization) {
            let reconstruct;
            let path;
            try {
                // loop constructed solely to access type-property. Only one expected!
                for (path in _serialization) {
                    reconstruct = Serializer.reconstruct(path);
                    reconstruct = await reconstruct.deserialize(_serialization[path]);
                    return reconstruct;
                }
            }
            catch (_error) {
                let message = `Deserialization of ${path}, ${reconstruct ? Reflect.get(reconstruct, "idResource") : ""} failed: ` + _error;
                throw new Error(message);
            }
            return null;
        }
        /**
         * Returns an Array of javascript object representing the serializable FUDGE-objects given in the array,
         * including attached components, children, superclass-objects all information needed for reconstruction
         */
        static serializeArray(_type, _objects) {
            let serializations = [];
            let path = this.getFullPath(new _type());
            if (!path)
                throw new Error(`Namespace of serializable object of type ${_type.name} not found. Maybe the namespace hasn't been registered or the class not exported?`);
            for (let object of _objects)
                serializations.push(object.serialize());
            let serialization = {};
            serialization[path] = serializations;
            return serialization;
        }
        /**
         * Returns an Array of FUDGE-objects reconstructed from the information in the array of {@link Serialization}s given,
         * including attached components, children, superclass-objects
         */
        static async deserializeArray(_serialization) {
            let serializables = [];
            let construct;
            let serializations = [];
            try {
                // loop constructed solely to access type-property. Only one expected!
                for (let path in _serialization) {
                    construct = Serializer.getConstructor(path);
                    serializations = _serialization[path];
                    break;
                }
            }
            catch (_error) {
                throw new Error("Deserialization failed: " + _error);
            }
            for (let serialization of serializations) {
                let serializable = new construct();
                await serializable.deserialize(serialization);
                serializables.push(serializable);
            }
            return serializables;
        }
        //TODO: implement prettifier to make JSON-Stringification of serializations more readable, e.g. placing x, y and z in one line
        /**
         * Prettify a JSON-String, to make it more readable.
         * not implemented yet
         */
        static prettify(_json) { return _json; }
        /**
         * Returns a formatted, human readable JSON-String, representing the given {@link Serialization} that may have been created by {@link Serializer}.serialize
         * @param _serialization
         */
        static stringify(_serialization) {
            // adjustments to serialization can be made here before stringification, if desired
            let json = JSON.stringify(_serialization, null, 2);
            let pretty = Serializer.prettify(json);
            return pretty;
        }
        /**
         * Returns a {@link Serialization} created from the given JSON-String. Result may be passed to {@link Serializer.deserialize}
         * @param _json
         */
        static parse(_json) {
            return JSON.parse(_json);
        }
        /**
         * Creates an object of the class defined with the full path including the namespaceName(s) and the className seperated by dots(.)
         * @param _path
         */
        static reconstruct(_path) {
            let constructor = Serializer.getConstructor(_path);
            let reconstruction = new constructor();
            return reconstruction;
        }
        // public static getConstructor<T extends Serializable>(_type: string, _namespace: Object = FudgeCore): new () => T {
        /**
         * Returns the constructor from the given path to a class
         */
        static getConstructor(_path) {
            let typeName = _path.substring(_path.lastIndexOf(".") + 1);
            let namespace = Serializer.getNamespace(_path);
            if (!namespace)
                throw new Error(`Constructor of serializable object of type ${_path} not found. Maybe the namespace hasn't been registered?`);
            return namespace[typeName];
        }
        /**
         * Returns the full path to the class of the object, if found in the registered namespaces
         * @param _object
         */
        static getFullPath(_object) {
            let typeName = _object.constructor.name;
            // Debug.log("Searching namespace of: " + typeName);
            for (let namespaceName in Serializer.namespaces) {
                let found = Serializer.namespaces[namespaceName][typeName];
                if (found && _object instanceof found)
                    return namespaceName + "." + typeName;
            }
            return null;
        }
        /**
         * Returns the namespace-object defined within the full path, if registered
         * @param _path
         */
        static getNamespace(_path) {
            let namespaceName = _path.substr(0, _path.lastIndexOf("."));
            return Serializer.namespaces[namespaceName] || FudgeCore;
        }
        /**
         * Finds the namespace-object in properties of the parent-object (e.g. window), if present
         * @param _namespace
         * @param _parent
         */
        static findNamespaceIn(_namespace, _parent) {
            for (let prop in _parent)
                if (_parent[prop] == _namespace)
                    return prop;
            return null;
        }
    }
    FudgeCore.Serializer = Serializer;
    /**
     * Creates a new (abstract) class implementing {@link SerializableResourceExternal} from any class that implements {@link SerializableResource} by mixing in the functionality to load the resource from an external source.
     * @internal
     * @authors Jonas Plotzky, HFU, 2024
     */
    function mixinSerializableResourceExternal(_base) {
        class SerializableResourceExternalMixin extends _base {
            constructor() {
                super(...arguments);
                this.status = FudgeCore.RESOURCE_STATUS.PENDING;
            }
            /**
             * Returns a {@link Serialization} of this resource. Only the data needed to load it from the external source is serialized ("url", "name", "idResource").
             */
            serialize() {
                const serialization = {
                    idResource: this.idResource,
                    name: this.name,
                    type: this.type,
                    url: this.url.toString()
                };
                return serialization;
            }
            async deserialize(_serialization) {
                FudgeCore.Project.register(this, _serialization.idResource);
                this.url = _serialization.url;
                this.name = _serialization.name;
                return this.load();
            }
        }
        ;
        if (_base.prototype instanceof FudgeCore.Mutable) {
            /**
             * Mixin the {@link Mutable} functionality into the class
             * @authors Jonas Plotzky, HFU, 2024
             */
            function mixinMutableSerializableResourceExternal(_base) {
                class MutableSerializableResourceExternal extends _base {
                    async mutate(_mutator, _selection = null, _dispatchMutate = true) {
                        await super.mutate(_mutator, _selection, false);
                        if (_mutator.url != undefined || _mutator.name != undefined)
                            await this.load();
                    }
                    reduceMutator(_mutator) {
                        delete _mutator.status;
                    }
                }
                return MutableSerializableResourceExternal;
            }
            return mixinMutableSerializableResourceExternal(SerializableResourceExternalMixin);
        }
        return SerializableResourceExternalMixin;
    }
    FudgeCore.mixinSerializableResourceExternal = mixinSerializableResourceExternal;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Manages uniform data to be transmitted during rendering. All data is collected in one contiguous buffer and sent to the GPU in a single operation.
     * @internal
     * @authors Jonas Plotzky, HFU, 2025
     */
    class RenderBufferManager {
        static { this.mapObjectToOffset = new WeakMap(); } // Maps the objects to their respective byte offset in the gpu buffer
        /** @internal Replaces the decorated method with the manager‚Äôs implementation of the same name. */
        static decorate(_method, _context) {
            return Reflect.get(this, _context.name).bind(this);
        }
        static initialize(_renderWebGL, _blockBinding, _blockSize, _maxObjects) {
            this.blockSize = _blockSize;
            this.blockBinding = _blockBinding;
            const crc3 = _renderWebGL.getRenderingContext();
            const alignment = crc3.getParameter(WebGL2RenderingContext.UNIFORM_BUFFER_OFFSET_ALIGNMENT);
            this.spaceBuffer = Math.ceil(this.blockSize / alignment) * alignment; // round to multiple of alignment
            this.spaceData = this.spaceBuffer / Float32Array.BYTES_PER_ELEMENT;
            this.data = new Float32Array(this.spaceData * _maxObjects);
            this.dataUInt = new Uint32Array(this.data.buffer);
            this.count = 0;
            this.buffer = _renderWebGL.assert(crc3.createBuffer());
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, this.buffer);
            crc3.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, this.data.byteLength, WebGL2RenderingContext.DYNAMIC_DRAW);
        }
        static resetRenderData() {
            this.count = 0;
        }
        static updateRenderbuffer() {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, this.buffer);
            crc3.bufferSubData(WebGL2RenderingContext.UNIFORM_BUFFER, 0, this.data, 0, this.count * this.spaceData);
        }
        static useRenderData(_object) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindBufferRange(WebGL2RenderingContext.UNIFORM_BUFFER, this.blockBinding, this.buffer, this.mapObjectToOffset.get(_object), this.blockSize);
        }
        static store(_object) {
            const offsetData = this.count * this.spaceData;
            this.mapObjectToOffset.set(_object, this.count * this.spaceBuffer); // offset in bytes
            this.count++;
            if (offsetData + this.spaceData > this.data.length)
                this.grow();
            return offsetData;
        }
        static updateRenderData(_object, ..._data) {
            /** overriden in subclasses */
        }
        ;
        static grow() {
            const data = new Float32Array(this.data.length * 1.5);
            data.set(this.data);
            this.data = data;
            this.dataUInt = new Uint32Array(this.data.buffer);
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, this.buffer);
            crc3.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, this.data.byteLength, WebGL2RenderingContext.DYNAMIC_DRAW);
        }
    }
    FudgeCore.RenderBufferManager = RenderBufferManager;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Manages {@link Coat} data to be transmitted during rendering.
     * @internal
     * @authors Jonas Plotzky, HFU, 2025
     */
    class RenderManagerCoat extends FudgeCore.RenderBufferManager {
        static initialize(_renderWebGL) {
            const maxMaterials = 128;
            const blockSize = (4 + 1 + 1 + 1 + 1 + 1) * 4; // vct4 color, float diffuse, float specular, float intensity, float metallic, float alphaClip
            super.initialize(_renderWebGL, FudgeCore.UNIFORM_BLOCK.MATERIAL.BINDING, blockSize, maxMaterials);
        }
        static updateRenderData(_coat) {
            const offset = this.store(_coat);
            const data = this.data;
            if (_coat instanceof FudgeCore.CoatColored) { // TODO: use inheritance to avoid check?
                const color = _coat.color;
                data[offset] = color.r;
                data[offset + 1] = color.g;
                data[offset + 2] = color.b;
                data[offset + 3] = color.a;
            }
            if (_coat instanceof FudgeCore.CoatRemissive || _coat instanceof FudgeCore.CoatRemissiveTextured) {
                data[offset + 4] = _coat.diffuse;
                data[offset + 5] = _coat.specular;
                data[offset + 6] = _coat.intensity;
                data[offset + 7] = _coat.metallic;
            }
            data[offset + 8] = _coat.alphaClip;
        }
        static useRenderData(_coat) {
            super.useRenderData(_coat);
            if (_coat instanceof FudgeCore.CoatTextured)
                _coat.texture.useRenderData(FudgeCore.TEXTURE_LOCATION.COLOR.UNIT);
            if (_coat instanceof FudgeCore.CoatRemissiveTexturedNormals)
                _coat.normalMap.useRenderData(FudgeCore.TEXTURE_LOCATION.NORMAL.UNIT);
            if (_coat instanceof FudgeCore.CoatToon)
                _coat.texToon.useRenderData(FudgeCore.TEXTURE_LOCATION.TOON.UNIT);
        }
    }
    FudgeCore.RenderManagerCoat = RenderManagerCoat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Manages {@link Node} data (data that is unique for each node, i.e. {@link Component} data) to be transmitted during rendering.
     * @internal
     * @authors Jonas Plotzky, HFU, 2025
     */
    class RenderManagerNode extends FudgeCore.RenderBufferManager {
        static initialize(_renderWebGL) {
            const maxNodes = 256;
            const blockSize = (16 + 12 + 4 + 1 + 1 + 1 + 1 + 1 + 1) * 4; // mat4 mtxWorld, mat3 mtxPivot, vec4 color, float blendMode, float duration, float size, float time, bool faceCameraActive, bool faceCameraRestrict, 
            super.initialize(_renderWebGL, FudgeCore.UNIFORM_BLOCK.NODE.BINDING, blockSize, maxNodes);
        }
        static updateRenderData(_node, _cmpMesh, _cmpMaterial, _cmpFaceCamera, _cmpParticleSystem) {
            const offset = this.store(_node);
            const data = this.data;
            // mtx world
            data.set(_cmpMesh.mtxWorld.getArray(), offset);
            // mtx pivot
            let dataPivot = _cmpMaterial.mtxPivot.getArray();
            data[offset + 16] = dataPivot[0];
            data[offset + 17] = dataPivot[1];
            data[offset + 18] = dataPivot[2];
            // data[offsetPivot + 19] = padding
            data[offset + 20] = dataPivot[3];
            data[offset + 21] = dataPivot[4];
            data[offset + 22] = dataPivot[5];
            // data[offsetPivot + 23] = padding
            data[offset + 24] = dataPivot[6];
            data[offset + 25] = dataPivot[7];
            data[offset + 26] = dataPivot[8];
            // data[offsetPivot + 27] = padding
            // color
            let color = _cmpMaterial.clrPrimary;
            data[offset + 28] = color.r;
            data[offset + 29] = color.g;
            data[offset + 30] = color.b;
            data[offset + 31] = color.a;
            if (_cmpParticleSystem) {
                const dataUint = this.dataUInt;
                dataUint[offset + 32] = _cmpParticleSystem.blendMode;
                data[offset + 33] = _cmpParticleSystem.duration;
                data[offset + 34] = _cmpParticleSystem.size;
                data[offset + 35] = _cmpParticleSystem.time;
                dataUint[offset + 36] = _cmpFaceCamera?.isActive ? 1 : 0;
                dataUint[offset + 37] = _cmpFaceCamera?.restrict ? 1 : 0;
            }
        }
        static useRenderData(_node, _mtxWorldOverride) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            let offset = this.mapObjectToOffset.get(_node);
            crc3.bindBufferRange(WebGL2RenderingContext.UNIFORM_BUFFER, this.blockBinding, this.buffer, offset, this.blockSize);
            if (_mtxWorldOverride) // this is relatively slow, but since prepare has no camera information, we may need to override the world matrix here
                crc3.bufferSubData(WebGL2RenderingContext.UNIFORM_BUFFER, offset, _mtxWorldOverride.getArray());
        }
    }
    FudgeCore.RenderManagerNode = RenderManagerNode;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles picking.
     * @internal
     */
    class RenderWebGLPicking {
        static #sizeMax; // the dimension of the square pick texture
        static #data;
        static #dataClearColor = [0, 0, 0, 0];
        /**
         * Initialize framebuffers and render attachments.
         */
        static initialize(_renderWebGL) {
            const crc3 = _renderWebGL.getRenderingContext();
            RenderWebGLPicking.fboPick = _renderWebGL.assert(crc3.createFramebuffer());
            RenderWebGLPicking.texPick = _renderWebGL.createTexture(WebGL2RenderingContext.NEAREST, WebGL2RenderingContext.CLAMP_TO_EDGE);
            RenderWebGLPicking.texDepth = _renderWebGL.createTexture(WebGL2RenderingContext.NEAREST, WebGL2RenderingContext.CLAMP_TO_EDGE);
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGLPicking.fboPick);
            crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, RenderWebGLPicking.texPick, 0);
            crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.DEPTH_ATTACHMENT, WebGL2RenderingContext.TEXTURE_2D, RenderWebGLPicking.texDepth, 0);
            RenderWebGLPicking.resize(_renderWebGL, 10); // initial size
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, null);
        }
        /**
         * Used with a {@link Picker}-camera, this method renders one pixel with picking information
         * for each pickable object in the line of sight and returns that as an unsorted array of {@link Pick}s.
         * The function to render the objects into the pick buffer must be provided by the caller.
         * @param _pick The function which renders objects into the pick buffer. Returns a {@link Pick} for each rendered object.
         * **MUST** use {@link ShaderPick} or {@link ShaderPickTextured} to render objects.
         */
        static pickFrom(_from, _cmpCamera, _pick) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            // adjust buffer size
            const size = Math.ceil(Math.sqrt(_from.length));
            if (size > RenderWebGLPicking.#sizeMax)
                RenderWebGLPicking.resize(FudgeCore.RenderWebGL, size);
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGLPicking.fboPick);
            crc3.viewport(0, 0, size, size);
            // clear buffer
            crc3.clearBufferiv(WebGL2RenderingContext.COLOR, 0, RenderWebGLPicking.#dataClearColor);
            crc3.clearBufferfi(WebGL2RenderingContext.DEPTH_STENCIL, 0, 1, 0);
            FudgeCore.RenderWebGLComponentCamera.useRenderbuffer(_cmpCamera);
            // buffer size into pick shaders
            FudgeCore.ShaderPick.useProgram();
            crc3.uniform1i(FudgeCore.ShaderPick.uniforms["u_size"], size);
            FudgeCore.ShaderPickTextured.useProgram();
            crc3.uniform1i(FudgeCore.ShaderPickTextured.uniforms["u_size"], size);
            // render picks into pick buffer
            FudgeCore.RenderWebGL.setBlendMode(FudgeCore.BLEND.OPAQUE);
            const picks = _pick(_from, _cmpCamera);
            FudgeCore.RenderWebGL.setBlendMode(FudgeCore.BLEND.TRANSPARENT);
            // get/filter picks
            // evaluate texture by reading pixels and extract, convert and store the information about each mesh hit
            const data = RenderWebGLPicking.#data;
            crc3.readPixels(0, 0, size, size, WebGL2RenderingContext.RGBA_INTEGER, WebGL2RenderingContext.INT, data);
            const picked = [];
            const mtxViewToWorld = FudgeCore.Matrix4x4.INVERSE(_cmpCamera.mtxWorldToView);
            for (let i = 0; i < picks.length; i++) {
                let zBuffer = data[4 * i + 0] + data[4 * i + 1] / 256;
                if (zBuffer == 0) // discard misses 
                    continue;
                let pick = picks[i];
                pick.zBuffer = RenderWebGLPicking.convertInt32toFloat32(data, 4 * i + 0) * 2 - 1;
                pick.color = RenderWebGLPicking.convertInt32toColor(data, 4 * i + 1);
                pick.textureUV = FudgeCore.Recycler.reuse(FudgeCore.Vector2);
                pick.textureUV.set(RenderWebGLPicking.convertInt32toFloat32(data, 4 * i + 2), RenderWebGLPicking.convertInt32toFloat32(data, 4 * i + 3));
                pick.mtxViewToWorld = mtxViewToWorld;
                picked.push(pick);
            }
            FudgeCore.Recycler.store(mtxViewToWorld);
            // reset
            FudgeCore.RenderWebGL.resetFramebuffer();
            const canvasRectangle = FudgeCore.RenderWebGL.getCanvasRectangle();
            crc3.viewport(0, 0, canvasRectangle.width, canvasRectangle.height);
            return picked;
        }
        static convertInt32toFloat32(_int32Array, _index) {
            let buffer = new ArrayBuffer(4);
            let view = new DataView(buffer);
            view.setInt32(0, _int32Array[_index]);
            return view.getFloat32(0);
        }
        static convertInt32toColor(_int32Array, _index) {
            let buffer = new ArrayBuffer(4);
            let view = new DataView(buffer);
            view.setInt32(0, _int32Array[_index]);
            let color = FudgeCore.Color.CSS(`rgb(${view.getUint8(0)}, ${view.getUint8(1)}, ${view.getUint8(2)})`, view.getUint8(3) / 255);
            return color;
        }
        static resize(_renderWebGL, _size) {
            const crc3 = _renderWebGL.getRenderingContext();
            RenderWebGLPicking.#sizeMax = _size;
            RenderWebGLPicking.#data = new Int32Array(_size * _size * 4);
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGLPicking.texPick);
            crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA32I, _size, _size, 0, WebGL2RenderingContext.RGBA_INTEGER, WebGL2RenderingContext.INT, null); // could use RBGA32F in the future e.g. WebGPU
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGLPicking.texDepth);
            crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.DEPTH_COMPONENT24, _size, _size, 0, WebGL2RenderingContext.DEPTH_COMPONENT, WebGL2RenderingContext.UNSIGNED_INT, null);
        }
    }
    FudgeCore.RenderWebGLPicking = RenderWebGLPicking;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Manages {@link ComponentLight} data to be transmitted during rendering.
     * @internal
     * @authors Jonas Plotzky, HFU, 2025
     */
    class RenderWebGLComponentLight {
        static #buffer;
        static #data;
        static #dataHeader;
        static #dataAmbient;
        static #dataPoint;
        static #dataSpot;
        static #dataDirectional;
        /**
         * Initialize the light uniform buffer.
         */
        static initialize(_renderWebGL) {
            const MAX_LIGHTS_DIRECTIONAL = 15;
            const MAX_LIGHTS_POINT = 100;
            const MAX_LIGHTS_SPOT = 100;
            const HEADER_UINTS = 4;
            const COLOR_FLOATS = 4;
            const MATRIX_FLOATS = 16;
            const LIGHT_FLOATS = COLOR_FLOATS + MATRIX_FLOATS + MATRIX_FLOATS;
            RenderWebGLComponentLight.#data = new Float32Array(HEADER_UINTS + COLOR_FLOATS + (MAX_LIGHTS_DIRECTIONAL + MAX_LIGHTS_POINT + MAX_LIGHTS_SPOT) * LIGHT_FLOATS);
            RenderWebGLComponentLight.#dataHeader = new Uint32Array(RenderWebGLComponentLight.#data.buffer, 0, HEADER_UINTS);
            RenderWebGLComponentLight.#dataAmbient = new Float32Array(RenderWebGLComponentLight.#data.buffer, RenderWebGLComponentLight.#dataHeader.byteOffset + RenderWebGLComponentLight.#dataHeader.byteLength, COLOR_FLOATS); // ambient light color
            RenderWebGLComponentLight.#dataDirectional = new Float32Array(RenderWebGLComponentLight.#data.buffer, RenderWebGLComponentLight.#dataAmbient.byteOffset + RenderWebGLComponentLight.#dataAmbient.byteLength, MAX_LIGHTS_DIRECTIONAL * LIGHT_FLOATS);
            RenderWebGLComponentLight.#dataPoint = new Float32Array(RenderWebGLComponentLight.#data.buffer, RenderWebGLComponentLight.#dataDirectional.byteOffset + RenderWebGLComponentLight.#dataDirectional.byteLength, MAX_LIGHTS_POINT * LIGHT_FLOATS);
            RenderWebGLComponentLight.#dataSpot = new Float32Array(RenderWebGLComponentLight.#data.buffer, RenderWebGLComponentLight.#dataPoint.byteOffset + RenderWebGLComponentLight.#dataPoint.byteLength, MAX_LIGHTS_SPOT * LIGHT_FLOATS);
            const crc3 = _renderWebGL.getRenderingContext();
            RenderWebGLComponentLight.#buffer = _renderWebGL.assert(crc3.createBuffer());
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, RenderWebGLComponentLight.#buffer);
            crc3.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, RenderWebGLComponentLight.#data.byteLength, WebGL2RenderingContext.DYNAMIC_DRAW);
            crc3.bindBufferBase(WebGL2RenderingContext.UNIFORM_BUFFER, FudgeCore.UNIFORM_BLOCK.LIGHTS.BINDING, RenderWebGLComponentLight.#buffer);
        }
        /** Replaces the decorated method with the manager‚Äôs implementation of the same name. */
        static decorate(_method, _context) {
            return Reflect.get(this, _context.name);
        }
        /**
         * Buffer the light data to the uniform buffer.
         */
        static updateRenderbuffer(_lights) {
            // fill the buffer with the ambient light color
            let cmpLights = _lights.get(FudgeCore.LIGHT_TYPE.AMBIENT);
            if (cmpLights?.length > 0) {
                let clrSum = FudgeCore.Recycler.get(FudgeCore.Color).set(0, 0, 0, 0);
                let clrLight = FudgeCore.Recycler.get(FudgeCore.Color);
                for (let cmpLight of cmpLights)
                    clrSum.add(FudgeCore.Color.SCALE(cmpLight.color, cmpLight.intensity, clrLight));
                FudgeCore.Recycler.store(clrSum);
                FudgeCore.Recycler.store(clrLight);
                clrSum.toArray(RenderWebGLComponentLight.#dataAmbient);
            }
            const cmpLightsDirectional = _lights.get(FudgeCore.LIGHT_TYPE.DIRECTIONAL);
            const cmpLightsPoint = _lights.get(FudgeCore.LIGHT_TYPE.POINT);
            const cmpLightsSpot = _lights.get(FudgeCore.LIGHT_TYPE.SPOT);
            RenderWebGLComponentLight.#dataHeader[0] = cmpLightsDirectional?.length ?? 0;
            RenderWebGLComponentLight.#dataHeader[1] = cmpLightsPoint?.length ?? 0;
            RenderWebGLComponentLight.#dataHeader[2] = cmpLightsSpot?.length ?? 0;
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, RenderWebGLComponentLight.#buffer);
            crc3.bufferSubData(WebGL2RenderingContext.UNIFORM_BUFFER, 0, RenderWebGLComponentLight.#data, 0, RenderWebGLComponentLight.#dataHeader.length + RenderWebGLComponentLight.#dataAmbient.length); // header + ambient color
            const clrOut = FudgeCore.Recycler.get(FudgeCore.Color); // stores intermediate color
            const mtxOut = FudgeCore.Matrix4x4.IDENTITY(); // stores intermediate matrix
            RenderWebGLComponentLight.bufferLights(crc3, cmpLightsDirectional, RenderWebGLComponentLight.#dataDirectional, clrOut, mtxOut);
            RenderWebGLComponentLight.bufferLights(crc3, cmpLightsPoint, RenderWebGLComponentLight.#dataPoint, clrOut, mtxOut);
            RenderWebGLComponentLight.bufferLights(crc3, cmpLightsSpot, RenderWebGLComponentLight.#dataSpot, clrOut, mtxOut);
            FudgeCore.Recycler.store(clrOut);
            FudgeCore.Recycler.store(mtxOut);
        }
        static bufferLights(_crc3, _cmpLights, _data, _clrOut, _mtxOut) {
            if (!_cmpLights)
                return;
            let iLight = 0;
            for (let cmpLight of _cmpLights) {
                // set vctColor
                FudgeCore.Color.SCALE(cmpLight.color, cmpLight.intensity, _clrOut).toArray(_data, iLight);
                // set mtxShape
                FudgeCore.Matrix4x4.PRODUCT(cmpLight.node.mtxWorld, cmpLight.mtxPivot, _mtxOut);
                if (cmpLight.lightType == FudgeCore.LIGHT_TYPE.DIRECTIONAL)
                    _mtxOut.translation = _mtxOut.translation.set(0, 0, 0);
                _mtxOut.toArray(_data, iLight + 4);
                // set mtxShapeInverse
                if (cmpLight.lightType != FudgeCore.LIGHT_TYPE.DIRECTIONAL)
                    FudgeCore.Matrix4x4.INVERSE(_mtxOut, _mtxOut).toArray(_data, iLight + 20);
                iLight += 36;
            }
            _crc3.bufferSubData(WebGL2RenderingContext.UNIFORM_BUFFER, _data.byteOffset, _data, 0, iLight);
        }
    }
    FudgeCore.RenderWebGLComponentLight = RenderWebGLComponentLight;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Manages {@link ComponentFog} data to be transmitted during rendering.
     * @internal
     * @authors Jonas Plotzky, HFU, 2025
     */
    class RenderWebGLComponentFog {
        static #buffer;
        static #data;
        /**
         * Initialize the fog uniform buffer.
         */
        static initialize(_renderWebGL) {
            const crc3 = _renderWebGL.getRenderingContext();
            RenderWebGLComponentFog.#buffer = _renderWebGL.assert(crc3.createBuffer());
            RenderWebGLComponentFog.#data = new Float32Array(8);
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, RenderWebGLComponentFog.#buffer);
            crc3.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, RenderWebGLComponentFog.#data.byteLength, WebGL2RenderingContext.DYNAMIC_DRAW);
            crc3.bindBufferBase(WebGL2RenderingContext.UNIFORM_BUFFER, FudgeCore.UNIFORM_BLOCK.FOG.BINDING, RenderWebGLComponentFog.#buffer);
        }
        /**
         * Buffer the fog data to the uniform buffer.
         */
        static useRenderbuffer(_cmpFog) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            const data = RenderWebGLComponentFog.#data;
            data[0] = _cmpFog?.isActive ? 1 : 0;
            if (_cmpFog) {
                data[1] = _cmpFog.near;
                data[2] = _cmpFog.far;
                data.set(_cmpFog.color.get(), 4);
            }
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, RenderWebGLComponentFog.#buffer);
            crc3.bufferSubData(WebGL2RenderingContext.UNIFORM_BUFFER, 0, RenderWebGLComponentFog.#data);
        }
    }
    FudgeCore.RenderWebGLComponentFog = RenderWebGLComponentFog;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Manages {@link ComponentCamera} data to be transmitted during rendering.
     * @internal
     * @authors Jonas Plotzky, HFU, 2025
     */
    class RenderWebGLComponentCamera {
        static #buffer;
        static #data;
        /**
         * Initialize the camera uniform buffer.
         */
        static initialize(_renderWebGL) {
            const crc3 = _renderWebGL.getRenderingContext();
            RenderWebGLComponentCamera.#buffer = _renderWebGL.assert(crc3.createBuffer());
            RenderWebGLComponentCamera.#data = new Float32Array(16 + 16 + 16 + 3);
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, RenderWebGLComponentCamera.#buffer);
            crc3.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, RenderWebGLComponentCamera.#data.byteLength, WebGL2RenderingContext.DYNAMIC_DRAW);
            crc3.bindBufferBase(WebGL2RenderingContext.UNIFORM_BUFFER, FudgeCore.UNIFORM_BLOCK.CAMERA.BINDING, RenderWebGLComponentCamera.#buffer);
        }
        /**
         * Buffer the camera data to the uniform buffer.
         */
        static useRenderbuffer(_cmpCamera) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            const data = RenderWebGLComponentCamera.#data;
            const mtxView = _cmpCamera.mtxCameraInverse;
            const mtxProjection = _cmpCamera.mtxProjection;
            const mtxViewProjection = _cmpCamera.mtxWorldToView;
            const vctPosition = _cmpCamera.mtxWorld.translation;
            data.set(mtxView.getArray(), 0);
            data.set(mtxProjection.getArray(), 16);
            data.set(mtxViewProjection.getArray(), 32);
            vctPosition.toArray(data, 48);
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, RenderWebGLComponentCamera.#buffer);
            crc3.bufferSubData(WebGL2RenderingContext.UNIFORM_BUFFER, 0, RenderWebGLComponentCamera.#data);
        }
    }
    FudgeCore.RenderWebGLComponentCamera = RenderWebGLComponentCamera;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles the {@link ComponentAmbientOcclusion ambient occlusion} post-processing effect.
     * @internal
     * @authors Jonas Plotzky, HFU, 2025
     */
    class RenderWebGLComponentAmbientOcclusion {
        static #dataCamera = new Float32Array(3);
        /**
         * Initialize framebuffers and render attachments.
         */
        static initialize(_renderWebGL) {
            const crc3 = _renderWebGL.getRenderingContext();
            RenderWebGLComponentAmbientOcclusion.texOut = _renderWebGL.texColor;
            RenderWebGLComponentAmbientOcclusion.texNoise = _renderWebGL.createTexture(WebGL2RenderingContext.NEAREST, WebGL2RenderingContext.CLAMP_TO_EDGE);
            RenderWebGLComponentAmbientOcclusion.fboOut = _renderWebGL.assert(crc3.createFramebuffer());
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGLComponentAmbientOcclusion.fboOut);
            crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, RenderWebGLComponentAmbientOcclusion.texOut, 0);
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, null);
        }
        /**
         * Draw the ambient occlusion effect.
         */
        static draw(_cmpCamera, _cmpAmbientOcclusion) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            FudgeCore.ShaderAmbientOcclusion.useProgram();
            FudgeCore.RenderWebGL.bindTexture(FudgeCore.ShaderAmbientOcclusion, FudgeCore.RenderWebGL.texPosition, WebGL2RenderingContext.TEXTURE0, "u_texPosition");
            FudgeCore.RenderWebGL.bindTexture(FudgeCore.ShaderAmbientOcclusion, FudgeCore.RenderWebGL.texNormal, WebGL2RenderingContext.TEXTURE1, "u_texNormal");
            FudgeCore.RenderWebGL.bindTexture(FudgeCore.ShaderAmbientOcclusion, RenderWebGLComponentAmbientOcclusion.texNoise, WebGL2RenderingContext.TEXTURE2, "u_texNoise");
            crc3.uniform1f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_fNear"], _cmpCamera.near);
            crc3.uniform1f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_fFar"], _cmpCamera.far);
            crc3.uniform1f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_fBias"], _cmpAmbientOcclusion.bias);
            crc3.uniform1f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_fSampleRadius"], _cmpAmbientOcclusion.sampleRadius);
            crc3.uniform1f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_fAttenuationConstant"], _cmpAmbientOcclusion.attenuationConstant);
            crc3.uniform1f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_fAttenuationLinear"], _cmpAmbientOcclusion.attenuationLinear);
            crc3.uniform1f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_fAttenuationQuadratic"], _cmpAmbientOcclusion.attenuationQuadratic);
            crc3.uniform2f(FudgeCore.ShaderAmbientOcclusion.uniforms["u_vctResolution"], FudgeCore.RenderWebGL.getCanvasRectangle().width, FudgeCore.RenderWebGL.getCanvasRectangle().height);
            crc3.uniform3fv(FudgeCore.ShaderAmbientOcclusion.uniforms["u_vctCamera"], _cmpCamera.mtxWorld.translation.toArray(RenderWebGLComponentAmbientOcclusion.#dataCamera));
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGLComponentAmbientOcclusion.fboOut);
            FudgeCore.RenderWebGL.setBlendMode(FudgeCore.BLEND.SUBTRACTIVE);
            crc3.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, 3);
            FudgeCore.RenderWebGL.setBlendMode(FudgeCore.BLEND.TRANSPARENT);
        }
        /**
         * Resize the render attachments.
         */
        static resize(_renderWebGL, _width, _height) {
            const crc3 = _renderWebGL.getRenderingContext();
            const canvasWidth = _width || 1;
            const canvasHeight = _height || 1;
            crc3.activeTexture(crc3.TEXTURE0);
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGLComponentAmbientOcclusion.texOut);
            crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, canvasWidth, canvasHeight, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, null);
            const nValues = canvasWidth * canvasHeight * 4;
            const noiseData = new Uint8Array(nValues);
            for (let i = 0; i < nValues; i += 4) {
                noiseData[i] = Math.floor(Math.random() * 256);
                noiseData[i + 1] = Math.floor(Math.random() * 256);
                noiseData[i + 2] = Math.floor(Math.random() * 256);
                noiseData[i + 3] = Math.floor(Math.random() * 256);
            }
            crc3.bindTexture(crc3.TEXTURE_2D, RenderWebGLComponentAmbientOcclusion.texNoise);
            crc3.texImage2D(crc3.TEXTURE_2D, 0, crc3.RGBA, canvasWidth, canvasHeight, 0, crc3.RGBA, crc3.UNSIGNED_BYTE, noiseData);
            crc3.bindTexture(crc3.TEXTURE_2D, null);
        }
    }
    FudgeCore.RenderWebGLComponentAmbientOcclusion = RenderWebGLComponentAmbientOcclusion;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles the {@link ComponentBloom bloom} post-processing effect.
     * @internal
     * @authors Jonas Plotzky, HFU, 2025
     */
    class RenderWebGLComponentBloom {
        /**
         * Initialize framebuffers and render attachments.
         */
        static initialize(_renderWebGL) {
            const crc3 = _renderWebGL.getRenderingContext();
            RenderWebGLComponentBloom.textures = new Array(6);
            RenderWebGLComponentBloom.fbos = new Array(6);
            for (let i = 0; i < RenderWebGLComponentBloom.textures.length; i++) {
                RenderWebGLComponentBloom.textures[i] = _renderWebGL.createTexture(WebGL2RenderingContext.LINEAR, WebGL2RenderingContext.CLAMP_TO_EDGE);
                RenderWebGLComponentBloom.fbos[i] = _renderWebGL.assert(crc3.createFramebuffer());
                crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGLComponentBloom.fbos[i]);
                crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, RenderWebGLComponentBloom.textures[i], 0);
            }
            RenderWebGLComponentBloom.fboOut = _renderWebGL.assert(crc3.createFramebuffer());
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGLComponentBloom.fboOut);
            crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, _renderWebGL.texColor, 0);
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, null);
        }
        /**
         * Draw the bloom effect.
         */
        static draw(_cmpBloom) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            FudgeCore.ShaderBloom.useProgram();
            // extract bright colors, could move this to main render pass so that individual objects can be exempt from bloom
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGLComponentBloom.fbos[0]);
            // crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, RenderWebGLComponentBloom.textures[0], 0);
            FudgeCore.RenderWebGL.clear();
            FudgeCore.RenderWebGL.bindTexture(FudgeCore.ShaderBloom, FudgeCore.RenderWebGL.texColor, WebGL2RenderingContext.TEXTURE0, "u_texSource");
            crc3.uniform1f(FudgeCore.ShaderBloom.uniforms["u_fThreshold"], _cmpBloom.threshold);
            crc3.uniform1i(FudgeCore.ShaderBloom.uniforms["u_iMode"], 0);
            crc3.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, 3);
            const canvasRectangle = FudgeCore.RenderWebGL.getCanvasRectangle();
            const canvasWidth = canvasRectangle.width;
            const canvasHeight = canvasRectangle.height;
            // downsample
            const iterations = RenderWebGLComponentBloom.textures.length;
            for (let i = 1, divisor = 2; i < iterations; i++, divisor *= 2) {
                let width = Math.max(Math.round(canvasWidth / divisor), 1);
                let height = Math.max(Math.round(canvasHeight / divisor), 1);
                crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGLComponentBloom.fbos[i]);
                crc3.viewport(0, 0, width, height);
                FudgeCore.RenderWebGL.clear();
                FudgeCore.RenderWebGL.bindTexture(FudgeCore.ShaderBloom, RenderWebGLComponentBloom.textures[i - 1], WebGL2RenderingContext.TEXTURE0, "u_texSource");
                crc3.uniform1i(FudgeCore.ShaderBloom.uniforms["u_iMode"], 1);
                crc3.uniform2f(FudgeCore.ShaderBloom.uniforms["u_vctTexel"], 0.5 / width, 0.5 / height); // half texel size
                crc3.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, 3);
            }
            FudgeCore.RenderWebGL.setBlendMode(FudgeCore.BLEND.ADDITIVE);
            // upsample
            for (let i = iterations - 1, divisor = 2 ** (iterations - 2); i > 0; i--, divisor /= 2) {
                let width = Math.max(Math.round(canvasWidth / divisor), 1);
                let height = Math.max(Math.round(canvasHeight / divisor), 1);
                crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGLComponentBloom.fbos[i - 1]);
                crc3.viewport(0, 0, Math.round(width), Math.round(height));
                FudgeCore.RenderWebGL.bindTexture(FudgeCore.ShaderBloom, RenderWebGLComponentBloom.textures[i], WebGL2RenderingContext.TEXTURE0, "u_texSource");
                crc3.uniform1i(FudgeCore.ShaderBloom.uniforms["u_iMode"], 2);
                crc3.uniform2f(FudgeCore.ShaderBloom.uniforms["u_vctTexel"], 0.5 / width, 0.5 / height); // half texel size
                crc3.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, 3);
            }
            crc3.viewport(0, 0, canvasWidth, canvasHeight);
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGLComponentBloom.fboOut);
            FudgeCore.RenderWebGL.bindTexture(FudgeCore.ShaderBloom, RenderWebGLComponentBloom.textures[0], WebGL2RenderingContext.TEXTURE0, "u_texSource");
            crc3.uniform1i(FudgeCore.ShaderBloom.uniforms["u_iMode"], 3);
            crc3.uniform1f(FudgeCore.ShaderBloom.uniforms["u_fIntensity"], _cmpBloom.intensity);
            crc3.uniform1f(FudgeCore.ShaderBloom.uniforms["u_fHighlightDesaturation"], _cmpBloom.highlightDesaturation);
            crc3.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, 3);
            FudgeCore.RenderWebGL.setBlendMode(FudgeCore.BLEND.TRANSPARENT);
        }
        /**
         * Resize the render attachments.
         */
        static resize(_renderWebGL, _width, _height) {
            const crc3 = _renderWebGL.getRenderingContext();
            const canvasWidth = _width || 1;
            const canvasHeight = _height || 1;
            for (let i = 0, divisor = 1; i < RenderWebGLComponentBloom.textures.length; i++, divisor *= 2) {
                let width = Math.max(Math.round(canvasWidth / divisor), 1);
                let height = Math.max(Math.round(canvasHeight / divisor), 1);
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGLComponentBloom.textures[i]);
                crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, width, height, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, null);
            }
            crc3.bindTexture(crc3.TEXTURE_2D, null);
        }
    }
    FudgeCore.RenderWebGLComponentBloom = RenderWebGLComponentBloom;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles the {@link ComponentOutline outline} post-processing effect.
     * @internal
     * @authors Jonas Plotzky, HFU, 2025
     */
    class RenderWebGLComponentOutline {
        /**
         * Initialize framebuffers and render attachments.
         */
        static initialize(_renderWebGL) {
            const crc3 = _renderWebGL.getRenderingContext();
            RenderWebGLComponentOutline.texDepthStencil = _renderWebGL.createTexture(WebGL2RenderingContext.NEAREST, WebGL2RenderingContext.CLAMP_TO_EDGE);
            RenderWebGLComponentOutline.fboDepthPass = _renderWebGL.assert(crc3.createFramebuffer());
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGLComponentOutline.fboDepthPass);
            crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.DEPTH_STENCIL_ATTACHMENT, WebGL2RenderingContext.TEXTURE_2D, RenderWebGLComponentOutline.texDepthStencil, 0);
            RenderWebGLComponentOutline.texOut = _renderWebGL.texColor;
            RenderWebGLComponentOutline.fboOut = _renderWebGL.assert(crc3.createFramebuffer());
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGLComponentOutline.fboOut);
            crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, RenderWebGLComponentOutline.texOut, 0);
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, null);
        }
        /**
         * Draw the outline effect.
         */
        static draw(_nodes, _cmpCamera, _cmpOutline) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGLComponentOutline.fboDepthPass);
            FudgeCore.RenderWebGL.clear();
            crc3.disable(WebGL2RenderingContext.BLEND);
            for (let selected of _nodes)
                for (const node of selected) {
                    if (node.getComponent(FudgeCore.ComponentMesh)?.isActive && node.getComponent(FudgeCore.ComponentMaterial)?.isActive)
                        FudgeCore.RenderWebGL.drawNode(node, _cmpCamera);
                }
            crc3.enable(WebGL2RenderingContext.BLEND);
            FudgeCore.ShaderOutline.useProgram();
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGLComponentOutline.fboOut);
            FudgeCore.RenderWebGL.bindTexture(FudgeCore.ShaderOutline, RenderWebGLComponentOutline.texDepthStencil, WebGL2RenderingContext.TEXTURE0, "u_texDepthOutline");
            FudgeCore.RenderWebGL.bindTexture(FudgeCore.ShaderOutline, FudgeCore.RenderWebGL.texDepthStencil, WebGL2RenderingContext.TEXTURE1, "u_texDepthScene");
            crc3.uniform4fv(FudgeCore.ShaderOutline.uniforms["u_vctColor"], _cmpOutline.color.get());
            crc3.uniform4fv(FudgeCore.ShaderOutline.uniforms["u_vctColorOccluded"], _cmpOutline.colorOccluded.get());
            const rectCanvas = FudgeCore.RenderWebGL.getCanvasRectangle();
            crc3.uniform2f(FudgeCore.ShaderOutline.uniforms["u_vctTexel"], 1 / Math.round(rectCanvas.width), 1 / Math.round(rectCanvas.height)); // half texel size
            crc3.drawArrays(WebGL2RenderingContext.TRIANGLES, 0, 3);
        }
        /**
         * Resize the render attachments.
         */
        static resize(_renderWebGL, _width, _height) {
            const crc3 = _renderWebGL.getRenderingContext();
            const canvasWidth = _width || 1;
            const canvasHeight = _height || 1;
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGLComponentOutline.texDepthStencil);
            crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.DEPTH24_STENCIL8, canvasWidth, canvasHeight, 0, WebGL2RenderingContext.DEPTH_STENCIL, WebGL2RenderingContext.UNSIGNED_INT_24_8, null);
        }
    }
    FudgeCore.RenderWebGLComponentOutline = RenderWebGLComponentOutline;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Gives WebGL Buffer the data from the {@link Shader}
     * @internal
     */
    class RenderInjectorShader {
        /**
         * Injects the functionality of this class into the constructor of the given {@link Shader}-subclass
         */
        static decorate(_constructor, _context) {
            Object.defineProperty(_constructor, _constructor.useProgram.name, {
                value: RenderInjectorShader.useProgram
            });
            Object.defineProperty(_constructor, _constructor.createProgram.name, {
                value: RenderInjectorShader.createProgram
            });
            Object.defineProperty(_constructor, _constructor.deleteProgram.name, {
                value: RenderInjectorShader.deleteProgram
            });
        }
        /**
         * Set this program to use as the active program in WebGL
         */
        static useProgram() {
            if (!this.program)
                this.createProgram();
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.useProgram(this.program);
        }
        /**
         * Deletes this program from WebGL, clearing the used memory on the GPU.
         */
        static deleteProgram() {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.program) {
                crc3.deleteProgram(this.program);
                delete this.uniforms;
                delete this.program;
            }
        }
        static createProgram() {
            FudgeCore.Debug.fudge("Create shader program", this.name);
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            let program = crc3.createProgram();
            try {
                let shdVertex = compileShader(this.getVertexShaderSource(), WebGL2RenderingContext.VERTEX_SHADER);
                let shdFragment = compileShader(this.getFragmentShaderSource(), WebGL2RenderingContext.FRAGMENT_SHADER);
                crc3.attachShader(program, FudgeCore.RenderWebGL.assert(shdVertex));
                crc3.attachShader(program, FudgeCore.RenderWebGL.assert(shdFragment));
                crc3.linkProgram(program);
                let error = FudgeCore.RenderWebGL.assert(crc3.getProgramInfoLog(program));
                if (error !== "") {
                    throw new Error("Error linking Shader: " + error);
                }
                this.program = program;
                this.uniforms = detectUniforms();
                bindUniformBlock(program, FudgeCore.UNIFORM_BLOCK.LIGHTS.NAME, FudgeCore.UNIFORM_BLOCK.LIGHTS.BINDING);
                bindUniformBlock(program, FudgeCore.UNIFORM_BLOCK.CAMERA.NAME, FudgeCore.UNIFORM_BLOCK.CAMERA.BINDING);
                bindUniformBlock(program, FudgeCore.UNIFORM_BLOCK.MATERIAL.NAME, FudgeCore.UNIFORM_BLOCK.MATERIAL.BINDING);
                bindUniformBlock(program, FudgeCore.UNIFORM_BLOCK.NODE.NAME, FudgeCore.UNIFORM_BLOCK.NODE.BINDING);
                bindUniformBlock(program, FudgeCore.UNIFORM_BLOCK.SKIN.NAME, FudgeCore.UNIFORM_BLOCK.SKIN.BINDING);
                bindUniformBlock(program, FudgeCore.UNIFORM_BLOCK.FOG.NAME, FudgeCore.UNIFORM_BLOCK.FOG.BINDING);
                crc3.useProgram(this.program);
                let uniform = this.uniforms[FudgeCore.TEXTURE_LOCATION.COLOR.UNIFORM];
                if (uniform)
                    crc3.uniform1i(uniform, FudgeCore.TEXTURE_LOCATION.COLOR.INDEX);
                uniform = this.uniforms[FudgeCore.TEXTURE_LOCATION.NORMAL.UNIFORM];
                if (uniform)
                    crc3.uniform1i(uniform, FudgeCore.TEXTURE_LOCATION.NORMAL.INDEX);
                uniform = this.uniforms[FudgeCore.TEXTURE_LOCATION.TOON.UNIFORM];
                if (uniform)
                    crc3.uniform1i(uniform, FudgeCore.TEXTURE_LOCATION.TOON.INDEX);
                uniform = this.uniforms[FudgeCore.TEXTURE_LOCATION.PARTICLE.UNIFORM];
                if (uniform)
                    crc3.uniform1i(uniform, FudgeCore.TEXTURE_LOCATION.PARTICLE.INDEX);
            }
            catch (_error) {
                FudgeCore.Debug.error(_error);
                debugger;
            }
            function compileShader(_shaderCode, _shaderType) {
                let webGLShader = crc3.createShader(_shaderType);
                crc3.shaderSource(webGLShader, _shaderCode);
                crc3.compileShader(webGLShader);
                let error = FudgeCore.RenderWebGL.assert(crc3.getShaderInfoLog(webGLShader));
                if (error !== "") {
                    FudgeCore.Debug.log(_shaderCode);
                    throw new Error("Error compiling shader: " + error);
                }
                // Check for any compilation errors.
                if (!crc3.getShaderParameter(webGLShader, WebGL2RenderingContext.COMPILE_STATUS)) {
                    alert(crc3.getShaderInfoLog(webGLShader));
                    return null;
                }
                return webGLShader;
            }
            function detectUniforms() {
                let detectedUniforms = {};
                let uniformCount = crc3.getProgramParameter(program, WebGL2RenderingContext.ACTIVE_UNIFORMS);
                for (let i = 0; i < uniformCount; i++) {
                    let info = FudgeCore.RenderWebGL.assert(crc3.getActiveUniform(program, i));
                    if (!info) {
                        break;
                    }
                    let location = crc3.getUniformLocation(program, info.name);
                    if (location)
                        detectedUniforms[info.name] = FudgeCore.RenderWebGL.assert(location);
                }
                return detectedUniforms;
            }
            function bindUniformBlock(_program, _uniformBlockName, _uniformBlockBinding) {
                let blockIndex = crc3.getUniformBlockIndex(_program, _uniformBlockName);
                if (blockIndex == WebGL2RenderingContext.INVALID_INDEX)
                    return;
                let referencedByVertexShader = crc3.getActiveUniformBlockParameter(_program, blockIndex, WebGL2RenderingContext.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER);
                let referencedByFragmentShader = crc3.getActiveUniformBlockParameter(_program, blockIndex, WebGL2RenderingContext.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER);
                if (!referencedByVertexShader && !referencedByFragmentShader)
                    return;
                crc3.uniformBlockBinding(_program, blockIndex, _uniformBlockBinding);
            }
        }
    }
    FudgeCore.RenderInjectorShader = RenderInjectorShader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Buffers the data from the {@link Mesh} into a WebGL Buffer
     * @internal
     */
    class RenderInjectorMesh {
        /**
         * Injects the functionality of this class into the constructor of the given {@link Mesh}-subclass
         */
        static decorate(_constructor, _context) {
            Object.defineProperty(_constructor.prototype, _constructor.prototype.useRenderBuffers.name, {
                value: RenderInjectorMesh.useRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, _constructor.prototype.getRenderBuffers.name, {
                value: RenderInjectorMesh.getRenderBuffers
            });
            Object.defineProperty(_constructor.prototype, _constructor.prototype.deleteRenderBuffers.name, {
                value: RenderInjectorMesh.deleteRenderBuffers
            });
        }
        static getRenderBuffers() {
            let buffers = this.renderMesh.buffers;
            if (buffers)
                return buffers;
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            const vao = FudgeCore.RenderWebGL.assert(crc3.createVertexArray());
            crc3.bindVertexArray(vao);
            buffers = {
                indices: createBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, this.renderMesh.indices),
                positions: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.positions),
                normals: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.normals),
                textureUVs: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.textureUVs),
                colors: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.colors),
                tangents: createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.tangents),
                nIndices: this.renderMesh.indices.length,
                vao: vao
            };
            if (this.renderMesh.bones)
                buffers.bones = createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.bones);
            if (this.renderMesh.weights)
                buffers.weights = createBuffer(WebGL2RenderingContext.ARRAY_BUFFER, this.renderMesh.weights);
            setAttributeBuffer(buffers.positions, FudgeCore.SHADER_ATTRIBUTE.POSITION, 3, WebGL2RenderingContext.FLOAT);
            setAttributeBuffer(buffers.normals, FudgeCore.SHADER_ATTRIBUTE.NORMAL, 3, WebGL2RenderingContext.FLOAT);
            setAttributeBuffer(buffers.textureUVs, FudgeCore.SHADER_ATTRIBUTE.TEXCOORDS, 2, WebGL2RenderingContext.FLOAT);
            setAttributeBuffer(buffers.colors, FudgeCore.SHADER_ATTRIBUTE.COLOR, 4, WebGL2RenderingContext.FLOAT);
            setAttributeBuffer(buffers.tangents, FudgeCore.SHADER_ATTRIBUTE.TANGENT, 4, WebGL2RenderingContext.FLOAT);
            if (buffers.bones)
                setAttributeBuffer(buffers.bones, FudgeCore.SHADER_ATTRIBUTE.BONES, 4, WebGL2RenderingContext.UNSIGNED_BYTE);
            if (buffers.weights)
                setAttributeBuffer(buffers.weights, FudgeCore.SHADER_ATTRIBUTE.WEIGHTS, 4, WebGL2RenderingContext.FLOAT);
            return this.renderMesh.buffers = buffers;
            function createBuffer(_type, _array) {
                let buffer = FudgeCore.RenderWebGL.assert(crc3.createBuffer());
                crc3.bindBuffer(_type, buffer);
                crc3.bufferData(_type, _array, WebGL2RenderingContext.STATIC_DRAW);
                return buffer;
            }
            function setAttributeBuffer(_buffer, _location, _size, _type) {
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, _buffer);
                crc3.enableVertexAttribArray(_location);
                if (_type == WebGL2RenderingContext.FLOAT)
                    crc3.vertexAttribPointer(_location, _size, _type, false, 0, 0);
                if (_type == WebGL2RenderingContext.UNSIGNED_BYTE)
                    crc3.vertexAttribIPointer(_location, _size, _type, 0, 0);
            }
        }
        static useRenderBuffers() {
            const buffers = this.getRenderBuffers();
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindVertexArray(buffers.vao);
            return buffers;
        }
        static deleteRenderBuffers(_renderBuffers) {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (_renderBuffers) {
                crc3.deleteVertexArray(_renderBuffers.vao);
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, null);
                crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, null);
                Object.values(_renderBuffers)
                    .filter(_value => _value instanceof WebGLBuffer)
                    .forEach(_buffer => crc3.deleteBuffer(_buffer));
            }
        }
    }
    FudgeCore.RenderInjectorMesh = RenderInjectorMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let ParticleData;
    (function (ParticleData) {
        let FUNCTION;
        (function (FUNCTION) {
            // VALUE = "value",
            FUNCTION["ADDITION"] = "addition";
            FUNCTION["SUBTRACTION"] = "subtraction";
            FUNCTION["MULTIPLICATION"] = "multiplication";
            FUNCTION["DIVISION"] = "division";
            FUNCTION["MODULO"] = "modulo";
            FUNCTION["POWER"] = "power";
            FUNCTION["POLYNOMIAL3"] = "polynomial3";
            FUNCTION["SQUARE_ROOT"] = "squareRoot";
            FUNCTION["RANDOM"] = "random";
            FUNCTION["RANDOM_RANGE"] = "randomRange";
        })(FUNCTION = ParticleData.FUNCTION || (ParticleData.FUNCTION = {}));
        ParticleData.FUNCTION_MINIMUM_PARAMETERS = {
            // [ParticleData.FUNCTION.VALUE]: 1,
            [ParticleData.FUNCTION.ADDITION]: 2,
            [ParticleData.FUNCTION.SUBTRACTION]: 2,
            [ParticleData.FUNCTION.MULTIPLICATION]: 2,
            [ParticleData.FUNCTION.DIVISION]: 2,
            [ParticleData.FUNCTION.MODULO]: 2,
            [ParticleData.FUNCTION.POWER]: 2,
            [ParticleData.FUNCTION.POLYNOMIAL3]: 5,
            [ParticleData.FUNCTION.SQUARE_ROOT]: 1,
            [ParticleData.FUNCTION.RANDOM]: 0,
            [ParticleData.FUNCTION.RANDOM_RANGE]: 2
        };
        ParticleData.PREDEFINED_VARIABLES = {
            systemDuration: "u_fParticleSystemDuration",
            systemSize: "u_fParticleSystemSize",
            systemTime: "u_fParticleSystemTime",
            particleId: "fParticleId"
        };
    })(ParticleData = FudgeCore.ParticleData || (FudgeCore.ParticleData = {}));
    /**
     * Compiles particle system shaders ({@link ShaderParticleSystem}) from shader universal derivates for WebGL
     * @authors Jonas Plotzky, HFU, 2022
     * @internal
     */
    class RenderInjectorShaderParticleSystem {
        static { this.FUNCTIONS = {
            // [ParticleData.FUNCTION.VALUE]: (_parameters: string[]) => {
            //   return `(${_parameters[0]})`;
            // },
            [ParticleData.FUNCTION.ADDITION]: (_parameters) => {
                return `(${_parameters.reduce((_accumulator, _value) => `${_accumulator} + ${_value}`)})`;
            },
            [ParticleData.FUNCTION.SUBTRACTION]: (_parameters) => {
                return `(${_parameters.reduce((_accumulator, _value) => `${_accumulator} - ${_value}`)})`;
            },
            [ParticleData.FUNCTION.MULTIPLICATION]: (_parameters) => {
                return `(${_parameters.reduce((_accumulator, _value) => `${_accumulator} * ${_value}`)})`;
            },
            [ParticleData.FUNCTION.DIVISION]: (_parameters) => {
                return `(${_parameters[0]} / ${_parameters[1]})`;
            },
            [ParticleData.FUNCTION.MODULO]: (_parameters) => {
                return `(${_parameters.reduce((_accumulator, _value) => `mod(${_accumulator}, ${_value})`)})`;
            },
            [ParticleData.FUNCTION.POWER]: (_parameters) => {
                return `pow(${_parameters[0]}, ${_parameters[1]})`;
            },
            [ParticleData.FUNCTION.POLYNOMIAL3]: (_parameters) => {
                let x = _parameters[0];
                let a = _parameters[1];
                let b = _parameters[2];
                let c = _parameters[3];
                let d = _parameters[4];
                return `(${a} * pow(${x}, 3.0) + ${b} * pow(${x}, 2.0) + ${c} * ${x} + ${d})`;
            },
            [ParticleData.FUNCTION.SQUARE_ROOT]: (_parameters) => {
                let x = _parameters[0];
                return `sqrt(${x})`;
            },
            [ParticleData.FUNCTION.RANDOM]: (_parameters) => {
                return `fetchRandomNumber(${(RenderInjectorShaderParticleSystem.randomNumberIndexOffset++).toFixed(0)}, iParticleSystemRandomNumbersSize, iParticleSystemRandomNumbersLength)`;
            },
            [ParticleData.FUNCTION.RANDOM_RANGE]: (_parameters) => {
                return `(${RenderInjectorShaderParticleSystem.FUNCTIONS["random"]()} * (${_parameters[1]} - ${_parameters[0]}) + ${_parameters[0]})`;
            }
        }; }
        static { this.randomNumberIndexOffset = 0; }
        static decorate(_constructor, _context) {
            FudgeCore.RenderInjectorShader.decorate(_constructor.prototype, _context);
            Object.defineProperty(_constructor.prototype, _constructor.prototype.getVertexShaderSource.name, {
                value: RenderInjectorShaderParticleSystem.getVertexShaderSource
            });
            Object.defineProperty(_constructor.prototype, _constructor.prototype.getFragmentShaderSource.name, {
                value: RenderInjectorShaderParticleSystem.getFragmentShaderSource
            });
        }
        /**
         * Generates the source code for the vertex shader of the {@link ShaderParticleSystem} from the set {@link ShaderParticleSystem.data} and the original {@link ShaderParticleSystem.vertexShaderSource}.
         */
        static getVertexShaderSource() {
            let data = this.data;
            let mtxLocal = data?.mtxLocal;
            let mtxWorld = data?.mtxWorld;
            RenderInjectorShaderParticleSystem.randomNumberIndexOffset = 0;
            let source = this.vertexShaderSource
                .replace("#version 300 es", `#version 300 es\n#define ${this.define[0]}${data.color ? "\n#define PARTICLE_COLOR" : ""}`)
                .replace("/*$variables*/", RenderInjectorShaderParticleSystem.generateVariables(data?.variables, data?.variableNames))
                .replace("/*$mtxLocal*/", RenderInjectorShaderParticleSystem.generateTransformations(mtxLocal, "Local"))
                .replace("/*$mtxLocal*/", mtxLocal && mtxLocal.length > 0 ? "* mtxLocal" : "")
                .replace("/*$mtxWorld*/", RenderInjectorShaderParticleSystem.generateTransformations(mtxWorld, "World"))
                .replace("/*$mtxWorld*/", mtxWorld && mtxWorld.length > 0 ? "mtxWorld *" : "")
                .replaceAll("/*$color*/", RenderInjectorShaderParticleSystem.generateColor(data?.color));
            return source;
        }
        /**
         * Generates the source code for the fragment shader of the {@link ShaderParticleSystem} from the set {@link ShaderParticleSystem.data} and the original {@link ShaderParticleSystem.fragmentShaderSource}.
         */
        static getFragmentShaderSource() {
            return this.fragmentShaderSource.replace("#version 300 es", `#version 300 es\n#define ${this.define[0]}${this.data.color ? "\n#define PARTICLE_COLOR" : ""}`);
        }
        //#region code generation
        static generateVariables(_variables, _variableNames) {
            if (!_variables)
                return "";
            return _variables
                .map((_variable, _index) => ({ name: "fParticleSystemVariable_" + _variableNames[_index], value: RenderInjectorShaderParticleSystem.generateExpression(_variable) }))
                .map(_variable => `float ${_variable.name} = ${_variable.value};`)
                .reduce((_accumulator, _code) => `${_accumulator}\n${_code}`, "");
        }
        static generateTransformations(_transformations, _localOrWorld) {
            if (!_transformations || _transformations.length == 0)
                return "";
            let transformations = _transformations
                .map(_data => {
                let isScale = _data.transformation === "scale";
                let [x, y, z] = [_data.parameters[0], _data.parameters[1], _data.parameters[2]]
                    .map((_value) => _value ? RenderInjectorShaderParticleSystem.generateExpression(_value) : (isScale ? "1.0" : "0.0"));
                return [_data.transformation, x, y, z];
            });
            let code = "";
            code += transformations
                .map(([_transformation, _x, _y, _z], _index) => {
                let rotateId = _index + _localOrWorld;
                if (_transformation == "rotate") {
                    let toRadians = (_value) => `${_value} * ${FudgeCore.Calc.deg2rad}`;
                    return `float fXRadians${rotateId} = ${toRadians(_x)};
              float fYRadians${rotateId} = ${toRadians(_y)};
              float fZRadians${rotateId} = ${toRadians(_z)};
              float fSinX${rotateId} = sin(fXRadians${rotateId});
              float fCosX${rotateId} = cos(fXRadians${rotateId}); 
              float fSinY${rotateId} = sin(fYRadians${rotateId});
              float fCosY${rotateId} = cos(fYRadians${rotateId});
              float fSinZ${rotateId} = sin(fZRadians${rotateId});
              float fCosZ${rotateId} = cos(fZRadians${rotateId});\n`;
                }
                else
                    return "";
            })
                .filter((_transformation) => _transformation != "")
                .reduce((_accumulator, _code) => `${_accumulator}\n${_code}`, "");
            code += "\n";
            code += `mat4 mtx${_localOrWorld} = `;
            code += transformations
                .map(([_transformation, _x, _y, _z], _index) => {
                let rotateId = _index + _localOrWorld;
                switch (_transformation) {
                    case "translate":
                        return `mat4(
              1.0, 0.0, 0.0, 0.0,
              0.0, 1.0, 0.0, 0.0,
              0.0, 0.0, 1.0, 0.0,
              ${_x}, ${_y}, ${_z}, 1.0)`;
                    case "rotate":
                        return `mat4(
              fCosZ${rotateId} * fCosY${rotateId}, fSinZ${rotateId} * fCosY${rotateId}, -fSinY${rotateId}, 0.0,
              fCosZ${rotateId} * fSinY${rotateId} * fSinX${rotateId} - fSinZ${rotateId} * fCosX${rotateId}, fSinZ${rotateId} * fSinY${rotateId} * fSinX${rotateId} + fCosZ${rotateId} * fCosX${rotateId}, fCosY${rotateId} * fSinX${rotateId}, 0.0,
              fCosZ${rotateId} * fSinY${rotateId} * fCosX${rotateId} + fSinZ${rotateId} * fSinX${rotateId}, fSinZ${rotateId} * fSinY${rotateId} * fCosX${rotateId} - fCosZ${rotateId} * fSinX${rotateId}, fCosY${rotateId} * fCosX${rotateId}, 0.0,
              0.0, 0.0, 0.0, 1.0
              )`;
                    case "scale":
                        return `mat4(
              ${_x}, 0.0, 0.0, 0.0,
              0.0, ${_y}, 0.0, 0.0,
              0.0, 0.0, ${_z}, 0.0,
              0.0, 0.0, 0.0, 1.0
              )`;
                    default:
                        throw `Error in ${FudgeCore.ParticleSystem.name}: "${_transformation}" is not a transformation`;
                }
            })
                .reduce((_accumulator, _code) => `${_accumulator} * \n${_code}`);
            code += ";\n";
            return code;
        }
        static generateColor(_color) {
            if (!_color)
                return "";
            let rgba = [_color[0], _color[1], _color[2], _color[3]]
                .map((_value) => _value ? RenderInjectorShaderParticleSystem.generateExpression(_value) : "1.0")
                .join(", ");
            return `vec4(${rgba});`;
        }
        static generateExpression(_expression) {
            if (ParticleData.isFunction(_expression)) {
                let parameters = [];
                for (let param of _expression.parameters) {
                    parameters.push(RenderInjectorShaderParticleSystem.generateExpression(param));
                }
                return RenderInjectorShaderParticleSystem.generateFunction(_expression.function, parameters);
            }
            if (ParticleData.isVariable(_expression)) {
                return ParticleData.PREDEFINED_VARIABLES[_expression.value] || "fParticleSystemVariable_" + _expression.value;
            }
            if (ParticleData.isConstant(_expression)) {
                let value = _expression.value.toString();
                return `${value}${value.includes(".") ? "" : ".0"}`;
            }
            if (ParticleData.isCode(_expression)) {
                let code = _expression.code
                    .replaceAll(/\b[a-zA-z]+\w*(?!\()\b/g, (_match) => ParticleData.PREDEFINED_VARIABLES[_match] || "fParticleSystemVariable_" + _match)
                    .replaceAll(/(?<!\.)\b\d+\b(?!\.)/g, (_match) => _match + ".0");
                code = RenderInjectorShaderParticleSystem.replaceFunctions(code);
                return code;
            }
            throw `Error in ${FudgeCore.ParticleSystem.name}: invalid node structure in particle system serialization`;
        }
        static generateFunction(_function, _parameters) {
            if (_parameters.length < ParticleData.FUNCTION_MINIMUM_PARAMETERS[_function])
                throw `Error in ${FudgeCore.ParticleSystem.name}: "${_function}" needs at least ${ParticleData.FUNCTION_MINIMUM_PARAMETERS[_function]} parameters`;
            if (Object.values(ParticleData.FUNCTION).includes(_function))
                return RenderInjectorShaderParticleSystem.FUNCTIONS[_function](_parameters);
            else
                throw `Error in ${FudgeCore.ParticleSystem.name}: "${_function}" is not an operation`;
        }
        static replaceFunctions(_code) {
            let functionRegex = /\b[a-zA-z_]+\w*\(/g;
            let match;
            while ((match = functionRegex.exec(_code)) != null) {
                let functionGenerator = RenderInjectorShaderParticleSystem.FUNCTIONS[match[0].slice(0, -1)];
                if (!functionGenerator)
                    continue;
                let commaIndices = [];
                let openBrackets = 1;
                let argumentsLastIndex = functionRegex.lastIndex;
                while (openBrackets > 0) {
                    switch (_code[argumentsLastIndex]) {
                        case "(":
                            openBrackets++;
                            break;
                        case ")":
                            openBrackets--;
                            break;
                        case ",":
                            if (openBrackets == 1)
                                commaIndices.push(argumentsLastIndex);
                            break;
                    }
                    argumentsLastIndex++;
                }
                let args = [functionRegex.lastIndex - 1, ...commaIndices, argumentsLastIndex - 1].reduce((_accumulator, _position, _index, _positions) => {
                    return _index == _positions.length - 1 ?
                        _accumulator :
                        _accumulator.concat(_code.slice(_position + 1, _positions[_index + 1]).trim());
                }, []);
                functionRegex.lastIndex = match.index;
                _code = `${_code.slice(0, match.index)}(${functionGenerator(args)})${_code.slice(argumentsLastIndex)}`;
            }
            return _code;
        }
    }
    FudgeCore.RenderInjectorShaderParticleSystem = RenderInjectorShaderParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Buffers the random number data for the particle system ({@link ComponentParticleSystem}) into a WebGL Texture
     * @authors Jonas Plotzky, HFU, 2022
     * @internal
     */
    class RenderInjectorComponentParticleSystem {
        /**
         * Replaces the decorated method with the static method of the same name of class. Used in {@link ComponentParticleSystem}
         */
        static decorate(_method, _context) {
            return Reflect.get(this, _context.name);
        }
        static useRenderData() {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.renderData) {
                crc3.activeTexture(FudgeCore.TEXTURE_LOCATION.PARTICLE.UNIT); // ATTENTION!: changing this id requires changing of corresponding id in particle render method, use ctrl + shift + f search!
                crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.renderData);
                return;
            }
            const texture = FudgeCore.Render.assert(crc3.createTexture());
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
            let textureSize = Math.ceil(Math.sqrt(this.size));
            textureSize = Math.min(textureSize, crc3.getParameter(crc3.MAX_TEXTURE_SIZE));
            // TODO: use internal random number generator, additionally maybe use a seed to make it possible to recreate the same random numbers
            let randomNumbers = [];
            for (let i = 0; i < textureSize * textureSize; i++)
                randomNumbers.push(Math.random());
            try {
                crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.R32F, textureSize, textureSize, 0, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT, Float32Array.from(randomNumbers));
            }
            catch (_error) {
                FudgeCore.Debug.error(_error);
            }
            crc3.texParameteri(crc3.TEXTURE_2D, crc3.TEXTURE_MIN_FILTER, crc3.NEAREST);
            crc3.texParameteri(crc3.TEXTURE_2D, crc3.TEXTURE_MAG_FILTER, crc3.NEAREST);
            this.renderData = texture;
            this.useRenderData();
        }
        static deleteRenderData() {
            if (!this.renderData)
                return;
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
            crc3.deleteTexture(this.renderData);
            delete this.renderData;
        }
    }
    FudgeCore.RenderInjectorComponentParticleSystem = RenderInjectorComponentParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Keeps a depot of objects that have been marked for reuse, sorted by type.
     * Using {@link Recycler} reduces load on the carbage collector and thus supports smooth performance.
     * @author Jirka Dell'Oro-Friedl, HFU, 2021
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Recycler
     */
    class Recycler {
        static { this.depot = {}; }
        /**
         * Fetches an object of the requested type from the depot, calls its recycle-method and returns it.
         * If the depot for that type is empty it returns a new object of the requested type.
         * @param _t The class identifier of the desired object
         */
        static get(_t) {
            let instances = Recycler.depot[_t.name];
            if (instances?.length > 0) {
                let instance = instances.pop();
                instance.recycle?.();
                return instance;
            }
            else
                return new _t();
        }
        /**
         * Fetches an object of the requested type from the depot and returns it. ‚ö†Ô∏è**DOES NOT** call its recycle-method.
         * Faster than {@link Recycler.get}, but should be used with caution.
         */
        static reuse(_t) {
            return Recycler.depot[_t.name]?.pop() ?? new _t();
        }
        /**
         * Stores the object in the depot for later recycling. Users are responsible for throwing in objects that are about to loose scope and are not referenced by any other
         * @param _instance
         */
        static store(_instance) {
            (Recycler.depot[_instance.constructor.name] ??= new FudgeCore.RecycableArray()).push(_instance);
        }
        /**
         * Emptys the depot of a given type, leaving the objects for the garbage collector. May result in a short stall when many objects were in
         * @param _t
         */
        static dump(_t) {
            Recycler.depot[_t.name] = new FudgeCore.RecycableArray();
        }
        /**
         * Emptys all depots, leaving all objects to the garbage collector. May result in a short stall when many objects were in
         */
        static dumpAll() {
            Recycler.depot = {};
        }
    }
    FudgeCore.Recycler = Recycler;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a twodimensional vector comprised of the components x and y
     * ```text
     *            +y
     *             |__ +x
     * ```
     * @authors Lukas Scheuerle, Jirka Dell'Oro-Friedl, HFU, 2019 | Jonas Plotzky, HFU, 2025
     */
    class Vector2 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0) {
            super();
            this.set(_x, _y);
        }
        //#region Static
        /**
         * A shorthand for writing `new Vector2(0, 0)`.
         * @returns A new vector with the values (0, 0)
         */
        static ZERO() {
            return FudgeCore.Recycler.get(Vector2);
        }
        /**
         * A shorthand for writing `new Vector2(_scale, _scale)`.
         * @param _scale the scale of the vector. Default: 1
         */
        static ONE(_scale = 1) {
            return FudgeCore.Recycler.reuse(Vector2).set(_scale, _scale);
        }
        /**
         * A shorthand for writing `new Vector2(x, 0)`.
         * @param _scale The number to write in the x coordinate. Default: 1
         * @returns A new vector with the values (_scale, 0)
         */
        static X(_scale = 1) {
            return FudgeCore.Recycler.reuse(Vector2).set(_scale, 0);
        }
        /**
         * A shorthand for writing `new Vector2(0, y)`.
         * @param _scale The number to write in the y coordinate. Default: 1
         * @returns A new vector with the values (0, _scale)
         */
        static Y(_scale = 1) {
            return FudgeCore.Recycler.reuse(Vector2).set(0, _scale);
        }
        /**
         * Creates and returns a vector through transformation of the given vector by the given matrix
         * @param _out Optional vector to store the result in.
         */
        static TRANSFORMATION(_vector, _mtxTransform, _includeTranslation = true, _out = FudgeCore.Recycler.reuse(Vector2)) {
            let m = _mtxTransform.getArray();
            _out.set(m[0] * _vector.x + m[3] * _vector.y, m[1] * _vector.x + m[4] * _vector.y);
            if (_includeTranslation)
                _out.add(_mtxTransform.translation);
            return _out;
        }
        /**
         * Creates and returns a vector which is a copy of the given vector scaled to the given length.
         * @param _out Optional vector to store the result in.
         */
        static NORMALIZATION(_vector, _length = 1, _out = FudgeCore.Recycler.reuse(Vector2)) {
            return _out.copy(_vector).normalize(_length);
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor
         * @param _out Optional vector to store the result in.
         */
        static SCALE(_vector, _scale, _out = FudgeCore.Recycler.reuse(Vector2)) {
            return _out.set(_vector.x * _scale, _vector.y * _scale);
        }
        /**
         * Returns the result of the addition of two vectors.
         * @param _out Optional vector to store the result in.
         */
        static SUM(_a, _b, _out = FudgeCore.Recycler.reuse(Vector2)) {
            return _out.set(_a.x + _b.x, _a.y + _b.y);
        }
        /**
         * Returns the result of the subtraction of two vectors.
         * @param _out Optional vector to store the result in.
         */
        static DIFFERENCE(_minuend, _subtrahend, _out = FudgeCore.Recycler.reuse(Vector2)) {
            return _out.set(_minuend.x - _subtrahend.x, _minuend.y - _subtrahend.y);
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor.
         * @param _out Optional vector to store the result in.
         */
        static NEGATION(_vector, _out = FudgeCore.Recycler.reuse(Vector2)) {
            return _out.set(-_vector.x, -_vector.y);
        }
        /**
         * Calculates the cross product of two Vectors. Due to them being only 2 Dimensional, the result is a single number,
         * which implicitly is on the Z axis. It is also the signed magnitude of the result.
         */
        static CROSS(_a, _b) {
            return _a.x * _b.y - _a.y * _b.x;
        }
        /**
         * Computes the dotproduct of 2 vectors.
         */
        static DOT(_a, _b) {
            return _a.x * _b.x + _a.y * _b.y;
        }
        /**
         * Calculates the orthogonal vector to the given vector. Rotates counterclockwise by default.
         * ```text
         * ‚Üë => ‚Üê => ‚Üì => ‚Üí => ‚Üë
         * ```
         * @param _vector Vector to get the orthogonal equivalent of
         * @param _clockwise Should the rotation be clockwise instead of the default counterclockwise? default: false
         * @param _out Optional vector to store the result in.
         * @returns A Vector that is orthogonal to and has the same magnitude as the given Vector.
         */
        static ORTHOGONAL(_vector, _clockwise = false, _out = FudgeCore.Recycler.reuse(Vector2)) {
            if (_clockwise)
                return _out.set(_vector.y, -_vector.x);
            else
                return _out.set(-_vector.y, _vector.x);
        }
        /**
         * Creates a cartesian vector from polar coordinates.
         * @param _out Optional vector to store the result in.
         */
        static GEO(_angle = 0, _magnitude = 1, _out = FudgeCore.Recycler.reuse(Vector2)) {
            const geo = FudgeCore.Recycler.reuse(FudgeCore.Geo2).set(_angle, _magnitude);
            _out.geo = geo;
            FudgeCore.Recycler.store(geo);
            return _out;
        }
        //#endregion
        //#region Accessors
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return this.x * this.x + this.y * this.y;
        }
        /**
         * - get: Returns a polar representation of this vector
         * - set: Adjusts the cartesian values of this vector to represent the given as polar coordinates
         */
        get geo() {
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo2);
            geo.magnitude = this.magnitude;
            if (geo.magnitude === 0)
                return geo;
            geo.angle = 180 * Math.atan2(this.y / geo.magnitude, this.x / geo.magnitude) / Math.PI;
            return geo;
        }
        set geo(_geo) {
            this.set(_geo.magnitude, 0);
            const rotation = FudgeCore.Matrix3x3.ROTATION(_geo.angle);
            this.transform(rotation);
            FudgeCore.Recycler.store(rotation);
        }
        /**
         * Creates and returns a clone of this vector.
         */
        get clone() {
            return FudgeCore.Recycler.reuse(Vector2).copy(this);
        }
        //#endregion
        /**
         * Copies the components of the given vector into this vector.
         * @returns A reference to this vector.
         */
        copy(_original) {
            this.x = _original.x;
            this.y = _original.y;
            return this;
        }
        /**
         * Sets the components of this vector.
         * @returns A reference to this vector.
         */
        set(_x = 0, _y = 0) {
            this.x = _x;
            this.y = _y;
            return this;
        }
        recycle() {
            this.set(0, 0);
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            return true;
        }
        /**
         * Returns the distance bewtween this vector and the given vector.
         */
        getDistance(_to) {
            let difference = Vector2.DIFFERENCE(this, _to);
            FudgeCore.Recycler.store(difference);
            return difference.magnitude;
        }
        /**
         * Adds the given vector to this vector.
         * @returns A reference to this vector.
         */
        add(_addend) {
            this.x += _addend.x;
            this.y += _addend.y;
            return this;
        }
        /**
         * Subtracts the given vector from this vector.
         * @returns A reference to this vector.
         */
        subtract(_subtrahend) {
            this.x -= _subtrahend.x;
            this.y -= _subtrahend.y;
            return this;
        }
        /**
         * Scales the Vector by the given _scalar.
         * @returns A reference to this vector.
         */
        scale(_scalar) {
            this.x *= _scalar;
            this.y *= _scalar;
            return this;
        }
        /**
         * Negates this vector by flipping the signs of its components
         * @returns A reference to this vector.
         */
        negate() {
            this.x = -this.x;
            this.y = -this.y;
            return this;
        }
        /**
         * Normalizes this to the given length, 1 by default
         * @returns A reference to this vector.
         */
        normalize(_length = 1) {
            let magnitudeSquared = this.magnitudeSquared;
            if (magnitudeSquared == 0)
                throw (new RangeError("Impossible normalization"));
            this.scale(_length / Math.sqrt(magnitudeSquared));
            return this;
        }
        /**
         * Transforms this vector by the given matrix, including or exluding the translation.
         * Including is the default, excluding will only rotate and scale this vector.
         * @returns A reference to this vector.
         */
        transform(_mtxTransform, _includeTranslation = true) {
            return Vector2.TRANSFORMATION(this, _mtxTransform, _includeTranslation, this);
        }
        /**
         * For each dimension, moves the component to the minimum of this and the given vector.
         * @returns A reference to this vector.
         */
        min(_compare) {
            this.x = Math.min(this.x, _compare.x);
            this.y = Math.min(this.y, _compare.y);
            return this;
        }
        /**
         * For each dimension, moves the component to the maximum of this and the given vector.
         * @returns A reference to this vector.
         */
        max(_compare) {
            this.x = Math.max(this.x, _compare.x);
            this.y = Math.max(this.y, _compare.y);
            return this;
        }
        /**
         * Calls a defined callback function on each component of the vector, and returns a new vector that contains the results. Similar to {@link Array.map}.
         * @param _out Optional vector to store the result in.
         */
        map(_function, _out = FudgeCore.Recycler.reuse(Vector2)) {
            _out.x = _function(this.x, 0, "x", this);
            _out.y = _function(this.y, 1, "y", this);
            return _out;
        }
        /**
         * Calls a defined callback function on each component of the vector and assigns the result to the component. Similar to {@link Vector2.map} but mutates this vector instead of creating a new one.
         * @returns A reference to this vector.
         */
        apply(_function) {
            this.x = _function(this.x, 0, "x", this);
            this.y = _function(this.y, 1, "y", this);
            return this;
        }
        /**
         * Returns an array of the components of this vector.
         */
        get() {
            return new Float32Array([this.x, this.y]);
        }
        /**
         * Copys the elements of this vector into the given array starting at the given offset.
         * @returns A reference to the given array.
         */
        toArray(_out, _offset = 0) {
            _out[_offset] = this.x;
            _out[_offset + 1] = this.y;
            return _out;
        }
        /**
         * Adds a z-component of the given magnitude (default=0) to the vector and returns a new Vector3.
         * @param _out Optional vector to store the result in.
         */
        toVector3(_z = 0, _out = FudgeCore.Recycler.reuse(FudgeCore.Vector3)) {
            return _out.set(this.x, this.y, _z);
        }
        /**
         * Returns a formatted string representation of this vector.
         */
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)})`;
            return result;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator();
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.x}, ${this.y}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.x, this.y] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        getMutator() {
            let mutator = {
                x: this.x, y: this.y
            };
            return mutator;
        }
        mutate(_mutator) {
            if (_mutator.x != undefined)
                this.x = _mutator.x;
            if (_mutator.y != undefined)
                this.y = _mutator.y;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector2 = Vector2;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../Recycle/Recycler.ts"/>
///<reference path="Vector2.ts"/>
var FudgeCore;
///<reference path="../Recycle/Recycler.ts"/>
///<reference path="Vector2.ts"/>
(function (FudgeCore) {
    /**
     * Defines the origin of a rectangle
     */
    let ORIGIN2D;
    (function (ORIGIN2D) {
        ORIGIN2D[ORIGIN2D["TOPLEFT"] = 0] = "TOPLEFT";
        ORIGIN2D[ORIGIN2D["TOPCENTER"] = 1] = "TOPCENTER";
        ORIGIN2D[ORIGIN2D["TOPRIGHT"] = 2] = "TOPRIGHT";
        ORIGIN2D[ORIGIN2D["CENTERLEFT"] = 16] = "CENTERLEFT";
        ORIGIN2D[ORIGIN2D["CENTER"] = 17] = "CENTER";
        ORIGIN2D[ORIGIN2D["CENTERRIGHT"] = 18] = "CENTERRIGHT";
        ORIGIN2D[ORIGIN2D["BOTTOMLEFT"] = 32] = "BOTTOMLEFT";
        ORIGIN2D[ORIGIN2D["BOTTOMCENTER"] = 33] = "BOTTOMCENTER";
        ORIGIN2D[ORIGIN2D["BOTTOMRIGHT"] = 34] = "BOTTOMRIGHT";
    })(ORIGIN2D = FudgeCore.ORIGIN2D || (FudgeCore.ORIGIN2D = {}));
    /**
     * Defines a rectangle with position and size and add comfortable methods to it
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Rectangle extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            super();
            this.position = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.size = FudgeCore.Recycler.get(FudgeCore.Vector2);
            this.setPositionAndSize(_x, _y, _width, _height, _origin);
        }
        /**
         * Returns a new rectangle created with the given parameters.
         * @param _out Optional rectangle to store the result in.
         */
        static GET(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT, _out = FudgeCore.Recycler.reuse(Rectangle)) {
            return _out.setPositionAndSize(_x, _y, _width, _height, _origin);
        }
        get x() {
            return this.position.x;
        }
        set x(_x) {
            this.position.x = _x;
        }
        get y() {
            return this.position.y;
        }
        set y(_y) {
            this.position.y = _y;
        }
        get width() {
            return this.size.x;
        }
        set width(_width) {
            this.size.x = _width;
        }
        get height() {
            return this.size.y;
        }
        set height(_height) {
            this.size.y = _height;
        }
        /**
         * Get/set the leftmost expansion, respecting also negative values of width
         */
        get left() {
            if (this.size.x > 0)
                return this.position.x;
            return (this.position.x + this.size.x);
        }
        set left(_value) {
            this.size.x = this.right - _value;
            this.position.x = _value;
        }
        /**
         * Get/set the topmost expansion, respecting also negative values of height
         */
        get top() {
            if (this.size.y > 0)
                return this.position.y;
            return (this.position.y + this.size.y);
        }
        set top(_value) {
            this.size.y = this.bottom - _value;
            this.position.y = _value;
        }
        /**
         * Get/set the rightmost expansion, respecting also negative values of width
         */
        get right() {
            if (this.size.x > 0)
                return (this.position.x + this.size.x);
            return this.position.x;
        }
        set right(_value) {
            this.size.x = this.position.x + _value;
        }
        /**
         * Get/set the lowest expansion, respecting also negative values of height
         */
        get bottom() {
            if (this.size.y > 0)
                return (this.position.y + this.size.y);
            return this.position.y;
        }
        set bottom(_value) {
            this.size.y = this.position.y + _value;
        }
        get clone() {
            return FudgeCore.Recycler.reuse(Rectangle).copy(this);
        }
        recycle() {
            this.setPositionAndSize();
        }
        /**
         * Returns true if this rectangle is equal to the given rectagnle within the given tolerance.
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            return Math.abs(this.x - _compare.x) <= _tolerance &&
                Math.abs(this.y - _compare.y) <= _tolerance &&
                Math.abs(this.width - _compare.width) <= _tolerance &&
                Math.abs(this.height - _compare.height) <= _tolerance;
        }
        /**
         * Set this rectangle to the values given by the rectangle provided.
         * @returns A reference to this rectangle.
         */
        copy(_rect) {
            return this.setPositionAndSize(_rect.x, _rect.y, _rect.width, _rect.height);
        }
        /**
         * Sets the position and size of the rectangle according to the given parameters.
         * @param _origin The origin of the rectangle. The default is {@link ORIGIN2D.TOPLEFT}.
         * @returns A reference to this rectangle.
         * @deprecated Use {@link set} instead.
         */
        setPositionAndSize(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            return this.set(_x, _y, _width, _height, _origin);
        }
        /**
         * Sets the position and size of the rectangle according to the given parameters.
         * @param _origin The origin of the rectangle. The default is {@link ORIGIN2D.TOPLEFT}.
         * @returns A reference to this rectangle.
         */
        set(_x = 0, _y = 0, _width = 1, _height = 1, _origin = ORIGIN2D.TOPLEFT) {
            this.size.set(_width, _height);
            switch (_origin & 0x03) {
                case 0x00:
                    this.position.x = _x;
                    break;
                case 0x01:
                    this.position.x = _x - _width / 2;
                    break;
                case 0x02:
                    this.position.x = _x - _width;
                    break;
            }
            switch (_origin & 0x30) {
                case 0x00:
                    this.position.y = _y;
                    break;
                case 0x10:
                    this.position.y = _y - _height / 2;
                    break;
                case 0x20:
                    this.position.y = _y - _height;
                    break;
            }
            return this;
        }
        /**
         * Transforms the given point from this rectangles space to the target rectangles space.
         * @param _out Optional vector to store the result in.
         */
        pointToRect(_point, _target, _out = FudgeCore.Recycler.reuse(FudgeCore.Vector2)) {
            _out.copy(_point);
            _out.subtract(this.position);
            _out.x *= _target.width / this.width;
            _out.y *= _target.height / this.height;
            _out.add(_target.position);
            return _out;
        }
        /**
         * Returns true if the given point is inside of this rectangle or on the border.
         */
        isInside(_point) {
            return (_point.x >= this.left && _point.x <= this.right && _point.y >= this.top && _point.y <= this.bottom);
        }
        /**
         * Returns true if this rectangle collides with the given rectangle.
         */
        collides(_rect) {
            if (this.left > _rect.right)
                return false;
            if (this.right < _rect.left)
                return false;
            if (this.top > _rect.bottom)
                return false;
            if (this.bottom < _rect.top)
                return false;
            return true;
        }
        /**
         * Returns true if this rectangle completely encloses the given rectangle.
         */
        covers(_rect) {
            if (this.left > _rect.left)
                return false;
            if (this.right < _rect.right)
                return false;
            if (this.top > _rect.top)
                return false;
            if (this.bottom < _rect.bottom)
                return false;
            return true;
        }
        /**
         * Returns the rectangle created by the intersection of this and the given rectangle or null, if they don't collide.
         * @param _out Optional rectangle to store the result in.
         */
        getIntersection(_rect, _out = FudgeCore.Recycler.reuse(Rectangle)) {
            if (!this.collides(_rect))
                return null;
            _out.x = Math.max(this.left, _rect.left);
            _out.y = Math.max(this.top, _rect.top);
            _out.width = Math.min(this.right, _rect.right) - _out.x;
            _out.height = Math.min(this.bottom, _rect.bottom) - _out.y;
            return _out;
        }
        /**
         * Creates a string representation of this rectangle.
         */
        toString() {
            return `∆í.Rectangle(position:${this.position.toString()}, size:${this.size.toString()}, left:${this.left.toPrecision(5)}, top:${this.top.toPrecision(5)}, right:${this.right.toPrecision(5)}, bottom:${this.bottom.toPrecision(5)})`;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Rectangle = Rectangle;
})(FudgeCore || (FudgeCore = {}));
///<reference path="RenderBufferManager.ts"/>
///<reference path="RenderManagerCoat.ts"/>
///<reference path="RenderManagerNode.ts"/>
///<reference path="RenderWebGLPicking.ts"/>
///<reference path="RenderWebGLComponentLight.ts"/>
///<reference path="RenderWebGLComponentFog.ts"/>
///<reference path="RenderWebGLComponentCamera.ts"/>
///<reference path="RenderWebGLComponentAmbientOcclusion.ts"/>
///<reference path="RenderWebGLComponentBloom.ts"/>
///<reference path="RenderWebGLComponentOutline.ts"/>
///<reference path="RenderInjectorShader.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
///<reference path="RenderInjectorShaderParticleSystem.ts"/>
///<reference path="RenderInjectorComponentParticleSystem.ts"/>
///<reference path="../Math/Rectangle.ts"/>
var FudgeCore;
///<reference path="RenderBufferManager.ts"/>
///<reference path="RenderManagerCoat.ts"/>
///<reference path="RenderManagerNode.ts"/>
///<reference path="RenderWebGLPicking.ts"/>
///<reference path="RenderWebGLComponentLight.ts"/>
///<reference path="RenderWebGLComponentFog.ts"/>
///<reference path="RenderWebGLComponentCamera.ts"/>
///<reference path="RenderWebGLComponentAmbientOcclusion.ts"/>
///<reference path="RenderWebGLComponentBloom.ts"/>
///<reference path="RenderWebGLComponentOutline.ts"/>
///<reference path="RenderInjectorShader.ts"/>
///<reference path="RenderInjectorMesh.ts"/>
///<reference path="RenderInjectorShaderParticleSystem.ts"/>
///<reference path="RenderInjectorComponentParticleSystem.ts"/>
///<reference path="../Math/Rectangle.ts"/>
(function (FudgeCore) {
    // export declare let fudgeConfig: General;
    let BLEND;
    (function (BLEND) {
        BLEND[BLEND["OPAQUE"] = 0] = "OPAQUE";
        BLEND[BLEND["TRANSPARENT"] = 1] = "TRANSPARENT";
        BLEND[BLEND["ADDITIVE"] = 2] = "ADDITIVE";
        BLEND[BLEND["SUBTRACTIVE"] = 3] = "SUBTRACTIVE";
        BLEND[BLEND["MODULATE"] = 4] = "MODULATE";
    })(BLEND = FudgeCore.BLEND || (FudgeCore.BLEND = {}));
    let DEPTH_FUNCTION;
    (function (DEPTH_FUNCTION) {
        DEPTH_FUNCTION[DEPTH_FUNCTION["NEVER"] = 0] = "NEVER";
        DEPTH_FUNCTION[DEPTH_FUNCTION["LESS"] = 1] = "LESS";
        DEPTH_FUNCTION[DEPTH_FUNCTION["EQUAL"] = 2] = "EQUAL";
        DEPTH_FUNCTION[DEPTH_FUNCTION["LESS_EQUAL"] = 3] = "LESS_EQUAL";
        DEPTH_FUNCTION[DEPTH_FUNCTION["GREATER"] = 4] = "GREATER";
        DEPTH_FUNCTION[DEPTH_FUNCTION["NOT_EQUAL"] = 5] = "NOT_EQUAL";
        DEPTH_FUNCTION[DEPTH_FUNCTION["GREATER_EQUAL"] = 6] = "GREATER_EQUAL";
        DEPTH_FUNCTION[DEPTH_FUNCTION["ALWAYS"] = 7] = "ALWAYS";
    })(DEPTH_FUNCTION = FudgeCore.DEPTH_FUNCTION || (FudgeCore.DEPTH_FUNCTION = {}));
    let SHADER_ATTRIBUTE;
    (function (SHADER_ATTRIBUTE) {
        SHADER_ATTRIBUTE[SHADER_ATTRIBUTE["POSITION"] = 0] = "POSITION";
        SHADER_ATTRIBUTE[SHADER_ATTRIBUTE["NORMAL"] = 1] = "NORMAL";
        SHADER_ATTRIBUTE[SHADER_ATTRIBUTE["TEXCOORDS"] = 2] = "TEXCOORDS";
        SHADER_ATTRIBUTE[SHADER_ATTRIBUTE["COLOR"] = 3] = "COLOR";
        SHADER_ATTRIBUTE[SHADER_ATTRIBUTE["TANGENT"] = 4] = "TANGENT";
        SHADER_ATTRIBUTE[SHADER_ATTRIBUTE["BONES"] = 5] = "BONES";
        SHADER_ATTRIBUTE[SHADER_ATTRIBUTE["WEIGHTS"] = 6] = "WEIGHTS";
    })(SHADER_ATTRIBUTE = FudgeCore.SHADER_ATTRIBUTE || (FudgeCore.SHADER_ATTRIBUTE = {}));
    // we want type inference here so we can use vs code to search for references
    FudgeCore.UNIFORM_BLOCK = {
        LIGHTS: {
            NAME: "Lights",
            BINDING: 0
        },
        CAMERA: {
            NAME: "Camera",
            BINDING: 1
        },
        MATERIAL: {
            NAME: "Material",
            BINDING: 2
        },
        NODE: {
            NAME: "Node",
            BINDING: 3
        },
        SKIN: {
            NAME: "Skin",
            BINDING: 4
        },
        FOG: {
            NAME: "Fog",
            BINDING: 5
        }
    };
    FudgeCore.TEXTURE_LOCATION = {
        COLOR: {
            UNIFORM: "u_texColor",
            UNIT: WebGL2RenderingContext.TEXTURE0,
            INDEX: 0 // could compute these by UNIT - WebGL2RenderingContext.TEXTURE0 
        },
        NORMAL: {
            UNIFORM: "u_texNormal",
            UNIT: WebGL2RenderingContext.TEXTURE1,
            INDEX: 1
        },
        PARTICLE: {
            UNIFORM: "u_particleSystemRandomNumbers",
            UNIT: WebGL2RenderingContext.TEXTURE2,
            INDEX: 2
        },
        TEXT: {
            UNIFORM: "u_texText", // TODO: add text uniform to shader...
            UNIT: WebGL2RenderingContext.TEXTURE3,
            INDEX: 3
        },
        TOON: {
            UNIFORM: "u_texToon",
            UNIT: WebGL2RenderingContext.TEXTURE4,
            INDEX: 4
        }
    };
    /**
     * Base class for RenderManager, handling the connection to the rendering system, in this case WebGL.
     * Methods and attributes of this class should not be called directly, only through {@link Render}
     */
    class RenderWebGL extends FudgeCore.EventTargetStatic {
        static { this.crc3 = RenderWebGL.initialize(); }
        static { this.attachmentsColorPositionNormal = [WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.COLOR_ATTACHMENT1, WebGL2RenderingContext.COLOR_ATTACHMENT2]; } // eslint-disable-line
        static { this.attachmentsColor = [WebGL2RenderingContext.COLOR_ATTACHMENT0]; } // eslint-disable-line
        /**
         * Initializes offscreen-canvas, renderingcontext and hardware viewport. Call once before creating any resources like meshes or shaders
         */
        static initialize(_antialias, _alpha) {
            let fudgeConfig = Reflect.get(globalThis, "fudgeConfig") || {};
            const antialias = (_antialias != undefined) ? _antialias : fudgeConfig.antialias || false;
            if (antialias)
                FudgeCore.Debug.error("The default antialiasing is not compatible with the current post-processing effects and will therefore be disabled.");
            let contextAttributes = {
                alpha: (_alpha != undefined) ? _alpha : fudgeConfig.alpha || false,
                antialias: false,
                premultipliedAlpha: false,
                stencil: true
            };
            FudgeCore.Debug.fudge("Initialize RenderWebGL", contextAttributes);
            // let canvas: OffscreenCanvas = new OffscreenCanvas(1, 1); // TODO: inspect using a real OffscreenCanvas
            let canvas = document.createElement("canvas");
            let crc3;
            crc3 = RenderWebGL.assert(canvas.getContext("webgl2", contextAttributes), "WebGL-context couldn't be created");
            RenderWebGL.crc3 = crc3;
            // Enable backface- and zBuffer-culling.
            crc3.enable(WebGL2RenderingContext.CULL_FACE);
            crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
            crc3.enable(WebGL2RenderingContext.BLEND);
            RenderWebGL.setBlendMode(BLEND.TRANSPARENT);
            RenderWebGL.rectCanvas = FudgeCore.Rectangle.GET(0, 0, RenderWebGL.crc3.canvas.width, RenderWebGL.crc3.canvas.height);
            RenderWebGL.rectRender = RenderWebGL.getCanvasRectangle().clone;
            RenderWebGL.initializeAttachments();
            RenderWebGL.adjustAttachments();
            FudgeCore.RenderWebGLComponentCamera.initialize(RenderWebGL);
            FudgeCore.RenderWebGLComponentFog.initialize(RenderWebGL);
            FudgeCore.RenderWebGLComponentLight.initialize(RenderWebGL);
            FudgeCore.RenderManagerNode.initialize(RenderWebGL);
            FudgeCore.RenderManagerCoat.initialize(RenderWebGL);
            return crc3;
        }
        /**
        * Checks the first parameter and throws an exception with the WebGL-errorcode if the value is null
        * @param _value  value to check against null
        * @param _message  optional, additional message for the exception
        */
        static assert(_value, _message = "") {
            if (_value === null)
                throw new Error(`Assertion failed. ${_message}, WebGL-Error: ${RenderWebGL.crc3 ? RenderWebGL.crc3.getError() : ""}`);
            return _value;
        }
        /**
         * Return a reference to the offscreen-canvas.
         *
         * - Do not read or modify the canvas dimensions directly.
         * - Use {@link getCanvasRectangle} to retrieve the size of the offscreen-canvas.
         * - Use {@link setCanvasSize} to set the size of the offscreen-canvas.
         */
        static getCanvas() {
            return RenderWebGL.crc3.canvas; // TODO: enable OffscreenCanvas
        }
        /**
         * Return a reference to the rendering context
         */
        static getRenderingContext() {
            return RenderWebGL.crc3;
        }
        /**
         * Returns a reference to the rectangle describing the size of the offscreen-canvas. x,y are 0 at all times.
         *
         * Do not modify the rectangle directly, use {@link setCanvasSize} instead.
         */
        static getCanvasRectangle() {
            return RenderWebGL.rectCanvas;
        }
        /**
         * Set the size of the offscreen-canvas.
         *
         * ‚ö†Ô∏è CAUTION: If size changes invokes {@link adjustAttachments} which is an expensive operation.
         */
        static setCanvasSize(_width, _height) {
            let sizeChanged = false;
            if (RenderWebGL.rectCanvas.width != _width) {
                RenderWebGL.rectCanvas.width = _width;
                RenderWebGL.crc3.canvas.width = _width;
                sizeChanged = true;
            }
            if (RenderWebGL.rectCanvas.height != _height) {
                RenderWebGL.rectCanvas.height = _height;
                RenderWebGL.crc3.canvas.height = _height;
                sizeChanged = true;
            }
            if (sizeChanged)
                RenderWebGL.adjustAttachments();
        }
        /**
         * Retrieve the area on the offscreen-canvas the camera image gets rendered to.
         *
         * Do not modify the rectangle directly, use {@link setRenderRectangle} instead.
         */
        static getRenderRectangle() {
            return RenderWebGL.rectRender;
        }
        /**
         * Set the area on the offscreen-canvas to render the camera image to.
         */
        static setRenderRectangle(_rect) {
            if (RenderWebGL.rectRender.equals(_rect))
                return;
            RenderWebGL.rectRender.copy(_rect);
            RenderWebGL.crc3.viewport(_rect.x, _rect.y, _rect.width, _rect.height);
        }
        /**
         * Clear the offscreen renderbuffer with the given {@link Color}
         */
        static clear(_color, _colors = true, _depth = true, _stencil = true) {
            RenderWebGL.crc3.clearColor(_color?.r ?? 0, _color?.g ?? 0, _color?.b ?? 0, _color?.a ?? 1);
            let mask = 0;
            if (_colors)
                mask |= WebGL2RenderingContext.COLOR_BUFFER_BIT;
            if (_depth)
                mask |= WebGL2RenderingContext.DEPTH_BUFFER_BIT;
            if (_stencil)
                mask |= WebGL2RenderingContext.STENCIL_BUFFER_BIT;
            RenderWebGL.crc3.clear(mask);
        }
        /**
         * Set the final framebuffer to render to. If null, the canvas default framebuffer is used.
         * Used by XR to render to the XRWebGLLayer framebuffer.
         */
        static setFramebufferTarget(_buffer) {
            RenderWebGL.fboOut = _buffer;
        }
        /**
         * Reset the framebuffer to the main color buffer.
         */
        static resetFramebuffer() {
            RenderWebGL.crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboScene);
        }
        /**
         * Enable / Disable WebGLs depth test.
         */
        static setDepthTest(_test) {
            if (_test)
                RenderWebGL.crc3.enable(WebGL2RenderingContext.DEPTH_TEST);
            else
                RenderWebGL.crc3.disable(WebGL2RenderingContext.DEPTH_TEST);
        }
        /**
         * Set the comparison operation used to test fragment depths against current depth buffer values.
         */
        static setDepthFunction(_function = DEPTH_FUNCTION.LESS) {
            RenderWebGL.crc3.depthFunc(_function + WebGL2RenderingContext.NEVER);
        }
        /**
         * Enable / Disable WebGLs scissor test.
         */
        static setScissorTest(_test, _x, _y, _width, _height) {
            if (_test)
                RenderWebGL.crc3.enable(WebGL2RenderingContext.SCISSOR_TEST);
            else
                RenderWebGL.crc3.disable(WebGL2RenderingContext.SCISSOR_TEST);
            RenderWebGL.crc3.scissor(_x, _y, _width, _height);
        }
        /**
         * Set which color components to enable or to disable when rendering to a color buffer.
         */
        static setColorWriteMask(_r, _g, _b, _a) {
            RenderWebGL.crc3.colorMask(_r, _g, _b, _a);
        }
        /**
         * Set WebGLs viewport.
         */
        static setViewport(_x, _y, _width, _height) {
            RenderWebGL.crc3.viewport(_x, _y, _width, _height);
        }
        /**
         * Set the blend mode to render with
         */
        static setBlendMode(_mode) {
            switch (_mode) {
                case BLEND.OPAQUE:
                    RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ZERO);
                    break;
                case BLEND.TRANSPARENT:
                    RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
                    // RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                    break;
                case BLEND.ADDITIVE:
                    RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
                    // RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE);
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE);
                    break;
                case BLEND.SUBTRACTIVE:
                    RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_REVERSE_SUBTRACT);
                    // RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE);
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE);
                    break;
                case BLEND.MODULATE: // color gets multiplied, tried to copy unitys "Particle Shader: Blending Option: Rendering Mode: Modulate"
                    RenderWebGL.crc3.blendEquation(WebGL2RenderingContext.FUNC_ADD);
                    RenderWebGL.crc3.blendFunc(WebGL2RenderingContext.DST_COLOR, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
                default:
                    break;
            }
        }
        /**
         * Read the (world) position from the pixel at the given point on the render-rectangle (origin top left).
         * ‚ö†Ô∏è CAUTION: Currently only works when ambient occlusion is active due to writing to the position texture being disabled otherwise.
         */
        static pointRenderToWorld(_render) {
            const crc3 = RenderWebGL.getRenderingContext();
            const data = new Float32Array(4);
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboScene);
            crc3.readBuffer(WebGL2RenderingContext.COLOR_ATTACHMENT1);
            crc3.readPixels(_render.x, RenderWebGL.rectRender.height - _render.y, 1, 1, crc3.RGBA, crc3.FLOAT, data);
            crc3.readBuffer(WebGL2RenderingContext.COLOR_ATTACHMENT0);
            let position = FudgeCore.Recycler.get(FudgeCore.Vector3);
            position.set(data[0], data[1], data[2]);
            return position;
        }
        /**
         * Initializes different framebuffers aswell as texture attachments to use as render targets
         */
        static initializeAttachments() {
            const crc3 = RenderWebGL.crc3;
            crc3.getExtension("EXT_color_buffer_float"); // TODO: disable ssao if not supported
            RenderWebGL.fboScene = RenderWebGL.assert(crc3.createFramebuffer());
            RenderWebGL.fboOut = null;
            RenderWebGL.texColor = RenderWebGL.createTexture(WebGL2RenderingContext.NEAREST, WebGL2RenderingContext.CLAMP_TO_EDGE);
            RenderWebGL.texPosition = RenderWebGL.createTexture(WebGL2RenderingContext.NEAREST, WebGL2RenderingContext.CLAMP_TO_EDGE);
            RenderWebGL.texNormal = RenderWebGL.createTexture(WebGL2RenderingContext.LINEAR, WebGL2RenderingContext.CLAMP_TO_EDGE);
            RenderWebGL.texDepthStencil = RenderWebGL.createTexture(WebGL2RenderingContext.NEAREST, WebGL2RenderingContext.CLAMP_TO_EDGE);
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboScene);
            crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT0, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texColor, 0);
            crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT1, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texPosition, 0);
            crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.COLOR_ATTACHMENT2, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texNormal, 0);
            crc3.framebufferTexture2D(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.DEPTH_STENCIL_ATTACHMENT, WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texDepthStencil, 0);
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, null);
            FudgeCore.RenderWebGLComponentAmbientOcclusion.initialize(RenderWebGL);
            FudgeCore.RenderWebGLComponentBloom.initialize(RenderWebGL);
            FudgeCore.RenderWebGLComponentOutline.initialize(RenderWebGL);
            FudgeCore.RenderWebGLPicking.initialize(RenderWebGL);
        }
        /**
         * Adjusts the size of the different texture attachments (render targets) to the canvas size.
         *
         * ‚ö†Ô∏è CAUTION: Expensive operation, use only when canvas size changed.
         */
        static adjustAttachments() {
            const crc3 = RenderWebGL.getRenderingContext();
            const canvasWidth = RenderWebGL.rectCanvas.width || 1;
            const canvasHeight = RenderWebGL.rectCanvas.height || 1;
            crc3.activeTexture(crc3.TEXTURE0);
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texColor);
            crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, canvasWidth, canvasHeight, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, null);
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texPosition);
            // In view space 16F would be precise enough... but we want to use world space for calculations
            crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA32F, canvasWidth, canvasHeight, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, null);
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texNormal);
            crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA16F, canvasWidth, canvasHeight, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, null);
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, RenderWebGL.texDepthStencil);
            crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.DEPTH24_STENCIL8, canvasWidth, canvasHeight, 0, WebGL2RenderingContext.DEPTH_STENCIL, WebGL2RenderingContext.UNSIGNED_INT_24_8, null);
            crc3.bindTexture(crc3.TEXTURE_2D, null);
            FudgeCore.RenderWebGLComponentAmbientOcclusion.resize(RenderWebGL, canvasWidth, canvasHeight);
            FudgeCore.RenderWebGLComponentBloom.resize(RenderWebGL, canvasWidth, canvasHeight);
            FudgeCore.RenderWebGLComponentOutline.resize(RenderWebGL, canvasWidth, canvasHeight);
        }
        static createTexture(_filter, _wrap) {
            const crc3 = RenderWebGL.getRenderingContext();
            const texture = RenderWebGL.assert(crc3.createTexture());
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, texture);
            crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, _filter);
            crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, _filter);
            crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, _wrap);
            crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, _wrap);
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
            return texture;
        }
        static bindTexture(_shader, _texture, _unit, _uniform) {
            const crc3 = RenderWebGL.getRenderingContext();
            crc3.activeTexture(_unit);
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, _texture);
            crc3.uniform1i(_shader.uniforms[_uniform], _unit - WebGL2RenderingContext.TEXTURE0);
        }
        static useNodeUniforms(_shader, _mtxWorld, _mtxPivot, _color, _id) {
            const crc3 = RenderWebGL.crc3;
            let uniform = _shader.uniforms["u_mtxMeshToWorld"];
            if (uniform && _mtxWorld)
                crc3.uniformMatrix4fv(uniform, false, _mtxWorld.getArray());
            uniform = _shader.uniforms["u_mtxPivot"];
            if (uniform && _mtxPivot)
                crc3.uniformMatrix3fv(_shader.uniforms["u_mtxPivot"], false, _mtxPivot.getArray());
            uniform = _shader.uniforms["u_vctColor"];
            if (uniform && _color)
                crc3.uniform4fv(uniform, _color.get());
            uniform = _shader.uniforms["u_id"];
            if (uniform)
                RenderWebGL.crc3.uniform1i(uniform, _id);
        }
        /**
         * Draw a mesh buffer using the given infos and the complete projection matrix
        */
        static drawNode(_node, _cmpCamera) {
            let cmpMesh = _node.getComponent(FudgeCore.ComponentMesh);
            let cmpMaterial = _node.getComponent(FudgeCore.ComponentMaterial);
            let cmpParticleSystem = _node.getComponent(FudgeCore.ComponentParticleSystem);
            if (cmpParticleSystem?.isActive) {
                RenderWebGL.drawParticles(_node, cmpParticleSystem, cmpMesh, cmpMaterial);
                return;
            }
            let cmpText = _node.getComponent(FudgeCore.ComponentText);
            let cmpFaceCamera = _node.getComponent(FudgeCore.ComponentFaceCamera);
            const material = cmpMaterial.material;
            material.getShader().useProgram();
            material.coat.useRenderData();
            if (cmpMesh.skeleton?.isActive)
                cmpMesh.skeleton.useRenderBuffer();
            let mtxWorldOverride;
            if (cmpText?.isActive)
                mtxWorldOverride = cmpText.useRenderData(cmpMesh.mtxWorld, _cmpCamera);
            if (cmpFaceCamera?.isActive)
                mtxWorldOverride = RenderWebGL.faceCamera(_node, mtxWorldOverride ?? cmpMesh.mtxWorld, _cmpCamera.mtxWorld);
            _node.useRenderData(mtxWorldOverride);
            const renderBuffers = cmpMesh.mesh.useRenderBuffers(); // TODO: find out why this gets slower the more different meshes are drawn???
            RenderWebGL.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
        }
        /**
         * Used with a {@link Picker}-camera, this method renders one pixel with picking information
         * for each node in the line of sight and return that as an unsorted {@link Pick}-array
         */
        static pick(_nodes, _cmpCamera) {
            return FudgeCore.RenderWebGLPicking.pickFrom(_nodes, _cmpCamera, RenderWebGL.pickNodes);
        }
        /**
         * The render function for picking nodes.
         * A cameraprojection with extremely narrow focus is used, so each pixel of the buffer would hold the same information from the node,
         * but the fragment shader renders only 1 pixel for each node into the render buffer, 1st node to 1st pixel, 2nd node to second pixel etc.
         */
        static pickNodes(_nodes, _cmpCamera) {
            let picks = [];
            for (const node of _nodes) {
                let cmpMesh = node.getComponent(FudgeCore.ComponentMesh);
                let cmpMaterial = node.getComponent(FudgeCore.ComponentMaterial);
                if (!(cmpMesh && cmpMesh.isActive && cmpMaterial && cmpMaterial.isActive))
                    continue;
                let coat = cmpMaterial.material.coat;
                let shader = coat instanceof FudgeCore.CoatTextured ? FudgeCore.ShaderPickTextured : FudgeCore.ShaderPick;
                shader.useProgram();
                coat.useRenderData();
                let mtxMeshToWorld = RenderWebGL.faceCamera(node, cmpMesh.mtxWorld, _cmpCamera.mtxWorld);
                RenderWebGL.useNodeUniforms(shader, mtxMeshToWorld, cmpMaterial.mtxPivot, cmpMaterial.clrPrimary, picks.length);
                const renderBuffers = cmpMesh.mesh.useRenderBuffers();
                RenderWebGL.crc3.drawElements(WebGL2RenderingContext.TRIANGLES, renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
                picks.push(new FudgeCore.Pick(node));
            }
            return picks;
        }
        /**
         * Draws the given nodes using the given camera and the post process components attached to the same node as the camera
         * The opaque nodes are drawn first, then ssao is applied, then bloom is applied, then nodes alpha (sortForAlpha) are drawn.
         */
        static drawNodes(_nodesOpaque, _nodesAlpha, _cmpCamera) {
            const crc3 = RenderWebGL.getRenderingContext();
            const node = _cmpCamera.node;
            const cmpFog = node?.getComponent(FudgeCore.ComponentFog);
            const cmpAmbientOcclusion = node?.getComponent(FudgeCore.ComponentAmbientOcclusion);
            const cmpBloom = node?.getComponent(FudgeCore.ComponentBloom);
            const cmpOutline = node?.getComponent(FudgeCore.ComponentOutline);
            FudgeCore.RenderWebGLComponentFog.useRenderbuffer(cmpFog);
            FudgeCore.RenderWebGLComponentCamera.useRenderbuffer(_cmpCamera);
            // opaque pass 
            // TODO: think about disabling blending for all opaque objects, this might improve performance 
            // as otherwise the 3 color attachments (color, position and normals) all need to be blended
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboScene);
            crc3.drawBuffers(cmpAmbientOcclusion?.isActive ? RenderWebGL.attachmentsColorPositionNormal : RenderWebGL.attachmentsColor);
            crc3.disable(WebGL2RenderingContext.BLEND);
            for (let node of _nodesOpaque)
                RenderWebGL.drawNode(node, _cmpCamera);
            crc3.enable(WebGL2RenderingContext.BLEND);
            // ambient occlusion pass
            if (cmpAmbientOcclusion?.isActive)
                FudgeCore.RenderWebGLComponentAmbientOcclusion.draw(_cmpCamera, cmpAmbientOcclusion);
            // transparent pass TODO: think about disabling depth write for all transparent objects -> this might make depth mask option in component particle system obsolete
            crc3.bindFramebuffer(WebGL2RenderingContext.FRAMEBUFFER, RenderWebGL.fboScene);
            crc3.drawBuffers(RenderWebGL.attachmentsColor);
            // crc3.depthMask(false);
            for (let node of _nodesAlpha)
                RenderWebGL.drawNode(node, _cmpCamera);
            // crc3.depthMask(true);
            // bloom pass
            if (cmpBloom?.isActive)
                FudgeCore.RenderWebGLComponentBloom.draw(cmpBloom);
            if (cmpOutline?.isActive && cmpOutline.selection)
                FudgeCore.RenderWebGLComponentOutline.draw(cmpOutline.selection, _cmpCamera, cmpOutline);
            // copy framebuffer to canvas
            crc3.bindFramebuffer(WebGL2RenderingContext.READ_FRAMEBUFFER, RenderWebGL.fboScene);
            crc3.bindFramebuffer(WebGL2RenderingContext.DRAW_FRAMEBUFFER, RenderWebGL.fboOut);
            crc3.blitFramebuffer(0, 0, RenderWebGL.rectCanvas.width, RenderWebGL.rectCanvas.height, 0, 0, RenderWebGL.rectCanvas.width, RenderWebGL.rectCanvas.height, WebGL2RenderingContext.COLOR_BUFFER_BIT | WebGL2RenderingContext.DEPTH_BUFFER_BIT, WebGL2RenderingContext.NEAREST);
        }
        static drawParticles(_node, _cmpParticleSystem, _cmpMesh, _cmpMaterial) {
            const crc3 = RenderWebGL.getRenderingContext();
            const renderBuffers = _cmpMesh.mesh.useRenderBuffers();
            const material = _cmpMaterial.material;
            material.coat.useRenderData();
            _cmpParticleSystem.particleSystem.getShaderFrom(material.getShader()).useProgram();
            _cmpParticleSystem.useRenderData();
            _node.useRenderData();
            crc3.depthMask(_cmpParticleSystem.depthMask);
            RenderWebGL.setBlendMode(_cmpParticleSystem.blendMode);
            crc3.drawElementsInstanced(WebGL2RenderingContext.TRIANGLES, renderBuffers.nIndices, WebGL2RenderingContext.UNSIGNED_SHORT, 0, _cmpParticleSystem.size);
            crc3.depthMask(true);
            RenderWebGL.setBlendMode(BLEND.TRANSPARENT);
        }
        static faceCamera(_node, _mtxMeshToWorld, _mtxCamera) {
            let cmpFaceCamera = _node.getComponent(FudgeCore.ComponentFaceCamera);
            if (cmpFaceCamera?.isActive)
                return _mtxMeshToWorld.clone.lookAt(_mtxCamera.translation, cmpFaceCamera.upLocal ? null : cmpFaceCamera.up, cmpFaceCamera.restrict);
            return _mtxMeshToWorld;
        }
    }
    FudgeCore.RenderWebGL = RenderWebGL;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Gives WebGL Buffer the data from the {@link Texture}
     * @internal
     */
    class RenderInjectorTexture {
        static decorate(_constructor, _context) {
            Object.defineProperty(_constructor.prototype, _constructor.prototype.useRenderData.name, {
                value: RenderInjectorTexture.useRenderData
            });
            Object.defineProperty(_constructor.prototype, _constructor.prototype.deleteRenderData.name, {
                value: RenderInjectorTexture.deleteRenderData
            });
        }
        static useRenderData(_textureUnit = WebGL2RenderingContext.TEXTURE0) {
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (!this.renderData)
                this.renderData = FudgeCore.RenderWebGL.assert(crc3.createTexture()); // TODO: check if all WebGL-Creations are asserted
            crc3.activeTexture(_textureUnit);
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.renderData);
            if (this.textureDirty) {
                try {
                    // Always premultiply alpha while loading textures
                    crc3.pixelStorei(crc3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
                    crc3.texImage2D(WebGL2RenderingContext.TEXTURE_2D, 0, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE, this.texImageSource);
                    crc3.pixelStorei(crc3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                    this.mipmapDirty = true;
                    this.textureDirty = false;
                }
                catch (_error) {
                    FudgeCore.Debug.error(_error);
                }
            }
            if (this.mipmapDirty) {
                switch (this.mipmap) {
                    case FudgeCore.MIPMAP.CRISP:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST);
                        break;
                    case FudgeCore.MIPMAP.MEDIUM:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST_MIPMAP_LINEAR);
                        crc3.generateMipmap(WebGL2RenderingContext.TEXTURE_2D);
                        break;
                    case FudgeCore.MIPMAP.BLURRY:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.LINEAR);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR_MIPMAP_LINEAR);
                        crc3.generateMipmap(WebGL2RenderingContext.TEXTURE_2D);
                        break;
                    case FudgeCore.MIPMAP.SMOOTH:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.LINEAR);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR);
                }
                this.mipmapDirty = false;
            }
            if (this.wrapDirty) {
                switch (this.wrap) {
                    case FudgeCore.WRAP.REPEAT:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.REPEAT);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.REPEAT);
                        break;
                    case FudgeCore.WRAP.CLAMP:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
                        break;
                    case FudgeCore.WRAP.MIRROR:
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.MIRRORED_REPEAT);
                        crc3.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.MIRRORED_REPEAT);
                        break;
                }
                this.wrapDirty = false;
            }
        }
        static deleteRenderData() {
            if (!this.renderData)
                return;
            let crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
            crc3.deleteTexture(this.renderData);
            this.renderData = null;
            this.textureDirty = true;
            this.mipmapDirty = true;
            this.wrapDirty = true;
        }
    }
    FudgeCore.RenderInjectorTexture = RenderInjectorTexture;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Represents a node in the scenetree.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Graph
     */
    let Node = (() => {
        var _a, _b, _c, _d;
        let _classSuper = FudgeCore.EventTargetUnified;
        let _staticExtraInitializers = [];
        let _static_resetRenderData_decorators;
        let _static_updateRenderbuffer_decorators;
        let _static_updateRenderData_decorators;
        let _static_useRenderData_decorators;
        return class Node extends _classSuper {
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(this, null, _static_resetRenderData_decorators, { kind: "method", name: "resetRenderData", static: true, private: false, access: { has: obj => "resetRenderData" in obj, get: obj => obj.resetRenderData }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(this, null, _static_updateRenderbuffer_decorators, { kind: "method", name: "updateRenderbuffer", static: true, private: false, access: { has: obj => "updateRenderbuffer" in obj, get: obj => obj.updateRenderbuffer }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(this, null, _static_updateRenderData_decorators, { kind: "method", name: "updateRenderData", static: true, private: false, access: { has: obj => "updateRenderData" in obj, get: obj => obj.updateRenderData }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(this, null, _static_useRenderData_decorators, { kind: "method", name: "useRenderData", static: true, private: false, access: { has: obj => "useRenderData" in obj, get: obj => obj.useRenderData }, metadata: _metadata }, null, _staticExtraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(this, _staticExtraInitializers);
            }
            #listeners;
            #captures;
            #mtxWorldInverseUpdated;
            #mtxWorldInverse;
            /**
             * Creates a new node with a name and initializes all attributes
             */
            constructor(_name) {
                super();
                this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
                this.timestampUpdate = 0;
                /** The number of nodes of the whole branch including this node and all successors */
                this.nNodesInBranch = 0;
                /** The radius of the bounding sphere in world dimensions enclosing the geometry of this node and all successors in the branch */
                this.radius = 0;
                this.parent = null; // The parent of this node.
                this.children = []; // array of child nodes appended to this node.
                this.components = {};
                // private tags: string[] = []; // Names of tags that are attached to this node. (TODO: As of yet no functionality)
                // private layers: string[] = []; // Names of the layers this node is on. (TODO: As of yet no functionality)
                this.active = true;
                this.#listeners = {};
                this.#captures = {};
                /**
                 * Simply calls {@link addChild}. This reference is here solely because appendChild is the equivalent method in DOM.
                 * See and preferably use {@link addChild}
                 */
                // eslint-disable-next-line @typescript-eslint/member-ordering
                this.appendChild = this.addChild;
                this.name = _name;
            }
            /**
             * Return the mutator-like path string to get from one node to another or null if no path is found e.g.:
             * ```typescript
             * "node/parent/children/1/components/ComponentSkeleton/0"
             * ```
             */
            static PATH_FROM_TO(_from, _to) {
                const from = _from instanceof FudgeCore.Component ? _from.node : _from;
                const to = _to instanceof FudgeCore.Component ? _to.node : _to;
                if (!from || !to)
                    return null;
                // find paths to lowest common ancestor
                let pathFrom = from.getPath();
                let pathTo = to.getPath();
                let ancestor = null;
                while (pathFrom.length && pathTo.length && pathFrom[0] == pathTo[0]) {
                    ancestor = pathFrom.shift();
                    pathTo.shift();
                }
                pathTo.unshift(ancestor);
                if (!ancestor)
                    return null;
                // create relative path
                let pathToAncestor = pathFrom.map(_node => "parent"); // TODO: use "keyof Node" as type
                let pathFromAncestor = pathTo
                    .flatMap((_node, _index, _array) => ["children", _node.findChild(_array[_index + 1]).toString()])
                    .slice(0, -2);
                if (_from instanceof FudgeCore.Component)
                    pathToAncestor.unshift("node");
                if (_to instanceof FudgeCore.Component)
                    pathFromAncestor.push("components", _to.type, to.components[_to.type].indexOf(_to).toString());
                return pathToAncestor.concat(pathFromAncestor).join("/"); // TODO: or maybe validate this string with node and component objects?
            }
            /**
             * Return the {@link Node} or {@link Component} found at the given path starting from the given node or undefined if not found
             */
            static FIND(_from, _path) {
                if (_path == "")
                    return _from;
                let path = _path.split("/");
                let to = _from;
                while (path.length && to)
                    to = Reflect.get(to, path.shift());
                return to;
            }
            /** @internal reroute to {@link RenderManagerNode.resetRenderData} */
            static resetRenderData() { }
            ;
            /** @internal reroute to {@link RenderManagerNode.updateRenderbuffer} */
            static updateRenderbuffer() { }
            ;
            /** @internal reroute to {@link RenderManagerNode.updateRenderData} */
            static updateRenderData(_node, _cmpMesh, _cmpMaterial, _cmpFaceCamera, _cmpParticleSystem) { }
            ;
            /** @internal reroute to {@link RenderManagerNode.useRenderData} */
            static useRenderData(_node, _mtxWorldOverride) { }
            ;
            get isActive() {
                return this.active;
            }
            /**
             * Shortcut to retrieve this nodes {@link ComponentTransform}
             */
            get cmpTransform() {
                return this.getComponent(FudgeCore.ComponentTransform);
            }
            /**
             * Shortcut to retrieve the local {@link Matrix4x4} attached to this nodes {@link ComponentTransform}
             * Fails if no {@link ComponentTransform} is attached
             */
            get mtxLocal() {
                return this.cmpTransform?.mtxLocal;
            }
            get mtxWorldInverse() {
                if (this.#mtxWorldInverseUpdated != this.timestampUpdate)
                    this.#mtxWorldInverse = FudgeCore.Matrix4x4.INVERSE(this.mtxWorld);
                this.#mtxWorldInverseUpdated = this.timestampUpdate;
                return this.#mtxWorldInverse;
            }
            /**
             * Returns the number of children attached to this
             */
            get nChildren() {
                return this.children.length;
            }
            /**
             * Generator yielding the node and all decendants in the graph below for iteration
             * Inactive nodes and their descendants can be filtered
             */
            *getIterator(_active = false) {
                if (!_active || this.isActive) {
                    yield this;
                    for (let child of this.children)
                        yield* child.getIterator(_active);
                }
            }
            /**
             * Returns an iterator over this node and all its descendants in the graph below
             */
            [(_static_resetRenderData_decorators = [(_a = FudgeCore.RenderManagerNode).decorate.bind(_a)], _static_updateRenderbuffer_decorators = [(_b = FudgeCore.RenderManagerNode).decorate.bind(_b)], _static_updateRenderData_decorators = [(_c = FudgeCore.RenderManagerNode).decorate.bind(_c)], _static_useRenderData_decorators = [(_d = FudgeCore.RenderManagerNode).decorate.bind(_d)], Symbol.iterator)]() {
                return this.getIterator();
            }
            /** Called by the render system during {@link Render.prepare}. Override this to provide the render system with additional render data. */
            updateRenderData(_cmpMesh, _cmpMaterial, _cmpFaceCamera, _cmpParticleSystem) {
                Node.updateRenderData(this, _cmpMesh, _cmpMaterial, _cmpFaceCamera, _cmpParticleSystem);
            }
            ;
            /** Called by the render system during {@link Render.draw}. Override this to provide the render system with additional render data. */
            useRenderData(_mtxWorldOverride) {
                Node.useRenderData(this, _mtxWorldOverride);
            }
            ;
            /**
             * De- / Activate this node. Inactive nodes will not be processed by the renderer.
             */
            activate(_on) {
                this.active = _on;
                this.dispatchEvent(new Event(_on ? "nodeActivate" /* EVENT.NODE_ACTIVATE */ : "nodeDeactivate" /* EVENT.NODE_DEACTIVATE */, { bubbles: true }));
                this.broadcastEvent(new Event(_on ? "nodeActivate" /* EVENT.NODE_ACTIVATE */ : "nodeDeactivate" /* EVENT.NODE_DEACTIVATE */));
            }
            // #region Scenetree
            /**
             * Returns a reference to this nodes parent node
             */
            getParent() {
                return this.parent;
            }
            /**
             * Traces back the ancestors of this node and returns the first.
             */
            getAncestor() {
                let ancestor = this;
                while (ancestor.getParent())
                    ancestor = ancestor.getParent();
                return ancestor;
            }
            /**
             * Traces the hierarchy upwards to the root and returns the path from the root to this node.
             */
            getPath(_out = [], _offset = 0) {
                let ancestor = this;
                _out[_offset] = ancestor;
                while ((ancestor = ancestor.getParent()))
                    _out[++_offset] = ancestor;
                return _out.reverse();
            }
            /**
             * Returns child at the given index in the list of children
             */
            getChild(_index) {
                return this.children[_index];
            }
            /**
             * Returns the readonly list of children. Create a copy to modify it.
             */
            getChildren() {
                return this.children;
            }
            /**
             * Returns the first child with the supplied name.
             */
            getChildByName(_name) {
                for (let i = 0; i < this.children.length; i++) { // no garbage creation
                    if (this.children[i].name == _name)
                        return this.children[i];
                }
                return null;
            }
            /**
             * Returns an array of references to childnodes with the supplied name.
             */
            getChildrenByName(_name) {
                let found = [];
                found = this.children.filter((_node) => _node.name == _name);
                return found;
            }
            addChild(_child, _index) {
                if (this.children.includes(_child) && _index == undefined)
                    // _node is already a child of this
                    return;
                let inAudioGraph = false;
                let graphListened = FudgeCore.AudioManager.default.getGraphListeningTo();
                let ancestor = this;
                while (ancestor) {
                    ancestor.timestampUpdate = 0;
                    inAudioGraph = inAudioGraph || (ancestor == graphListened);
                    if (ancestor == _child)
                        throw (new Error("Cyclic reference prohibited in node hierarchy, ancestors must not be added as children"));
                    else
                        ancestor = ancestor.parent;
                }
                let previousParent = _child.parent;
                if (previousParent == this && _index > previousParent.findChild(_child))
                    _index--;
                if (previousParent)
                    previousParent.removeChild(_child);
                this.children.splice(_index ?? this.children.length, 0, _child);
                _child.parent = this;
                _child.dispatchEvent(new Event("childAppend" /* EVENT.CHILD_APPEND */, { bubbles: true }));
                if (inAudioGraph)
                    _child.broadcastEvent(new Event("childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */));
            }
            /**
             * Removes the reference to the give node from the list of children
             */
            removeChild(_child) {
                let found = this.findChild(_child);
                if (found < 0)
                    return;
                _child.dispatchEvent(new Event("childRemove" /* EVENT.CHILD_REMOVE */, { bubbles: true }));
                _child.broadcastEvent(new Event("nodeDeactivate" /* EVENT.NODE_DEACTIVATE */));
                if (this.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo()))
                    _child.broadcastEvent(new Event("childRemoveFromAudioGraph" /* EVENT_AUDIO.CHILD_REMOVE */));
                this.children.splice(found, 1);
                _child.parent = null;
            }
            /**
             * Removes all references in the list of children
             */
            removeAllChildren() {
                while (this.children.length)
                    this.removeChild(this.children[0]);
            }
            /**
             * Returns the position of the node in the list of children or -1 if not found
             */
            findChild(_search) {
                return this.children.indexOf(_search);
            }
            /**
             * Replaces a child node with another, preserving the position in the list of children
             */
            replaceChild(_replace, _with) {
                let found = this.findChild(_replace);
                if (found < 0)
                    return false;
                _with.getParent()?.removeChild(_with);
                this.removeChild(_replace);
                this.addChild(_with, found);
                return true;
            }
            /**
             * Returns true if the given timestamp matches the last update timestamp this node underwent, else false
             */
            isUpdated(_timestampUpdate) {
                return (this.timestampUpdate == _timestampUpdate);
            }
            /**
             * Returns true if this node is a descendant of the given node, directly or indirectly, else false
             */
            isDescendantOf(_ancestor) {
                let node = this;
                while (node && node != _ancestor)
                    node = node.parent;
                return (node != null);
            }
            /**
             * Applies a Mutator from {@link Animation} to all its components and transfers it to its children.
             */
            applyAnimation(_mutator) {
                if (_mutator.components) {
                    for (const componentType in _mutator.components) {
                        let componentsOfType = this.components[componentType];
                        let mutatorsForType = _mutator.components[componentType];
                        for (let i = 0; i < componentsOfType.length; i++)
                            componentsOfType[i].mutate(mutatorsForType[i], null, false);
                    }
                }
                if (_mutator.children)
                    for (const childName in _mutator.children)
                        this.getChildByName(childName).applyAnimation(_mutator.children[childName]);
            }
            // #endregion
            // #region Components
            /**
             * Returns a list of all components attached to this node, independent of type.
             */
            getAllComponents() {
                let all = [];
                for (let type in this.components) {
                    all = all.concat(this.components[type]);
                }
                return all;
            }
            /**
             * Returns the list of components of the given class attached to this node. If no components of this type are attached, an empty array is returned.
             * @returns A **readonly** array of components.
             */
            getComponents(_class) {
                return (this.components[_class.name] ??= []);
            }
            /**
             * Returns the first compontent found of the given class attached this node or null, if list is empty or doesn't exist
             */
            getComponent(_class) {
                return this.components[_class.name]?.[0];
            }
            /**
             * Attach the given component to this node. Identical to {@link addComponent}
             */
            attach(_component) {
                this.addComponent(_component);
            }
            /**
             * Attach the given component to this node
             */
            addComponent(_component) {
                if (_component.node == this)
                    return;
                let cmpList = this.components[_component.type];
                if (cmpList === undefined)
                    this.components[_component.type] = [_component];
                else if (cmpList.length && _component.isSingleton)
                    throw new Error(`Component ${_component.type} is marked singleton and can't be attached, no more than one allowed`);
                else
                    cmpList.push(_component);
                _component.attachToNode(this);
                _component.dispatchEvent(new Event("componentAdd" /* EVENT.COMPONENT_ADD */));
                this.dispatchEventToTargetOnly(new CustomEvent("componentAdd" /* EVENT.COMPONENT_ADD */, { detail: _component })); // TODO: see if this is be feasable
            }
            /**
             * Detach the given component from this node. Identical to {@link removeComponent}
             */
            detach(_component) {
                this.removeComponent(_component);
            }
            /**
             * Removes all components of the given class attached to this node.
             */
            removeComponents(_class) {
                for (const component of this.getComponents(_class))
                    this.removeComponent(component);
            }
            /**
             * Removes the given component from the node, if it was attached, and sets its parent to null.
             */
            removeComponent(_component) {
                try {
                    let componentsOfType = this.components[_component.type];
                    let foundAt = componentsOfType.indexOf(_component);
                    if (foundAt < 0)
                        return;
                    _component.dispatchEvent(new Event("componentRemove" /* EVENT.COMPONENT_REMOVE */));
                    this.dispatchEventToTargetOnly(new CustomEvent("componentRemove" /* EVENT.COMPONENT_REMOVE */, { detail: _component })); // TODO: see if this would be feasable
                    componentsOfType.splice(foundAt, 1);
                    _component.attachToNode(null);
                }
                catch (_error) {
                    throw new Error(`Unable to remove component '${_component}'in node named '${this.name}'`);
                }
            }
            // #endregion
            // #region Serialization
            serialize() {
                let serialization = {
                    name: this.name,
                    active: this.active
                };
                let components = {};
                for (let type in this.components) {
                    if (this.components[type].length == 0)
                        continue;
                    components[type] = [];
                    for (let component of this.components[type]) {
                        // components[type].push(component.serialize());
                        components[type].push(FudgeCore.Serializer.serialize(component));
                    }
                }
                serialization["components"] = components;
                let children = [];
                for (let child of this.children) {
                    children.push(FudgeCore.Serializer.serialize(child));
                }
                serialization["children"] = children;
                this.dispatchEvent(new Event("nodeSerialized" /* EVENT.NODE_SERIALIZED */));
                return serialization;
            }
            async deserialize(_serialization) {
                this.name = _serialization.name;
                // this.parent = is set when the nodes are added
                // deserialize components first so scripts can react to children being appended
                for (let type in _serialization.components) {
                    for (let serializedComponent of _serialization.components[type]) {
                        let deserializedComponent = await FudgeCore.Serializer.deserialize(serializedComponent);
                        this.addComponent(deserializedComponent);
                    }
                }
                if (_serialization.children)
                    for (let serializedChild of _serialization.children) {
                        let deserializedChild = await FudgeCore.Serializer.deserialize(serializedChild);
                        this.appendChild(deserializedChild);
                    }
                this.dispatchEvent(new Event("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */));
                for (let component of this.getAllComponents())
                    component.dispatchEvent(new Event("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */));
                // TODO: consider if this is a good idea
                // const hndGraphDeserialized: EventListenerUnified = () => {
                //   for (let component of this.getAllComponents())
                //     component.dispatchEvent(new Event(EVENT.GRAPH_DESERIALIZED, { bubbles: false }));
                //   this.removeEventListener(EVENT.GRAPH_DESERIALIZED, hndGraphDeserialized, true);
                //   this.removeEventListener(EVENT.GRAPH_INSTANTIATED, hndGraphDeserialized, true);
                // };
                // this.addEventListener(EVENT.GRAPH_DESERIALIZED, hndGraphDeserialized, true);
                // this.addEventListener(EVENT.GRAPH_INSTANTIATED, hndGraphDeserialized, true);
                this.activate(_serialization.active);
                return this;
            }
            // #endregion
            toString() {
                return this.name;
            }
            /**
             * Creates a string as representation of this node and its descendants
             */
            toHierarchyString(_node = null, _level = 0) {
                // TODO: refactor for better readability
                if (!_node)
                    _node = this;
                let prefix = "+".repeat(_level);
                let output = prefix + " " + _node.name + " | ";
                for (let type in _node.components)
                    output += _node.components[type].length + " " + type.split("Component").pop() + ", ";
                output = output.slice(0, -2) + "</br>";
                for (let child of _node.children) {
                    output += this.toHierarchyString(child, _level + 1);
                }
                return output;
            }
            // #region Events
            /**
             * Adds an event listener to the node. The given handler will be called when a matching event is passed to the node.
             * Deviating from the standard EventTarget, here the _handler must be a function and _capture is the only option.
             */
            addEventListener(_type, _handler, _capture = false) {
                const listListeners = _capture ? this.#captures : this.#listeners;
                const listenersForType = listListeners[_type] ??= new Set();
                listenersForType.add(_handler);
            }
            /**
             * Removes an event listener from the node. The signature must match the one used with addEventListener
             */
            removeEventListener(_type, _handler, _capture = false) {
                const listenersForType = _capture ? this.#captures[_type] : this.#listeners[_type];
                if (!listenersForType)
                    return;
                listenersForType.delete(_handler);
            }
            /**
             * Dispatches a synthetic event to target. This implementation always returns true (standard: return true only if either event's cancelable attribute value is false or its preventDefault() method was not invoked)
             * The event travels into the hierarchy to this node dispatching the event, invoking matching handlers of the nodes ancestors listening to the capture phase,
             * than the matching handler of the target node in the target phase, and back out of the hierarchy in the bubbling phase, invoking appropriate handlers of the anvestors
             */
            dispatchEvent(_event) {
                if (_event instanceof FudgeCore.RecyclableEvent) {
                    _event.setTarget(this);
                    // update path
                    const path = _event.path;
                    path.length = 0;
                    this.getPath(path).reverse();
                    // capture phase
                    _event.setEventPhase(Event.CAPTURING_PHASE);
                    for (let i = path.length - 1; i >= 1; i--) {
                        let ancestor = path[i];
                        _event.setCurrentTarget(ancestor);
                        this.callListeners(ancestor.#captures[_event.type], _event);
                    }
                    // target phase
                    _event.setEventPhase(Event.AT_TARGET);
                    _event.setCurrentTarget(this);
                    this.callListeners(this.#captures[_event.type], _event);
                    this.callListeners(this.#listeners[_event.type], _event);
                    // bubble phase
                    if (!_event.bubbles)
                        return true;
                    _event.setEventPhase(Event.BUBBLING_PHASE);
                    for (let i = 1; i < path.length; i++) {
                        let ancestor = path[i];
                        _event.setCurrentTarget(ancestor);
                        this.callListeners(ancestor.#listeners[_event.type], _event);
                    }
                }
                else {
                    let ancestors = [];
                    let upcoming = this;
                    // overwrite event target
                    Object.defineProperty(_event, "target", { writable: true, value: this });
                    // TODO: consider using Reflect instead of Object throughout. See also Render and Mutable...
                    while (upcoming.parent)
                        ancestors.push(upcoming = upcoming.parent);
                    Object.defineProperty(_event, "path", { writable: true, value: new Array(this, ...ancestors) });
                    // capture phase
                    Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
                    for (let i = ancestors.length - 1; i >= 0; i--) {
                        let ancestor = ancestors[i];
                        Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                        this.callListeners(ancestor.#captures[_event.type], _event);
                    }
                    // target phase
                    Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.AT_TARGET });
                    Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
                    this.callListeners(this.#captures[_event.type], _event);
                    this.callListeners(this.#listeners[_event.type], _event);
                    if (!_event.bubbles)
                        return true;
                    // bubble phase
                    Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.BUBBLING_PHASE });
                    for (let i = 0; i < ancestors.length; i++) {
                        let ancestor = ancestors[i];
                        Object.defineProperty(_event, "currentTarget", { writable: true, value: ancestor });
                        this.callListeners(ancestor.#listeners[_event.type], _event);
                    }
                }
                return true; //TODO: return a meaningful value, see documentation of dispatch event
            }
            /**
             * Dispatches a synthetic event to target without travelling through the graph hierarchy neither during capture nor bubbling phase
             */
            dispatchEventToTargetOnly(_event) {
                if (_event instanceof FudgeCore.RecyclableEvent) {
                    _event.setCurrentTarget(this);
                    _event.setEventPhase(Event.AT_TARGET);
                }
                else {
                    Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.AT_TARGET });
                    Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
                }
                this.callListeners(this.#listeners[_event.type], _event); // TODO: examine if this should go to the captures instead of the listeners
                return true;
            }
            /**
             * Broadcasts a synthetic event to this node and from there to all nodes deeper in the hierarchy,
             * invoking matching handlers of the nodes listening to the capture phase. Watch performance when there are many nodes involved
             */
            broadcastEvent(_event) {
                if (_event instanceof FudgeCore.RecyclableEvent) {
                    _event.setCurrentTarget(this);
                    _event.setEventPhase(Event.CAPTURING_PHASE);
                }
                else {
                    // overwrite event target and phase
                    Object.defineProperty(_event, "eventPhase", { writable: true, value: Event.CAPTURING_PHASE });
                    Object.defineProperty(_event, "target", { writable: true, value: this });
                }
                this.broadcastEventRecursive(_event);
            }
            broadcastEventRecursive(_event) {
                if (_event instanceof FudgeCore.RecyclableEvent)
                    _event.setEventPhase(Event.CAPTURING_PHASE);
                else
                    Object.defineProperty(_event, "currentTarget", { writable: true, value: this });
                this.callListeners(this.#captures[_event.type], _event);
                // same for children
                for (let child of this.children) {
                    child.broadcastEventRecursive(_event);
                }
            }
            /**
             * Calls the listeners with the given event. The listeners are called in the order they were added. Handles listeners removing themselves or other listeners from the list during execution.
             */
            callListeners(_listeners, _event) {
                if (!_listeners || _listeners.size == 0)
                    return;
                for (const handler of _listeners) {
                    // @ts-ignore
                    handler(_event);
                }
            }
        };
    })();
    FudgeCore.Node = Node;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
var FudgeCore;
// / <reference path="../Transfer/Serializer.ts"/>
// / <reference path="../Transfer/Mutable.ts"/>
(function (FudgeCore) {
    /**
     * Superclass for all {@link Component}s that can be attached to {@link Node}s.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020 | Jascha Karag√∂l, HFU, 2019
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Component
     */
    class Component extends FudgeCore.Mutable {
        /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
        static { this.baseClass = Component; }
        /** list of all the subclasses derived from this class, if they registered properly*/
        static { this.subclasses = []; }
        #node;
        constructor() {
            super();
            this.singleton = true;
            this.active = true;
            this.#node = null;
            this.addEventListener("mutate" /* EVENT.MUTATE */, (_event) => {
                if (this.#node) {
                    // TODO: find the number of the component in the array if not singleton
                    _event.detail.component = this;
                    //@ts-ignore
                    _event.detail.componentIndex = this.node.getComponents(this.constructor).indexOf(this);
                    this.#node.dispatchEvent(_event);
                }
            });
        }
        static registerSubclass(_subclass) { return Component.subclasses.push(_subclass) - 1; }
        get isActive() {
            return this.active;
        }
        /**
         * Is true, when only one instance of the component class can be attached to a node
         */
        get isSingleton() {
            return this.singleton;
        }
        /**
         * Retrieves the node, this component is currently attached to
         */
        get node() {
            return this.#node;
        }
        /**
         * De- / Activate this component. Inactive components will not be processed by the renderer.
         */
        activate(_on) {
            this.active = _on;
            this.dispatchEvent(new Event(_on ? "componentActivate" /* EVENT.COMPONENT_ACTIVATE */ : "componentDeactivate" /* EVENT.COMPONENT_DEACTIVATE */));
        }
        /**
         * Tries to attach the component to the given node, removing it from the node it was attached to if applicable
         */
        attachToNode(_container) {
            if (this.#node == _container)
                return;
            let previousContainer = this.#node;
            try {
                if (previousContainer)
                    previousContainer.removeComponent(this);
                this.#node = _container;
                if (this.#node)
                    this.#node.addComponent(this);
            }
            catch (_error) {
                this.#node = previousContainer;
            }
        }
        //#region Transfer
        serialize() {
            let serialization = {
                active: this.active
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.activate(_serialization.active);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            await super.mutate(_mutator, _selection, _dispatchMutate);
            if (_mutator.active != undefined)
                this.activate(_mutator.active);
        }
        mutateSync(_mutator, _dispatchMutate = true) {
            super.mutateSync(_mutator, _dispatchMutate);
            if (_mutator.active != undefined)
                this.activate(_mutator.active);
        }
        reduceMutator(_mutator) {
            delete _mutator.singleton;
            delete _mutator.mtxWorld;
        }
    }
    FudgeCore.Component = Component;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Wraps a regular Javascript Array and offers very limited functionality geared solely towards avoiding garbage colletion.
     * @author Jirka Dell'Oro-Friedl, HFU, 2021
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Recycler
     */
    class RecycableArray {
        #length = 0;
        #array = new Array();
        // #type: new () => T;
        // //tslint:disable-next-line:no-any
        // constructor(_type: new (...args: any[]) => T) {
        //   this.#type = _type;
        // }
        get length() {
            return this.#length;
        }
        /**
         * Sets the virtual length of the array to zero but keeps the entries beyond.
         */
        reset() {
            this.#length = 0;
        }
        /**
         * Recycle this array
         */
        recycle() {
            this.reset();
        }
        /**
         * Appends a new entry to the end of the array, and returns the new length of the array.
         */
        push(_entry) {
            this.#array[this.#length] = _entry;
            this.#length++;
            return this.#length;
        }
        /**
         * Removes the last entry from the array and returns it.
         */
        pop() {
            if (this.#length == 0)
                return undefined;
            this.#length--;
            return this.#array[this.#length];
        }
        /**
         * Recycles the object following the last in the array and increases the array length
         * It must be assured, that none of the objects in the array is still in any use of any kind!
         */
        // public recycle(): T {
        //   if (this.#length < this.#array.length) {
        //     this.#length++;
        //     return this.#array[this.#length++];
        //   }
        //   this.#array.push(Recycler.get(this.#type));
        //   return this.#array[this.#length++];
        // }
        *[Symbol.iterator]() {
            for (let i = 0; i < this.#length; i++)
                yield this.#array[i];
        }
        /**
         * Returns a copy of the array sorted according to the given compare function
         */
        getSorted(_sort) {
            let sorted = this.#array.slice(0, this.#length);
            sorted.sort(_sort);
            return sorted;
        }
    }
    FudgeCore.RecycableArray = RecycableArray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Special type of {@link Event} for physics.
     */
    class EventPhysics extends Event {
        /** Creates a new event customized for physics. Holding informations about impulses. Collision point and the body that is colliding */
        constructor(_type, _hitRigidbody, _normalImpulse, _tangentImpulse, _binormalImpulse, _collisionPoint = null, _collisionNormal = null) {
            super(_type);
            this.cmpRigidbody = _hitRigidbody;
            this.normalImpulse = _normalImpulse;
            this.tangentImpulse = _tangentImpulse;
            this.binomalImpulse = _binormalImpulse;
            this.collisionPoint = _collisionPoint;
            this.collisionNormal = _collisionNormal;
        }
    }
    FudgeCore.EventPhysics = EventPhysics;
    /**
    * Groups to place a node in, not every group should collide with every group. Use a Mask in to exclude collisions
    */
    let COLLISION_GROUP;
    (function (COLLISION_GROUP) {
        COLLISION_GROUP[COLLISION_GROUP["DEFAULT"] = 1] = "DEFAULT";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_1"] = 2] = "GROUP_1";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_2"] = 4] = "GROUP_2";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_3"] = 8] = "GROUP_3";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_4"] = 16] = "GROUP_4";
        COLLISION_GROUP[COLLISION_GROUP["GROUP_5"] = 32] = "GROUP_5";
    })(COLLISION_GROUP = FudgeCore.COLLISION_GROUP || (FudgeCore.COLLISION_GROUP = {}));
    /**
    * Defines the type of the rigidbody which determines the way it interacts with the physical and the visual world
    */
    let BODY_TYPE;
    (function (BODY_TYPE) {
        /** The body ignores the hierarchy of the render graph, is completely controlled  by physics and takes its node with it  */
        BODY_TYPE[BODY_TYPE["DYNAMIC"] = 0] = "DYNAMIC";
        /** The body ignores the hierarchy of the render graph, is completely immoveble and keeps its node from moving  */
        BODY_TYPE[BODY_TYPE["STATIC"] = 1] = "STATIC";
        /** The body is controlled by its node and moves with it, while it impacts the physical world e.g. by collisions */
        BODY_TYPE[BODY_TYPE["KINEMATIC"] = 2] = "KINEMATIC"; // = OIMO.RigidBodyType.KINEMATIC
    })(BODY_TYPE = FudgeCore.BODY_TYPE || (FudgeCore.BODY_TYPE = {}));
    /**
    * Different types of collider shapes, with different options in scaling BOX = Vector3(length, height, depth),
    * SPHERE = Vector3(diameter, x, x), CAPSULE = Vector3(diameter, height, x), CYLINDER = Vector3(diameter, height, x),
    * CONE = Vector(diameter, height, x), PYRAMID = Vector3(length, height, depth); x == unused.
    * CONVEX = ComponentMesh needs to be available in the RB Property convexMesh, the points of that component are used to create a collider that matches,
    * the closest possible representation of that form, in form of a hull. Convex is experimental and can produce unexpected behaviour when vertices
    * are too close to one another and the given vertices do not form a in itself closed shape and having a genus of 0 (no holes). Vertices in the ComponentMesh can be scaled differently
    * for texturing/normal or other reasons, so the collider might be off compared to the visual shape, this can be corrected by changing the pivot scale of the ComponentRigidbody.
    */
    let COLLIDER_TYPE;
    (function (COLLIDER_TYPE) {
        COLLIDER_TYPE[COLLIDER_TYPE["CUBE"] = 0] = "CUBE";
        COLLIDER_TYPE[COLLIDER_TYPE["SPHERE"] = 1] = "SPHERE";
        COLLIDER_TYPE[COLLIDER_TYPE["CAPSULE"] = 2] = "CAPSULE";
        COLLIDER_TYPE[COLLIDER_TYPE["CYLINDER"] = 3] = "CYLINDER";
        COLLIDER_TYPE[COLLIDER_TYPE["CONE"] = 4] = "CONE";
        COLLIDER_TYPE[COLLIDER_TYPE["PYRAMID"] = 5] = "PYRAMID";
        COLLIDER_TYPE[COLLIDER_TYPE["CONVEX"] = 6] = "CONVEX";
    })(COLLIDER_TYPE = FudgeCore.COLLIDER_TYPE || (FudgeCore.COLLIDER_TYPE = {}));
    /** Displaying different types of debug information about different physic features. Default = JOINTS_AND_COLLIDER. */
    let PHYSICS_DEBUGMODE;
    (function (PHYSICS_DEBUGMODE) {
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["NONE"] = 0] = "NONE";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["COLLIDERS"] = 1] = "COLLIDERS";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["JOINTS_AND_COLLIDER"] = 2] = "JOINTS_AND_COLLIDER";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["BOUNDING_BOXES"] = 3] = "BOUNDING_BOXES";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["CONTACTS"] = 4] = "CONTACTS";
        PHYSICS_DEBUGMODE[PHYSICS_DEBUGMODE["PHYSIC_OBJECTS_ONLY"] = 5] = "PHYSIC_OBJECTS_ONLY";
    })(PHYSICS_DEBUGMODE = FudgeCore.PHYSICS_DEBUGMODE || (FudgeCore.PHYSICS_DEBUGMODE = {}));
    /** Info about Raycasts shot from the physics system. */
    class RayHitInfo {
        constructor() {
            this.hitPoint = FudgeCore.Vector3.ZERO();
            this.hitNormal = FudgeCore.Vector3.ZERO();
            this.rayEnd = FudgeCore.Vector3.ZERO();
            this.rayOrigin = FudgeCore.Vector3.ZERO();
            this.recycle();
        }
        recycle() {
            this.hit = false;
            this.hitDistance = 0;
            this.hitPoint.recycle();
            this.rigidbodyComponent = null;
            this.hitNormal.recycle();
            this.rayOrigin.recycle();
            this.rayEnd.recycle();
        }
    }
    FudgeCore.RayHitInfo = RayHitInfo;
    /** General settings for the physic simulation and the debug of it. */
    class PhysicsSettings {
        constructor(_defaultCollisionGroup, _defaultCollisionMask) {
            if (typeof OIMO == "undefined")
                return;
            this.defaultCollisionGroup = _defaultCollisionGroup;
            this.defaultCollisionMask = _defaultCollisionMask;
        }
        /** Change if rigidbodies are able to sleep (don't be considered in physical calculations) when their movement is below a threshold. Deactivation is decreasing performance for minor advantage in precision. */
        get disableSleeping() {
            return OIMO.Setting.disableSleeping;
        }
        set disableSleeping(_value) {
            OIMO.Setting.disableSleeping = _value;
        }
        /** Sleeping Threshold for Movement Veloctiy. */
        get sleepingVelocityThreshold() {
            return OIMO.Setting.sleepingVelocityThreshold;
        }
        set sleepingVelocityThreshold(_value) {
            OIMO.Setting.sleepingVelocityThreshold = _value;
        }
        /** Sleeping Threshold for Rotation Velocity. */
        get sleepingAngularVelocityThreshold() {
            return OIMO.Setting.sleepingAngularVelocityThreshold;
        }
        set sleepingAngularVelocityThreshold(_value) {
            OIMO.Setting.sleepingAngularVelocityThreshold = _value;
        }
        /** Threshold how long the Rigidbody must be below/above the threshold to count as sleeping. */
        get sleepingTimeThreshold() {
            return OIMO.Setting.sleepingTimeThreshold;
        }
        set sleepingTimeThreshold(_value) {
            OIMO.Setting.sleepingTimeThreshold = _value;
        }
        /** Error threshold. Default is 0.05. The higher the more likely collisions get detected before actual impact at high speeds but it's visually less accurate. */
        get defaultCollisionMargin() {
            return OIMO.Setting.defaultGJKMargin;
        }
        set defaultCollisionMargin(_thickness) {
            OIMO.Setting.defaultGJKMargin = _thickness;
        }
        /** The default applied friction between two rigidbodies with the default value. How much velocity is slowed down when moving accross this surface. */
        get defaultFriction() {
            return OIMO.Setting.defaultFriction;
        }
        set defaultFriction(_value) {
            OIMO.Setting.defaultFriction = _value;
        }
        /** Bounciness of rigidbodies. How much of the impact is restituted. */
        get defaultRestitution() {
            return OIMO.Setting.defaultRestitution;
        }
        set defaultRestitution(_value) {
            OIMO.Setting.defaultRestitution = _value;
        }
        /** Groups the default rigidbody will collide with. Set it like: (PHYSICS_GROUP.DEFAULT | PHYSICS_GROUP.GROUP_1 | PHYSICS_GROUP.GROUP_2 | PHYSICS_GROUP.GROUP_3)
         * to collide with multiple groups. Default is collision with everything but triggers.
        */
        get defaultCollisionMask() {
            return OIMO.Setting.defaultCollisionMask;
        }
        set defaultCollisionMask(_value) {
            OIMO.Setting.defaultCollisionMask = _value;
        }
        /** The group that this rigidbody belongs to. Default is the DEFAULT Group which means its just a normal Rigidbody not a trigger nor anything special. */
        get defaultCollisionGroup() {
            return OIMO.Setting.defaultCollisionGroup;
        }
        set defaultCollisionGroup(_value) {
            OIMO.Setting.defaultCollisionGroup = _value;
        }
        /** Change the type of joint solver algorithm. Default Iterative == 0, is faster but less stable. Direct == 1, slow but more stable, recommended for complex joint work. Change this setting only at the start of your game. */
        get defaultConstraintSolverType() {
            return OIMO.Setting.defaultJointConstraintSolverType;
        }
        set defaultConstraintSolverType(_value) {
            OIMO.Setting.defaultJointConstraintSolverType = _value;
        }
        /** The correction algorithm used to correct physics calculations. Change this only at the beginning of your game. Each has different approaches, so if you have problems test another
         *  Default 0 = Baumgarte (fast but less correct induces some energy errors), 1 = Split-Impulse (fast and no engery errors, but more inaccurate for joints), 2 = Non-linear Gauss Seidel (slowest but most accurate)*/
        get defaultCorrectionAlgorithm() {
            return OIMO.Setting.defaultJointPositionCorrectionAlgorithm;
        }
        set defaultCorrectionAlgorithm(_value) {
            OIMO.Setting.defaultJointPositionCorrectionAlgorithm = _value;
        }
        /** The precision of the simulation in form of number of iterations the simulations runs through until it accepts the result.
         *  10 Default - Higher means more precision but results in a performance decrease. This helps especially with joints,
         * but also the general stability of the simulation due to simulation steps being rechecked multiple times before being set.
         */
        get solverIterations() {
            return FudgeCore.Physics.activeInstance.getOimoWorld().getNumPositionIterations();
        }
        set solverIterations(_value) {
            FudgeCore.Physics.activeInstance.getOimoWorld().setNumPositionIterations(_value);
            FudgeCore.Physics.activeInstance.getOimoWorld().setNumVelocityIterations(_value);
        }
    }
    FudgeCore.PhysicsSettings = PhysicsSettings;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * Acts as the physical representation of a connection between two {@link Node}'s.
       * The type of conncetion is defined by the subclasses like prismatic joint, cylinder joint etc.
       * A Rigidbody on the {@link Node} that this component is added to is needed. Setting the connectedRigidbody and
       * initializing the connection creates a physical connection between them. This differs from a connection through hierarchy
       * in the node structure of fudge. Joints can have different DOF's (Degrees Of Freedom), 1 Axis that can either twist or swing is a degree of freedom.
       * A joint typically consists of a motor that limits movement/rotation or is activly trying to move to a limit. And a spring which defines the rigidity.
       * @author Marko Fehrenbach, HFU 2020
       */
    class Joint extends FudgeCore.Component {
        /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
        static { this.baseClass = Joint; }
        /** list of all the subclasses derived from this class, if they registered properly*/
        static { this.subclasses = []; }
        #idBodyAnchor;
        #idBodyTied;
        #bodyAnchor;
        #bodyTied;
        #connected;
        #anchor;
        #internalCollision;
        #breakForce;
        #breakTorque;
        #nameChildToConnect;
        /** Create a joint connection between the two given RigidbodyComponents. */
        constructor(_bodyAnchor = null, _bodyTied = null) {
            super();
            // public static readonly iSubclass: number = Component.registerSubclass(ComponentJoint);
            this.singleton = false; //Multiple joints can be attached to one Node
            this.#idBodyAnchor = 0;
            this.#idBodyTied = 0;
            this.#connected = false;
            this.#internalCollision = false;
            this.#breakForce = 0;
            this.#breakTorque = 0;
            this.hndEvent = (_event) => {
                switch (_event.type) {
                    case "componentAdd" /* EVENT.COMPONENT_ADD */:
                        this.node.addEventListener("disconnectJoint" /* EVENT.DISCONNECT_JOINT */, () => { this.disconnect(); this.dirtyStatus(); }, true);
                        this.dirtyStatus();
                        break;
                    case "componentRemove" /* EVENT.COMPONENT_REMOVE */:
                        this.node.removeEventListener("disconnectJoint" /* EVENT.DISCONNECT_JOINT */, () => { this.disconnect(); this.dirtyStatus(); }, true);
                        this.removeJoint();
                        break;
                }
            };
            this.#getMutator = () => {
                let mutator = {
                    nameChildToConnect: this.#nameChildToConnect,
                    internalCollision: this.#internalCollision,
                    breakForce: this.#breakForce,
                    breakTorque: this.#breakTorque
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.mutateBase(_mutator, ["internalCollision", "breakForce", "breakTorque"]);
            };
            this.bodyAnchor = _bodyAnchor;
            this.bodyTied = _bodyTied;
            /*
              Tell the physics that there is a new joint and on the physics start the actual joint is first created. Values can be set but the
              actual constraint ain't existent until the game starts
            */
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.hndEvent);
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.hndEvent);
        }
        static registerSubclass(_subclass) { return Joint.subclasses.push(_subclass) - 1; }
        /** Get/Set the first ComponentRigidbody of this connection. It should always be the one that this component is attached too in the sceneTree. */
        get bodyAnchor() {
            return this.#bodyAnchor;
        }
        set bodyAnchor(_cmpRB) {
            this.#idBodyAnchor = _cmpRB != null ? _cmpRB.id : -1;
            this.#bodyAnchor = _cmpRB;
            this.disconnect();
            this.dirtyStatus();
        }
        /** Get/Set the second ComponentRigidbody of this connection. */
        get bodyTied() {
            return this.#bodyTied;
        }
        set bodyTied(_cmpRB) {
            this.#idBodyTied = _cmpRB != null ? _cmpRB.id : -1;
            this.#bodyTied = _cmpRB;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The exact position where the two {@link Node}s are connected. When changed after initialization the joint needs to be reconnected.
         */
        get anchor() {
            return new FudgeCore.Vector3(this.#anchor.x, this.#anchor.y, this.#anchor.z);
        }
        set anchor(_value) {
            this.#anchor = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The amount of force needed to break the JOINT, while rotating, in Newton. 0 equals unbreakable (default)
        */
        get breakTorque() {
            return this.#breakTorque;
        }
        set breakTorque(_value) {
            this.#breakTorque = _value;
            if (this.joint != null)
                this.joint.setBreakTorque(this.#breakTorque);
        }
        /**
         * The amount of force needed to break the JOINT, in Newton. 0 equals unbreakable (default)
         */
        get breakForce() {
            return this.#breakForce;
        }
        set breakForce(_value) {
            this.#breakForce = _value;
            if (this.joint != null)
                this.joint.setBreakForce(this.#breakForce);
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
          * On a welding joint the connected bodies should not be colliding with each other,
          * for best results
         */
        get internalCollision() {
            return this.#internalCollision;
        }
        set internalCollision(_value) {
            this.#internalCollision = _value;
            if (this.joint != null)
                this.joint.setAllowCollision(this.#internalCollision);
        }
        /**
         * Connect a child node with the given name to the joint.
         */
        connectChild(_name) {
            this.#nameChildToConnect = _name;
            if (!this.node)
                return;
            let children = this.node.getChildrenByName(_name);
            if (children.length == 1)
                this.connectNode(children.pop());
            else
                FudgeCore.Debug.warn(`${this.constructor.name} at ${this.node.name} fails to connect child with non existent or ambigous name ${_name}`);
        }
        /**
         * Connect the given node to the joint. Tieing its rigidbody to the nodes rigidbody this component is attached to.
         */
        connectNode(_node) {
            if (!_node || !this.node)
                return;
            FudgeCore.Debug.fudge(`${this.constructor.name} connected ${this.node.name} and ${_node.name}`);
            let connectBody = _node.getComponent(FudgeCore.ComponentRigidbody);
            let thisBody = this.node.getComponent(FudgeCore.ComponentRigidbody);
            if (!connectBody || !thisBody) {
                FudgeCore.Debug.warn(`${this.constructor.name} at ${this.node.name} fails due to missing rigidbodies on ${this.node.name} or ${_node.name}`);
                return;
            }
            this.bodyAnchor = thisBody;
            this.bodyTied = connectBody;
        }
        /** Check if connection is dirty, so when either rb is changed disconnect and reconnect. Internally used no user interaction needed. */
        isConnected() {
            return this.#connected;
        }
        /**
         * Initializing and connecting the two rigidbodies with the configured joint properties
         * is automatically called by the physics system. No user interaction needed.
         */
        connect() {
            if (this.#connected == false) {
                if (this.#idBodyAnchor == -1 || this.#idBodyTied == -1) {
                    if (this.#nameChildToConnect)
                        this.connectChild(this.#nameChildToConnect);
                    return;
                }
                this.constructJoint();
                this.#connected = true;
                this.addJoint();
            }
        }
        /**
         * Disconnecting the two rigidbodies and removing them from the physics system,
         * is automatically called by the physics system. No user interaction needed.
         */
        disconnect() {
            if (this.#connected == true) {
                this.removeJoint();
                this.#connected = false;
            }
        }
        /**
         * Returns the original Joint used by the physics engine. Used internally no user interaction needed.
         * Only to be used when functionality that is not added within FUDGE is needed.
        */
        getOimoJoint() {
            return this.joint;
        }
        serialize() {
            let serialization = this.#getMutator();
            serialization.anchor = this.anchor.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.anchor = await new FudgeCore.Vector3().deserialize(_serialization.anchor);
            this.#mutate(_serialization);
            await super.deserialize(_serialization[super.constructor.name]);
            this.connectChild(_serialization.nameChildToConnect);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            Object.assign(mutator, this.#getMutator());
            mutator.anchor = this.anchor.getMutator();
            return mutator;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            types.nameChildToConnect = "String";
            return types;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (typeof (_mutator.anchor) !== "undefined")
                this.anchor = new FudgeCore.Vector3(...(Object.values(_mutator.anchor)));
            delete _mutator.anchor;
            if (typeof (_mutator.nameChildToConnect) !== "undefined")
                this.connectChild(_mutator.nameChildToConnect);
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        reduceMutator(_mutator) {
            delete _mutator.springDamper;
            delete _mutator.joint;
            delete _mutator.motor;
            super.reduceMutator(_mutator);
        }
        /** Tell the FudgePhysics system that this joint needs to be handled in the next frame. */
        dirtyStatus() {
            FudgeCore.Physics.changeJointStatus(this);
        }
        addJoint() {
            FudgeCore.Physics.addJoint(this);
        }
        removeJoint() {
            FudgeCore.Physics.removeJoint(this);
        }
        constructJoint(..._configParams) {
            let posBodyAnchor = this.bodyAnchor.node.mtxWorld.translation; //Setting the anchor position locally from the first rigidbody
            let worldAnchor = new OIMO.Vec3(posBodyAnchor.x + this.#anchor.x, posBodyAnchor.y + this.#anchor.y, posBodyAnchor.z + this.#anchor.z);
            // @ts-ignore    // unfortunately, method init is not a member of the base class OIMO.JointConfig
            this.config.init(this.#bodyAnchor.getOimoRigidbody(), this.#bodyTied.getOimoRigidbody(), worldAnchor, ..._configParams);
        }
        configureJoint() {
            this.joint.setBreakForce(this.breakForce);
            this.joint.setBreakTorque(this.breakTorque);
            this.joint.setAllowCollision(this.#internalCollision);
        }
        deleteFromMutator(_mutator, _delete) {
            for (let key in _delete)
                delete _mutator[key];
        }
        #getMutator;
        #mutate;
    }
    FudgeCore.Joint = Joint;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * Base class for joints operating with exactly one axis
       * @author Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class JointAxial extends FudgeCore.Joint {
        //Internal Variables
        #maxMotor = 10;
        #minMotor = -10;
        #motorSpeed = 0;
        #axis;
        #springFrequency = 0;
        #springDamping = 0;
        /** Creating a cylindrical joint between two ComponentRigidbodies moving on one axis and rotating around another bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.axis = _axis;
            this.anchor = _localAnchor;
            this.minMotor = -10;
            this.maxMotor = 10;
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axis() {
            return new FudgeCore.Vector3(this.#axis.x, this.#axis.y, this.#axis.z);
        }
        set axis(_value) {
            this.#axis = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        get maxMotor() {
            return this.#maxMotor;
        }
        set maxMotor(_value) {
            this.#maxMotor = _value;
            try {
                this.joint.getLimitMotor().upperLimit = _value;
            }
            catch (_e) { /* */ }
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        get minMotor() {
            return this.#minMotor;
        }
        set minMotor(_value) {
            this.#minMotor = _value;
            try {
                this.joint.getLimitMotor().lowerLimit = _value;
            }
            catch (_e) { /* */ }
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDamping() {
            return this.#springDamping;
        }
        set springDamping(_value) {
            this.#springDamping = _value;
            try {
                this.joint.getSpringDamper().dampingRatio = _value;
            }
            catch (_e) { /* */ }
        }
        /**
          * The target speed of the motor in m/s.
         */
        get motorSpeed() {
            return this.#motorSpeed;
        }
        set motorSpeed(_value) {
            this.#motorSpeed = _value;
            try {
                this.joint.getLimitMotor().motorSpeed = _value;
            }
            catch (_e) { /* */ }
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequency() {
            return this.#springFrequency;
        }
        set springFrequency(_value) {
            this.#springFrequency = _value;
            try {
                this.joint.getSpringDamper().frequency = _value;
            }
            catch (_e) { /* */ }
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.axis = this.axis.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.axis = await new FudgeCore.Vector3().deserialize(_serialization.axis);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (typeof (_mutator.axis) !== "undefined")
                this.axis = new FudgeCore.Vector3(...(Object.values(_mutator.axis)));
            delete _mutator.axis;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.axis = this.axis.getMutator();
            Object.assign(mutator, this.#getMutator());
            return mutator;
        }
        //#endregion
        constructJoint() {
            this.springDamper = new OIMO.SpringDamper().setSpring(this.#springFrequency, this.#springDamping);
            super.constructJoint(this.#axis);
        }
        #getMutator = () => {
            let mutator = {
                springDamping: this.#springDamping,
                springFrequency: this.#springFrequency,
                maxMotor: this.#maxMotor,
                minMotor: this.#minMotor,
                motorSpeed: this.#motorSpeed
            };
            return mutator;
        };
        #mutate = (_mutator) => {
            this.mutateBase(_mutator, ["springDamping", "springFrequency", "maxMotor", "minMotor", "motorSpeed"]);
        };
    }
    FudgeCore.JointAxial = JointAxial;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let MODE;
    (function (MODE) {
        MODE[MODE["EDITOR"] = 0] = "EDITOR";
        MODE[MODE["RUNTIME"] = 1] = "RUNTIME";
    })(MODE = FudgeCore.MODE || (FudgeCore.MODE = {}));
    let RESOURCE_STATUS;
    (function (RESOURCE_STATUS) {
        RESOURCE_STATUS[RESOURCE_STATUS["PENDING"] = 0] = "PENDING";
        RESOURCE_STATUS[RESOURCE_STATUS["READY"] = 1] = "READY";
        RESOURCE_STATUS[RESOURCE_STATUS["ERROR"] = 2] = "ERROR";
    })(RESOURCE_STATUS = FudgeCore.RESOURCE_STATUS || (FudgeCore.RESOURCE_STATUS = {}));
    /** A serializable resource implementing an id and a name so it can be managed by the {@link Project} */
    class SerializableResource extends FudgeCore.Implementable {
    } // allow check with instanceof 
    FudgeCore.SerializableResource = SerializableResource;
    /**
     * Static class handling the resources used with the current FUDGE-instance.
     * Keeps a list of the resources and generates ids to retrieve them.
     * Resources are objects referenced multiple times but supposed to be stored only once
     */
    class Project extends FudgeCore.EventTargetStatic {
        static { this.resources = {}; }
        static { this.serialization = {}; }
        static { this.scriptNamespaces = {}; }
        static { this.baseURL = new URL(location.toString()); }
        static { this.mode = MODE.RUNTIME; }
        static { this.graphInstancesToResync = {}; }
        /**
         * Registers the resource and generates an id for it by default.
         * If the resource already has an id, thus having been registered, its deleted from the list and registered anew.
         * It's possible to pass an id, but should not be done except by the Serializer.
         */
        static register(_resource, _idResource) {
            if (_resource.idResource && _resource.idResource == _idResource)
                return;
            if (_resource.idResource) // deregister the old id
                this.deregister(_resource);
            if (_idResource) {
                _resource.idResource = _idResource;
                this.deregister(_resource); // deregister the new id
            }
            if (!_resource.idResource)
                _resource.idResource = Project.generateId(_resource);
            Project.resources[_resource.idResource] = _resource;
            if (_resource instanceof FudgeCore.Graph)
                _resource.addEventListener("graphMutated" /* EVENT.GRAPH_MUTATED */, (_event) => this.dispatchEvent(new CustomEvent("graphMutated" /* EVENT.GRAPH_MUTATED */, { detail: _resource })));
        }
        /**
         * Removes the resource from the list of resources.
         */
        static deregister(_resource) {
            delete (Project.resources[_resource.idResource]);
            delete (Project.serialization[_resource.idResource]);
        }
        /**
         * Clears the list of resources and their serialization, thus removing all resources.
         */
        static clear() {
            Project.resources = {};
            Project.serialization = {};
            Project.clearScriptNamespaces();
            // Project.scriptNamespaces = {};
        }
        // <T extends Component>(_class: new () => T): T[] {
        //   return <T[]>(this.components[_class.name] || []).slice(0);
        // }
        /**
         * Returns an array of all resources of the requested type.
         */
        static getResourcesByType(_type) {
            let found = [];
            for (let resourceId in Project.resources) {
                let resource = Project.resources[resourceId];
                if (resource instanceof _type)
                    found.push(resource);
            }
            return found;
        }
        /**
         * Returns an array of all resources with the requested name.
         */
        static getResourcesByName(_name) {
            let found = [];
            for (let resourceId in Project.resources) {
                let resource = Project.resources[resourceId];
                if (resource.name == _name)
                    found.push(resource);
            }
            return found;
        }
        /**
         * Generate a user readable and unique id using the type of the resource, the date and random numbers
         * @param _resource
         */
        static generateId(_resource) {
            // TODO: build id and integrate info from resource, not just date
            let idResource;
            do
                idResource = _resource.constructor.name + "|" + new Date().toISOString() + "|" + Math.random().toPrecision(5).substr(2, 5);
            while (Project.resources[idResource]);
            return idResource;
        }
        /**
         * Tests, if an object is a {@link SerializableResource}
         * @param _object The object to examine
         */
        static isResource(_object) {
            return (Reflect.has(_object, "idResource"));
        }
        /**
         * Retrieves the resource stored with the given id
         */
        static async getResource(_idResource) {
            let resource = Project.resources[_idResource];
            if (!resource) {
                let serialization = Project.serialization[_idResource];
                if (!serialization) {
                    FudgeCore.Debug.error("Resource not found", _idResource);
                    return null;
                }
                resource = await Project.deserializeResource(serialization);
            }
            return resource;
        }
        static async cloneResource(_resource) {
            if (!_resource)
                return null;
            let serialization = FudgeCore.Serializer.serialize(_resource);
            let type = Reflect.ownKeys(serialization)[0];
            delete (serialization[type].idResource);
            let clone = await Project.deserializeResource(serialization);
            Project.register(clone);
            clone.name += "_clone";
            return clone;
        }
        /**
         * Creates and registers a resource from a {@link Node}, copying the complete graph starting with it
         * @param _node A node to create the resource from
         * @param _replaceWithInstance if true (default), the node used as origin is replaced by a {@link GraphInstance} of the {@link Graph} created
         */
        static async registerAsGraph(_node, _replaceWithInstance = true) {
            let serialization = _node.serialize();
            let graph = new FudgeCore.Graph(_node.name);
            await graph.deserialize(serialization);
            Project.register(graph);
            if (_replaceWithInstance && _node.getParent()) {
                let instance = await Project.createGraphInstance(graph);
                _node.getParent().replaceChild(_node, instance);
            }
            return graph;
        }
        /**
         * Creates and returns a {@link GraphInstance} of the given {@link Graph}
         * and connects it to the graph for synchronisation of mutation.
         */
        static async createGraphInstance(_graph) {
            let instance = new FudgeCore.GraphInstance(_graph); // TODO: cleanup since creation moved here
            await instance.connectToGraph();
            return instance;
        }
        /**
         * Register the given {@link GraphInstance} to be resynced
         */
        static registerGraphInstanceForResync(_instance) {
            let instances = Project.graphInstancesToResync[_instance.idSource] || [];
            instances.push(_instance);
            Project.graphInstancesToResync[_instance.idSource] = instances;
        }
        /**
         * Resync all {@link GraphInstance} registered to the given {@link Graph}
         */
        static async resyncGraphInstances(_graph) {
            let instances = Project.graphInstancesToResync[_graph.idResource];
            if (!instances)
                return;
            for (let instance of instances)
                await instance.connectToGraph();
            delete (Project.graphInstancesToResync[_graph.idResource]);
        }
        /**
         * Register the given namespace to the list of script-namespaces.
         */
        static registerScriptNamespace(_namespace) {
            let name = FudgeCore.Serializer.registerNamespace(_namespace);
            if (!Project.scriptNamespaces[name])
                Project.scriptNamespaces[name] = _namespace;
        }
        /**
         * Clear the list of script-namespaces.
         */
        static clearScriptNamespaces() {
            for (let name in Project.scriptNamespaces) {
                Reflect.set(window, name, undefined);
                Project.scriptNamespaces[name] = undefined;
                delete Project.scriptNamespaces[name];
            }
        }
        /**
         * Collects all {@link ComponentScript}s registered in {@link Project.scriptNamespaces} and returns them.
         */
        static getComponentScripts() {
            let compoments = {};
            for (let namespace in Project.scriptNamespaces) {
                compoments[namespace] = [];
                for (let name in Project.scriptNamespaces[namespace]) {
                    let script = Reflect.get(Project.scriptNamespaces[namespace], name);
                    // Using Object.create doesn't call the constructor, but instanceof can be used. More elegant than the loop above, though maybe not as performant. 
                    try {
                        let o = Object.create(script);
                        if (o.prototype instanceof FudgeCore.ComponentScript)
                            compoments[namespace].push(script);
                    }
                    catch (_e) { /* */ }
                }
            }
            return compoments;
        }
        /**
         * Loads a script from the given URL and integrates it into a {@link HTMLScriptElement} in the {@link document.head}
         */
        static async loadScript(_url) {
            let script = document.createElement("script");
            script.type = "text/javascript";
            // script.type = "module";
            script.async = false;
            // script.addEventListener("load", handleLoadedScript)
            let head = document.head;
            head.appendChild(script);
            FudgeCore.Debug.log("Loading: ", _url);
            return new Promise((_resolve, _reject) => {
                script.addEventListener("load", () => _resolve());
                script.addEventListener("error", () => {
                    FudgeCore.Debug.error("Loading script", _url);
                    _reject();
                });
                script.src = _url.toString();
            });
        }
        /**
         * Load {@link Resources} from the given url
         */
        static async loadResources(_url) {
            const response = await fetch(_url);
            const resourceFileContent = await response.text();
            let serialization = FudgeCore.Serializer.parse(resourceFileContent);
            let reconstruction = await Project.deserialize(serialization);
            Project.dispatchEvent(new CustomEvent("resourcesLoaded" /* EVENT.RESOURCES_LOADED */, { detail: { url: _url, resources: reconstruction } }));
            return reconstruction;
        }
        /**
         * Load all resources from the {@link document.head}
         */
        static async loadResourcesFromHTML() {
            const head = document.head;
            let links = head.querySelectorAll("link[type=resources]");
            for (let link of links) {
                let url = link.getAttribute("src");
                await Project.loadResources(url);
            }
        }
        /**
         * Serialize all resources
         */
        static serialize() {
            let serialization = {};
            for (let idResource in Project.resources) {
                let resource = Project.resources[idResource];
                if (idResource != resource.idResource)
                    FudgeCore.Debug.error("Resource-id mismatch", resource);
                serialization[idResource] = FudgeCore.Serializer.serialize(resource);
            }
            return serialization;
        }
        /**
         * Create resources from a serialization, deleting all resources previously registered
         * @param _serialization
         */
        static async deserialize(_serialization) {
            Project.serialization = _serialization;
            Project.resources = {};
            for (let idResource in _serialization) {
                let serialization = _serialization[idResource];
                let resource = await Project.deserializeResource(serialization);
                if (resource)
                    Project.resources[idResource] = resource;
            }
            return Project.resources;
        }
        static async deserializeResource(_serialization) {
            return FudgeCore.Serializer.deserialize(_serialization);
        }
    }
    FudgeCore.Project = Project;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * - CRISP: no mipmapping, mag filter nearest, min filter nearest
     * - MEDIUM: mipmapping, mag filter nearest, min filter nearest_mipmap_linear
     * - BLURRY: mipmapping, mag filter linear, min filter linear_mipmap_linear
     * - SMOOTH: no mipmapping, mag filter linear, min filter linear
     */
    let MIPMAP;
    (function (MIPMAP) {
        MIPMAP[MIPMAP["CRISP"] = 0] = "CRISP";
        MIPMAP[MIPMAP["MEDIUM"] = 1] = "MEDIUM";
        MIPMAP[MIPMAP["BLURRY"] = 2] = "BLURRY";
        MIPMAP[MIPMAP["SMOOTH"] = 3] = "SMOOTH";
    })(MIPMAP = FudgeCore.MIPMAP || (FudgeCore.MIPMAP = {}));
    let WRAP;
    (function (WRAP) {
        WRAP[WRAP["REPEAT"] = 0] = "REPEAT";
        WRAP[WRAP["CLAMP"] = 1] = "CLAMP";
        WRAP[WRAP["MIRROR"] = 2] = "MIRROR";
    })(WRAP = FudgeCore.WRAP || (FudgeCore.WRAP = {}));
    /**
     * Baseclass for different kinds of textures.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let Texture = (() => {
        var _a, _b;
        let _classDecorators = [(_a = FudgeCore.RenderInjectorTexture).decorate.bind(_a), (_b = FudgeCore.SerializableResource).register.bind(_b)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Mutable;
        var Texture = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                Texture = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(_classThis, _classExtraInitializers);
            }
            #mipmap;
            #wrap;
            constructor(_name = "Texture") {
                super();
                this.idResource = undefined;
                this.textureDirty = true;
                this.mipmapDirty = true;
                this.wrapDirty = true;
                this.#mipmap = MIPMAP.CRISP;
                this.#wrap = WRAP.REPEAT;
                this.name = _name;
            }
            set mipmap(_mipmap) {
                this.#mipmap = _mipmap;
                this.mipmapDirty = true;
            }
            get mipmap() {
                return this.#mipmap;
            }
            set wrap(_wrap) {
                this.#wrap = _wrap;
                this.wrapDirty = true;
            }
            get wrap() {
                return this.#wrap;
            }
            /**
             * Generates and binds the texture in WebGL from the {@link texImageSource}.
             * Injected by {@link RenderInjectorTexture}. Used by the render system.
             * @internal
             */
            useRenderData(_textureUnit = 0) { }
            /**
             * Deletes the texture in WebGL freeing the allocated gpu memory.
             * Injected by {@link RenderInjectorTexture}.
             * @internal
             */
            deleteRenderData() { }
            /**
             * Refreshes the image data in the render engine.
             */
            refresh() {
                this.textureDirty = true;
            }
            //#region Transfer
            serialize() {
                let serialization = {
                    idResource: this.idResource,
                    name: this.name,
                    mipmap: MIPMAP[this.#mipmap],
                    wrap: WRAP[this.#wrap]
                };
                return serialization;
            }
            async deserialize(_serialization) {
                FudgeCore.Project.register(this, _serialization.idResource);
                this.name = _serialization.name;
                this.#mipmap = MIPMAP[_serialization.mipmap];
                this.#wrap = WRAP[_serialization.wrap];
                return this;
            }
            getMutator(_extendable) {
                let mutator = super.getMutator(true);
                mutator.mipmap = this.#mipmap;
                mutator.wrap = this.#wrap;
                return mutator;
            }
            getMutatorAttributeTypes(_mutator) {
                let types = super.getMutatorAttributeTypes(_mutator);
                if (types.mipmap)
                    types.mipmap = MIPMAP;
                if (types.wrap)
                    types.wrap = WRAP;
                return types;
            }
            reduceMutator(_mutator) {
                delete _mutator.idResource;
                delete _mutator.renderData;
                delete _mutator.textureDirty;
                delete _mutator.mipmapDirty;
                delete _mutator.mipmapGenerated;
                delete _mutator.wrapDirty;
            }
        };
        return Texture = _classThis;
    })();
    FudgeCore.Texture = Texture;
    /**
     * Texture created from an existing image
     */
    class TextureImage extends Texture {
        constructor(_url) {
            super();
            this.image = null;
            if (_url) {
                this.load(_url);
                this.name = _url.toString().split("/").pop();
            }
            FudgeCore.Project.register(this);
        }
        get texImageSource() {
            return this.image;
        }
        /**
         * Asynchronously loads the image from the given url
         */
        async load(_url) {
            this.url = _url;
            this.image = new Image();
            // const response: Response = await window.fetch(this.url);
            // const blob: Blob = await response.blob();
            // let objectURL: string = URL.createObjectURL(blob);
            // this.image.src = objectURL;
            return new Promise((_resolve, _reject) => {
                this.image.addEventListener("load", () => {
                    this.renderData = null; // refresh render data on next draw call
                    _resolve();
                });
                this.image.addEventListener("error", () => _reject());
                this.image.src = new URL(this.url.toString(), FudgeCore.Project.baseURL).toString();
            });
        }
        //#region Transfer
        serialize() {
            return {
                url: this.url,
                type: this.type, // serialize for editor views
                [super.constructor.name]: super.serialize()
            };
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            await this.load(_serialization.url);
            // this.type is an accessor of Mutable doesn't need to be deserialized
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (_mutator.url && _mutator.url != this.url.toString())
                await this.load(_mutator.url);
            // except url from mutator for further processing
            delete (_mutator.url);
            await super.mutate(_mutator, _selection, _dispatchMutate);
            // TODO: examine necessity to reconstruct, if mutator is kept by caller
            // _mutator.url = this.url; 
        }
    }
    FudgeCore.TextureImage = TextureImage;
    /**
     * Texture created from a canvas
     */
    class TextureBase64 extends Texture {
        constructor(_name, _base64, _mipmap = MIPMAP.CRISP, _wrap = WRAP.REPEAT, _width, _height) {
            super(_name);
            this.image = new Image();
            this.image.src = _base64;
            this.mipmap = _mipmap;
            this.wrap = _wrap;
            if (_width)
                this.image.width = _width;
            if (_height)
                this.image.height = _height;
        }
        get texImageSource() {
            return this.image;
        }
    }
    FudgeCore.TextureBase64 = TextureBase64;
    /**
     * Texture created from a canvas
     */
    class TextureCanvas extends Texture {
        constructor(_name, _crc2) {
            super(_name);
            this.crc2 = _crc2;
        }
        get texImageSource() {
            return this.crc2.canvas;
        }
    }
    FudgeCore.TextureCanvas = TextureCanvas;
    /**
     * Texture created from a text. Texture upates when the text or font changes. The texture is resized to fit the text.
     * @authors Jonas Plotzky, HFU, 2024
     */
    class TextureText extends Texture {
        #text;
        #font;
        constructor(_name, _text = "Text", _font = "20px monospace") {
            super(_name);
            this.crc2 = document.createElement("canvas").getContext("2d");
            this.text = _text;
            this.font = _font;
        }
        set text(_text) {
            this.#text = _text;
            this.textureDirty = true;
        }
        get text() {
            return this.#text;
        }
        set font(_font) {
            this.#font = _font;
            document.fonts.load(this.#font)
                .catch((_error) => FudgeCore.Debug.error(`${TextureText.name}: ${_error}`))
                .finally(() => this.textureDirty = true);
        }
        get font() {
            return this.#font;
        }
        get texImageSource() {
            return this.canvas;
        }
        get width() {
            return this.canvas.width;
        }
        get height() {
            return this.canvas.height;
        }
        get hasTransparency() {
            return true;
        }
        get canvas() {
            return this.crc2.canvas;
        }
        useRenderData(_textureUnit) {
            if (this.textureDirty) {
                this.crc2.font = this.font;
                let metrics = this.crc2.measureText(this.text);
                let width = metrics.width;
                let height = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
                this.canvas.width = width + this.crc2.measureText("  ").width;
                this.canvas.height = height * 1.1; // padding, otherwise on some glyphs might get cut off
                if (this.canvas.width == 0)
                    return;
                this.crc2.font = this.font; // TODO: wait for font to be loaded using document.fonts
                this.crc2.textAlign = "center";
                this.crc2.textBaseline = "middle";
                this.crc2.fillStyle = "white";
                this.crc2.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.crc2.fillText(this.#text, this.canvas.width / 2, this.canvas.height / 2);
            }
            super.useRenderData(_textureUnit);
        }
        serialize() {
            return {
                [super.constructor.name]: super.serialize(),
                text: this.text,
                font: this.font
            };
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            this.text = _serialization.text;
            this.font = _serialization.font;
            return this;
        }
        getMutator(_extendable) {
            let mutator = super.getMutator(true);
            mutator.text = this.text;
            mutator.font = this.font;
            return mutator;
        }
    }
    FudgeCore.TextureText = TextureText;
    /**
     * Texture created from a FUDGE-Sketch
     */
    class TextureSketch extends TextureCanvas {
        get texImageSource() {
            return null;
        }
    }
    FudgeCore.TextureSketch = TextureSketch;
    /**
     * Texture created from an HTML-page
     */
    class TextureHTML extends TextureCanvas {
        get texImageSource() {
            return null;
        }
    }
    FudgeCore.TextureHTML = TextureHTML;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Abstract base class for all meshes.
     * Meshes provide indexed vertices, the order of indices to create trigons and normals, and texture coordinates
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019/22
     */
    let Mesh = (() => {
        var _a, _b;
        let _classDecorators = [(_a = FudgeCore.RenderInjectorMesh).decorate.bind(_a), (_b = FudgeCore.SerializableResource).register.bind(_b)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Mutable;
        var Mesh = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                Mesh = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
            static { this.baseClass = Mesh; }
            /** list of all the subclasses derived from this class, if they registered properly*/
            static { this.subclasses = []; }
            #renderMesh;
            constructor(_name = "Mesh") {
                super();
                // TODO: rename vertices to verticesSmooth or just cloud, and cloud to vertices
                this.idResource = undefined;
                this.name = "Mesh";
                // base structure for meshes in FUDGE
                this.vertices = new FudgeCore.Vertices();
                this.faces = [];
                this.name = _name;
                this.clear();
                FudgeCore.Project.register(this);
            }
            static registerSubclass(_subClass) { return Mesh.subclasses.push(_subClass) - 1; }
            get renderMesh() {
                if (this.#renderMesh == null)
                    this.#renderMesh = new FudgeCore.RenderMesh(this);
                return this.#renderMesh;
            }
            get boundingBox() {
                if (this.∆íbox == null)
                    this.∆íbox = this.createBoundingBox();
                return this.∆íbox;
            }
            get radius() {
                if (this.∆íradius == null)
                    this.∆íradius = this.createRadius();
                return this.∆íradius;
            }
            /**
             * Injected by {@link RenderInjectorMesh}.
             * Used by the render system.
             * @internal
             */ // TODO: rename this
            useRenderBuffers() { return null; /* injected by RenderInjector*/ }
            /**
             * Injected by {@link RenderInjectorMesh}.
             * Used by the render system.
             * @internal
             */
            getRenderBuffers() { return null; /* injected by RenderInjector*/ }
            /**
             * Injected by {@link RenderInjectorMesh}.
             * Used by the render system.
             * @internal
             */
            deleteRenderBuffers(_renderBuffers) { }
            /**
             * Clears the bounds of this mesh aswell as the buffers of the associated {@link RenderMesh}.
             */
            clear() {
                this.∆íbox = undefined;
                this.∆íradius = undefined;
                this.deleteRenderBuffers(this.renderMesh.buffers);
                this.renderMesh.clear();
            }
            //#region Transfer
            // Serialize/Deserialize for all meshes that calculate without parameters
            serialize() {
                let serialization = {
                    idResource: this.idResource,
                    name: this.name,
                    type: this.type // store for editor view
                }; // no data needed ...
                return serialization;
            }
            async deserialize(_serialization) {
                FudgeCore.Project.register(this, _serialization.idResource);
                this.name = _serialization.name;
                // type is an accessor and must not be deserialized
                return this;
            }
            reduceMutator(_mutator) {
                // TODO: so much to delete... rather just gather what to mutate
                delete _mutator.∆íbox;
                delete _mutator.∆íradius;
                delete _mutator.renderBuffers;
            }
            //#endregion
            createRadius() {
                //TODO: radius and bounding box could be created on construction of vertex-array
                let radius = 0;
                for (let i = 0; i < this.vertices.length; i++) {
                    radius = Math.max(radius, this.vertices.position(i).magnitudeSquared);
                }
                return Math.sqrt(radius);
            }
            createBoundingBox() {
                let box = FudgeCore.Recycler.get(FudgeCore.Box);
                box.set();
                for (let i = 0; i < this.vertices.length; i++) {
                    let point = this.vertices.position(i);
                    box.expand(point);
                }
                return box;
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return Mesh = _classThis;
    })();
    FudgeCore.Mesh = Mesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for materials. Combines a {@link Shader} with a compatible {@link Coat}
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let Material = (() => {
        var _a;
        let _classDecorators = [FudgeCore.enumerate, (_a = FudgeCore.SerializableResource).register.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Mutable;
        let _instanceExtraInitializers = [];
        let _get_coat_decorators;
        var Material = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _get_coat_decorators = [FudgeCore.type(FudgeCore.Coat), FudgeCore.enumerate];
                __esDecorate(this, null, _get_coat_decorators, { kind: "getter", name: "coat", static: false, private: false, access: { has: obj => "coat" in obj, get: obj => obj.coat }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                Material = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(_classThis, _classExtraInitializers);
            }
            #coat;
            constructor(_name, _shader, _coat) {
                super();
                /** The name to call the Material by. */
                this.name = __runInitializers(this, _instanceExtraInitializers);
                this.idResource = undefined;
                this.timestampUpdate = 0;
                this.name = _name;
                this.shaderType = _shader;
                if (_shader) {
                    if (_coat)
                        this.coat = _coat;
                    else
                        this.coat = this.createCoatMatchingShader();
                }
                FudgeCore.Project.register(this);
            }
            /**
             * Returns the currently referenced {@link Coat} instance
             */
            get coat() {
                return this.#coat;
            }
            /**
             * Makes this material reference the given {@link Coat} if it is compatible with the referenced {@link Shader}
             */
            set coat(_coat) {
                if (this.shaderType)
                    if (_coat.constructor != this.shaderType.getCoat())
                        if (_coat instanceof this.shaderType.getCoat())
                            FudgeCore.Debug.fudge("Coat is extension of Coat required by shader");
                        else
                            throw (new Error("Shader and coat don't match"));
                this.#coat = _coat;
            }
            /**
             * Creates a new {@link Coat} instance that is valid for the {@link Shader} referenced by this material
             */
            createCoatMatchingShader() {
                let coat = new (this.shaderType.getCoat())();
                return coat;
            }
            /**
             * Changes the materials reference to the given {@link Shader}, creates and references a new {@link Coat} instance
             * and mutates the new coat to preserve matching properties.
             * @param _shaderType
             */
            setShader(_shaderType) {
                this.shaderType = _shaderType;
                let coat = this.createCoatMatchingShader();
                coat.mutate(this.#coat?.getMutator());
                this.coat = coat;
            }
            /**
             * Returns the {@link Shader} referenced by this material
             */
            getShader() {
                return this.shaderType;
            }
            //#region Transfer
            // TODO: this type of serialization was implemented for implicit Material create. Check if obsolete when only one material class exists and/or materials are stored separately
            serialize() {
                let serialization = {
                    name: this.name,
                    idResource: this.idResource,
                    shader: this.shaderType.name,
                    coat: FudgeCore.Serializer.serialize(this.#coat),
                };
                return serialization;
            }
            async deserialize(_serialization) {
                this.name = _serialization.name;
                FudgeCore.Project.register(this, _serialization.idResource);
                this.shaderType = FudgeCore[_serialization.shader];
                let coat = await FudgeCore.Serializer.deserialize(_serialization.coat);
                this.coat = coat;
                return this;
            }
            reduceMutator(_mutator) {
                delete _mutator.timestampUpdate;
                // delete _mutator.idResource;
            }
        };
        return Material = _classThis;
    })();
    FudgeCore.Material = Material;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The namesapce for handling the particle data
     */
    let ParticleData;
    (function (ParticleData) {
        /**
         * Returns true if the given data is a {@link Expression}
         */
        function isExpression(_data) {
            return isFunction(_data) || isVariable(_data) || isConstant(_data) || isCode(_data);
        }
        ParticleData.isExpression = isExpression;
        /**
         * Returns true if the given data is a {@link Function}
         */
        function isFunction(_data) {
            return typeof _data == "object" && "function" in _data;
        }
        ParticleData.isFunction = isFunction;
        /**
         * Returns true if the given data is a {@link Variable}
         */
        function isVariable(_data) {
            return typeof _data == "object" && "value" in _data && typeof _data.value == "string";
        }
        ParticleData.isVariable = isVariable;
        /**
         * Returns true if the given data is a {@link Constant}
         */
        function isConstant(_data) {
            return typeof _data == "object" && "value" in _data && typeof _data.value == "number";
        }
        ParticleData.isConstant = isConstant;
        /**
         * Returns true if the given data is a {@link Code}
         */
        function isCode(_data) {
            return typeof _data == "object" && "code" in _data;
        }
        ParticleData.isCode = isCode;
        /**
         * Returns true if the given data is a {@link Transformation}
         */
        function isTransformation(_data) {
            return typeof _data == "object" && "transformation" in _data;
        }
        ParticleData.isTransformation = isTransformation;
    })(ParticleData = FudgeCore.ParticleData || (FudgeCore.ParticleData = {}));
    /**
     * Holds information on how to mutate the particles of a particle system.
     * A full particle system is composed by attaching a {@link ComponentParticleSystem}, {@link ComponentMesh} and {@link ComponentMaterial} to the same {@link Node}.
     * Additionally a {@link ComponentFaceCamera} can be attached to make the particles face the camera.
     * @authors Jonas Plotzky, HFU, 2022
     */
    let ParticleSystem = (() => {
        var _a;
        let _classDecorators = [(_a = FudgeCore.SerializableResource).register.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Mutable;
        var ParticleSystem = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                ParticleSystem = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(_classThis, _classExtraInitializers);
            }
            #data;
            /** Map of shader universal derivates to corresponding computed {@link ShaderParticleSystem}.
             * This way each particle system resource can be used in conjunction with multiple shader universal derivates */
            #mapShaderToShaderParticleSystem;
            constructor(_name = ParticleSystem.name, _data = {}) {
                super();
                this.idResource = undefined;
                /** Map of shader universal derivates to corresponding computed {@link ShaderParticleSystem}.
                 * This way each particle system resource can be used in conjunction with multiple shader universal derivates */
                this.#mapShaderToShaderParticleSystem = new Map();
                this.name = _name;
                this.data = _data;
                FudgeCore.Project.register(this);
            }
            get data() {
                return this.#data;
            }
            set data(_data) {
                this.#data = _data;
                this.#mapShaderToShaderParticleSystem.forEach(_shader => _shader.deleteProgram());
                this.#mapShaderToShaderParticleSystem.clear();
            }
            /**
             * Returns a corresponding {@link ShaderParticleSystem} for the given shader universal derivate.
             * Used by the render system to render the particle system.
             * @returns the corresponding {@link ShaderParticleSystem}
             * @internal
             */
            getShaderFrom(_source) {
                if (!this.#mapShaderToShaderParticleSystem.has(_source)) {
                    let particleShader = new FudgeCore.ShaderParticleSystem();
                    particleShader.data = this.data;
                    particleShader.define = [...particleShader.define, ..._source.define];
                    particleShader.vertexShaderSource = _source.getVertexShaderSource();
                    particleShader.fragmentShaderSource = _source.getFragmentShaderSource();
                    this.#mapShaderToShaderParticleSystem.set(_source, particleShader);
                }
                return this.#mapShaderToShaderParticleSystem.get(_source);
            }
            //#region Transfer
            serialize() {
                let serialization = {
                    idResource: this.idResource,
                    name: this.name,
                    data: this.data
                };
                return serialization;
            }
            async deserialize(_serialization) {
                FudgeCore.Project.register(this, _serialization.idResource);
                this.name = _serialization.name;
                this.data = _serialization.data;
                return this;
            }
            reduceMutator(_mutator) {
                delete _mutator.cachedMutators;
                delete _mutator.shaderMap;
            }
        };
        return ParticleSystem = _classThis;
    })();
    FudgeCore.ParticleSystem = ParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Buffers the bone data from the {@link ComponentSkeleton} into a WebGL Buffer
     * @internal
     */
    class RenderInjectorComponentSkeleton {
        static decorate(_constructor, _context) {
            Object.defineProperty(_constructor.prototype, _constructor.prototype.useRenderBuffer.name, {
                value: RenderInjectorComponentSkeleton.useRenderBuffer
            });
            Object.defineProperty(_constructor.prototype, _constructor.prototype.updateRenderBuffer.name, {
                value: RenderInjectorComponentSkeleton.updateRenderBuffer
            });
            Object.defineProperty(_constructor.prototype, _constructor.prototype.deleteRenderBuffer.name, {
                value: RenderInjectorComponentSkeleton.deleteRenderBuffer
            });
        }
        static useRenderBuffer() {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.renderBuffer)
                crc3.bindBufferBase(WebGL2RenderingContext.UNIFORM_BUFFER, FudgeCore.UNIFORM_BLOCK.SKIN.BINDING, this.renderBuffer);
        }
        static updateRenderBuffer() {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (!this.renderBuffer) {
                const bonesByteSize = 256 * 16 * 4; // CAUTION: this is dependent on the shader source code where 256 is the maximum number of bones
                this.renderBuffer = FudgeCore.RenderWebGL.assert(crc3.createBuffer());
                crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, this.renderBuffer);
                crc3.bufferData(WebGL2RenderingContext.UNIFORM_BUFFER, bonesByteSize, WebGL2RenderingContext.DYNAMIC_DRAW);
            }
            if (!this.mtxBonesData) {
                this.mtxBones = new Array(this.bones.length);
                this.mtxBonesData = new Float32Array(this.bones.length * 16);
                for (let i = 0; i < this.bones.length; i++)
                    this.mtxBones[i] = new FudgeCore.Matrix4x4(this.mtxBonesData.subarray(i * 16, i * 16 + 16));
            }
            for (let i = 0; i < this.bones.length; i++)
                FudgeCore.Matrix4x4.PRODUCT(this.bones[i].mtxWorld, this.mtxBindInverses[i], this.mtxBones[i]);
            crc3.bindBuffer(WebGL2RenderingContext.UNIFORM_BUFFER, this.renderBuffer);
            crc3.bufferSubData(WebGL2RenderingContext.UNIFORM_BUFFER, 0, this.mtxBonesData);
        }
        static deleteRenderBuffer() {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (this.renderBuffer)
                crc3.deleteBuffer(this.renderBuffer);
        }
    }
    FudgeCore.RenderInjectorComponentSkeleton = RenderInjectorComponentSkeleton;
})(FudgeCore || (FudgeCore = {}));
///<reference path="./../Render/RenderInjectorComponentSkeleton.ts"/>
var FudgeCore;
///<reference path="./../Render/RenderInjectorComponentSkeleton.ts"/>
(function (FudgeCore) {
    /**
     * Holds an array of bones ({@link Node}s within a {@link Graph}). Referenced from a {@link ComponentMesh} it can be associated with a {@link Mesh} and enable skinning for the mesh.
     * @authors Matthias Roming, HFU, 2022-2023 | Jonas Plotzky, HFU, 2023
     */
    let ComponentSkeleton = (() => {
        var _a;
        let _classDecorators = [(_a = FudgeCore.RenderInjectorComponentSkeleton).decorate.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Component;
        var ComponentSkeleton = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                ComponentSkeleton = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(_classThis, _classExtraInitializers);
            }
            constructor(_bones = [], _mtxBoneInverses = []) {
                super();
                this.singleton = false;
                this.bones = _bones;
                this.mtxBindInverses = _mtxBoneInverses;
                for (let i = 0; i < this.bones.length; i++) {
                    if (this.mtxBindInverses[i] == null)
                        this.mtxBindInverses[i] = this.bones[i].mtxWorldInverse.clone;
                }
            }
            /**
             * Injected by {@link RenderInjectorComponentSkeleton}.
             * Used by the render system.
             * @internal
             */
            useRenderBuffer() { }
            ;
            /**
             * Injected by {@link RenderInjectorComponentSkeleton}.
             * Used by the render system.
             * @internal
             */
            updateRenderBuffer() { }
            /**
             * Injected by {@link RenderInjectorComponentSkeleton}.
             * Used by the render system.
             * @internal
             */
            deleteRenderBuffer() { }
            /**
             * Adds a node as a bone with its bind inverse matrix
             */
            addBone(_bone, _mtxBindInverse = _bone.mtxWorldInverse.clone) {
                this.bones.push(_bone);
                this.mtxBindInverses.push(_mtxBindInverse);
                this.mtxBonesData = null;
            }
            indexOf(_name) {
                if (typeof (_name) == "string")
                    return this.bones.findIndex((_bone) => _bone.name == _name);
                else
                    return this.bones.indexOf(_name);
            }
            /**
             * Resets the pose of this skeleton to the default pose
             */
            resetPose() {
                for (let i = 0; i < this.bones.length; i++)
                    this.bones[i].mtxLocal.copy(FudgeCore.Matrix4x4.INVERSE(this.mtxBindInverses[i]));
            }
            serialize() {
                const serialization = {};
                serialization[super.constructor.name] = super.serialize();
                serialization.bones = this.bones.map(_bone => FudgeCore.Node.PATH_FROM_TO(this, _bone));
                serialization.mtxBindInverses = FudgeCore.Serializer.serializeArray(FudgeCore.Matrix4x4, this.mtxBindInverses);
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization[super.constructor.name]);
                const hndNodeDeserialized = () => {
                    this.bones = _serialization.bones.map((_path) => {
                        let bone = FudgeCore.Node.FIND(this, _path);
                        if (!bone)
                            throw new Error(`${FudgeCore.Node.name} "${this.node.name}" ${ComponentSkeleton.name}: Could not find bone ${_path}`);
                        return bone;
                    });
                    this.removeEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
                };
                this.addEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
                this.mtxBindInverses = await FudgeCore.Serializer.deserializeArray(_serialization.mtxBindInverses);
                return this;
            }
        };
        return ComponentSkeleton = _classThis;
    })();
    FudgeCore.ComponentSkeleton = ComponentSkeleton;
})(FudgeCore || (FudgeCore = {}));
/// <reference path="Debug/Performance.ts"/>
/// <reference path="Debug/DebugTarget.ts"/>
/// <reference path="Debug/Debug.ts"/>
// / <reference path="Time/Time.ts"/>
/// <reference path="Event/Event.ts"/>
/// <reference path="Recycle/RecyclableEvent.ts"/>
/// <reference path="Serialization/Mutable.ts"/>
/// <reference path="Serialization/Serializer.ts"/> 
/// <reference path="Render/RenderWebGL.ts"/>
/// <reference path="Render/RenderInjectorTexture.ts"/>
/// <reference path="Graph/Node.ts"/>
/// <reference path="Component/Component.ts"/>
/// <reference path="Recycle/RecycableArray.ts"/>
/// <reference path="Physics/HelpersPhysics.ts"/>
/// <reference path="Physics/Joint.ts"/>
/// <reference path="Physics/JointAxial.ts"/>
/// <reference path="Serialization/Project.ts"/>
/// <reference path="Texture/Texture.ts"/>
/// <reference path="Mesh/Mesh.ts"/>
/// <reference path="Material/Material.ts"/>
/// <reference path="ParticleSystem/ParticleSystem.ts"/>
/// <reference path="Component/ComponentSkeleton.ts"/>
//global functions
function ifNumber(_check, _default) {
    return typeof _check == "undefined" ? _default : _check;
}
var FudgeCore;
(function (FudgeCore) {
    /**
     * Internally used to differentiate between the various generated structures and events.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_STRUCTURE_TYPE;
    (function (ANIMATION_STRUCTURE_TYPE) {
        /**Default: forward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["NORMAL"] = 0] = "NORMAL";
        /**backward, continous */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["REVERSE"] = 1] = "REVERSE";
        /**forward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTERED"] = 2] = "RASTERED";
        /**backward, rastered */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["RASTEREDREVERSE"] = 3] = "RASTEREDREVERSE";
        /** forward, sampled at discrete frame times */
        ANIMATION_STRUCTURE_TYPE[ANIMATION_STRUCTURE_TYPE["SAMPLED"] = 4] = "SAMPLED";
    })(ANIMATION_STRUCTURE_TYPE || (ANIMATION_STRUCTURE_TYPE = {}));
    /**
     * Holds different playmodes the animation uses to play back its animation.
     * @author Lukas Scheuerle, HFU, 2019
     */
    let ANIMATION_PLAYMODE;
    (function (ANIMATION_PLAYMODE) {
        /**Plays animation in a loop: it restarts once it hit the end.*/
        ANIMATION_PLAYMODE["LOOP"] = "loop";
        /**Plays animation once and stops at the last key/frame*/
        ANIMATION_PLAYMODE["PLAY_ONCE"] = "playOnce";
        /**Plays animation once and stops on the first key/frame */
        ANIMATION_PLAYMODE["PLAY_ONCE_RESET"] = "playOnceReset";
        /**Plays animation like LOOP, but backwards.*/
        ANIMATION_PLAYMODE["REVERSE_LOOP"] = "reverseLoop";
        /**Causes the animation not to play at all. Useful for jumping to various positions in the animation without proceeding in the animation.*/
        ANIMATION_PLAYMODE["STOP"] = "stop";
        //TODO: add an INHERIT and a PINGPONG mode
    })(ANIMATION_PLAYMODE = FudgeCore.ANIMATION_PLAYMODE || (FudgeCore.ANIMATION_PLAYMODE = {}));
    let ANIMATION_QUANTIZATION;
    (function (ANIMATION_QUANTIZATION) {
        //TODO: add an in-depth description of what happens to the animation (and events) depending on the quantization. Use Graphs to explain.
        /**Calculates the state of the animation at the exact position of time. Ignores FPS value of animation.*/
        ANIMATION_QUANTIZATION["CONTINOUS"] = "continous";
        /**Limits the calculation of the state of the animation to the FPS value of the animation. Skips frames if needed.*/
        ANIMATION_QUANTIZATION["DISCRETE"] = "discrete";
        /** Advances the time each frame according to the FPS value of the animation, ignoring the actual duration of the frames. Doesn't skip any frames.*/
        ANIMATION_QUANTIZATION["FRAMES"] = "frames";
    })(ANIMATION_QUANTIZATION = FudgeCore.ANIMATION_QUANTIZATION || (FudgeCore.ANIMATION_QUANTIZATION = {}));
    /**
     * Describes and controls and animation by yielding mutators
     * according to the stored {@link AnimationStructure} and {@link AnimationSequenceNumber}s
     * Applied to a {@link Node} directly via script or {@link ComponentAnimation}.
     * @authors Lukas Scheuerle, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2021-2023 | Jonas Plotzky, HFU, 2025
     */
    let Animation = (() => {
        var _a;
        let _classDecorators = [(_a = FudgeCore.SerializableResource).register.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Mutable;
        var Animation = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                Animation = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            // /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
            // public static readonly baseClass: typeof Animation = Animation;
            // /** list of all the subclasses derived from this class, if they registered properly*/
            static { this.subclasses = []; }
            static { this.iSubclass = Animation.registerSubclass(Animation); }
            #animationStructuresProcessed;
            constructor(_name = Animation.name, _animStructure = {}, _fps = 60) {
                super();
                this.idResource = undefined;
                this.totalTime = 0; // Why isn't this called duration or length?
                this.labels = {}; // a label marks a specific time to conveniently jump to using a text identifier
                this.sampled = false; // TODO: if set the cache needs to be adjusted (animationStructuresProcessed)
                this.events = {};
                this.framesPerSecond = 60; // TODO: change this and its accessors to #framesPerSecond?
                // processed eventlist and animation strucutres for playback.
                this.eventsProcessed = new Map();
                this.#animationStructuresProcessed = new Map();
                this.name = _name;
                this.animationStructure = _animStructure;
                this.#animationStructuresProcessed.set(ANIMATION_STRUCTURE_TYPE.NORMAL, _animStructure);
                this.framesPerSecond = _fps;
                this.calculateTotalTime();
                FudgeCore.Project.register(this);
            }
            /**
             * Override the given base mutator with the given override mutator using linear interpolation between the values with the given weight.
             * Set the intersect flag to only include properties in the result that exist in both of the given mutators.
             */
            static blendOverride(_base, _override, _weight, _intersect = false) {
                return Animation.blendRecursive(_base, _override, 1 - _weight, _weight, _intersect);
            }
            /**
             * Add the given additive mutator to the given base mutator. The values of the additive mutator will be multiplied by the given weight.
             */
            static blendAdditive(_base, _add, _weight) {
                return Animation.blendRecursive(_base, _add, 1, _weight);
            }
            /**
             * Blend the two given mutators together, using the given weights to determine the influence of each.
             * The resulting mutator will contain all properties of the base mutator, with the properties of the blend mutator blended in.
             * Blend mutator properties that don't exist in the base mutator will be added to the result mutator.
             * Set the intersect flag to only include properties in the result that exist in both of the given mutators.
             */
            static blendRecursive(_base, _blend, _weightBase, _weightBlend, _intersect = false) {
                let mutator = _intersect ? {} : { ..._base };
                for (const key in _blend) {
                    if (_intersect && _base[key] == undefined)
                        continue;
                    if (typeof _blend[key] == "number") {
                        mutator[key] = (_base[key] ?? 0) * _weightBase + _blend[key] * _weightBlend;
                        continue;
                    }
                    if (typeof _base[key] == "object") {
                        let base = _base[key];
                        let blend = _blend[key];
                        if (base.x != undefined && base.y != undefined && base.z != undefined && base.w != undefined && FudgeCore.Quaternion.DOT(base, blend) < 0)
                            FudgeCore.Quaternion.negate(base); // TODO: eliminate this side effect
                        mutator[key] = this.blendRecursive(base, blend, _weightBase, _weightBlend, _intersect);
                        continue;
                    }
                    if (typeof _blend[key] === "object") {
                        mutator[key] = this.blendRecursive({}, _blend[key], _weightBase, _weightBlend, _intersect);
                        continue;
                    }
                }
                return mutator;
            }
            static registerSubclass(_subClass) { return Animation.subclasses.push(_subClass) - 1; }
            get getLabels() {
                //TODO: this actually needs testing
                let en = new Enumerator(this.labels);
                return en;
            }
            get fps() {
                return this.framesPerSecond;
            }
            set fps(_fps) {
                this.framesPerSecond = _fps;
                this.eventsProcessed.clear();
                this.clearCache();
            }
            /**
             * Clear this animations cache.
             */
            clearCache() {
                this.#animationStructuresProcessed.clear();
            }
            /**
             * Generates and returns a {@link Mutator} with the information to apply to the {@link Node} to animate
             * in the state the animation is in at the given time, direction and quantization
             */
            getState(_time, _direction, _quantization, _mutatorOut = {}) {
                let frame = this.sampled ? Math.floor(_time * this.framesPerSecond / 1000) : undefined;
                return this.traverseStructureForMutator(this.getAnimationStructure(_direction, _quantization), _time, frame, _mutatorOut);
            }
            /**
             * Returns a list of the names of the events the {@link ComponentAnimation} needs to fire between _min and _max input values.
             * @param _direction The direction the animation is supposed to run in. >0 == forward, 0 == stop, <0 == backwards
             * @returns a list of strings with the names of the custom events to fire.
             */
            getEventsToFire(_min, _max, _quantization, _direction) {
                let events = [];
                let minSection = Math.floor(_min / this.totalTime);
                let maxSection = Math.floor(_max / this.totalTime);
                _min = _min % this.totalTime;
                _max = _max % this.totalTime;
                while (minSection <= maxSection) {
                    let eventTriggers = this.getCorrectEventList(_direction, _quantization);
                    if (minSection == maxSection) {
                        this.addEventsBetween(eventTriggers, _min, _max, events);
                    }
                    else {
                        this.addEventsBetween(eventTriggers, _min, _max, events);
                        _min = 0;
                    }
                    minSection++;
                }
                return events;
            }
            /**
             * Adds an Event to the List of events.
             * @param _name The name of the event (needs to be unique per Animation).
             * @param _time The timestamp of the event (in milliseconds).
             */
            setEvent(_name, _time) {
                this.events[_name] = _time;
                this.eventsProcessed.clear();
            }
            /**
             * Removes the event with the given name from the list of events.
             * @param _name name of the event to remove.
             */
            removeEvent(_name) {
                delete this.events[_name];
                this.eventsProcessed.clear();
            }
            /**
             * (Re-)Calculate the total time of the Animation. Calculation-heavy, use only if actually needed.
             */
            calculateTotalTime() {
                this.totalTime = 0;
                this.traverseStructureForTime(this.animationStructure);
                // if (this.totalTime == 0) // animations with one keyframe need a total time != 0 to work
                //   this.totalTime = 1;
            }
            /**
             * Returns the time to use for animation sampling when applying a playmode
             */
            getModalTime(_time, _playmode, _timeStop = _time) {
                switch (_playmode) {
                    case ANIMATION_PLAYMODE.STOP:
                        // return this.localTime.getOffset();
                        return _timeStop;
                    case ANIMATION_PLAYMODE.PLAY_ONCE:
                        if (_time >= this.totalTime)
                            return this.totalTime - 0.01; //TODO: this might cause some issues
                    case ANIMATION_PLAYMODE.PLAY_ONCE_RESET:
                        if (_time >= this.totalTime)
                            // TODO: return _timeStop instead?
                            return this.totalTime + 0.01; //TODO: this might cause some issues
                }
                return _time;
            }
            /**
             * Calculates and returns the direction the animation should currently be playing in.
             * @param _time the time at which to calculate the direction
             * @returns 1 if forward, 0 if stop, -1 if backwards
             */
            calculateDirection(_time, _playmode) {
                switch (_playmode) {
                    case ANIMATION_PLAYMODE.STOP:
                        return 0;
                    // case ANIMATION_PLAYMODE.PINGPONG:
                    //   if (Math.floor(_time / this.animation.totalTime) % 2 == 0)
                    //     return 1;
                    //   else
                    //     return -1;
                    case ANIMATION_PLAYMODE.REVERSE_LOOP:
                        return -1;
                    case ANIMATION_PLAYMODE.PLAY_ONCE:
                    case ANIMATION_PLAYMODE.PLAY_ONCE_RESET:
                        if (_time >= this.totalTime) {
                            return 0;
                        }
                    default:
                        return 1;
                }
            }
            //#region transfer
            serialize() {
                let s = {
                    idResource: this.idResource,
                    name: this.name,
                    labels: {},
                    events: {},
                    sampled: this.sampled,
                    framesPerSecond: this.framesPerSecond
                    // sps: this.stepsPerSecond
                };
                for (let name in this.labels) {
                    s.labels[name] = this.labels[name];
                }
                for (let name in this.events) {
                    s.events[name] = this.events[name];
                }
                s.animationStructure = this.traverseStructureForSerialization(this.animationStructure);
                return s;
            }
            async deserialize(_serialization) {
                FudgeCore.Project.register(this, _serialization.idResource);
                this.name = _serialization.name;
                this.sampled = _serialization.sampled;
                this.framesPerSecond = _serialization.framesPerSecond;
                // this.stepsPerSecond = _serialization.sps;
                this.labels = {};
                for (let name in _serialization.labels) {
                    this.labels[name] = _serialization.labels[name];
                }
                this.events = {};
                for (let name in _serialization.events) {
                    this.events[name] = _serialization.events[name];
                }
                this.eventsProcessed = new Map();
                this.animationStructure = await this.traverseStructureForDeserialization(_serialization.animationStructure);
                this.#animationStructuresProcessed = new Map();
                this.calculateTotalTime();
                return this;
            }
            // public getMutator(): Mutator {
            //   return this.serialize();
            // }
            reduceMutator(_mutator) {
                delete _mutator.totalTime;
            }
            /**
             * Traverses an AnimationStructure and returns the Serialization of said Structure.
             * @param _structure The Animation Structure at the current level to transform into the Serialization.
             * @returns the filled Serialization.
             */
            traverseStructureForSerialization(_structure) {
                let serialization = {};
                for (const property in _structure) {
                    let structureOrSequence = _structure[property];
                    if (structureOrSequence instanceof FudgeCore.AnimationSequence)
                        serialization[property] = structureOrSequence.serialize();
                    else
                        serialization[property] = this.traverseStructureForSerialization(structureOrSequence);
                }
                return serialization;
            }
            /**
             * Traverses a Serialization to create a new AnimationStructure.
             * @param _serialization The serialization to transfer into an AnimationStructure
             * @returns the newly created AnimationStructure.
             */
            async traverseStructureForDeserialization(_serialization) {
                let structure = {};
                for (let n in _serialization) {
                    if (_serialization[n].animationSequence) {
                        let animSeq = new FudgeCore.AnimationSequence([], null);
                        structure[n] = (await animSeq.deserialize(_serialization[n]));
                    }
                    else {
                        structure[n] = await this.traverseStructureForDeserialization(_serialization[n]);
                    }
                }
                return structure;
            }
            //#endregion
            /**
             * Finds and returns the list of events to be used with these settings.
             */
            getCorrectEventList(_direction, _quantization) {
                if (_quantization != ANIMATION_QUANTIZATION.FRAMES) {
                    if (_direction >= 0) {
                        return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.NORMAL);
                    }
                    else {
                        return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE);
                    }
                }
                else {
                    if (_direction >= 0) {
                        return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTERED);
                    }
                    else {
                        return this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE);
                    }
                }
            }
            /**
             * Traverses an {@link AnimationStructure} and returns a {@link Mutator} describing the state at the given time.
             */
            traverseStructureForMutator(_structure, _time, _frame, _mutatorOut = {}) {
                if (Array.isArray(_structure))
                    for (let n = 0; n < _structure.length; n++) {
                        if (_structure[n] instanceof FudgeCore.AnimationSequence)
                            _mutatorOut[n] = _structure[n].evaluate(_time, _frame, _mutatorOut[n]);
                        else
                            _mutatorOut[n] = this.traverseStructureForMutator(_structure[n], _time, _frame, _mutatorOut[n]);
                    }
                else
                    for (let n in _structure) {
                        if (_structure[n] instanceof FudgeCore.AnimationSequence)
                            _mutatorOut[n] = _structure[n].evaluate(_time, _frame, _mutatorOut[n]);
                        else
                            _mutatorOut[n] = this.traverseStructureForMutator(_structure[n], _time, _frame, _mutatorOut[n]);
                    }
                return _mutatorOut;
            }
            /**
             * Traverses the current AnimationStrcuture to find the totalTime of this animation.
             * @param _structure The structure to traverse
             */
            traverseStructureForTime(_structure) {
                for (let n in _structure) {
                    if (_structure[n] instanceof FudgeCore.AnimationSequence) {
                        let sequence = _structure[n];
                        if (sequence.length > 0) {
                            let sequenceTime = sequence.getKey(sequence.length - 1).time;
                            this.totalTime = Math.max(sequenceTime, this.totalTime);
                        }
                    }
                    else {
                        this.traverseStructureForTime(_structure[n]);
                    }
                }
            }
            getAnimationStructure(_direction, _quantization) {
                let animationStructure;
                if (_quantization == ANIMATION_QUANTIZATION.CONTINOUS)
                    if (this.sampled)
                        animationStructure = ANIMATION_STRUCTURE_TYPE.SAMPLED;
                    else
                        animationStructure = _direction < 0 ? ANIMATION_STRUCTURE_TYPE.REVERSE : ANIMATION_STRUCTURE_TYPE.NORMAL;
                else
                    animationStructure = _direction < 0 ? ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE : ANIMATION_STRUCTURE_TYPE.RASTERED;
                return this.getProcessedAnimationStructure(animationStructure);
            }
            /**
             * Ensures the existance of the requested {@link AnimationStructure} and returns it.
             * @param _type the type of the structure to get
             * @returns the requested [[@link AnimationStructure]]
             */
            getProcessedAnimationStructure(_type) {
                let processed = this.#animationStructuresProcessed.get(_type);
                if (processed)
                    return processed;
                this.calculateTotalTime();
                processed = {};
                switch (_type) {
                    case ANIMATION_STRUCTURE_TYPE.NORMAL:
                        processed = this.animationStructure;
                        break;
                    case ANIMATION_STRUCTURE_TYPE.REVERSE:
                        processed = this.traverseStructureForNewStructure(this.animationStructure, this.calculateReverseSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTERED:
                        processed = this.traverseStructureForNewStructure(this.animationStructure, this.calculateRasteredSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                        processed = this.traverseStructureForNewStructure(this.getProcessedAnimationStructure(ANIMATION_STRUCTURE_TYPE.REVERSE), this.calculateRasteredSequence.bind(this));
                        break;
                    case ANIMATION_STRUCTURE_TYPE.SAMPLED:
                        processed = this.traverseStructureForNewStructure(this.animationStructure, this.calculateSampledSequence.bind(this));
                        break;
                    default:
                        return undefined;
                }
                this.#animationStructuresProcessed.set(_type, processed);
                return processed;
            }
            /**
             * Ensures the existance of the requested {@link AnimationEventTrigger} and returns it.
             * @param _type The type of AnimationEventTrigger to get
             * @returns the requested {@link AnimationEventTrigger}
             */
            getProcessedEventTrigger(_type) {
                let processed = this.eventsProcessed.get(_type);
                if (processed)
                    return processed;
                this.calculateTotalTime();
                processed = {};
                switch (_type) {
                    case ANIMATION_STRUCTURE_TYPE.NORMAL:
                        processed = this.events;
                        break;
                    case ANIMATION_STRUCTURE_TYPE.REVERSE:
                        processed = this.calculateReverseEventTriggers(this.events);
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTERED:
                        processed = this.calculateRasteredEventTriggers(this.events);
                        break;
                    case ANIMATION_STRUCTURE_TYPE.RASTEREDREVERSE:
                        processed = this.calculateRasteredEventTriggers(this.getProcessedEventTrigger(ANIMATION_STRUCTURE_TYPE.REVERSE));
                        break;
                    default:
                        return undefined;
                }
                this.eventsProcessed.set(_type, processed);
                return processed;
            }
            /**
             * Traverses an existing structure to apply a recalculation function to the AnimationStructure to store in a new Structure.
             * @param _oldStructure The old structure to traverse
             * @param _functionToUse The function to use to recalculated the structure.
             * @returns A new Animation Structure with the recalulated Animation Sequences.
             */
            traverseStructureForNewStructure(_oldStructure, _functionToUse) {
                let newStructure = {};
                for (let n in _oldStructure) {
                    if (_oldStructure[n] instanceof FudgeCore.AnimationSequence) {
                        newStructure[n] = _functionToUse(_oldStructure[n]);
                    }
                    else {
                        newStructure[n] = this.traverseStructureForNewStructure(_oldStructure[n], _functionToUse);
                    }
                }
                return newStructure;
            }
            /**
             * Creates a reversed Animation Sequence out of a given Sequence.
             * @param _sequence The sequence to calculate the new sequence out of
             * @returns The reversed Sequence
             */
            calculateReverseSequence(_sequence) {
                let keys = new Array(_sequence.length);
                for (let i = 0; i < _sequence.length; i++) {
                    let oldKey = _sequence.getKey(i);
                    keys[i] = new FudgeCore.AnimationKey(this.totalTime - oldKey.time, oldKey.value, oldKey.interpolation, oldKey.slopeOut, oldKey.slopeIn);
                }
                return new FudgeCore.AnimationSequence(keys, _sequence.classType);
            }
            /**
             * Creates a rastered {@link AnimationSequenceNumber} out of a given sequence.
             * @param _sequence The sequence to calculate the new sequence out of
             * @returns the rastered sequence.
             */
            calculateRasteredSequence(_sequence) {
                let keys = [];
                let frameTime = 1000 / this.framesPerSecond;
                for (let i = 0; i < this.totalTime; i += frameTime)
                    keys.push(new FudgeCore.AnimationKey(i, _sequence.evaluate(i), FudgeCore.ANIMATION_INTERPOLATION.CONSTANT));
                return new FudgeCore.AnimationSequence(keys, _sequence.classType);
            }
            /**
             * Creates a {@link AnimationSequenceSampled} out of a given sequence.
             */
            calculateSampledSequence(_sequence) {
                const frameTime = 1000 / this.framesPerSecond;
                const nFrames = Math.ceil(this.totalTime / frameTime);
                let keysOriginal = _sequence.getKeys();
                let keysSampled = new Array(nFrames + 1);
                for (let iSampled = 0, iOriginal = 0, time = 0; iSampled <= nFrames; iSampled++, time += frameTime) {
                    while (iOriginal < keysOriginal.length - 1 && keysOriginal[iOriginal + 1].time <= time + 1e-3)
                        iOriginal++;
                    keysSampled[iSampled] = keysOriginal[iOriginal];
                }
                return new FudgeCore.AnimationSequenceSampled(keysSampled, _sequence.classType);
                ;
            }
            /**
             * Creates a new reversed {@link AnimationEventTrigger} object based on the given one.
             * @param _events the event object to calculate the new one out of
             * @returns the reversed event object
             */
            calculateReverseEventTriggers(_events) {
                let ae = {};
                for (let name in _events) {
                    ae[name] = this.totalTime - _events[name];
                }
                return ae;
            }
            /**
             * Creates a rastered {@link AnimationEventTrigger} object based on the given one.
             * @param _events the event object to calculate the new one out of
             * @returns the rastered event object
             */
            calculateRasteredEventTriggers(_events) {
                let ae = {};
                let frameTime = 1000 / this.framesPerSecond;
                for (let name in _events) {
                    ae[name] = _events[name] - (_events[name] % frameTime);
                }
                return ae;
            }
            /**
             * Checks which events lay between two given times and returns the names of the ones that do.
             * @param _eventTriggers The event object to check the events inside of.
             * @param _min the minimum of the range to check between (inclusive).
             * @param _max the maximum of the range to check between (exclusive).
             * @param _events the array to add the names of the events to.
             * @returns an given array of the events appended with the events in the given range.
             */
            addEventsBetween(_eventTriggers, _min, _max, _events) {
                for (let name in _eventTriggers) {
                    if (_min <= _eventTriggers[name] && _eventTriggers[name] < _max) {
                        _events.push(name);
                    }
                }
                return _events;
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return Animation = _classThis;
    })();
    FudgeCore.Animation = Animation;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Calculates the values between {@link AnimationKeyNumber}s.
     * Represented internally by a cubic function (`f(x) = ax¬≥ + bx¬≤ + cx + d`).
     * Only needs to be recalculated when the keys change, so at runtime it should only be calculated once.
     * @authors Lukas Scheuerle, HFU, 2019 | Jonas Plotzky, HFU, 2025
     */
    class AnimationFunction {
        constructor(_keyIn, _keyOut = null) {
            this.keyIn = _keyIn;
            this.keyOut = _keyOut;
            this.calculate();
        }
        /**
         * Returns the parameter values of this cubic function. `f(x) = ax¬≥ + bx¬≤ + cx + d`
         * Used by editor.
         */
        getParameters() {
            return { a: this.a, b: this.b, c: this.c, d: this.d };
        }
    }
    FudgeCore.AnimationFunction = AnimationFunction;
    class AnimationFunctionNumber extends AnimationFunction {
        evaluate(_time) {
            _time -= this.keyIn.time;
            let time2 = _time * _time;
            let time3 = time2 * _time;
            return this.a * time3 + this.b * time2 + this.c * _time + this.d;
        }
        calculate() {
            this.d = this.c = this.b = this.a = 0;
            if (!this.keyIn)
                return;
            this.d = this.keyIn.value;
            if (!this.keyOut || this.keyIn.interpolation == FudgeCore.ANIMATION_INTERPOLATION.CONSTANT)
                return;
            let x1 = this.keyOut.time - this.keyIn.time;
            if (this.keyIn.interpolation == FudgeCore.ANIMATION_INTERPOLATION.LINEAR) {
                this.c = (this.keyOut.value - this.keyIn.value) / x1;
                return;
            }
            this.c = this.keyIn.slopeOut;
            this.a = (-x1 * (this.keyIn.slopeOut + this.keyOut.slopeIn) - 2 * this.keyIn.value + 2 * this.keyOut.value) / -Math.pow(x1, 3);
            this.b = (this.keyOut.slopeIn - this.keyIn.slopeOut - 3 * this.a * Math.pow(x1, 2)) / (2 * x1);
        }
    }
    FudgeCore.AnimationFunctionNumber = AnimationFunctionNumber;
    class AnimationFunctionVector3 extends AnimationFunction {
        evaluate(_time, _out = {}) {
            _time -= this.keyIn.time;
            let time2 = _time * _time;
            let time3 = time2 * _time;
            _out.x = this.a.x * time3 + this.b.x * time2 + this.c.x * _time + this.d.x;
            _out.y = this.a.y * time3 + this.b.y * time2 + this.c.y * _time + this.d.y;
            _out.z = this.a.z * time3 + this.b.z * time2 + this.c.z * _time + this.d.z;
            return _out;
        }
        calculate() {
            this.a = { x: 0, y: 0, z: 0 };
            this.b = { x: 0, y: 0, z: 0 };
            this.c = { x: 0, y: 0, z: 0 };
            this.d = { x: 0, y: 0, z: 0 };
            if (!this.keyIn)
                return;
            Object.assign(this.d, this.keyIn.value);
            if (!this.keyOut || this.keyIn.interpolation == FudgeCore.ANIMATION_INTERPOLATION.CONSTANT)
                return;
            let x1 = this.keyOut.time - this.keyIn.time;
            if (this.keyIn.interpolation == FudgeCore.ANIMATION_INTERPOLATION.LINEAR) {
                this.c.x = (this.keyOut.value.x - this.keyIn.value.x) / x1;
                this.c.y = (this.keyOut.value.y - this.keyIn.value.y) / x1;
                this.c.z = (this.keyOut.value.z - this.keyIn.value.z) / x1;
                return;
            }
            Object.assign(this.c, this.keyIn.slopeOut);
            this.a.x = (-x1 * (this.keyIn.slopeOut.x + this.keyOut.slopeIn.x) - 2 * this.keyIn.value.x + 2 * this.keyOut.value.x) / -Math.pow(x1, 3);
            this.a.y = (-x1 * (this.keyIn.slopeOut.y + this.keyOut.slopeIn.y) - 2 * this.keyIn.value.y + 2 * this.keyOut.value.y) / -Math.pow(x1, 3);
            this.a.z = (-x1 * (this.keyIn.slopeOut.z + this.keyOut.slopeIn.z) - 2 * this.keyIn.value.z + 2 * this.keyOut.value.z) / -Math.pow(x1, 3);
            this.b.x = (this.keyOut.slopeIn.x - this.keyIn.slopeOut.x - 3 * this.a.x * Math.pow(x1, 2)) / (2 * x1);
            this.b.y = (this.keyOut.slopeIn.y - this.keyIn.slopeOut.y - 3 * this.a.y * Math.pow(x1, 2)) / (2 * x1);
            this.b.z = (this.keyOut.slopeIn.z - this.keyIn.slopeOut.z - 3 * this.a.z * Math.pow(x1, 2)) / (2 * x1);
        }
    }
    FudgeCore.AnimationFunctionVector3 = AnimationFunctionVector3;
    class AnimationFunctionQuaternion extends AnimationFunction {
        evaluate(_time, _out = {}) {
            _time -= this.keyIn.time;
            let time2 = _time * _time;
            let time3 = time2 * _time;
            _out.x = this.a.x * time3 + this.b.x * time2 + this.c.x * _time + this.d.x;
            _out.y = this.a.y * time3 + this.b.y * time2 + this.c.y * _time + this.d.y;
            _out.z = this.a.z * time3 + this.b.z * time2 + this.c.z * _time + this.d.z;
            _out.w = this.a.w * time3 + this.b.w * time2 + this.c.w * _time + this.d.w;
            return _out;
        }
        calculate() {
            this.a = { x: 0, y: 0, z: 0, w: 0 };
            this.b = { x: 0, y: 0, z: 0, w: 0 };
            this.c = { x: 0, y: 0, z: 0, w: 0 };
            this.d = { x: 0, y: 0, z: 0, w: 0 };
            if (!this.keyIn)
                return;
            Object.assign(this.d, this.keyIn.value);
            if (!this.keyOut || this.keyIn.interpolation == FudgeCore.ANIMATION_INTERPOLATION.CONSTANT)
                return;
            let x1 = this.keyOut.time - this.keyIn.time;
            if (this.keyIn.interpolation == FudgeCore.ANIMATION_INTERPOLATION.LINEAR) {
                this.c.x = (this.keyOut.value.x - this.keyIn.value.x) / x1;
                this.c.y = (this.keyOut.value.y - this.keyIn.value.y) / x1;
                this.c.z = (this.keyOut.value.z - this.keyIn.value.z) / x1;
                this.c.w = (this.keyOut.value.w - this.keyIn.value.w) / x1;
                return;
            }
            Object.assign(this.c, this.keyIn.slopeOut);
            this.a.x = (-x1 * (this.keyIn.slopeOut.x + this.keyOut.slopeIn.x) - 2 * this.keyIn.value.x + 2 * this.keyOut.value.x) / -Math.pow(x1, 3);
            this.a.y = (-x1 * (this.keyIn.slopeOut.y + this.keyOut.slopeIn.y) - 2 * this.keyIn.value.y + 2 * this.keyOut.value.y) / -Math.pow(x1, 3);
            this.a.z = (-x1 * (this.keyIn.slopeOut.z + this.keyOut.slopeIn.z) - 2 * this.keyIn.value.z + 2 * this.keyOut.value.z) / -Math.pow(x1, 3);
            this.a.w = (-x1 * (this.keyIn.slopeOut.w + this.keyOut.slopeIn.w) - 2 * this.keyIn.value.w + 2 * this.keyOut.value.w) / -Math.pow(x1, 3);
            this.b.x = (this.keyOut.slopeIn.x - this.keyIn.slopeOut.x - 3 * this.a.x * Math.pow(x1, 2)) / (2 * x1);
            this.b.y = (this.keyOut.slopeIn.y - this.keyIn.slopeOut.y - 3 * this.a.y * Math.pow(x1, 2)) / (2 * x1);
            this.b.z = (this.keyOut.slopeIn.z - this.keyIn.slopeOut.z - 3 * this.a.z * Math.pow(x1, 2)) / (2 * x1);
            this.b.w = (this.keyOut.slopeIn.w - this.keyIn.slopeOut.w - 3 * this.a.w * Math.pow(x1, 2)) / (2 * x1);
        }
    }
    FudgeCore.AnimationFunctionQuaternion = AnimationFunctionQuaternion;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * An {@link Animation} loaded from a glTF-File.
     * @authors Jonas Plotzky
     */
    class AnimationGLTF extends FudgeCore.mixinSerializableResourceExternal(FudgeCore.Animation) {
        async load(_url = this.url, _name = this.name) {
            this.url = _url;
            this.name = _name;
            return FudgeCore.GLTFLoader.loadResource(this);
        }
        serialize() {
            const serialization = super.serialize();
            serialization.events = { ...this.events };
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.events = { ..._serialization.events };
            return this;
        }
    }
    FudgeCore.AnimationGLTF = AnimationGLTF;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let ANIMATION_INTERPOLATION;
    (function (ANIMATION_INTERPOLATION) {
        ANIMATION_INTERPOLATION[ANIMATION_INTERPOLATION["CONSTANT"] = 0] = "CONSTANT";
        ANIMATION_INTERPOLATION[ANIMATION_INTERPOLATION["LINEAR"] = 1] = "LINEAR";
        ANIMATION_INTERPOLATION[ANIMATION_INTERPOLATION["CUBIC"] = 2] = "CUBIC";
    })(ANIMATION_INTERPOLATION = FudgeCore.ANIMATION_INTERPOLATION || (FudgeCore.ANIMATION_INTERPOLATION = {}));
    /**
     * Holds information about continous points in time their accompanying values as well as their slopes.
     * Also holds a reference to the {@link AnimationFunction}s that come in and out of the sides.
     * The {@link AnimationFunction}s are handled by the {@link AnimationSequence}s.
     * If the property constant is true, the value does not change and wil not be interpolated between this and the next key in a sequence
     * @authors Lukas Scheuerle, HFU, 2019 | Jonas Plotzky, HFU, 2025
     */
    class AnimationKey extends FudgeCore.Mutable {
        #interpolation;
        #time;
        #value;
        #slopeIn;
        #slopeOut;
        constructor(_time = 0, _value, _interpolation = ANIMATION_INTERPOLATION.CUBIC, _slopeIn, _slopeOut) {
            super();
            this.#time = _time;
            this.#value = _value;
            this.#interpolation = _interpolation;
            this.#slopeIn = _slopeIn;
            this.#slopeOut = _slopeOut;
            if (typeof this.#value == "object") {
                this.#slopeIn ??= {};
                this.#slopeOut ??= {};
                for (const key of Object.keys(this.#value)) {
                    Reflect.set(this.#slopeIn, key, 0);
                    Reflect.set(this.#slopeOut, key, 0);
                }
            }
            else if (typeof this.#value == "number") {
                this.#slopeIn ??= 0;
                this.#slopeOut ??= 0;
            }
        }
        /**
         * Static comparation function to use in an array sort function to sort the keys by their time.
         * @param _a the animation key to check
         * @param _b the animation key to check against
         * @returns >0 if a>b, 0 if a=b, <0 if a<b
         */
        static compare(_a, _b) {
            return _a.time - _b.time;
        }
        get time() {
            return this.#time;
        }
        set time(_time) {
            this.#time = _time;
            this.functionOut.calculate();
        }
        get value() {
            return this.#value;
        }
        set value(_value) {
            this.#value = _value;
            this.functionOut.calculate();
        }
        get interpolation() {
            return this.#interpolation;
        }
        set interpolation(_interpolation) {
            this.#interpolation = _interpolation;
            this.functionOut.calculate();
        }
        get slopeIn() {
            return this.#slopeIn;
        }
        set slopeIn(_slope) {
            this.#slopeIn = _slope;
        }
        get slopeOut() {
            return this.#slopeOut;
        }
        set slopeOut(_slope) {
            this.#slopeOut = _slope;
            this.functionOut.calculate();
        }
        //#region transfer
        serialize() {
            let serialization = {};
            serialization.time = this.#time;
            serialization.value = this.#value;
            serialization.interpolation = this.#interpolation;
            serialization.slopeIn = this.#slopeIn;
            serialization.slopeOut = this.#slopeOut;
            return serialization;
        }
        async deserialize(_serialization) {
            this.#time = _serialization.time;
            this.#value = _serialization.value;
            this.#interpolation = _serialization.interpolation;
            this.#slopeIn = _serialization.slopeIn;
            this.#slopeOut = _serialization.slopeOut;
            return this;
        }
        getMutator() {
            return this.serialize();
        }
        reduceMutator(_mutator) {
            //
        }
    }
    FudgeCore.AnimationKey = AnimationKey;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Blending modes used in {@link AnimationNodeBlend}. */
    let ANIMATION_BLENDING;
    (function (ANIMATION_BLENDING) {
        /** Adds this animation to the previous animations. */
        ANIMATION_BLENDING["ADDITIVE"] = "Additive";
        /** Overrides the previous animations using linear interpolation. */
        ANIMATION_BLENDING["OVERRIDE"] = "Override";
    })(ANIMATION_BLENDING = FudgeCore.ANIMATION_BLENDING || (FudgeCore.ANIMATION_BLENDING = {}));
    /**
     * Base class for all animation nodes. Animation nodes form an animation graph enabling hierachical animation blending and animation transitions.
     * Can be attached to a {@link Node} via {@link ComponentAnimationGraph}.
     * @author Jonas Plotzky, HFU, 2024-2025
     */
    class AnimationNode {
        constructor(_options) {
            this.speed = _options?.speed ?? 1;
            this.weight = _options?.weight ?? 1;
            this.blending = _options?.blending ?? ANIMATION_BLENDING.OVERRIDE;
        }
    }
    FudgeCore.AnimationNode = AnimationNode;
    /**
     * Evaluates a single {@link Animation} providing a {@link mutator} and {@link events}.
     * Used as an input for other {@link AnimationNode}s.
     * @author Jonas Plotzky, HFU, 2024-2025
     */
    class AnimationNodeAnimation extends AnimationNode {
        constructor(_animation, _options) {
            super(_options);
            if (!_animation)
                return;
            if (!(_animation instanceof FudgeCore.Animation)) {
                this.mutator = _animation;
                return;
            }
            this.animation = _animation;
            this.offset = _options?.offset ?? 0;
            this.playmode = _options?.playmode;
            this.time = 0;
        }
        /** Resets this node to its {@link offset} time. */
        reset() {
            this.time = this.offset;
        }
        update(_deltaTime) {
            if (!this.animation)
                return;
            _deltaTime *= this.speed;
            let updatedTime = this.time + _deltaTime;
            if (this.animation.totalTime == 0)
                return;
            updatedTime = this.animation.getModalTime(updatedTime, this.playmode);
            let direction = this.animation.calculateDirection(updatedTime, this.playmode);
            this.events = this.animation.getEventsToFire(this.time, updatedTime, FudgeCore.ANIMATION_QUANTIZATION.CONTINOUS, direction);
            this.mutator = this.animation.getState(updatedTime % this.animation.totalTime, direction, FudgeCore.ANIMATION_QUANTIZATION.CONTINOUS);
            this.time = updatedTime;
            return;
        }
    }
    FudgeCore.AnimationNodeAnimation = AnimationNodeAnimation;
    /**
     * Blends multiple input {@link AnimationNode}s providing a blended {@link mutator} and the {@link events} from all nodes.
     * Each child node must specify its own blend {@link weight} and {@link blending}. Processes nodes sequentially, each node blends with the accumulated result.
     * When combined with {@link AnimationNodeTransition}s as children, transitions from/into an empty state will blend from/into the accumulated result of this node.
     * @author Jonas Plotzky, HFU, 2024-2025
     *
     * **Example walk-run-blend:**
     * ```typescript
     * import ∆í = FudgeCore;
     * // initialization
     * const walk: ∆í.Animation = new ∆í.Animation();
     * const run: ∆í.Animation = new ∆í.Animation();
     * const nodeWalk: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(walk);
     * const nodeRun: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(run, { speed: run.totalTime / walk.totalTime }) // slow down the playback speed of run to synchronize the motion with walk.
     * const nodeMove: ∆í.AnimationNodeBlend = new ∆í.AnimationNodeBlend([nodeWalk, nodeRun]);
     * const cmpAnimationGraph: ∆í.ComponentAnimationGraph = new ∆í.ComponentAnimationGraph(); // get the animation component
     * cmpAnimationGraph.root = nodeMove;
     *
     * // during the game
     * nodeRun.weight = 0.5; // adjust the weight: 0 is walking, 1 is running.
     * nodeMove.speed = 1 + nodeRun.weight * nodeRun.speed; // adjust the playback speed of the blend to account for the slowed down run animation.
     * ```
     * **Example transition-empty-state:**
     * ```typescript
     * import ∆í = FudgeCore;
     * // initialization
     * const idle: ∆í.Animation = new ∆í.Animation();
     * const walk: ∆í.Animation = new ∆í.Animation();
     * const draw: ∆í.Animation = new ∆í.Animation();
     * const sheathe: ∆í.Animation = new ∆í.Animation();
     *
     * const nodeEmpty: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation();
     * const nodeIdle: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(idle);
     * const nodeWalk: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(walk);
     * const nodeDraw: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(draw, { playmode: ∆í.ANIMATION_PLAYMODE.PLAY_ONCE });
     * const nodeSheathe: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(sheathe, { playmode: ∆í.ANIMATION_PLAYMODE.PLAY_ONCE });
     *
     * const nodeWholeBody: ∆í.AnimationNodeTransition = new ∆í.AnimationNodeTransition(nodeIdle);
     * const nodeUpperBody: ∆í.AnimationNodeTransition = new ∆í.AnimationNodeTransition(nodeEmpty);
     * const nodeRoot: ∆í.AnimationNodeBlend = new ∆í.AnimationNodeBlend([nodeWholeBody, nodeUpperBody]);
     * const cmpAnimationGraph: ∆í.ComponentAnimationGraph = new ∆í.ComponentAnimationGraph(); // get the animation component
     * cmpAnimationGraph.root = nodeRoot;
     *
     * // during the game
     * nodeWholeBody.transit(nodeWalk, 300); // transit whole body into walk.
     * // in parallel to the whole body, the upper body can transit from empty to draw/sheath and back to empty.
     * nodeUpperBody.transit(nodeDraw, 300); // transit upper body from empty into draw.
     * nodeUpperBody.transit(nodeSheathe, 300); // transit upper body from draw into sheathe.
     * nodeUpperBody.transit(nodeEmpty, 300); // transit upper body from sheathe into empty.
     * ```
     */
    class AnimationNodeBlend extends AnimationNode {
        constructor(_nodes, _options) {
            super(_options);
            this.nodes = _nodes;
        }
        reset() {
            for (const node of this.nodes)
                node.reset();
        }
        update(_deltaTime) {
            if (this.nodes.length == 0) {
                this.mutator = null;
                this.events = [];
                return;
            }
            _deltaTime *= this.speed;
            this.nodes[0].update(_deltaTime, {}); // TODO: add base pose snapshot to blend from
            let mutator = this.nodes[0].mutator ?? {};
            let events = this.nodes[0].events ?? [];
            for (let i = 1; i < this.nodes.length; i++) {
                const node = this.nodes[i];
                node.update(_deltaTime, mutator);
                if (!node.mutator)
                    continue;
                switch (node.blending) {
                    case ANIMATION_BLENDING.ADDITIVE:
                        mutator = FudgeCore.Animation.blendAdditive(mutator, node.mutator, node.weight);
                        break;
                    case ANIMATION_BLENDING.OVERRIDE:
                        mutator = FudgeCore.Animation.blendOverride(mutator, node.mutator, node.weight);
                        break;
                }
                events = events.concat(node.events);
            }
            this.mutator = mutator;
            this.events = events;
        }
    }
    FudgeCore.AnimationNodeBlend = AnimationNodeBlend;
    /**
     * Allows to transition from one {@link AnimationNode} to another over a specified time.
     * If nested inside an {@link AnimationNodeBlend}, transit from/into an empty state to blend from/into the accumulated result of the container blend node.
     * @author Jonas Plotzky, HFU, 2024-2025
     *
     * **Example:**
     * ```typescript
     * import ∆í = FudgeCore;
     * // initialization
     * const idle: ∆í.Animation = new ∆í.Animation();
     * const walk: ∆í.Animation = new ∆í.Animation();
     * const nodeIdle: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(idle);
     * const nodeWalk: ∆í.AnimationNodeAnimation = new ∆í.AnimationNodeAnimation(walk);
     * const nodeTransition: ∆í.AnimationNodeTransition = new ∆í.AnimationNodeTransition(nodeIdle);
     * const cmpAnimationGraph: ∆í.ComponentAnimationGraph = new ∆í.ComponentAnimationGraph(); // get the animation component
     * cmpAnimationGraph.root = nodeTransition;
     *
     * // during the game
     * nodeTransition.transit(nodeWalk, 300); // transit to the walk animation in 300ms.
     * nodeTransition.transit(nodeIdle, 300); // transit back to the idle animation.
     * ```
     */
    class AnimationNodeTransition extends AnimationNode {
        constructor(_animation, _options) {
            super(_options);
            this.from = _animation;
        }
        reset() {
            this.from.reset();
            this.to?.reset();
        }
        /** Transit to the given {@link AnimationNode} over the specified duration. The given node will be {@link reset}. */
        transit(_to, _duration) {
            _to.reset();
            if (this.to)
                this.from = new AnimationNodeAnimation(this.mutator);
            this.to = _to;
            this.duration = _duration;
            this.time = 0;
        }
        update(_deltaTime, _pose) {
            _deltaTime *= this.speed;
            this.time += _deltaTime;
            this.from.update(_deltaTime);
            if (!this.to) {
                this.mutator = this.from.mutator;
                this.events = this.from.events;
                return;
            }
            this.to.update(_deltaTime);
            let progress = Math.min(this.time / this.duration, 1);
            let from = this.from.mutator ?? _pose;
            let to = this.to.mutator ?? _pose;
            if (from == to) {
                this.mutator = null;
                return;
            }
            this.mutator = FudgeCore.Animation.blendOverride(from, to, progress, from == _pose || to == _pose);
            this.events = this.to.events;
            if (progress >= 1) {
                this.from = this.to;
                this.to = null;
                this.duration = null;
                this.time = null;
            }
        }
    }
    FudgeCore.AnimationNodeTransition = AnimationNodeTransition;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A sequence of {@link AnimationKey}s that is mapped to an attribute of a {@link Node} or its {@link Component}s inside the {@link Animation}.
     * Provides functions to modify said keys
     * @authors Lukas Scheuerle, HFU, 2019 | Jonas Plotzky, HFU, 2022-2025
     */
    class AnimationSequence extends FudgeCore.Mutable {
        #classType;
        constructor(_keys = [], _valueType) {
            super();
            this.keys = _keys;
            this.keys.sort(FudgeCore.AnimationKey.compare);
            this.classType = _valueType;
            this.regenerateFunctions();
        }
        get length() {
            return this.keys.length;
        }
        get classType() {
            return this.#classType;
        }
        set classType(_type) {
            this.#classType = _type;
        }
        /**
         * Evaluates the sequence at the given point in time.
         * @param _time the point in time at which to evaluate the sequence in milliseconds.
         * @returns the value of the sequence at the given time. undefined if there are no keys.
         */
        evaluate(_time, _frame, _out) {
            let iLeft = 0, iRight = this.keys.length - 1, iMid;
            while (iLeft <= iRight) {
                iMid = Math.floor((iLeft + iRight) / 2);
                if (this.keys[iMid].time < _time)
                    iLeft = iMid + 1;
                else
                    iRight = iMid - 1;
            }
            const key = this.keys[iRight] ?? this.keys[iLeft];
            return key?.functionOut.evaluate(_time, _out);
            // if (this.keys.length == 0)
            //   return undefined; //TODO: shouldn't return 0 but something indicating no change, like null. probably needs to be changed in Node as well to ignore non-numeric values in the applyAnimation function
            // if (this.keys.length == 1 || this.keys[0].time >= _time)
            //   return this.keys[0].value;
            // for (let i: number = 0; i < this.keys.length - 1; i++) {
            //   if (this.keys[i].time <= _time && _time < this.keys[i + 1].time) {
            //     return this.keys[i].functionOut.evaluate(_time);
            //   }
            //   // if (this.keys[i].time == _time)
            //   //   return this.keys[i].value;
            // }
            // return this.keys[this.keys.length - 1].value;
        }
        /**
         * Adds a new key to the sequence.
         * @param _key the key to add
         */
        addKey(_key) {
            this.keys.push(_key);
            this.keys.sort(FudgeCore.AnimationKey.compare);
            this.regenerateFunctions();
        }
        /**
         * Modifys a given key in the sequence.
         * @param _key the key to add
         */
        modifyKey(_key, _time, _value) {
            if (_time != null)
                _key.time = _time;
            if (_value != null)
                _key.value = _value;
            this.keys.sort(FudgeCore.AnimationKey.compare);
            this.regenerateFunctions();
        }
        /**
         * Removes a given key from the sequence.
         * @param _key the key to remove
         */
        removeKey(_key) {
            for (let i = 0; i < this.keys.length; i++) {
                if (this.keys[i] == _key) {
                    this.keys.splice(i, 1);
                    this.regenerateFunctions();
                    return;
                }
            }
        }
        /**
         * Find a key in the sequence exactly matching the given time.
         */
        findKey(_time) {
            for (let key of this.keys)
                if (key.time == _time)
                    return key;
            return null;
        }
        /**
         * Removes the Animation Key at the given index from the keys.
         * @param _index the zero-based index at which to remove the key
         * @returns the removed AnimationKey if successful, null otherwise.
         */
        removeKeyAtIndex(_index) {
            if (_index < 0 || _index >= this.keys.length) {
                return null;
            }
            let ak = this.keys[_index];
            this.keys.splice(_index, 1);
            this.regenerateFunctions();
            return ak;
        }
        /**
         * Gets a key from the sequence at the desired index.
         * @param _index the zero-based index at which to get the key
         * @returns the AnimationKey at the index if it exists, null otherwise.
         */
        getKey(_index) {
            if (_index < 0 || _index >= this.keys.length)
                return null;
            return this.keys[_index];
        }
        /**
         * Returns this sequence's keys. This is not a copy, but the actual array used internally. Handle with care!
         * Used by Editor.
         */
        getKeys() {
            return this.keys;
        }
        serialize() {
            let s = {
                keys: [],
                classType: this.classType.name,
                animationSequence: true
            };
            for (let i = 0; i < this.keys.length; i++) {
                s.keys[i] = this.keys[i].serialize();
            }
            return s;
        }
        async deserialize(_serialization) {
            if (_serialization.classType != null)
                this.classType = Reflect.get(FudgeCore, _serialization.classType);
            this.classType ??= Number;
            for (let i = 0; i < _serialization.keys.length; i++) {
                // this.keys.push(<AnimationKey>Serializer.deserialize(_serialization.keys[i]));
                let k = new FudgeCore.AnimationKey();
                await k.deserialize(_serialization.keys[i]);
                this.keys[i] = k;
            }
            this.regenerateFunctions();
            return this;
        }
        /**
         * Utility function that (re-)generates all functions in the sequence.
         */
        regenerateFunctions(_keys = this.keys) {
            if (_keys.length == 0)
                return;
            if (!this.classType)
                throw new Error(`${this.constructor.name}: No key type specified. Cannot generate animation functions.`);
            const functionType = Reflect.get(FudgeCore, FudgeCore.AnimationFunction.name + this.classType.name);
            for (let i = 0; i < _keys.length; i++) {
                const key = _keys[i];
                const keyNext = _keys[i + 1];
                key.functionOut = new functionType(key, keyNext);
            }
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.AnimationSequence = AnimationSequence;
    /**
     * A sequence of {@link AnimationKeyNumber}s sampled from an original sequence. In a sampled sequence, the keys are stored at indices corresponding to discrete frames in accordance with the {@link Animation}'s frames per second.
     * Keys from the original sequence may be referenced repeated times in a sampled sequence. Sampled sequences allow O(1) access to keys based on the desired frame.
     * @authors Jonas Plotzky, HFU, 2025
     */
    class AnimationSequenceSampled extends AnimationSequence {
        /** Evaluates the sequence at the given frame and time. */
        evaluate(_time, _frame, _out) {
            return this.keys[_frame]?.functionOut.evaluate(_time, _out);
        }
        regenerateFunctions(_keys = this.keys) {
            super.regenerateFunctions([...new Set(_keys)]); // remove duplicates, as sampled sequences may contain the same key repeated times
        }
    }
    FudgeCore.AnimationSequenceSampled = AnimationSequenceSampled;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let AnimationSprite = (() => {
        let _classDecorators = [FudgeCore.enumerate];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Animation;
        let _instanceExtraInitializers = [];
        let _get_texture_decorators;
        var AnimationSprite = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _get_texture_decorators = [FudgeCore.enumerate, FudgeCore.type(FudgeCore.Texture)];
                __esDecorate(this, null, _get_texture_decorators, { kind: "getter", name: "texture", static: false, private: false, access: { has: obj => "texture" in obj, get: obj => obj.texture }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                AnimationSprite = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Animation.registerSubclass(AnimationSprite); }
            #texture;
            // TODO: fps should be a parameter too
            constructor(_name = "AnimationSprite") {
                super(_name, {}, 1);
                this.frames = (__runInitializers(this, _instanceExtraInitializers), 25);
                this.wrapAfter = 5;
                this.start = new FudgeCore.Vector2(0, 0);
                this.size = new FudgeCore.Vector2(80, 80);
                this.next = new FudgeCore.Vector2(80, 0);
                this.wrap = new FudgeCore.Vector2(0, 80);
                this.#texture = FudgeCore.TextureDefault.color;
                this.framesPerSecond = this.frames;
                this.create(this.texture, this.frames, this.wrapAfter, this.start, this.size, this.next, this.wrap, this.framesPerSecond);
            }
            get texture() {
                return this.#texture;
            }
            /**
             * Sets the texture to be used as the spritesheet
             */
            set texture(_texture) {
                this.#texture = _texture;
                this.create(this.texture, this.frames, this.wrapAfter, this.start, this.size, this.next, this.wrap, this.framesPerSecond);
            }
            /**
             * Creates this animation sprite from the given arguments
             */
            create(_texture, _frames, _wrapAfter, _start, _size, _next, _wrap, _framesPerSecond) {
                this.#texture = _texture;
                this.frames = _frames;
                this.wrapAfter = _wrapAfter;
                this.start = _start;
                this.size = _size;
                this.next = _next;
                this.wrap = _wrap;
                this.framesPerSecond = _framesPerSecond;
                let scale = this.getScale();
                let positions = this.getPositions();
                // TODO: implement and use AnimationSequence<Vector2>?
                let xTranslationKeys = new Array(this.frames + 1);
                let yTranslationKeys = new Array(this.frames + 1);
                for (let frame = 0; frame <= this.frames; frame++) {
                    let time = 1000 * frame / this.framesPerSecond;
                    let position = positions[Math.min(frame, this.frames - 1)]; //repeat the last key to give the last frame some time
                    xTranslationKeys[frame] = new FudgeCore.AnimationKey(time, position.x / this.#texture.texImageSource.width, FudgeCore.ANIMATION_INTERPOLATION.CONSTANT);
                    yTranslationKeys[frame] = new FudgeCore.AnimationKey(time, position.y / this.#texture.texImageSource.height, FudgeCore.ANIMATION_INTERPOLATION.CONSTANT);
                }
                let xTranslation = new FudgeCore.AnimationSequence(xTranslationKeys, Number);
                let yTranslation = new FudgeCore.AnimationSequence(yTranslationKeys, Number);
                let xScale = new FudgeCore.AnimationSequence([new FudgeCore.AnimationKey(0, scale.x, FudgeCore.ANIMATION_INTERPOLATION.CONSTANT)], Number);
                let yScale = new FudgeCore.AnimationSequence([new FudgeCore.AnimationKey(0, scale.y, FudgeCore.ANIMATION_INTERPOLATION.CONSTANT)], Number);
                this.animationStructure = {
                    "components": {
                        "ComponentMaterial": [{
                                "mtxPivot": {
                                    "translation": {
                                        x: xTranslation,
                                        y: yTranslation
                                    },
                                    "scaling": {
                                        x: xScale,
                                        y: yScale
                                    }
                                }
                            }]
                    }
                };
                this.calculateTotalTime();
            }
            /**
             * Returns the scale of the spritesheet
             */
            getScale() {
                return new FudgeCore.Vector2(this.size.x / this.#texture.texImageSource.width, this.size.y / this.#texture.texImageSource.height);
            }
            /**
             * Returns the positions of the spritesheet
             */
            getPositions() {
                let iNext = 0;
                let iWrap = 0;
                let positions = [];
                for (let frame = 0; frame < this.frames; frame++) {
                    positions.push(new FudgeCore.Vector2(this.start.x + iNext * this.next.x + iWrap * this.wrap.x, this.start.y + iNext * this.next.y + iWrap * this.wrap.y));
                    iNext++;
                    if (iNext >= this.wrapAfter) {
                        iNext = 0;
                        iWrap++;
                    }
                }
                return positions;
            }
            //#region transfer
            async mutate(_mutator, _selection, _dispatchMutate) {
                super.mutate(_mutator, _selection, _dispatchMutate);
                this.create(this.texture, this.frames, this.wrapAfter, this.start, this.size, this.next, this.wrap, this.framesPerSecond);
            }
            serialize() {
                let serialization = {};
                serialization.idResource = this.idResource;
                serialization.idTexture = this.#texture.idResource;
                serialization.frames = this.frames;
                serialization.wrapAfter = this.wrapAfter;
                for (let name of ["start", "size", "next", "wrap"])
                    serialization[name] = Reflect.get(this, name).serialize();
                let animationsStructure = this.animationStructure;
                this.animationStructure = {}; // no need to serialize structure
                // let serialization: Serialization = super.serialize();
                serialization[super.constructor.name] = super.serialize();
                this.animationStructure = animationsStructure; // restore existent structure
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization[super.constructor.name]);
                if (_serialization.idTexture)
                    this.#texture = await FudgeCore.Project.getResource(_serialization.idTexture);
                for (let name of ["start", "size", "next", "wrap"])
                    Reflect.get(this, name).deserialize(_serialization[name]);
                this.create(this.texture, _serialization.frames, _serialization.wrapAfter, this.start, this.size, this.next, this.wrap, this.framesPerSecond);
                return this;
            }
            //#endregion
            /**
             * Converts the {@link AnimationSprite} into an {@link Animation}
             */
            convertToAnimation() {
                let animation = new FudgeCore.Animation(this.name, this.animationStructure, this.framesPerSecond);
                return animation;
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return AnimationSprite = _classThis;
    })();
    FudgeCore.AnimationSprite = AnimationSprite;
})(FudgeCore || (FudgeCore = {}));
// namespace FudgeCore {
//   export class AnimationTargetBinding {
//     public path: string;
//     public parsedPath: string[];
//     public node: Node;
//     public component: Component;
//     public constructor(_rootNode: Node, _path: string) {
//       this.path = _path;
//       this.parsedPath = AnimationTargetBinding.parsePath(_path);
//     }
//     public static parsePath(_path: string): string[] {
//       return _path.split("/");
//     }
//     /**
//      * @example "node/parent/children/1/components/ComponentSkeleton/0"
//      */
//     public static findTarget(_rootNode: Node, _path: string): Node {
//       throw new Error("Not implemented");
//     }
//     public bind(): void {
//       throw new Error("Not implemented");
//     }
//     public unbind(): void {
//       throw new Error("Not implemented");
//     }
//     public getValue(): unknown {
//       throw new Error("Not implemented");
//     }
//     public setValue(_value: unknown): void {
//       throw new Error("Not implemented");
//     }
//   }
// }
var FudgeCore;
(function (FudgeCore) {
    /**
     * Extension of AudioBuffer with a load method that creates a buffer in the {@link AudioManager}.default to be used with {@link ComponentAudio}
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    let Audio = (() => {
        var _a;
        let _classDecorators = [(_a = FudgeCore.SerializableResource).register.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Mutable;
        var Audio = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                Audio = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(_classThis, _classExtraInitializers);
            }
            constructor(_url) {
                super();
                this.name = "Audio";
                this.idResource = undefined;
                this.buffer = undefined;
                this.path = undefined;
                this.url = undefined;
                this.ready = false;
                if (_url) {
                    this.load(_url);
                    this.name = _url.toString().split("/").pop();
                }
                FudgeCore.Project.register(this);
            }
            get isReady() {
                return this.ready;
            }
            /**
             * Asynchronously loads the audio (mp3) from the given url
             */
            async load(_url) {
                FudgeCore.Debug.fudge("AudioLoad", _url);
                this.url = _url;
                this.ready = false;
                this.path = new URL(this.url.toString(), FudgeCore.Project.baseURL);
                const response = await window.fetch(this.path.toString());
                const arrayBuffer = await response.arrayBuffer();
                let buffer = await FudgeCore.AudioManager.default.decodeAudioData(arrayBuffer);
                this.buffer = buffer;
                this.ready = true;
                this.dispatchEvent(new Event("ready" /* EVENT_AUDIO.READY */));
            }
            //#region Transfer
            serialize() {
                return {
                    url: this.url,
                    idResource: this.idResource,
                    name: this.name,
                    type: this.type
                };
            }
            async deserialize(_serialization) {
                FudgeCore.Project.register(this, _serialization.idResource);
                await this.load(_serialization.url);
                this.name = _serialization.name;
                return this;
            }
            async mutate(_mutator, _selection, _dispatchMutate) {
                let url = _mutator.url; // save url for reconstruction after exclusion
                if (_mutator.url != this.url.toString())
                    this.load(_mutator.url);
                // except url from mutator for further processing
                delete (_mutator.url);
                super.mutate(_mutator, _selection, _dispatchMutate);
                // reconstruct, for mutator may be kept by caller
                Reflect.set(_mutator, "url", url);
            }
            reduceMutator(_mutator) {
                // delete _mutator.idResource; 
                delete _mutator.ready;
            }
        };
        return Audio = _classThis;
    })();
    FudgeCore.Audio = Audio;
})(FudgeCore || (FudgeCore = {}));
///<reference path="../Event/EventAudio.ts"/>
var FudgeCore;
///<reference path="../Event/EventAudio.ts"/>
(function (FudgeCore) {
    /**
     * Extends the standard AudioContext for integration with FUDGE-graphs.
     * Creates a default object at startup to be addressed as AudioManager default.
     * Other objects of this class may be create for special purposes.
     */
    class AudioManager extends AudioContext {
        /** The default context that may be used throughout the project without the need to create others */
        static { this.default = new AudioManager({ latencyHint: "interactive", sampleRate: 44100 }); }
        static { this.eventUpdate = new Event("updateAudioGraph" /* EVENT_AUDIO.UPDATE */); }
        constructor(_contextOptions) {
            super(_contextOptions);
            this.graph = null;
            this.cmpListener = null;
            /**
             * Determines FUDGE-graph to listen to. Each {@link ComponentAudio} in the graph will connect to this contexts master gain, all others disconnect.
             */
            this.listenTo = (_graph) => {
                if (this.graph)
                    this.graph.broadcastEvent(new Event("childRemoveFromAudioGraph" /* EVENT_AUDIO.CHILD_REMOVE */));
                if (!_graph)
                    return;
                this.graph = _graph;
                this.graph.broadcastEvent(new Event("childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */));
            };
            /**
             * Retrieve the FUDGE-graph currently listening to
             */
            this.getGraphListeningTo = () => {
                return this.graph;
            };
            /**
             * Set the {@link ComponentAudioListener} that serves the spatial location and orientation for this contexts listener
             */
            this.listenWith = (_cmpListener) => {
                this.cmpListener = _cmpListener;
            };
            /**
             * Updates the spatial settings of the AudioNodes effected in the current FUDGE-graph
             */
            this.update = () => {
                if (this.state != "running")
                    return;
                // this.graph.broadcastEvent(new Event(EVENT_AUDIO.UPDATE));
                this.graph.broadcastEvent(AudioManager.eventUpdate);
                if (this.cmpListener)
                    this.cmpListener.update(this.listener);
            };
            this.gain = this.createGain();
            this.gain.connect(this.destination);
        }
        /**
         * Set the master volume
         */
        set volume(_value) {
            this.gain.gain.value = _value;
        }
        /**
         * Get the master volume
         */
        get volume() {
            return this.gain.gain.value;
        }
    }
    FudgeCore.AudioManager = AudioManager;
})(FudgeCore || (FudgeCore = {}));
// namespace FudgeCore {
//     /**
//      * Enumerator for all possible Oscillator Types
//      */
//     type OSCILLATOR_TYPE = "sine" | "square" | "sawtooth" | "triangle" | "custom";
//     /**
//      * Interface to create Custom Oscillator Types.
//      * Start-/Endpoint of a custum curve e.g. sine curve.
//      * Both parameters need to be inbetween -1 and 1.
//      * @param startpoint startpoint of a curve 
//      * @param endpoint Endpoint of a curve 
//      */
//     interface OscillatorWave {
//         startpoint: number;
//         endpoint: number;
//     }
//     /**
//      * Add an {@link AudioFilter} to an {@link Audio]]
//      * @authors Thomas Dorner, HFU, 2019
//      */
//     export class AudioOscillator {
//         public audioOscillator: OscillatorNode; 
//         private frequency: number;
//         private oscillatorType: OSCILLATOR_TYPE;
//         private oscillatorWave: PeriodicWave;
//         private localGain: GainNode;
//         private localGainValue: number;
//         constructor(_audioSettings: AudioSettings, _oscillatorType?: OSCILLATOR_TYPE) {
//             this.audioOscillator = _audioSettings.getAudioContext().createOscillator();
//             this.localGain = _audioSettings.getAudioContext().createGain();
//             this.oscillatorType = _oscillatorType;
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//                 else {
//                     console.log("Create a Custom Periodic Wave first to use Custom Type");
//                 }
//             }
//         }
//         public setOscillatorType(_oscillatorType: OSCILLATOR_TYPE): void {
//             if (this.oscillatorType != "custom") {
//                 this.audioOscillator.type = this.oscillatorType;
//             }
//             else {
//                 if (!this.oscillatorWave) {
//                     this.audioOscillator.setPeriodicWave(this.oscillatorWave);
//                 }
//             }
//         }
//         public getOscillatorType(): OSCILLATOR_TYPE {
//             return this.oscillatorType;
//         }
//         public createPeriodicWave(_audioSettings: AudioSettings, _real: OscillatorWave, _imag: OscillatorWave): void {
//             let waveReal: Float32Array = new Float32Array(2);
//             waveReal[0] = _real.startpoint;
//             waveReal[1] = _real.endpoint;
//             let waveImag: Float32Array = new Float32Array(2);
//             waveImag[0] = _imag.startpoint;
//             waveImag[1] = _imag.endpoint;
//             this.oscillatorWave = _audioSettings.getAudioContext().createPeriodicWave(waveReal, waveImag);
//         }
//         public setLocalGain(_localGain: GainNode): void {
//             this.localGain = _localGain;
//         }
//         public getLocalGain(): GainNode {
//             return this.localGain;
//         }
//         public setLocalGainValue(_localGainValue: number): void {
//             this.localGainValue = _localGainValue;
//             this.localGain.gain.value = this.localGainValue;
//         }
//         public getLocalGainValue(): number {
//             return this.localGainValue;
//         }
//         public setFrequency(_audioSettings: AudioSettings, _frequency: number): void {
//             this.frequency = _frequency;
//             this.audioOscillator.frequency.setValueAtTime(this.frequency, _audioSettings.getAudioContext().currentTime);
//         }
//         public getFrequency(): number {
//             return this.frequency;
//         }
//         public createSnare(_audioSettings: AudioSettings): void {
//             this.setOscillatorType("triangle");
//             this.setFrequency(_audioSettings, 100);
//             this.setLocalGainValue(0);
//             this.localGain.gain.setValueAtTime(0, _audioSettings.getAudioContext().currentTime);
//             this.localGain.gain.exponentialRampToValueAtTime(0.01, _audioSettings.getAudioContext().currentTime + .1);
//             this.audioOscillator.connect(this.localGain);
//         }
//     }
// }
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attached to a {@link Node} with an attached {@link ComponentCamera} this causes the rendered image to receive an ambient occlusion effect.
     * @authors Roland Heer, HFU, 2023 | Jonas Plotzky, HFU, 2023
     */
    class ComponentAmbientOcclusion extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentAmbientOcclusion); }
        constructor(_sampleRadius = 16, _bias = 0.07, _attenuationConstant = 2.5, _attenuationLinear = 1, _attenuationQuadratic = 1) {
            super();
            this.sampleRadius = _sampleRadius;
            this.bias = _bias;
            this.attenuationConstant = _attenuationConstant;
            this.attenuationLinear = _attenuationLinear;
            this.attenuationQuadratic = _attenuationQuadratic;
        }
        //#region Transfer
        serialize() {
            let serialization = {
                sampleRadius: this.sampleRadius,
                bias: this.bias,
                attenuationConstant: this.attenuationConstant,
                attenuationLinear: this.attenuationLinear,
                attenuationQuadratic: this.attenuationQuadratic
            };
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.sampleRadius = _serialization.sampleRadius;
            this.bias = _serialization.bias;
            this.attenuationConstant = _serialization.attenuationConstant;
            this.attenuationLinear = _serialization.attenuationLinear;
            this.attenuationQuadratic = _serialization.attenuationQuadratic;
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
    }
    FudgeCore.ComponentAmbientOcclusion = ComponentAmbientOcclusion;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
var FudgeCore;
// / <reference path="../Time/Loop.ts"/>
// / <reference path="../Animation/Animation.ts"/>
(function (FudgeCore) {
    /**
     * Holds a reference to an {@link Animation} and controls it. Controls quantization and playmode as well as speed.
     * @authors Lukas Scheuerle, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2021 | Jonas Plotzky, HFU, 2022-2025
     */
    let ComponentAnimation = (() => {
        let _classDecorators = [FudgeCore.enumerate];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Component;
        let _instanceExtraInitializers = [];
        let _get_animation_decorators;
        var ComponentAnimation = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _get_animation_decorators = [FudgeCore.enumerate, FudgeCore.type(FudgeCore.Animation)];
                __esDecorate(this, null, _get_animation_decorators, { kind: "getter", name: "animation", static: false, private: false, access: { has: obj => "animation" in obj, get: obj => obj.animation }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                ComponentAnimation = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentAnimation); }
            #animation;
            #mutator;
            #scale;
            #timeLocal;
            #previous;
            constructor(_animation, _playmode = FudgeCore.ANIMATION_PLAYMODE.LOOP, _quantization = FudgeCore.ANIMATION_QUANTIZATION.CONTINOUS) {
                super();
                this.playmode = __runInitializers(this, _instanceExtraInitializers);
                this.scaleWithGameTime = true;
                this.animateInEditor = false;
                this.#scale = 1;
                this.#previous = 0;
                //#region updateAnimation
                /**
                 * Updates the Animation.
                 * Uses the built-in time unless a different time is specified.
                 * May also be called from updateAnimation().
                 */
                this.updateAnimationLoop = (_e, _time) => {
                    if (this.animation.totalTime == 0)
                        return null;
                    let time = _time || _time === 0 ? _time : this.#timeLocal.get();
                    if (this.quantization == FudgeCore.ANIMATION_QUANTIZATION.FRAMES) {
                        time = this.#previous + (1000 / this.animation.fps);
                    }
                    let direction = this.animation.calculateDirection(time, this.playmode);
                    time = this.animation.getModalTime(time, this.playmode, this.#timeLocal.getOffset());
                    this.executeEvents(this.animation.getEventsToFire(this.#previous, time, this.quantization, direction));
                    if (this.#previous != time) {
                        this.#previous = time;
                        time = time % this.animation.totalTime;
                        this.#mutator = this.animation.getState(time, direction, this.quantization, this.#mutator);
                        if (this.node)
                            this.node.applyAnimation(this.#mutator);
                        return this.#mutator;
                    }
                    return null;
                };
                /**
                 * Updates the scale of the animation if the user changes it or if the global game timer changed its scale.
                 */
                this.updateScale = () => {
                    let newScale = this.#scale;
                    if (this.scaleWithGameTime)
                        newScale *= FudgeCore.Time.game.getScale();
                    this.#timeLocal.setScale(newScale);
                };
                this.playmode = _playmode;
                this.quantization = _quantization;
                this.#animation = _animation;
                this.#timeLocal = new FudgeCore.Time();
                //TODO: update animation total time when loading a different animation?
                this.#animation?.calculateTotalTime();
                this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, () => this.activate(false));
                this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, () => {
                    this.node.addEventListener("childRemove" /* EVENT.CHILD_REMOVE */, () => this.activate(false));
                    this.activate(true);
                });
            }
            get animation() {
                return this.#animation;
            }
            set animation(_animation) {
                this.#animation = _animation;
                this.#mutator = undefined;
            }
            set scale(_scale) {
                this.#scale = _scale;
                this.updateScale();
            }
            get scale() {
                return this.#scale;
            }
            /**
             * - get: return the current sample time of the animation
             * - set: jump to a certain sample time in the animation
             */
            get time() {
                return this.#timeLocal.get() % this.animation.totalTime;
            }
            set time(_time) {
                this.jumpTo(_time);
            }
            activate(_on) {
                super.activate(_on);
                if (!this.node)
                    return;
                this.activateListeners(_on);
            }
            /**
             * Jumps to a certain time in the animation to play from there.
             */
            jumpTo(_time) {
                this.#timeLocal.set(_time);
                this.#previous = _time;
                _time = _time % this.animation.totalTime;
                let mutator = this.animation.getState(_time, this.animation.calculateDirection(_time, this.playmode), this.quantization);
                this.node.applyAnimation(mutator);
            }
            /**
             * Jumps to a certain label in the animation if defined
             */
            jumpToLabel(_label) {
                let time = this.animation.labels[_label];
                if (time)
                    this.jumpTo(time);
            }
            /**
             * Forces an update of the animation from outside. Used in the ViewAnimation. Shouldn't be used during the game.
             * @param _time the (unscaled) time to update the animation with.
             * @returns the Mutator for Animation.
             */
            updateAnimation(_time) {
                this.#previous = undefined;
                return this.updateAnimationLoop(null, _time);
            }
            //#region transfer
            serialize() {
                let serialization = {};
                serialization[super.constructor.name] = super.serialize();
                serialization.idAnimation = this.animation.idResource;
                serialization.playmode = this.playmode;
                serialization.quantization = this.quantization;
                serialization.scale = this.scale;
                serialization.scaleWithGameTime = this.scaleWithGameTime;
                serialization.animateInEditor = this.animateInEditor;
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization[super.constructor.name]);
                this.animation = await FudgeCore.Project.getResource(_serialization.idAnimation);
                this.playmode = _serialization.playmode;
                this.quantization = _serialization.quantization;
                this.scale = _serialization.scale;
                this.scaleWithGameTime = _serialization.scaleWithGameTime;
                this.animateInEditor = _serialization.animateInEditor;
                return this;
            }
            async mutate(_mutator, _selection = null, _dispatchMutate = true) {
                await super.mutate(_mutator, _selection, _dispatchMutate);
                if (typeof (_mutator.animateInEditor) !== "undefined") {
                    this.updateAnimation(0);
                    this.activateListeners(this.active);
                }
            }
            getMutatorAttributeTypes(_mutator) {
                let types = super.getMutatorAttributeTypes(_mutator);
                if (types.playmode)
                    types.playmode = FudgeCore.ANIMATION_PLAYMODE;
                if (types.quantization)
                    types.quantization = FudgeCore.ANIMATION_QUANTIZATION;
                return types;
            }
            //#endregion
            activateListeners(_on) {
                if (_on && (FudgeCore.Project.mode != FudgeCore.MODE.EDITOR || FudgeCore.Project.mode == FudgeCore.MODE.EDITOR && this.animateInEditor)) {
                    FudgeCore.Time.game.addEventListener("timeScaled" /* EVENT.TIME_SCALED */, this.updateScale);
                    this.node.addEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.updateAnimationLoop);
                }
                else {
                    FudgeCore.Time.game.removeEventListener("timeScaled" /* EVENT.TIME_SCALED */, this.updateScale);
                    this.node.removeEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.updateAnimationLoop);
                }
            }
            /**
             * Fires all custom events the Animation should have fired between the last frame and the current frame.
             * @param _events a list of names of custom events to fire
             */
            executeEvents(_events) {
                for (let i = 0; i < _events.length; i++) {
                    this.dispatchEvent(new Event(_events[i]));
                }
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return ComponentAnimation = _classThis;
    })();
    FudgeCore.ComponentAnimation = ComponentAnimation;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches an {@link AnimationNode animation graph} to a {@link Node} and animates it.
     * @author Jonas Plotzky, HFU, 2024-2025
     */
    class ComponentAnimationGraph extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentAnimationGraph); }
        constructor(_root) {
            super();
            this.update = () => {
                FudgeCore.PerformanceMonitor.startMeasure("ComponentAnimationGraph.update");
                if (!this.root || !this.node || !this.active)
                    return;
                FudgeCore.PerformanceMonitor.startMeasure("ComponentAnimationGraph.update compute");
                this.root.update(FudgeCore.Loop.timeFrameGame);
                this.root.events?.forEach(_event => this.dispatchEvent(new Event(_event)));
                FudgeCore.PerformanceMonitor.endMeasure("ComponentAnimationGraph.update compute");
                FudgeCore.PerformanceMonitor.startMeasure("ComponentAnimationGraph.update apply");
                this.node.applyAnimation(this.root.mutator);
                FudgeCore.PerformanceMonitor.endMeasure("ComponentAnimationGraph.update apply");
                FudgeCore.PerformanceMonitor.endMeasure("ComponentAnimationGraph.update");
            };
            this.root = _root;
            if (FudgeCore.Project.mode == FudgeCore.MODE.EDITOR)
                return;
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, () => this.node.addEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.update));
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, () => this.node.removeEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.update));
        }
    }
    FudgeCore.ComponentAnimationGraph = ComponentAnimationGraph;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let AUDIO_PANNER;
    (function (AUDIO_PANNER) {
        AUDIO_PANNER["CONE_INNER_ANGLE"] = "coneInnerAngle";
        AUDIO_PANNER["CONE_OUTER_ANGLE"] = "coneOuterAngle";
        AUDIO_PANNER["CONE_OUTER_GAIN"] = "coneOuterGain";
        AUDIO_PANNER["DISTANCE_MODEL"] = "distanceModel";
        AUDIO_PANNER["MAX_DISTANCE"] = "maxDistance";
        AUDIO_PANNER["PANNING_MODEL"] = "panningModel";
        AUDIO_PANNER["REF_DISTANCE"] = "refDistance";
        AUDIO_PANNER["ROLLOFF_FACTOR"] = "rolloffFactor";
    })(AUDIO_PANNER = FudgeCore.AUDIO_PANNER || (FudgeCore.AUDIO_PANNER = {}));
    let AUDIO_NODE_TYPE;
    (function (AUDIO_NODE_TYPE) {
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["SOURCE"] = 0] = "SOURCE";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["PANNER"] = 1] = "PANNER";
        AUDIO_NODE_TYPE[AUDIO_NODE_TYPE["GAIN"] = 2] = "GAIN";
    })(AUDIO_NODE_TYPE = FudgeCore.AUDIO_NODE_TYPE || (FudgeCore.AUDIO_NODE_TYPE = {}));
    /**
     * Builds a minimal audio graph (by default in {@link AudioManager}.default) and synchronizes it with the containing {@link Node}
     * ```text
     * ‚îå AudioManager(.default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     * ‚îÇ ‚îå ComponentAudio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
     * ‚îÇ ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
     * ‚îÇ ‚îÇ    ‚îÇsource‚îÇ ‚Üí ‚îÇpanner‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚îÇ
     * ‚îÇ ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
     * ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
     * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     * @authors Thomas Dorner, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ComponentAudio = (() => {
        let _classSuper = FudgeCore.Component;
        let _audio_decorators;
        let _audio_initializers = [];
        let _audio_extraInitializers = [];
        return class ComponentAudio extends _classSuper {
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _audio_decorators = [FudgeCore.type(FudgeCore.Audio)];
                __esDecorate(null, null, _audio_decorators, { kind: "field", name: "audio", static: false, private: false, access: { has: obj => "audio" in obj, get: obj => obj.audio, set: (obj, value) => { obj.audio = value; } }, metadata: _metadata }, _audio_initializers, _audio_extraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudio); }
            constructor(_audio = null, _loop = false, _start = false, _audioManager = FudgeCore.AudioManager.default) {
                super();
                /** places and directs the panner relative to the world transform of the {@link Node}  */
                this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
                this.singleton = false;
                this.audio = __runInitializers(this, _audio_initializers, void 0);
                this.gain = __runInitializers(this, _audio_extraInitializers);
                this.playing = false;
                this.listened = false;
                //#endregion
                this.hndAudioReady = (_event) => {
                    FudgeCore.Debug.fudge("Audio start", Reflect.get(_event.target, "url"));
                    if (this.playing)
                        this.play(true);
                };
                this.hndAudioEnded = (_event) => {
                    // Debug.fudge("Audio ended", Reflect.get(_event.target, "url"));
                    this.playing = false;
                };
                /**
                 * Automatically connects/disconnects AudioNodes when adding/removing this component to/from a node.
                 * Therefore unused AudioNodes may be garbage collected when an unused component is collected
                 */
                this.handleAttach = (_event) => {
                    // Debug.log(_event);
                    if (_event.type == "componentAdd" /* EVENT.COMPONENT_ADD */) {
                        this.node.addEventListener("childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */, this.handleGraph, true);
                        this.node.addEventListener("childRemoveFromAudioGraph" /* EVENT_AUDIO.CHILD_REMOVE */, this.handleGraph, true);
                        this.node.addEventListener("updateAudioGraph" /* EVENT_AUDIO.UPDATE */, this.update, true);
                        this.listened = this.node.isDescendantOf(FudgeCore.AudioManager.default.getGraphListeningTo());
                    }
                    else {
                        this.node.removeEventListener("childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */, this.handleGraph, true);
                        this.node.removeEventListener("childRemoveFromAudioGraph" /* EVENT_AUDIO.CHILD_REMOVE */, this.handleGraph, true);
                        this.node.removeEventListener("updateAudioGraph" /* EVENT_AUDIO.UPDATE */, this.update, true);
                        this.listened = false;
                    }
                    this.updateConnection();
                };
                /**
                 * Automatically connects/disconnects AudioNodes when appending/removing the FUDGE-graph the component is in.
                 */
                this.handleGraph = (_event) => {
                    // Debug.log(_event);
                    this.listened = (_event.type == "childAppendToAudioGraph" /* EVENT_AUDIO.CHILD_APPEND */);
                    this.updateConnection();
                };
                /**
                 * Updates the panner node, its position and direction, using the worldmatrix of the container and the pivot of this component.
                 */
                this.update = (_event) => {
                    let mtxResult = this.mtxPivot;
                    if (this.node)
                        mtxResult = FudgeCore.Matrix4x4.PRODUCT(this.node.mtxWorld, this.mtxPivot);
                    // Debug.log(mtxResult.toString());
                    let position = mtxResult.translation;
                    let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
                    this.panner.positionX.value = position.x;
                    this.panner.positionY.value = position.y;
                    this.panner.positionZ.value = position.z;
                    this.panner.orientationX.value = forward.x;
                    this.panner.orientationY.value = forward.y;
                    this.panner.orientationZ.value = forward.z;
                    FudgeCore.Recycler.store(forward);
                    // TODO: examine why the following produces erroneous results, see test "Spatial Audio"
                    if (this.node)
                        FudgeCore.Recycler.store(mtxResult);
                };
                this.install(_audioManager);
                this.createSource(_audio, _loop);
                this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.handleAttach);
                this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.handleAttach);
                if (_start)
                    this.play(_start);
            }
            set volume(_value) {
                this.gain.gain.value = _value;
            }
            get volume() {
                return this.gain.gain.value;
            }
            set loop(_on) {
                this.source.loop = _on;
            }
            get loop() {
                return this.source.loop;
            }
            set playbackRate(_value) {
                this.source.playbackRate.value = _value;
            }
            get playbackRate() {
                return this.source.playbackRate.value;
            }
            get isPlaying() {
                return this.playing;
            }
            get isAttached() {
                return this.node != null;
            }
            get isListened() {
                return this.listened;
            }
            /**
             * Sets the given {@link Audio} as the audio source
             */
            setAudio(_audio) {
                this.createSource(_audio, this.source.loop);
            }
            /**
             * Returns the {@link Audio} currently used as audio source
             */
            getAudio() {
                return this.audio;
            }
            /**
             * Set the property of the panner to the given value. Use to manipulate range and rolloff etc.
             */
            setPanner(_property, _value) {
                Reflect.set(this.panner, _property, _value);
            }
            // TODO: may be used for serialization of AudioNodes
            /**
             * Returns the mutator for the specified AudioNode of the standard graph
             */
            getMutatorOfNode(_type) {
                let node = this.getAudioNode(_type);
                let mutator = FudgeCore.getMutatorOfArbitrary(node);
                return mutator;
            }
            /**
             * Returns the specified AudioNode of the standard graph for further manipulation
             */
            getAudioNode(_type) {
                switch (_type) {
                    case AUDIO_NODE_TYPE.SOURCE: return this.source;
                    case AUDIO_NODE_TYPE.PANNER: return this.panner;
                    case AUDIO_NODE_TYPE.GAIN: return this.gain;
                }
            }
            /**
             * Start or stop playing the audio
             */
            play(_on) {
                if (_on) {
                    if (this.audio.isReady) {
                        this.createSource(this.audio, this.source.loop, this.playbackRate);
                        this.source.start(0, 0);
                    }
                    else {
                        this.audio.addEventListener("ready" /* EVENT_AUDIO.READY */, this.hndAudioReady);
                    }
                    this.source.addEventListener("ended" /* EVENT_AUDIO.ENDED */, this.hndAudioEnded);
                }
                else
                    try {
                        this.source.stop();
                    }
                    catch (_error) { /* catch exception when source hasn't been started... */ }
                this.playing = _on;
            }
            /**
             * Inserts AudioNodes between the panner and the local gain of this {@link ComponentAudio}
             * _input and _output may be the same AudioNode, if there is only one to insert,
             * or may have multiple AudioNode between them to create an effect-graph.\
             * Note that {@link ComponentAudio} does not keep track of inserted AudioNodes!
             * ```text
             * ‚îå AudioManager(.default) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
             * ‚îÇ ‚îå ComponentAudio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
             * ‚îÇ ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
             * ‚îÇ ‚îÇ    ‚îÇsource‚îÇ ‚Üí ‚îÇpanner‚îÇ ‚Üí ‚îÇ_input‚îÇ ‚Üí ...  ‚Üí ‚îÇ_output‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚Üí ‚îÇ gain ‚îÇ ‚îÇ
             * ‚îÇ ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
             * ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
             * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             * ```
             */
            insertAudioNodes(_input, _output) {
                this.panner.disconnect(0);
                if (!_input && !_output) {
                    this.panner.connect(this.gain);
                    return;
                }
                this.panner.connect(_input);
                _output.connect(this.gain);
            }
            /**
             * Activate override. Connects or disconnects AudioNodes
             */
            activate(_on) {
                super.activate(_on);
                this.updateConnection();
            }
            /**
             * Connects this components gain-node to the gain node of the AudioManager this component runs on.
             * Only call this method if the component is not attached to a {@link Node} but needs to be heard.
             */
            connect(_on) {
                if (_on)
                    this.gain.connect(this.audioManager.gain);
                else
                    this.gain.disconnect(this.audioManager.gain);
            }
            drawGizmos() {
                let mtxShape = FudgeCore.Matrix4x4.PRODUCT(this.node.mtxWorld, this.mtxPivot);
                mtxShape.scaling = new FudgeCore.Vector3(0.5, 0.5, 0.5);
                let color = FudgeCore.Color.CSS("cornflowerblue");
                FudgeCore.Gizmos.drawIcon(FudgeCore.TextureDefault.iconAudio, mtxShape, color);
                FudgeCore.Recycler.store(mtxShape);
                FudgeCore.Recycler.store(color);
            }
            ;
            //#region Transfer
            serialize() {
                let serialization = super.serialize();
                serialization.idResource = this.audio?.idResource;
                serialization.playing = this.playing;
                serialization.loop = this.loop;
                serialization.volume = this.volume;
                // console.log(this.getMutatorOfNode(AUDIO_NODE_TYPE.PANNER));
                // TODO: serialize panner parameters
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization);
                let audio = await FudgeCore.Project.getResource(_serialization.idResource);
                this.createSource(audio, _serialization.loop);
                this.volume = _serialization.volume;
                this.play(_serialization.playing);
                return this;
            }
            getMutator() {
                let mutator = super.getMutator(true);
                let audio = mutator.audio;
                delete mutator.audio; // just to rearrange in interfaces...
                mutator.loop = this.loop;
                mutator.volume = this.volume;
                mutator.audio = audio; //... so audio comes last
                return mutator;
            }
            // public async mutate(_mutator: Mutator): Promise<void> {
            //   await super.mutate(_mutator);
            //   // this.volume = _mutator.volume;
            //   // this.loop = _mutator.loop;
            // }
            reduceMutator(_mutator) {
                super.reduceMutator(_mutator);
                delete _mutator.listened;
            }
            install(_audioManager = FudgeCore.AudioManager.default) {
                let active = this.isActive;
                this.activate(false);
                this.audioManager = _audioManager;
                this.panner = _audioManager.createPanner();
                this.gain = _audioManager.createGain();
                this.panner.connect(this.gain);
                this.gain.connect(_audioManager.gain);
                this.activate(active);
            }
            createSource(_audio, _loop, _playbackRate = 1.0) {
                if (this.source) {
                    this.source.disconnect();
                    this.source.buffer = null;
                }
                this.source = this.audioManager.createBufferSource();
                this.source.connect(this.panner);
                if (_audio) {
                    this.audio = _audio;
                    this.source.buffer = _audio.buffer;
                }
                this.source.loop = _loop;
                this.playbackRate = _playbackRate;
            }
            updateConnection() {
                try {
                    this.connect(this.isActive && this.isAttached && this.listened);
                }
                catch (_error) {
                    // nop
                }
            }
        };
    })();
    FudgeCore.ComponentAudio = ComponentAudio;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Serves to set the spatial location and orientation of AudioListeners relative to the
     * world transform of the {@link Node} it is attached to.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentAudioListener extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
        }
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentAudioListener); }
        /**
         * Updates the position and orientation of the given AudioListener
         */
        update(_listener) {
            let mtxResult = this.mtxPivot;
            if (this.node)
                mtxResult = FudgeCore.Matrix4x4.PRODUCT(this.node.mtxWorld, this.mtxPivot);
            // Debug.log(mtxResult.toString());
            let position = mtxResult.translation;
            let forward = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Z(1), mtxResult, false);
            let up = FudgeCore.Vector3.TRANSFORMATION(FudgeCore.Vector3.Y(), mtxResult, false);
            if (_listener.positionX != undefined) {
                _listener.positionX.value = position.x;
                _listener.positionY.value = position.y;
                _listener.positionZ.value = position.z;
                _listener.forwardX.value = forward.x;
                _listener.forwardY.value = forward.y;
                _listener.forwardZ.value = forward.z;
                _listener.upX.value = up.x;
                _listener.upY.value = up.y;
                _listener.upZ.value = up.z;
            }
            else {
                // Firefox still uses deprecated methods. TODO: delete as soon as possible!
                _listener.setPosition(position.x, position.y, position.z);
                _listener.setOrientation(forward.x, forward.y, forward.z, up.x, up.y, up.z);
            }
            FudgeCore.Recycler.store(forward);
            FudgeCore.Recycler.store(up);
            if (this.node)
                FudgeCore.Recycler.store(mtxResult);
            // Debug.log(mtxResult.translation.toString(), forward.toString(), up.toString());
        }
    }
    FudgeCore.ComponentAudioListener = ComponentAudioListener;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attached to a {@link Node} with an attached {@link ComponentCamera} this causes the rendered image to receive a bloom-effect.
     * @authors Roland Heer, HFU, 2023
     */
    class ComponentBloom extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentBloom); }
        #threshold;
        #intensity;
        #highlightDesaturation;
        constructor(_threshold = 0.95, _intensity = 1.0, _desaturateHighlights = 0.5) {
            super();
            this.#threshold = _threshold;
            this.#intensity = _intensity;
            this.#highlightDesaturation = _desaturateHighlights;
        }
        get threshold() {
            return this.#threshold;
        }
        set threshold(_value) {
            this.#threshold = FudgeCore.Calc.clamp(_value, 0, 1);
        }
        get intensity() {
            return this.#intensity;
        }
        set intensity(_value) {
            this.#intensity = Math.max(0, _value);
        }
        get highlightDesaturation() {
            return this.#highlightDesaturation;
        }
        set highlightDesaturation(_value) {
            this.#highlightDesaturation = FudgeCore.Calc.clamp(_value, 0, 1);
        }
        //#region Transfer
        serialize() {
            let serialization = {
                threshold: this.#threshold,
                intensity: this.#intensity,
                desaturateHighlights: this.#highlightDesaturation,
            };
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.#threshold = _serialization.threshold;
            this.#intensity = _serialization.intensity;
            this.#highlightDesaturation = _serialization.desaturateHighlights;
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.threshold = this.threshold;
            mutator.intensity = this.intensity;
            mutator.highlightDesaturation = this.highlightDesaturation;
            return mutator;
        }
    }
    FudgeCore.ComponentBloom = ComponentBloom;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="Component.ts"/>
var FudgeCore;
// / <reference path="Component.ts"/>
(function (FudgeCore) {
    let FIELD_OF_VIEW;
    (function (FIELD_OF_VIEW) {
        FIELD_OF_VIEW["HORIZONTAL"] = "horizontal";
        FIELD_OF_VIEW["VERTICAL"] = "vertical";
        FIELD_OF_VIEW["DIAGONAL"] = "diagonal";
    })(FIELD_OF_VIEW = FudgeCore.FIELD_OF_VIEW || (FudgeCore.FIELD_OF_VIEW = {}));
    /**
     * Defines identifiers for the various projections a camera can provide.
     * TODO: change back to number enum if strings not needed
     */
    let PROJECTION;
    (function (PROJECTION) {
        PROJECTION["CENTRAL"] = "central";
        PROJECTION["ORTHOGRAPHIC"] = "orthographic";
        PROJECTION["DIMETRIC"] = "dimetric";
        PROJECTION["STEREO"] = "stereo";
    })(PROJECTION = FudgeCore.PROJECTION || (FudgeCore.PROJECTION = {}));
    /**
     * The camera component holds the projection-matrix and other data needed to render a scene from the perspective of the node it is attached to.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019 | Jonas Plotzky, HFU, 2025
     */
    let ComponentCamera = (() => {
        let _classDecorators = [FudgeCore.enumerate];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Component;
        let _instanceExtraInitializers = [];
        let _get_backgroundEnabled_decorators;
        let _get_projection_decorators;
        let _get_aspectRatio_decorators;
        let _get_fieldOfView_decorators;
        let _get_direction_decorators;
        let _get_near_decorators;
        let _get_far_decorators;
        var ComponentCamera = class extends _classSuper {
            static { _classThis = this; }
            constructor() {
                super(...arguments);
                this.mtxPivot = (__runInitializers(this, _instanceExtraInitializers), FudgeCore.Matrix4x4.IDENTITY());
                this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
                this.clrBackground = new FudgeCore.Color(0, 0, 0, 1); // The color of the background the camera will render.
                //private orthographic: boolean = false; // Determines whether the image will be rendered with perspective or orthographic projection.
                this.#projection = PROJECTION.CENTRAL;
                this.#fieldOfView = 45; // The camera's sensorangle.
                this.#aspectRatio = 1.0;
                this.#direction = FIELD_OF_VIEW.DIAGONAL;
                this.#near = 1;
                this.#far = 2000;
                this.#backgroundEnabled = true; // Determines whether or not the background of this camera will be rendered. // TODO: seems to be unused, remove?
                // TODO: examine, if background should be an attribute of Camera or Viewport
                this.#mtxWorldToView = FudgeCore.Matrix4x4.IDENTITY();
                this.#mtxCameraInverse = FudgeCore.Matrix4x4.IDENTITY();
                this.#mtxProjection = FudgeCore.Matrix4x4.IDENTITY();
                //#endregion
            }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _get_backgroundEnabled_decorators = [FudgeCore.enumerate];
                _get_projection_decorators = [FudgeCore.enumerate, FudgeCore.type(PROJECTION)];
                _get_aspectRatio_decorators = [FudgeCore.enumerate];
                _get_fieldOfView_decorators = [FudgeCore.enumerate];
                _get_direction_decorators = [FudgeCore.enumerate, FudgeCore.type(FIELD_OF_VIEW)];
                _get_near_decorators = [FudgeCore.enumerate];
                _get_far_decorators = [FudgeCore.enumerate];
                __esDecorate(this, null, _get_backgroundEnabled_decorators, { kind: "getter", name: "backgroundEnabled", static: false, private: false, access: { has: obj => "backgroundEnabled" in obj, get: obj => obj.backgroundEnabled }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(this, null, _get_projection_decorators, { kind: "getter", name: "projection", static: false, private: false, access: { has: obj => "projection" in obj, get: obj => obj.projection }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(this, null, _get_aspectRatio_decorators, { kind: "getter", name: "aspectRatio", static: false, private: false, access: { has: obj => "aspectRatio" in obj, get: obj => obj.aspectRatio }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(this, null, _get_fieldOfView_decorators, { kind: "getter", name: "fieldOfView", static: false, private: false, access: { has: obj => "fieldOfView" in obj, get: obj => obj.fieldOfView }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(this, null, _get_direction_decorators, { kind: "getter", name: "direction", static: false, private: false, access: { has: obj => "direction" in obj, get: obj => obj.direction }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(this, null, _get_near_decorators, { kind: "getter", name: "near", static: false, private: false, access: { has: obj => "near" in obj, get: obj => obj.near }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(this, null, _get_far_decorators, { kind: "getter", name: "far", static: false, private: false, access: { has: obj => "far" in obj, get: obj => obj.far }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                ComponentCamera = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentCamera); }
            //private orthographic: boolean = false; // Determines whether the image will be rendered with perspective or orthographic projection.
            #projection;
            #fieldOfView; // The camera's sensorangle.
            #aspectRatio;
            #direction;
            #near;
            #far;
            #backgroundEnabled; // Determines whether or not the background of this camera will be rendered. // TODO: seems to be unused, remove?
            // TODO: examine, if background should be an attribute of Camera or Viewport
            #mtxWorldToView;
            #mtxCameraInverse;
            #mtxProjection;
            /**
             * Returns {@link mtxProjection} * {@link mtxCameraInverse}
             * yielding the worldspace to viewspace matrix
             */
            get mtxWorldToView() {
                if (this.#mtxProjection.modified || this.mtxCameraInverse.modified) {
                    FudgeCore.Matrix4x4.PRODUCT(this.#mtxProjection, this.mtxCameraInverse, this.#mtxWorldToView);
                    this.#mtxProjection.modified = false;
                    this.mtxCameraInverse.modified = false;
                }
                return this.#mtxWorldToView;
            }
            /**
             * Returns the inversion of this cameras worldtransformation
             */
            get mtxCameraInverse() {
                if (this.mtxWorld.modified) {
                    FudgeCore.Matrix4x4.INVERSE(this.mtxWorld, this.#mtxCameraInverse);
                    this.mtxWorld.modified = false;
                }
                return this.#mtxCameraInverse;
            }
            /**
             * Returns the projectionmatrix of this camera.
             */
            get mtxProjection() {
                return this.#mtxProjection;
            }
            /**
             * Returns true if the background of the camera should be rendered, false if not.
             */
            get backgroundEnabled() {
                return this.#backgroundEnabled;
            }
            /**
             * Returns the cameras {@link PROJECTION} mode.
             */
            get projection() {
                return this.#projection;
            }
            /**
             * Returns the cameras aspect ratio.
             */
            get aspectRatio() {
                return this.#aspectRatio;
            }
            /**
             * Returns the cameras field of view in degrees.
             */
            get fieldOfView() {
                return this.#fieldOfView;
            }
            /**
             * Returns the cameras direction i.e. the plane on which the fieldOfView-Angle is given.
             */
            get direction() {
                return this.#direction;
            }
            /**
             * Returns the cameras near value i.e. the minimum distance to render objects at.
             */
            get near() {
                return this.#near;
            }
            /**
             * Returns the cameras far value i.e. the maximum distance to render objects at.
             */
            get far() {
                return this.#far;
            }
            /**
             * Returns the cameras {@link PROJECTION} mode.
             * @deprecated Use {@link projection} instead.
             */
            getProjection() {
                return this.#projection;
            }
            /**
             * Returns true if the background of the camera should be rendered, false if not.
             * @deprecated Use {@link backgroundEnabled} instead.
             */
            getBackgroundEnabled() {
                return this.#backgroundEnabled;
            }
            /**
             * Returns the cameras aspect ratio.
             * @deprecated Use {@link aspectRatio} instead.
             */
            getAspect() {
                return this.#aspectRatio;
            }
            /**
             * Returns the cameras field of view in degrees.
             * @deprecated Use {@link fieldOfView} instead.
             */
            getFieldOfView() {
                return this.#fieldOfView;
            }
            /**
             * Returns the cameras direction i.e. the plane on which the fieldOfView-Angle is given.
             * @deprecated Use {@link direction} instead.
             */
            getDirection() {
                return this.#direction;
            }
            /**
             * Returns the cameras near value i.e. the minimum distance to render objects at.
             * @deprecated Use {@link near} instead.
             */
            getNear() {
                return this.#near;
            }
            /**
             * Returns the cameras far value i.e. the maximum distance to render objects at.
             * @deprecated Use {@link far} instead.
             */
            getFar() {
                return this.#far;
            }
            /**
             * Set the camera to perspective projection. The world origin is in the center of the canvaselement.
             * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
             * @param _fieldOfView The field of view in Degrees. (Default = 45)
             * @param _direction The plane on which the fieldOfView-Angle is given
             */
            projectCentral(_aspect = this.#aspectRatio, _fieldOfView = this.#fieldOfView, _direction = this.#direction, _near = this.#near, _far = this.#far) {
                this.#aspectRatio = _aspect;
                this.#fieldOfView = _fieldOfView;
                this.#direction = _direction;
                this.#projection = PROJECTION.CENTRAL;
                this.#near = _near;
                this.#far = _far;
                FudgeCore.Matrix4x4.PROJECTION_CENTRAL(_aspect, this.#fieldOfView, _near, _far, this.#direction, this.#mtxProjection);
            }
            /**
             * Set the camera to orthographic projection. Default values are derived the canvas client dimensions
             * @param _left The positionvalue of the projectionspace's left border.
             * @param _right The positionvalue of the projectionspace's right border.
             * @param _bottom The positionvalue of the projectionspace's bottom border.
             * @param _top The positionvalue of the projectionspace's top border.
             */
            projectOrthographic(_left, _right, _bottom, _top) {
                const rectCanvas = FudgeCore.Render.getCanvasRectangle();
                const width = rectCanvas.width;
                const height = rectCanvas.height;
                _left = -width / 2;
                _right = width / 2;
                _bottom = height / 2;
                _top = -height / 2;
                this.#projection = PROJECTION.ORTHOGRAPHIC;
                FudgeCore.Matrix4x4.PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, 400, -400, this.#mtxProjection); // TODO: examine magic numbers!
            }
            /**
             * Returns a (recycled) rectangle of the calculated dimension of a projection surface in the hypothetical distance of 1 to the camera.
             * @param _out Optional rectangle to store the result in.
             */
            getProjectionRectangle(_out = FudgeCore.Recycler.reuse(FudgeCore.Rectangle)) {
                let tanFov = Math.tan(Math.PI * this.#fieldOfView / 360); // Half of the angle, to calculate dimension from the center -> right angle
                let tanHorizontal = 0;
                let tanVertical = 0;
                if (this.#direction == FIELD_OF_VIEW.DIAGONAL) {
                    let aspect = Math.sqrt(this.#aspectRatio);
                    tanHorizontal = tanFov * aspect;
                    tanVertical = tanFov / aspect;
                }
                else if (this.#direction == FIELD_OF_VIEW.VERTICAL) {
                    tanVertical = tanFov;
                    tanHorizontal = tanVertical * this.#aspectRatio;
                }
                else { //FOV_DIRECTION.HORIZONTAL
                    tanHorizontal = tanFov;
                    tanVertical = tanHorizontal / this.#aspectRatio;
                }
                return _out.set(0, 0, tanHorizontal * 2, tanVertical * 2);
            }
            /**
             * Transforms the given point from world space to clip space.
             * @param _out Optional vector to store the result in.
             */
            pointWorldToClip(_pointInWorldSpace, _out = FudgeCore.Recycler.reuse(FudgeCore.Vector3)) {
                const m = this.mtxWorldToView.getArray();
                const w = m[3] * _pointInWorldSpace.x + m[7] * _pointInWorldSpace.y + m[11] * _pointInWorldSpace.z + m[15];
                return FudgeCore.Vector3.TRANSFORMATION(_pointInWorldSpace, this.mtxWorldToView, true, _out).scale(1 / w);
            }
            /**
             * Transforms the given point from clip space to world space.
             * @param _out Optional vector to store the result in.
             */
            pointClipToWorld(_pointInClipSpace, _out = FudgeCore.Recycler.reuse(FudgeCore.Vector3)) {
                const mtxViewToWorld = FudgeCore.Matrix4x4.INVERSE(this.mtxWorldToView);
                const m = mtxViewToWorld.getArray();
                const w = m[3] * _pointInClipSpace.x + m[7] * _pointInClipSpace.y + m[11] * _pointInClipSpace.z + m[15];
                FudgeCore.Recycler.store(mtxViewToWorld);
                return FudgeCore.Vector3.TRANSFORMATION(_pointInClipSpace, mtxViewToWorld, true, _out).scale(1 / w);
            }
            /**
             * Returns a scaling factor that, given a position in world space,
             * scales an object at that position so that one unit equals one (logical) pixel on the screen
             * when seen through this camera.
             * e.g., after setting the scaling, 1 unit in the world equals one (logical) pixel on the screen.
             */
            getWorldToPixelScale(_posWorld) {
                let distance = this.mtxWorld.translation.getDistance(_posWorld);
                let scale;
                let rect = FudgeCore.Render.getRenderRectangle();
                switch (this.#direction) {
                    case FIELD_OF_VIEW.VERTICAL:
                        scale = 1 / rect.height * window.devicePixelRatio;
                        break;
                    case FIELD_OF_VIEW.HORIZONTAL:
                        scale = 1 / rect.width * window.devicePixelRatio;
                        break;
                    case FIELD_OF_VIEW.DIAGONAL:
                        scale = 1 / Math.sqrt((rect.width * rect.height) * window.devicePixelRatio);
                        break;
                }
                return scale * distance;
            }
            //#region Transfer
            serialize() {
                let serialization = {
                    backgroundColor: this.clrBackground,
                    backgroundEnabled: this.#backgroundEnabled,
                    projection: this.#projection,
                    fieldOfView: this.#fieldOfView,
                    direction: this.#direction,
                    near: this.#near,
                    far: this.#far,
                    aspect: this.#aspectRatio,
                    pivot: this.mtxPivot.serialize(),
                    [super.constructor.name]: super.serialize()
                };
                return serialization;
            }
            async deserialize(_serialization) {
                await this.clrBackground.deserialize(_serialization.backgroundColor);
                this.#backgroundEnabled = _serialization.backgroundEnabled;
                this.#projection = _serialization.projection;
                this.#fieldOfView = _serialization.fieldOfView;
                this.#aspectRatio = _serialization.aspect;
                this.#direction = _serialization.direction;
                this.#near = _serialization.near ?? this.#near;
                this.#far = _serialization.far ?? this.#far;
                await this.mtxPivot.deserialize(_serialization.pivot);
                await super.deserialize(_serialization[super.constructor.name]);
                switch (this.#projection) {
                    case PROJECTION.ORTHOGRAPHIC:
                        this.projectOrthographic(); // TODO: serialize and deserialize parameters
                        break;
                    case PROJECTION.CENTRAL:
                        this.projectCentral();
                        break;
                }
                return this;
            }
            async mutate(_mutator, _selection = null, _dispatchMutate = true) {
                await super.mutate(_mutator, _selection, _dispatchMutate);
                switch (this.#projection) {
                    case PROJECTION.CENTRAL:
                        this.projectCentral(this.#aspectRatio, this.#fieldOfView, this.#direction, this.#near, this.#far);
                        break;
                }
            }
            drawGizmos() {
                const mtxWorld = this.mtxWorld.clone;
                mtxWorld.scaling = mtxWorld.scaling.set(0.5, 0.5, 0.5);
                const color = FudgeCore.Color.CSS("lightgrey");
                FudgeCore.Gizmos.drawIcon(FudgeCore.TextureDefault.iconCamera, mtxWorld, color);
                FudgeCore.Recycler.store(mtxWorld);
                FudgeCore.Recycler.store(color);
            }
            drawGizmosSelected() {
                FudgeCore.Gizmos.drawWireFrustum(this.#aspectRatio, this.#fieldOfView, this.#near, this.#far, this.#direction, this.mtxWorld, FudgeCore.Color.CSS("lightgrey"));
            }
            ;
            reduceMutator(_mutator) {
                delete _mutator.transform;
                super.reduceMutator(_mutator);
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return ComponentCamera = _classThis;
    })();
    FudgeCore.ComponentCamera = ComponentCamera;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Makes the node face the camera when rendering, respecting restrictions for rotation around specific axis
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Component
     */
    class ComponentFaceCamera extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentFaceCamera); }
        constructor() {
            super();
            this.upLocal = true;
            this.up = FudgeCore.Vector3.Y(1);
            this.restrict = false;
            this.singleton = true;
        }
    }
    FudgeCore.ComponentFaceCamera = ComponentFaceCamera;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attached to a {@link Node} with an attached {@link ComponentCamera} this causes the rendered image to receive a fog-effect.
     * @authors Roland Heer, HFU, 2023
     */
    class ComponentFog extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentFog); }
        constructor(_color = new FudgeCore.Color(1, 1, 1, 1), _near = 1, _far = 50) {
            super();
            this.color = _color;
            this.near = _near;
            this.far = _far;
        }
        //#region Transfer
        serialize() {
            let serialization = {
                color: this.color.serialize(),
                near: this.near,
                far: this.far
            };
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await this.color.deserialize(_serialization.color);
            this.near = _serialization.near ?? this.near;
            this.far = _serialization.far ?? this.far;
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
    }
    FudgeCore.ComponentFog = ComponentFog;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Filters synchronization between a graph instance and the graph it is connected to. If active, no synchronization occurs.
     * Maybe more finegrained in the future...
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Component
     */
    class ComponentGraphFilter extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentGraphFilter); }
        constructor() {
            super();
            this.singleton = true;
        }
        serialize() {
            return this.getMutator();
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
    }
    FudgeCore.ComponentGraphFilter = ComponentGraphFilter;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines identifiers for the various types of light this component can provide.
     */
    // export let LIGHT_TYPE: { [type: string]: string } = {
    let LIGHT_TYPE;
    (function (LIGHT_TYPE) {
        LIGHT_TYPE["AMBIENT"] = "LightAmbient";
        LIGHT_TYPE["DIRECTIONAL"] = "LightDirectional";
        LIGHT_TYPE["POINT"] = "LightPoint";
        LIGHT_TYPE["SPOT"] = "LightSpot";
    })(LIGHT_TYPE = FudgeCore.LIGHT_TYPE || (FudgeCore.LIGHT_TYPE = {}));
    /**
      * Attaches a {@link Light} to the node
      * The pivot matrix has different effects depending on the type of the {@link Light}. See there for details.
      * @authors Jirka Dell'Oro-Friedl, HFU, 2019
      */
    let ComponentLight = (() => {
        var _a;
        let _classSuper = FudgeCore.Component;
        let _staticExtraInitializers = [];
        let _static_updateRenderbuffer_decorators;
        let _lightType_decorators;
        let _lightType_initializers = [];
        let _lightType_extraInitializers = [];
        return class ComponentLight extends _classSuper {
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _lightType_decorators = [FudgeCore.type(LIGHT_TYPE)];
                _static_updateRenderbuffer_decorators = [(_a = FudgeCore.RenderWebGLComponentLight).decorate.bind(_a)];
                __esDecorate(this, null, _static_updateRenderbuffer_decorators, { kind: "method", name: "updateRenderbuffer", static: true, private: false, access: { has: obj => "updateRenderbuffer" in obj, get: obj => obj.updateRenderbuffer }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(null, null, _lightType_decorators, { kind: "field", name: "lightType", static: false, private: false, access: { has: obj => "lightType" in obj, get: obj => obj.lightType, set: (obj, value) => { obj.lightType = value; } }, metadata: _metadata }, _lightType_initializers, _lightType_extraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = (__runInitializers(this, _staticExtraInitializers), FudgeCore.Component.registerSubclass(ComponentLight)); }
            constructor(_lightType = LIGHT_TYPE.AMBIENT, _color = new FudgeCore.Color(1, 1, 1, 1), _intensity = 1) {
                super();
                this.lightType = __runInitializers(this, _lightType_initializers, void 0);
                this.mtxPivot = (__runInitializers(this, _lightType_extraInitializers), FudgeCore.Matrix4x4.IDENTITY());
                this.singleton = false;
                this.lightType = _lightType;
                this.color = _color;
                this.intensity = _intensity;
            }
            /** @internal reroute to {@link RenderWebGLComponentLight.updateRenderbuffer} */
            static updateRenderbuffer(_lights) { }
            ;
            serialize() {
                let serialization = {
                    lightType: this.lightType,
                    pivot: this.mtxPivot.serialize(),
                    color: this.color.serialize(),
                    intensity: this.intensity
                };
                serialization[super.constructor.name] = super.serialize();
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization[super.constructor.name]);
                if (_serialization.lightType != undefined)
                    this.lightType = _serialization.lightType;
                await this.mtxPivot.deserialize(_serialization.pivot);
                if (_serialization.color != undefined)
                    await this.color.deserialize(_serialization.color);
                if (_serialization.intensity != undefined)
                    this.intensity = _serialization.intensity;
                // backwards compatibility, remove in future versions
                let light = _serialization.light;
                if (light != undefined) {
                    for (const path in light) {
                        this.lightType = FudgeCore.Serializer.getConstructor(path).name;
                        light = light[path];
                        if (light.color != undefined)
                            await this.color.deserialize(light.color);
                        if (light.intensity != undefined)
                            this.intensity = light.intensity;
                    }
                }
                return this;
            }
            drawGizmos() {
                let mtxShape = FudgeCore.Matrix4x4.PRODUCT(this.node.mtxWorld, this.mtxPivot);
                mtxShape.scaling = new FudgeCore.Vector3(0.5, 0.5, 0.5);
                FudgeCore.Gizmos.drawIcon(FudgeCore.TextureDefault.iconLight, mtxShape, this.color);
                FudgeCore.Recycler.store(mtxShape);
            }
            ;
            drawGizmosSelected() {
                let mtxShape = FudgeCore.Matrix4x4.PRODUCT(this.node.mtxWorld, this.mtxPivot);
                let color = FudgeCore.Color.CSS("yellow");
                switch (this.lightType) {
                    case LIGHT_TYPE.DIRECTIONAL:
                        const radius = 0.5;
                        FudgeCore.Gizmos.drawWireCircle(mtxShape, color);
                        const lines = new Array(10).fill(null).map(() => FudgeCore.Recycler.get(FudgeCore.Vector3));
                        lines[0].set(0, 0, 0);
                        lines[1].set(0, 0, 1);
                        lines[2].set(0, radius, 0);
                        lines[3].set(0, radius, 1);
                        lines[6].set(0, -radius, 0);
                        lines[7].set(0, -radius, 1);
                        lines[4].set(radius, 0, 0);
                        lines[5].set(radius, 0, 1);
                        lines[8].set(-radius, 0, 0);
                        lines[9].set(-radius, 0, 1);
                        FudgeCore.Gizmos.drawLines(lines, mtxShape, color);
                        FudgeCore.Recycler.store(lines);
                        break;
                    case LIGHT_TYPE.POINT:
                        mtxShape.scale(new FudgeCore.Vector3(2, 2, 2));
                        FudgeCore.Gizmos.drawWireSphere(mtxShape, color);
                        break;
                    case LIGHT_TYPE.SPOT:
                        FudgeCore.Gizmos.drawWireCone(mtxShape, color);
                        break;
                }
                FudgeCore.Recycler.store(mtxShape);
                FudgeCore.Recycler.store(color);
            }
        };
    })();
    FudgeCore.ComponentLight = ComponentLight;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a {@link Material} to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019 - 2021
     */
    let ComponentMaterial = (() => {
        let _classSuper = FudgeCore.Component;
        let _material_decorators;
        let _material_initializers = [];
        let _material_extraInitializers = [];
        return class ComponentMaterial extends _classSuper {
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _material_decorators = [FudgeCore.type(FudgeCore.Material)];
                __esDecorate(null, null, _material_decorators, { kind: "field", name: "material", static: false, private: false, access: { has: obj => "material" in obj, get: obj => obj.material, set: (obj, value) => { obj.material = value; } }, metadata: _metadata }, _material_initializers, _material_extraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentMaterial); }
            // public mutatorCoat: MutatorForComponent;
            constructor(_material = null) {
                super();
                this.clrPrimary = FudgeCore.Color.CSS("white");
                this.clrSecondary = FudgeCore.Color.CSS("white");
                this.mtxPivot = FudgeCore.Matrix3x3.IDENTITY();
                this.material = __runInitializers(this, _material_initializers, void 0);
                /** Support sorting of objects with transparency when rendering, render objects in the back first. When this component is used as a part of a {@link ParticleSystem}, try enabling this when disabling {@link ComponentParticleSystem.depthMask} */
                this.sortForAlpha = (__runInitializers(this, _material_extraInitializers), false); // TODO: maybe make this a property of the material?
                this.material = _material;
                // this.mutatorCoat = _material.getCoat().getMutatorForComponent();
            }
            //#region Transfer
            serialize() {
                let serialization = {
                    sortForAlpha: this.sortForAlpha,
                    clrPrimary: this.clrPrimary.serialize(),
                    clrSecondary: this.clrSecondary.serialize(),
                    pivot: this.mtxPivot.serialize(),
                    [super.constructor.name]: super.serialize(),
                    idMaterial: this.material.idResource
                };
                return serialization;
            }
            async deserialize(_serialization) {
                this.material = await FudgeCore.Project.getResource(_serialization.idMaterial);
                await this.clrPrimary.deserialize(_serialization.clrPrimary);
                await this.clrSecondary.deserialize(_serialization.clrSecondary);
                this.sortForAlpha = _serialization.sortForAlpha;
                await this.mtxPivot.deserialize(_serialization.pivot);
                await super.deserialize(_serialization[super.constructor.name]);
                return this;
            }
        };
    })();
    FudgeCore.ComponentMaterial = ComponentMaterial;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a {@link Mesh} to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    let ComponentMesh = (() => {
        let _classDecorators = [FudgeCore.enumerate];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Component;
        let _instanceExtraInitializers = [];
        let _mesh_decorators;
        let _mesh_initializers = [];
        let _mesh_extraInitializers = [];
        let _get_mtxPivot_decorators;
        var ComponentMesh = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _mesh_decorators = [FudgeCore.type(FudgeCore.Mesh)];
                _get_mtxPivot_decorators = [FudgeCore.enumerate];
                __esDecorate(this, null, _get_mtxPivot_decorators, { kind: "getter", name: "mtxPivot", static: false, private: false, access: { has: obj => "mtxPivot" in obj, get: obj => obj.mtxPivot }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(null, null, _mesh_decorators, { kind: "field", name: "mesh", static: false, private: false, access: { has: obj => "mesh" in obj, get: obj => obj.mesh, set: (obj, value) => { obj.mesh = value; } }, metadata: _metadata }, _mesh_initializers, _mesh_extraInitializers);
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                ComponentMesh = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentMesh); }
            #mtxPivot;
            constructor(_mesh, _skeleton) {
                super();
                this.mtxWorld = (__runInitializers(this, _instanceExtraInitializers), FudgeCore.Matrix4x4.IDENTITY());
                this.mesh = __runInitializers(this, _mesh_initializers, void 0);
                this.skeleton = __runInitializers(this, _mesh_extraInitializers);
                this.#mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
                this.mesh = _mesh;
                this.skeleton = _skeleton;
            }
            get mtxPivot() {
                return this.#mtxPivot;
            }
            set mtxPivot(_mtx) {
                this.#mtxPivot = _mtx;
                this.#mtxPivot.modified = true;
            }
            get radius() {
                let scaling = this.mtxWorld.scaling;
                let scale = Math.max(Math.abs(scaling.x), Math.abs(scaling.y), Math.abs(scaling.z));
                return this.mesh.radius * scale;
            }
            // /**
            //  * Calculates the position of a vertex transformed by the skeleton
            //  * @param _index index of the vertex
            //  */
            // public getVertexPosition(_index: number): Vector3 {
            //   // extract the vertex data (vertices: 3D vectors, bone indices & weights: 4D vectors)
            //   const iVertex: number = _index * 3;
            //   const iBoneInfluence: number = _index * 4;
            //   const vertex: Vector3 = new Vector3(...Reflect.get(this.mesh, "renderMesh").vertices.slice(iVertex, iVertex + 3));
            //   if (!(this.mesh instanceof MeshSkin)) return vertex;
            //   const iBones: Uint8Array = this.mesh.iBones.slice(iBoneInfluence, iBoneInfluence + 4);
            //   const weights: Float32Array = this.mesh.weights.slice(iBoneInfluence, iBoneInfluence + 4);
            //   // get bone matrices
            //   const mtxBones: Array<Matrix4x4> = this.skeleton.mtxBones;
            //   // skin matrix S = sum_i=1^m{w_i * B_i}
            //   const skinMatrix: Matrix4x4 = new Matrix4x4();
            //   skinMatrix.set(Array
            //     .from(iBones)
            //     .map((iBone, iWeight) => mtxBones[iBone].get().map(value => value * weights[iWeight])) // apply weight on each matrix
            //     .reduce((mtxSum, mtxBone) => mtxSum.map((value, index) => value + mtxBone[index])) // sum up the matrices
            //   );
            //   // transform vertex
            //   vertex.transform(skinMatrix);
            //   return vertex;
            // }
            // TODO: remove or think if the transformed bounding box is of value or can be made to be
            // public get boundingBox(): Box {
            //   let box: Box = Recycler.get(Box);
            //   box.set(
            //     Vector3.TRANSFORMATION(this.mesh.boundingBox.min, this.mtxWorld, true),
            //     Vector3.TRANSFORMATION(this.mesh.boundingBox.max, this.mtxWorld, true)
            //   );
            //   return box;
            // }
            //#region Transfer
            serialize() {
                let serialization;
                /* at this point of time, serialization as resource and as inline object is possible. TODO: check if inline becomes obsolete */
                let idMesh = this.mesh.idResource;
                if (idMesh)
                    serialization = { idMesh: idMesh };
                else
                    serialization = { mesh: FudgeCore.Serializer.serialize(this.mesh) };
                if (this.skeleton)
                    serialization.skeleton = FudgeCore.Node.PATH_FROM_TO(this, this.skeleton);
                serialization.pivot = this.mtxPivot.serialize();
                serialization[super.constructor.name] = super.serialize();
                return serialization;
            }
            async deserialize(_serialization) {
                let mesh;
                if (_serialization.idMesh)
                    mesh = await FudgeCore.Project.getResource(_serialization.idMesh);
                else
                    mesh = await FudgeCore.Serializer.deserialize(_serialization.mesh);
                this.mesh = mesh;
                if (_serialization.skeleton) {
                    const hndNodeDeserialized = () => {
                        const hndGraphDeserialized = () => {
                            this.skeleton = FudgeCore.Node.FIND(this, _serialization.skeleton);
                            this.node.removeEventListener("graphDeserialized" /* EVENT.GRAPH_DESERIALIZED */, hndGraphDeserialized, true);
                            this.removeEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
                        };
                        this.node.addEventListener("graphDeserialized" /* EVENT.GRAPH_DESERIALIZED */, hndGraphDeserialized, true);
                    };
                    this.addEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
                }
                await this.mtxPivot.deserialize(_serialization.pivot);
                await super.deserialize(_serialization[super.constructor.name]);
                return this;
            }
            //#endregion
            drawGizmosSelected() {
                if (!this.mesh)
                    return;
                let color = FudgeCore.Color.CSS("salmon");
                FudgeCore.Gizmos.drawWireMesh(this.mesh, this.mtxWorld, color, 0.1);
                FudgeCore.Recycler.store(color);
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return ComponentMesh = _classThis;
    })();
    FudgeCore.ComponentMesh = ComponentMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attached to a {@link Node} with an attached {@link ComponentCamera} this causes all nodes in {@link selection} to be drawn with a 1px outline.
     * @authors Jonas Plotzky, HFU, 2025
     */
    class ComponentOutline extends FudgeCore.Component {
        constructor(_selection = [], _color = new FudgeCore.Color(0, 0, 0, 1), _colorOccluded = new FudgeCore.Color(0, 0, 0, 0)) {
            super();
            this.selection = _selection;
            this.color = _color;
            this.colorOccluded = _colorOccluded;
        }
    }
    FudgeCore.ComponentOutline = ComponentOutline;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let PARTICLE_SYSTEM_PLAYMODE;
    (function (PARTICLE_SYSTEM_PLAYMODE) {
        /**Plays particle system in a loop: it restarts once it hit the end.*/
        PARTICLE_SYSTEM_PLAYMODE[PARTICLE_SYSTEM_PLAYMODE["LOOP"] = 0] = "LOOP";
        /**Plays particle system once and stops at the last point in time.*/
        PARTICLE_SYSTEM_PLAYMODE[PARTICLE_SYSTEM_PLAYMODE["PLAY_ONCE"] = 1] = "PLAY_ONCE";
    })(PARTICLE_SYSTEM_PLAYMODE = FudgeCore.PARTICLE_SYSTEM_PLAYMODE || (FudgeCore.PARTICLE_SYSTEM_PLAYMODE = {}));
    /**
     * Attaches a {@link ParticleSystem} to the node.
     * Works in conjunction with {@link ComponentMesh} and {@link ComponentMaterial} to create a shader particle system.
     * Additionally a {@link ComponentFaceCamera} can be attached to make the particles face the camera.
     * @author Jonas Plotzky, HFU, 2022
     */
    let ComponentParticleSystem = (() => {
        var _a, _b;
        let _classDecorators = [FudgeCore.enumerate];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Component;
        let _instanceExtraInitializers = [];
        let _particleSystem_decorators;
        let _particleSystem_initializers = [];
        let _particleSystem_extraInitializers = [];
        let _get_size_decorators;
        let _useRenderData_decorators;
        let _deleteRenderData_decorators;
        var ComponentParticleSystem = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _particleSystem_decorators = [FudgeCore.type(FudgeCore.ParticleSystem)];
                _get_size_decorators = [FudgeCore.enumerate];
                _useRenderData_decorators = [(_a = FudgeCore.RenderInjectorComponentParticleSystem).decorate.bind(_a)];
                _deleteRenderData_decorators = [(_b = FudgeCore.RenderInjectorComponentParticleSystem).decorate.bind(_b)];
                __esDecorate(this, null, _get_size_decorators, { kind: "getter", name: "size", static: false, private: false, access: { has: obj => "size" in obj, get: obj => obj.size }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(this, null, _useRenderData_decorators, { kind: "method", name: "useRenderData", static: false, private: false, access: { has: obj => "useRenderData" in obj, get: obj => obj.useRenderData }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(this, null, _deleteRenderData_decorators, { kind: "method", name: "deleteRenderData", static: false, private: false, access: { has: obj => "deleteRenderData" in obj, get: obj => obj.deleteRenderData }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(null, null, _particleSystem_decorators, { kind: "field", name: "particleSystem", static: false, private: false, access: { has: obj => "particleSystem" in obj, get: obj => obj.particleSystem, set: (obj, value) => { obj.particleSystem = value; } }, metadata: _metadata }, _particleSystem_initializers, _particleSystem_extraInitializers);
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                ComponentParticleSystem = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentParticleSystem); }
            /** The number of particles */
            #size;
            #timeScale;
            #time;
            constructor(_particleSystem = null) {
                super();
                this.particleSystem = (__runInitializers(this, _instanceExtraInitializers), __runInitializers(this, _particleSystem_initializers, void 0));
                /** When disabled try enabling {@link ComponentMaterial.sortForAlpha} */
                this.depthMask = __runInitializers(this, _particleSystem_extraInitializers);
                this.#timeScale = 1;
                //#endregion
                this.hndEvent = (_event) => {
                    switch (_event.type) {
                        case "nodeDeserialized" /* EVENT.NODE_DESERIALIZED */:
                        case "componentAdd" /* EVENT.COMPONENT_ADD */:
                            FudgeCore.Time.game.addEventListener("timeScaled" /* EVENT.TIME_SCALED */, this.updateTimeScale);
                            this.node.addEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.update);
                            break;
                        case "componentRemove" /* EVENT.COMPONENT_REMOVE */:
                            FudgeCore.Time.game.removeEventListener("timeScaled" /* EVENT.TIME_SCALED */, this.updateTimeScale);
                            this.node.removeEventListener("renderPrepare" /* EVENT.RENDER_PREPARE */, this.update);
                    }
                };
                this.update = () => {
                    if (this.time > this.duration)
                        switch (this.playMode) {
                            default:
                            case PARTICLE_SYSTEM_PLAYMODE.LOOP:
                                this.time = 0;
                                break;
                            case PARTICLE_SYSTEM_PLAYMODE.PLAY_ONCE:
                                this.time = this.duration;
                                this.timeScale = 0;
                                break;
                        }
                };
                this.updateTimeScale = () => {
                    let timeScale = this.#timeScale * FudgeCore.Time.game.getScale();
                    this.#time.setScale(timeScale);
                };
                this.particleSystem = _particleSystem;
                this.depthMask = true;
                this.blendMode = FudgeCore.BLEND.ADDITIVE;
                this.playMode = PARTICLE_SYSTEM_PLAYMODE.LOOP;
                this.duration = 1000;
                this.size = 10;
                this.#time = new FudgeCore.Time();
                this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.hndEvent);
                this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.hndEvent);
                this.addEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, this.hndEvent);
            }
            /**
             * Get the number of particles
             */
            get size() {
                return this.#size;
            }
            /**
             * Set the number of particles. Caution: Setting this will reinitialize the random numbers array(texture) used in the shader.
             */
            set size(_size) {
                this.#size = _size;
                this.deleteRenderData();
            }
            get time() {
                return this.#time.get();
            }
            set time(_time) {
                this.#time.set(_time);
            }
            get timeScale() {
                return this.#timeScale;
            }
            set timeScale(_scale) {
                this.#timeScale = _scale;
                this.updateTimeScale();
            }
            /**
             * Generates and binds the random numbers texture in WebGL
             * Injected by {@link RenderInjectorComponentParticleSystem}. Used by the render system.
             * @internal
             */
            useRenderData() { }
            /**
             * Deletes the random numbers texture in WebGL freeing the allocated gpu memory.
             * Injected by {@link RenderInjectorComponentParticleSystem}.
             * @internal
             */
            deleteRenderData() { }
            //#region transfer
            serialize() {
                let serialization = {
                    [super.constructor.name]: super.serialize(),
                    idParticleSystem: this.particleSystem?.idResource,
                    depthMask: this.depthMask,
                    blendMode: this.blendMode,
                    playMode: this.playMode,
                    duration: this.duration,
                    size: this.size
                };
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization[super.constructor.name]);
                if (_serialization.idParticleSystem)
                    this.particleSystem = await FudgeCore.Project.getResource(_serialization.idParticleSystem);
                this.depthMask = _serialization.depthMask;
                this.blendMode = _serialization.blendMode;
                this.playMode = _serialization.playMode;
                this.duration = _serialization.duration;
                this.size = _serialization.size;
                return this;
            }
            getMutatorForAnimation() {
                let mutator = this.getMutator();
                delete mutator.particleSystem;
                delete mutator.size;
                return mutator;
            }
            getMutatorAttributeTypes(_mutator) {
                let types = super.getMutatorAttributeTypes(_mutator);
                if (types.blendMode)
                    types.blendMode = FudgeCore.BLEND;
                if (types.playMode)
                    types.playMode = PARTICLE_SYSTEM_PLAYMODE;
                return types;
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return ComponentParticleSystem = _classThis;
    })();
    FudgeCore.ComponentParticleSystem = ComponentParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let PICK;
    (function (PICK) {
        PICK["RADIUS"] = "radius";
        PICK["CAMERA"] = "camera";
        PICK["PHYSICS"] = "physics";
    })(PICK = FudgeCore.PICK || (FudgeCore.PICK = {}));
    /**
     * Attaches picking functionality to the node
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class ComponentPick extends FudgeCore.Component {
        constructor() {
            super(...arguments);
            this.pick = PICK.RADIUS;
        }
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentPick); }
        /**
         * Picks the node according to the given {@link Ray} and invokes events accordingly
         */
        pickAndDispatch(_ray, _event) {
            let cmpMesh = this.node.getComponent(FudgeCore.ComponentMesh);
            let position = cmpMesh ? cmpMesh.mtxWorld.translation : this.node.mtxWorld.translation;
            switch (this.pick) {
                case PICK.RADIUS:
                    // TODO: should only be node.radius. Adjustment needed, if mesh was transformed...
                    if (_ray.getDistance(position).magnitude < this.node.radius) {
                        this.node.dispatchEvent(_event);
                    }
                    break;
                case PICK.PHYSICS:
                    let hitInfo = FudgeCore.Physics.raycast(_ray.origin, _ray.direction, FudgeCore.Vector3.DIFFERENCE(position, _ray.origin).magnitudeSquared);
                    if (hitInfo.hit)
                        this.node.dispatchEvent(_event);
                    break;
                //TODO: PICK.CAMERA
            }
        }
        serialize() {
            return this.getMutator();
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.pick)
                types.pick = PICK;
            return types;
        }
        drawGizmosSelected(_cmpCamera) {
            if (this.pick != PICK.RADIUS)
                return;
            let translation = (this.node.getComponent(FudgeCore.ComponentMesh)?.mtxWorld ?? this.node.mtxWorld).translation;
            let color = FudgeCore.Color.CSS("white", 0.5);
            let scaling = FudgeCore.Recycler.get(FudgeCore.Vector3).set(this.node.radius * 2, this.node.radius * 2, this.node.radius * 2);
            let mtxWorld = FudgeCore.Matrix4x4.COMPOSITION(translation, undefined, scaling);
            FudgeCore.Gizmos.drawSphere(mtxWorld, color);
            FudgeCore.Recycler.store(mtxWorld);
            FudgeCore.Recycler.store(scaling);
            FudgeCore.Recycler.store(color);
        }
    }
    FudgeCore.ComponentPick = ComponentPick;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Base class for scripts the user writes
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Component
     */
    class ComponentScript extends FudgeCore.Component {
        // registering this doesn't make sense, only its subclasses. Or this component must refer to scripts to be attached to this component
        // TODO: rethink & refactor
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentScript); }
        constructor() {
            super();
            this.singleton = false;
        }
        serialize() {
            return this.getMutator(true);
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
    }
    FudgeCore.ComponentScript = ComponentScript;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Attaches a {@link TextureText} to the node.
     * Works in conjunction with {@link ComponentMesh} and {@link ComponentMaterial} to create a text node.
     * A 'textured' {@link Material} (e.g. {@link ShaderLitTextured}) must be used to display the text properly. Ideally a {@link MeshQuad} should be used to render the text onto.
     * Additionally a {@link ComponentFaceCamera} can be attached to make the text face the camera.
     * @authors Jonas Plotzky, HFU, 2024
     */
    class ComponentText extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentText); }
        constructor(_text, _font) {
            super();
            this.texture = new FudgeCore.TextureText(ComponentText.name, _text, _font);
            this.mtxWorld = FudgeCore.Matrix4x4.IDENTITY();
            this.fixedSize = false;
        }
        serialize() {
            return this.getMutator();
        }
        async deserialize(_serialization) {
            this.mutate(_serialization);
            return this;
        }
        useRenderData(_mtxMeshToWorld, _cmpCamera) {
            this.texture.useRenderData(FudgeCore.TEXTURE_LOCATION.COLOR.UNIT);
            this.mtxWorld.copy(_mtxMeshToWorld);
            let scaling = FudgeCore.Recycler.get(FudgeCore.Vector3);
            if (this.fixedSize) {
                let scale = _cmpCamera.getWorldToPixelScale(_mtxMeshToWorld.translation);
                this.mtxWorld.scaling = scaling.set(this.texture.width * scale, this.texture.height * scale, 1);
                ;
            }
            else {
                let pixelsToUnits = 1 / this.texture.height;
                scaling.set(this.texture.width * pixelsToUnits, this.texture.height * pixelsToUnits, 1);
                this.mtxWorld.scale(scaling);
            }
            FudgeCore.Recycler.store(scaling);
            return this.mtxWorld;
        }
        drawGizmosSelected() {
            let mesh = this.node.getComponent(FudgeCore.ComponentMesh)?.mesh;
            let cmpMaterial = this.node.getComponent(FudgeCore.ComponentMaterial);
            if (mesh == null || cmpMaterial == null)
                return;
            FudgeCore.Gizmos.drawWireMesh(mesh, this.mtxWorld, cmpMaterial.clrPrimary);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.texture.name;
        }
    }
    FudgeCore.ComponentText = ComponentText;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let BASE;
    (function (BASE) {
        BASE[BASE["SELF"] = 0] = "SELF";
        BASE[BASE["PARENT"] = 1] = "PARENT";
        BASE[BASE["WORLD"] = 2] = "WORLD";
        BASE[BASE["NODE"] = 3] = "NODE";
    })(BASE = FudgeCore.BASE || (FudgeCore.BASE = {}));
    /**
     * Attaches a transform-{@link Matrix4x4} to the node, moving, scaling and rotating it in space relative to its parent.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class ComponentTransform extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentTransform); }
        constructor(_mtxInit = FudgeCore.Matrix4x4.IDENTITY()) {
            super();
            this.mtxLocal = _mtxInit;
        }
        //#region Transformations respecting the hierarchy
        /**
         * recalculates this local matrix to yield the identical world matrix based on the given node.
         * Use rebase before appending the container of this component to another node while preserving its transformation in the world.
         */
        rebase(_node = null) {
            let mtxResult = this.mtxLocal;
            let container = this.node;
            if (container)
                mtxResult = container.mtxWorld;
            if (_node)
                mtxResult = FudgeCore.Matrix4x4.RELATIVE(mtxResult, null, _node.mtxWorldInverse);
            this.mtxLocal = mtxResult;
        }
        /**
         * Applies the given transformation relative to the selected base (SELF, PARENT, WORLD) or a particular other node (NODE)
         */
        transform(_mtxTransform, _base = BASE.SELF, _node = null) {
            switch (_base) {
                case BASE.SELF:
                    this.mtxLocal.multiply(_mtxTransform);
                    break;
                case BASE.PARENT:
                    this.mtxLocal.multiply(_mtxTransform, true);
                    break;
                case BASE.NODE:
                    if (!_node)
                        throw new Error("BASE.NODE requires a node given as base");
                case BASE.WORLD:
                    this.rebase(_node);
                    this.mtxLocal.multiply(_mtxTransform, true);
                    let node = this.node;
                    if (node) {
                        let mtxTemp;
                        if (_base == BASE.NODE) {
                            // fix mtxWorld of container for subsequent rebasing 
                            mtxTemp = FudgeCore.Matrix4x4.PRODUCT(_node.mtxWorld, node.mtxLocal);
                            node.mtxWorld.copy(mtxTemp);
                            FudgeCore.Recycler.store(mtxTemp);
                        }
                        let parent = node.getParent();
                        if (parent) {
                            // fix mtxLocal for current parent
                            this.rebase(node.getParent());
                            mtxTemp = FudgeCore.Matrix4x4.PRODUCT(node.getParent().mtxWorld, node.mtxLocal);
                            node.mtxWorld.copy(mtxTemp);
                            FudgeCore.Recycler.store(mtxTemp);
                        }
                    }
                    break;
            }
        }
        //#endregion
        //#region Transfer
        serialize() {
            let serialization = {
                local: this.mtxLocal.serialize(),
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization[super.constructor.name]);
            await this.mtxLocal.deserialize(_serialization.local);
            return this;
        }
        mutate(_mutator, _selection, _dispatchMutate = true) {
            // super.mutateSync(_mutator, _dispatchMutate);
            // inline mutation for animation performance, slightly faster than calling super.mutate
            if (_mutator.active != undefined)
                this.activate(_mutator.active);
            if (_mutator.mtxLocal != undefined)
                this.mtxLocal.mutate(_mutator.mtxLocal);
            if (_dispatchMutate)
                this.dispatchEvent(new CustomEvent("mutate" /* EVENT.MUTATE */, { bubbles: true, detail: { mutator: _mutator } }));
        }
        reduceMutator(_mutator) {
            delete _mutator.world;
            super.reduceMutator(_mutator);
        }
    }
    FudgeCore.ComponentTransform = ComponentTransform;
    // function decorateMutable<M extends (this: General, ...args: General) => General>(_method: M, _context: ClassMethodDecoratorContext<typeof Coat, M>): M {
    //   return 
    // }
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Describes a VR Controller and its capabilities.
     */
    class VRController {
        constructor() {
            this.cmpTransform = null;
            this.gamePad = null;
            this.thumbstickX = null;
            this.thumbstickY = null;
        }
    }
    FudgeCore.VRController = VRController;
    /**
     * VR Component Class, for Session Management, Controller Management and Reference Space Management.
     * @author Valentin Schmidberger, HFU, 2022
     */
    class ComponentVRDevice extends FudgeCore.ComponentCamera {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentVRDevice); }
        #mtxLocal;
        constructor() {
            super();
            this.rightCntrl = new VRController();
            this.leftCntrl = new VRController();
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.getMtxLocalFromCmpTransform);
        }
        /**
         * Returns the actual matrix of the vr - device.
         * Creators should use this for readonly purposes.
         */
        get mtxLocal() {
            return this.#mtxLocal;
        }
        /**
         * Sets a Vector3 as Position of the reference space.
         */
        set translation(_translation) {
            let translation = _translation.clone;
            translation.subtract(this.#mtxLocal.translation);
            translation.negate();
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(translation));
            this.#mtxLocal.translation = _translation;
            FudgeCore.Recycler.store(translation);
        }
        /**
         * Sets Vector3 Rotation of the reference space.
         */
        set rotation(_rotation) {
            let rotation = _rotation.clone;
            rotation.subtract(this.#mtxLocal.rotation);
            rotation.negate();
            let orientation = new FudgeCore.Quaternion();
            orientation.eulerAngles = rotation;
            // Rotation needs to be set in the Origin (0,0,0), otherwise the XR-Rig gets rotated around the origin. 
            // set xr - rig back to origin
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.DIFFERENCE(this.#mtxLocal.translation, FudgeCore.Vector3.ZERO())));
            // rotate xr rig in origin
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.ZERO(), orientation));
            // set xr - rig back to last position 
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.DIFFERENCE(FudgeCore.Vector3.ZERO(), this.#mtxLocal.translation)));
            this.#mtxLocal.rotation = _rotation;
            FudgeCore.Recycler.store(rotation);
        }
        /**
         * Adds a Vector3 in Position of the reference space.
         */
        translate(_by) {
            let translation = _by.clone;
            translation.transform(this.#mtxLocal.quaternion);
            translation.negate();
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(translation));
            this.#mtxLocal.translate(_by);
            FudgeCore.Recycler.store(translation);
        }
        /**
         * Adds a Vector3 in Rotation of the reference space.
         */
        rotate(_by) {
            let rotation = _by.clone.negate();
            let orientation = new FudgeCore.Quaternion();
            orientation.eulerAngles = rotation;
            // Rotation needs to be added in the Origin (0,0,0), otherwise the XR-Rig gets rotated around the origin. 
            // set xr - rig back to origin
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.DIFFERENCE(this.#mtxLocal.translation, FudgeCore.Vector3.ZERO())));
            // rotate xr rig in origin
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.ZERO(), orientation));
            // set xr - rig back to last position 
            FudgeCore.XRViewport.default.referenceSpace = FudgeCore.XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(FudgeCore.Vector3.DIFFERENCE(FudgeCore.Vector3.ZERO(), this.#mtxLocal.translation)));
            this.#mtxLocal.rotate(_by);
            FudgeCore.Recycler.store(rotation);
        }
        getMtxLocalFromCmpTransform() {
            this.#mtxLocal = this.node.mtxLocal;
        }
    }
    FudgeCore.ComponentVRDevice = ComponentVRDevice;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Processes input signals of type number and generates an output signal of the same type using
     * proportional, integral or differential mapping, an amplification factor and a linear dampening/delay
     * ```text
     *         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     *         ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      pass through (Proportional)      ‚îÇ
     * Input ‚Üí ‚îÇ ‚Üí ‚îÇamplify‚îÇ ‚Üí ‚îÇdelay‚îÇ ‚Üí ‚öü sum up over time (Integral) ‚öû ‚Üí ‚îÇ ‚Üí Output
     *         ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      pass change  (Differential)      ‚îÇ
     *         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     */
    class Control extends EventTarget {
        constructor(_name, _factor = 1, _type = 0 /* CONTROL_TYPE.PROPORTIONAL */, _delay = 0) {
            super();
            this.rateDispatchOutput = 0;
            this.valuePrevious = 0;
            this.outputBase = 0;
            this.outputTarget = 0;
            this.outputPrevious = 0;
            this.outputTargetPrevious = 0;
            this.factor = 0;
            this.time = FudgeCore.Time.game;
            this.timeValueDelay = 0;
            this.timeOutputTargetSet = 0;
            this.idTimer = undefined;
            this.dispatchOutput = (_eventOrValue) => {
                if (!this.active)
                    return;
                let timer = this.time.getTimer(this.idTimer);
                let output;
                if (typeof (_eventOrValue) == "number")
                    output = _eventOrValue;
                else
                    output = this.calculateOutput();
                let outputChanged = (output != this.outputPrevious);
                if (timer) {
                    timer.active = outputChanged;
                    if (!outputChanged)
                        return;
                }
                this.outputPrevious = output;
                let event = new CustomEvent("output" /* EVENT_CONTROL.OUTPUT */, {
                    detail: {
                        output: output
                    }
                });
                this.dispatchEvent(event);
            };
            this.factor = _factor;
            this.type = _type;
            this.active = true;
            this.name = _name;
            this.setDelay(_delay);
        }
        /**
         * Set the time-object to be used when calculating the output in {@link CONTROL_TYPE.INTEGRAL}
         */
        setTimebase(_time) {
            this.time = _time;
            this.calculateOutput();
        }
        /**
         * Feed an input value into this control and fire the events {@link EVENT_CONTROL.INPUT} and {@link EVENT_CONTROL.OUTPUT}
         */
        setInput(_input) {
            if (!this.active)
                return;
            this.outputBase = this.calculateOutput();
            this.valuePrevious = this.getValueDelayed();
            this.outputTarget = this.factor * _input;
            this.timeOutputTargetSet = this.time.get();
            if (this.type == 2 /* CONTROL_TYPE.DIFFERENTIAL */) {
                this.valuePrevious = this.outputTarget - this.outputTargetPrevious;
                this.outputTargetPrevious = this.outputTarget;
                this.outputTarget = 0;
            }
            this.dispatchEvent(new Event("input" /* EVENT_CONTROL.INPUT */));
            if (this.type == 2 /* CONTROL_TYPE.DIFFERENTIAL */)
                this.dispatchOutput(this.valuePrevious);
            else
                this.dispatchOutput(null);
        }
        /**
         * TODO: describe!
         */
        pulse(_input) {
            this.setInput(_input);
            this.setInput(0);
        }
        /**
         * Set the time to take for the internal linear dampening until the final ouput value is reached
         */
        setDelay(_time) {
            this.timeValueDelay = Math.max(0, _time);
        }
        /**
         * Set the number of output-events to dispatch per second.
         * At the default of 0, the control output must be polled and will only actively dispatched once each time input occurs and the output changes.
         */
        setRateDispatchOutput(_rateDispatchOutput = 0) {
            this.rateDispatchOutput = _rateDispatchOutput;
            this.time.deleteTimer(this.idTimer);
            this.idTimer = undefined;
            if (this.rateDispatchOutput)
                this.idTimer = this.time.setTimer(1000 / this.rateDispatchOutput, 0, this.dispatchOutput);
        }
        /**
         * Set the factor to multiply the input value given with {@link setInput} with
         */
        setFactor(_factor) {
            this.factor = _factor;
        }
        /**
         * Get the value from the output of this control
         */
        getOutput() {
            return this.calculateOutput();
        }
        /**
         * Calculates the output of this control
         */
        calculateOutput() {
            let output = 0;
            let value = this.getValueDelayed();
            switch (this.type) {
                case 1 /* CONTROL_TYPE.INTEGRAL */:
                    let timeCurrent = this.time.get();
                    let timeElapsedSinceInput = timeCurrent - this.timeOutputTargetSet;
                    output = this.outputBase;
                    if (this.timeValueDelay > 0) {
                        if (timeElapsedSinceInput < this.timeValueDelay) {
                            output += 0.5 * (this.valuePrevious + value) * timeElapsedSinceInput;
                            break;
                        }
                        else {
                            output += 0.5 * (this.valuePrevious + value) * this.timeValueDelay;
                            timeElapsedSinceInput -= this.timeValueDelay;
                        }
                    }
                    output += value * timeElapsedSinceInput;
                    // value += 0.5 * (this.inputPrevious - input) * this.timeInputDelay + input * timeElapsedSinceInput;
                    break;
                case 2 /* CONTROL_TYPE.DIFFERENTIAL */:
                case 0 /* CONTROL_TYPE.PROPORTIONAL */:
                default:
                    output = value;
                    break;
            }
            return output;
        }
        /**
         * calculates the output considering the time of the delay
         */
        getValueDelayed() {
            if (this.timeValueDelay > 0) {
                let timeElapsedSinceInput = this.time.get() - this.timeOutputTargetSet;
                if (timeElapsedSinceInput < this.timeValueDelay)
                    return this.valuePrevious + (this.outputTarget - this.valuePrevious) * timeElapsedSinceInput / this.timeValueDelay;
            }
            return this.outputTarget;
        }
    }
    FudgeCore.Control = Control;
})(FudgeCore || (FudgeCore = {}));
///<reference path="Control.ts"/>
var FudgeCore;
///<reference path="Control.ts"/>
(function (FudgeCore) {
    /**
     * Handles multiple controls as inputs and creates an output from that.
     * As a subclass of {@link Control}, axis calculates the ouput summing up the inputs and processing the result using its own settings.
     * Dispatches {@link EVENT_CONTROL.OUTPUT} and {@link EVENT_CONTROL.INPUT} when one of the controls dispatches them.
     * ```text
     *           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                 ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ\                                ‚îÇ
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò \                               ‚îÇ
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  \‚îå‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ---‚îÇsum‚îÇ ‚Üí ‚îÇinternal control ‚îÇ ‚Üí ‚îÇ ‚Üí Output
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  /‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
     *           ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê /                               ‚îÇ
     *   Input ‚Üí ‚îÇ ‚îÇcontrol‚îÇ/                                ‚îÇ
     *           ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
     *           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     * ```
     */
    class Axis extends FudgeCore.Control {
        constructor() {
            super(...arguments);
            this.controls = new Map();
            this.sumPrevious = 0;
            this.hndOutputEvent = (_event) => {
                if (!this.active)
                    return;
                let control = _event.target;
                let event = new CustomEvent("output" /* EVENT_CONTROL.OUTPUT */, {
                    detail: {
                        control: control,
                        input: _event.detail.output,
                        output: this.getOutput()
                    }
                });
                this.dispatchEvent(event);
            };
            this.hndInputEvent = (_event) => {
                if (!this.active)
                    return;
                let event = new Event("input" /* EVENT_CONTROL.INPUT */, _event);
                this.dispatchEvent(event);
            };
        }
        /**
         * Add the control given to the list of controls feeding into this axis
         */
        addControl(_control) {
            this.controls.set(_control.name, _control);
            _control.addEventListener("input" /* EVENT_CONTROL.INPUT */, this.hndInputEvent);
            _control.addEventListener("output" /* EVENT_CONTROL.OUTPUT */, this.hndOutputEvent);
        }
        /**
         * Returns the control with the given name
         */
        getControl(_name) {
            return this.controls.get(_name);
        }
        /**
         * Removes the control with the given name
         */
        removeControl(_name) {
            let control = this.getControl(_name);
            if (control) {
                control.removeEventListener("input" /* EVENT_CONTROL.INPUT */, this.hndInputEvent);
                control.removeEventListener("output" /* EVENT_CONTROL.OUTPUT */, this.hndOutputEvent);
                this.controls.delete(_name);
            }
        }
        /**
         * Returns the value of this axis after summing up all inputs and processing the sum according to the axis' settings
         */
        getOutput() {
            let sumInput = 0;
            for (let control of this.controls) {
                if (control[1].active)
                    sumInput += control[1].getOutput();
            }
            if (sumInput != this.sumPrevious)
                super.setInput(sumInput);
            this.sumPrevious = sumInput;
            return super.getOutput();
        }
    }
    FudgeCore.Axis = Axis;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Collects the keys pressed on the keyboard and stores their status.
     */
    class Keyboard {
        static { this.keysPressed = Keyboard.initialize(); }
        // private static code_en: Object;
        /**
         * Returns true if one of the given keys is is currently being pressed.
         */
        static isPressedOne(_keys) {
            for (let code of _keys) {
                if (Keyboard.keysPressed[code])
                    return true;
            }
            return false;
        }
        /**
         * Returns true if all of the given keys are currently being pressed
         */
        static isPressedCombo(_keys) {
            for (let code of _keys) {
                if (!Keyboard.keysPressed[code])
                    return false;
            }
            return true;
        }
        /**
         * Returns the value given as _active if one or, when _combo is true, all of the given keys are pressed.
         * Returns the value given as _inactive if not.
         */
        static mapToValue(_active, _inactive, _keys, _combo = false) {
            if (!_combo && Keyboard.isPressedOne(_keys))
                return _active;
            if (Keyboard.isPressedCombo(_keys))
                return _active;
            return _inactive;
        }
        /**
         * Returns a balanced ternary value (either -1, 0 or 1)
         * according to the match of the keys currently being pressed and the lists of keys given
         */
        static mapToTrit(_positive, _negative) {
            return Keyboard.mapToValue(-1, 0, _negative) + Keyboard.mapToValue(1, 0, _positive);
        }
        // public static locale(_keyboard: Object): void {
        //   if (!Keyboard.code_en) {
        //     // save original keyboard codes to be able to switch back later
        //     Keyboard.code_en = {};
        //     Object.assign(Keyboard.code_en, KEYBOARD_CODE);
        //   }
        //   for (let key in _keyboard) {
        //     let value: string = Reflect.get(_keyboard, key);
        //     for (let original in KEYBOARD_CODE)
        //       if (Reflect.get(KEYBOARD_CODE, original) == value)
        //         // remove original key the yields the value
        //         Reflect.deleteProperty(KEYBOARD_CODE, original);
        //     // add new key to yield that value
        //     Reflect.set(KEYBOARD_CODE, key, value);
        //   }
        // }
        static initialize() {
            let store = {};
            document.addEventListener("keydown", Keyboard.hndKeyInteraction);
            document.addEventListener("keyup", Keyboard.hndKeyInteraction);
            return store;
        }
        static hndKeyInteraction(_event) {
            Keyboard.keysPressed[_event.code] = (_event.type == "keydown");
        }
    }
    FudgeCore.Keyboard = Keyboard;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to the alert box
     */
    class DebugAlert extends FudgeCore.DebugTarget {
        static { this.delegates = {
            [FudgeCore.DEBUG_FILTER.INFO]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
            [FudgeCore.DEBUG_FILTER.LOG]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
            [FudgeCore.DEBUG_FILTER.WARN]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
            [FudgeCore.DEBUG_FILTER.ERROR]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE]),
            [FudgeCore.DEBUG_FILTER.SOURCE]: DebugAlert.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE])
        }; }
        /**
         * Returns a delegate-function expecting a message to log.
         */
        static createDelegate(_headline) {
            let delegate = function (_message, ..._args) {
                let args = _args.map(_arg => _arg.toString());
                let out = _headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, args);
                alert(out);
            };
            return delegate;
        }
    }
    FudgeCore.DebugAlert = DebugAlert;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Routing to a HTMLDialogElement
     */
    class DebugDialog extends FudgeCore.DebugTarget {
    }
    FudgeCore.DebugDialog = DebugDialog;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="DebugTarget.ts"/>
var FudgeCore;
// / <reference path="DebugTarget.ts"/>
(function (FudgeCore) {
    /**
     * Route to an HTMLTextArea, may be obsolete when using HTMLDialogElement
     */
    class DebugTextArea extends FudgeCore.DebugTarget {
        static { this.textArea = document.createElement("textarea"); }
        static { this.autoScroll = true; }
        static { this.delegates = {
            [FudgeCore.DEBUG_FILTER.INFO]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.INFO]),
            [FudgeCore.DEBUG_FILTER.LOG]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.LOG]),
            [FudgeCore.DEBUG_FILTER.WARN]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.WARN]),
            [FudgeCore.DEBUG_FILTER.ERROR]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.ERROR]),
            [FudgeCore.DEBUG_FILTER.FUDGE]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.FUDGE]),
            [FudgeCore.DEBUG_FILTER.CLEAR]: DebugTextArea.clear,
            [FudgeCore.DEBUG_FILTER.GROUP]: DebugTextArea.group,
            [FudgeCore.DEBUG_FILTER.GROUPCOLLAPSED]: DebugTextArea.group,
            [FudgeCore.DEBUG_FILTER.GROUPEND]: DebugTextArea.groupEnd,
            [FudgeCore.DEBUG_FILTER.SOURCE]: DebugTextArea.createDelegate(FudgeCore.DEBUG_SYMBOL[FudgeCore.DEBUG_FILTER.SOURCE])
        }; }
        static { this.groups = []; }
        /**
         * Clears the text area and the groups
         */
        static clear() {
            DebugTextArea.textArea.textContent = "";
            DebugTextArea.groups = [];
        }
        /**
         * Begins a new group with the given name
         */
        static group(_name) {
            DebugTextArea.print("‚ñº " + _name);
            DebugTextArea.groups.push(_name);
        }
        /**
         * Ends the last group
         */
        static groupEnd() {
            DebugTextArea.groups.pop();
        }
        /**
         * Returns a delegate-function expecting a message to log.
         */
        static createDelegate(_headline) {
            let delegate = function (_message, ..._args) {
                DebugTextArea.print(_headline + " " + FudgeCore.DebugTarget.mergeArguments(_message, _args));
            };
            return delegate;
        }
        static getIndentation(_level) {
            let result = "";
            for (let i = 0; i < _level; i++)
                result += "| ";
            return result;
        }
        static print(_text) {
            DebugTextArea.textArea.textContent += DebugTextArea.getIndentation(DebugTextArea.groups.length) + _text + "\n";
            if (DebugTextArea.autoScroll)
                DebugTextArea.textArea.scrollTop = DebugTextArea.textArea.scrollHeight;
        }
    }
    FudgeCore.DebugTextArea = DebugTextArea;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The codes sent from a standard english keyboard layout
     */
    let KEYBOARD_CODE;
    (function (KEYBOARD_CODE) {
        KEYBOARD_CODE["A"] = "KeyA";
        KEYBOARD_CODE["B"] = "KeyB";
        KEYBOARD_CODE["C"] = "KeyC";
        KEYBOARD_CODE["D"] = "KeyD";
        KEYBOARD_CODE["E"] = "KeyE";
        KEYBOARD_CODE["F"] = "KeyF";
        KEYBOARD_CODE["G"] = "KeyG";
        KEYBOARD_CODE["H"] = "KeyH";
        KEYBOARD_CODE["I"] = "KeyI";
        KEYBOARD_CODE["J"] = "KeyJ";
        KEYBOARD_CODE["K"] = "KeyK";
        KEYBOARD_CODE["L"] = "KeyL";
        KEYBOARD_CODE["M"] = "KeyM";
        KEYBOARD_CODE["N"] = "KeyN";
        KEYBOARD_CODE["O"] = "KeyO";
        KEYBOARD_CODE["P"] = "KeyP";
        KEYBOARD_CODE["Q"] = "KeyQ";
        KEYBOARD_CODE["R"] = "KeyR";
        KEYBOARD_CODE["S"] = "KeyS";
        KEYBOARD_CODE["T"] = "KeyT";
        KEYBOARD_CODE["U"] = "KeyU";
        KEYBOARD_CODE["V"] = "KeyV";
        KEYBOARD_CODE["W"] = "KeyW";
        KEYBOARD_CODE["X"] = "KeyX";
        KEYBOARD_CODE["Y"] = "KeyY";
        KEYBOARD_CODE["Z"] = "KeyZ";
        KEYBOARD_CODE["ESC"] = "Escape";
        KEYBOARD_CODE["ZERO"] = "Digit0";
        KEYBOARD_CODE["ONE"] = "Digit1";
        KEYBOARD_CODE["TWO"] = "Digit2";
        KEYBOARD_CODE["THREE"] = "Digit3";
        KEYBOARD_CODE["FOUR"] = "Digit4";
        KEYBOARD_CODE["FIVE"] = "Digit5";
        KEYBOARD_CODE["SIX"] = "Digit6";
        KEYBOARD_CODE["SEVEN"] = "Digit7";
        KEYBOARD_CODE["EIGHT"] = "Digit8";
        KEYBOARD_CODE["NINE"] = "Digit9";
        KEYBOARD_CODE["MINUS"] = "Minus";
        KEYBOARD_CODE["EQUAL"] = "Equal";
        KEYBOARD_CODE["BACKSPACE"] = "Backspace";
        KEYBOARD_CODE["TABULATOR"] = "Tab";
        KEYBOARD_CODE["BRACKET_LEFT"] = "BracketLeft";
        KEYBOARD_CODE["BRACKET_RIGHT"] = "BracketRight";
        KEYBOARD_CODE["ENTER"] = "Enter";
        KEYBOARD_CODE["CTRL_LEFT"] = "ControlLeft";
        KEYBOARD_CODE["SEMICOLON"] = "Semicolon";
        KEYBOARD_CODE["QUOTE"] = "Quote";
        KEYBOARD_CODE["BACK_QUOTE"] = "Backquote";
        KEYBOARD_CODE["SHIFT_LEFT"] = "ShiftLeft";
        KEYBOARD_CODE["BACKSLASH"] = "Backslash";
        KEYBOARD_CODE["COMMA"] = "Comma";
        KEYBOARD_CODE["PERIOD"] = "Period";
        KEYBOARD_CODE["SLASH"] = "Slash";
        KEYBOARD_CODE["SHIFT_RIGHT"] = "ShiftRight";
        KEYBOARD_CODE["NUMPAD_MULTIPLY"] = "NumpadMultiply";
        KEYBOARD_CODE["ALT_LEFT"] = "AltLeft";
        KEYBOARD_CODE["SPACE"] = "Space";
        KEYBOARD_CODE["CAPS_LOCK"] = "CapsLock";
        KEYBOARD_CODE["F1"] = "F1";
        KEYBOARD_CODE["F2"] = "F2";
        KEYBOARD_CODE["F3"] = "F3";
        KEYBOARD_CODE["F4"] = "F4";
        KEYBOARD_CODE["F5"] = "F5";
        KEYBOARD_CODE["F6"] = "F6";
        KEYBOARD_CODE["F7"] = "F7";
        KEYBOARD_CODE["F8"] = "F8";
        KEYBOARD_CODE["F9"] = "F9";
        KEYBOARD_CODE["F10"] = "F10";
        KEYBOARD_CODE["PAUSE"] = "Pause";
        KEYBOARD_CODE["SCROLL_LOCK"] = "ScrollLock";
        KEYBOARD_CODE["NUMPAD7"] = "Numpad7";
        KEYBOARD_CODE["NUMPAD8"] = "Numpad8";
        KEYBOARD_CODE["NUMPAD9"] = "Numpad9";
        KEYBOARD_CODE["NUMPAD_SUBTRACT"] = "NumpadSubtract";
        KEYBOARD_CODE["NUMPAD4"] = "Numpad4";
        KEYBOARD_CODE["NUMPAD5"] = "Numpad5";
        KEYBOARD_CODE["NUMPAD6"] = "Numpad6";
        KEYBOARD_CODE["NUMPAD_ADD"] = "NumpadAdd";
        KEYBOARD_CODE["NUMPAD1"] = "Numpad1";
        KEYBOARD_CODE["NUMPAD2"] = "Numpad2";
        KEYBOARD_CODE["NUMPAD3"] = "Numpad3";
        KEYBOARD_CODE["NUMPAD0"] = "Numpad0";
        KEYBOARD_CODE["NUMPAD_DECIMAL"] = "NumpadDecimal";
        KEYBOARD_CODE["PRINT_SCREEN"] = "PrintScreen";
        KEYBOARD_CODE["INTL_BACK_SLASH"] = "IntlBackSlash";
        KEYBOARD_CODE["F11"] = "F11";
        KEYBOARD_CODE["F12"] = "F12";
        KEYBOARD_CODE["NUMPAD_EQUAL"] = "NumpadEqual";
        KEYBOARD_CODE["F13"] = "F13";
        KEYBOARD_CODE["F14"] = "F14";
        KEYBOARD_CODE["F15"] = "F15";
        KEYBOARD_CODE["F16"] = "F16";
        KEYBOARD_CODE["F17"] = "F17";
        KEYBOARD_CODE["F18"] = "F18";
        KEYBOARD_CODE["F19"] = "F19";
        KEYBOARD_CODE["F20"] = "F20";
        KEYBOARD_CODE["F21"] = "F21";
        KEYBOARD_CODE["F22"] = "F22";
        KEYBOARD_CODE["F23"] = "F23";
        KEYBOARD_CODE["F24"] = "F24";
        KEYBOARD_CODE["KANA_MODE"] = "KanaMode";
        KEYBOARD_CODE["LANG2"] = "Lang2";
        KEYBOARD_CODE["LANG1"] = "Lang1";
        KEYBOARD_CODE["INTL_RO"] = "IntlRo";
        KEYBOARD_CODE["CONVERT"] = "Convert";
        KEYBOARD_CODE["NON_CONVERT"] = "NonConvert";
        KEYBOARD_CODE["INTL_YEN"] = "IntlYen";
        KEYBOARD_CODE["NUMPAD_COMMA"] = "NumpadComma";
        KEYBOARD_CODE["UNDO"] = "Undo";
        KEYBOARD_CODE["PASTE"] = "Paste";
        KEYBOARD_CODE["MEDIA_TRACK_PREVIOUS"] = "MediaTrackPrevious";
        KEYBOARD_CODE["CUT"] = "Cut";
        KEYBOARD_CODE["COPY"] = "Copy";
        KEYBOARD_CODE["MEDIA_TRACK_NEXT"] = "MediaTrackNext";
        KEYBOARD_CODE["NUMPAD_ENTER"] = "NumpadEnter";
        KEYBOARD_CODE["CTRL_RIGHT"] = "ControlRight";
        KEYBOARD_CODE["AUDIO_VOLUME_MUTE"] = "AudioVolumeMute";
        KEYBOARD_CODE["LAUNCH_APP2"] = "LaunchApp2";
        KEYBOARD_CODE["MEDIA_PLAY_PAUSE"] = "MediaPlayPause";
        KEYBOARD_CODE["MEDIA_STOP"] = "MediaStop";
        KEYBOARD_CODE["EJECT"] = "Eject";
        KEYBOARD_CODE["AUDIO_VOLUME_DOWN"] = "AudioVolumeDown";
        KEYBOARD_CODE["VOLUME_DOWN"] = "VolumeDown";
        KEYBOARD_CODE["AUDIO_VOLUME_UP"] = "AudioVolumeUp";
        KEYBOARD_CODE["VOLUME_UP"] = "VolumeUp";
        KEYBOARD_CODE["BROWSER_HOME"] = "BrowserHome";
        KEYBOARD_CODE["NUMPAD_DIVIDE"] = "NumpadDivide";
        KEYBOARD_CODE["ALT_RIGHT"] = "AltRight";
        KEYBOARD_CODE["HELP"] = "Help";
        KEYBOARD_CODE["NUM_LOCK"] = "NumLock";
        KEYBOARD_CODE["HOME"] = "Home";
        KEYBOARD_CODE["ARROW_UP"] = "ArrowUp";
        KEYBOARD_CODE["ARROW_RIGHT"] = "ArrowRight";
        KEYBOARD_CODE["ARROW_DOWN"] = "ArrowDown";
        KEYBOARD_CODE["ARROW_LEFT"] = "ArrowLeft";
        KEYBOARD_CODE["END"] = "End";
        KEYBOARD_CODE["PAGE_UP"] = "PageUp";
        KEYBOARD_CODE["PAGE_DOWN"] = "PageDown";
        KEYBOARD_CODE["INSERT"] = "Insert";
        KEYBOARD_CODE["DELETE"] = "Delete";
        KEYBOARD_CODE["META_LEFT"] = "Meta_Left";
        KEYBOARD_CODE["OS_LEFT"] = "OSLeft";
        KEYBOARD_CODE["META_RIGHT"] = "MetaRight";
        KEYBOARD_CODE["OS_RIGHT"] = "OSRight";
        KEYBOARD_CODE["CONTEXT_MENU"] = "ContextMenu";
        KEYBOARD_CODE["POWER"] = "Power";
        KEYBOARD_CODE["BROWSER_SEARCH"] = "BrowserSearch";
        KEYBOARD_CODE["BROWSER_FAVORITES"] = "BrowserFavorites";
        KEYBOARD_CODE["BROWSER_REFRESH"] = "BrowserRefresh";
        KEYBOARD_CODE["BROWSER_STOP"] = "BrowserStop";
        KEYBOARD_CODE["BROWSER_FORWARD"] = "BrowserForward";
        KEYBOARD_CODE["BROWSER_BACK"] = "BrowserBack";
        KEYBOARD_CODE["LAUNCH_APP1"] = "LaunchApp1";
        KEYBOARD_CODE["LAUNCH_MAIL"] = "LaunchMail";
        KEYBOARD_CODE["LAUNCH_MEDIA_PLAYER"] = "LaunchMediaPlayer";
        //mac brings this buttton
        KEYBOARD_CODE["FN"] = "Fn";
        //Linux brings these
        KEYBOARD_CODE["AGAIN"] = "Again";
        KEYBOARD_CODE["PROPS"] = "Props";
        KEYBOARD_CODE["SELECT"] = "Select";
        KEYBOARD_CODE["OPEN"] = "Open";
        KEYBOARD_CODE["FIND"] = "Find";
        KEYBOARD_CODE["WAKE_UP"] = "WakeUp";
        KEYBOARD_CODE["NUMPAD_PARENT_LEFT"] = "NumpadParentLeft";
        KEYBOARD_CODE["NUMPAD_PARENT_RIGHT"] = "NumpadParentRight";
        //android
        KEYBOARD_CODE["SLEEP"] = "Sleep";
    })(KEYBOARD_CODE = FudgeCore.KEYBOARD_CODE || (FudgeCore.KEYBOARD_CODE = {}));
    let KEYBOARD_CODE_DE;
    (function (KEYBOARD_CODE_DE) {
        KEYBOARD_CODE_DE["Z"] = "KeyY";
        KEYBOARD_CODE_DE["Y"] = "KeyZ";
        KEYBOARD_CODE_DE["\u00D6"] = "Semicolon";
        KEYBOARD_CODE_DE["\u00C4"] = "Quote";
        KEYBOARD_CODE_DE["\u00DC"] = "BracketLeft";
        KEYBOARD_CODE_DE["HASH"] = "Backslash";
        KEYBOARD_CODE_DE["PLUS"] = "BracketRight";
        // eslint-disable-next-line 
        KEYBOARD_CODE_DE["\u00DF"] = "Minus";
        KEYBOARD_CODE_DE["ACUTE"] = "Equal";
        KEYBOARD_CODE_DE["LESS_THAN"] = "IntlBackSlash";
        KEYBOARD_CODE_DE["MINUS"] = "Slash";
    })(KEYBOARD_CODE_DE = FudgeCore.KEYBOARD_CODE_DE || (FudgeCore.KEYBOARD_CODE_DE = {}));
    /*
    Firefox can't make use of those buttons and Combinations:
    SINGELE_BUTTONS:
     Druck,
    COMBINATIONS:
     Shift + F10, Shift + Numpad5,
     CTRL + q, CTRL + F4,
     ALT + F1, ALT + F2, ALT + F3, ALT + F7, ALT + F8, ALT + F10
    Opera won't do good with these Buttons and combinations:
    SINGLE_BUTTONS:
     Float32Array, F11, ALT,
    COMBINATIONS:
     CTRL + q, CTRL + t, CTRL + h, CTRL + g, CTRL + n, CTRL + f
     ALT + F1, ALT + F2, ALT + F4, ALT + F5, ALT + F6, ALT + F7, ALT + F8, ALT + F10
     */
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * An event that represents a call from a {@link Timer}
     */
    class EventTimer {
        constructor(_timer, ..._arguments) {
            this.type = "\u0192lapse" /* EVENT_TIMER.CALL */;
            this.firstCall = true;
            this.lastCall = false;
            this.target = _timer;
            this.arguments = _arguments;
            this.firstCall = true;
        }
    }
    FudgeCore.EventTimer = EventTimer;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Custom touch events
     */
    let EVENT_TOUCH;
    (function (EVENT_TOUCH) {
        /** custom event fired in addition to the standard touchmove, details offset to starting touch */
        EVENT_TOUCH["MOVE"] = "touchMove";
        /** custom event fired when the touches haven't moved outside of the tap radius */
        EVENT_TOUCH["TAP"] = "touchTap";
        /** custom event fired when the touches have moved outside of the notch radius, details offset and cardinal direction */
        EVENT_TOUCH["NOTCH"] = "touchNotch";
        /** custom event fired when the touches haven't moved outside of the tap radius for some time */
        EVENT_TOUCH["LONG"] = "touchLong";
        /** custom event fired when two taps were detected in short succession */
        EVENT_TOUCH["DOUBLE"] = "touchDouble";
        /** custom event fired when the distance between the only two touches changes beyond a tolerance */
        EVENT_TOUCH["PINCH"] = "touchPinch";
        /** custom event not implemented yet */
        EVENT_TOUCH["ROTATE"] = "touchRotate";
    })(EVENT_TOUCH = FudgeCore.EVENT_TOUCH || (FudgeCore.EVENT_TOUCH = {}));
    /**
     * Dispatches CustomTouchEvents to the EventTarget given with the constructor.
     * When using touch events, make sure to set `touch-action: none` in CSS
     * @author Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class TouchEventDispatcher {
        constructor(_target, _radiusTap = 5, _radiusNotch = 50, _timeDouble = 200, _timerLong = 1000) {
            this.posStart = FudgeCore.Vector2.ZERO();
            this.posNotch = FudgeCore.Vector2.ZERO();
            this.posPrev = FudgeCore.Vector2.ZERO();
            this.moved = false;
            this.time = new FudgeCore.Time();
            this.pinchDistance = 0;
            this.pinchTolerance = 1;
            this.hndEvent = (_event) => {
                _event.preventDefault();
                let touchFirst = _event.touches[0];
                let position = this.calcAveragePosition(_event.touches); //new Vector2(touchFirst?.clientX, touchFirst?.clientY);
                let offset;
                switch (_event.type) {
                    case "touchstart":
                        this.moved = false;
                        this.startGesture(position);
                        if (_event.touches.length == 2) {
                            // reset pinch
                            let pinch = new FudgeCore.Vector2(_event.touches[1].clientX - touchFirst.clientX, _event.touches[1].clientY - touchFirst.clientY);
                            this.pinchDistance = pinch.magnitude;
                        }
                        let dispatchLong = (_eventTimer) => {
                            this.moved = true;
                            this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.LONG, {
                                bubbles: true, detail: { position: position, touches: _event.touches }
                            }));
                        };
                        this.timerLong?.clear();
                        this.timerLong = new FudgeCore.Timer(this.time, this.timeLong, 1, dispatchLong);
                        break;
                    case "touchend":
                        this.timerLong?.clear();
                        if (_event.touches.length > 0) {
                            // still touches active
                            this.startGesture(position);
                            break;
                        }
                        let dispatchTap = (_eventTimer) => {
                            this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.TAP, {
                                bubbles: true, detail: { position: position, touches: _event.touches }
                            }));
                        };
                        // check if there was a tap before and timer is still running -> double tap
                        if (this.timerDouble?.active) {
                            this.timerDouble.clear();
                            // this.timer = undefined;
                            this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.DOUBLE, {
                                bubbles: true, detail: { position: position, touches: _event.touches }
                            }));
                        }
                        else if (!this.moved)
                            // check if there was movement, otherwise set timer to fire tap
                            this.timerDouble = new FudgeCore.Timer(this.time, this.timeDouble, 1, dispatchTap);
                        break;
                    case "touchmove":
                        this.detectPinch(_event, position);
                        offset = FudgeCore.Vector2.DIFFERENCE(this.posPrev, this.posStart);
                        this.moved ||= (offset.magnitude < this.radiusTap); // remember that touch moved over tap radius
                        let movement = FudgeCore.Vector2.DIFFERENCE(position, this.posPrev);
                        this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.MOVE, {
                            bubbles: true, detail: { position: position, touches: _event.touches, offset: offset, movement: movement }
                        }));
                        // fire notch when touches moved out of notch radius and reset notch
                        offset = FudgeCore.Vector2.DIFFERENCE(position, this.posNotch);
                        if (offset.magnitude > this.radiusNotch) {
                            let cardinal = Math.abs(offset.x) > Math.abs(offset.y) ?
                                FudgeCore.Vector2.X(offset.x < 0 ? -1 : 1) :
                                FudgeCore.Vector2.Y(offset.y < 0 ? -1 : 1);
                            this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.NOTCH, {
                                bubbles: true, detail: { position: position, touches: _event.touches, offset: offset, cardinal: cardinal, movement: movement }
                            }));
                            this.posNotch = position;
                        }
                        //TODO: pinch, rotate...
                        break;
                    default:
                        break;
                }
                this.posPrev.set(position.x, position.y);
            };
            this.detectPinch = (_event, _position) => {
                if (_event.touches.length != 2)
                    return;
                let t = _event.touches;
                let pinch = new FudgeCore.Vector2(t[1].clientX - t[0].clientX, t[1].clientY - t[0].clientY);
                let pinchDistance = pinch.magnitude;
                let pinchDelta = pinchDistance - this.pinchDistance;
                if (Math.abs(pinchDelta) > this.pinchTolerance)
                    this.target.dispatchEvent(new CustomEvent(EVENT_TOUCH.PINCH, {
                        bubbles: true, detail: { position: _position, touches: _event.touches, pinch: pinch, pinchDelta: pinchDelta }
                    }));
                this.pinchDistance = pinchDistance;
            };
            this.target = _target;
            this.radiusTap = _radiusTap;
            this.radiusNotch = _radiusNotch;
            this.timeDouble = _timeDouble;
            this.timeLong = _timerLong;
            this.activate(true);
        }
        /**
         * De-/Activates the dispatch of CustomTouchEvents
         */
        activate(_on) {
            if (_on) {
                this.target.addEventListener("touchstart", this.hndEvent);
                this.target.addEventListener("touchend", this.hndEvent);
                this.target.addEventListener("touchmove", this.hndEvent);
                return;
            }
            this.target.removeEventListener("touchstart", this.hndEvent);
            this.target.removeEventListener("touchend", this.hndEvent);
            this.target.removeEventListener("touchmove", this.hndEvent);
        }
        startGesture(_position) {
            this.posNotch.set(_position.x, _position.y);
            this.posStart.set(_position.x, _position.y);
        }
        calcAveragePosition(_touches) {
            let average = FudgeCore.Vector2.ZERO();
            for (let touch of _touches) {
                average.x += touch.clientX;
                average.y += touch.clientY;
            }
            average.scale(1 / _touches.length);
            return average;
        }
    }
    FudgeCore.TouchEventDispatcher = TouchEventDispatcher;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A node managed by {@link Project} that functions as a template for {@link GraphInstance}s
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Resource
     */
    let Graph = (() => {
        var _a;
        let _classDecorators = [(_a = FudgeCore.SerializableResource).register.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.Node;
        var Graph = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                Graph = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(_classThis, _classExtraInitializers);
            }
            // #syncing: boolean = false;
            constructor(_name = "Graph") {
                super(_name);
                this.idResource = undefined;
                this.hndMutate = async (_event) => {
                    // TODO: if path contains a graph instance below this, don't dispatch!
                    // let path: Node[] = Reflect.get(_event, "path");
                    // for (let node of path)
                    //   if (node instanceof GraphInstance && node.idSource != this.idResource)
                    //     return;
                    // console.log("Graph mutates", this.name);
                    // this.#syncing = true;
                    _event.detail.path = Reflect.get(_event, "path"); // save path to target in detail
                    this.dispatchEvent(new CustomEvent("mutateGraph" /* EVENT.MUTATE_GRAPH */, { detail: _event.detail }));
                    this.dispatchEvent(new CustomEvent("graphMutated" /* EVENT.GRAPH_MUTATED */, { detail: _event.detail }));
                    // this.dispatchEvent(new Event(EVENT.MUTATE_INSTANCE));
                    // this.#syncing = false;
                };
                this.addEventListener("mutate" /* EVENT.MUTATE */, this.hndMutate);
            }
            get type() {
                return this.constructor.name;
            }
            serialize() {
                let serialization = super.serialize();
                serialization.idResource = this.idResource;
                serialization.type = this.type;
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization);
                FudgeCore.Project.register(this, _serialization.idResource);
                await FudgeCore.Project.resyncGraphInstances(this);
                this.broadcastEvent(new Event("graphDeserialized" /* EVENT.GRAPH_DESERIALIZED */));
                FudgeCore.Debug.log("Deserialized", this.name);
                return this;
            }
        };
        return Graph = _classThis;
    })();
    FudgeCore.Graph = Graph;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Graph} loaded from a glTF-File.
     * @authors Jonas Plotzky, HFU, 2024
     */
    class GraphGLTF extends FudgeCore.mixinSerializableResourceExternal(FudgeCore.Graph) {
        async load(_url = this.url, _name = this.name) {
            this.url = _url;
            this.name = _name;
            return FudgeCore.GLTFLoader.loadResource(this);
        }
        serialize() {
            const serializationExternal = super.serialize();
            const serializationNode = FudgeCore.Node.prototype.serialize.call(this); // this is wasteful as we only need the components deserialized
            delete serializationNode.components[FudgeCore.ComponentSkeleton.name];
            delete serializationNode.children;
            return { ...serializationNode, ...serializationExternal };
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            await FudgeCore.Graph.prototype.deserialize.call(this, _serialization);
            return this;
        }
    }
    FudgeCore.GraphGLTF = GraphGLTF;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // enum SYNC {
    //   READY, GRAPH_SYNCED, GRAPH_DONE, INSTANCE
    // }
    /**
     * An instance of a {@link Graph}.
     * This node keeps a reference to its resource an can thus optimize serialization
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Resource
     */
    class GraphInstance extends FudgeCore.Node {
        /** id of the resource that instance was created from */
        // TODO: examine, if this should be a direct reference to the Graph, instead of the id
        static { this.count = 0; }
        #idSource;
        // #sync: SYNC = SYNC.READY;
        #deserializeFromSource;
        /**
         * This constructor alone will not create a reconstruction, but only save the id.
         * To create an instance of the graph, call reset on this or set with a graph as parameter.
         * Prefer Project.createGraphInstance(_graph).
         */
        constructor(_graph) {
            super("GraphInstance");
            this.#idSource = undefined;
            // #sync: SYNC = SYNC.READY;
            this.#deserializeFromSource = true;
            /**
             * Source graph mutated, reflect mutation in this instance
             */
            this.hndMutationGraph = async (_event) => {
                if (this.isFiltered())
                    return;
                await this.reflectMutation(_event, _event.currentTarget, this, _event.detail.path);
                this.dispatchEvent(new Event("mutateGraphDone" /* EVENT.MUTATE_INSTANCE */, { bubbles: true }));
            };
            /**
             * This instance mutated, reflect mutation in source graph
             */
            this.hndMutationInstance = async (_event) => {
                if (this.isFiltered())
                    return;
                await this.reflectMutation(_event, this, this.get(), Reflect.get(_event, "path"));
                this.get().dispatchEvent(new CustomEvent("mutate" /* EVENT.MUTATE */, { detail: _event.detail }));
            };
            this.addEventListener("mutate" /* EVENT.MUTATE */, this.hndMutationInstance);
            if (!_graph)
                return;
            this.#idSource = _graph.idResource;
        }
        get idSource() {
            return this.#idSource;
        }
        /**
         * Recreate this node from the {@link Graph} referenced
         */
        async reset() {
            let resource = await FudgeCore.Project.getResource(this.#idSource);
            await this.set(resource);
        }
        //TODO: optimize using the referenced Graph, serialize/deserialize only the differences
        serialize() {
            let filter = this.getComponent(FudgeCore.ComponentGraphFilter);
            let serialization = {};
            if (filter && filter.isActive) { // if graph synchronisation is unfiltered, knowing the source is sufficient for serialization
                serialization = super.serialize();
                let graph = this.get();
                if (graph instanceof FudgeCore.GraphGLTF) { // like for the GraphGLTF: children and components loaded from gltf must never be serialized
                    delete serialization.components[FudgeCore.ComponentSkeleton.name];
                    delete serialization.children;
                    serialization.url = graph.url;
                }
            }
            else {
                serialization.deserializeFromSource = true;
            }
            serialization.idSource = this.#idSource;
            return serialization;
        }
        async deserialize(_serialization) {
            this.#idSource = _serialization.idSource ?? _serialization.idResource;
            if (!_serialization.deserializeFromSource) {
                let graph = await FudgeCore.Project.getResource(this.#idSource);
                if (graph instanceof FudgeCore.GraphGLTF)
                    await FudgeCore.GLTFLoader.loadResource(this, _serialization.url);
                await super.deserialize(_serialization); // instance is deserialized from individual data
                this.#deserializeFromSource = false;
            }
            let graph = this.get();
            if (graph)
                await this.connectToGraph(); // otherwise just connect
            else {
                FudgeCore.Debug.log("Register for resync", _serialization.name, this.name);
                FudgeCore.Project.registerGraphInstanceForResync(this);
            }
            return this;
        }
        /**
         * Connects this graph instance to the graph referenced.
         */
        async connectToGraph() {
            let graph = this.get();
            if (this.#deserializeFromSource)
                await this.set(graph);
        }
        /**
         * Set this node to be a recreation of the {@link Graph} given
         */
        async set(_graph) {
            this.#idSource = _graph.idResource;
            let currentGraph = this.get();
            if (currentGraph) {
                currentGraph.removeEventListener("mutateGraph" /* EVENT.MUTATE_GRAPH */, this.hndMutationGraph);
            }
            // TODO: examine, if the serialization should be stored in the Graph for optimization <- also useful for sync with instances
            let serialization = FudgeCore.Serializer.serialize(_graph);
            for (let path in serialization) {
                await this.deserialize(serialization[path]);
                break;
            }
            FudgeCore.Debug.fudge("GraphInstance set to " + this.name + " | " + "Instance count: " + GraphInstance.count++);
            _graph.addEventListener("mutateGraph" /* EVENT.MUTATE_GRAPH */, this.hndMutationGraph);
            this.broadcastEvent(new Event("graphInstantiated" /* EVENT.GRAPH_INSTANTIATED */));
        }
        /**
         * Retrieve the graph this instances refers to
         */
        get() {
            return FudgeCore.Project.resources[this.#idSource];
        }
        // reflect mutation from a source graph or instance to a destination instance or graph
        async reflectMutation(_event, _source, _destination, _path) {
            for (let node of _path) // iterate up the event path, which may contain regular Nodes or GraphInstances
                if (node instanceof GraphInstance) // until this GraphInstance is found (or no GraphInstance...)
                    if (node == this)
                        break;
                    else {
                        console.log("Sync aborted, target already synced");
                        return;
                    }
            // find the corresponding node in the destination hierarchy
            let index = _path.indexOf(_source);
            for (let i = index - 1; i >= 0; i--) {
                let childIndex = _path[i].getParent().findChild(_path[i]); // get the index of the childnode in the original path
                _destination = _destination.getChild(childIndex); // get the corresponding child in this path
                // TODO: respect index for non-singleton components...
            }
            // mutate the corresponding component in the destination
            let cmpMutate = _destination.getComponent(_event.detail.component.constructor);
            if (cmpMutate)
                await cmpMutate.mutate(_event.detail.mutator, null, false);
        }
        isFiltered() {
            let cmpFilter = this.getComponent(FudgeCore.ComponentGraphFilter);
            return (cmpFilter && cmpFilter.isActive);
        }
    }
    FudgeCore.GraphInstance = GraphInstance;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Holds data to feed into a {@link Shader} to describe the surface of {@link Mesh}.
     * {@link Material}s reference {@link Coat} and {@link Shader}.
     * The method useRenderData will be injected by {@link RenderInjector} at runtime, extending the functionality of this class to deal with the renderer.
     */
    let Coat = (() => {
        var _a, _b, _c, _d;
        let _classSuper = FudgeCore.Mutable;
        let _staticExtraInitializers = [];
        let _static_resetRenderData_decorators;
        let _static_updateRenderbuffer_decorators;
        let _static_updateRenderData_decorators;
        let _static_useRenderData_decorators;
        return class Coat extends _classSuper {
            constructor() {
                super(...arguments);
                // public name: string = "Coat";
                /**
                 * Clipping threshold for alpha values, every pixel with alpha < alphaClip will be discarded.
                 */
                this.alphaClip = 0.01;
                //#endregion
            }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _static_resetRenderData_decorators = [(_a = FudgeCore.RenderManagerCoat).decorate.bind(_a)];
                _static_updateRenderbuffer_decorators = [(_b = FudgeCore.RenderManagerCoat).decorate.bind(_b)];
                _static_updateRenderData_decorators = [(_c = FudgeCore.RenderManagerCoat).decorate.bind(_c)];
                _static_useRenderData_decorators = [(_d = FudgeCore.RenderManagerCoat).decorate.bind(_d)];
                __esDecorate(this, null, _static_resetRenderData_decorators, { kind: "method", name: "resetRenderData", static: true, private: false, access: { has: obj => "resetRenderData" in obj, get: obj => obj.resetRenderData }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(this, null, _static_updateRenderbuffer_decorators, { kind: "method", name: "updateRenderbuffer", static: true, private: false, access: { has: obj => "updateRenderbuffer" in obj, get: obj => obj.updateRenderbuffer }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(this, null, _static_updateRenderData_decorators, { kind: "method", name: "updateRenderData", static: true, private: false, access: { has: obj => "updateRenderData" in obj, get: obj => obj.updateRenderData }, metadata: _metadata }, null, _staticExtraInitializers);
                __esDecorate(this, null, _static_useRenderData_decorators, { kind: "method", name: "useRenderData", static: true, private: false, access: { has: obj => "useRenderData" in obj, get: obj => obj.useRenderData }, metadata: _metadata }, null, _staticExtraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(this, _staticExtraInitializers);
            }
            /** @internal reroute to {@link RenderManagerCoat.resetRenderData} */
            static resetRenderData() { }
            ;
            /** @internal reroute to {@link RenderManagerCoat.updateRenderbuffer} */
            static updateRenderbuffer() { }
            ;
            /** @internal reroute to {@link RenderManagerCoat.updateRenderData} */
            static updateRenderData(_coat) { }
            ;
            /** @internal reroute to {@link RenderManagerCoat.useRenderData} */
            static useRenderData(_coat) { }
            ;
            /** Called by the render system during {@link Render.prepare}. Override this to provide the render system with additional render data. */
            updateRenderData() {
                Coat.updateRenderData(this);
            }
            ;
            /** Called by the render system during {@link Render.draw}. Override this to provide the render system with additional render data. */
            useRenderData() {
                Coat.useRenderData(this);
            }
            ;
            //#region Transfer
            serialize() {
                return {
                    alphaClip: this.alphaClip
                };
            }
            async deserialize(_serialization) {
                if (_serialization.alphaClip !== undefined)
                    this.alphaClip = _serialization.alphaClip;
                return this;
            }
            reduceMutator(_mutator) {
                delete _mutator.renderData;
            }
        };
    })();
    FudgeCore.Coat = Coat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The simplest {@link Coat} providing just a color
     */
    class CoatColored extends FudgeCore.Coat {
        constructor(_color = new FudgeCore.Color()) {
            super();
            this.color = _color;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.color = this.color.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            await this.color.deserialize(_serialization.color);
            return this;
        }
    }
    FudgeCore.CoatColored = CoatColored;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a color and parameters for the phong shading model.
     */
    class CoatRemissive extends FudgeCore.CoatColored {
        #metallic;
        constructor(_color = new FudgeCore.Color(), _diffuse = 1, _specular = 0.5, _intensity = 0.7, _metallic = 0.0) {
            super(_color);
            this.diffuse = _diffuse;
            this.specular = _specular;
            this.intensity = _intensity;
            this.metallic = _metallic;
        }
        get metallic() {
            return this.#metallic;
        }
        set metallic(_value) {
            this.#metallic = FudgeCore.Calc.clamp(_value, 0, 1);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.diffuse = this.diffuse;
            serialization.specular = this.specular;
            serialization.intensity = this.intensity;
            serialization.metallic = this.metallic;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.diffuse = _serialization.diffuse;
            this.specular = _serialization.specular;
            this.intensity = _serialization.intensity ?? this.intensity;
            this.metallic = _serialization.metallic ?? this.metallic;
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            delete mutator.diffuse;
            delete mutator.specular;
            delete mutator.intensity;
            mutator.diffuse = this.diffuse;
            mutator.specular = this.specular;
            mutator.intensity = this.intensity;
            mutator.metallic = this.metallic;
            return mutator;
        }
    }
    FudgeCore.CoatRemissive = CoatRemissive;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a texture and additional data for texturing
     */
    let CoatTextured = (() => {
        let _classSuper = FudgeCore.CoatColored;
        let _texture_decorators;
        let _texture_initializers = [];
        let _texture_extraInitializers = [];
        return class CoatTextured extends _classSuper {
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _texture_decorators = [FudgeCore.type(FudgeCore.Texture)];
                __esDecorate(null, null, _texture_decorators, { kind: "field", name: "texture", static: false, private: false, access: { has: obj => "texture" in obj, get: obj => obj.texture, set: (obj, value) => { obj.texture = value; } }, metadata: _metadata }, _texture_initializers, _texture_extraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            constructor(_color = new FudgeCore.Color(), _texture = FudgeCore.TextureDefault.color) {
                super(_color);
                this.texture = __runInitializers(this, _texture_initializers, void 0);
                __runInitializers(this, _texture_extraInitializers);
                this.texture = _texture;
            }
            //#region Transfer
            serialize() {
                let serialization = super.serialize();
                serialization.idTexture = this.texture.idResource;
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization);
                if (_serialization.idTexture)
                    this.texture = await FudgeCore.Project.getResource(_serialization.idTexture);
                return this;
            }
        };
    })();
    FudgeCore.CoatTextured = CoatTextured;
})(FudgeCore || (FudgeCore = {}));
///<reference path="CoatTextured.ts"/>
var FudgeCore;
///<reference path="CoatTextured.ts"/>
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a texture and additional data for texturing
     */
    class CoatRemissiveTextured extends FudgeCore.CoatTextured {
        #metallic;
        constructor(_color = new FudgeCore.Color(), _texture = FudgeCore.TextureDefault.color, _diffuse = 1, _specular = 0.5, _intensity = 0.7, _metallic = 0.0) {
            super(_color, _texture);
            this.diffuse = _diffuse;
            this.specular = _specular;
            this.intensity = _intensity;
            this.metallic = _metallic;
        }
        get metallic() {
            return this.#metallic;
        }
        set metallic(_value) {
            this.#metallic = FudgeCore.Calc.clamp(_value, 0, 1);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.diffuse = this.diffuse;
            serialization.specular = this.specular;
            serialization.intensity = this.intensity;
            serialization.metallic = this.metallic;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.diffuse = _serialization.diffuse;
            this.specular = _serialization.specular;
            this.intensity = _serialization.intensity ?? this.intensity;
            this.metallic = _serialization.metallic ?? this.metallic;
            return this;
        }
        getMutator() {
            let mutator = super.getMutator(true);
            delete mutator.diffuse;
            delete mutator.specular;
            delete mutator.intensity;
            mutator.diffuse = this.diffuse;
            mutator.specular = this.specular;
            mutator.intensity = this.intensity;
            mutator.metallic = this.metallic;
            return mutator;
        }
    }
    FudgeCore.CoatRemissiveTextured = CoatRemissiveTextured;
})(FudgeCore || (FudgeCore = {}));
///<reference path="CoatTextured.ts"/>
var FudgeCore;
///<reference path="CoatTextured.ts"/>
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a texture and additional data for texturing
     */
    let CoatRemissiveTexturedNormals = (() => {
        let _classSuper = FudgeCore.CoatRemissiveTextured;
        let _normalMap_decorators;
        let _normalMap_initializers = [];
        let _normalMap_extraInitializers = [];
        return class CoatRemissiveTexturedNormals extends _classSuper {
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _normalMap_decorators = [FudgeCore.type(FudgeCore.Texture)];
                __esDecorate(null, null, _normalMap_decorators, { kind: "field", name: "normalMap", static: false, private: false, access: { has: obj => "normalMap" in obj, get: obj => obj.normalMap, set: (obj, value) => { obj.normalMap = value; } }, metadata: _metadata }, _normalMap_initializers, _normalMap_extraInitializers);
                if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            constructor(_color = new FudgeCore.Color(), _texture = FudgeCore.TextureDefault.color, _normalMap = FudgeCore.TextureDefault.normal, _diffuse, _specular = undefined, _intensity = undefined, _metallic = undefined) {
                super(_color, _texture, _diffuse, _specular, _intensity, _metallic);
                this.normalMap = __runInitializers(this, _normalMap_initializers, void 0);
                __runInitializers(this, _normalMap_extraInitializers);
                this.normalMap = _normalMap;
            }
            //#region Transfer
            serialize() {
                let serialization = super.serialize();
                serialization.idNormalMap = this.normalMap.idResource;
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization);
                if (_serialization.idNormalMap)
                    this.normalMap = await FudgeCore.Project.getResource(_serialization.idNormalMap);
                return this;
            }
        };
    })();
    FudgeCore.CoatRemissiveTexturedNormals = CoatRemissiveTexturedNormals;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Coat} providing a color and parameters for the toon shading model.
     */
    class CoatToon extends mixinCoatToon(FudgeCore.CoatRemissive) {
        constructor(_color = new FudgeCore.Color(), _texToon = FudgeCore.TextureDefault.toon, _diffuse, _specular = 1.2, _intensity, _metallic) {
            super(_color, _diffuse, _specular, _intensity, _metallic);
            this.texToon = _texToon;
        }
    }
    FudgeCore.CoatToon = CoatToon;
    /**
     * A {@link Coat} providing a texture, a color and parameters for the toon shading model.
     */
    class CoatToonTextured extends mixinCoatToon(FudgeCore.CoatRemissiveTextured) {
        constructor(_color = new FudgeCore.Color(), _texture = FudgeCore.TextureDefault.color, _texToon = FudgeCore.TextureDefault.toon, _diffuse, _specular = 1.2, _intensity, _metallic) {
            super(_color, _texture, _diffuse, _specular, _intensity, _metallic);
            this.texToon = _texToon;
        }
    }
    FudgeCore.CoatToonTextured = CoatToonTextured;
    function mixinCoatToon(_base) {
        let CoatToon = (() => {
            let _classSuper = _base;
            let _texToon_decorators;
            let _texToon_initializers = [];
            let _texToon_extraInitializers = [];
            return class CoatToon extends _classSuper {
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    _texToon_decorators = [FudgeCore.type(FudgeCore.Texture)];
                    __esDecorate(null, null, _texToon_decorators, { kind: "field", name: "texToon", static: false, private: false, access: { has: obj => "texToon" in obj, get: obj => obj.texToon, set: (obj, value) => { obj.texToon = value; } }, metadata: _metadata }, _texToon_initializers, _texToon_extraInitializers);
                    if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                }
                serialize() {
                    let serialization = super.serialize();
                    serialization.idTexToon = this.texToon.idResource;
                    return serialization;
                }
                async deserialize(_serialization) {
                    await super.deserialize(_serialization);
                    if (_serialization.idTexToon)
                        this.texToon = await FudgeCore.Project.getResource(_serialization.idTexToon);
                    return this;
                }
                constructor() {
                    super(...arguments);
                    this.texToon = __runInitializers(this, _texToon_initializers, void 0);
                    __runInitializers(this, _texToon_extraInitializers);
                }
            };
        })();
        return CoatToon;
    }
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines a color as values in the range of 0 to 1 for the four channels red, green, blue and alpha (for opacity)
     */
    class Color extends FudgeCore.Mutable {
        // crc2 only used for converting colors from strings predefined by CSS
        static { this.crc2 = (() => {
            const canvas = document.createElement("canvas");
            canvas.width = 1;
            canvas.height = 1;
            const crc2 = canvas.getContext("2d", { willReadFrequently: true });
            crc2.globalCompositeOperation = "copy";
            return crc2;
        })(); }
        constructor(_r = 1, _g = 1, _b = 1, _a = 1) {
            super();
            this.set(_r, _g, _b, _a);
        }
        /**
         * Converts the given HSL values to RGB and returns the result in the given object.
         * @param _hue Hue as an angle in degrees in range [0, 360].
         * @param _saturation Saturation in range [0, 1]
         * @param _lightness Lightness in range [0, 1]
         * @param _out Optional color to store the result in.
         * @returns The RGB values in range [0, 1].
         * @source https://www.w3.org/TR/css-color-4/#hsl-to-rgb
         */
        static hsl2rgb(_hue, _saturation, _lightness, _out) {
            _hue = _hue % 360;
            if (_hue < 0)
                _hue += 360;
            _out.r = Color.#f(0, _hue, _saturation, _lightness);
            _out.g = Color.#f(8, _hue, _saturation, _lightness);
            _out.b = Color.#f(4, _hue, _saturation, _lightness);
            return _out;
        }
        /**
         * @param _red Red value  [0, 1]
         * @param _green Green component [0, 1]
         * @param _blue Blue component [0, 1]
         * @param _out Optional color to store the result in.
         * @returns The HSL values. Hue as an angle in degrees in range [0, 360]. Saturation and lightness in range [0, 1].
         * @source https://www.w3.org/TR/css-color-4/#rgb-to-hsl
         */
        static rgb2hsl(_red, _green, _blue, _out) {
            let max = Math.max(_red, _green, _blue);
            let min = Math.min(_red, _green, _blue);
            let hue = NaN;
            let saturation = 0;
            let lightness = (min + max) / 2;
            let d = max - min;
            if (d !== 0) {
                saturation = (lightness === 0 || lightness === 1)
                    ? 0
                    : (max - lightness) / Math.min(lightness, 1 - lightness);
                switch (max) {
                    case _red:
                        hue = (_green - _blue) / d + (_green < _blue ? 6 : 0);
                        break;
                    case _green:
                        hue = (_blue - _red) / d + 2;
                        break;
                    case _blue: hue = (_red - _green) / d + 4;
                }
                hue = hue * 60;
            }
            if (saturation < 0) {
                hue += 180;
                saturation = Math.abs(saturation);
            }
            if (hue >= 360)
                hue -= 360;
            _out.h = hue;
            _out.s = saturation;
            _out.l = lightness;
            return _out;
        }
        /**
         * Returns a new {@link Color} object created from the given css color keyword.
         * Passing an _alpha value will override the alpha value specified in the keyword.
         * Supported color formats are:
         * - named colors (e.g. "red", "blue", "green")
         * - hex colors (e.g. "#f00" "#ff0000", "#ff0000ff")
         * - srgb colors (e.g. "rgb(255 0 0 / 1)", "rgb(255, 0, 0)", "rgba(0, 0, 255, 1))
         * - hsl colors (e.g. "hsl(90deg 100% 50% / 1)", "hsl(90, 100%, 50%)", hsla(90, 100%, 50%, 1))
         *
         * **Note:** If possibile try to avoid invoking this method frequently, as it might cause major garbage collection depending on the keyword and browser.
         * @param _out Optional color to store the result in.
         */
        static CSS(_keyword, _alpha, _out = FudgeCore.Recycler.reuse(Color)) {
            Color.crc2.fillStyle = _keyword; // THIS still causes major garbage collection depending on the keyword (tested in Chrome)
            const value = Color.crc2.fillStyle;
            if (value.startsWith("#")) { // value = "#rrggbb"
                return _out.set(parseInt(value.slice(1, 3), 16) / 255, parseInt(value.slice(3, 5), 16) / 255, parseInt(value.slice(5, 7), 16) / 255, _alpha ?? 1);
            }
            if (value.startsWith("rgba")) { // value = "rgba(r, g, b, a)""
                const iOpenParenthesis = value.indexOf("(");
                const iComma0 = value.indexOf(",", iOpenParenthesis);
                const iComma1 = value.indexOf(",", iComma0 + 1);
                const iComma2 = value.indexOf(",", iComma1 + 1);
                const iCloseParenthesis = value.indexOf(")", iOpenParenthesis);
                return _out.set(parseFloat(value.slice(iOpenParenthesis + 1, iComma0)) / 255, parseFloat(value.slice(iComma0 + 2, iComma1)) / 255, parseFloat(value.slice(iComma1 + 2, iComma2)) / 255, _alpha ?? parseFloat(value.slice(iComma2 + 2, iCloseParenthesis)));
            }
            if (value.startsWith("color(srgb")) { // value = "color(srgb r g b / a)"
                const iOpenParenthesis = value.indexOf("(");
                const iSpace0 = value.indexOf(" ", iOpenParenthesis);
                const iSpace1 = value.indexOf(" ", iSpace0 + 1);
                const iSpace2 = value.indexOf(" ", iSpace1 + 1);
                const iSpace3 = value.indexOf(" ", iSpace2 + 1);
                const iCloseParenthesis = value.indexOf(")", iOpenParenthesis);
                const hasAlpha = iSpace3 != -1;
                return _out.set(parseFloat(value.slice(iSpace0 + 1, iSpace1)), parseFloat(value.slice(iSpace1 + 1, iSpace2)), parseFloat(value.slice(iSpace2 + 1, hasAlpha ? iSpace3 : iCloseParenthesis)), _alpha ?? (hasAlpha ? parseFloat(value.slice(iSpace3 + 3, iCloseParenthesis)) : 1));
            }
            throw new Error(`${Color.name}.${Color.CSS.name}: Unrecognized color format: "${_keyword}"`);
            // Color.crc2.fillRect(0, 0, 1, 1);
            // let data: Uint8ClampedArray = Color.crc2.getImageData(0, 0, 1, 1).data;
            // return _out.set(
            //   data[0] / 255,
            //   data[1] / 255,
            //   data[2] / 255,
            //   _alpha ?? data[3] / 255
            // );
        }
        /**
         * Computes and returns the sum of two colors.
         * @param _out Optional color to store the result in.
         */
        static SUM(_clrA, _clrB, _out = FudgeCore.Recycler.reuse(Color)) {
            return _out.set(_clrA.r + _clrB.r, _clrA.g + _clrB.g, _clrA.b + _clrB.b, _clrA.a + _clrB.a);
        }
        /**
         * Computes and returns the sum of two colors.
         * @param _out Optional color to store the result in.
         */
        static DIFFERENCE(_clrA, _clrB, _out = FudgeCore.Recycler.reuse(Color)) {
            return _out.set(Math.max(0, _clrA.r - _clrB.r), Math.max(0, _clrA.g - _clrB.g), Math.max(0, _clrA.b - _clrB.b), Math.max(0, _clrA.a - _clrB.a));
        }
        /**
         * Computes and returns the product of two colors.
         * @param _out Optional color to store the result in.
         */
        static PRODUCT(_clrA, _clrB, _out = FudgeCore.Recycler.reuse(Color)) {
            return _out.set(_clrA.r * _clrB.r, _clrA.g * _clrB.g, _clrA.b * _clrB.b, _clrA.a * _clrB.a);
        }
        /**
         * Returns a new color representing the given color scaled by the given scaling factor.
         * @param _out Optional color to store the result in.
         */
        static SCALE(_vector, _scaling, _out = FudgeCore.Recycler.reuse(Color)) {
            return _out.set(_vector.r * _scaling, _vector.g * _scaling, _vector.b * _scaling, _vector.a * _scaling);
        }
        static #f(_n, _hue, _saturation, _light) {
            let k = (_n + _hue / 30) % 12;
            let a = _saturation * Math.min(_light, 1 - _light);
            return _light - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));
        }
        /**
         * Creates and returns a clone of this color.
         */
        get clone() {
            return FudgeCore.Recycler.reuse(Color).copy(this);
        }
        /**
         * Copies the color channels of the given color into this color and returns it.
         * @returns A reference to this color.
         */
        copy(_color) {
            this.r = _color.r;
            this.g = _color.g;
            this.b = _color.b;
            this.a = _color.a;
            return this;
        }
        /**
         * Sets the color channels of this color.
         * @returns A reference to this color.
         */
        set(_r, _g, _b, _a) {
            this.r = _r;
            this.g = _g;
            this.b = _b;
            this.a = _a;
            return this;
        }
        recycle() {
            this.r = 1;
            this.g = 1;
            this.b = 1;
            this.a = 1;
        }
        /**
         * Returns true if this vector is equal to the given vector within the given tolerance.
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            return Math.abs(this.r - _compare.r) <= _tolerance &&
                Math.abs(this.g - _compare.g) <= _tolerance &&
                Math.abs(this.b - _compare.b) <= _tolerance &&
                Math.abs(this.a - _compare.a) <= _tolerance;
        }
        /**
         * Sets this color from the given css color keyword. Optinally sets the alpha value to the given value.
         * @returns A reference to this color.
         */
        setCSS(_keyword, _alpha) {
            return Color.CSS(_keyword, _alpha ?? this.a, this);
        }
        /**
         * Sets the color channels of this color and clamps them between 0 and 1.
         * @returns A reference to this color.
         */
        setClamped(_r, _g, _b, _a) {
            return this.set(FudgeCore.Calc.clamp(_r, 0, 1), FudgeCore.Calc.clamp(_g, 0, 1), FudgeCore.Calc.clamp(_b, 0, 1), FudgeCore.Calc.clamp(_a, 0, 1));
            ;
        }
        /**
         * Sets this color from the given hsl values.
         */
        setHSL(_hue, _saturation, _lightness, _alpha) {
            if (_alpha != undefined)
                this.a = _alpha;
            return Color.hsl2rgb(_hue, _saturation, _lightness, this);
        }
        /**
         * Sets this color from the given 8-bit values for the color channels.
         * @returns A reference to this color.
         */
        setBytes(_r, _g, _b, _a) {
            return this.set(_r / 255, _g / 255, _b / 255, _a / 255);
        }
        /**
         * Sets this color from the given hex string color.
         * @returns A reference to this color.
         */
        setHex(_hex) {
            if (_hex.startsWith("#"))
                _hex = _hex.slice(1);
            this.r = parseInt(_hex.slice(0, 2), 16) / 255;
            this.g = parseInt(_hex.slice(2, 4), 16) / 255;
            this.b = parseInt(_hex.slice(4, 6), 16) / 255;
            if (_hex.length >= 8)
                this.a = parseInt(_hex.slice(6, 8), 16) / 255;
            return this;
        }
        /**
         * Returns an array of the color channels of this color.
         */
        get() {
            return new Float32Array([this.r, this.g, this.b, this.a]);
        }
        /**
         * Returns the css color keyword representing this color.
         * @deprecated Use {@link toCSS} instead.
         */
        getCSS() {
            return this.toCSS();
        }
        /**
         * Returns the hex string representation of this color.
         * @deprecated Use {@link toHex} instead.
         */
        getHex() {
            return this.toHex();
        }
        /**
         * Adds the given color to this.
         */
        add(_color) {
            this.r += _color.r;
            this.g += _color.g;
            this.b += _color.b;
            this.a += _color.a;
            return this;
        }
        /**
         * Adds the given color to this.
         */
        subtract(_color) {
            this.r = Math.max(0, this.r - _color.r);
            this.g = Math.max(0, this.g - _color.g);
            this.b = Math.max(0, this.b - _color.b);
            this.a = Math.max(0, this.a - _color.a);
            return this;
        }
        /**
         * Multiplies this with the given color.
         */
        multiply(_color) {
            this.r *= _color.r;
            this.g *= _color.g;
            this.b *= _color.b;
            this.a *= _color.a;
            return this;
        }
        /**
         * Scales this color by the given factor.
         */
        scale(_scaling) {
            this.r *= _scaling;
            this.g *= _scaling;
            this.b *= _scaling;
            this.a *= _scaling;
            return this;
        }
        /**
         * Calls a defined callback function on each channel of the color, and returns a new color that contains the results. Similar to {@link Array.map}.
         * @param _out Optional color to store the result in.
         */
        map(_function, _out = FudgeCore.Recycler.reuse(Color)) {
            _out.r = _function(this.r, 0, "r", this);
            _out.g = _function(this.g, 1, "g", this);
            _out.b = _function(this.b, 2, "b", this);
            _out.a = _function(this.a, 3, "a", this);
            return _out;
        }
        /**
         * Calls a defined callback function on each channel of the color and assigns the result to the channel. Similar to {@link Color.map} but mutates this color instead of creating a new one.
         * @returns A reference to this color.
         */
        apply(_function) {
            this.r = _function(this.r, 0, "r", this);
            this.g = _function(this.g, 1, "g", this);
            this.b = _function(this.b, 2, "b", this);
            this.a = _function(this.a, 3, "a", this);
            return this;
        }
        /**
         * Copies the channels of this color into the given array starting at the given offset.
         * @returns A reference to the given array.
         */
        toArray(_out, _offset = 0) {
            _out[_offset] = this.r;
            _out[_offset + 1] = this.g;
            _out[_offset + 2] = this.b;
            _out[_offset + 3] = this.a;
            return _out;
        }
        /**
         * Returns a formatted string representation of this color
         */
        toString() {
            return `(r: ${this.r.toFixed(3)}, g: ${this.g.toFixed(3)}, b: ${this.b.toFixed(3)}, a: ${this.a.toFixed(3)})`;
        }
        /**
         * Returns the hex string representation of this color. // TODO: maybe this should return a number instead of a string?
         */
        toHex() {
            return `${(this.r * 255).toString(16).padStart(2, "0")}${(this.g * 255).toString(16).padStart(2, "0")}${(this.b * 255).toString(16).padStart(2, "0")}${(this.a * 255).toString(16).padStart(2, "0")}`;
        }
        /**
         * Returns the css color keyword representing this color.
         */
        toCSS() {
            return `rgba(${Math.round(this.r * 255)}, ${Math.round(this.g * 255)}, ${Math.round(this.b * 255)}, ${this.a})`;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator(true);
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.r}, ${this.g}, ${this.b}, ${this.a}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.r, this.g, this.b, this.a] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        mutate(_mutator) {
            if (_mutator.r != undefined)
                this.r = _mutator.r;
            if (_mutator.g != undefined)
                this.g = _mutator.g;
            if (_mutator.b != undefined)
                this.b = _mutator.b;
            if (_mutator.a != undefined)
                this.a = _mutator.a;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Color = Color;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Material} loaded from a glTF-File.
     * @authors Jonas Plotzky, HFU, 2024
     */
    class MaterialGLTF extends FudgeCore.mixinSerializableResourceExternal(FudgeCore.Material) {
        async load(_url = this.url, _name = this.name) {
            this.url = _url;
            this.name = _name;
            return FudgeCore.GLTFLoader.loadResource(this);
        }
    }
    FudgeCore.MaterialGLTF = MaterialGLTF;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Abstract class supporting various arithmetical helper functions
     */
    class Calc {
        /** factor multiplied with angle in degrees yields the angle in radian */
        static { this.deg2rad = Math.PI / 180; }
        /** factor multiplied with angle in radian yields the angle in degrees */
        static { this.rad2deg = 1 / Calc.deg2rad; }
        /**
         * Returns one of the values passed in, either _value if within _min and _max or the boundary being exceeded by _value.
         */
        static clamp(_value, _min, _max, _isSmaller = (Calc.isSmaller)) {
            if (_isSmaller(_value, _min))
                return _min;
            if (_isSmaller(_max, _value))
                return _max;
            return _value;
        }
        /**
         * Returns the linear interpolation between two values. When t is 0 the result is a, when t is 1 the result is b. Clamps t between 0 and 1.
         */
        static lerp(_a, _b, _t) {
            return _a + Calc.clamp(_t, 0, 1) * (_b - _a);
        }
        /**
         * Rounds the given value to the nearest multiple of the given increment using the given rounding function.
         * Default rounding function is {@link Math.round}, use {@link Math.floor} or {@link Math.ceil} to round down or up.
         */
        static snap(_value, _increment, _round = Math.round) {
            return _round(_value / _increment) * _increment;
        }
        static isSmaller(_value1, _value2) {
            return _value1 < _value2;
        }
    }
    FudgeCore.Calc = Calc;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Framing describes how to map a rectangle into a given frame
     * and how points in the frame correspond to points in the resulting rectangle and vice versa
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Framing
     */
    class Framing extends FudgeCore.Mutable {
        reduceMutator(_mutator) { }
    }
    FudgeCore.Framing = Framing;
    /**
     * The resulting rectangle has a fixed width and height and display should scale to fit the frame
     * Points are scaled in the same ratio
     */
    class FramingFixed extends Framing {
        constructor(_width = 300, _height = 150) {
            super();
            this.width = 300;
            this.height = 150;
            this.setSize(_width, _height);
        }
        /**
         * Sets this framing to the given width and height
         */
        setSize(_width, _height) {
            this.width = _width;
            this.height = _height;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.width * (_pointInFrame.x - _rectFrame.x) / _rectFrame.width, this.height * (_pointInFrame.y - _rectFrame.y) / _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x * _rect.width / this.width + _rect.x, _point.y * _rect.height / this.height + _rect.y);
            return result;
        }
        getRect(_rectFrame, _rectOut = FudgeCore.Recycler.reuse(FudgeCore.Rectangle)) {
            return FudgeCore.Rectangle.GET(0, 0, this.width, this.height, undefined, _rectOut);
        }
    }
    FudgeCore.FramingFixed = FramingFixed;
    /**
     * Width and height of the resulting rectangle are fractions of those of the frame, scaled by normed values normWidth and normHeight.
     * Display should scale to fit the frame and points are scaled in the same ratio
     */
    class FramingScaled extends Framing {
        constructor() {
            super(...arguments);
            this.normWidth = 1.0;
            this.normHeight = 1.0;
        }
        /**
         * Sets this framing to the given normed width and height
         */
        setScale(_normWidth, _normHeight) {
            this.normWidth = _normWidth;
            this.normHeight = _normHeight;
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(this.normWidth * (_pointInFrame.x - _rectFrame.x), this.normHeight * (_pointInFrame.y - _rectFrame.y));
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x / this.normWidth + _rect.x, _point.y / this.normHeight + _rect.y);
            return result;
        }
        getRect(_rectFrame, _rectOut = FudgeCore.Recycler.reuse(FudgeCore.Rectangle)) {
            return FudgeCore.Rectangle.GET(0, 0, this.normWidth * _rectFrame.width, this.normHeight * _rectFrame.height, undefined, _rectOut);
        }
    }
    FudgeCore.FramingScaled = FramingScaled;
    /**
     * The resulting rectangle fits into a margin given as fractions of the size of the frame given by normAnchor
     * plus an absolute padding given by pixelBorder. Display should fit into this.
     */
    class FramingComplex extends Framing {
        constructor() {
            super(...arguments);
            this.margin = { left: 0, top: 0, right: 0, bottom: 0 };
            this.padding = { left: 0, top: 0, right: 0, bottom: 0 };
        }
        getPoint(_pointInFrame, _rectFrame) {
            let result = new FudgeCore.Vector2(_pointInFrame.x - this.padding.left - this.margin.left * _rectFrame.width, _pointInFrame.y - this.padding.top - this.margin.top * _rectFrame.height);
            return result;
        }
        getPointInverse(_point, _rect) {
            let result = new FudgeCore.Vector2(_point.x + this.padding.left + this.margin.left * _rect.width, _point.y + this.padding.top + this.margin.top * _rect.height);
            return result;
        }
        getRect(_rectFrame, _rectOut = FudgeCore.Recycler.reuse(FudgeCore.Rectangle)) {
            if (!_rectFrame)
                return null;
            let minX = _rectFrame.x + this.margin.left * _rectFrame.width + this.padding.left;
            let minY = _rectFrame.y + this.margin.top * _rectFrame.height + this.padding.top;
            let maxX = _rectFrame.x + (1 - this.margin.right) * _rectFrame.width - this.padding.right;
            let maxY = _rectFrame.y + (1 - this.margin.bottom) * _rectFrame.height - this.padding.bottom;
            return FudgeCore.Rectangle.GET(minX, minY, maxX - minX, maxY - minY, undefined, _rectOut);
        }
        getMutator() {
            return { margin: this.margin, padding: this.padding };
        }
    }
    FudgeCore.FramingComplex = FramingComplex;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Representation of a vector2 as polar coordinates
     * ```text
     *  ‚Üï- angle (Angle to the x-axis)
     *  -‚Üí Magnitude (Distance from the center)
     * ```
     */
    class Geo2 {
        constructor(_angle = 0, _magnitude = 1) {
            this.magnitude = 0;
            this.angle = 0;
            this.set(_angle, _magnitude);
        }
        /**
         * Set the properties of this instance at once
         */
        set(_angle = 0, _magnitude = 1) {
            this.magnitude = _magnitude;
            this.angle = _angle;
            return this;
        }
        recycle() {
            this.set();
        }
        /**
         * Returns a pretty string representation
         */
        toString() {
            return `angle: ${this.angle.toPrecision(5)},  magnitude: ${this.magnitude.toPrecision(5)}`;
        }
    }
    FudgeCore.Geo2 = Geo2;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Representation of a vector3 as geographic coordinates as seen on a globe
     * ```text
     * ‚Üê|‚Üí Longitude (Angle to the z-axis)
     *  ‚Üï- Latitude (Angle to the equator)
     *  -‚Üí Magnitude (Distance from the center)
     * ```
     */
    class Geo3 {
        constructor(_longitude = 0, _latitude = 0, _magnitude = 1) {
            this.magnitude = 0;
            this.latitude = 0;
            this.longitude = 0;
            this.set(_longitude, _latitude, _magnitude);
        }
        /**
         * Set the properties of this instance at once
         */
        set(_longitude = 0, _latitude = 0, _magnitude = 1) {
            this.magnitude = _magnitude;
            this.latitude = _latitude;
            this.longitude = _longitude;
            return this;
        }
        recycle() {
            this.set();
        }
        /**
         * Returns a pretty string representation
         */
        toString() {
            return `longitude: ${this.longitude.toPrecision(5)}, latitude: ${this.latitude.toPrecision(5)}, magnitude: ${this.magnitude.toPrecision(5)}`;
        }
    }
    FudgeCore.Geo3 = Geo3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // From http://baagoe.com/en/RandomMusings/javascript/
    // Johannes Baag√∏e <baagoe@baagoe.com>, 2010
    function Mash() {
        let n = 0xefc8249d;
        let mash = function (_data) {
            _data = _data.toString();
            for (let i = 0; i < _data.length; i++) {
                n += _data.charCodeAt(i);
                let h = 0.02519603282416938 * n;
                n = h >>> 0;
                h -= n;
                h *= n;
                n = h >>> 0;
                h -= n;
                n += h * 0x100000000; // 2^32
            }
            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
        };
        // mash.version = 'Mash 0.9';
        return mash;
    }
    FudgeCore.Mash = Mash;
    // From http://baagoe.com/en/RandomMusings/javascript/
    function LFIB4() {
        // George Marsaglia's LFIB4,
        //http://groups.google.com/group/sci.crypt/msg/eb4ddde782b17051
        let args = Array.prototype.slice.call(arguments);
        let k0 = 0, k1 = 58, k2 = 119, k3 = 178;
        let s = [];
        let mash = Mash();
        if (args.length === 0) {
            args = [+new Date()];
        }
        for (let j = 0; j < 256; j++) {
            s[j] = mash(" ");
            s[j] -= mash(" ") * 4.76837158203125e-7; // 2^-21
            if (s[j] < 0) {
                s[j] += 1;
            }
        }
        for (let i = 0; i < args.length; i++) {
            for (let j = 0; j < 256; j++) {
                s[j] -= mash(args[i]);
                s[j] -= mash(args[i]) * 4.76837158203125e-7; // 2^-21
                if (s[j] < 0) {
                    s[j] += 1;
                }
            }
        }
        mash = null;
        let random = function () {
            let x;
            k0 = (k0 + 1) & 255;
            k1 = (k1 + 1) & 255;
            k2 = (k2 + 1) & 255;
            k3 = (k3 + 1) & 255;
            x = s[k0] - s[k1];
            if (x < 0) {
                x += 1;
            }
            x -= s[k2];
            if (x < 0) {
                x += 1;
            }
            x -= s[k3];
            if (x < 0) {
                x += 1;
            }
            return s[k0] = x;
        };
        // random.uint32 = function () {
        //   return random() * 0x100000000 >>> 0; // 2^32
        // };
        // random.fract53 = random;
        // random.version = "LFIB4 0.9";
        // random.args = args;
        return random;
    }
    FudgeCore.LFIB4 = LFIB4;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Simple class for 3x3 matrix operations
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2020 | Jonas Plotzky, HFU, 2025
     */
    class Matrix3x3 extends FudgeCore.Mutable {
        #translation;
        #scaling;
        #rotation;
        #translationDirty;
        #rotationDirty;
        #scalingDirty;
        constructor() {
            super();
            this.data = new Float32Array(9); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.#translation = FudgeCore.Vector2.ZERO();
            this.#scaling = FudgeCore.Vector2.ONE();
            this.#rotation = 0;
            this.#translationDirty = false;
            this.#rotationDirty = false;
            this.#scalingDirty = false;
            this.recycle();
        }
        //TODO: figure out what this is used for
        /** TODO: describe! */
        static PROJECTION(_width, _height, _mtxOut = FudgeCore.Recycler.reuse(Matrix3x3)) {
            return _mtxOut.set(2 / _width, 0, 0, 0, -2 / _height, 0, -1, 1, 1);
        }
        /**
         * Retrieve a new identity matrix.
         */
        static IDENTITY() {
            return FudgeCore.Recycler.get(Matrix3x3);
        }
        /**
         * Composes a new matrix according to the given translation, rotation and scaling.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static COMPOSITION(_translation, _rotation, _scaling, _mtxOut = FudgeCore.Recycler.get(Matrix3x3)) {
            return _mtxOut.compose(_translation, _rotation, _scaling);
        }
        /**
         * Returns a matrix that translates coordinates along the x- and y-axis according to the given {@link Vector2}.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static TRANSLATION(_translate, _mtxOut = FudgeCore.Recycler.reuse(Matrix3x3)) {
            return _mtxOut.set(1, 0, 0, 0, 1, 0, _translate.x, _translate.y, 1);
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         * @param _angleInDegrees The value of the rotation.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static ROTATION(_angleInDegrees, _mtxOut = FudgeCore.Recycler.reuse(Matrix3x3)) {
            let angleInRadians = _angleInDegrees * FudgeCore.Calc.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            return _mtxOut.set(cos, sin, 0, -sin, cos, 0, 0, 0, 1);
        }
        /**
         * Returns a matrix that scales coordinates along the x- and y-axis according to the given {@link Vector2}.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static SCALING(_scalar, _mtxOut = FudgeCore.Recycler.reuse(Matrix3x3)) {
            return _mtxOut.set(_scalar.x, 0, 0, 0, _scalar.y, 0, 0, 0, 1);
        }
        //#endregion
        /**
         * Computes and returns the product of two passed matrices.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static PRODUCT(_mtxLeft, _mtxRight, _mtxOut = FudgeCore.Recycler.reuse(Matrix3x3)) {
            const left = _mtxLeft.data;
            const right = _mtxRight.data;
            const a00 = left[0], a01 = left[1], a02 = left[2];
            const a10 = left[3], a11 = left[4], a12 = left[5];
            const a20 = left[6], a21 = left[7], a22 = left[8];
            const b00 = right[0], b01 = right[1], b02 = right[2];
            const b10 = right[3], b11 = right[4], b12 = right[5];
            const b20 = right[6], b21 = right[7], b22 = right[8];
            return _mtxOut.set(b00 * a00 + b01 * a10 + b02 * a20, b00 * a01 + b01 * a11 + b02 * a21, b00 * a02 + b01 * a12 + b02 * a22, b10 * a00 + b11 * a10 + b12 * a20, b10 * a01 + b11 * a11 + b12 * a21, b10 * a02 + b11 * a12 + b12 * a22, b20 * a00 + b21 * a10 + b22 * a20, b20 * a01 + b21 * a11 + b22 * a21, b20 * a02 + b21 * a12 + b22 * a22);
        }
        /**
         * Computes and returns the inverse of a passed matrix.
         * @param _mtx The matrix to compute the inverse of.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static INVERSE(_mtx, _mtxOut = FudgeCore.Recycler.reuse(Matrix3x3)) {
            const m = _mtx.data;
            const m00 = m[0], m01 = m[1], m02 = m[2];
            const m10 = m[3], m11 = m[4], m12 = m[5];
            const m20 = m[6], m21 = m[7], m22 = m[8];
            let d = 1 /
                (m00 * (m11 * m22 - m21 * m12) -
                    m01 * (m10 * m22 - m12 * m20) +
                    m02 * (m10 * m21 - m11 * m20));
            return _mtxOut.set(d * (m11 * m22 - m21 * m12), d * (m02 * m21 - m01 * m22), d * (m01 * m12 - m02 * m11), d * (m12 * m20 - m10 * m22), d * (m00 * m22 - m02 * m20), d * (m10 * m02 - m00 * m12), d * (m10 * m21 - m20 * m11), d * (m20 * m01 - m00 * m21), d * (m00 * m11 - m10 * m01));
        }
        /**
         * - get: return a vector representation of the translation {@link Vector2}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: effect the matrix ignoring its rotation and scaling
         */
        get translation() {
            if (this.#translationDirty) {
                this.#translationDirty = false;
                this.#translation.set(this.data[6], this.data[7]);
            }
            return this.#translation;
        }
        set translation(_translation) {
            this.compose(_translation, undefined, undefined);
        }
        /**
         * - get: a copy of the calculated rotation {@link Vector2}
         * - set: effect the matrix
         */
        get rotation() {
            if (this.#rotationDirty) {
                let scaling = this.scaling;
                let s0 = this.data[0] / scaling.x;
                let s1 = this.data[1] / scaling.x;
                let s3 = this.data[3] / scaling.y;
                let s4 = this.data[4] / scaling.y;
                let xSkew = Math.atan2(-s3, s4);
                let ySkew = Math.atan2(s0, s1);
                let sy = Math.sqrt(s0 * s0 + s1 * s1); // probably 2. param should be this.data[4] / scaling.y
                let rotation;
                if (!(sy > 1e-6))
                    rotation = ySkew;
                else
                    rotation = xSkew;
                rotation *= FudgeCore.Calc.rad2deg;
                this.#rotation = rotation;
                this.#rotationDirty = false;
            }
            return this.#rotation;
        }
        set rotation(_rotation) {
            this.compose(undefined, _rotation, undefined);
        }
        /**
         * - get: return a vector representation of the scale {@link Vector3}.
         * **Caution!** Do not manipulate result, instead create a clone!
         * - set: effect the matrix
         */
        get scaling() {
            if (this.#scalingDirty) {
                this.#scaling.set(Math.sqrt(this.data[0] * this.data[0] + this.data[1] * this.data[1]) * (this.data[0] < 0 ? -1 : 1), Math.sqrt(this.data[3] * this.data[3] + this.data[4] * this.data[4]) * (this.data[4] < 0 ? -1 : 1));
                this.#scalingDirty = false;
            }
            return this.#scaling;
        }
        set scaling(_scaling) {
            this.compose(undefined, undefined, _scaling);
        }
        /**
         * Creates and returns a clone of this matrix.
         */
        get clone() {
            return FudgeCore.Recycler.reuse(Matrix3x3).copy(this);
        }
        /**
         * Resets the matrix to the identity-matrix and clears cache. Used by the recycler to reset.
         */
        recycle() {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        }
        /**
         * Resets the matrix to the identity-matrix and clears cache.
         */
        reset() {
            this.recycle();
        }
        //#region Translation
        /**
         * Adds a translation by the given {@link Vector2} to this matrix.
         * @returns A reference to this matrix.
         */
        translate(_by) {
            const mtxTranslation = Matrix3x3.TRANSLATION(_by);
            Matrix3x3.PRODUCT(this, mtxTranslation, this);
            FudgeCore.Recycler.store(mtxTranslation);
            return this;
        }
        /**
         * Adds a translation along the x-axis to this matrix.
         * @returns A reference to this matrix.
         */
        translateX(_by) {
            const translation = FudgeCore.Recycler.reuse(FudgeCore.Vector2).set(_by, 0);
            this.translate(translation);
            FudgeCore.Recycler.store(translation);
            return this;
        }
        /**
         * Adds a translation along the y-axis to this matrix.
         * @returns A reference to this matrix.
         */
        translateY(_by) {
            const translation = FudgeCore.Recycler.reuse(FudgeCore.Vector2).set(0, _by);
            this.translate(translation);
            FudgeCore.Recycler.store(translation);
            return this;
        }
        //#endregion
        //#region Rotation
        /**
         * Adds a rotation around the z-Axis to this matrix
         * @returns A reference to this matrix.
         */
        rotate(_angleInDegrees) {
            const mtxRotation = Matrix3x3.ROTATION(_angleInDegrees);
            Matrix3x3.PRODUCT(this, mtxRotation, this);
            FudgeCore.Recycler.store(mtxRotation);
            return this;
        }
        //#endregion
        //#region Scaling
        /**
         * Adds a scaling by the given {@link Vector2} to this matrix.
         * @returns A reference to this matrix.
         */
        scale(_by) {
            const mtxScaling = Matrix3x3.SCALING(_by);
            Matrix3x3.PRODUCT(this, mtxScaling, this);
            FudgeCore.Recycler.store(mtxScaling);
            return this;
        }
        /**
         * Adds a scaling along the x-Axis to this matrix.
         * @returns A reference to this matrix.
         */
        scaleX(_by) {
            const scaling = FudgeCore.Recycler.reuse(FudgeCore.Vector2).set(_by, 1);
            this.scale(scaling);
            FudgeCore.Recycler.store(scaling);
            return this;
        }
        /**
         * Adds a scaling along the y-Axis to this matrix.
         * @returns A reference to this matrix.
         */
        scaleY(_by) {
            const scaling = FudgeCore.Recycler.reuse(FudgeCore.Vector2).set(1, _by);
            this.scale(scaling);
            FudgeCore.Recycler.store(scaling);
            return this;
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix with the given matrix.
         * @returns A reference to this matrix.
         */
        multiply(_mtxRight) {
            return Matrix3x3.PRODUCT(this, _mtxRight, this);
        }
        /**
         * Premultiply this matrix with the given matrix.
         * @returns A reference to this matrix.
         */
        premultiply(_mtxLeft) {
            return Matrix3x3.PRODUCT(_mtxLeft, this, this);
        }
        //#endregion
        //#region Transfer
        /**
         * (Re-)Compose this matrix from the given translation, rotation and scaling.
         * Missing values will be decompsed from the current matrix state if necessary.
         * @returns A reference to this matrix.
         */
        compose(_translation, _rotation, _scaling) {
            const m = this.data;
            if (_translation) {
                const translation = this.translation;
                translation.mutate(_translation);
                m[6] = translation.x;
                m[7] = translation.y;
                this.#translationDirty = false;
            }
            if (_rotation || _scaling) {
                const rotation = _rotation ?? this.rotation;
                if (_rotation != undefined)
                    this.#rotation = rotation;
                const scaling = this.scaling;
                if (_scaling)
                    scaling.mutate(_scaling);
                const angleInRadians = rotation * FudgeCore.Calc.deg2rad;
                const sin = Math.sin(angleInRadians);
                const cos = Math.cos(angleInRadians);
                m[0] = cos * scaling.x;
                m[1] = sin * scaling.x;
                m[3] = -sin * scaling.y;
                m[4] = cos * scaling.y;
                this.#rotationDirty = false;
                this.#scalingDirty = false;
            }
            this.mutator = null;
            return this;
        }
        /**
         * Sets the elements of this matrix to the given array starting at the given offset.
         * @returns A reference to this matrix.
         */
        setArray(_array, _offset = 0) {
            this.data.set(_array, _offset);
            this.resetCache();
            return this;
        }
        /**
         * Sets the elements of this matrix to the given values.
         * @returns A reference to this matrix.
         */
        set(_m00, _m01, _m02, _m10, _m11, _m12, _m20, _m21, _m22) {
            const m = this.data;
            m[0] = _m00;
            m[1] = _m01;
            m[2] = _m02;
            m[3] = _m10;
            m[4] = _m11;
            m[5] = _m12;
            m[6] = _m20;
            m[7] = _m21;
            m[8] = _m22;
            this.resetCache();
            return this;
        }
        /**
         * Copies the elements of the given matrix into this matrix.
         * @returns A reference to this matrix.
         */
        copy(_original) {
            this.data.set(_original.data);
            this.mutator = null;
            this.#translationDirty = _original.#translationDirty;
            this.#rotationDirty = _original.#rotationDirty;
            this.#scalingDirty = _original.#scalingDirty;
            if (!this.#translationDirty)
                this.#translation.copy(_original.#translation);
            if (!this.#rotationDirty)
                this.#rotation = _original.#rotation;
            if (!this.#scalingDirty)
                this.#scaling.copy(_original.#scaling);
            return this;
        }
        /**
         * Returns a formatted string representation of this matrix
         */
        toString() {
            return `∆í.Matrix3x3(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Copys the elements of this matrix into the given array starting at the given offset.
         * @returns A reference to the given array.
         */
        toArray(_out, _offset = 0) {
            for (let i = 0; i < 9; i++)
                _out[_offset + i] = this.data[i];
            return _out;
        }
        /**
         * Returns the array of the elements of this matrix.
         * @returns A readonly view of the internal array.
         */
        getArray() {
            return this.data;
        }
        serialize() {
            // this.getMutator();
            let serialization = {
                translation: this.translation.serialize(),
                rotation: this.rotation,
                scaling: this.scaling.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            let mutator = {
                translation: await this.translation.deserialize(_serialization.translation),
                rotation: _serialization.rotation,
                scaling: await this.scaling.deserialize(_serialization.scaling)
            };
            this.mutate(mutator);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation,
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        // Optimized mutate method to directly update matrix values
        mutate(_mutator) {
            this.compose(_mutator.translation, _mutator.rotation, _mutator.scaling);
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector2";
            if (_mutator.rotation != undefined)
                types.rotation = "number";
            if (_mutator.scaling)
                types.scaling = "Vector2";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.#translationDirty = true;
            this.#rotationDirty = true;
            this.#scalingDirty = true;
            this.mutator = null;
        }
    }
    FudgeCore.Matrix3x3 = Matrix3x3;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores a 4x4 transformation matrix and provides operations for it.
     * ```text
     * [ 0, 1, 2, 3 ] ‚Üê row vector x
     * [ 4, 5, 6, 7 ] ‚Üê row vector y
     * [ 8, 9,10,11 ] ‚Üê row vector z
     * [12,13,14,15 ] ‚Üê translation
     *            ‚Üë  homogeneous column
     * ```
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019 | Jonas Plotzky, HFU, 2023-2025
     */
    class Matrix4x4 extends FudgeCore.Mutable {
        #translation;
        #scaling;
        #rotation;
        #quaternion;
        #translationDirty;
        #scalingDirty;
        #rotationDirty;
        #quaternionDirty;
        constructor(_data) {
            super();
            this.data = new Float32Array(16); // The data of the matrix.
            this.mutator = null; // prepared for optimization, keep mutator to reduce redundant calculation and for comparison. Set to null when data changes!
            this.#translation = FudgeCore.Vector3.ZERO();
            this.#scaling = FudgeCore.Vector3.ZERO();
            this.#rotation = FudgeCore.Vector3.ONE();
            this.#quaternion = FudgeCore.Quaternion.IDENTITY();
            if (!_data) {
                this.recycle();
                return;
            }
            this.data = _data;
            this.resetCache();
        }
        //#region STATICS
        /**
         * Retrieve a new identity matrix
         */
        static IDENTITY() {
            return FudgeCore.Recycler.get(Matrix4x4);
        }
        /**
         * Composes a new matrix according to the given translation, rotation and scaling.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static COMPOSITION(_translation, _rotation, _scaling, _mtxOut = FudgeCore.Recycler.get(Matrix4x4)) {
            return _mtxOut.compose(_translation, _rotation, _scaling);
        }
        /**
         * Computes and returns the product of two passed matrices.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static PRODUCT(_mtxLeft, _mtxRight, _mtxOut = FudgeCore.Recycler.reuse(Matrix4x4)) {
            const left = _mtxLeft.data;
            const right = _mtxRight.data;
            const out = _mtxOut.data;
            const a00 = left[0], a01 = left[1], a02 = left[2], a03 = left[3];
            const a10 = left[4], a11 = left[5], a12 = left[6], a13 = left[7];
            const a20 = left[8], a21 = left[9], a22 = left[10], a23 = left[11];
            const a30 = left[12], a31 = left[13], a32 = left[14], a33 = left[15];
            const b00 = right[0], b01 = right[1], b02 = right[2], b03 = right[3];
            const b10 = right[4], b11 = right[5], b12 = right[6], b13 = right[7];
            const b20 = right[8], b21 = right[9], b22 = right[10], b23 = right[11];
            const b30 = right[12], b31 = right[13], b32 = right[14], b33 = right[15];
            out[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
            out[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
            out[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
            out[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
            out[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
            out[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
            out[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
            out[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
            out[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
            out[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
            out[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
            out[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
            out[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
            out[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
            out[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
            out[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
            _mtxOut.resetCache();
            return _mtxOut;
        }
        /**
         * Computes and returns the transpose of a passed matrix.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static TRANSPOSE(_mtx, _mtxOut = FudgeCore.Recycler.reuse(Matrix4x4)) {
            const m = _mtx.data;
            return _mtxOut.set(m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]);
            ;
        }
        /**
         * Computes and returns the inverse of a passed matrix.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static INVERSE(_mtx, _mtxOut = FudgeCore.Recycler.reuse(Matrix4x4)) {
            const m = _mtx.data;
            const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
            const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
            const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
            const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
            const tmp0 = m22 * m33;
            const tmp1 = m32 * m23;
            const tmp2 = m12 * m33;
            const tmp3 = m32 * m13;
            const tmp4 = m12 * m23;
            const tmp5 = m22 * m13;
            const tmp6 = m02 * m33;
            const tmp7 = m32 * m03;
            const tmp8 = m02 * m23;
            const tmp9 = m22 * m03;
            const tmp10 = m02 * m13;
            const tmp11 = m12 * m03;
            const tmp12 = m20 * m31;
            const tmp13 = m30 * m21;
            const tmp14 = m10 * m31;
            const tmp15 = m30 * m11;
            const tmp16 = m10 * m21;
            const tmp17 = m20 * m11;
            const tmp18 = m00 * m31;
            const tmp19 = m30 * m01;
            const tmp20 = m00 * m21;
            const tmp21 = m20 * m01;
            const tmp22 = m00 * m11;
            const tmp23 = m10 * m01;
            const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -
                (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);
            const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -
                (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);
            const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -
                (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);
            const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -
                (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);
            const d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
            return _mtxOut.set(d * t0, d * t1, d * t2, d * t3, d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) - (tmp0 * m10 + tmp3 * m20 + tmp4 * m30)), d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) - (tmp1 * m00 + tmp6 * m20 + tmp9 * m30)), d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) - (tmp2 * m00 + tmp7 * m10 + tmp10 * m30)), d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) - (tmp5 * m00 + tmp8 * m10 + tmp11 * m20)), d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) - (tmp13 * m13 + tmp14 * m23 + tmp17 * m33)), d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) - (tmp12 * m03 + tmp19 * m23 + tmp20 * m33)), d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) - (tmp15 * m03 + tmp18 * m13 + tmp23 * m33)), d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) - (tmp16 * m03 + tmp21 * m13 + tmp22 * m23)), d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) - (tmp16 * m32 + tmp12 * m12 + tmp15 * m22)), d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) - (tmp18 * m22 + tmp21 * m32 + tmp13 * m02)), d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) - (tmp22 * m32 + tmp14 * m02 + tmp19 * m12)), d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) - (tmp20 * m12 + tmp23 * m22 + tmp17 * m02)));
        }
        /**
         * Computes and returns a matrix with the given translation, its z-axis pointing directly at the given target,
         * and a minimal angle between its y-axis and the given up-{@link Vector3}, respetively calculating yaw and pitch.
         * The pitch may be restricted to the up-vector to only calculate yaw. Optionally pass a desired scaling.
         * @param _up A unit vector indicating the up-direction.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static LOOK_AT(_translation, _target, _up, _restrict = false, _scaling, _mtxOut = FudgeCore.Recycler.reuse(Matrix4x4)) {
            const forward = FudgeCore.Vector3.DIFFERENCE(_target, _translation);
            forward.normalize();
            Matrix4x4.LOOK_IN(forward, _up, _restrict, _translation, _scaling, _mtxOut);
            FudgeCore.Recycler.store(forward);
            return _mtxOut;
        }
        /**
         * Computes and returns a matrix with its z-axis pointing directly in the given forward direction,
         * and a minimal angle between its y-axis and the given up direction. The pitch may be restricted to the up-vector to only calculate yaw.
         * Optionally pass a desired translation and/or scaling.
         * @param _forward A unit vector indicating the desired forward-direction.
         * @param _up A unit vector indicating the up-direction.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static LOOK_IN(_forward, _up, _restrict = false, _translation, _scaling, _mtxOut = FudgeCore.Recycler.reuse(Matrix4x4)) {
            const zAxis = _forward.clone;
            const yAxis = _up ? _up.clone : FudgeCore.Vector3.Y();
            const xAxis = FudgeCore.Vector3.CROSS(yAxis, zAxis);
            // if z and up is parallel, there is no up to remain...
            if (xAxis.magnitudeSquared == 0) { // from three.js 
                if (Math.abs(yAxis.z) === 1)
                    zAxis.x += 0.0001;
                else
                    zAxis.z += 0.0001;
                zAxis.normalize();
                FudgeCore.Vector3.CROSS(yAxis, zAxis, xAxis);
            }
            xAxis.normalize();
            if (_restrict)
                FudgeCore.Vector3.CROSS(xAxis, yAxis, zAxis);
            else
                FudgeCore.Vector3.CROSS(zAxis, xAxis, yAxis);
            const scaling = _mtxOut.#scaling;
            if (_scaling) {
                scaling.copy(_scaling);
                xAxis.scale(scaling.x);
                yAxis.scale(scaling.y);
                zAxis.scale(scaling.z);
            }
            else {
                scaling.set(1, 1, 1);
            }
            const translation = _mtxOut.#translation;
            if (_translation)
                translation.copy(_translation);
            else
                translation.set(0, 0, 0);
            _mtxOut.set(xAxis.x, xAxis.y, xAxis.z, 0, yAxis.x, yAxis.y, yAxis.z, 0, zAxis.x, zAxis.y, zAxis.z, 0, translation.x, translation.y, translation.z, 1);
            FudgeCore.Recycler.store(xAxis);
            FudgeCore.Recycler.store(yAxis);
            FudgeCore.Recycler.store(zAxis);
            _mtxOut.#translationDirty = false;
            _mtxOut.#scalingDirty = false;
            return _mtxOut;
        }
        /**
         * Returns a matrix that translates coordinates along the x-, y- and z-axis according to the given {@link Vector3}.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static TRANSLATION(_translate, _mtxOut = FudgeCore.Recycler.reuse(Matrix4x4)) {
            return _mtxOut.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, _translate.x, _translate.y, _translate.z, 1);
        }
        /**
         * Returns a matrix that rotates coordinates on the x-axis when multiplied by.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static ROTATION_X(_angleInDegrees, _mtxOut = FudgeCore.Recycler.reuse(Matrix4x4)) {
            let angleInRadians = _angleInDegrees * FudgeCore.Calc.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            return _mtxOut.set(1, 0, 0, 0, 0, cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1);
        }
        /**
         * Returns a matrix that rotates coordinates on the y-axis when multiplied by.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static ROTATION_Y(_angleInDegrees, _mtxOut = FudgeCore.Recycler.reuse(Matrix4x4)) {
            let angleInRadians = _angleInDegrees * FudgeCore.Calc.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            return _mtxOut.set(cos, 0, -sin, 0, 0, 1, 0, 0, sin, 0, cos, 0, 0, 0, 0, 1);
        }
        /**
         * Returns a matrix that rotates coordinates on the z-axis when multiplied by.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static ROTATION_Z(_angleInDegrees, _mtxOut = FudgeCore.Recycler.reuse(Matrix4x4)) {
            let angleInRadians = _angleInDegrees * FudgeCore.Calc.deg2rad;
            let sin = Math.sin(angleInRadians);
            let cos = Math.cos(angleInRadians);
            return _mtxOut.set(cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        /**
         * Returns a matrix that rotates coordinates when multiplied by, using the rotation euler angles or unit quaternion given.
         * Rotation occurs around the axis in the order Z-Y-X.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static ROTATION(_rotation, _mtxOut = FudgeCore.Recycler.get(Matrix4x4)) {
            // avoid decompostion of rotation and scaling in compose...
            _mtxOut.#scaling.set(1, 1, 1);
            _mtxOut.#scalingDirty = false;
            if (_rotation instanceof FudgeCore.Quaternion) {
                _mtxOut.#quaternion.copy(_rotation);
                _mtxOut.#quaternionDirty = false;
                _mtxOut.#rotationDirty = true;
            }
            else {
                _mtxOut.#rotation.copy(_rotation);
                _mtxOut.#rotationDirty = false;
                _mtxOut.#quaternionDirty = true;
            }
            _mtxOut.rotation = _rotation;
            return _mtxOut;
        }
        /**
         * Returns a matrix that rotates coordinates around an arbitrary axis when multiplied by.
         * @param _axis The axis to rotate around as a unit vector.
         * @param _angle The angle in degrees.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static ROTATION_AXIS_ANGLE(_axis, _angle, _mtxOut = FudgeCore.Recycler.get(Matrix4x4)) {
            // from three.js, adjusted for FUDGE row vector * row-major matrix transformation convention
            _angle *= FudgeCore.Calc.deg2rad;
            const c = Math.cos(_angle);
            const s = Math.sin(_angle);
            const t = 1 - c;
            const x = _axis.x, y = _axis.y, z = _axis.z;
            const tx = t * x, ty = t * y;
            _mtxOut.set(tx * x + c, tx * y + s * z, tx * z - s * y, 0, tx * y - s * z, ty * y + c, ty * z + s * x, 0, tx * z + s * y, ty * z - s * x, t * z * z + c, 0, 0, 0, 0, 1);
            return _mtxOut;
        }
        /**
         * Returns a matrix that scales coordinates along the x-, y- and z-axis according to the given {@link Vector3}.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static SCALING(_scalar, _mtxOut = FudgeCore.Recycler.reuse(Matrix4x4)) {
            return _mtxOut.set(_scalar.x, 0, 0, 0, 0, _scalar.y, 0, 0, 0, 0, _scalar.z, 0, 0, 0, 0, 1);
        }
        /**
         * Returns a representation of the given matrix relative to the given base.
         * If known, pass the inverse of the base to avoid unneccesary calculation.
         * @param _mtxOut Optional matrix to store the result in.
         */
        static RELATIVE(_mtx, _mtxBase, _mtxInverse, _mtxOut = FudgeCore.Recycler.reuse(Matrix4x4)) {
            if (_mtxInverse)
                return Matrix4x4.PRODUCT(_mtxInverse, _mtx, _mtxOut);
            let mtxInverse = Matrix4x4.INVERSE(_mtxBase);
            Matrix4x4.PRODUCT(mtxInverse, _mtx, _mtxOut);
            FudgeCore.Recycler.store(mtxInverse);
            return _mtxOut;
        }
        //#endregion
        //#region PROJECTIONS
        /**
         * Computes and returns a matrix that applies perspective to an object, if its transform is multiplied by it.
         * @param _aspect The aspect ratio between width and height of projectionspace.(Default = canvas.clientWidth / canvas.ClientHeight)
         * @param _fieldOfViewInDegrees The field of view in Degrees. (Default = 45)
         * @param _near The near clipspace border on the z-axis.
         * @param _far The far clipspace border on the z-axis.
         * @param _direction The plane on which the fieldOfView-Angle is given
         * @param _mtxOut Optional matrix to store the result in.
         */
        static PROJECTION_CENTRAL(_aspect, _fieldOfViewInDegrees, _near, _far, _direction, _mtxOut = FudgeCore.Recycler.reuse(Matrix4x4)) {
            //TODO: camera looks down negative z-direction, should be positive
            let fieldOfViewInRadians = _fieldOfViewInDegrees * FudgeCore.Calc.deg2rad;
            let f = Math.tan(0.5 * (Math.PI - fieldOfViewInRadians));
            let rangeInv = 1.0 / (_near - _far);
            _mtxOut.set(f, 0, 0, 0, 0, f, 0, 0, 0, 0, (_near + _far) * rangeInv, -1, 0, 0, _near * _far * rangeInv * 2, 0);
            if (_direction == FudgeCore.FIELD_OF_VIEW.DIAGONAL) {
                _aspect = Math.sqrt(_aspect);
                _mtxOut.data[0] = f / _aspect;
                _mtxOut.data[5] = f * _aspect;
            }
            else if (_direction == FudgeCore.FIELD_OF_VIEW.VERTICAL)
                _mtxOut.data[0] = f / _aspect;
            else //FOV_DIRECTION.HORIZONTAL
                _mtxOut.data[5] = f * _aspect;
            // HACK: matrix should look in positive z-direction, preferably the matrix should be calculated like that right away
            _mtxOut.rotateY(180);
            return _mtxOut;
        }
        /**
         * Computes and returns a matrix that applies orthographic projection to an object, if its transform is multiplied by it.
         * @param _left The positionvalue of the projectionspace's left border.
         * @param _right The positionvalue of the projectionspace's right border.
         * @param _bottom The positionvalue of the projectionspace's bottom border.
         * @param _top The positionvalue of the projectionspace's top border.
         * @param _near The positionvalue of the projectionspace's near border.
         * @param _far The positionvalue of the projectionspace's far border
         * @param _mtxOut Optional matrix to store the result in.
         */
        static PROJECTION_ORTHOGRAPHIC(_left, _right, _bottom, _top, _near = -400, _far = 400, _mtxOut = FudgeCore.Recycler.reuse(Matrix4x4)) {
            _mtxOut.set(2 / (_right - _left), 0, 0, 0, 0, -2 / (_top - _bottom), 0, 0, 0, 0, 2 / (_far - _near), 0, (_left + _right) / (_left - _right), (_bottom + _top) / (_bottom - _top), (_near + _far) / (_near - _far), 1);
            return _mtxOut;
        }
        //#endregion
        //#region  Accessors
        /**
         * - get: return a vector representation of the translation {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: effect the matrix ignoring its rotation and scaling
         */
        get translation() {
            if (this.#translationDirty) {
                this.#translation.set(this.data[12], this.data[13], this.data[14]);
                this.#translationDirty = false;
            }
            return this.#translation;
        }
        set translation(_translation) {
            this.compose(_translation);
        }
        /**
         * - get: return a vector representation of the rotation {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: effect the matrix
         */
        get rotation() {
            if (this.#rotationDirty) {
                let scaling = this.scaling;
                let s0 = this.data[0] / scaling.x;
                let s1 = this.data[1] / scaling.x;
                let s2 = this.data[2] / scaling.x;
                let s6 = this.data[6] / scaling.y;
                let s10 = this.data[10] / scaling.z;
                let sy = Math.sqrt(s0 * s0 + s1 * s1); // probably 2. param should be this.data[4] / scaling.y
                let singular = sy < 1e-6; // If
                let x1, y1, z1;
                let x2, y2, z2;
                if (!singular) {
                    x1 = Math.atan2(s6, s10);
                    y1 = Math.atan2(-s2, sy);
                    z1 = Math.atan2(s1, s0);
                    x2 = Math.atan2(-s6, -s10);
                    y2 = Math.atan2(-s2, -sy);
                    z2 = Math.atan2(-s1, -s0);
                    if (Math.abs(x2) + Math.abs(y2) + Math.abs(z2) < Math.abs(x1) + Math.abs(y1) + Math.abs(z1)) {
                        x1 = x2;
                        y1 = y2;
                        z1 = z2;
                    }
                }
                else {
                    x1 = Math.atan2(-this.data[9] / scaling.z, this.data[5] / scaling.y);
                    y1 = Math.atan2(-this.data[2] / scaling.x, sy);
                    z1 = 0;
                }
                this.#rotation.set(x1, y1, z1);
                this.#rotation.scale(FudgeCore.Calc.rad2deg);
                this.#rotationDirty = false;
            }
            return this.#rotation;
        }
        set rotation(_rotation) {
            this.compose(undefined, _rotation);
        }
        /**
         * - get: return a vector representation of the scaling {@link Vector3}.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: effect the matrix
         */
        get scaling() {
            if (this.#scalingDirty) {
                this.#scaling.set(Math.sqrt(this.data[0] * this.data[0] + this.data[1] * this.data[1] + this.data[2] * this.data[2]), //* (this.data[0] < 0 ? -1 : 1),
                Math.sqrt(this.data[4] * this.data[4] + this.data[5] * this.data[5] + this.data[6] * this.data[6]), //* (this.data[5] < 0 ? -1 : 1),
                Math.sqrt(this.data[8] * this.data[8] + this.data[9] * this.data[9] + this.data[10] * this.data[10]) // * (this.data[10] < 0 ? -1 : 1)
                );
                // if (this.determinant < 0) // ‚ö†Ô∏èEXPERMINETAL from three js: if determinant is negative, invert one scale
                //   this.#scaling.x = -this.#scaling.x;
                this.#scalingDirty = false;
            }
            return this.#scaling;
        }
        set scaling(_scaling) {
            this.compose(undefined, undefined, _scaling);
        }
        /**
         * - get: return a unit quaternion representing the rotation of this matrix.
         * **Caution!** Use immediately and readonly, since the quaternion is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: effect the matrix
         */
        get quaternion() {
            if (this.#quaternionDirty) {
                this.#quaternion.eulerAngles = this.rotation;
                this.#quaternionDirty = false;
                // alternative quaternion calculation, faster than euler angles, but produces different results for matrices with determinant < 0 than euler angles...
                // from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm, adjusted for FUDGE row vector * row-major matrix transformation convention
                // requires a pure (unscaled) rotation matrix
                // const scaling: Vector3 = this.scaling;
                // const invScalingX: number =  (this.getDeterminant() < 0 ? -1 : 1) / scaling.x;
                // const invScalingY: number = 1 / scaling.y;
                // const invScalingZ: number = 1 / scaling.z;
                // const m00: number = this.data[0] * invScalingX;
                // const m01: number = this.data[1] * invScalingX;
                // const m02: number = this.data[2] * invScalingX;
                // const m10: number = this.data[4] * invScalingY;
                // const m11: number = this.data[5] * invScalingY;
                // const m12: number = this.data[6] * invScalingY;
                // const m20: number = this.data[8] * invScalingZ;
                // const m21: number = this.data[9] * invScalingZ;
                // const m22: number = this.data[10] * invScalingZ;
                // const trace: number = m00 + m11 + m22;
                // if (trace > 0) {
                //   const s: number = 0.5 / Math.sqrt(trace + 1);
                //   this.#quaternion.set(
                //     (m12 - m21) * s, 
                //     (m20 - m02) * s, 
                //     (m01 - m10) * s, 
                //     0.25 / s);
                // } else if (m00 > m11 && m00 > m22) {
                //   const s: number = 2 * Math.sqrt(1 + m00 - m11 - m22);
                //   this.#quaternion.set(
                //     0.25 * s,
                //     (m10 + m01) / s,
                //     (m20 + m02) / s,
                //     (m12 - m21) / s
                //   );
                // } else if (m11 > m22) {
                //   const s: number = 2 * Math.sqrt(1 + m11 - m00 - m22);
                //   this.#quaternion.set(
                //     (m10 + m01) / s,
                //     0.25 * s,
                //     (m21 + m12) / s,
                //     (m20 - m02) / s
                //   );
                // } else {
                //   const s: number = 2 * Math.sqrt(1 + m22 - m00 - m11);
                //   this.#quaternion.set(
                //     (m20 + m02) / s,
                //     (m21 + m12) / s,
                //     0.25 * s,
                //     (m01 - m10) / s
                //   );
                // }
                // this.#quaternionDirty = false;
            }
            return this.#quaternion;
        }
        set quaternion(_quaternion) {
            this.compose(undefined, _quaternion);
        }
        /**
         * Returns the determinant of this matrix. Computational heavy operation, not cached so use with care.
         * @deprecated Use {@link Matrix4x4.getDeterminant} instead.
         */
        get determinant() {
            const m = this.data;
            const det00 = m[10] * m[15] - m[11] * m[14];
            const det01 = m[9] * m[15] - m[11] * m[13];
            const det02 = m[9] * m[14] - m[10] * m[13];
            const det03 = m[8] * m[15] - m[11] * m[12];
            const det04 = m[8] * m[14] - m[10] * m[12];
            const det05 = m[8] * m[13] - m[9] * m[12];
            const det = m[0] * (m[5] * det00 - m[6] * det01 + m[7] * det02) -
                m[1] * (m[4] * det00 - m[6] * det03 + m[7] * det04) +
                m[2] * (m[4] * det01 - m[5] * det03 + m[7] * det05) -
                m[3] * (m[4] * det02 - m[5] * det04 + m[6] * det05);
            return det;
        }
        /**
         * Returns the normalized cardinal x-axis.
         * @deprecated use {@link getRight} instead.
         */
        get right() {
            let right = this.getX();
            right.normalize();
            return right;
        }
        /**
         * Returns the normalized cardinal y-axis.
         * @deprecated use {@link getUp} instead.
         */
        get up() {
            let up = this.getY();
            up.normalize();
            return up;
        }
        /**
         * Returns the normalized cardinal z-axis.
         * @deprecated use {@link getForward} instead.
         */
        get forward() {
            let forward = this.getZ();
            forward.normalize();
            return forward;
        }
        /**
         * Creates and returns a clone of this matrix.
         */
        get clone() {
            return FudgeCore.Recycler.reuse(Matrix4x4).copy(this);
        }
        //#endregion
        /**
         * Resets the matrix to the identity-matrix and clears cache. Used by the recycler to reset.
         */
        recycle() {
            this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            // TODO: think about this: should the cache be initialized as well? This would come in handy for when setting only rotation or scaling...
            // this.#translation.set(0, 0, 0);
            // this.#rotation.set(0, 0, 0);
            // this.#scaling.set(1, 1, 1);
            // this.#quaternion.set(0, 0, 0, 1);
            // this.#translationDirty = false;
            // this.#rotationDirty = false;
            // this.#scalingDirty = false;
            // this.#quaternionDirty = false;
        }
        /**
         * Resets the matrix to the identity-matrix and clears cache.
         * @returns A reference to this matrix.
         */
        reset() {
            this.recycle();
            return this;
        }
        /**
         * Transpose this matrix.
         * @returns A reference to this matrix.
         */
        transpose() {
            return Matrix4x4.TRANSPOSE(this, this);
        }
        /**
         * Invert this matrix.
         * @returns A reference to this matrix.
         */
        invert() {
            return Matrix4x4.INVERSE(this, this);
        }
        //#region Translation
        /**
         * Adds a translation by the given {@link Vector3} to this matrix.
         * If _local is true, the translation occurs according to the current rotation and scaling of this matrix,
         * otherwise, it occurs according to the parent.
         * @returns A reference to this matrix.
         */
        translate(_by, _local = true) {
            if (_local) {
                let mtxTranslation = Matrix4x4.TRANSLATION(_by);
                this.multiply(mtxTranslation);
                FudgeCore.Recycler.store(mtxTranslation);
            }
            else {
                this.data[12] += _by.x;
                this.data[13] += _by.y;
                this.data[14] += _by.z;
                this.mutator = null;
                this.#translationDirty = true;
                this.modified = true;
            }
            // const matrix: Matrix4x4 = Matrix4x4.MULTIPLICATION(this, Matrix4x4.TRANSLATION(_by));
            // // TODO: possible optimization, translation may alter mutator instead of deleting it.
            // this.set(matrix);
            // Recycler.store(matrix);
            return this;
        }
        /**
         * Adds a translation along the x-axis to this matrix.
         * @returns A reference to this matrix.
         */
        translateX(_x, _local = true) {
            let translation = FudgeCore.Vector3.X(_x);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
            return this;
        }
        /**
         * Adds a translation along the y-axis to this matrix.
         * @returns A reference to this matrix.
         */
        translateY(_y, _local = true) {
            let translation = FudgeCore.Vector3.Y(_y);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
            return this;
        }
        /**
         * Adds a translation along the z-axis to this matrix.
         * @returns A reference to this matrix.
         */
        translateZ(_z, _local = true) {
            let translation = FudgeCore.Vector3.Z(_z);
            this.translate(translation, _local);
            FudgeCore.Recycler.store(translation);
            return this;
        }
        //#endregion
        //#region Rotation
        /**
         * Rotates this matrix by given {@link Vector3} in the order Z, Y, X. Right hand rotation is used, thumb points in axis direction, fingers curling indicate rotation
         * The rotation is appended to already applied transforms, thus multiplied from the right. Set _fromLeft to true to switch and put it in front.
         * @returns A reference to this matrix.
         */
        rotate(_by, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION(_by);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
            return this;
        }
        /**
         * Adds a rotation around the x-axis to this matrix.
         * @returns A reference to this matrix.
         */
        rotateX(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_X(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
            return this;
        }
        /**
         * Adds a rotation around the y-axis to this matrix.
         * @returns A reference to this matrix.
         */
        rotateY(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_Y(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
            return this;
        }
        /**
         * Adds a rotation around the z-axis to this matrix.
         * @returns A reference to this matrix.
         */
        rotateZ(_angleInDegrees, _fromLeft = false) {
            let mtxRotation = Matrix4x4.ROTATION_Z(_angleInDegrees);
            this.multiply(mtxRotation, _fromLeft);
            FudgeCore.Recycler.store(mtxRotation);
            return this;
        }
        /**
         * Adjusts the rotation of this matrix to point the z-axis directly at the given target and tilts it to accord with the given up-{@link Vector3},
         * respectively calculating yaw and pitch. If no up-{@link Vector3} is given, the previous up-{@link Vector3} is used.
         * The pitch may be restricted to the up-vector to only calculate yaw.
         * @param _up A unit vector indicating the up-direction.
         * @returns A reference to this matrix.
         */ // TODO: maybe passing up should be mandatory, default up (local up) and default restrict (false) form a feedback loop, as the local up gets modified each call...
        lookAt(_target, _up, _restrict = false) {
            const up = _up ? _up : this.getUp();
            Matrix4x4.LOOK_AT(this.translation, _target, up, _restrict, this.scaling, this);
            if (!_up)
                FudgeCore.Recycler.store(up);
            return this;
        }
        /**
         * Adjusts the rotation of this matrix to align the z-axis with the given forward-direction and tilts it to accord with the given up-{@link Vector3}.
         * If no up-vector is provided, the local {@link Matrix4x4.getUp} is used.
         * The pitch may be restricted to the up-vector to only calculate yaw.
         * @param _forward A unit vector indicating the desired forward-direction.
         * @param _up A unit vector indicating the up-direction.
         * @returns A reference to this matrix.
         */ // TODO: maybe passing up should be mandatory, default up (local up) and default restrict (false) form a feedback loop, as the local up gets modified each call...
        lookIn(_forward, _up, _restrict = false) {
            const up = _up ? _up : this.getUp();
            Matrix4x4.LOOK_IN(_forward, up, _restrict, this.translation, this.scaling, this);
            if (!_up)
                FudgeCore.Recycler.store(up);
            return this;
        }
        /**
         * Same as {@link Matrix4x4.lookAt}, but optimized and needs testing
         */
        // TODO: testing lookat that really just rotates the matrix rather than creating a new one
        // public lookAtRotate(_target: Vector3, _up?: Vector3, _preserveScaling: boolean = true): void {
        //   if (!_up)
        //     _up = this.getY();
        //   let scaling: Vector3 = this.scaling;
        //   let difference: Vector3 = Vector3.DIFFERENCE(_target, this.translation);
        //   difference.normalize();
        //   let cos: number = Vector3.DOT(Vector3.NORMALIZATION(this.getZ()), difference);
        //   let sin: number = Vector3.DOT(Vector3.NORMALIZATION(this.getX()), difference);
        //   // console.log(sin, cos);
        //   let mtxRotation: Matrix4x4 = Recycler.get(Matrix4x4);
        //   mtxRotation.data.set([
        //     cos, 0, -sin, 0,
        //     0, 1, 0, 0,
        //     sin, 0, cos, 0,
        //     0, 0, 0, 1
        //   ]);
        //   this.multiply(mtxRotation, false);
        //   cos = Vector3.DOT(Vector3.NORMALIZATION(this.getZ()), difference);
        //   sin = -Vector3.DOT(Vector3.NORMALIZATION(this.getY()), difference);
        //   // console.log(sin, cos);
        //   mtxRotation.data.set([
        //     1, 0, 0, 0,
        //     0, cos, sin, 0,
        //     0, -sin, cos, 0,
        //     0, 0, 0, 1
        //   ]);
        //   this.multiply(mtxRotation, false);
        //   this.scaling = scaling;
        //   Recycler.store(mtxRotation);
        // }
        //#endregion
        //#region Scaling
        /**
         * Adds a scaling by the given {@link Vector3} to this matrix.
         * @returns A reference to this matrix.
         */
        scale(_by, _fromLeft = false) {
            const mtxScaling = Matrix4x4.SCALING(_by);
            this.multiply(mtxScaling, _fromLeft);
            FudgeCore.Recycler.store(mtxScaling);
            return this;
        }
        /**
         * Adds a scaling along the x-axis to this matrix.
         * @returns A reference to this matrix.
         */
        scaleX(_by) {
            let vector = FudgeCore.Recycler.reuse(FudgeCore.Vector3);
            vector.set(_by, 1, 1);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
            return this;
        }
        /**
         * Adds a scaling along the y-axis to this matrix.
         * @returns A reference to this matrix.
         */
        scaleY(_by) {
            let vector = FudgeCore.Recycler.reuse(FudgeCore.Vector3);
            vector.set(1, _by, 1);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
            return this;
        }
        /**
         * Adds a scaling along the z-axis to this matrix.
         * @returns A reference to this matrix.
         */
        scaleZ(_by) {
            let vector = FudgeCore.Recycler.reuse(FudgeCore.Vector3);
            vector.set(1, 1, _by);
            this.scale(vector);
            FudgeCore.Recycler.store(vector);
            return this;
        }
        //#endregion
        //#region Transformation
        /**
         * Multiply this matrix by the given matrix.
         * @returns A reference to this matrix.
         */
        multiply(_matrix, _fromLeft = false) {
            if (_fromLeft)
                return Matrix4x4.PRODUCT(_matrix, this, this);
            else
                return Matrix4x4.PRODUCT(this, _matrix, this);
        }
        /**
         * Premultiply this matrix with the given matrix.
         * @returns A reference to this matrix.
         */
        premultiply(_mtxLeft) {
            return Matrix4x4.PRODUCT(_mtxLeft, this, this);
        }
        //#endregion
        //#region Transfer
        /**
         * (Re-)Compose this matrix from the given translation, rotation and scaling.
         * Missing values will be decompsed from the current matrix state if necessary.
         * @returns A reference to this matrix.
         */
        compose(_translation, _rotation, _scaling) {
            const m = this.data;
            if (_translation) {
                const translation = this.translation;
                translation.mutate(_translation);
                m[12] = translation.x;
                m[13] = translation.y;
                m[14] = translation.z;
                this.#translationDirty = false;
            }
            if (_rotation || _scaling) {
                const isQuaternion = _rotation?.w != undefined;
                const rotation = isQuaternion ? this.quaternion : this.rotation;
                if (_rotation) {
                    rotation.mutate(_rotation);
                    if (isQuaternion)
                        rotation.normalize();
                }
                const scaling = this.scaling;
                if (_scaling)
                    scaling.mutate(_scaling);
                const sx = scaling.x, sy = scaling.y, sz = scaling.z;
                if (isQuaternion) {
                    // fast algorithm from three.js
                    const x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;
                    const x2 = x + x, y2 = y + y, z2 = z + z;
                    const xx = x * x2, xy = x * y2, xz = x * z2;
                    const yy = y * y2, yz = y * z2, zz = z * z2;
                    const wx = w * x2, wy = w * y2, wz = w * z2;
                    m[0] = (1 - (yy + zz)) * sx;
                    m[1] = (xy + wz) * sx;
                    m[2] = (xz - wy) * sx;
                    m[4] = (xy - wz) * sy;
                    m[5] = (1 - (xx + zz)) * sy;
                    m[6] = (yz + wx) * sy;
                    m[8] = (xz + wy) * sz;
                    m[9] = (yz - wx) * sz;
                    m[10] = (1 - (xx + yy)) * sz;
                }
                else {
                    const radX = rotation.x * FudgeCore.Calc.deg2rad;
                    const radY = rotation.y * FudgeCore.Calc.deg2rad;
                    const radZ = rotation.z * FudgeCore.Calc.deg2rad;
                    const sinX = Math.sin(radX);
                    const cosX = Math.cos(radX);
                    const sinY = Math.sin(radY);
                    const cosY = Math.cos(radY);
                    const sinZ = Math.sin(radZ);
                    const cosZ = Math.cos(radZ);
                    m[0] = (cosZ * cosY) * sx;
                    m[1] = (sinZ * cosY) * sx;
                    m[2] = -sinY * sx;
                    m[4] = (cosZ * sinY * sinX - sinZ * cosX) * sy;
                    m[5] = (sinZ * sinY * sinX + cosZ * cosX) * sy;
                    m[6] = (cosY * sinX) * sy;
                    m[8] = (cosZ * sinY * cosX + sinZ * sinX) * sz;
                    m[9] = (sinZ * sinY * cosX - cosZ * sinX) * sz;
                    m[10] = (cosY * cosX) * sz;
                }
                this.#rotationDirty = isQuaternion;
                this.#quaternionDirty = !isQuaternion;
                this.#scalingDirty = false;
            }
            this.mutator = null;
            this.modified = true;
            return this;
        }
        /**
         * Sets the elements of this matrix to the given array starting at the given offset.
         * @returns A reference to this matrix.
         */
        setArray(_array, _offset = 0) {
            this.data.set(_array, _offset);
            this.resetCache();
            return this;
        }
        /**
         * Sets the elements of this matrix to the given values.
         * @returns A reference to this matrix.
         */
        set(_m00, _m01, _m02, _m03, _m10, _m11, _m12, _m13, _m20, _m21, _m22, _m23, _m30, _m31, _m32, _m33) {
            const m = this.data;
            m[0] = _m00;
            m[1] = _m01;
            m[2] = _m02;
            m[3] = _m03;
            m[4] = _m10;
            m[5] = _m11;
            m[6] = _m12;
            m[7] = _m13;
            m[8] = _m20;
            m[9] = _m21;
            m[10] = _m22;
            m[11] = _m23;
            m[12] = _m30;
            m[13] = _m31;
            m[14] = _m32;
            m[15] = _m33;
            this.resetCache();
            return this;
        }
        /**
         * Copies the state of the given matrix into this matrix.
         * @returns A reference to this matrix.
         */
        copy(_original) {
            this.data.set(_original.data);
            this.mutator = null;
            this.modified = true;
            this.#translationDirty = _original.#translationDirty;
            this.#rotationDirty = _original.#rotationDirty;
            this.#scalingDirty = _original.#scalingDirty;
            this.#quaternionDirty = _original.#quaternionDirty;
            if (!this.#translationDirty)
                this.#translation.copy(_original.#translation);
            if (!this.#rotationDirty)
                this.#rotation.copy(_original.#rotation);
            if (!this.#scalingDirty)
                this.#scaling.copy(_original.#scaling);
            if (!this.#quaternionDirty)
                this.#quaternion.copy(_original.#quaternion);
            return this;
        }
        /**
         * Returns a formatted string representation of this matrix
         */
        toString() {
            return `∆í.Matrix4x4(translation: ${this.translation.toString()}, rotation: ${this.rotation.toString()}, scaling: ${this.scaling.toString()}`;
        }
        /**
         * Copys the elements of this matrix into the given array starting at the given offset.
         * @returns A reference to the given array.
         */
        toArray(_out, _offset = 0) {
            for (let i = 0; i < 16; i++)
                _out[_offset + i] = this.data[i];
            return _out;
        }
        /**
         * Returns the array of the elements of this matrix.
         * @returns A readonly view of the internal array.
         */
        getArray() {
            return this.data;
        }
        /**
          * Returns the determinant of this matrix.
          */
        getDeterminant() {
            const m = this.data;
            const det00 = m[10] * m[15] - m[11] * m[14];
            const det01 = m[9] * m[15] - m[11] * m[13];
            const det02 = m[9] * m[14] - m[10] * m[13];
            const det03 = m[8] * m[15] - m[11] * m[12];
            const det04 = m[8] * m[14] - m[10] * m[12];
            const det05 = m[8] * m[13] - m[9] * m[12];
            const det = m[0] * (m[5] * det00 - m[6] * det01 + m[7] * det02) -
                m[1] * (m[4] * det00 - m[6] * det03 + m[7] * det04) +
                m[2] * (m[4] * det01 - m[5] * det03 + m[7] * det05) -
                m[3] * (m[4] * det02 - m[5] * det04 + m[6] * det05);
            return det;
        }
        /**
         * Return cardinal x-axis.
         * @param _vctOut Optional vector to store the result in.
         */
        getX(_vctOut = FudgeCore.Recycler.reuse(FudgeCore.Vector3)) {
            return _vctOut.set(this.data[0], this.data[1], this.data[2]);
            ;
        }
        /**
         * Return cardinal y-axis.
         * @param _vctOut Optional vector to store the result in.
         */
        getY(_vctOut = FudgeCore.Recycler.reuse(FudgeCore.Vector3)) {
            return _vctOut.set(this.data[4], this.data[5], this.data[6]);
        }
        /**
         * Return cardinal z-axis.
         * @param _vctOut Optional vector to store the result in.
         */
        getZ(_vctOut = FudgeCore.Recycler.reuse(FudgeCore.Vector3)) {
            return _vctOut.set(this.data[8], this.data[9], this.data[10]);
        }
        /**
         * Returns the normalized cardinal x-axis.
         * @param _vctOut Optional vector to store the result in.
         */
        getRight(_vctOut = FudgeCore.Recycler.reuse(FudgeCore.Vector3)) {
            return _vctOut.set(this.data[0], this.data[1], this.data[2]).normalize();
        }
        /**
         * Returns the normalized cardinal y-axis.
         * @param _vctOut Optional vector to store the result in.
         */
        getUp(_vctOut = FudgeCore.Recycler.reuse(FudgeCore.Vector3)) {
            return _vctOut.set(this.data[4], this.data[5], this.data[6]).normalize();
        }
        /**
         * Returns the normalized cardinal z-axis.
         * @param _vctOut Optional vector to store the result in.
         */
        getForward(_vctOut = FudgeCore.Recycler.reuse(FudgeCore.Vector3)) {
            return _vctOut.set(this.data[8], this.data[9], this.data[10]).normalize();
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapXY() {
            const m = this.data;
            const xAxis = this.getX(); // store x-axis
            m[4] = xAxis.x;
            m[5] = xAxis.y;
            m[6] = xAxis.z; // overwrite y-axis with x-axis
            m[0] = m[4];
            m[1] = m[5];
            m[2] = m[6]; // overwrite x-axis with y-axis
            m[8] = -m[8];
            m[9] = -m[9];
            m[10] = -m[10]; // reverse z-axis
            FudgeCore.Recycler.store(xAxis);
            this.resetCache();
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapXZ() {
            const m = this.data;
            const xAxis = this.getX(); // store x-axis
            m[4] = -m[4];
            m[5] = -m[5];
            m[6] = -m[6]; // reverse y-axis
            m[0] = m[8];
            m[1] = m[9];
            m[2] = m[10]; // overwrite x-axis with z-axis
            m[8] = xAxis.x;
            m[9] = xAxis.y;
            m[10] = xAxis.z; // overwrite z-axis with x-axis
            FudgeCore.Recycler.store(xAxis);
            this.resetCache();
        }
        /**
         * Swaps the two cardinal axis and reverses the third, effectively rotating the transform 180 degrees around one and 90 degrees around a second axis
         */
        swapYZ() {
            const m = this.data;
            const yAxis = this.getY(); // store y-axis
            m[0] = -m[0];
            m[1] = -m[1];
            m[2] = -m[2]; // reverse x-axis
            m[4] = m[8];
            m[5] = m[9];
            m[6] = m[10]; // overwrite y-axis with z-axis
            m[8] = yAxis.x;
            m[9] = yAxis.y;
            m[10] = yAxis.z; // overwrite z-axis with y-axis
            FudgeCore.Recycler.store(yAxis);
            this.resetCache();
        }
        /**
         * Returns the tranlation from this matrix to the target matrix.
         * @param _vctOut Optional vector to store the result in.
         */
        getTranslationTo(_mtxTarget, _vctOut = FudgeCore.Recycler.reuse(FudgeCore.Vector3)) {
            return _vctOut.set(_mtxTarget.data[12] - this.data[12], _mtxTarget.data[13] - this.data[13], _mtxTarget.data[14] - this.data[14]);
            ;
        }
        serialize() {
            // this.getMutator();
            let serialization = {
                translation: this.translation.serialize(),
                rotation: this.rotation.serialize(),
                scaling: this.scaling.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            let mutator = {
                translation: await this.translation.deserialize(_serialization.translation),
                rotation: await this.rotation.deserialize(_serialization.rotation),
                scaling: await this.scaling.deserialize(_serialization.scaling)
            };
            this.mutate(mutator);
            return this;
        }
        getMutator() {
            if (this.mutator)
                return this.mutator;
            let mutator = {
                translation: this.translation.getMutator(),
                rotation: this.rotation.getMutator(),
                scaling: this.scaling.getMutator()
            };
            // cache mutator
            this.mutator = mutator;
            return mutator;
        }
        mutate(_mutator) {
            this.compose(_mutator.translation, _mutator.rotation, _mutator.scaling);
        }
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            if (_mutator.translation)
                types.translation = "Vector3";
            if (_mutator.rotation)
                types.rotation = "Vector3";
            if (_mutator.scaling)
                types.scaling = "Vector3";
            return types;
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.#translationDirty = true;
            this.#rotationDirty = true;
            this.#quaternionDirty = true;
            this.#scalingDirty = true;
            this.modified = true;
            this.mutator = null;
        }
    }
    FudgeCore.Matrix4x4 = Matrix4x4;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Baseclass for Noise2, Noise3 and Noise4
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
     */
    class Noise {
        constructor(_random = Math.random) {
            this.perm = new Uint8Array(512);
            this.permMod12 = new Uint8Array(512);
            const p = new Uint8Array(256);
            for (let i = 0; i < 256; i++)
                p[i] = i;
            let n;
            let q;
            for (let i = 255; i > 0; i--) {
                n = Math.floor((i + 1) * _random());
                q = p[i];
                p[i] = p[n];
                p[n] = q;
            }
            for (let i = 0; i < 512; i++) {
                this.perm[i] = p[i & 255];
                this.permMod12[i] = this.perm[i] % 12;
            }
        }
    }
    FudgeCore.Noise = Noise;
})(FudgeCore || (FudgeCore = {}));
///<reference path="./Noise.ts"/>
var FudgeCore;
///<reference path="./Noise.ts"/>
(function (FudgeCore) {
    /**
     * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
     * done by Jirka Dell'Oro-Friedl, HFU, 2021
     *
     * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
     * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
     * Better rank ordering method by Stefan Gustavson in 2012.
     *
     * This code was placed in the public domain by its original author,
     * Stefan Gustavson. You may use it as you see fit, but
     * attribution is appreciated.
     */
    class Noise2 extends FudgeCore.Noise {
        static { this.offset = (3.0 - Math.sqrt(3.0)) / 6.0; }
        static { this.gradient = [[1, 1], [-1, 1], [1, -1], [-1, -1], [1, 0], [-1, 0], [1, 0], [-1, 0], [0, 1], [0, -1], [0, 1], [0, -1]]; }
        #sample;
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y) => {
                return this.#sample(_x, _y);
            };
            this.#sample = (_x, _y) => {
                // Skew the input space to determine which simplex cell we're in
                const s = (_x + _y) * 0.5 * (Math.sqrt(3.0) - 1.0); // Hairy factor for 2D
                const i = Math.floor(_x + s);
                const j = Math.floor(_y + s);
                const t = (i + j) * Noise2.offset;
                const X0 = i - t; // Unskew the cell origin back to (x,y) space
                const Y0 = j - t;
                const x0 = _x - X0; // The x,y distances from the cell origin
                const y0 = _y - Y0;
                // Determine which simplex we are in.
                const i1 = x0 > y0 ? 1 : 0;
                const j1 = x0 > y0 ? 0 : 1;
                // Offset:numbers for corners
                const x1 = x0 - i1 + Noise2.offset;
                const y1 = y0 - j1 + Noise2.offset;
                const x2 = x0 - 1.0 + 2.0 * Noise2.offset;
                const y2 = y0 - 1.0 + 2.0 * Noise2.offset;
                // Work out the hashed gradient indices of the three simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const g0 = Noise2.gradient[this.permMod12[ii + this.perm[jj]]];
                const g1 = Noise2.gradient[this.permMod12[ii + i1 + this.perm[jj + j1]]];
                const g2 = Noise2.gradient[this.permMod12[ii + 1 + this.perm[jj + 1]]];
                // Calculate the contribution from the three corners
                const t0 = 0.5 - x0 * x0 - y0 * y0;
                const n0 = t0 < 0 ? 0.0 : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0);
                const t1 = 0.5 - x1 * x1 - y1 * y1;
                const n1 = t1 < 0 ? 0.0 : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1);
                const t2 = 0.5 - x2 * x2 - y2 * y2;
                const n2 = t2 < 0 ? 0.0 : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2);
                // Add contributions from each corner to get the final noise value.
                // The result is scaled to return values in the interval [-1, 1]
                return 70.14805770653952 * (n0 + n1 + n2);
            };
        }
    }
    FudgeCore.Noise2 = Noise2;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
     * done by Jirka Dell'Oro-Friedl, HFU, 2021
     *
     * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
     * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
     * Better rank ordering method by Stefan Gustavson in 2012.
     *
     * This code was placed in the public domain by its original author,
     * Stefan Gustavson. You may use it as you see fit, but
     * attribution is appreciated.
     */
    // TODO: Test
    class Noise3 extends FudgeCore.Noise {
        static { this.offset = 1.0 / 6.0; }
        static { this.gradient = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, -1], [0, 1, -1], [0, -1, -1]
        ]; }
        #sample;
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y, _z) => {
                return this.#sample(_x, _y, _z);
            };
            this.#sample = (_x, _y, _z) => {
                // Skew the input space to determine which simplex cell we're in
                const s = (_x + _y + _z) / 3.0; // Very nice and simple skew factor for 3D
                const i = Math.floor(_x + s);
                const j = Math.floor(_y + s);
                const k = Math.floor(_z + s);
                const t = (i + j + k) * Noise3.offset;
                const X0 = i - t; // Unskew the cell origin back to (x,y,z) space
                const Y0 = j - t;
                const Z0 = k - t;
                const x0 = _x - X0; // The x,y,z distances from the cell origin
                const y0 = _y - Y0;
                const z0 = _z - Z0;
                // Deterine which simplex we are in
                let i1, j1, k1 // Offsets for second corner of simplex in (i,j,k) coords
                ;
                let i2, j2, k2 // Offsets for third corner of simplex in (i,j,k) coords
                ;
                if (x0 >= y0) {
                    if (y0 >= z0) {
                        i1 = i2 = j2 = 1;
                        j1 = k1 = k2 = 0;
                    }
                    else if (x0 >= z0) {
                        i1 = i2 = k2 = 1;
                        j1 = k1 = j2 = 0;
                    }
                    else {
                        k1 = i2 = k2 = 1;
                        i1 = j1 = j2 = 0;
                    }
                }
                else {
                    if (y0 < z0) {
                        k1 = j2 = k2 = 1;
                        i1 = j1 = i2 = 0;
                    }
                    else if (x0 < z0) {
                        j1 = j2 = k2 = 1;
                        i1 = k1 = i2 = 0;
                    }
                    else {
                        j1 = i2 = j2 = 1;
                        i1 = k1 = k2 = 0;
                    }
                }
                const x1 = x0 - i1 + Noise3.offset; // Offsets for second corner in (x,y,z) coords
                const y1 = y0 - j1 + Noise3.offset;
                const z1 = z0 - k1 + Noise3.offset;
                const x2 = x0 - i2 + 2.0 * Noise3.offset; // Offsets for third corner in (x,y,z) coords
                const y2 = y0 - j2 + 2.0 * Noise3.offset;
                const z2 = z0 - k2 + 2.0 * Noise3.offset;
                const x3 = x0 - 1.0 + 3.0 * Noise3.offset; // Offsets for last corner in (x,y,z) coords
                const y3 = y0 - 1.0 + 3.0 * Noise3.offset;
                const z3 = z0 - 1.0 + 3.0 * Noise3.offset;
                // Work :numberut the hashed gradient indices of the four simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                const g0 = Noise3.gradient[this.permMod12[ii + this.perm[jj + this.perm[kk]]]];
                const g1 = Noise3.gradient[this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]]];
                const g2 = Noise3.gradient[this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]]];
                const g3 = Noise3.gradient[this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]]];
                // Calcu:numberate the contribution from the four corners
                const t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0;
                const n0 = t0 < 0
                    ? 0.0
                    : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0 + g0[2] * z0);
                const t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1;
                const n1 = t1 < 0
                    ? 0.0
                    : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1 + g1[2] * z1);
                const t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2;
                const n2 = t2 < 0
                    ? 0.0
                    : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2 + g2[2] * z2);
                const t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3;
                const n3 = t3 < 0
                    ? 0.0
                    : Math.pow(t3, 4) * (g3[0] * x3 + g3[1] * y3 + g3[2] * z3);
                // Add contributions from each corner to get the final noise value.
                // The result is scaled to stay just inside [-1,1]
                return 94.68493150681972 * (n0 + n1 + n2 + n3);
            };
        }
    }
    FudgeCore.Noise3 = Noise3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // TODO: Test
    /**
     * This is an adaption of https://www.npmjs.com/package/fast-simplex-noise
     * done by Jirka Dell'Oro-Friedl, HFU, 2021
     *
     * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
     * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
     * Better rank ordering method by Stefan Gustavson in 2012.
     *
     * This code was placed in the public domain by its original author,
     * Stefan Gustavson. You may use it as you see fit, but
     * attribution is appreciated.
     */
    class Noise4 extends FudgeCore.Noise {
        static { this.offset = (5.0 - Math.sqrt(5.0)) / 20.0; }
        static { this.gradient = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]]; }
        #sample;
        constructor(_random = Math.random) {
            super(_random);
            this.#sample = null;
            this.sample = (_x, _y, _z, _w) => {
                return this.#sample(_x, _y, _z, _w);
            };
            this.#sample = (_x, _y, _z, _w) => {
                // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
                const s = (_x + _y + _z + _w) * (Math.sqrt(5.0) - 1.0) / 4.0; // Factor for 4D skewing
                const i = Math.floor(_x + s);
                const j = Math.floor(_y + s);
                const k = Math.floor(_z + s);
                const l = Math.floor(_w + s);
                const t = (i + j + k + l) * Noise4.offset; // Factor for 4D unskewing
                const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
                const Y0 = j - t;
                const Z0 = k - t;
                const W0 = l - t;
                const x0 = _x - X0; // The x,y,z,w distances from the cell origin
                const y0 = _y - Y0;
                const z0 = _z - Z0;
                const w0 = _w - W0;
                // To find out which of the 24 possible simplices we're in, we need to determine the
                // magnitude ordering of x0, y0, z0 and w0. Six pair-wise comparisons are performed between
                // each possible pair of the four coordinates, and the results are used to rank the numbers.
                let rankx = 0;
                let ranky = 0;
                let rankz = 0;
                let rankw = 0;
                if (x0 > y0)
                    rankx++;
                else
                    ranky++;
                if (x0 > z0)
                    rankx++;
                else
                    rankz++;
                if (x0 > w0)
                    rankx++;
                else
                    rankw++;
                if (y0 > z0)
                    ranky++;
                else
                    rankz++;
                if (y0 > w0)
                    ranky++;
                else
                    rankw++;
                if (z0 > w0)
                    rankz++;
                else
                    rankw++;
                // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
                // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
                // impossible. Only the 24 indices which have non-zero entries make any sense.
                // We use a thresholding to set the coordinates in turn from the largest magnitude.
                // Rank 3 denotes the largest coordinate.
                const i1 = rankx >= 3 ? 1 : 0;
                const j1 = ranky >= 3 ? 1 : 0;
                const k1 = rankz >= 3 ? 1 : 0;
                const l1 = rankw >= 3 ? 1 : 0;
                // Rank : 2 denotes the second largest coordinate.
                const i2 = rankx >= 2 ? 1 : 0;
                const j2 = ranky >= 2 ? 1 : 0;
                const k2 = rankz >= 2 ? 1 : 0;
                const l2 = rankw >= 2 ? 1 : 0;
                // Rank : 1 denotes the second smallest coordinate.
                const i3 = rankx >= 1 ? 1 : 0;
                const j3 = ranky >= 1 ? 1 : 0;
                const k3 = rankz >= 1 ? 1 : 0;
                const l3 = rankw >= 1 ? 1 : 0;
                // The fifth corner has all coordinate offsets = 1, so no need to compute that.
                const x1 = x0 - i1 + Noise4.offset; // Offsets for second corner in (x,y,z,w) coords
                const y1 = y0 - j1 + Noise4.offset;
                const z1 = z0 - k1 + Noise4.offset;
                const w1 = w0 - l1 + Noise4.offset;
                const x2 = x0 - i2 + 2.0 * Noise4.offset; // Offsets for third corner in (x,y,z,w) coords
                const y2 = y0 - j2 + 2.0 * Noise4.offset;
                const z2 = z0 - k2 + 2.0 * Noise4.offset;
                const w2 = w0 - l2 + 2.0 * Noise4.offset;
                const x3 = x0 - i3 + 3.0 * Noise4.offset; // Offsets for fourth corner in (x,y,z,w) coords
                const y3 = y0 - j3 + 3.0 * Noise4.offset;
                const z3 = z0 - k3 + 3.0 * Noise4.offset;
                const w3 = w0 - l3 + 3.0 * Noise4.offset;
                const x4 = x0 - 1.0 + 4.0 * Noise4.offset; // Offsets for last corner in (x,y,z,w) coords
                const y4 = y0 - 1.0 + 4.0 * Noise4.offset;
                const z4 = z0 - 1.0 + 4.0 * Noise4.offset;
                const w4 = w0 - 1.0 + 4.0 * Noise4.offset;
                // Work out the hashed gradient indices of the five simplex corners
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                const ll = l & 255;
                const g0 = Noise4.gradient[this.perm[ii + this.perm[jj + this.perm[kk + this.perm[ll]]]] %
                    32];
                const g1 = Noise4.gradient[this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1 + this.perm[ll + l1]]]] % 32];
                const g2 = Noise4.gradient[this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2 + this.perm[ll + l2]]]] % 32];
                const g3 = Noise4.gradient[this.perm[ii + i3 + this.perm[jj + j3 + this.perm[kk + k3 + this.perm[ll + l3]]]] % 32];
                const g4 = Noise4.gradient[this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1 + this.perm[ll + 1]]]] % 32];
                // Calculate the contribution from the five corners
                const t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
                const n0 = t0 < 0
                    ? 0.0
                    : Math.pow(t0, 4) * (g0[0] * x0 + g0[1] * y0 + g0[2] * z0 + g0[3] * w0);
                const t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
                const n1 = t1 < 0
                    ? 0.0
                    : Math.pow(t1, 4) * (g1[0] * x1 + g1[1] * y1 + g1[2] * z1 + g1[3] * w1);
                const t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
                const n2 = t2 < 0
                    ? 0.0
                    : Math.pow(t2, 4) * (g2[0] * x2 + g2[1] * y2 + g2[2] * z2 + g2[3] * w2);
                const t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
                const n3 = t3 < 0
                    ? 0.0
                    : Math.pow(t3, 4) * (g3[0] * x3 + g3[1] * y3 + g3[2] * z3 + g3[3] * w3);
                const t4 = 0.5 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
                const n4 = t4 < 0
                    ? 0.0
                    : Math.pow(t4, 4) * (g4[0] * x4 + g4[1] * y4 + g4[2] * z4 + g4[3] * w4);
                // Sum up and scale the result to cover the range [-1,1]
                return 72.37855765153665 * (n0 + n1 + n2 + n3 + n4);
            };
        }
    }
    FudgeCore.Noise4 = Noise4;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
      * Storing and manipulating rotations in the form of quaternions.
      * Constructed out of the 4 components: (x, y, z, w). Mathematical notation: w + xi + yj + zk.
      * A Quaternion can be described with an axis and angle: (x, y, z) = sin(angle/2)*axis; w = cos(angle/2).
      * roll: x, pitch: y, yaw: z. Note that operations are adapted to work with vectors where y is up and z is forward.
      * @authors Matthias Roming, HFU, 2023 | Marko Fehrenbach, HFU, 2020 | Jonas Plotzky, HFU, 2023
      */
    class Quaternion extends FudgeCore.Mutable {
        #eulerAngles = FudgeCore.Vector3.ZERO(); // euler angle representation of this quaternion in degrees.
        #eulerAnglesDirty;
        constructor(_x = 0, _y = 0, _z = 0, _w = 1) {
            super();
            this.set(_x, _y, _z, _w);
        }
        /**
         * Retrieve a new identity quaternion
         */
        static IDENTITY() {
            return FudgeCore.Recycler.get(Quaternion);
        }
        /**
         * Returns a copy of the given quaternion scaled to length 1 (a unit quaternion) making it a valid rotation representation.
         * @param _out Optional quaternion to store the result in.
         */
        static NORMALIZATION(_quaternion, _out = FudgeCore.Recycler.reuse(Quaternion)) {
            return _out.copy(_quaternion).normalize();
        }
        /**
         * Returns a quaternion that rotates coordinates when multiplied by, using the angles given.
         * Rotation occurs around the axis in the order Z-Y-X.
         * @param _out Optional quaternion to store the result in.
         */
        static ROTATION_EULER_ANGLES(_eulerAngles, _out = FudgeCore.Recycler.reuse(Quaternion)) {
            _out.eulerAngles = _eulerAngles;
            return _out;
        }
        /**
         * Returns a quaternion that rotates coordinates when multiplied by, using the axis and angle given.
         * Axis must be normalized. Angle is in degrees.
         * @param _out Optional quaternion to store the result in.
         */
        static ROTATION_AXIS_ANGLE(_axis, _angle, _out = FudgeCore.Recycler.reuse(Quaternion)) {
            const halfAngle = _angle * FudgeCore.Calc.deg2rad / 2;
            const sinHalfAngle = Math.sin(halfAngle);
            return _out.set(_axis.x * sinHalfAngle, _axis.y * sinHalfAngle, _axis.z * sinHalfAngle, Math.cos(halfAngle));
        }
        /**
         * Returns a quaternion with the given forward and up direction.
         * @param _forward A unit vector indicating the desired forward-direction.
         * @param _up A unit vector indicating the up-direction.
         * @param _out Optional quaternion to store the result in.
         */
        static ROTATION_LOOK_IN(_forward, _up, _out = FudgeCore.Recycler.reuse(Quaternion)) {
            const right = FudgeCore.Vector3.CROSS(_up, _forward);
            const matrix = FudgeCore.Recycler.reuse(FudgeCore.Matrix4x4);
            matrix.set(right.x, right.y, right.z, 0, _up.x, _up.y, _up.z, 0, _forward.x, _forward.y, _forward.z, 0, 0, 0, 0, 1);
            _out.copy(matrix.quaternion);
            FudgeCore.Recycler.store(right);
            FudgeCore.Recycler.store(matrix);
            return _out;
        }
        /**
         * Returns a quaternion that will rotate one vector to align with another.
         * @param _from The normalized direction vector to rotate from.
         * @param _to The normalized direction vector to rotate to.
         * @param _out Optional quaternion to store the result in.
         */
        static ROTATION_FROM_TO(_from, _to, _out = FudgeCore.Recycler.reuse(Quaternion)) {
            const angle = Math.acos(FudgeCore.Vector3.DOT(_from, _to)) * FudgeCore.Calc.rad2deg;
            const axis = FudgeCore.Vector3.CROSS(_from, _to).normalize();
            Quaternion.ROTATION_AXIS_ANGLE(axis, angle, _out);
            FudgeCore.Recycler.store(axis);
            return _out;
        }
        static ROTATION(_vector, _angleOrUp) {
            const result = FudgeCore.Recycler.get(Quaternion);
            if (_angleOrUp == undefined) {
                result.eulerAngles = _vector;
            }
            else if (typeof _angleOrUp == "number") {
                let halfAngle = _angleOrUp * FudgeCore.Calc.deg2rad / 2;
                let sinHalfAngle = Math.sin(halfAngle);
                result.set(_vector.x * sinHalfAngle, _vector.y * sinHalfAngle, _vector.z * sinHalfAngle, Math.cos(halfAngle));
            }
            else {
                const right = FudgeCore.Vector3.CROSS(_angleOrUp, _vector);
                const matrix = FudgeCore.Recycler.reuse(FudgeCore.Matrix4x4);
                matrix.set(right.x, right.y, right.z, 0, _angleOrUp.x, _angleOrUp.y, _angleOrUp.z, 0, _vector.x, _vector.y, _vector.z, 0, 0, 0, 0, 1);
                result.copy(matrix.quaternion);
                FudgeCore.Recycler.store(right);
                FudgeCore.Recycler.store(matrix);
            }
            return result;
        }
        /**
         * Computes and returns the product of two passed quaternions.
         * @param _out Optional quaternion to store the result in.
         */
        static PRODUCT(_left, _right, _out = FudgeCore.Recycler.reuse(Quaternion)) {
            // from: http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
            const ax = _left.x;
            const ay = _left.y;
            const az = _left.z;
            const aw = _left.w;
            const bx = _right.x;
            const by = _right.y;
            const bz = _right.z;
            const bw = _right.w;
            _out.set(ax * bw + ay * bz - az * by + aw * bx, -ax * bz + ay * bw + az * bx + aw * by, ax * by - ay * bx + az * bw + aw * bz, -ax * bx - ay * by - az * bz + aw * bw);
            return _out;
        }
        /**
         * Computes and returns the inverse of a passed quaternion.
         * Quaternion is assumed to be normalized.
         * @param _out Optional quaternion to store the result in.
         */
        static INVERSE(_quaternion, _out = FudgeCore.Recycler.reuse(Quaternion)) {
            return Quaternion.CONJUGATE(_quaternion, _out); // q‚Åª¬π = q* / |q|¬≤ => |q|¬≤ = 1 => q‚Åª¬π = q*
        }
        /**
         * Computes and returns the conjugate of a passed quaternion.
         * @param _out Optional quaternion to store the result in.
         */
        static CONJUGATE(_quaternion, _out = FudgeCore.Recycler.reuse(Quaternion)) {
            return _out.set(-_quaternion.x, -_quaternion.y, -_quaternion.z, _quaternion.w);
        }
        /**
         * Returns the dot product of two quaternions.
         */
        static DOT(_a, _b) {
            return _a.x * _b.x + _a.y * _b.y + _a.z * _b.z + _a.w * _b.w;
        }
        /**
         * Returns the normalized linear interpolation between two quaternions. When t is 0 the result is a, when t is 1 the result is b. Clamps t between 0 and 1.
         * @param _out Optional quaternion to store the result in.
         */
        static LERP(_a, _b, _t, _out = FudgeCore.Recycler.reuse(Quaternion)) {
            _t = FudgeCore.Calc.clamp(_t, 0, 1);
            return _out.set((_a.x + _t * (_b.x - _a.x)), (_a.y + _t * (_b.y - _a.y)), (_a.z + _t * (_b.z - _a.z)), (_a.w + _t * (_b.w - _a.w))).normalize();
        }
        /**
         * Returns the spherical linear interpolation between two quaternions. When t is 0 the result is a, when t is 1 the result is b.
         * @param _out Optional quaternion to store the result in.
         */
        static SLERP(_a, _b, _t, _out = FudgeCore.Recycler.reuse(Quaternion)) {
            // From: https://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            let cosHalfTheta = _a.w * _b.w + _a.x * _b.x + _a.y * _b.y + _a.z * _b.z;
            if (Math.abs(cosHalfTheta) >= 1)
                return _out.copy(_a);
            let halfTheta = Math.acos(cosHalfTheta);
            let sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
            if (Math.abs(sinHalfTheta) < 1e-3) {
                return _out.set((_a.x * 0.5 + _b.x * 0.5), (_a.y * 0.5 + _b.y * 0.5), (_a.z * 0.5 + _b.z * 0.5), (_a.w * 0.5 + _b.w * 0.5));
            }
            let ratioA = Math.sin((1 - _t) * halfTheta) / sinHalfTheta;
            let ratioB = Math.sin(_t * halfTheta) / sinHalfTheta;
            return _out.set((_a.x * ratioA + _b.x * ratioB), (_a.y * ratioA + _b.y * ratioB), (_a.z * ratioA + _b.z * ratioB), (_a.w * ratioA + _b.w * ratioB));
        }
        /**
         * Return the angle in degrees between the two given quaternions.
         */
        static ANGLE(_from, _to) {
            return 2 * Math.acos(Math.abs(FudgeCore.Calc.clamp(Quaternion.DOT(_from, _to), -1, 1))) * FudgeCore.Calc.rad2deg;
        }
        /**
         * Negates the given quaternion.
         */
        static negate(_q) {
            _q.x = -_q.x;
            _q.y = -_q.y;
            _q.z = -_q.z;
            _q.w = -_q.w;
        }
        /**
         * Creates and returns a clone of this quaternion.
         */
        get clone() {
            return FudgeCore.Recycler.reuse(Quaternion).copy(this);
        }
        /**
         * - get: return the euler angle representation of the rotation in degrees.
         * **Caution!** Use immediately and readonly, since the vector is going to be reused internally. Create a clone to keep longer and manipulate.
         * - set: set the euler angle representation of the rotation in degrees.
         */
        get eulerAngles() {
            if (this.#eulerAnglesDirty) {
                this.#eulerAnglesDirty = false;
                // roll (x-axis rotation)
                let sinrcosp = 2 * (this.w * this.x + this.y * this.z);
                let cosrcosp = 1 - 2 * (this.x * this.x + this.y * this.y);
                this.#eulerAngles.x = Math.atan2(sinrcosp, cosrcosp);
                // pitch (y-axis rotation)
                let sinp = 2 * (this.w * this.y - this.z * this.x);
                if (Math.abs(sinp) >= 1)
                    this.#eulerAngles.y = sinp < 0 ? -Math.abs(Math.PI / 2) : Math.abs(Math.PI / 2); // use 90 degrees if out of range
                else
                    this.#eulerAngles.y = Math.asin(sinp);
                // yaw (z-axis rotation)
                let sinycosp = 2 * (this.w * this.z + this.x * this.y);
                let cosycosp = 1 - 2 * (this.y * this.y + this.z * this.z);
                this.#eulerAngles.z = Math.atan2(sinycosp, cosycosp);
                this.#eulerAngles.scale(FudgeCore.Calc.rad2deg);
            }
            return this.#eulerAngles;
        }
        set eulerAngles(_eulerAngles) {
            const halfdeg2rad = FudgeCore.Calc.deg2rad / 2;
            const x = _eulerAngles.x * halfdeg2rad, y = _eulerAngles.y * halfdeg2rad, z = _eulerAngles.z * halfdeg2rad;
            const cosX = Math.cos(x);
            const cosY = Math.cos(y);
            const cosZ = Math.cos(z);
            const sinX = Math.sin(x);
            const sinY = Math.sin(y);
            const sinZ = Math.sin(z);
            this.x = sinX * cosY * cosZ - cosX * sinY * sinZ;
            this.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
            this.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
            this.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            // this.set(
            //   sinX * cosY * cosZ - cosX * sinY * sinZ,
            //   cosX * sinY * cosZ + sinX * cosY * sinZ,
            //   cosX * cosY * sinZ - sinX * sinY * cosZ,
            //   cosX * cosY * cosZ + sinX * sinY * sinZ
            // );
            this.#eulerAngles.copy(_eulerAngles);
            this.#eulerAnglesDirty = false;
        }
        /**
         * Copies the given quaternion.
         * @returns A reference to this quaternion.
         */
        copy(_original) {
            this.x = _original.x;
            this.y = _original.y;
            this.z = _original.z;
            this.w = _original.w;
            this.#eulerAnglesDirty = _original.#eulerAnglesDirty;
            if (!this.#eulerAnglesDirty)
                this.#eulerAngles.copy(_original.#eulerAngles);
            // this.mutator = null;
            return this;
        }
        /**
         * Resets the quaternion to the identity-quaternion and clears cache. Used by the recycler to reset.
         */
        recycle() {
            this.set(0, 0, 0, 1);
        }
        /**
         * Sets the components of this quaternion.
         * @returns A reference to this quaternion.
         */
        set(_x, _y, _z, _w) {
            this.x = _x;
            this.y = _y;
            this.z = _z;
            this.w = _w;
            this.resetCache();
            return this;
        }
        /**
         * Returns true if this quaternion is equal to the given quaternion within the given tolerance.
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            return Math.abs(this.x - _compare.x) <= _tolerance &&
                Math.abs(this.y - _compare.y) <= _tolerance &&
                Math.abs(this.z - _compare.z) <= _tolerance &&
                Math.abs(this.w - _compare.w) <= _tolerance;
        }
        /**
         * Normalizes this quaternion to a length of 1 (a unit quaternion) making it a valid rotation representation.
         * @returns A reference to this quaternion.
         */
        normalize() {
            let length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            if (length === 0) {
                this.set(0, 0, 0, 1);
            }
            else {
                length = 1 / length;
                this.x *= length;
                this.y *= length;
                this.z *= length;
                this.w *= length;
            }
            this.resetCache();
            return this;
        }
        /**
         * Negates this quaternion.
         * @returns A reference to this quaternion.
         */
        negate() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            this.resetCache();
            return this;
        }
        /**
         * Invert this quaternion.
         * Quaternion is assumed to be normalized.
         * @returns A reference to this quaternion.
         */
        invert() {
            return this.conjugate();
        }
        /**
         * Conjugates this quaternion and returns it.
         * @returns A reference to this quaternion.
         */
        conjugate() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.resetCache();
            return this;
        }
        /**
         * Multiply this quaternion with the given quaternion.
         * @returns A reference to this quaternion.
         */
        multiply(_quaternion, _fromLeft = false) {
            return Quaternion.PRODUCT(this, _quaternion, this);
        }
        /**
         * Premultiply this quaternion with the given quaternion.
         * @returns A reference to this quaternion.
         */
        premultiply(_quaternion) {
            return Quaternion.PRODUCT(_quaternion, this, this);
        }
        /**
         * Returns a formatted string representation of this quaternion
         */
        toString() {
            return `∆í.Quaternion(x: ${this.x}, y: ${this.y}, z: ${this.z}, w: ${this.w})`;
        }
        // currently quaternions are never serialized, so this is not needed. But maybe it will be in the future.
        serialize() {
            let serialization = this.getMutator();
            serialization.toJSON = () => { return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.x, this.y, this.z, this.w] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        mutate(_mutator) {
            if (_mutator.x != undefined)
                this.x = _mutator.x;
            if (_mutator.y != undefined)
                this.y = _mutator.y;
            if (_mutator.z != undefined)
                this.z = _mutator.z;
            if (_mutator.w != undefined)
                this.w = _mutator.w;
            this.resetCache();
        }
        reduceMutator(_mutator) { }
        resetCache() {
            this.#eulerAnglesDirty = true;
        }
    }
    FudgeCore.Quaternion = Quaternion;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Class for creating random values, supporting Javascript's Math.random and a deterministig pseudo-random number generator (PRNG)
     * that can be fed with a seed and then returns a reproducable set of random numbers (if the precision of Javascript allows)
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Random {
        static { this.default = new Random(); }
        /**
         * Create an instance of {@link Random}.
         * If a seed is given, LFIB4 is used as generator, reproducing a series of numbers from that seed.
         * If a function producing values between 0 and 1 is given, it will be used as generator.
         */
        constructor(_seedOrFunction) {
            this.generate = Math.random;
            if (_seedOrFunction instanceof Function)
                this.generate = _seedOrFunction;
            else if (_seedOrFunction == undefined)
                this.generate = Math.random;
            else
                //@ts-ignore
                this.generate = new FudgeCore.LFIB4(_seedOrFunction);
        }
        /**
         * Returns a normed random number, thus in the range of [0, 1[
         */
        getNorm() {
            return this.generate();
        }
        /**
         * Returns a random number in the range of given [_min, _max[
         */
        getRange(_min, _max) {
            return _min + this.generate() * (_max - _min);
        }
        /**
         * Returns a random integer number in the range of given floored [_min, _max[
         */
        getRangeFloored(_min, _max) {
            return Math.floor(this.getRange(_min, _max));
        }
        /**
         * Returns true or false randomly
         */
        getBoolean() {
            return this.generate() < 0.5;
        }
        /**
         * Returns -1 or 1 randomly
         */
        getSign() {
            return this.getBoolean() ? 1 : -1;
        }
        /**
         * Returns a randomly selected index into the given array
         */
        getIndex(_array) {
            if (_array.length > 0)
                return this.getRangeFloored(0, _array.length);
            return -1;
        }
        /**
         * Returns a randomly selected element of the given array
         */
        getElement(_array) {
            if (_array.length > 0)
                return _array[this.getIndex(_array)];
            return null;
        }
        /**
         * Removes a randomly selected element from the given array and returns it
         */
        splice(_array) {
            return _array.splice(this.getIndex(_array), 1)[0];
        }
        /**
         * Returns a randomly selected key from the given Map-instance
         */
        getKey(_map) {
            let keys = Array.from(_map.keys());
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a randomly selected property name from the given object
         */
        getPropertyName(_object) {
            let keys = Object.getOwnPropertyNames(_object);
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a randomly selected symbol from the given object, if symbols are used as keys
         */
        getPropertySymbol(_object) {
            let keys = Object.getOwnPropertySymbols(_object);
            return keys[this.getIndex(keys)];
        }
        /**
         * Returns a random three-dimensional vector in the limits of the box defined by the vectors given as [_corner0, _corner1[
         */
        getVector3(_corner0, _corner1) {
            return new FudgeCore.Vector3(this.getRange(_corner0.x, _corner1.x), this.getRange(_corner0.y, _corner1.y), this.getRange(_corner0.z, _corner1.z));
        }
        /**
         * Returns a random two-dimensional vector in the limits of the rectangle defined by the vectors given as [_corner0, _corner1[
         */
        getVector2(_corner0, _corner1) {
            return new FudgeCore.Vector2(this.getRange(_corner0.x, _corner1.x), this.getRange(_corner0.y, _corner1.y));
        }
        /**
         * Returns a color with its r, g, b values set to random numbers in the range of [0, 1[.
         */
        getColor() {
            return new FudgeCore.Color(this.getNorm(), this.getNorm(), this.getNorm(), 1);
        }
    }
    FudgeCore.Random = Random;
    /**
     * Standard {@link Random}-instance using Math.random().
     */
    FudgeCore.random = new Random();
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a threedimensional vector comprised of the components x, y and z
     * ```text
     *            +y
     *             |__ +x
     *            /
     *          +z
     * ```
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019-2022 | Jonas Plotzky, HFU, 2023
     */
    class Vector3 extends FudgeCore.Mutable {
        /**
         * Array of the keys of a vector. Allows to translate an index (0, 1, 2) to a key ("x", "y", "z") or to iterate over a vector.
         */
        static { this.keys = ["x", "y", "z"]; }
        constructor(_x = 0, _y = 0, _z = 0) {
            super();
            this.set(_x, _y, _z);
        }
        //#region Static
        /**
         * Creates and returns a vector with the given length pointing in x-direction
         */
        static X(_scale = 1) {
            return FudgeCore.Recycler.reuse(Vector3).set(_scale, 0, 0);
        }
        /**
         * Creates and returns a vector with the given length pointing in y-direction
         */
        static Y(_scale = 1) {
            return FudgeCore.Recycler.reuse(Vector3).set(0, _scale, 0);
        }
        /**
         * Creates and returns a vector with the given length pointing in z-direction
         */
        static Z(_scale = 1) {
            return FudgeCore.Recycler.reuse(Vector3).set(0, 0, _scale);
        }
        /**
         * Creates and returns a vector with the value 0 on each axis
         */
        static ZERO() {
            return FudgeCore.Recycler.get(Vector3);
        }
        /**
         * Creates and returns a vector of the given size on each of the three axis
         */
        static ONE(_scale = 1) {
            return FudgeCore.Recycler.reuse(Vector3).set(_scale, _scale, _scale);
        }
        /**
         * Creates and returns a vector through transformation of the given vector by the given matrix or rotation quaternion.
         * @param _out Optional vector to store the result in.
         */
        static TRANSFORMATION(_vector, _transform, _includeTranslation = true, _out = FudgeCore.Recycler.reuse(Vector3)) {
            if (_transform instanceof FudgeCore.Matrix4x4) {
                const m = _transform.getArray();
                _out.set(m[0] * _vector.x + m[4] * _vector.y + m[8] * _vector.z, m[1] * _vector.x + m[5] * _vector.y + m[9] * _vector.z, m[2] * _vector.x + m[6] * _vector.y + m[10] * _vector.z);
                if (_includeTranslation)
                    _out.add(_transform.translation);
                return _out;
            }
            // From: https://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/transforms/index.htm
            // out = q * quaternion(vector.x, vector.y, vector.z, 0) * conj(q)
            // q * quaternion(vector.x, vector.y, vector.z, 0) ...
            const qx = _transform.w * _vector.x + _transform.y * _vector.z - _transform.z * _vector.y;
            const qy = _transform.w * _vector.y + _transform.z * _vector.x - _transform.x * _vector.z;
            const qz = _transform.w * _vector.z + _transform.x * _vector.y - _transform.y * _vector.x;
            const qw = -_transform.x * _vector.x - _transform.y * _vector.y - _transform.z * _vector.z;
            // ... * conj(q)
            return _out.set(qx * _transform.w + qw * -_transform.x + qy * -_transform.z - qz * -_transform.y, qy * _transform.w + qw * -_transform.y + qz * -_transform.x - qx * -_transform.z, qz * _transform.w + qw * -_transform.z + qx * -_transform.y - qy * -_transform.x);
        }
        /**
         * Creates and returns a vector which is a copy of the given vector scaled to the given length.
         * @param _out Optional vector to store the result in.
         */
        static NORMALIZATION(_vector, _length = 1, _out = FudgeCore.Recycler.reuse(Vector3)) {
            return _out.copy(_vector).normalize(_length);
        }
        /**
         * Returns the result of the addition of two vectors.
         * @param _out Optional vector to store the result in.
         */
        static SUM(_a, _b, _out = FudgeCore.Recycler.reuse(Vector3)) {
            return _out.set(_a.x + _b.x, _a.y + _b.y, _a.z + _b.z);
        }
        /**
         * Returns the result of the subtraction of two vectors.
         * @param _out Optional vector to store the result in.
         */
        static DIFFERENCE(_minuend, _subtrahend, _out = FudgeCore.Recycler.reuse(Vector3)) {
            return _out.set(_minuend.x - _subtrahend.x, _minuend.y - _subtrahend.y, _minuend.z - _subtrahend.z);
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor.
         * @param _out Optional vector to store the result in.
         */
        static SCALE(_vector, _scaling, _out = FudgeCore.Recycler.reuse(Vector3)) {
            return _out.set(_vector.x * _scaling, _vector.y * _scaling, _vector.z * _scaling);
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor.
         * @param _out Optional vector to store the result in.
         */
        static NEGATION(_vector, _out = FudgeCore.Recycler.reuse(Vector3)) {
            return _out.set(-_vector.x, -_vector.y, -_vector.z);
        }
        /**
         * Divides the dividend by the divisor component by component and returns the result.
         * @param _out Optional vector to store the result in.
         */
        static RATIO(_dividend, _divisor, _out = FudgeCore.Recycler.reuse(Vector3)) {
            return _out.set(_dividend.x / _divisor.x, _dividend.y / _divisor.y, _dividend.z / _divisor.z);
        }
        /**
         * Computes the crossproduct of 2 vectors.
         * @param _out Optional vector to store the result in.
         */
        static CROSS(_a, _b, _out = FudgeCore.Recycler.reuse(Vector3)) {
            return _out.set(_a.y * _b.z - _a.z * _b.y, _a.z * _b.x - _a.x * _b.z, _a.x * _b.y - _a.y * _b.x);
        }
        /**
         * Computes the dotproduct of 2 vectors.
         */
        static DOT(_a, _b) {
            return _a.x * _b.x + _a.y * _b.y + _a.z * _b.z;
        }
        /**
         * Calculates and returns the reflection of the incoming vector at the given normal vector. The length of normal should be 1.
         * ```text
         * _________________________
         *           /|\
         * incoming / | \ reflection
         *         /  |  \
         *          normal
         * ```
         * @param _out Optional vector to store the result in.
         */
        static REFLECTION(_incoming, _normal, _out = FudgeCore.Recycler.reuse(Vector3)) {
            if (_out == _incoming) // clone _incoming to allow reading from it
                FudgeCore.Recycler.store(_incoming = _incoming.clone); // dangerous, this only works because sup-method calls don't fetch from recycler
            return Vector3.SUM(_incoming, Vector3.SCALE(_normal, 2 * -Vector3.DOT(_incoming, _normal), _out), _out);
        }
        /**
         * Creates a cartesian vector from geographic coordinates.
         * @param _out Optional vector to store the result in.
         */
        static GEO(_longitude = 0, _latitude = 0, _magnitude = 1, _out = FudgeCore.Recycler.reuse(Vector3)) {
            const geo = FudgeCore.Recycler.reuse(FudgeCore.Geo3).set(_longitude, _latitude, _magnitude);
            _out.geo = geo;
            FudgeCore.Recycler.store(geo);
            return _out;
        }
        /**
         * Return the angle in degrees between the two given vectors.
         */
        static ANGLE(_from, _to) {
            let angle = Math.acos(FudgeCore.Calc.clamp(Vector3.DOT(_from, _to) / (_from.magnitude * _to.magnitude), -1, 1)); // clamp because of floating point errors when from == to
            return angle * FudgeCore.Calc.rad2deg;
        }
        /**
         * Return the projection of a onto b.
         * @param _out Optional vector to store the result in.
         */
        static PROJECTION(_a, _b, _out = FudgeCore.Recycler.reuse(Vector3)) {
            return _out.copy(_a).project(_b);
        }
        /**
         * Returns the linear interpolation between two vectors. When t is 0 the result is a, when t is 1 the result is b. Clamps t between 0 and 1.
         * @param _out Optional vector to store the result in.
         */
        static LERP(_a, _b, _t, _out = FudgeCore.Recycler.reuse(Vector3)) {
            _t = FudgeCore.Calc.clamp(_t, 0, 1);
            return _out.set(_a.x + _t * (_b.x - _a.x), _a.y + _t * (_b.y - _a.y), _a.z + _t * (_b.z - _a.z));
        }
        /**
         * Smoothly interpolates between two vectors based on a critically damped spring model.
         * Allows to smooth toward a moving target with an ease-in/ease-out motion maintaining a continuous velocity.
         * Does not overshoot.
         * @param _current - The current value.
         * @param _target - The target value.
         * @param _velocity - The velocity at which the value is moving. This value is **modified** by the function and must be maintained in the outside context.
         * @param _smoothTime - The time it would take for the value to reach the target if it were moving at maximum velocity for the entire duration. When following a moving target the smooth time equals the lag time allowing to calculate the `lag distance = target velocity * smooth time`.
         * @param _timeFrame - The elapsed time since the last call to the function.
         * @param _maxSpeed - An optional maximum speed that limits the velocity of the value. Defaults to Infinity.
         * @param _out Optional vector to store the result in.
         * @source from Andrew Kirmse, Game Programming Gems 4, Chapter 1.10
         */
        static SMOOTHDAMP(_current, _target, _velocity, _smoothTime, _timeFrame, _maxSpeed = Infinity, _out = FudgeCore.Recycler.reuse(Vector3)) {
            const omega = 2 / _smoothTime;
            const x = omega * _timeFrame;
            const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x); // approximation of e ^ -omega * timeFrame
            let changeX = _current.x - _target.x;
            let changeY = _current.y - _target.y;
            let changeZ = _current.z - _target.z;
            const maxChange = _maxSpeed * _smoothTime;
            const magnitudeSquared = changeX * changeX + changeY * changeY + changeZ * changeZ;
            let targetX;
            let targetY;
            let targetZ;
            if (magnitudeSquared > maxChange * maxChange) {
                let scalar = maxChange / Math.sqrt(magnitudeSquared); // normalize to maxChange
                changeX *= scalar;
                changeY *= scalar;
                changeZ *= scalar;
                // change = current - target  ==  target = current - change
                targetX = _current.x - changeX;
                targetY = _current.y - changeY;
                targetZ = _current.z - changeZ;
            }
            else {
                targetX = _target.x;
                targetY = _target.y;
                targetZ = _target.z;
            }
            let tempX = (_velocity.x + omega * changeX) * _timeFrame;
            let tempY = (_velocity.y + omega * changeY) * _timeFrame;
            let tempZ = (_velocity.z + omega * changeZ) * _timeFrame;
            _velocity.x = (_velocity.x - omega * tempX) * exp;
            _velocity.y = (_velocity.y - omega * tempY) * exp;
            _velocity.z = (_velocity.z - omega * tempZ) * exp;
            _out.x = targetX + (changeX + tempX) * exp;
            _out.y = targetY + (changeY + tempY) * exp;
            _out.z = targetZ + (changeZ + tempZ) * exp;
            return _out;
        }
        //#endregion
        //#region Accessors
        /**
         * Returns the length of the vector
         */
        get magnitude() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        /**
         * Returns the square of the magnitude of the vector without calculating a square root. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        /**
         * - get: Returns a geographic representation of this vector
         * - set: Adjusts the cartesian values of this vector to represent the given as geographic coordinates
         */
        get geo() {
            let geo = FudgeCore.Recycler.get(FudgeCore.Geo3);
            geo.magnitude = this.magnitude;
            if (geo.magnitude === 0)
                return geo;
            geo.longitude = 180 * Math.atan2(this.x / geo.magnitude, this.z / geo.magnitude) / Math.PI;
            geo.latitude = 180 * Math.asin(this.y / geo.magnitude) / Math.PI;
            return geo;
        }
        set geo(_geo) {
            this.set(0, 0, _geo.magnitude);
            const mtxRotationX = FudgeCore.Matrix4x4.ROTATION_X(_geo.latitude);
            const mtxRotationY = FudgeCore.Matrix4x4.ROTATION_Y(_geo.longitude);
            this.transform(mtxRotationX);
            this.transform(mtxRotationY);
            FudgeCore.Recycler.store(mtxRotationX);
            FudgeCore.Recycler.store(mtxRotationY);
        }
        /**
         * Creates and returns a clone of this vector.
         */
        get clone() {
            return FudgeCore.Recycler.reuse(Vector3).copy(this);
        }
        //#endregion
        /**
         * Copies the components of the given vector into this vector.
         * @returns A reference to this vector.
         */
        copy(_original) {
            this.x = _original.x;
            this.y = _original.y;
            this.z = _original.z;
            return this;
        }
        /**
         * Sets the components of this vector and returns it.
         * @returns A reference to this vector.
         */
        set(_x = 0, _y = 0, _z = 0) {
            this.x = _x;
            this.y = _y;
            this.z = _z;
            return this;
        }
        recycle() {
            this.set(0, 0, 0);
        }
        /**
         * Returns true if the coordinates of this and the given vector are to be considered identical within the given tolerance
         * TODO: examine, if tolerance as criterium for the difference is appropriate with very large coordinate values or if _tolerance should be multiplied by coordinate value
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            if (Math.abs(this.x - _compare.x) > _tolerance)
                return false;
            if (Math.abs(this.y - _compare.y) > _tolerance)
                return false;
            if (Math.abs(this.z - _compare.z) > _tolerance)
                return false;
            return true;
        }
        /**
         * Returns true if the position described by this is within a cube with the opposite corners 1 and 2.
         */
        isInsideCube(_corner1, _corner2) {
            const diagonal = Vector3.DIFFERENCE(_corner2, _corner1);
            const relative = Vector3.DIFFERENCE(this, _corner1);
            const ratio = Vector3.RATIO(relative, diagonal);
            FudgeCore.Recycler.store(diagonal);
            FudgeCore.Recycler.store(relative);
            FudgeCore.Recycler.store(ratio);
            if (ratio.x > 1 || ratio.x < 0)
                return false;
            if (ratio.y > 1 || ratio.y < 0)
                return false;
            if (ratio.z > 1 || ratio.z < 0)
                return false;
            return true;
        }
        /**
         * Returns true if the position described by this is within a sphere with the given center and radius.
         */
        isInsideSphere(_center, _radius) {
            const difference = Vector3.DIFFERENCE(this, _center);
            FudgeCore.Recycler.store(difference);
            return difference.magnitudeSquared < (_radius * _radius);
        }
        /**
         * Returns the distance bewtween this vector and the given vector.
         */
        getDistance(_to) {
            let difference = Vector3.DIFFERENCE(this, _to);
            FudgeCore.Recycler.store(difference);
            return difference.magnitude;
        }
        /**
         * Adds the given vector to this vector.
         * @returns A reference to this vector.
         */
        add(_addend) {
            this.x += _addend.x;
            this.y += _addend.y;
            this.z += _addend.z;
            return this;
        }
        /**
         * Subtracts the given vector from this vector.
         * @returns A reference to this vector.
         */
        subtract(_subtrahend) {
            this.x -= _subtrahend.x;
            this.y -= _subtrahend.y;
            this.z -= _subtrahend.z;
            return this;
        }
        /**
         * Scales this vector by the given scalar.
         * @returns A reference to this vector.
         */
        scale(_scalar) {
            this.x *= _scalar;
            this.y *= _scalar;
            this.z *= _scalar;
            return this;
        }
        /**
         * Negates this vector by flipping the signs of its components
         * @returns A reference to this vector.
         */
        negate() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        }
        /**
         * Normalizes this to the given length, 1 by default
         * @returns A reference to this vector.
         */
        normalize(_length = 1) {
            let magnitudeSquared = this.magnitudeSquared;
            if (magnitudeSquared == 0)
                throw (new RangeError("Impossible normalization"));
            this.scale(_length / Math.sqrt(magnitudeSquared));
            return this;
        }
        /**
         * Reflects this vector at a given normal. See {@link Vector3.REFLECTION}.
         * @returns A reference to this vector.
         */
        reflect(_normal) {
            return Vector3.REFLECTION(this, _normal, this);
        }
        /**
         * Projects this vector onto the given vector.
         * @returns A reference to this vector.
         */
        project(_on) {
            let scalar = Vector3.DOT(this, _on) / _on.magnitudeSquared;
            this.x = _on.x * scalar;
            this.y = _on.y * scalar;
            this.z = _on.z * scalar;
            return this;
        }
        /**
         * Transforms this vector by the given matrix or rotation quaternion.
         * Including or exluding the translation if a matrix is passed.
         * Including is the default, excluding will only rotate and scale this vector.
         * @returns A reference to this vector.
         */
        transform(_transform, _includeTranslation = true) {
            return Vector3.TRANSFORMATION(this, _transform, _includeTranslation, this);
        }
        /**
         * Shuffles the components of this vector.
         * @returns A reference to this vector.
         */
        shuffle() {
            // Durstenfeld shuffle
            for (let i = Vector3.keys.length - 1, j; i > 0; i--) {
                j = Math.floor(Math.random() * (i + 1)); // Random.default.getRangeFloored(0, i + 1);
                const temp = this[Vector3.keys[i]];
                this[Vector3.keys[i]] = this[Vector3.keys[j]];
                this[Vector3.keys[j]] = temp;
            }
            return this;
        }
        /**
         * For each dimension, moves the component to the minimum of this and the given vector.
         * @returns A reference to this vector.
         */
        min(_compare) {
            this.x = Math.min(this.x, _compare.x);
            this.y = Math.min(this.y, _compare.y);
            this.z = Math.min(this.z, _compare.z);
            return this;
        }
        /**
         * For each dimension, moves the component to the maximum of this and the given vector.
         * @returns A reference to this vector.
         */
        max(_compare) {
            this.x = Math.max(this.x, _compare.x);
            this.y = Math.max(this.y, _compare.y);
            this.z = Math.max(this.z, _compare.z);
            return this;
        }
        /**
         * Calls a defined callback function on each component of the vector, and returns a new vector that contains the results. Similar to {@link Array.map}.
         * @param _out Optional vector to store the result in.
         */
        map(_function, _out = FudgeCore.Recycler.reuse(Vector3)) {
            _out.x = _function(this.x, 0, "x", this);
            _out.y = _function(this.y, 1, "y", this);
            _out.z = _function(this.z, 2, "z", this);
            return _out;
        }
        /**
         * Calls a defined callback function on each component of the vector and assigns the result to the component. Similar to {@link Vector3.map} but mutates this vector instead of creating a new one.
         * @returns A reference to this vector.
         */
        apply(_function) {
            this.x = _function(this.x, 0, "x", this);
            this.y = _function(this.y, 1, "y", this);
            this.z = _function(this.z, 2, "z", this);
            return this;
        }
        /**
         * Returns an array of the components of this vector.
         */
        get() {
            return new Float32Array([this.x, this.y, this.z]);
        }
        /**
         * Copys the elements of this vector into the given array starting at the given offset.
         * @returns A reference to the given array.
         */
        toArray(_out, _offset = 0) {
            _out[_offset] = this.x;
            _out[_offset + 1] = this.y;
            _out[_offset + 2] = this.z;
            return _out;
        }
        /**
         * Drops the z-component and returns a Vector2 consisting of the x- and y-components.
         * @param _out Optional vector to store the result in.
         */
        toVector2(_out = FudgeCore.Recycler.reuse(FudgeCore.Vector2)) {
            return _out.set(this.x, this.y);
        }
        /**
         * Returns a formatted string representation of this vector
         */
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)}, ${this.z.toPrecision(5)})`;
            return result;
        }
        //#region Transfer
        serialize() {
            let serialization = this.getMutator();
            // serialization.toJSON = () => { return `{ "r": ${this.r}, "g": ${this.g}, "b": ${this.b}, "a": ${this.a}}`; };
            serialization.toJSON = () => { return `[${this.x}, ${this.y}, ${this.z}]`; };
            return serialization;
        }
        async deserialize(_serialization) {
            if (typeof (_serialization) == "string") {
                [this.x, this.y, this.z] = JSON.parse(_serialization);
            }
            else
                this.mutate(_serialization);
            return this;
        }
        mutate(_mutator) {
            if (_mutator.x != undefined)
                this.x = _mutator.x;
            if (_mutator.y != undefined)
                this.y = _mutator.y;
            if (_mutator.z != undefined)
                this.z = _mutator.z;
        }
        getMutator() {
            let mutator = { x: this.x, y: this.y, z: this.z };
            return mutator;
        }
        reduceMutator(_mutator) { }
    }
    FudgeCore.Vector3 = Vector3;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores and manipulates a fourdimensional vector comprised of the components x, y, z and w.
     * @authors Jonas Plotzky, HFU, 2023
     */
    class Vector4 extends FudgeCore.Mutable {
        constructor(_x = 0, _y = 0, _z = 0, _w = 0) {
            super();
            this.set(_x, _y, _z, _w);
        }
        /**
         * Creates and returns a vector which is a copy of the given vector scaled to the given length.
         * @param _out Optional vector to store the result in.
         */
        static NORMALIZATION(_vector, _length = 1, _out = FudgeCore.Recycler.reuse(Vector4)) {
            return _out.copy(_vector).normalize(_length);
        }
        /**
         * Returns the result of the addition of two vectors.
         * @param _out Optional vector to store the result in.
         */
        static SUM(_a, _b, _out = FudgeCore.Recycler.reuse(Vector4)) {
            return _out.set(_a.x + _b.x, _a.y + _b.y, _a.z + _b.z, _a.w + _b.w);
        }
        /**
         * Returns the result of the subtraction of two vectors.
         * @param _out Optional vector to store the result in.
         */
        static DIFFERENCE(_minuend, _subtrahend, _out = FudgeCore.Recycler.reuse(Vector4)) {
            return _out.set(_minuend.x - _subtrahend.x, _minuend.y - _subtrahend.y, _minuend.z - _subtrahend.z, _minuend.w - _subtrahend.w);
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor.
         * @param _out Optional vector to store the result in.
         */
        static SCALE(_vector, _scaling, _out = FudgeCore.Recycler.reuse(Vector4)) {
            return _out.set(_vector.x * _scaling, _vector.y * _scaling, _vector.z * _scaling, _vector.w * _scaling);
        }
        /**
         * Returns a new vector representing the given vector scaled by the given scaling factor.
         * @param _out Optional vector to store the result in.
         */
        static NEGATION(_vector, _out = FudgeCore.Recycler.reuse(Vector4)) {
            return _out.set(-_vector.x, -_vector.y, -_vector.z, -_vector.w);
        }
        /**
         * Computes the dotproduct of 2 vectors.
         */
        static DOT(_a, _b) {
            return _a.x * _b.x + _a.y * _b.y + _a.z * _b.z + _a.w * _b.w;
        }
        /**
         * The magnitude (length) of the vector.
         */
        get magnitude() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        /**
         * The squared magnitude (length) of the vector. Faster for simple proximity evaluation.
         */
        get magnitudeSquared() {
            return Vector4.DOT(this, this);
        }
        /**
         * Creates and returns a clone of this vector.
         */
        get clone() {
            return FudgeCore.Recycler.reuse(Vector4).copy(this);
        }
        /**
         * Copies the components of the given vector into this vector.
         * @returns A reference to this vector.
         */
        copy(_original) {
            this.x = _original.x;
            this.y = _original.y;
            this.z = _original.z;
            this.w = _original.w;
            return this;
        }
        /**
         * Sets the components of this vector and returns it.
         * @returns A reference to this vector.
         */
        set(_x, _y, _z, _w) {
            this.x = _x;
            this.y = _y;
            this.z = _z;
            this.w = _w;
            return this;
        }
        /**
         * Returns an array of the components of this vector. // TODO: remove this
         */
        get() {
            return [this.x, this.y, this.z, this.w];
        }
        recycle() {
            this.set(0, 0, 0, 0);
        }
        /**
         * Returns true if this vector is equal to the given vector within the given tolerance.
         */
        equals(_compare, _tolerance = Number.EPSILON) {
            return Math.abs(this.x - _compare.x) <= _tolerance &&
                Math.abs(this.y - _compare.y) <= _tolerance &&
                Math.abs(this.z - _compare.z) <= _tolerance &&
                Math.abs(this.w - _compare.w) <= _tolerance;
        }
        /**
         * Adds the given vector to this vector.
         * @returns A reference to this vector.
         */
        add(_addend) {
            this.x += _addend.x;
            this.y += _addend.y;
            this.z += _addend.z;
            this.w += _addend.w;
            return this;
        }
        /**
         * Subtracts the given vector from this vector.
         * @returns A reference to this vector.
         */
        subtract(_subtrahend) {
            this.x -= _subtrahend.x;
            this.y -= _subtrahend.y;
            this.z -= _subtrahend.z;
            this.w -= _subtrahend.w;
            return this;
        }
        /**
         * Scales this vector by the given scalar.
         * @returns A reference to this vector.
         */
        scale(_scalar) {
            this.x *= _scalar;
            this.y *= _scalar;
            this.z *= _scalar;
            this.w *= _scalar;
            return this;
        }
        /**
         * Negates this vector by flipping the signs of its components
         * @returns A reference to this vector.
         */
        negate() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this;
        }
        /**
         * Normalizes this vector to the given length, 1 by default.
         * @returns A reference to this vector.
         */
        normalize(_length = 1) {
            let magnitudeSquared = this.magnitudeSquared;
            if (magnitudeSquared == 0)
                throw (new RangeError("Impossible normalization"));
            this.scale(_length / Math.sqrt(magnitudeSquared));
            return this;
        }
        /**
         * For each dimension, moves the component to the minimum of this and the given vector.
         * @returns A reference to this vector.
         */
        min(_compare) {
            this.x = Math.min(this.x, _compare.x);
            this.y = Math.min(this.y, _compare.y);
            this.z = Math.min(this.z, _compare.z);
            this.w = Math.min(this.w, _compare.w);
            return this;
        }
        /**
         * For each dimension, moves the component to the maximum of this and the given vector.
         * @returns A reference to this vector.
         */
        max(_compare) {
            this.x = Math.max(this.x, _compare.x);
            this.y = Math.max(this.y, _compare.y);
            this.z = Math.max(this.z, _compare.z);
            this.w = Math.max(this.w, _compare.w);
            return this;
        }
        /**
         * Calls a defined callback function on each component of the vector, and returns a new vector that contains the results. Similar to {@link Array.map}.
         * @param _out Optional vector to store the result in.
         */
        map(_function, _out = FudgeCore.Recycler.reuse(Vector4)) {
            _out.x = _function(this.x, 0, "x", this);
            _out.y = _function(this.y, 1, "y", this);
            _out.z = _function(this.z, 2, "z", this);
            _out.w = _function(this.w, 3, "w", this);
            return _out;
        }
        /**
         * Calls a defined callback function on each component of the vector and assigns the result to the component. Similar to {@link Vector4.map} but mutates this vector instead of creating a new one.
         * @returns A reference to this vector.
         */
        apply(_function) {
            this.x = _function(this.x, 0, "x", this);
            this.y = _function(this.y, 1, "y", this);
            this.z = _function(this.z, 2, "z", this);
            this.w = _function(this.w, 3, "w", this);
            return this;
        }
        /**
         * Copys the elements of this vector into the given array starting at the given offset.
         * @returns A reference to the given array.
         */
        toArray(_out, _offset = 0) {
            _out[_offset] = this.x;
            _out[_offset + 1] = this.y;
            _out[_offset + 2] = this.z;
            _out[_offset + 3] = this.w;
            return _out;
        }
        /**
         * Drops the z-component and w-component and returns a Vector2 consisting of the x- and y-components.
         * @param _out Optional vector to store the result in.
         */
        toVector2(_out = FudgeCore.Recycler.reuse(FudgeCore.Vector2)) {
            return _out.set(this.x, this.y);
        }
        /**
         * Drops the w-component and returns a Vector3 consisting of the x-, y- and z-components.
         * @param _out Optional vector to store the result in.
         */
        toVector3(_out = FudgeCore.Recycler.reuse(FudgeCore.Vector3)) {
            return _out.set(this.x, this.y, this.z);
        }
        /**
         * Returns a formatted string representation of this vector.
         */
        toString() {
            let result = `(${this.x.toPrecision(5)}, ${this.y.toPrecision(5)}, ${this.z.toPrecision(5)}, ${this.w.toPrecision(5)})`;
            return result;
        }
        serialize() {
            return { toJSON: () => `[${this.x}, ${this.y}, ${this.z}, ${this.w}]` };
        }
        async deserialize(_serialization) {
            [this.x, this.y, this.z, this.w] = JSON.parse(_serialization);
            return this;
        }
        mutate(_mutator) {
            if (_mutator.x != undefined)
                this.x = _mutator.x;
            if (_mutator.y != undefined)
                this.y = _mutator.y;
            if (_mutator.z != undefined)
                this.z = _mutator.z;
            if (_mutator.w != undefined)
                this.w = _mutator.w;
        }
        reduceMutator(_mutator) { }
        ;
    }
    FudgeCore.Vector4 = Vector4;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Describes a face of a {@link Mesh} by referencing three {@link Vertices} with their indizes
     * and calculates face normals.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Face {
        constructor(_vertices, _index0, _index1, _index2) {
            this.indices = [];
            this.angles = [];
            this.indices = [_index0, _index1, _index2];
            this.vertices = _vertices;
            this.calculateNormals();
        }
        /**
         * Returns the position of the vertex referenced by the given index
         */
        getPosition(_index) {
            return this.vertices.position(this.indices[_index]);
        }
        /**
         * must be coplanar
         */
        isInside(_point) {
            let diffs = [];
            for (let index of this.indices) {
                let diff = FudgeCore.Vector3.DIFFERENCE(this.vertices.position(index), _point);
                diffs.push(diff);
            }
            let n0 = FudgeCore.Vector3.CROSS(diffs[1], diffs[0]);
            let n1 = FudgeCore.Vector3.CROSS(diffs[2], diffs[1]);
            let n2 = FudgeCore.Vector3.CROSS(diffs[0], diffs[2]);
            let dot1 = FudgeCore.Vector3.DOT(n0, n1);
            let dot2 = FudgeCore.Vector3.DOT(n0, n2);
            return !(dot1 < 0 || dot2 < 0);
        }
        calculateNormals() {
            let trigon = this.indices.map((_index) => this.vertices.position(_index));
            let v1 = FudgeCore.Vector3.DIFFERENCE(trigon[1], trigon[0]);
            let v2 = FudgeCore.Vector3.DIFFERENCE(trigon[2], trigon[0]);
            this.normalUnscaled = FudgeCore.Vector3.CROSS(v1, v2);
            this.normal = FudgeCore.Vector3.NORMALIZATION(this.normalUnscaled);
            this.angles.push(FudgeCore.Vector3.ANGLE(v1, v2), FudgeCore.Vector3.ANGLE(FudgeCore.Vector3.DIFFERENCE(trigon[2], trigon[1]), FudgeCore.Vector3.DIFFERENCE(trigon[0], trigon[1])), FudgeCore.Vector3.ANGLE(FudgeCore.Vector3.DIFFERENCE(trigon[0], trigon[2]), FudgeCore.Vector3.DIFFERENCE(trigon[1], trigon[2])));
        }
    }
    FudgeCore.Face = Face;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple cube with edges of length 1, each face consisting of two trigons
     * ```text
     *       (12) 4____7  (11)
     *       (8) 0/__3/| (10)
     *       (15) ||5_||6 (14)
     *       (9) 1|/_2|/ (13)
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshCube extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshCube); }
        constructor(_name = "MeshCube") {
            super(_name);
            // no shared vertices, corners need three normals for Phong and Gouraud
            this.vertices = new FudgeCore.Vertices(
            // front vertices
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.5, 0.5), new FudgeCore.Vector2(0, 0)), // 0
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, -0.5, 0.5), new FudgeCore.Vector2(0, 1)), // 1
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, -0.5, 0.5), new FudgeCore.Vector2(1, 1)), // 2
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.5, 0.5), new FudgeCore.Vector2(1, 0)) //3
            );
            // generate vertices on sides
            for (let angle = 90; angle < 360; angle += 90) {
                let transform = FudgeCore.Matrix4x4.ROTATION(FudgeCore.Vector3.Y(angle));
                let side = this.vertices.slice(0, 4).map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, transform), _v.uv));
                this.vertices.push(...side);
            }
            // generate vertices for top and bottom
            for (let angle = 90; angle < 360; angle += 180) {
                let transform = FudgeCore.Matrix4x4.ROTATION(FudgeCore.Vector3.X(angle));
                let side = this.vertices.slice(0, 4).map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, transform), _v.uv));
                this.vertices.push(...side);
            }
            this.faces = [];
            for (let i = 0; i < 24; i += 4)
                // generate faces
                this.faces.push(...new FudgeCore.Quad(this.vertices, i + 0, i + 1, i + 2, i + 3).faces);
        }
    }
    FudgeCore.MeshCube = MeshCube;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a flat polygon. All trigons share vertex 0, so careful design is required to create concave polygons.
     * Vertex 0 is also associated with the face normal.
     * ```text
     *             0
     *           1‚ï±|‚ï≤  4 ...
     *            ‚ï≤|_‚ï≤‚ï±
     *            2   3
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshPolygon extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshPolygon); }
        static { this.shapeDefault = [
            new FudgeCore.Vector2(-1, -1),
            new FudgeCore.Vector2(1, -1),
            new FudgeCore.Vector2(0, 1)
        ]; }
        constructor(_name = "MeshPolygon", _shape = MeshPolygon.shapeDefault, _fitTexture = true) {
            super(_name);
            this.shape = new FudgeCore.MutableArray(FudgeCore.Vector2);
            this.create(_shape, _fitTexture);
        }
        get minVertices() {
            return 3;
        }
        /**
         * Create this mesh from the given vertices.
         */
        create(_shape = [], _fitTexture = true) {
            this.shape = FudgeCore.MutableArray.from(_shape.map(_vertex => _vertex.clone));
            this.clear();
            this.fitTexture = _fitTexture;
            if (_shape.length < this.minVertices) {
                FudgeCore.Debug.warn(`At least ${this.minVertices} vertices needed to construct MeshPolygon, default trigon used`);
                this.create(MeshPolygon.shapeDefault, true);
                return;
            }
            let shape = _shape;
            let min = FudgeCore.Vector2.ZERO();
            let max = FudgeCore.Vector2.ZERO();
            this.vertices = new FudgeCore.Vertices();
            for (let vertex of shape) {
                this.vertices.push(new FudgeCore.Vertex(vertex.toVector3()));
                min.x = Math.min(min.x, vertex.x);
                max.x = Math.max(max.x, vertex.x);
                min.y = Math.min(min.y, vertex.y);
                max.y = Math.max(max.y, vertex.y);
            }
            let size = new FudgeCore.Vector2(max.x - min.x, max.y - min.y);
            if (this.fitTexture) {
                for (let i = 0; i < shape.length; i++) {
                    let textureUV = FudgeCore.Vector2.DIFFERENCE(shape[i], min);
                    this.vertices[i].uv = new FudgeCore.Vector2(textureUV.x / size.x, 1 - textureUV.y / size.y);
                }
            }
            else {
                _shape.forEach((_vertex, _i) => this.vertices[_i].uv = new FudgeCore.Vector2(_vertex.x, -_vertex.y));
            }
            this.faces = [];
            for (let i = 2; i < this.vertices.length; i++)
                this.faces.push(new FudgeCore.Face(this.vertices, i - 1, i, 0));
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.shape = FudgeCore.Serializer.serializeArray(FudgeCore.Vector2, this.shape);
            serialization.fitTexture = this.fitTexture;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let vectors = await FudgeCore.Serializer.deserializeArray(_serialization.shape);
            this.create(vectors, _serialization.fitTexture);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            await super.mutate(_mutator, _selection, _dispatchMutate);
            this.create(this.shape, this.fitTexture);
            this.dispatchEvent(new Event("mutate" /* EVENT.MUTATE */));
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
        }
    }
    FudgeCore.MeshPolygon = MeshPolygon;
})(FudgeCore || (FudgeCore = {}));
///<reference path="MeshPolygon.ts"/>
var FudgeCore;
///<reference path="MeshPolygon.ts"/>
(function (FudgeCore) {
    /**
     * Generates an extrusion of a polygon by a series of transformations
     * ```text
     *                      ____
     * Polygon         ____‚ï±‚ï≤   ‚ï≤                             y
     * Transform 0  ‚Üí ‚ï± ‚ï≤__‚ï≤_‚ï≤___‚ï≤ ‚Üê Transform 2          z __‚îÇ
     * (base)         ‚ï≤_‚ï±__‚ï± ‚ï±   ‚ï±   (lid)                     ‚ï≤
     *     Transform 1  ‚Üí  ‚ï≤‚ï±___‚ï±                               x
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshExtrusion extends FudgeCore.MeshPolygon {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshExtrusion); }
        static { this.mtxDefaults = [
            FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Vector3.Z(0.5)),
            FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Vector3.Z(-0.5))
        ]; }
        constructor(_name = "MeshExtrusion", _vertices = FudgeCore.MeshPolygon.shapeDefault, _mtxTransforms = MeshExtrusion.mtxDefaults, _fitTexture = true) {
            super(_name, _vertices, _fitTexture);
            this.mtxTransforms = new FudgeCore.MutableArray(FudgeCore.Matrix4x4);
            this.extrude(_mtxTransforms);
            // console.log("Mutator", this.getMutator());
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.transforms = FudgeCore.Serializer.serializeArray(FudgeCore.Matrix4x4, this.mtxTransforms);
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let mtxTransforms;
            if (_serialization.transforms)
                mtxTransforms = await FudgeCore.Serializer.deserializeArray(_serialization.transforms);
            this.extrude(mtxTransforms);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            await super.mutate(_mutator, _selection, _dispatchMutate);
            this.extrude(this.mtxTransforms);
            this.dispatchEvent(new Event("mutate" /* EVENT.MUTATE */));
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
        }
        //#endregion
        extrude(_mtxTransforms = MeshExtrusion.mtxDefaults) {
            this.mtxTransforms = FudgeCore.MutableArray.from(_mtxTransforms);
            let nTransforms = _mtxTransforms.length;
            let nVerticesShape = this.vertices.length;
            // create new vertex cloud, current cloud holds MeshPolygon
            let vertices = new FudgeCore.Vertices();
            // create base by transformation of polygon with first transform
            let base = this.vertices.map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, _mtxTransforms[0], true), _v.uv));
            vertices.push(...base);
            // create lid by transformation of polygon with last transform
            let lid = this.vertices.map((_v) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, _mtxTransforms[nTransforms - 1], true), _v.uv));
            vertices.push(...lid);
            // recreate base faces to recalculate normals
            this.faces = this.faces.map((_face) => new FudgeCore.Face(vertices, _face.indices[0], _face.indices[1], _face.indices[2]));
            // create the lid faces using the indices of the base faces, but with an index offset and reverse order of indices
            this.faces.push(...this.faces.map(_face => new FudgeCore.Face(vertices, _face.indices[2] + nVerticesShape, _face.indices[1] + nVerticesShape, _face.indices[0] + nVerticesShape)));
            for (let t = 0; t < nTransforms; t++) {
                let mtxTransform = _mtxTransforms[t];
                let referToClose = vertices.length;
                let wrap = this.vertices.map((_v, _i) => new FudgeCore.Vertex(FudgeCore.Vector3.TRANSFORMATION(_v.position, mtxTransform, true), new FudgeCore.Vector2(_i / nVerticesShape, t / nTransforms)));
                vertices.push(...wrap);
                vertices.push(new FudgeCore.Vertex(referToClose, new FudgeCore.Vector2(1, t / nTransforms)));
                // if (i > 0 && i < nTransforms - 1)
                //   vertices.push(...wrap.map((_vector: Vector3) => _vector.clone)); <- no slicing for flat shading yet...
            }
            // create indizes for wrapper
            for (let t = 0; t < nTransforms - 1; t++)
                for (let i = 0; i < nVerticesShape; i++) {
                    let index = +2 * nVerticesShape // base & lid are offsets 
                        + t * (nVerticesShape + 1) // offset for each transformation
                        + i;
                    let quad = new FudgeCore.Quad(vertices, index, index + nVerticesShape + 1, index + nVerticesShape + 2, index + 1, FudgeCore.QUADSPLIT.AT_0);
                    this.faces.push(...quad.faces);
                }
            this.vertices = vertices;
            return;
        }
    }
    FudgeCore.MeshExtrusion = MeshExtrusion;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A mesh loaded from an FBX-File.
     * @authors Matthias Roming, HFU, 2023 | Jonas Plotzky, HFU, 2023
     */
    class MeshFBX extends FudgeCore.mixinSerializableResourceExternal(FudgeCore.Mesh) {
        async load(_url = this.url, _iMesh = this.iMesh) {
            this.clear();
            this.url = _url;
            this.iMesh = _iMesh;
            const loader = await FudgeCore.FBXLoader.LOAD(this.url.toString());
            const geometryFBX = (loader.fbx.objects.geometries[_iMesh] ||
                loader.fbx.objects.geometries.find(_object => _object.name == this.name) ||
                loader.fbx.objects.models.find(_object => _object.name == this.name && _object.subtype == "Mesh").children[0]).load();
            if (geometryFBX)
                this.name = geometryFBX.name.length > 0 ? geometryFBX.name : geometryFBX.parents[0].name;
            let positions = [];
            let vertexBuffer = geometryFBX.Vertices;
            for (let iVertex = 0; iVertex < vertexBuffer.length; iVertex += 3) {
                positions.push(new FudgeCore.Vector3(vertexBuffer[iVertex + 0], vertexBuffer[iVertex + 1], vertexBuffer[iVertex + 2]));
            }
            let uvs = [];
            if (geometryFBX.LayerElementUV) {
                let uvBuffer = geometryFBX.LayerElementUV.UV;
                for (let iuv = 0; iuv < uvBuffer.length; iuv += 2) {
                    uvs.push(new FudgeCore.Vector2(uvBuffer[iuv], 1 - uvBuffer[iuv + 1]));
                }
            }
            let normals = [];
            if (geometryFBX.LayerElementNormal) {
                let normalBuffer = geometryFBX.LayerElementNormal.Normals;
                for (let iNormal = 0; iNormal < normalBuffer.length; iNormal += 3) {
                    normals.push(new FudgeCore.Vector3(normalBuffer[iNormal], normalBuffer[iNormal + 1], normalBuffer[iNormal + 2]));
                }
            }
            let mapVertexToIndex = new Map();
            let newVertexIndices = [];
            let iPolygon = 0;
            let isEndOfPolygon = false;
            let polygon = [];
            geometryFBX.PolygonVertexIndex.forEach((_iVertex, _iPolygonVertex) => {
                if (_iVertex < 0) {
                    _iVertex = _iVertex ^ -1;
                    isEndOfPolygon = true;
                }
                let position = positions[_iVertex];
                let uv = uvs[this.getDataIndex(geometryFBX.LayerElementUV, _iVertex, iPolygon, _iPolygonVertex)];
                let vertexKey = position.toString() + uv.toString();
                if (!mapVertexToIndex.has(vertexKey)) {
                    let normal = normals[this.getDataIndex(geometryFBX.LayerElementNormal, _iVertex, iPolygon, _iPolygonVertex)];
                    this.vertices.push(new FudgeCore.Vertex(position, uv, normal));
                    mapVertexToIndex.set(vertexKey, this.vertices.length - 1);
                    if (!newVertexIndices[_iVertex])
                        newVertexIndices[_iVertex] = [];
                    newVertexIndices[_iVertex].push(this.vertices.length - 1);
                }
                polygon.push(mapVertexToIndex.get(vertexKey));
                if (isEndOfPolygon) {
                    if (polygon.length == 3) {
                        this.faces.push(new FudgeCore.Face(this.vertices, polygon[0], polygon[1], polygon[2]));
                    }
                    else if (polygon.length == 4) {
                        let quad = new FudgeCore.Quad(this.vertices, polygon[0], polygon[1], polygon[2], polygon[3]);
                        this.faces.push(...quad.faces);
                    }
                    else {
                        for (let i = 2; i < polygon.length; i++)
                            this.faces.push(new FudgeCore.Face(this.vertices, polygon[0], polygon[i - 1], polygon[i - 0]));
                        // console.warn(`${MeshLoaderFBX.name}: Polygons with more than 4 vertices are not supported.`);
                    }
                    polygon = [];
                    isEndOfPolygon = false;
                    iPolygon++;
                }
            });
            if (geometryFBX.children?.[0].type == "Deformer") {
                const fbxDeformer = geometryFBX.children[0];
                const skeleton = await loader.getSkeleton(fbxDeformer.children[0].children[0]); // Deformer.SubDeformer.LimbNode
                this.createBones(fbxDeformer, skeleton, this.vertices, newVertexIndices);
            }
            return this;
        }
        serialize() {
            const serialization = super.serialize();
            serialization.iMesh = this.iMesh;
            return serialization;
        }
        async deserialize(_serialization) {
            this.iMesh = _serialization.iMesh;
            return super.deserialize(_serialization);
        }
        getDataIndex(_layerElement, _iVertex, _iPolygon, _iPolygonVertex) {
            let index = _layerElement.MappingInformationType == "ByVertex" ?
                _iVertex :
                _layerElement.MappingInformationType == "ByPolygon" ?
                    _iPolygon :
                    _iPolygonVertex;
            if (_layerElement.ReferenceInformationType === 'IndexToDirect') {
                let indices = _layerElement.UVIndex || _layerElement.NormalsIndex;
                index = indices[index];
            }
            return index;
        }
        createBones(_deformerFBX, _skeleton, _vertices, _newVertexIndices) {
            for (const fbxSubDeformer of _deformerFBX.children) {
                fbxSubDeformer.load();
                if (fbxSubDeformer.Indexes)
                    for (let iBoneInfluence = 0; iBoneInfluence < fbxSubDeformer.Indexes.length; iBoneInfluence++) {
                        const iVertex = fbxSubDeformer.Indexes[iBoneInfluence];
                        for (const iVertexNew of _newVertexIndices ? _newVertexIndices[iVertex] : [iVertex]) {
                            (_vertices[iVertexNew].bones || (_vertices[iVertexNew].bones = [])).push({
                                index: _skeleton.indexOf(fbxSubDeformer.children[0].name),
                                weight: fbxSubDeformer.Weights[iBoneInfluence] || 1
                            });
                        }
                    }
            }
        }
    }
    FudgeCore.MeshFBX = MeshFBX;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Allows to create custom meshes from given Data */
    class MeshFromData extends FudgeCore.Mesh {
        constructor(_vertices, _textureUVs, _indices, _faceNormals) {
            super();
            this.verticesToSet = _vertices;
            this.textureUVsToSet = _textureUVs;
            this.indicesToSet = _indices;
            this.faceNormalsToSet = _faceNormals;
        }
        createVertices() {
            return this.verticesToSet;
        }
        createTextureUVs() {
            return this.textureUVsToSet;
        }
        createIndices() {
            return this.indicesToSet;
        }
        createFlatNormals() {
            return this.faceNormalsToSet;
        }
    }
    FudgeCore.MeshFromData = MeshFromData;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Mesh} loaded from a glTF-File.
     * @authors Jonas Plotzky, HFU, 2024
     */
    class MeshGLTF extends FudgeCore.mixinSerializableResourceExternal(FudgeCore.Mesh) {
        async load(_url = this.url, _name = this.name, _iPrimitive = this.iPrimitive) {
            this.url = _url;
            this.name = _name;
            this.iPrimitive = _iPrimitive;
            return FudgeCore.GLTFLoader.loadResource(this);
        }
        serialize() {
            const serialization = super.serialize();
            serialization.iPrimitive = this.iPrimitive;
            return serialization;
        }
        deserialize(_serialization) {
            this.iPrimitive = _serialization.iPrimitive;
            return super.deserialize(_serialization);
        }
    }
    FudgeCore.MeshGLTF = MeshGLTF;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A mesh loaded from an OBJ-file.
     * Simple Wavefront OBJ import. Takes a wavefront obj string. To Load from a file url, use the
     * static LOAD Method. Currently only works with triangulated Meshes
     * (activate 'Geomentry ‚Üí Triangulate Faces' in Blenders obj exporter)
     * @todo Load Materials, Support Quads
     * @authors Simon Storl-Schulke 2021 | Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021-2022 | Matthias Roming, HFU, 2023 | Jonas Plotzky, HFU, 2023
     */
    class MeshOBJ extends FudgeCore.mixinSerializableResourceExternal(FudgeCore.Mesh) {
        async load(_url = this.url) {
            const url = new URL(_url.toString(), FudgeCore.Project.baseURL).toString();
            const data = await (await fetch(url)).text();
            this.name = url.split("/").pop();
            this.url = _url;
            const lines = data.split("\n");
            const indices = [];
            const positions = [];
            const uvs = [];
            const normals = [];
            const norms = [];
            const vertices = new FudgeCore.Vertices();
            const faces = [];
            const mapPositionUVNormalToIndex = {};
            const mapPositionNormalToIndex = {};
            // TODO: think about creating the needed buffers for rendermesh here already...
            for (let line of lines) {
                const parts = line.trim().split(" ");
                switch (parts.shift()) {
                    case "v": //Vertex - example: v 0.70 -0.45 -0.52         
                        positions.push(new FudgeCore.Vector3(...parts.map(_value => +_value)));
                        break;
                    case "vn": //Normal - example: vn 0.00 0.00 1.00
                        normals.push(new FudgeCore.Vector3(...parts.map(_value => +_value)));
                        break;
                    case "vt": //Texcoord - example: vt 0.545454 0.472382
                        uvs.push(new FudgeCore.Vector2(...parts.map((_value, _index) => +_value * (_index == 1 ? -1 : 1))));
                        break;
                    case "f": /*Face Indices - example: f 1/1/1 2/2/1 3/3/1 --> vertex1/texcoord1/normal1 vertex2/texcoord2/normal2 vertex3/texcoord3/normal3*/
                        for (let i = 0; i < 3; i++) {
                            let key = parts[i];
                            let index = mapPositionUVNormalToIndex[key];
                            if (index === undefined) {
                                index = vertices.length;
                                const vertexInfo = parts[i].split("/");
                                let position = positions[+vertexInfo[0] - 1]; // obj uses 1-based indices
                                let uv = uvs[+vertexInfo[1] - 1] ?? undefined;
                                let normal = normals[+vertexInfo[2] - 1] ?? undefined;
                                if (normal)
                                    norms.push(normal.x, normal.y, normal.z);
                                let keyPosNorm = `${vertexInfo[0]}/${vertexInfo[2]}`;
                                vertices.push(new FudgeCore.Vertex(mapPositionNormalToIndex[keyPosNorm] ?? position, uv, normal));
                                mapPositionUVNormalToIndex[key] = index;
                                if (mapPositionNormalToIndex[keyPosNorm] == undefined)
                                    mapPositionNormalToIndex[keyPosNorm] = index;
                            }
                            indices.push(index);
                        }
                        try {
                            faces.push(new FudgeCore.Face(vertices, indices[indices.length - 2], indices[indices.length - 1], indices[indices.length - 3]));
                        }
                        catch (_e) {
                            FudgeCore.Debug.fudge("Face excluded", _e.message);
                        }
                        break;
                }
            }
            this.clear();
            this.vertices = vertices;
            this.faces = faces;
            if (norms.length > 0) // TODO: rendermesh should be able to handle undefined normals correctly, i.e. calculate them only if they are not present in the vertices
                this.renderMesh.normals = new Float32Array(norms);
            // _mesh.renderMesh.indices = new Uint16Array(indices); // doens't seem to affect scene loading time...
            return this;
        }
    }
    FudgeCore.MeshOBJ = MeshOBJ;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple pyramid with edges at the base of length 1 and a height of 1. The sides consisting of one, the base of two trigons
     * ```text
     *               4
     *              /\`.
     *            3/__\_\ 2
     *           0/____\/1
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class MeshPyramid extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshPyramid); }
        constructor(_name = "MeshPyramid") {
            super(_name);
            // this.create();
            this.vertices = new FudgeCore.Vertices(
            // ground vertices
            new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.0, 0.5), new FudgeCore.Vector2(0, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.0, 0.5), new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.0, -0.5), new FudgeCore.Vector2(1, 0)), new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.0, -0.5), new FudgeCore.Vector2(0, 0)), 
            // tip (vertex #4)
            new FudgeCore.Vertex(new FudgeCore.Vector3(0.0, 1.0, 0.0), new FudgeCore.Vector2(0.5, 0.5)), 
            // floor again for downside texture
            new FudgeCore.Vertex(0, new FudgeCore.Vector2(0, 0)), new FudgeCore.Vertex(1, new FudgeCore.Vector2(1, 0)), new FudgeCore.Vertex(2, new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(3, new FudgeCore.Vector2(0, 1)));
            this.faces = [
                new FudgeCore.Face(this.vertices, 4, 0, 1),
                new FudgeCore.Face(this.vertices, 4, 1, 2),
                new FudgeCore.Face(this.vertices, 4, 2, 3),
                new FudgeCore.Face(this.vertices, 4, 3, 0),
                new FudgeCore.Face(this.vertices, 5 + 0, 5 + 2, 5 + 1),
                new FudgeCore.Face(this.vertices, 5 + 0, 5 + 3, 5 + 2)
            ];
        }
    }
    FudgeCore.MeshPyramid = MeshPyramid;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a simple quad with edges of length 1, the face consisting of two trigons
     * ```text
     *        0 __ 3
     *         |_\|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019-2022
     */
    class MeshQuad extends FudgeCore.MeshPolygon {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshQuad); }
        static { this.shape = [
            new FudgeCore.Vector2(-0.5, 0.5), new FudgeCore.Vector2(-0.5, -0.5), new FudgeCore.Vector2(0.5, -0.5), new FudgeCore.Vector2(0.5, 0.5)
        ]; }
        constructor(_name = "MeshQuad") {
            super(_name, MeshQuad.shape);
        }
        // // flat equals smooth
        // public get verticesFlat(): Float32Array { return this.vertices; }
        // public get indicesFlat(): Uint16Array { return this.indices; }
        // public get normalsFlat(): Float32Array { return this.normalsVertex; }
        //#region Transger
        serialize() {
            let serialization = this.getMutator();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(MeshQuad.shape, true); // this seems to be dispatched doubled while deserializing the resources
            return this;
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
            delete _mutator.fitTexture;
        }
    }
    FudgeCore.MeshQuad = MeshQuad;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Information about the vertical projection of a given position onto the terrain
     */
    class TerrainInfo {
    }
    FudgeCore.TerrainInfo = TerrainInfo;
    /**
     * A terrain spreads out in the x-z-plane, y is the height derived from the heightmap function.
     * The terrain is always 1 in size in all dimensions, fitting into the unit-cube.
     * Resolution determines the number of quads in x and z dimension, scale the factor applied to the x,z-coordinates passed to the heightmap function.
     * Standard function is the simplex noise implemented with FUDGE, but another function can be given.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022 | Simon Storl-Schulke, HFU, 2020 | Moritz Beaugrand, HFU, 2021
     */
    class MeshTerrain extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshTerrain); }
        constructor(_name = "MeshTerrain", _resolution = FudgeCore.Vector2.ONE(2), _scaleInput = FudgeCore.Vector2.ONE(), _functionOrSeed = 0) {
            super(_name);
            this.heightMapFunction = null;
            this.create(_resolution, _scaleInput, _functionOrSeed);
        }
        /**
         * Create this mesh from the given parameters
         */
        create(_resolution = FudgeCore.Vector2.ONE(2), _scaleInput = FudgeCore.Vector2.ONE(), _functionOrSeed = 0) {
            this.clear();
            this.seed = undefined;
            this.resolution = new FudgeCore.Vector2(Math.round(_resolution.x), Math.round(_resolution.y));
            this.scale = _scaleInput.clone;
            if (_functionOrSeed instanceof Function)
                this.heightMapFunction = _functionOrSeed;
            else if (typeof (_functionOrSeed) == "number") {
                this.seed = _functionOrSeed;
                let prng = new FudgeCore.Random(this.seed);
                this.heightMapFunction = new FudgeCore.Noise2(() => prng.getNorm()).sample; // TODO call PRNG
            }
            else
                this.heightMapFunction = new FudgeCore.Noise2().sample;
            this.vertices = new FudgeCore.Vertices();
            //Iterate over each cell to generate grid of vertices
            for (let z = 0; z <= this.resolution.y; z++) {
                for (let x = 0; x <= this.resolution.x; x++) {
                    let xNorm = x / this.resolution.x;
                    let zNorm = z / this.resolution.y;
                    this.vertices.push(new FudgeCore.Vertex(new FudgeCore.Vector3(xNorm - 0.5, this.heightMapFunction(xNorm * this.scale.x, zNorm * this.scale.y), zNorm - 0.5), new FudgeCore.Vector2(xNorm, zNorm)));
                }
            }
            let quads = [];
            let split = FudgeCore.QUADSPLIT.AT_0;
            for (let z = 0; z < this.resolution.y; z++) {
                for (let x = 0; x < this.resolution.x; x++) {
                    quads.push(new FudgeCore.Quad(this.vertices, (x + 0) + (z + 0) * (this.resolution.x + 1), (x + 0) + (z + 1) * (this.resolution.x + 1), (x + 1) + (z + 1) * (this.resolution.x + 1), (x + 1) + (z + 0) * (this.resolution.x + 1), split));
                    split = (split == FudgeCore.QUADSPLIT.AT_0) ? FudgeCore.QUADSPLIT.AT_1 : FudgeCore.QUADSPLIT.AT_0;
                }
                if (this.resolution.x % 2 == 0) // reverse last split change if x-resolution is even
                    split = (split == FudgeCore.QUADSPLIT.AT_0) ? FudgeCore.QUADSPLIT.AT_1 : FudgeCore.QUADSPLIT.AT_0;
            }
            this.faces = quads.flatMap((_quad) => _quad.faces);
        }
        /**
         * Returns information about the vertical projection of the given position onto the terrain.
         * Pass the overall world transformation of the terrain if the position is given in world coordinates.
         * If at hand, pass the inverse too to avoid unnecessary calculation.
         */
        getTerrainInfo(_position, _mtxWorld = FudgeCore.Matrix4x4.IDENTITY(), _mtxInverse) {
            if (!_mtxInverse)
                _mtxInverse = FudgeCore.Matrix4x4.INVERSE(_mtxWorld);
            let terrainInfo = new TerrainInfo;
            let posLocal = FudgeCore.Vector3.TRANSFORMATION(_position, _mtxInverse, true);
            let z = Math.floor((posLocal.z + 0.5) * this.resolution.y);
            let x = Math.floor((posLocal.x + 0.5) * this.resolution.x);
            if (z < 0 || z > this.resolution.y - 1 || x < 0 || x > this.resolution.x - 1)
                return null;
            let index = (z * this.resolution.x + x) * 2;
            let face = this.faces[index];
            let ray = new FudgeCore.Ray(FudgeCore.Vector3.Y(), posLocal);
            let point = ray.intersectFacePlane(face);
            if (!face.isInside(point)) {
                index++;
                face = this.faces[index];
                point = ray.intersectFacePlane(face);
            }
            terrainInfo.index = index;
            terrainInfo.positionFace = point;
            terrainInfo.position = FudgeCore.Vector3.TRANSFORMATION(point, _mtxWorld, true);
            terrainInfo.normal = FudgeCore.Vector3.TRANSFORMATION(face.normal, FudgeCore.Matrix4x4.TRANSPOSE(_mtxInverse), false);
            terrainInfo.distance = _position.y - terrainInfo.position.y;
            terrainInfo.grid = this.getGridFromFaceIndex(index);
            return terrainInfo;
        }
        /**
         * Returns the grid coordinates of the quad the given face belongs to.
         */
        getGridFromFaceIndex(_index) {
            let result = FudgeCore.Recycler.get(FudgeCore.Vector2);
            let iQuad = Math.floor(_index / 2);
            result.set(iQuad % this.resolution.y, Math.floor(iQuad / this.resolution.x));
            return result;
        }
        /**
         * Returns the indices of the two faces forming the quad the given grid position belongs to.
         */
        getFaceIndicesFromGrid(_grid) {
            let iQuad = _grid.y * 2 * this.resolution.x + _grid.x * 2;
            return [iQuad, iQuad + 1];
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.seed = this.seed;
            serialization.scale = this.scale.serialize();
            serialization.resolution = this.resolution.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            await this.resolution.deserialize(_serialization.resolution);
            await this.scale.deserialize(_serialization.scale);
            this.seed = _serialization.seed;
            this.create(this.resolution, this.scale, this.seed);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            super.mutate(_mutator, _selection, _dispatchMutate);
            this.create(this.resolution, this.scale, this.seed);
        }
    }
    FudgeCore.MeshTerrain = MeshTerrain;
})(FudgeCore || (FudgeCore = {}));
///<reference path="MeshTerrain.ts"/>
var FudgeCore;
///<reference path="MeshTerrain.ts"/>
(function (FudgeCore) {
    /**
     * Generates a planar Grid and applies a Heightmap-Function to it.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021 | Moritz Beaugrand, HFU, 2020
     */
    let MeshRelief = (() => {
        let _classDecorators = [FudgeCore.enumerate];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _classSuper = FudgeCore.MeshTerrain;
        let _instanceExtraInitializers = [];
        let _get_texture_decorators;
        var MeshRelief = class extends _classSuper {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                _get_texture_decorators = [FudgeCore.enumerate, FudgeCore.type(FudgeCore.TextureImage)];
                __esDecorate(this, null, _get_texture_decorators, { kind: "getter", name: "texture", static: false, private: false, access: { has: obj => "texture" in obj, get: obj => obj.texture }, metadata: _metadata }, null, _instanceExtraInitializers);
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                MeshRelief = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshRelief); }
            #texture = __runInitializers(this, _instanceExtraInitializers);
            constructor(_name = "MeshRelief", _texture) {
                super(_name, FudgeCore.Vector2.ONE(2), undefined, (_x, _z) => 0);
                this.texture = _texture;
            }
            static createHeightMapFunction(_texture) {
                let array = MeshRelief.textureToClampedArray(_texture);
                let heightMapFunction = (_x, _z) => {
                    let pixel = Math.round(_z * _texture.image.width + _x);
                    return array[pixel * 4] / 255;
                };
                return heightMapFunction;
            }
            static textureToClampedArray(_texture) {
                let canvas = document.createElement("canvas");
                canvas.width = _texture.image.width;
                canvas.height = _texture.image.height;
                let crc = canvas.getContext("2d");
                crc.imageSmoothingEnabled = false;
                crc.drawImage(_texture.image, 0, 0);
                return crc.getImageData(0, 0, _texture.image.width, _texture.image.height).data;
            }
            /**
             * The texture to be used as the heightmap.
             * **Caution!** Setting this causes the mesh to be recreated which can be an expensive operation.
             */
            get texture() {
                return this.#texture;
            }
            set texture(_texture) {
                this.#texture = _texture;
                if (!_texture)
                    return;
                let resolution = _texture ? new FudgeCore.Vector2(_texture.image.width - 1, _texture.image.height - 1) : undefined;
                super.create(resolution, resolution, MeshRelief.createHeightMapFunction(_texture));
            }
            //#region Transfer
            serialize() {
                let serialization = super.serialize();
                delete serialization.seed;
                delete serialization.scale;
                delete serialization.resolution;
                if (this.#texture)
                    serialization.idTexture = this.texture.idResource;
                return serialization;
            }
            async deserialize(_serialization) {
                await super.deserialize(_serialization);
                if (_serialization.idTexture)
                    this.texture = await FudgeCore.Project.getResource(_serialization.idTexture);
                return this;
            }
            reduceMutator(_mutator) {
                super.reduceMutator(_mutator);
                delete _mutator.seed;
                delete _mutator.scale;
                delete _mutator.resolution;
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return MeshRelief = _classThis;
    })();
    FudgeCore.MeshRelief = MeshRelief;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="MeshPolygon.ts"/>
var FudgeCore;
// /<reference path="MeshPolygon.ts"/>
(function (FudgeCore) {
    /**
     * Generates a rotation of a polygon around the y-axis
     * ```text
     *                     y
     *                  _  ‚Üë 0_1
     *                 ‚îÇ   ‚îÇ‚Üíx ‚îÇ2
     *                  ‚ï≤  ‚îÇ  ‚ï±3
     *                  ‚ï±  ‚îÇ  ‚ï≤
     *                 ‚ï±___‚îÇ___‚ï≤4
     *                      5
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021-2022
     */
    class MeshRotation extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshRotation); }
        static { this.verticesDefault = [
            new FudgeCore.Vector2(0.5, 0.5),
            new FudgeCore.Vector2(0.5, -0.5)
        ]; }
        constructor(_name = "MeshRotation", _shape = MeshRotation.verticesDefault, _longitudes = 3) {
            super(_name);
            this.shape = new FudgeCore.MutableArray(FudgeCore.Vector2);
            this.rotate(_shape, _longitudes);
            // console.log("Mutator", this.getMutator());
        }
        get minVertices() {
            return 2;
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.shape = FudgeCore.Serializer.serializeArray(FudgeCore.Vector2, this.shape);
            serialization.longitudes = this.longitudes;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            let shape = await FudgeCore.Serializer.deserializeArray(_serialization.shape);
            this.longitudes = _serialization.longitudes;
            this.rotate(shape, this.longitudes);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            await super.mutate(_mutator, _selection, _dispatchMutate);
            this.rotate(this.shape, this.longitudes);
            this.dispatchEvent(new Event("mutate" /* EVENT.MUTATE */));
        }
        //#endregion
        rotate(_shape, _longitudes) {
            this.clear();
            this.shape = FudgeCore.MutableArray.from(_shape.map(_vertex => _vertex.clone));
            this.longitudes = Math.round(_longitudes);
            let angle = 360 / this.longitudes;
            let mtxRotate = FudgeCore.Matrix4x4.ROTATION_Y(angle);
            // copy original polygon as Vector3 array
            let polygon = [];
            let distances = [0];
            let total = 0;
            for (let i = 0; i < this.shape.length; i++) {
                polygon.push(this.shape[i].toVector3());
                if (i > 0) {
                    let distance = FudgeCore.Vector2.DIFFERENCE(this.shape[i], this.shape[i - 1]).magnitude;
                    total += distance;
                    distances.push(total);
                }
            }
            distances.forEach((_entry, _index) => { distances[_index] = _entry / total; });
            let nVerticesPolygon = polygon.length;
            let cloud = new FudgeCore.Vertices();
            for (let longitude = 0; longitude <= this.longitudes; longitude++) {
                for (let i = 0; i < nVerticesPolygon; i++) {
                    let uv = new FudgeCore.Vector2(longitude / this.longitudes, distances[i]);
                    // TODO: last sector should only be references to the first meridian
                    if (longitude == this.longitudes)
                        cloud.push(new FudgeCore.Vertex(i, uv));
                    else {
                        if (longitude > 0 && this.shape[i].x == 0) // use a single vertex when it's on the rotation axis
                            cloud.push(new FudgeCore.Vertex(i, uv));
                        else
                            cloud.push(new FudgeCore.Vertex(polygon[i].clone, uv));
                    }
                }
                polygon.forEach((_vector) => _vector.transform(mtxRotate));
            }
            // copy indices to new index array
            let faces = [];
            for (let longitude = 0; longitude < this.longitudes; longitude++) {
                for (let latitude = 0; latitude < nVerticesPolygon - 1; latitude++) {
                    let start = longitude * nVerticesPolygon + latitude;
                    let quad = new FudgeCore.Quad(cloud, start + 1, start + 1 + nVerticesPolygon, start + nVerticesPolygon, start);
                    faces.push(...quad.faces);
                    // TODO: catch invalid faces right here...
                }
            }
            this.vertices = cloud;
            this.faces = faces;
        }
    }
    FudgeCore.MeshRotation = MeshRotation;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a UV Sphere with a given number of sectors and stacks (clamped at 128*128)
     * Implementation based on http://www.songho.ca/opengl/gl_sphere.html
     * @authors Simon Storl-Schulke, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshSphere extends FudgeCore.MeshRotation {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSphere); }
        constructor(_name = "MeshSphere", _longitudes = 8, _latitudes = 8) {
            super(_name);
            this.create(_longitudes, _latitudes); // TODO: when deserialized this causes this causes the mesh to be created twice
        }
        /**
         * Create this sphere with a given number of longitudes and latitudes
         */
        create(_longitudes = 3, _latitudes = 2) {
            this.clear();
            //Clamp resolution to prevent performance issues
            this.longitudes = Math.min(Math.round(_longitudes), 128);
            this.latitudes = Math.min(Math.round(_latitudes), 128);
            if (_longitudes < 3 || _latitudes < 2) {
                FudgeCore.Debug.warn("UV Sphere must have at least 3 longitudes and 2 latitudes to form a 3-dimensional shape.");
                this.longitudes = Math.max(3, _longitudes);
                this.latitudes = Math.max(2, _latitudes);
            }
            let shape = [];
            let step = Math.PI / this.latitudes;
            for (let i = 0; i <= this.latitudes; ++i) {
                let angle = Math.PI / 2 - i * step;
                let x = Math.cos(angle);
                let y = Math.sin(angle);
                shape.push(new FudgeCore.Vector2(x / 2, y / 2));
            }
            // place first and last vertex exactly on rotation axis
            shape[0].x = 0;
            shape[shape.length - 1].x = 0;
            super.rotate(shape, _longitudes);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            delete serialization.shape;
            serialization.latitudes = this.latitudes;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(_serialization.longitudes, _serialization.latitudes);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            super.mutate(_mutator, _selection, _dispatchMutate);
            this.create(this.longitudes, this.latitudes);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
        }
    }
    FudgeCore.MeshSphere = MeshSphere;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate two quads placed back to back, the one facing in negative Z-direction is textured reversed
     * ```text
     *        0 __ 3
     *         |__|
     *        1    2
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshSprite extends FudgeCore.Mesh {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshSprite); }
        constructor(_name = "MeshSprite") {
            super(_name);
            this.vertices = new FudgeCore.Vertices(new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, 0.5, 0), new FudgeCore.Vector2(0, 0)), new FudgeCore.Vertex(new FudgeCore.Vector3(-0.5, -0.5, 0), new FudgeCore.Vector2(0, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, -0.5, 0), new FudgeCore.Vector2(1, 1)), new FudgeCore.Vertex(new FudgeCore.Vector3(0.5, 0.5, 0), new FudgeCore.Vector2(1, 0)));
            this.faces = [
                new FudgeCore.Face(this.vertices, 1, 2, 0),
                new FudgeCore.Face(this.vertices, 2, 3, 0),
                new FudgeCore.Face(this.vertices, 0, 3, 1),
                new FudgeCore.Face(this.vertices, 3, 2, 1)
            ];
        }
        // flat is standard here // TODO: is this still needed?
        get verticesFlat() { return this.renderMesh.positions; }
        get indicesFlat() { return this.renderMesh.indices; }
    }
    FudgeCore.MeshSprite = MeshSprite;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Generate a torus with a given ring radius, tube radius and the number of major- and minor segments
     * @authors Simon Storl-Schulke, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2020
     */
    class MeshTorus extends FudgeCore.MeshRotation {
        static { this.iSubclass = FudgeCore.Mesh.registerSubclass(MeshTorus); }
        constructor(_name = "MeshTorus", _radiusRing = 0.5 - 0.125, _radiusTube = 0.125, _longitudes = 8, _latitudes = 6) {
            super(_name, MeshTorus.getShape(_radiusRing, _radiusTube, Math.max(3, _latitudes)), _longitudes);
            this.latitudes = 12;
            this.radiusRing = 0.5 - 0.125;
            this.radiusTube = 0.125;
            this.radiusTube = _radiusTube;
            this.radiusRing = _radiusRing;
            this.longitudes = _longitudes;
            this.latitudes = Math.max(3, _latitudes);
        }
        static getShape(_radiusRing, _radiusTube, _latitudes) {
            let shape = [];
            let center = new FudgeCore.Vector2(_radiusRing, 0);
            for (let latitude = 0; latitude <= _latitudes; latitude++) {
                let angle = 2 * Math.PI * latitude / _latitudes;
                shape.push(FudgeCore.Vector2.SUM(center, new FudgeCore.Vector2(_radiusTube * -Math.cos(angle), _radiusTube * Math.sin(angle))));
            }
            return shape;
        }
        /**
         * Create this torus from the given parameters
         */
        create(_radiusRing = 0.5 - 0.125, _radiusTube = 0.125, _longitudes = 8, _latitudes = 6) {
            this.radiusTube = _radiusTube;
            this.latitudes = Math.max(3, _latitudes);
            this.radiusRing = _radiusRing;
            super.rotate(MeshTorus.getShape(_radiusRing, _radiusTube, _latitudes), _longitudes);
        }
        //#region Transfer
        serialize() {
            let serialization = super.serialize();
            serialization.latitudes = this.latitudes;
            serialization.radiusRing = this.radiusRing;
            serialization.radiusTube = this.radiusTube;
            return serialization;
        }
        async deserialize(_serialization) {
            await super.deserialize(_serialization);
            this.create(_serialization.radiusRing, _serialization.radiusTube, _serialization.longitudes, _serialization.latitudes);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            super.mutate(_mutator, _selection, _dispatchMutate);
            this.create(this.radiusRing, this.radiusTube, this.longitudes, this.latitudes);
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.shape;
        }
    }
    FudgeCore.MeshTorus = MeshTorus;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    let QUADSPLIT;
    (function (QUADSPLIT) {
        QUADSPLIT[QUADSPLIT["PLANAR"] = 0] = "PLANAR";
        QUADSPLIT[QUADSPLIT["AT_0"] = 1] = "AT_0";
        QUADSPLIT[QUADSPLIT["AT_1"] = 2] = "AT_1";
    })(QUADSPLIT = FudgeCore.QUADSPLIT || (FudgeCore.QUADSPLIT = {}));
    /**
     * A surface created with four vertices which immediately creates none, one or two {@link Face}s depending on vertices at identical positions.
     * ```text
     * QUADSPLIT:  PLANAR                  AT_0                     AT_1
     *             0 _ 3                   0 _ 3                    0 _ 3
     *              |\|                     |\|                      |/|
     *             1 ‚Äæ 2                   1 ‚Äæ 2                    1 ‚Äæ 2
     *  shared last vertex 2      last vertices 2 + 3      last vertices 3 + 0
     *
     * ```
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Quad {
        #split;
        constructor(_vertices, _index0, _index1, _index2, _index3, _split = QUADSPLIT.PLANAR) {
            this.faces = [];
            this.#split = _split;
            try {
                if (_split != QUADSPLIT.AT_1)
                    this.faces.push(new FudgeCore.Face(_vertices, _index0, _index1, _index2));
                else
                    this.faces.push(new FudgeCore.Face(_vertices, _index1, _index2, _index3));
            }
            catch (_e) {
                FudgeCore.Debug.fudge("Face excluded", _e.message);
            }
            try {
                if (_split == QUADSPLIT.PLANAR)
                    this.faces.push(new FudgeCore.Face(_vertices, _index3, _index0, _index2));
                else if (_split == QUADSPLIT.AT_0)
                    this.faces.push(new FudgeCore.Face(_vertices, _index0, _index2, _index3));
                else
                    this.faces.push(new FudgeCore.Face(_vertices, _index1, _index3, _index0));
            }
            catch (_e) {
                FudgeCore.Debug.fudge("Face excluded", _e.message);
            }
        }
        get split() {
            return this.#split;
        }
    }
    FudgeCore.Quad = Quad;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    // TODO: the refer to  description is no longer correct as refer to also works for bone indices
    /**
     * Represents a vertex of a mesh with extended information such as the uv coordinates and the vertex normal.
     * It may refer to another vertex via an index into some array, in which case the position and the normal are stored there.
     * This way, vertex position and normal is a 1:1 association, vertex to texture coordinates a 1:n association.
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Vertex {
        /**
         * Represents a vertex of a mesh with extended information such as the uv coordinates the vertex normal and its tangents.
         * It may refer to another vertex via an index into some array, in which case the position and the normal are stored there.
         * This way, vertex position and normal is a 1:1 association, vertex to texture coordinates a 1:n association.
       * @authors Jirka Dell'Oro-Friedl, HFU, 2022
         */
        constructor(_positionOrIndex, _uv = null, _normal = FudgeCore.Vector3.ZERO(), _tangent = null, _color = new FudgeCore.Color(1, 1, 1, 1), _bones = null) {
            if (_positionOrIndex instanceof FudgeCore.Vector3)
                this.position = _positionOrIndex;
            else
                this.referTo = _positionOrIndex;
            this.uv = _uv;
            this.normal = _normal;
            this.tangent = _tangent;
            this.color = _color;
            this.bones = _bones;
        }
    }
    FudgeCore.Vertex = Vertex;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Array with extended functionality to serve as a {@link Vertex}-cloud.
     * Accessors yield position or normal also for vertices referencing other vertices
     * @authors Jirka Dell'Oro-Friedl, HFU, 2022
     */
    class Vertices extends Array {
        // TODO: this class may become more powerful by hiding the array and add more service methods like calculating bounding box, radius etc.
        // see if a proxy of the array interfacing [] would do a good job -> tested: proxy is about 20 times slower!
        /**
         * Returns the subset of vertices that do not refer to other vertices
         */
        get originals() {
            return this.filter(_vertex => _vertex.referTo == undefined);
        }
        /**
         * returns the position associated with the vertex addressed, resolving references between vertices
         */
        position(_index) {
            let vertex = this[_index];
            return (vertex.referTo == undefined) ? vertex.position : this[vertex.referTo].position;
        }
        /**
         * returns the normal associated with the vertex addressed, resolving references between vertices
         */
        normal(_index) {
            let vertex = this[_index];
            return (vertex.referTo == undefined) ? vertex.normal : this[vertex.referTo].normal;
        }
        /**
         * returns the tangent associated with the vertex addressed
         */
        tangent(_index) {
            return this[_index].tangent; // tangents can not be shared as they are dependent on the uv-coordinates
        }
        /**
         * returns the uv-coordinates associated with the vertex addressed
         */
        uv(_index) {
            return this[_index].uv;
        }
        /**
         * returns the color associated with the vertex addressed
         */
        color(_index) {
            return this[_index].color;
        }
        /**
         * returns the bones associated with the vertex addressed, resolving references between vertices
         */
        bones(_index) {
            let vertex = this[_index];
            return (vertex.referTo == undefined) ? vertex.bones : this[vertex.referTo].bones;
        }
    }
    FudgeCore.Vertices = Vertices;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A WebGL shaderprogram for a particle system. Managed by a {@link ParticleSystem}. It uses {@link ParticleSystem.data} to generate and inject code into a shader universal derivate (GLSL) thus creating a shader particle system from a supplied {@link Shader}s vertex and fragment shader source code.
     * @author Jonas Plotzky, HFU, 2022
     * @internal
     */
    let ShaderParticleSystem = (() => {
        var _a;
        let _classDecorators = [(_a = FudgeCore.RenderInjectorShaderParticleSystem).decorate.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        var ShaderParticleSystem = class {
            static { _classThis = this; }
            constructor() {
                this.define = ["PARTICLE"];
            }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                ShaderParticleSystem = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                __runInitializers(_classThis, _classExtraInitializers);
            }
            /**
             * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
             * @internal
             */
            getVertexShaderSource() { return ""; /* injected by decorator */ }
            /**
             * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
             * @internal
             */
            getFragmentShaderSource() { return ""; /* injected by decorator */ }
            /**
             * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
             * @internal
             */
            deleteProgram() { }
            /**
             * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
             * @internal
             */
            useProgram() { }
            /**
             * Injected by {@link RenderInjectorShaderParticleSystem}. Used by the render system.
             * @internal
             */
            createProgram() { }
        };
        return ShaderParticleSystem = _classThis;
    })();
    FudgeCore.ShaderParticleSystem = ShaderParticleSystem;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Enables this node to access the waypoint grid established through {@link ComponentWaypoint}s and their {@link Connection}s,
     * find a path through them and even walk down the path.
     * @author Lukas Scheuerle, HFU, 2024
     */
    class ComponentWalker extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentWalker); }
        /** If true, move the node this component is attached to through forces instead of directly through the transform. Requires a [[ComponentRigidbody]] if true. */
        // public moveThroughPhysics: boolean = false;
        /** keeps the data needed for the current walk */
        #walkData;
        /** keeps the promise to resolve when the walker has reached the goal */
        #promiseResolverOnWalkFinished;
        /** status of whether it should rotate the walker to the walking direction */
        #rotateInWalkDirection;
        constructor() {
            super();
            /** The speed the walker should move with. Corresponds to units/s. */
            this.speed = 1;
            /** If true, move the node this component is attached to through forces instead of directly through the transform. Requires a [[ComponentRigidbody]] if true. */
            // public moveThroughPhysics: boolean = false;
            /** keeps the data needed for the current walk */
            this.#walkData = { path: [], totalProgress: -1 };
            /** status of whether it should rotate the walker to the walking direction */
            this.#rotateInWalkDirection = false;
            if (FudgeCore.Project.mode == FudgeCore.MODE.EDITOR)
                return;
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.#handleAttach.bind(this));
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.#handleDetach.bind(this));
        }
        serialize() {
            let serialization = {
                [super.constructor.name]: super.serialize(),
                speed: this.speed
                // moveThroughPhysics: this.moveThroughPhysics,
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.speed = _serialization.speed;
            // this.moveThroughPhysics = _serialization.moveThroughPhysics;
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async moveTo(_start, _end, _rotate = false) {
            if (!_start)
                return;
            let translate = FudgeCore.Vector3.DIFFERENCE(_start.mtxWorld.translation, this.node.mtxWorld.translation);
            this.node.mtxLocal.translate(translate);
            if (!_end || _start === _end) {
                this.#walkData = { path: [], totalProgress: -1 };
                return;
            }
            this.#rotateInWalkDirection = _rotate;
            return new Promise((_resolve, _reject) => {
                let path = this.getPath(_start, _end);
                if (!path || path.length === 0) {
                    _reject();
                    return;
                }
                this.#walkData = { path, totalProgress: 0 };
                this.#promiseResolverOnWalkFinished = _resolve;
                if (this.#rotateInWalkDirection && this.#walkData.path.length >= 1) {
                    this.rotateTowards(this.#walkData.path[0].waypoint);
                }
            });
        }
        /** Takes care of the moving algorithm by calculating the next step and moving along this step */
        moving() {
            // are we currently moving?
            if (this.#walkData.totalProgress < 0 || this.#walkData.path.length == 0)
                return;
            // do we have a current path we can follow
            let currentPath = this.#walkData.path[this.#walkData.totalProgress];
            if (!currentPath)
                return;
            // how big of a step are we taking this frame?
            let delta = this.speed * currentPath.previousConnection.speedModifier * FudgeCore.Loop.timeFrameGame / 1000;
            // how far away are we from the next waypoint?
            let step = FudgeCore.Vector3.DIFFERENCE(currentPath.waypoint.mtxWorld.translation, this.node.mtxWorld.translation);
            // let stepRotation: Matrix4x4 = Matrix4x4.CONSTRUCTION(step);
            // stepRotation.rotate(this.node.mtxWorld.rotation);
            // step = stepRotation.translation;
            let scale = FudgeCore.Vector3.DIFFERENCE(currentPath.waypoint.mtxWorld.scaling, this.node.mtxWorld.scaling);
            if (delta * delta < step.magnitudeSquared) { // won't reach next waypoint yet. Using squares because that's faster to compute than sqrt
                step.normalize(delta);
                this.node.mtxLocal.translate(step, false);
                if (scale.magnitudeSquared > 0) {
                    scale.normalize(delta);
                }
                this.node.mtxLocal.scaling = FudgeCore.Vector3.SUM(scale, this.node.mtxLocal.scaling);
                // this.node.mtxLocal.scale(Vector3.SUM(scale, this.node.mtxLocal.scaling));
                // TODO implement movement through physics
                return;
            }
            // reached next point
            this.dispatchEvent(new CustomEvent("waypointReached" /* EVENT.WAYPOINT_REACHED */, { bubbles: true, detail: currentPath.waypoint }));
            currentPath.waypoint.dispatchEvent(new CustomEvent("waypointReached" /* EVENT.WAYPOINT_REACHED */, { bubbles: true, detail: this }));
            let translate = FudgeCore.Vector3.DIFFERENCE(currentPath.waypoint.mtxWorld.translation, this.node.mtxWorld.translation);
            this.node.mtxLocal.translate(translate, false);
            this.node.mtxLocal.scaling = currentPath.waypoint.mtxWorld.scaling;
            this.#walkData.totalProgress++;
            // reached final point, finished walking
            if (this.#walkData.totalProgress >= this.#walkData.path.length) {
                if (this.#promiseResolverOnWalkFinished)
                    this.#promiseResolverOnWalkFinished();
                this.dispatchEvent(new CustomEvent("pathingConcluded" /* EVENT.PATHING_CONCLUDED */, { bubbles: true, detail: currentPath.waypoint }));
                return;
            }
            // should we rotate walker?
            if (this.#rotateInWalkDirection) {
                this.rotateTowards(this.#walkData.path[this.#walkData.totalProgress].waypoint);
            }
        }
        /** find the path between two given waypoints */
        getPath(_start, _end) {
            // TODO: use a more efficient algorithm like A* instead of Dijkstra
            // setup the graph of paths based on the start node
            let unvisitedNodes = [];
            let processedWaypoints = [_start];
            let waypointsToSearchThrough = [_start];
            do {
                let waypoint = waypointsToSearchThrough.pop();
                for (let connection of waypoint.connections) {
                    if (!processedWaypoints.includes(connection.end) && connection.start.isActive && connection.end.isActive) {
                        waypointsToSearchThrough.push(connection.end);
                        processedWaypoints.push(connection.end);
                    }
                }
                unvisitedNodes.push({ waypoint, distance: waypoint === _start ? 0 : Infinity, previous: null, previousConnection: null });
            } while (waypointsToSearchThrough.length > 0);
            // do the dijkstra
            while (unvisitedNodes.length > 0) {
                unvisitedNodes.sort((_a, _b) => _a.distance - _b.distance);
                let currentNode = unvisitedNodes.shift();
                if (currentNode.waypoint === _end)
                    return this.pathingNodeToPath(currentNode);
                for (let con of currentNode.waypoint.connections) {
                    if (!this.isConnectionUsable(con))
                        continue;
                    let endNode = unvisitedNodes.find(_n => _n.waypoint === con.end);
                    if (!endNode)
                        continue;
                    let newDistance = currentNode.distance + this.calculateConnectionCost(con);
                    if (newDistance >= endNode.distance)
                        continue;
                    endNode.distance = newDistance;
                    endNode.previous = currentNode;
                    endNode.previousConnection = con;
                }
            }
            return null;
        }
        /**
         * Checks whether a connection is usable by this specific walker.
         * **Always returns true, unless overwritten in a custom Walker subclass.**
         * Can be used to influence the pathfinding algorithm for custom waypoint / connection systems.
         * @param _connection A connection to check
         * @returns true if the connection is usable by this walker, false if not
         */
        isConnectionUsable(_connection) {
            return true;
        }
        /**
         * Calculates the new distance based on a connection.
         * **Always returns the plain connections cost unless overwritten in a custom walker subclass.**
         * Can be used to influence the pathfinding algorithm for custom waypoint / connection systems.
         * @param _connection A connection to check
         * @returns the amount of cost a connection encurs to the current walker or 0 if cost is negative.
         */
        calculateConnectionCost(_connection) {
            if (_connection.cost >= 0)
                return _connection.cost;
            return 0;
        }
        pathingNodeToPath(_node) {
            let path = [];
            if (!_node)
                return path;
            do {
                path.push(_node);
                _node = _node.previous;
            } while (_node?.previous);
            return path.reverse();
        }
        rotateTowards(_waypoint) {
            let mtxLook = FudgeCore.Matrix4x4.LOOK_AT(this.node.mtxWorld.translation, _waypoint.mtxWorld.translation);
            this.node.mtxLocal.rotation = mtxLook.rotation;
        }
        #handleAttach() {
            FudgeCore.Loop.addEventListener("loopFrame" /* EVENT.LOOP_FRAME */, this.moving.bind(this));
        }
        #handleDetach() {
            FudgeCore.Loop.removeEventListener("loopFrame" /* EVENT.LOOP_FRAME */, this.moving.bind(this));
        }
    }
    FudgeCore.ComponentWalker = ComponentWalker;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    var _a;
    /**
     * Sets a position that a {@link ComponentWalker} can use as a target point.
     * Implements {@link Waypoint}.
     * Registers itself to a static list of all available waypoints
     * @author Lukas Scheuerle, HFU, 2024
     */
    class ComponentWaypoint extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(this); }
        static #waypoints = [];
        #connections;
        constructor(_mtxInit = FudgeCore.Matrix4x4.IDENTITY(), _connections = []) {
            super();
            this.#connections = _connections;
            this.mtxLocal = _mtxInit;
            this.singleton = false;
            if (FudgeCore.Project.mode == FudgeCore.MODE.EDITOR)
                return;
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.#handleAttach.bind(this));
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.#handleDetach.bind(this));
        }
        /** All the waypoints that are currently loaded in the scene. **Do not edit, treat as readonly!** */
        static get waypoints() {
            return _a.#waypoints;
        }
        /**
         * A shorthand to create a connection between two {@link ComponentWaypoint}s
         * @param _start The {@link ComponentWaypoint} from which to start the connection.
         * @param _end The {@link ComponentWaypoint} to which the connection leads.
         * @param _cost The cost of the connection. The higher the value, the less likely it is to be taken. Cannot be negative.
         * @param _speedModifier How fast the connection can be walked on. Defaults to 1
         * @param _bothWays If true, creates a connection in both directions. Default: false
         */
        static addConnection(_start, _end, _cost, _speedModifier = 1, _bothWays = false) {
            _start.addConnection({ cost: _cost, end: _end, start: _start, speedModifier: _speedModifier });
            if (_bothWays)
                _end.addConnection({ cost: _cost, end: _start, start: _end, speedModifier: _speedModifier });
        }
        get isActive() {
            return this.active;
        }
        get connections() {
            return this.#connections;
        }
        /** The current world position of the Waypoint. Returns a new Matrix without connection to the Waypoint */
        get mtxWorld() {
            return FudgeCore.Matrix4x4.PRODUCT(this.mtxLocal, this.node.mtxWorld);
        }
        /** Adds a new {@link Connection} to this waypoint */
        addConnection(_connection) {
            this.#connections.push(_connection);
        }
        /** Removes a {@link Connection} from this waypoint */
        removeConnection(_connection) {
            let index = this.#connections.indexOf(_connection);
            if (index < 0)
                return;
            this.#connections.splice(index, 1);
        }
        serialize() {
            let serialization = {
                [super.constructor.name]: super.serialize(),
                matrix: this.mtxLocal.serialize(),
                connections: this.#connections.map(_con => {
                    let connection = { cost: _con.cost, end: _con.end, speedModifier: _con.speedModifier };
                    if (connection.end instanceof _a) {
                        connection.end = FudgeCore.Node.PATH_FROM_TO(this, connection.end);
                    }
                    return connection;
                })
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.mtxLocal.deserialize(_serialization.matrix);
            const hndNodeDeserialized = () => {
                this.#connections = _serialization.connections.map((_con) => {
                    let connection = { cost: _con.cost, end: this.serializedWaypointToWaypoint(_con.end), speedModifier: _con.speedModifier, start: this };
                    return connection;
                });
                this.removeEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
            };
            this.addEventListener("nodeDeserialized" /* EVENT.NODE_DESERIALIZED */, hndNodeDeserialized);
            await super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        drawGizmos() {
            let scaleVector = FudgeCore.Vector3.SCALE(FudgeCore.Vector3.ONE(), 0.1);
            let mtx = this.mtxWorld;
            FudgeCore.Gizmos.drawSphere(FudgeCore.Matrix4x4.COMPOSITION(mtx.translation, FudgeCore.Vector3.ZERO(), scaleVector), FudgeCore.Color.CSS("orange"));
            // return;
            let lines = [];
            for (let connection of this.connections) {
                // if the start and end point are on the same point, don't draw line.
                let tmpMtx = connection.end.mtxWorld.clone;
                let directionVector = FudgeCore.Vector3.DIFFERENCE(mtx.translation, tmpMtx.translation);
                if (directionVector.magnitudeSquared === 0)
                    continue;
                directionVector.normalize();
                // if one of the waypoints is inactive, don't draw gizmos
                if (!connection.end.isActive || !connection.start.isActive)
                    continue;
                // actual line
                lines.push(mtx.translation);
                lines.push(tmpMtx.translation);
                // arrow heads
                let directionMtx = FudgeCore.Matrix4x4.LOOK_IN(directionVector, undefined, false, tmpMtx.translation);
                directionMtx.scale(scaleVector);
                FudgeCore.Gizmos.drawWireCone(directionMtx, FudgeCore.Color.CSS("orange"));
            }
            FudgeCore.Gizmos.drawLines(lines, FudgeCore.Matrix4x4.IDENTITY(), FudgeCore.Color.CSS("orange"));
        }
        /** An internal function to help the deserializaztion process. */
        serializedWaypointToWaypoint(_point) {
            if (typeof _point !== "string")
                return _point;
            return FudgeCore.Node.FIND(this, _point);
        }
        #handleAttach() {
            _a.#waypoints.push(this);
        }
        #handleDetach() {
            let index = _a.#waypoints.indexOf(this);
            if (index >= 0) {
                _a.#waypoints.splice(index, 1);
            }
        }
    }
    _a = ComponentWaypoint;
    FudgeCore.ComponentWaypoint = ComponentWaypoint;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines automatic adjustment of the collider
     */
    let BODY_INIT;
    (function (BODY_INIT) {
        /** Collider uses the pivot of the mesh for initilialization */
        BODY_INIT[BODY_INIT["TO_MESH"] = 0] = "TO_MESH";
        /** Collider uses the transform of the node for initilialization */
        BODY_INIT[BODY_INIT["TO_NODE"] = 1] = "TO_NODE";
        /** Collider uses its own pivot for initilialization */
        BODY_INIT[BODY_INIT["TO_PIVOT"] = 2] = "TO_PIVOT";
    })(BODY_INIT = FudgeCore.BODY_INIT || (FudgeCore.BODY_INIT = {}));
    /**
     * Acts as the physical representation of the {@link Node} it's attached to.
     * It's the connection between the FUDGE rendered world and the Physics world.
     * For the physics to correctly get the transformations rotations need to be applied with from left = true.
     * Or rotations need to happen before scaling.
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class ComponentRigidbody extends FudgeCore.Component {
        static { this.iSubclass = FudgeCore.Component.registerSubclass(ComponentRigidbody); }
        static { this.mapBodyType = (typeof OIMO == "undefined") ?
            {
                [FudgeCore.BODY_TYPE.DYNAMIC]: FudgeCore.BODY_TYPE.DYNAMIC, [FudgeCore.BODY_TYPE.STATIC]: FudgeCore.BODY_TYPE.STATIC, [FudgeCore.BODY_TYPE.KINEMATIC]: FudgeCore.BODY_TYPE.KINEMATIC
            } : {
            [FudgeCore.BODY_TYPE.DYNAMIC]: OIMO.RigidBodyType.DYNAMIC, [FudgeCore.BODY_TYPE.STATIC]: OIMO.RigidBodyType.STATIC, [FudgeCore.BODY_TYPE.KINEMATIC]: OIMO.RigidBodyType.KINEMATIC
        }; }
        /** ID to reference this specific ComponentRigidbody */
        #id;
        //Private informations - Mostly OimoPhysics variables that should not be exposed to the FUDGE User and manipulated by them
        #collider;
        #colliderInfo;
        #collisionGroup;
        #typeCollider;
        #rigidbody;
        #rigidbodyInfo;
        #typeBody;
        #massData;
        #restitution;
        #friction;
        #dampingLinear;
        #dampingAngular;
        #effectRotation;
        #effectGravity;
        #isTrigger;
        #mtxPivotUnscaled;
        #mtxPivotInverse;
        #callbacks; //Callback Methods when within the oimoSystem a event is happening
        // #physics: Physics; //TODO: keep a pointer to the physics instance used by this component
        /** Creating a new rigidbody with a weight in kg, a physics type (default = dynamic), a collider type what physical form has the collider, to what group does it belong, is there a transform Matrix that should be used, and is the collider defined as a group of points that represent a convex mesh. */
        constructor(_mass = 1, _type = FudgeCore.BODY_TYPE.DYNAMIC, _colliderType = FudgeCore.COLLIDER_TYPE.CUBE, _group = FudgeCore.Physics.settings.defaultCollisionGroup, _mtxTransform = null, _convexMesh = null) {
            super();
            /** Transformation of the collider relative to the node's transform. Once set mostly remains constant.
             * If altered, {@link isInitialized} must be reset to false to recreate the collider in the next {@link Render.prepare}
             */
            this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
            /**
             * Vertices that build a convex mesh (form that is in itself closed). Needs to set in the construction of the rb if none of the standard colliders is used.
             * Untested and not yet fully supported by serialization and mutation.
             */
            this.convexMesh = null;
            /** Collisions with rigidbodies happening to this body, can be used to build a custom onCollisionStay functionality. */
            this.collisions = new Array();
            /** Triggers that are currently triggering this body */
            this.triggerings = new Array();
            /**
             * Automatic adjustment of the pivot when {@link Render.prepare} is called according to {@link BODY_INIT}
             */
            this.initialization = BODY_INIT.TO_PIVOT;
            /** Marks if collider was initialized. Reset to false to initialize again e.g. after manipulation of mtxPivot */
            this.isInitialized = false;
            /** ID to reference this specific ComponentRigidbody */
            this.#id = 0;
            this.#collisionGroup = FudgeCore.COLLISION_GROUP.DEFAULT;
            this.#typeCollider = FudgeCore.COLLIDER_TYPE.CUBE;
            this.#rigidbodyInfo = new OIMO.RigidBodyConfig();
            this.#typeBody = FudgeCore.BODY_TYPE.DYNAMIC;
            this.#massData = new OIMO.MassData();
            this.#dampingLinear = 0.1;
            this.#dampingAngular = 0.1;
            this.#effectRotation = FudgeCore.Vector3.ONE();
            this.#effectGravity = 1;
            this.#isTrigger = false;
            this.#mtxPivotUnscaled = FudgeCore.Matrix4x4.IDENTITY();
            this.#mtxPivotInverse = FudgeCore.Matrix4x4.IDENTITY();
            //#endregion
            // Activate the functions of this component as response to events
            this.hndEvent = (_event) => {
                switch (_event.type) {
                    case "componentAdd" /* EVENT.COMPONENT_ADD */:
                        // this.addEventListener(EVENT.COMPONENT_ACTIVATE, this.addRigidbodyToWorld);
                        this.addEventListener("componentDeactivate" /* EVENT.COMPONENT_DEACTIVATE */, this.removeRigidbodyFromWorld);
                        // this.node.addEventListener(EVENT.NODE_ACTIVATE, this.addRigidbodyToWorld, true); // use capture to react to broadcast!
                        this.node.addEventListener("nodeDeactivate" /* EVENT.NODE_DEACTIVATE */, this.hndNodeDeactivate, true);
                        if (!this.node.cmpTransform)
                            FudgeCore.Debug.warn("ComponentRigidbody attached to node missing ComponentTransform", this.node);
                        break;
                    case "componentRemove" /* EVENT.COMPONENT_REMOVE */:
                        // this.removeEventListener(EVENT.COMPONENT_ADD, this.addRigidbodyToWorld);
                        this.removeEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.removeRigidbodyFromWorld);
                        // this.node.removeEventListener(EVENT.NODE_ACTIVATE, this.addRigidbodyToWorld, true); // use capture to react to broadcast!
                        this.node.removeEventListener("nodeDeactivate" /* EVENT.NODE_DEACTIVATE */, this.hndNodeDeactivate, true);
                        this.removeRigidbodyFromWorld();
                        break;
                    case "nodeDeserialized" /* EVENT.NODE_DESERIALIZED */:
                        if (!this.node.cmpTransform)
                            FudgeCore.Debug.error("ComponentRigidbody attached to node missing ComponentTransform", this.node);
                        break;
                }
            };
            /** Adding this ComponentRigidbody to the Physiscs.world giving the oimoPhysics system the information needed */
            this.addRigidbodyToWorld = () => {
                if (!this.#rigidbody._world)
                    FudgeCore.Physics.addRigidbody(this);
            };
            /** Capture only events that are broadcast to this node from an ancestor. Don't capture events that get send to descendants. */
            this.hndNodeDeactivate = (_event) => {
                let path = this.node.getPath();
                if (!path.includes(_event.target))
                    return;
                this.removeRigidbodyFromWorld();
            };
            /** Removing this ComponentRigidbody from the Physiscs.world taking the informations from the oimoPhysics system */
            this.removeRigidbodyFromWorld = () => {
                FudgeCore.Physics.removeRigidbody(this);
                this.isInitialized = false;
            };
            this.create(_mass, _type, _colliderType, _group, _mtxTransform, _convexMesh);
            this.addEventListener("componentAdd" /* EVENT.COMPONENT_ADD */, this.hndEvent);
            this.addEventListener("componentRemove" /* EVENT.COMPONENT_REMOVE */, this.hndEvent);
            // this.addEventListener(EVENT.NODE_DESERIALIZED, this.hndEvent);
        }
        //#region Accessors
        get id() {
            return this.#id;
        }
        /** Used for calculation of the geometrical relationship of node and collider by {@link Render}*/
        get mtxPivotInverse() {
            return this.#mtxPivotInverse;
        }
        /** Used for calculation of the geometrical relationship of node and collider by {@link Render}*/
        get mtxPivotUnscaled() {
            return this.#mtxPivotUnscaled;
        }
        /** Retrieve the body type. See {@link BODY_TYPE} */
        get typeBody() {
            return this.#typeBody;
        }
        /** Set the body type. See {@link BODY_TYPE} */
        set typeBody(_value) {
            this.#typeBody = _value;
            this.#rigidbody.setType(ComponentRigidbody.mapBodyType[this.#typeBody]);
            this.#rigidbody.setMassData(this.#massData); //have to reset mass after changing the type, since Oimo is handling mass internally wrong when switching types
        }
        /** The shape that represents the {@link Node} in the physical world. Default is a Cube. */
        get typeCollider() {
            return this.#typeCollider;
        }
        set typeCollider(_value) {
            if (_value != this.#typeCollider && this.#rigidbody != null) {
                this.#typeCollider = _value;
                this.initialize();
            }
        }
        /** The collision group this {@link Node} belongs to it's the default group normally which means it physically collides with every group besides trigger. */
        get collisionGroup() {
            return this.#collisionGroup;
        }
        set collisionGroup(_value) {
            this.#collisionGroup = _value;
            if (this.#rigidbody != null)
                this.#rigidbody.getShapeList().setCollisionGroup(this.#collisionGroup);
        }
        /** Marking the Body as a trigger therefore not influencing the collision system but only sending triggerEvents */
        get isTrigger() {
            return this.#isTrigger;
        }
        set isTrigger(_value) {
            this.#isTrigger = _value;
            if (this.getOimoRigidbody() != null) {
                this.getOimoRigidbody()._isTrigger = this.#isTrigger;
            }
        }
        /**
         * Returns the physical weight of the {@link Node}
         */
        get mass() {
            return this.#rigidbody.getMass();
        }
        /**
         * Setting the physical weight of the {@link Node} in kg
         */
        set mass(_value) {
            this.#massData.mass = _value;
            if (this.node != null)
                if (this.#rigidbody != null)
                    this.#rigidbody.setMassData(this.#massData);
        }
        /** Drag of linear movement. A Body does slow down even on a surface without friction. */
        get dampTranslation() {
            return this.#rigidbody.getLinearDamping();
        }
        set dampTranslation(_value) {
            this.#dampingLinear = _value;
            this.#rigidbody.setLinearDamping(_value);
        }
        /** Drag of rotation. */
        get dampRotation() {
            return this.#rigidbody.getAngularDamping();
        }
        set dampRotation(_value) {
            this.#dampingAngular = _value;
            this.#rigidbody.setAngularDamping(_value);
        }
        /** The factor this rigidbody reacts rotations that happen in the physical world. 0 to lock rotation this axis. */
        get effectRotation() {
            return this.#effectRotation;
        }
        set effectRotation(_effect) {
            this.#effectRotation = _effect;
            this.#rigidbody.setRotationFactor(new OIMO.Vec3(this.#effectRotation.x, this.#effectRotation.y, this.#effectRotation.z));
        }
        /** The factor this rigidbody reacts to world gravity. Default = 1 e.g. 1*9.81 m/s. */
        get effectGravity() {
            return this.#effectGravity;
        }
        set effectGravity(_effect) {
            this.#effectGravity = _effect;
            if (this.#rigidbody != null)
                this.#rigidbody.setGravityScale(this.#effectGravity);
        }
        /**
         * Get the friction of the rigidbody, which is the factor of sliding resistance of this rigidbody on surfaces
         */
        get friction() {
            return this.#friction;
        }
        /**
         * Set the friction of the rigidbody, which is the factor of  sliding resistance of this rigidbody on surfaces
         */
        set friction(_friction) {
            this.#friction = _friction;
            if (this.#rigidbody.getShapeList() != null)
                this.#rigidbody.getShapeList().setFriction(this.#friction);
        }
        /**
         * Get the restitution of the rigidbody, which is the factor of bounciness of this rigidbody on surfaces
         */
        get restitution() {
            return this.#restitution;
        }
        /**
         * Set the restitution of the rigidbody, which is the factor of bounciness of this rigidbody on surfaces
         */
        set restitution(_restitution) {
            this.#restitution = _restitution;
            if (this.#rigidbody.getShapeList() != null)
                this.#rigidbody.getShapeList().setRestitution(this.#restitution);
        }
        //#endregion
        //#region Transformation
        /**
         * Returns the rigidbody in the form the physics engine is using it, should not be used unless a functionality
         * is not provided through the FUDGE Integration.
         */
        getOimoRigidbody() {
            return this.#rigidbody;
        }
        /** Rotating the rigidbody therefore changing it's rotation over time directly in physics. This way physics is changing instead of transform.
         *  But you are able to incremental changing it instead of a direct rotation.  Although it's always prefered to use forces in physics.
         */
        rotateBody(_rotationChange) {
            this.#rigidbody.rotateXyz(new OIMO.Vec3(_rotationChange.x * FudgeCore.Calc.deg2rad, _rotationChange.y * FudgeCore.Calc.deg2rad, _rotationChange.z * FudgeCore.Calc.deg2rad));
        }
        /** Translating the rigidbody therefore changing it's place over time directly in physics. This way physics is changing instead of transform.
         *  But you are able to incrementally changing it instead of a direct position. Although it's always prefered to use forces in physics.
         */
        translateBody(_translationChange) {
            this.#rigidbody.translate(new OIMO.Vec3(_translationChange.x, _translationChange.y, _translationChange.z));
        }
        /**
         * Get the current POSITION of the {@link Node} in the physical space
         */
        getPosition() {
            let tmpPos = this.#rigidbody.getPosition();
            return new FudgeCore.Vector3(tmpPos.x, tmpPos.y, tmpPos.z);
        }
        /**
         * Sets the current POSITION of the {@link Node} in the physical space
         */
        setPosition(_value) {
            this.#rigidbody.setPosition(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /**
         * Get the current ROTATION of the {@link Node} in the physical space. Note this range from -pi to pi, so -90 to 90.
         */
        getRotation() {
            let orientation = this.#rigidbody.getOrientation();
            let tmpQuat = FudgeCore.Recycler.get(FudgeCore.Quaternion);
            tmpQuat.set(orientation.x, orientation.y, orientation.z, orientation.w);
            let eulerAngles = tmpQuat.eulerAngles.clone;
            FudgeCore.Recycler.store(tmpQuat);
            return eulerAngles;
        }
        /**
         * Sets the current ROTATION of the {@link Node} in the physical space, in degree.
         */
        setRotation(_value) {
            let quaternion = _value instanceof FudgeCore.Vector3 ? FudgeCore.Quaternion.ROTATION(_value) : _value;
            let quat = new OIMO.Quat(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
            if (_value instanceof FudgeCore.Vector3)
                FudgeCore.Recycler.store(quaternion);
            this.#rigidbody.setOrientation(quat);
        }
        /** Get the current SCALING in the physical space. */
        getScaling() {
            let scaling = this.node.mtxWorld.scaling.clone;
            scaling.x *= this.mtxPivot.scaling.x;
            scaling.y *= this.mtxPivot.scaling.y;
            scaling.z *= this.mtxPivot.scaling.z;
            return scaling;
        }
        /** Scaling requires the collider to be completely recreated anew */
        setScaling(_value) {
            // let scaling: Vector3 = _value.clone;   
            this.createCollider(new OIMO.Vec3(_value.x / 2, _value.y / 2, _value.z / 2), this.#typeCollider); //recreate the collider
            this.#collider = new OIMO.Shape(this.#colliderInfo);
            let oldCollider = this.#rigidbody.getShapeList();
            this.#rigidbody.addShape(this.#collider); //add new collider, before removing the old, so the rb is never active with 0 colliders
            this.#rigidbody.removeShape(oldCollider); //remove the old collider
            this.#collider.userData = this; //reset the extra information so that this collider knows to which FUDGE Component it's connected
            this.#collider.setCollisionGroup(this.collisionGroup);
            this.#collider.setCollisionMask(this.collisionMask);
            this.#collider.setRestitution(this.#restitution);
            this.#collider.setFriction(this.#friction);
            this.#collider.setContactCallback(this.#callbacks);
        }
        /**
         * Initializes the rigidbody according to its initialization setting to match the mesh, the node or its own pivot matrix
         */
        initialize() {
            if (!this.node) // delay initialization until this rigidbody is attached to a node
                return;
            switch (Number(this.initialization)) {
                case BODY_INIT.TO_NODE:
                    this.mtxPivot = FudgeCore.Matrix4x4.IDENTITY();
                    break;
                case BODY_INIT.TO_MESH:
                    let cmpMesh = this.node.getComponent(FudgeCore.ComponentMesh);
                    if (cmpMesh)
                        this.mtxPivot = cmpMesh.mtxPivot.clone;
                    break;
                case BODY_INIT.TO_PIVOT:
                    break;
            }
            let mtxWorld = FudgeCore.Matrix4x4.PRODUCT(this.node.mtxWorld, this.mtxPivot);
            let position = mtxWorld.translation; //Adding the offsets from the pivot
            let rotation = mtxWorld.rotation;
            let scaling = mtxWorld.scaling;
            //scaling requires collider to be recreated
            this.setScaling(scaling);
            this.#rigidbody.setMassData(this.#massData);
            this.setPosition(position); //set the actual new rotation/position for this Rb again since it's now updated
            this.setRotation(rotation);
            let scalingInverse = this.node.mtxWorld.scaling.map(_i => 1 / _i);
            this.#mtxPivotUnscaled = FudgeCore.Matrix4x4.COMPOSITION(this.mtxPivot.translation, this.mtxPivot.rotation, scalingInverse);
            this.#mtxPivotInverse = FudgeCore.Matrix4x4.INVERSE(this.#mtxPivotUnscaled);
            this.addRigidbodyToWorld();
            this.isInitialized = true;
        }
        //#endregion
        //#region Velocity and Forces
        /**
        * Get the current VELOCITY of the {@link Node}
        */
        getVelocity() {
            let velocity = this.#rigidbody.getLinearVelocity();
            return new FudgeCore.Vector3(velocity.x, velocity.y, velocity.z);
        }
        /**
         * Sets the current VELOCITY of the {@link Node}
         */
        setVelocity(_value) {
            let velocity = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.#rigidbody.setLinearVelocity(velocity);
        }
        /**
         * Get the current ANGULAR - VELOCITY of the {@link Node}
         */
        getAngularVelocity() {
            let velocity = this.#rigidbody.getAngularVelocity();
            return new FudgeCore.Vector3(velocity.x, velocity.y, velocity.z);
        }
        /**
         * Sets the current ANGULAR - VELOCITY of the {@link Node}
         */
        setAngularVelocity(_value) {
            let velocity = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.#rigidbody.setAngularVelocity(velocity);
        }
        /**
        * Applies a continous FORCE at the center of the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS.
        * The force is measured in newton, 1kg needs about 10 Newton to fight against gravity.
        */
        applyForce(_force) {
            this.#rigidbody.applyForceToCenter(new OIMO.Vec3(_force.x, _force.y, _force.z));
        }
        /**
        * Applies a continous FORCE at a specific point in the world to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        */
        applyForceAtPoint(_force, _worldPoint) {
            this.#rigidbody.applyForce(new OIMO.Vec3(_force.x, _force.y, _force.z), new OIMO.Vec3(_worldPoint.x, _worldPoint.y, _worldPoint.z));
        }
        /**
        * Applies a continous ROTATIONAL FORCE (Torque) to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        */
        applyTorque(_rotationalForce) {
            this.#rigidbody.applyTorque(new OIMO.Vec3(_rotationalForce.x, _rotationalForce.y, _rotationalForce.z));
        }
        /**
        * Applies a instant FORCE at a point/rigidbodycenter to the RIGIDBODY in the three dimensions. Considering the rigidbod's MASS
        * Influencing the angular speed and the linear speed.
        */
        applyImpulseAtPoint(_impulse, _worldPoint = null) {
            _worldPoint = _worldPoint != null ? _worldPoint : this.getPosition();
            this.#rigidbody.applyImpulse(new OIMO.Vec3(_impulse.x, _impulse.y, _impulse.z), new OIMO.Vec3(_worldPoint.x, _worldPoint.y, _worldPoint.z));
        }
        /**
        * Applies a instant FORCE to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
        * Only influencing it's speed not rotation.
        */
        applyLinearImpulse(_impulse) {
            this.#rigidbody.applyLinearImpulse(new OIMO.Vec3(_impulse.x, _impulse.y, _impulse.z));
        }
        /**
         * Applies a instant ROTATIONAL-FORCE to the RIGIDBODY in the three dimensions. Considering the rigidbody's MASS
         * Only influencing it's rotation.
         */
        applyAngularImpulse(_rotationalImpulse) {
            this.#rigidbody.applyAngularImpulse(new OIMO.Vec3(_rotationalImpulse.x, _rotationalImpulse.y, _rotationalImpulse.z));
        }
        /**
         * Changing the VELOCITY of the RIGIDBODY. Only influencing the linear speed not angular
         */
        addVelocity(_value) {
            this.#rigidbody.addLinearVelocity(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /**
         * Changing the VELOCITY of the RIGIDBODY. Only influencing the angular speed not the linear
         */
        addAngularVelocity(_value) {
            this.#rigidbody.addAngularVelocity(new OIMO.Vec3(_value.x, _value.y, _value.z));
        }
        /**
         * De- / Activate the rigidbodies auto-sleeping function.
         * If activated the rigidbody will automatically sleep when needed, increasing performance.
         * If deactivated the rigidbody gets stopped from sleeping when movement is too minimal. Decreasing performance, for rarely more precise physics results
         */
        activateAutoSleep(_on) {
            this.#rigidbody.setAutoSleep(_on);
        }
        //#endregion
        //#region Collision
        // /**
        //  * Checking for Collision with other Colliders and dispatches a custom event with information about the collider.
        //  * Automatically called in the RenderManager, no interaction needed.
        //  */
        // public checkCollisionEvents(): void {
        //   if (!this.isInitialized) // check collisions only if initialization completed
        //     return;
        //   let contactLink: OIMO.ContactLink = this.#rigidbody.getContactLinkList(); // all physical contacts between colliding bodies on this rb
        //   while (contactLink != null) {
        //     let other: ComponentRigidbody = contactLink.getOther().userData; // get the other component rigidbody involved in the collision
        //     if (!other.isInitialized) {
        //       contactLink = contactLink.getNext();
        //       continue;
        //     }
        //     let contact: OIMO.Contact = contactLink.getContact();
        //     let wasTouching: boolean = this.collisions.includes(other);
        //     let isTouching: boolean = contact.isTouching();
        //     if (!wasTouching && isTouching) { // ENTER
        //       let manifold: OIMO.Manifold = contact.getManifold();
        //       let points: OIMO.ManifoldPoint[] = manifold.getPoints(); // All points in the collision where the two bodies are touching, used to calculate the full impact
        //       let normalImpulse: number = 0;
        //       let binormalImpulse: number = 0;
        //       let tangentImpulse: number = 0;
        //       for (let manifoldPoint of points) { // The impact of the collision involving all touching points
        //         normalImpulse += manifoldPoint.getNormalImpulse();
        //         binormalImpulse += manifoldPoint.getBinormalImpulse();
        //         tangentImpulse += manifoldPoint.getTangentImpulse();
        //       }
        //       let normal: OIMO.Vec3 = manifold.getNormal();
        //       let collisionNormal: Vector3 = new Vector3(normal.x, normal.y, normal.z);
        //       let collisionCenterPoint: Vector3 = this.collisionCenterPoint(points, manifold.getNumPoints());
        //       this.collisions.push(other);
        //       this.dispatchEvent(new EventPhysics(EVENT_PHYSICS.COLLISION_ENTER, other, normalImpulse, tangentImpulse, binormalImpulse, collisionCenterPoint, collisionNormal)); // Sending the given event
        //     } else if (wasTouching && !isTouching) { // EXIT
        //       this.collisions.splice(this.collisions.indexOf(other), 1);
        //       this.dispatchEvent(new EventPhysics(EVENT_PHYSICS.COLLISION_EXIT, other, 0, 0, 0));
        //     }
        //     contactLink = contactLink.getNext(); // Start the same routine with the next collision in the list
        //   }
        // }
        /**
         * Sends a ray through this specific body ignoring the rest of the world and checks if this body was hit by the ray,
         * returning info about the hit. Provides the same functionality and information a regular raycast does but the ray is only testing against this specific body.
         */
        raycastThisBody(_origin, _direction, _length, _debugDraw = false) {
            let hitInfo = new FudgeCore.RayHitInfo();
            let geometry = this.#rigidbody.getShapeList().getGeometry();
            let transform = this.#rigidbody.getTransform();
            let scaledDirection = _direction.clone;
            scaledDirection.scale(_length);
            let endpoint = FudgeCore.Vector3.SUM(scaledDirection, _origin.clone);
            let oimoRay = new OIMO.RayCastHit();
            let hit = geometry.rayCast(new OIMO.Vec3(_origin.x, _origin.y, _origin.z), new OIMO.Vec3(endpoint.x, endpoint.y, endpoint.z), transform, oimoRay); //the actual OimoPhysics Raycast
            if (hit) { //If hit return a bunch of informations about the hit
                hitInfo.hit = true;
                hitInfo.hitPoint = new FudgeCore.Vector3(oimoRay.position.x, oimoRay.position.y, oimoRay.position.z);
                hitInfo.hitNormal = new FudgeCore.Vector3(oimoRay.normal.x, oimoRay.normal.y, oimoRay.normal.z);
                let dx = _origin.x - hitInfo.hitPoint.x; //calculate hit distance
                let dy = _origin.y - hitInfo.hitPoint.y;
                let dz = _origin.z - hitInfo.hitPoint.z;
                hitInfo.hitDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                hitInfo.rigidbodyComponent = this;
                hitInfo.rayOrigin = _origin;
                hitInfo.rayEnd = endpoint;
            }
            else { //Only tell the origin, and the hit point is the end of the ray.
                hitInfo.rayOrigin = _origin;
                hitInfo.hitPoint = new FudgeCore.Vector3(endpoint.x, endpoint.y, endpoint.z);
            }
            if (_debugDraw) {
                FudgeCore.Physics.debugDraw.debugRay(hitInfo.rayOrigin, hitInfo.hitPoint, new FudgeCore.Color(0, 1, 0, 1));
            }
            return hitInfo;
        }
        //#endregion
        //#region Saving/Loading - Some properties might be missing, e.g. convexMesh (Float32Array)
        serialize() {
            let serialization = this.getMutator();
            delete serialization.mtxPivot;
            delete serialization.active;
            serialization.typeBody = FudgeCore.BODY_TYPE[this.#typeBody];
            serialization.typeCollider = FudgeCore.COLLIDER_TYPE[this.#typeCollider];
            serialization.initialization = BODY_INIT[this.initialization];
            serialization.id = this.#id;
            serialization.pivot = this.mtxPivot.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            super.deserialize(_serialization[super.constructor.name]);
            this.mtxPivot.deserialize(_serialization.pivot);
            this.#id = _serialization.id;
            this.mass = ifNumber(_serialization.mass, this.mass);
            this.dampTranslation = ifNumber(_serialization.dampTranslation, this.dampTranslation);
            this.dampRotation = ifNumber(_serialization.dampRotation, this.dampRotation);
            this.collisionGroup = ifNumber(_serialization.collisionGroup, this.collisionGroup);
            this.effectRotation = _serialization.effectRotation || this.effectRotation;
            this.effectGravity = ifNumber(_serialization.effectGravity, this.effectGravity);
            this.friction = ifNumber(_serialization.friction, this.friction);
            this.restitution = ifNumber(_serialization.restitution, this.restitution);
            this.isTrigger = _serialization.isTrigger || this.isTrigger;
            this.initialization = _serialization.initialization;
            this.initialization = BODY_INIT[_serialization.initialization];
            this.typeBody = FudgeCore.BODY_TYPE[_serialization.typeBody];
            this.typeCollider = FudgeCore.COLLIDER_TYPE[_serialization.typeCollider];
            // this.create(this.mass, this.#typeBody, this.#typeCollider, this.collisionGroup, null, this.convexMesh);
            return this;
        }
        /** Change properties by an associative array */
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (_mutator.typeBody != undefined)
                _mutator.typeBody = parseInt(_mutator.typeBody);
            if (_mutator.typeCollider != undefined)
                _mutator.typeCollider = parseInt(_mutator.typeCollider);
            if (_mutator.initialization != undefined)
                _mutator.initialization = parseInt(_mutator.initialization);
            await super.mutate(_mutator, _selection, _dispatchMutate);
            if (_mutator.initialization != undefined && this.isActive)
                this.initialize();
            // TODO: see if this alternative should be, at least partially, done with mutateSelection
            // let callIfExist: Function = (_key: string, _setter: Function) => {
            //   if (_mutator[_key])
            //     _setter(_mutator[_key]);
            // };
            // callIfExist("friction", (_value: number) => this.friction = _value);
            // callIfExist("restitution", (_value: number) => this.restitution = _value);
            // callIfExist("mass", (_value: number) => this.mass = _value);
            // callIfExist("dampTranslation", (_value: number) => this.dampTranslation = _value);
            // callIfExist("dampRotation", (_value: number) => this.dampRotation = _value);
            // callIfExist("effectGravity", (_value: number) => this.effectGravity = _value);
            // callIfExist("collisionGroup", (_value: COLLISION_GROUP) => this.collisionGroup = _value);
            // callIfExist("typeBody", (_value: string) => this.typeBody = parseInt(_value));
            // callIfExist("typeCollider", (_value: string) => this.typeCollider = parseInt(_value));
            // this.dispatchEvent(new Event(EVENT.MUTATE));
        }
        getMutator() {
            let mutator = super.getMutator(true);
            mutator.friction = this.friction;
            mutator.restitution = this.restitution;
            mutator.mass = this.mass;
            mutator.dampTranslation = this.dampTranslation;
            mutator.dampRotation = this.dampRotation;
            mutator.effectGravity = this.effectGravity;
            mutator.typeBody = this.#typeBody;
            mutator.typeCollider = this.#typeCollider;
            mutator.isTrigger = this.#isTrigger;
            // Object.preventExtensions(mutator);
            return mutator;
        }
        getMutatorAttributeTypes(_mutator) {
            let types = super.getMutatorAttributeTypes(_mutator);
            if (types.typeBody)
                types.typeBody = FudgeCore.BODY_TYPE;
            if (types.typeCollider)
                types.typeCollider = FudgeCore.COLLIDER_TYPE;
            if (types.initialization)
                types.initialization = BODY_INIT;
            return types;
        }
        reduceMutator(_mutator) {
            super.reduceMutator(_mutator);
            delete _mutator.convexMesh; //Convex Mesh can't be shown in the editor because float32Array is not a viable mutator
            delete _mutator.collisionMask;
            delete _mutator.isInitialized;
        }
        //#region Creation
        create(_mass = 1, _type = FudgeCore.BODY_TYPE.DYNAMIC, _colliderType = FudgeCore.COLLIDER_TYPE.CUBE, _group = FudgeCore.Physics.settings.defaultCollisionGroup, _mtxTransform = null, _convexMesh = null) {
            //Setting up all incoming values to be internal values
            this.convexMesh = _convexMesh;
            this.#typeBody = _type;
            this.#collisionGroup = _group;
            this.#typeCollider = _colliderType;
            this.mass = _mass;
            this.#restitution = FudgeCore.Physics.settings.defaultRestitution;
            this.#friction = FudgeCore.Physics.settings.defaultFriction;
            this.collisionMask = FudgeCore.Physics.settings.defaultCollisionMask;
            //Create the actual rigidbody in the OimoPhysics Space
            this.createRigidbody(_mass, _type, this.#typeCollider, _mtxTransform, this.#collisionGroup);
            this.#id = FudgeCore.Physics.distributeBodyID();
            // Event Callbacks directly from OIMO Physics
            this.#callbacks = new OIMO.ContactCallback(); //fehm
            this.#callbacks.beginTriggerContact = this.triggerEnter;
            this.#callbacks.endTriggerContact = this.triggerExit;
            this.#callbacks.postSolve = this.collisionEnter; // use postSolve for collisionEnter to get the impulse
            this.#callbacks.endContact = this.collisionExit;
        }
        /** Creates the actual OimoPhysics Rigidbody out of informations the FUDGE Component has. */
        createRigidbody(_mass, _type, _colliderType, _mtxTransform, _collisionGroup = FudgeCore.COLLISION_GROUP.DEFAULT) {
            let oimoType; //Need the conversion from simple enum to number because if enum is defined as Oimo.RigidyBodyType you have to include Oimo to use FUDGE at all
            switch (_type) {
                case FudgeCore.BODY_TYPE.DYNAMIC:
                    oimoType = OIMO.RigidBodyType.DYNAMIC;
                    break;
                case FudgeCore.BODY_TYPE.STATIC:
                    oimoType = OIMO.RigidBodyType.STATIC;
                    break;
                case FudgeCore.BODY_TYPE.KINEMATIC:
                    oimoType = OIMO.RigidBodyType.KINEMATIC;
                    break;
                default:
                    oimoType = OIMO.RigidBodyType.DYNAMIC;
                    break;
            }
            // remove all previous shapes from world. Necessary?
            // while (this.#rigidbody && this.#rigidbody.getShapeList() != null)
            //   this.#rigidbody.removeShape(this.#rigidbody.getShapeList());
            let tmpTransform = _mtxTransform == null ? super.node != null ? super.node.mtxWorld : FudgeCore.Matrix4x4.IDENTITY() : _mtxTransform; //Get transform informations from the world, since physics does not care about hierarchy
            //Convert informations from FUDGE to OimoPhysics and creating a collider with it, while also adding a pivot to derivate from the transform informations if needed
            let scale = new OIMO.Vec3((tmpTransform.scaling.x * this.mtxPivot.scaling.x) / 2, (tmpTransform.scaling.y * this.mtxPivot.scaling.y) / 2, (tmpTransform.scaling.z * this.mtxPivot.scaling.z) / 2);
            let position = new OIMO.Vec3(tmpTransform.translation.x + this.mtxPivot.translation.x, tmpTransform.translation.y + this.mtxPivot.translation.y, tmpTransform.translation.z + this.mtxPivot.translation.z);
            let rotation = new OIMO.Vec3(tmpTransform.rotation.x + this.mtxPivot.rotation.x, tmpTransform.rotation.y + this.mtxPivot.rotation.y, tmpTransform.rotation.z + this.mtxPivot.rotation.z);
            this.createCollider(scale, _colliderType);
            //Setting informations about mass, position/rotation and physical reaction type
            this.#massData.mass = _mass; //_type != PHYSICS_TYPE.STATIC ? _mass : 0; //If a object is static it acts as if it has no mass
            this.#rigidbodyInfo.type = oimoType;
            this.#rigidbodyInfo.position = position;
            this.#rigidbodyInfo.rotation.fromEulerXyz(new OIMO.Vec3(rotation.x, rotation.y, rotation.z)); //Convert eulerAngles in degree to the internally used quaternions
            //Creating the actual rigidbody and it's collider
            this.#rigidbody = new OIMO.RigidBody(this.#rigidbodyInfo);
            this.#collider = new OIMO.Shape(this.#colliderInfo);
            //Filling the additional settings and informations the rigidbody needs. Who is colliding, how is the collision handled (damping, influence factors)
            this.#collider.userData = this;
            this.#collider.setCollisionGroup(_collisionGroup);
            this.#collider.setCollisionMask(this.collisionMask);
            this.#rigidbody.addShape(this.#collider);
            this.#rigidbody.setMassData(this.#massData);
            this.#rigidbody.getShapeList().setRestitution(this.#restitution);
            this.#rigidbody.getShapeList().setFriction(this.#friction);
            this.#rigidbody.getShapeList().setContactCallback(this.#callbacks);
            this.#rigidbody.setLinearDamping(this.#dampingLinear);
            this.#rigidbody.setAngularDamping(this.#dampingAngular);
            this.#rigidbody.setGravityScale(this.#effectGravity);
            this.#rigidbody.setRotationFactor(new OIMO.Vec3(this.#effectRotation.x, this.#effectRotation.y, this.#effectRotation.z));
        }
        /** Creates a collider a shape that represents the object in the physical world.  */
        createCollider(_scale, _colliderType) {
            let shapeConf = new OIMO.ShapeConfig(); //Collider with geometry and infos like friction/restitution and more
            let geometry;
            if (this.typeCollider != _colliderType) //If the collider type was changed set the internal one new, else don't so there is not infinite set calls
                this.typeCollider = _colliderType;
            switch (_colliderType) { //Create a different OimoPhysics geometry based on the given type. That is only the mathematical shape of the collider
                case FudgeCore.COLLIDER_TYPE.CUBE:
                    geometry = new OIMO.BoxGeometry(_scale);
                    break;
                case FudgeCore.COLLIDER_TYPE.SPHERE:
                    geometry = new OIMO.SphereGeometry(_scale.x);
                    break;
                case FudgeCore.COLLIDER_TYPE.CAPSULE:
                    geometry = new OIMO.CapsuleGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.CYLINDER:
                    geometry = new OIMO.CylinderGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.CONE:
                    geometry = new OIMO.ConeGeometry(_scale.x, _scale.y);
                    break;
                case FudgeCore.COLLIDER_TYPE.PYRAMID:
                    geometry = this.createConvexGeometryCollider(this.createPyramidVertices(), _scale);
                    break;
                case FudgeCore.COLLIDER_TYPE.CONVEX:
                    geometry = this.createConvexGeometryCollider(this.convexMesh, _scale);
                    break;
            }
            shapeConf.geometry = geometry;
            this.#colliderInfo = shapeConf; //the configuration informations that are used to add an actual collider to the rigidbody in createRigidbody
        }
        /** Creating a shape that represents a in itself closed form, out of the given vertices. */
        createConvexGeometryCollider(_vertices, _scale) {
            let verticesAsVec3 = new Array(); //Convert FUDGE Vector3 to OimoVec3
            for (let i = 0; i < _vertices.length; i += 3) { //3 Values for one point
                verticesAsVec3.push(new OIMO.Vec3(_vertices[i] * _scale.x, _vertices[i + 1] * _scale.y, _vertices[i + 2] * _scale.z));
            }
            return new OIMO.ConvexHullGeometry(verticesAsVec3); //Tell OimoPhysics to create a hull that involves all points but close it of. A convex shape can not have a hole in it.
        }
        /** Internal implementation of vertices that construct a pyramid. The vertices of the implemented pyramid mesh can be used too. But they are halfed and double sided, so it's more performant to use this. */
        createPyramidVertices() {
            let vertices = new Float32Array([
                /*0*/ -1, 0, 1, /*1*/ 1, 0, 1, /*2*/ 1, 0, -1, /*3*/ -1, 0, -1,
                /*4*/ 0, 2, 0
            ]);
            return vertices;
        }
        //#region private EVENT functions
        //Calculating the center of a collision as a singular point - in case there is more than one point - by getting the geometrical center of all colliding points
        collisionCenterPoint(_colPoints, _numPoints) {
            let totalPoints = 0;
            let totalX = 0;
            let totalY = 0;
            let totalZ = 0;
            _colPoints.forEach((_value) => {
                if (totalPoints < _numPoints) {
                    totalPoints++;
                    totalX += _value.getPosition2().x;
                    totalY += _value.getPosition2().y;
                    totalZ += _value.getPosition2().z;
                }
            });
            return new FudgeCore.Vector3(totalX / _numPoints, totalY / _numPoints, totalZ / _numPoints);
            ;
        }
        //#endregion
        collisionEnter(_contact) {
            let bodyA = _contact.getShape1()?.userData;
            let bodyB = _contact.getShape2()?.userData;
            if (!bodyA || !bodyB || bodyA.collisions.includes(bodyB)) // already entered
                return;
            bodyA.collisions.push(bodyB);
            bodyB.collisions.push(bodyA);
            // TODO: maybe rather expose the manifold to the event or something
            let manifold = _contact.getManifold();
            let points = manifold.getPoints(); // All points in the collision where the two bodies are touching, used to calculate the full impact
            let normalImpulse = 0;
            let tangentImpulse = 0;
            let binormalImpulse = 0;
            for (let manifoldPoint of points) { // The impact of the collision involving all touching points
                normalImpulse += manifoldPoint.getNormalImpulse();
                tangentImpulse += manifoldPoint.getTangentImpulse();
                binormalImpulse += manifoldPoint.getBinormalImpulse();
            }
            let normal = manifold.getNormal();
            let collisionNormal = new FudgeCore.Vector3(normal.x, normal.y, normal.z);
            let collisionCenterPoint = bodyA.collisionCenterPoint(points, manifold.getNumPoints());
            bodyA.dispatchEvent(new FudgeCore.EventPhysics("ColliderEnteredCollision" /* EVENT_PHYSICS.COLLISION_ENTER */, bodyB, normalImpulse, tangentImpulse, binormalImpulse, collisionCenterPoint, collisionNormal));
            bodyB.dispatchEvent(new FudgeCore.EventPhysics("ColliderEnteredCollision" /* EVENT_PHYSICS.COLLISION_ENTER */, bodyA, normalImpulse, tangentImpulse, binormalImpulse, collisionCenterPoint, collisionNormal));
        }
        collisionExit(_contact) {
            let bodyA = _contact.getShape1()?.userData;
            let bodyB = _contact.getShape2()?.userData;
            if (!bodyA || !bodyB || !bodyA.collisions.includes(bodyB)) // already exited
                return;
            bodyA.collisions.splice(bodyA.collisions.indexOf(bodyB), 1);
            bodyB.collisions.splice(bodyB.collisions.indexOf(bodyA), 1);
            bodyA.dispatchEvent(new FudgeCore.EventPhysics("ColliderLeftCollision" /* EVENT_PHYSICS.COLLISION_EXIT */, bodyB, 0, 0, 0));
            bodyB.dispatchEvent(new FudgeCore.EventPhysics("ColliderLeftCollision" /* EVENT_PHYSICS.COLLISION_EXIT */, bodyA, 0, 0, 0));
        }
        /**
        * Trigger EnteringEvent Callback, automatically called by OIMO Physics within their calculations.
        * Since the event does not know which body is the trigger iniator, the event can be listened to
        * on either the trigger or the triggered. (This is only possible with the FUDGE OIMO Fork!)
        */
        triggerEnter(_contact) {
            let bodyA = _contact.getShape1()?.userData;
            let bodyB = _contact.getShape2()?.userData;
            if (!bodyA || !bodyB || bodyA.triggerings.includes(bodyB)) // already entered
                return;
            bodyA.triggerings.push(bodyB);
            bodyB.triggerings.push(bodyA);
            let manifold = _contact.getManifold();
            let points = manifold.getPoints();
            let normal = manifold.getNormal();
            let collisionNormal = new FudgeCore.Vector3(normal.x, normal.y, normal.z);
            let collisionCenterPoint = bodyA.collisionCenterPoint(points, manifold.getNumPoints());
            bodyA.dispatchEvent(new FudgeCore.EventPhysics("TriggerEnteredCollision" /* EVENT_PHYSICS.TRIGGER_ENTER */, bodyB, 0, 0, 0, collisionCenterPoint, collisionNormal));
            bodyB.dispatchEvent(new FudgeCore.EventPhysics("TriggerEnteredCollision" /* EVENT_PHYSICS.TRIGGER_ENTER */, bodyA, 0, 0, 0, collisionCenterPoint, collisionNormal));
        }
        /**
        * Trigger LeavingEvent Callback, automatically called by OIMO Physics within their calculations.
        * Since the event does not know which body is the trigger iniator, the event can be listened to
        * on either the trigger or the triggered. (This is only possible with the FUDGE OIMO Fork!)
        */
        triggerExit(_contact) {
            let bodyA = _contact.getShape1()?.userData;
            let bodyB = _contact.getShape2()?.userData;
            if (!bodyA || !bodyB || !bodyA.triggerings.includes(bodyB)) // already exited
                return;
            bodyA.triggerings.splice(bodyA.collisions.indexOf(bodyB), 1);
            bodyB.triggerings.splice(bodyB.collisions.indexOf(bodyA), 1);
            bodyA.dispatchEvent(new FudgeCore.EventPhysics("TriggerLeftCollision" /* EVENT_PHYSICS.TRIGGER_EXIT */, bodyB, 0, 0, 0));
            bodyB.dispatchEvent(new FudgeCore.EventPhysics("TriggerLeftCollision" /* EVENT_PHYSICS.TRIGGER_EXIT */, bodyA, 0, 0, 0));
        }
    }
    FudgeCore.ComponentRigidbody = ComponentRigidbody;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /** Internal class for holding data about physics debug vertices.*/
    class PhysicsDebugVertexBuffer {
        /** Setup the rendering context for this buffer and create the actual buffer for this context. */
        constructor(_renderingContext) {
            this.numVertices = 0;
            this.gl = _renderingContext;
            this.buffer = this.gl.createBuffer();
        }
        /** Fill the bound buffer with data. Used at buffer initialization */
        setData(_array) {
            if (this.attribs == null)
                throw "set attributes first";
            this.numVertices = _array.length / (this.stride / 4);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(_array), this.gl.DYNAMIC_DRAW);
            //not necessary an in webgl2 anymore to rebind the same last buffer (which is achieved by giving a null buffer), after buffer is changed. Removed it on all other occasions
            // this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null); 
        }
        /** Set Shader Attributes informations by getting their position in the shader, setting the offset, stride and size. For later use in the binding process */
        setAttribs(_attribs) {
            this.attribs = _attribs;
            this.offsets = [];
            this.stride = 0;
            let n = _attribs.length;
            for (let i = 0; i < n; i++) {
                this.offsets.push(this.stride);
                this.stride += _attribs[i].float32Count * Float32Array.BYTES_PER_ELEMENT; // 32bit float Bytes are a constant of 4
            }
        }
        /** Get the position of the attribute in the shader */
        loadAttribIndices(_program) {
            this.indices = _program.getAttribIndices(this.attribs);
        }
        /** Enable a attribute in a shader for this context, */
        bindAttribs() {
            if (this.indices == null)
                throw "indices are not loaded";
            let n = this.attribs.length;
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer); //making the buffer of this class the current buffer
            for (let i = 0; i < n; i++) {
                this.gl.enableVertexAttribArray(this.indices[i]); //enable the Attribute
                this.gl.vertexAttribPointer(this.indices[i], this.attribs[i].float32Count, this.gl.FLOAT, false, this.stride, this.offsets[i]); //creates a pointer and structure for this attribute
            }
        }
    }
    FudgeCore.PhysicsDebugVertexBuffer = PhysicsDebugVertexBuffer;
    /** Internal class for holding data about PhysicsDebugVertexBuffers */
    class PhysicsDebugIndexBuffer {
        /** Setup the rendering context for this buffer and create the actual buffer for this context. */
        constructor(_renderingContext) {
            this.gl = _renderingContext;
            this.buffer = this.gl.createBuffer();
        }
        /** Fill the bound buffer with data amount. Used at buffer initialization */
        setData(_array) {
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Int16Array(_array), this.gl.DYNAMIC_DRAW);
            this.count = _array.length;
        }
        /** The actual DrawCall for physicsDebugDraw Buffers. This is where the information from the debug is actually drawn. */
        draw(_mode = this.gl.TRIANGLES, _count = -1) {
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            this.gl.drawElements(_mode, _count >= 0 ? _count : this.count, this.gl.UNSIGNED_SHORT, 0);
        }
    }
    FudgeCore.PhysicsDebugIndexBuffer = PhysicsDebugIndexBuffer;
    /** Internal class for managing data about webGL Attributes */
    class PhysicsDebugVertexAttribute {
        constructor(_float32Count, _name) {
            this.name = _name;
            this.float32Count = _float32Count;
        }
    }
    FudgeCore.PhysicsDebugVertexAttribute = PhysicsDebugVertexAttribute;
    /** Internal class for Shaders used only by the physics debugDraw */
    class PhysicsDebugShader {
        /** Introduce the FUDGE Rendering Context to this class, creating a program and vertex/fragment shader in this context */
        constructor(_renderingContext) {
            this.gl = _renderingContext;
            this.program = this.gl.createProgram();
            this.vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
            this.fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        }
        /** Take glsl shaders as strings and compile them, attaching the compiled shaders to a program thats used by this rendering context. */
        compile(_vertexSource, _fragmentSource) {
            this.uniformLocationMap = new Map();
            this.compileShader(this.vertexShader, _vertexSource);
            this.compileShader(this.fragmentShader, _fragmentSource);
            this.gl.attachShader(this.program, this.vertexShader);
            this.gl.attachShader(this.program, this.fragmentShader);
            this.gl.linkProgram(this.program);
            if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) { //make sure the linking worked, so the program is valid, and shaders are working
                FudgeCore.Debug.log(this.gl.getProgramInfoLog(this.program));
            }
            this.gl.validateProgram(this.program);
            if (!this.gl.getProgramParameter(this.program, this.gl.VALIDATE_STATUS)) {
                console.error("ERROR validating program!", this.gl.getProgramInfoLog(this.program));
                return;
            }
        }
        /** Get index of a attribute in a shader in this program */
        getAttribIndex(_name) {
            return this.gl.getAttribLocation(this.program, _name);
        }
        /** Get the location of a uniform in a shader in this program */
        getUniformLocation(_name) {
            if (this.uniformLocationMap.has(_name))
                return this.uniformLocationMap.get(_name);
            let location = this.gl.getUniformLocation(this.program, _name);
            this.uniformLocationMap.set(_name, location);
            return location;
        }
        /** Get all indices for every attribute in the shaders of this program */
        getAttribIndices(_attribs) {
            let indices = [];
            _attribs.forEach(_value => {
                indices.push(this.getAttribIndex(_value.name));
            });
            return indices;
        }
        /** Tell the FUDGE Rendering Context to use this program to draw. */
        use() {
            this.gl.useProgram(this.program);
        }
        /** Compile a shader out of a string and validate it. */
        compileShader(_shader, _source) {
            this.gl.shaderSource(_shader, _source);
            this.gl.compileShader(_shader);
            if (!this.gl.getShaderParameter(_shader, this.gl.COMPILE_STATUS)) {
                FudgeCore.Debug.log(this.gl.getShaderInfoLog(_shader));
            }
        }
    }
    FudgeCore.PhysicsDebugShader = PhysicsDebugShader;
    /** Internal Class used to draw debugInformations about the physics simulation onto the renderContext. No user interaction needed.
     * @author Marko Fehrenbach, HFU 2020 //Based on OimoPhysics Haxe DebugDrawDemo
     */
    class PhysicsDebugDraw extends FudgeCore.RenderWebGL {
        /** Creating the debug for physics in FUDGE. Tell it to draw only wireframe objects, since FUDGE is handling rendering of the objects besides physics.
         * Override OimoPhysics Functions with own rendering. Initialize buffers and connect them with the context for later use. */
        constructor() {
            super();
            this.style = new OIMO.DebugDrawStyle();
            this.oimoDebugDraw = new OIMO.DebugDraw();
            this.oimoDebugDraw.wireframe = true; //Triangle Rendering is handled by FUDGE so, only the physics lines/points need to be rendered, although triangle is still implemented
            this.gl = FudgeCore.RenderWebGL.getRenderingContext();
            this.initializeOverride();
            this.shader = new PhysicsDebugShader(this.gl);
            this.shader.compile(this.vertexShaderSource(), this.fragmentShaderSource());
            this.initializeBuffers();
        }
        /** Receive the current DebugMode from the physics settings and set the OimoPhysics.DebugDraw booleans to show only certain informations.
         * Needed since some debug informations exclude others, and can't be drawn at the same time, by OimoPhysics. And for users it provides more readability
         * to debug only what they need and is commonly debugged.
         */
        setDebugMode(_mode = FudgeCore.PHYSICS_DEBUGMODE.NONE) {
            // tslint:disable-next-line
            let draw = { drawAabbs: false, drawBases: false, drawBvh: false, drawContactBases: false, drawContacts: false, drawJointLimits: false, drawJoints: false, drawPairs: false, drawShapes: false };
            switch (_mode) {
                case FudgeCore.PHYSICS_DEBUGMODE.COLLIDERS: //Colliders and Bases
                    draw.drawBases = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.JOINTS_AND_COLLIDER: //Colliders and joints
                    draw.drawJoints = draw.drawJointLimits = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.PHYSIC_OBJECTS_ONLY: //Physics Objects only, shows same as Collider / Joints but also hiding every other fudge object
                    draw.drawBases = draw.drawJointLimits = draw.drawJoints = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.CONTACTS: //Contacts
                    draw.drawBases = draw.drawContactBases = draw.drawContacts = draw.drawPairs = draw.drawShapes = true;
                    break;
                case FudgeCore.PHYSICS_DEBUGMODE.BOUNDING_BOXES: //Bounding Box / Broadphase Bvh / Bases
                    draw.drawAabbs = draw.drawBases = draw.drawBvh = true;
                    break;
            }
            Object.assign(this.oimoDebugDraw, draw);
        }
        /** Creating the empty render buffers. Defining the attributes used in shaders.
         * Needs to create empty buffers to already have them ready to draw later on, linking is only possible with existing buffers. */
        initializeBuffers() {
            let attribs = [
                new PhysicsDebugVertexAttribute(3, "aPosition"),
                new PhysicsDebugVertexAttribute(3, "aNormal"),
                new PhysicsDebugVertexAttribute(3, "aColor")
            ];
            this.pointVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.pointIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.pointVBO.setAttribs(attribs);
            this.pointVBO.loadAttribIndices(this.shader);
            this.lineVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.lineIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.lineVBO.setAttribs(attribs);
            this.lineVBO.loadAttribIndices(this.shader);
            this.triVBO = new PhysicsDebugVertexBuffer(this.gl);
            this.triIBO = new PhysicsDebugIndexBuffer(this.gl);
            this.triVBO.setAttribs(attribs);
            this.triVBO.loadAttribIndices(this.shader);
            this.clearBuffers();
        }
        /** Before OimoPhysics.world is filling the debug. Make sure the buffers are reset. Also receiving the debugMode from settings and updating the current projection for the vertexShader. */
        clearBuffers() {
            this.gl.lineWidth(2.0); //Does not affect anything because lineWidth is currently only supported by Microsoft Edge and FUDGE is optimized for Chrome
            this.pointData = []; //Resetting the data to be filled again
            this.lineData = [];
            this.triData = [];
            this.numPointData = 0; //Resetting the amount of data calls
            this.numLineData = 0;
            this.numTriData = 0;
        }
        /** After OimoPhysics.world filled the debug. Rendering calls. Setting this program to be used by the FUDGE rendering context. And draw each updated buffer and resetting them. */
        drawBuffers() {
            this.shader.use();
            this.gl.uniformMatrix4fv(this.shader.getUniformLocation("u_mtxWorldToView"), false, FudgeCore.Physics.mainCam.mtxWorldToView.getArray());
            this.gl.bindVertexArray(null);
            if (this.numPointData > 0) {
                this.pointIboData = []; //Buffer size matching to whats needed
                for (let i = 0; i < this.numPointData; i++) {
                    this.pointIboData.push(i);
                }
                this.pointIBO.setData(this.pointIboData); //Set Index buffer to correct size
                this.pointVBO.setData(this.pointData); //Set Vertex Buffer to current Data
                this.pointVBO.bindAttribs();
                this.pointIBO.draw(this.gl.POINTS, this.numPointData); //The actual draw call for each index in ibo
                this.numPointData = 0;
            }
            if (this.numLineData > 0) {
                this.lineIboData = [];
                for (let i = 0; i < this.numLineData; i++) {
                    this.lineIboData.push(i * 2);
                    this.lineIboData.push(i * 2 + 1);
                }
                this.lineIBO.setData(this.lineIboData);
                this.lineVBO.setData(this.lineData);
                this.lineVBO.bindAttribs();
                this.lineIBO.draw(this.gl.LINES, this.numLineData * 2);
                this.numLineData = 0;
            }
            if (this.numTriData > 0) {
                this.triIboData = [];
                for (let i = 0; i < this.numTriData; i++) {
                    this.triIboData.push(i * 3);
                    this.triIboData.push(i * 3 + 1);
                    this.triIboData.push(i * 3 + 2);
                }
                this.triIBO.setData(this.triIboData);
                this.triVBO.setData(this.triData);
                this.triVBO.bindAttribs();
                this.triIBO.draw(this.gl.TRIANGLES, this.numTriData * 3);
                this.numTriData = 0;
            }
        }
        /** Drawing the ray into the debugDraw Call. By using the overwritten line rendering functions and drawing a point (pointSize defined in the shader) at the end of the ray. */
        debugRay(_origin, _end, _color) {
            this.oimoDebugDraw.line(new OIMO.Vec3(_origin.x, _origin.y, _origin.z), new OIMO.Vec3(_end.x, _end.y, _end.z), new OIMO.Vec3(_color.r, _color.g, _color.b));
            this.oimoDebugDraw.point(new OIMO.Vec3(_end.x, _end.y, _end.z), new OIMO.Vec3(_color.r, _color.g, _color.b));
        }
        /** Overriding the existing functions from OimoPhysics.DebugDraw without actually inherit from the class, to avoid compiler problems.
         * Overriding them to receive debugInformations in the format the physic engine provides them but handling the rendering in the fudge context. */
        initializeOverride() {
            //Override point/line/triangle functions of OimoPhysics which are used to draw wireframes of objects, lines of raycasts or triangles when the objects are rendered by the physics not FUDGE (unused)
            OIMO.DebugDraw.prototype.point = function (_v, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw; //Get the custom physics debug class to have access to the data.
                if (FudgeCore.Physics.mainCam != null) { //only act when there is a camera that is rendering
                    let data = debugWrapper.pointData; //get the already written buffer informations
                    data.push(_v.x, _v.y, _v.z); //Coordinates of the point
                    data.push(0, 0, 0); //Point Normals - Empty since it's not a polygon
                    data.push(_color.x, _color.y, _color.z); //Color of the point
                    debugWrapper.numPointData++;
                }
            };
            OIMO.DebugDraw.prototype.line = function (_v1, _v2, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw;
                if (FudgeCore.Physics.mainCam != null) {
                    let data = debugWrapper.lineData;
                    data.push(_v1.x, _v1.y, _v1.z); //Point 1 Coordinates
                    data.push(0, 0, 0); //P1 Normals - Empty since it's not a polygon
                    data.push(_color.x, _color.y, _color.z); //P1 Color
                    data.push(_v2.x, _v2.y, _v2.z); //Point 2 Coordinates
                    data.push(0, 0, 0);
                    data.push(_color.x, _color.y, _color.z);
                    debugWrapper.numLineData++;
                }
            };
            OIMO.DebugDraw.prototype.triangle = function (_v1, _v2, _v3, _n1, _n2, _n3, _color) {
                let debugWrapper = FudgeCore.Physics.debugDraw;
                if (FudgeCore.Physics.mainCam != null) {
                    let data = debugWrapper.triData;
                    data.push(_v1.x, _v1.y, _v1.z);
                    data.push(_n1.x, _n1.y, _n1.z);
                    data.push(_color.x, _color.y, _color.z);
                    data.push(_v2.x, _v2.y, _v2.z);
                    data.push(_n2.x, _n2.y, _n2.z);
                    data.push(_color.x, _color.y, _color.z);
                    data.push(_v3.x, _v3.y, _v3.z);
                    data.push(_n3.x, _n3.y, _n3.z);
                    data.push(_color.x, _color.y, _color.z);
                    debugWrapper.numTriData++;
                }
            };
        }
        /** The source code (string) of the in physicsDebug used very simple vertexShader.
         *  Handling the projection (which includes, view/world[is always identity in this case]/projection in FUDGE). Increasing the size of single points drawn.
         *  And transfer position color to the fragmentShader. */
        vertexShaderSource() {
            return `
			precision mediump float;
			attribute vec3 aPosition;
			attribute vec3 aColor;
			attribute vec3 aNormal;
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec3 vColor;
			uniform mat4 u_mtxWorldToView;

			void main() {
				vPosition = aPosition;
				vColor = aColor;
				vNormal = aNormal;
				gl_Position = u_mtxWorldToView * vec4(aPosition,1.0);
				gl_PointSize = 6.0;
			}`;
        }
        /** The source code (string) of the in physicsDebug used super simple fragmentShader. Unlit - only colorizing the drawn pixels, normals/position are given to make it expandable */
        fragmentShaderSource() {
            return `
      precision mediump float;
			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec3 vColor;

			void main() {
				gl_FragColor = vec4(vColor, 1.0);
			}`;
        }
    }
    FudgeCore.PhysicsDebugDraw = PhysicsDebugDraw;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A physical connection between two bodies with a defined axe of translation and rotation. Two Degrees of Freedom in the defined axis.
     * Two RigidBodies need to be defined to use it. A motor can be defined for rotation and translation, along with spring settings.
     *
     * ```text
     *          JointHolder - bodyAnchor
     *                    ‚îå‚îÄ‚îÄ‚îÄ‚îê
     *                    ‚îÇ   ‚îÇ
     *           <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> tied body, sliding on axis = 1st degree of freedom
     *                    ‚îÇ   ‚îÇ        rotating around axis = 2nd degree of freedom
     *                    ‚îî‚îÄ‚îÄ‚îÄ‚îò
     * ```
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class JointCylindrical extends FudgeCore.JointAxial {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointCylindrical); }
        #springDampingRotation;
        #springFrequencyRotation;
        #motorForce;
        #maxRotor;
        #minRotor;
        #rotorTorque;
        #rotorSpeed;
        #rotor;
        #rotorSpringDamper;
        /** Creating a cylindrical joint between two ComponentRigidbodies moving on one axis and rotating around another bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.config = new OIMO.CylindricalJointConfig();
            this.#springDampingRotation = 0;
            this.#springFrequencyRotation = 0;
            this.#motorForce = 0;
            this.#maxRotor = 360;
            this.#minRotor = 0;
            this.#rotorTorque = 0;
            this.#rotorSpeed = 0;
            this.#getMutator = () => {
                let mutator = {
                    motorForce: this.motorForce,
                    springDampingRotation: this.springDampingRotation,
                    springFrequencyRotation: this.springFrequencyRotation,
                    maxRotor: this.maxRotor,
                    minRotor: this.minRotor,
                    rotorTorque: this.rotorTorque,
                    rotorSpeed: this.rotorSpeed
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.mutateBase(_mutator, ["motorForce", "rotorTorque", "rotorSpeed", "maxRotor", "minRotor", "springDampingRotation", "springFrequencyRotation", "springFrequency"]);
            };
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        set springDamping(_value) {
            super.springDamping = _value;
            if (this.joint != null)
                this.joint.getTranslationalSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        set springFrequency(_value) {
            super.springFrequency = _value;
            if (this.joint != null)
                this.joint.getTranslationalSpringDamper().frequency = _value;
        }
        /**
        * The damping of the spring. 1 equals completly damped. Influencing TORQUE / ROTATION
        */
        get springDampingRotation() {
            return this.#springDampingRotation;
        }
        set springDampingRotation(_value) {
            this.#springDampingRotation = _value;
            if (this.joint != null)
                this.joint.getRotationalSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. Influencing TORQUE / ROTATION
        */
        get springFrequencyRotation() {
            return this.#springFrequencyRotation;
        }
        set springFrequencyRotation(_value) {
            this.#springFrequencyRotation = _value;
            if (this.joint != null)
                this.joint.getRotationalSpringDamper().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxRotor() {
            return this.#maxRotor;
        }
        set maxRotor(_value) {
            this.#maxRotor = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().upperLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotor() {
            return this.#minRotor;
        }
        set minRotor(_value) {
            this.#minRotor = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().lowerLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeed() {
            return this.#rotorSpeed;
        }
        set rotorSpeed(_value) {
            this.#rotorSpeed = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorque() {
            return this.#rotorTorque;
        }
        set rotorTorque(_value) {
            this.#rotorTorque = _value;
            if (this.joint != null)
                this.joint.getRotationalLimitMotor().motorTorque = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        set maxMotor(_value) {
            super.maxMotor = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().upperLimit = _value;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit.
         */
        set minMotor(_value) {
            super.minMotor = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().lowerLimit = _value;
        }
        set motorSpeed(_value) {
            super.motorSpeed = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled.
         */
        get motorForce() {
            return this.#motorForce;
        }
        set motorForce(_value) {
            this.#motorForce = _value;
            if (this.joint != null)
                this.joint.getTranslationalLimitMotor().motorForce = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            return mutator;
        }
        //#endregion
        constructJoint() {
            this.#rotorSpringDamper = new OIMO.SpringDamper().setSpring(this.springFrequencyRotation, this.springDampingRotation);
            this.motor = new OIMO.TranslationalLimitMotor().setLimits(super.minMotor, super.maxMotor);
            this.motor.setMotor(super.motorSpeed, this.motorForce);
            this.#rotor = new OIMO.RotationalLimitMotor().setLimits(this.minRotor * FudgeCore.Calc.deg2rad, this.maxRotor * FudgeCore.Calc.deg2rad);
            this.#rotor.setMotor(this.rotorSpeed, this.rotorTorque);
            this.config = new OIMO.CylindricalJointConfig();
            super.constructJoint();
            this.config.translationalSpringDamper = this.springDamper;
            this.config.translationalLimitMotor = this.motor;
            this.config.rotationalLimitMotor = this.#rotor;
            this.config.rotationalSpringDamper = this.#rotorSpringDamper;
            this.joint = new OIMO.CylindricalJoint(this.config);
            this.configureJoint();
        }
        #getMutator;
        #mutate;
    }
    FudgeCore.JointCylindrical = JointCylindrical;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with a defined axe movement.
       * Used to create a sliding joint along one axis. Two RigidBodies need to be defined to use it.
       * A motor can be defined to move the connected along the defined axis. Great to construct standard springs or physical sliders.
       *
       * ```text
       *          JointHolder - bodyAnchor
       *                    ‚îå‚îÄ‚îÄ‚îÄ‚îê
       *                    ‚îÇ   ‚îÇ
       *           <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> tied body, sliding on one Axis, 1 Degree of Freedom
       *                    ‚îÇ   ‚îÇ
       *                    ‚îî‚îÄ‚îÄ‚îÄ‚îò
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointPrismatic extends FudgeCore.JointAxial {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointPrismatic); }
        //Internally used variables - Joint Properties that are used even when no actual joint is currently existent
        #motorForce;
        /** Creating a prismatic joint between two ComponentRigidbodies only moving on one axis bound on a local anchorpoint. */
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.config = new OIMO.PrismaticJointConfig();
            //Internally used variables - Joint Properties that are used even when no actual joint is currently existent
            this.#motorForce = 0;
            this.maxMotor = 10;
            this.minMotor = -10;
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled. This is the force that the motor is using to hold the position, or reach it if a motorSpeed is defined.
         */
        get motorForce() {
            return this.#motorForce;
        }
        set motorForce(_value) {
            this.#motorForce = _value;
            if (this.joint != null)
                this.joint.getLimitMotor().motorForce = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                motorForce: this.motorForce,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.motorForce = _serialization.motorForce;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.motorForce = this.motorForce;
            return mutator;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (typeof (_mutator.motorForce) !== "undefined")
                this.motorForce = _mutator.motorForce;
            delete _mutator.motorForce;
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        //#endregion
        /** Actual creation of a joint in the OimoPhysics system */
        constructJoint() {
            this.motor = new OIMO.TranslationalLimitMotor().setLimits(this.minMotor, this.maxMotor); //Create motor settings, to hold positions, set constraint min/max
            this.motor.setMotor(this.motorSpeed, this.motorForce);
            this.config = new OIMO.PrismaticJointConfig(); //Create a specific config for this joint type that is calculating the local axis for both bodies
            super.constructJoint();
            this.config.springDamper = this.springDamper; //Telling the config to use the motor/spring of the FUDGE Component
            this.config.limitMotor = this.motor;
            this.joint = new OIMO.PrismaticJoint(this.config);
            this.configureJoint();
        }
    }
    FudgeCore.JointPrismatic = JointPrismatic;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
      * A physical connection between two bodies, designed to simulate behaviour within a real body. It has two axis, a swing and twist axis, and also the perpendicular axis,
      * similar to a Spherical joint, but more restrictive in it's angles and only two degrees of freedom. Two RigidBodies need to be defined to use it. Mostly used to create humanlike joints that behave like a
      * lifeless body.
      * ```text
      *
      *                      anchor - it can twist on one axis and swing on another
      *                            ‚îÇ
      *         z            ‚îå‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îê
      *         ‚Üë            ‚îÇ   ‚îÇ ‚Üì ‚îÇ   ‚îÇ        e.g. z = TwistAxis, it can rotate in-itself around this axis
      *    -x ‚Üê‚îÄ‚îº‚îÄ‚Üí x        ‚îÇ   ‚îÇ x ‚îÇ   ‚îÇ        e.g. x = SwingAxis, it can rotate anchored around the base on this axis
      *         ‚Üì            ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
      *        -z            ‚îî‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îò         e.g. you can twist the leg in-itself to a certain degree,
      *                                                     but also rotate it forward/backward/left/right to a certain degree
      *                bodyAnchor          bodyTied
      *              (e.g. pelvis)         (e.g. upper-leg)
      *
      * ```
      * Twist equals a rotation around a point without moving on an axis.
      * Swing equals a rotation on a point with a moving local axis.
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
      */
    class JointRagdoll extends FudgeCore.Joint {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointRagdoll); }
        #springDampingTwist;
        #springFrequencyTwist;
        #springDampingSwing;
        #springFrequencySwing;
        #maxMotorTwist;
        #minMotorTwist;
        #motorTorqueTwist;
        #motorSpeedTwist;
        #motorTwist;
        #springDamperTwist;
        #springDamperSwing;
        #axisFirst;
        #axisSecond;
        #maxAngleFirst;
        #maxAngleSecond;
        constructor(_bodyAnchor = null, _bodyTied = null, _axisFirst = new FudgeCore.Vector3(1, 0, 0), _axisSecond = new FudgeCore.Vector3(0, 0, 1), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.config = new OIMO.RagdollJointConfig();
            this.#springDampingTwist = 0;
            this.#springFrequencyTwist = 0;
            this.#springDampingSwing = 0;
            this.#springFrequencySwing = 0;
            this.#maxMotorTwist = 360;
            this.#minMotorTwist = 0;
            this.#motorTorqueTwist = 0;
            this.#motorSpeedTwist = 0;
            this.#maxAngleFirst = 0;
            this.#maxAngleSecond = 0;
            this.#getMutator = () => {
                let mutator = {
                    maxAngleFirst: this.#maxAngleFirst,
                    maxAngleSecond: this.#maxAngleSecond,
                    springDampingTwist: this.springDampingTwist,
                    springFrequencyTwist: this.springFrequencyTwist,
                    springDampingSwing: this.springDampingSwing,
                    springFrequencySwing: this.springFrequencySwing,
                    maxMotorTwist: this.#maxMotorTwist,
                    minMotorTwist: this.#minMotorTwist,
                    motorSpeedTwist: this.motorSpeedTwist,
                    motorTorqueTwist: this.motorTorqueTwist
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                if (typeof (_mutator.maxAngleFirst) !== "undefined")
                    this.#maxAngleFirst = _mutator.maxAngleFirst;
                if (typeof (_mutator.maxAngleSecond) !== "undefined")
                    this.#maxAngleSecond = _mutator.maxAngleSecond;
                this.mutateBase(_mutator, [
                    "springDampingTwist", "springFrequencyTwist", "springDampingSwing", "springFrequencySwing", "maxMotorTwist", "minMotorTwist", "motorSpeedTwist", "motorTorqueTwist"
                ]);
            };
            this.axisFirst = _axisFirst;
            this.axisSecond = _axisSecond;
            this.anchor = _localAnchor;
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axisFirst() {
            return new FudgeCore.Vector3(this.#axisFirst.x, this.#axisFirst.y, this.#axisFirst.z);
        }
        set axisFirst(_value) {
            this.#axisFirst = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
        * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
        *  When changed after initialization the joint needs to be reconnected.
        */
        get axisSecond() {
            return new FudgeCore.Vector3(this.#axisSecond.x, this.#axisSecond.y, this.#axisSecond.z);
        }
        set axisSecond(_value) {
            this.#axisSecond = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The maximum angle of rotation along the first axis. Value needs to be positive. Changes do rebuild the joint
         */
        get maxAngleFirstAxis() {
            return this.#maxAngleFirst * FudgeCore.Calc.rad2deg;
        }
        set maxAngleFirstAxis(_value) {
            this.#maxAngleFirst = _value * FudgeCore.Calc.deg2rad;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The maximum angle of rotation along the second axis. Value needs to be positive. Changes do rebuild the joint
         */
        get maxAngleSecondAxis() {
            return this.#maxAngleSecond * FudgeCore.Calc.rad2deg;
        }
        set maxAngleSecondAxis(_value) {
            this.#maxAngleSecond = _value * FudgeCore.Calc.deg2rad;
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingTwist() {
            return this.#springDampingTwist;
        }
        set springDampingTwist(_value) {
            this.#springDampingTwist = _value;
            if (this.joint != null)
                this.joint.getTwistSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencyTwist() {
            return this.#springFrequencyTwist;
        }
        set springFrequencyTwist(_value) {
            this.#springFrequencyTwist = _value;
            if (this.joint != null)
                this.joint.getTwistSpringDamper().frequency = _value;
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingSwing() {
            return this.#springDampingSwing;
        }
        set springDampingSwing(_value) {
            this.#springDampingSwing = _value;
            if (this.joint != null)
                this.joint.getSwingSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencySwing() {
            return this.#springFrequencySwing;
        }
        set springFrequencySwing(_value) {
            this.#springFrequencySwing = _value;
            if (this.joint != null)
                this.joint.getSwingSpringDamper().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxMotorTwist() {
            return this.#maxMotorTwist * FudgeCore.Calc.rad2deg;
        }
        set maxMotorTwist(_value) {
            _value *= FudgeCore.Calc.deg2rad;
            this.#maxMotorTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().upperLimit = _value;
        }
        /**
         * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minMotorTwist() {
            return this.#minMotorTwist * FudgeCore.Calc.rad2deg;
        }
        set minMotorTwist(_value) {
            _value *= FudgeCore.Calc.deg2rad;
            this.#minMotorTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().lowerLimit = _value;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get motorSpeedTwist() {
            return this.#motorSpeedTwist;
        }
        set motorSpeedTwist(_value) {
            this.#motorSpeedTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get motorTorqueTwist() {
            return this.#motorTorqueTwist;
        }
        set motorTorqueTwist(_value) {
            this.#motorTorqueTwist = _value;
            if (this.joint != null)
                this.joint.getTwistLimitMotor().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.axisFirst = this.axisFirst.serialize();
            serialization.axisSecond = this.axisSecond.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            await this.axisFirst.deserialize(_serialization.axisFirst);
            await this.axisSecond.deserialize(_serialization.axisSecond);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (typeof (_mutator.axisFirst) !== "undefined")
                this.axisFirst = new FudgeCore.Vector3(...(Object.values(_mutator.axisFirst)));
            if (typeof (_mutator.axisSecond) !== "undefined")
                this.axisSecond = new FudgeCore.Vector3(...(Object.values(_mutator.axisSecond)));
            delete _mutator.axisFirst;
            delete _mutator.axisSecond;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            mutator.axisFirst = this.axisFirst.getMutator();
            mutator.axisSecond = this.axisSecond.getMutator();
            return mutator;
        }
        //#endregion
        constructJoint() {
            this.#springDamperTwist = new OIMO.SpringDamper().setSpring(this.springFrequencyTwist, this.springDampingTwist);
            this.#springDamperSwing = new OIMO.SpringDamper().setSpring(this.springFrequencySwing, this.springDampingSwing);
            this.#motorTwist = new OIMO.RotationalLimitMotor().setLimits(this.minMotorTwist, this.maxMotorTwist);
            this.#motorTwist.setMotor(this.motorSpeedTwist, this.motorTorqueTwist);
            this.config = new OIMO.RagdollJointConfig();
            super.constructJoint(this.axisFirst, this.axisSecond);
            this.config.swingSpringDamper = this.#springDamperSwing;
            this.config.twistSpringDamper = this.#springDamperTwist;
            this.config.twistLimitMotor = this.#motorTwist;
            this.config.maxSwingAngle1 = this.#maxAngleFirst;
            this.config.maxSwingAngle2 = this.#maxAngleSecond;
            this.joint = new OIMO.RagdollJoint(this.config);
            super.configureJoint();
        }
        #getMutator;
        #mutate;
    }
    FudgeCore.JointRagdoll = JointRagdoll;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with a defined axe of rotation. Also known as HINGE joint.
       * Two RigidBodies need to be defined to use it. A motor can be defined to rotate the connected along the defined axis.
       *
       * ```text
       *                  rotation axis, 1st Degree of freedom
       *                    ‚Üë
       *               ‚îå‚îÄ‚îÄ‚îÄ‚îê‚îÇ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îÇ   ‚îÇ‚îÇ‚îÇ    ‚îÇ
       *               ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       *                    ‚îÇ
       *      bodyAnchor         bodyTied
       *   (e.g. Doorhinge)       (e.g. Door)
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointRevolute extends FudgeCore.JointAxial {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointRevolute); }
        #motorTorque;
        #rotor;
        constructor(_bodyAnchor = null, _bodyTied = null, _axis = new FudgeCore.Vector3(0, 1, 0), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied, _axis, _localAnchor);
            this.config = new OIMO.RevoluteJointConfig();
            this.#motorTorque = 0;
            this.maxMotor = 360;
            this.minMotor = 0;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        set maxMotor(_value) {
            super.maxMotor = _value;
            _value *= FudgeCore.Calc.deg2rad;
            if (this.joint)
                this.joint.getLimitMotor().upperLimit = _value;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        set minMotor(_value) {
            super.minMotor = _value;
            if (this.joint)
                this.joint.getLimitMotor().lowerLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The maximum motor force in Newton. force <= 0 equals disabled.
         */
        get motorTorque() {
            return this.#motorTorque;
        }
        set motorTorque(_value) {
            this.#motorTorque = _value;
            if (this.joint != null)
                this.joint.getLimitMotor().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                motorTorque: this.motorTorque,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.motorTorque = _serialization.motorTorque;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.motorTorque = this.motorTorque;
            return mutator;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (typeof (_mutator.motorTorque) !== "undefined")
                this.motorTorque = _mutator.motorTorque;
            delete _mutator.motorTorque;
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        //#endregion
        constructJoint() {
            this.#rotor = new OIMO.RotationalLimitMotor().setLimits(super.minMotor * FudgeCore.Calc.deg2rad, super.maxMotor * FudgeCore.Calc.deg2rad);
            this.#rotor.setMotor(this.motorSpeed, this.motorTorque);
            this.config = new OIMO.RevoluteJointConfig();
            super.constructJoint();
            this.config.springDamper = this.springDamper;
            this.config.limitMotor = this.#rotor;
            this.joint = new OIMO.RevoluteJoint(this.config);
            this.configureJoint();
        }
    }
    FudgeCore.JointRevolute = JointRevolute;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with three Degrees of Freedom, also known as ball and socket joint. Two bodies connected at their anchor but free to rotate.
       * Used for things like the connection of bones in the human shoulder (if simplified, else better use JointRagdoll). Two RigidBodies need to be defined to use it. Only spring settings can be defined.
       * 3 Degrees are swing horizontal, swing vertical and twist.
       *
       * ```text
       *              JointHolder
       *         z      bodyAnchor (e.g. Human-Shoulder)
       *      y  ‚Üë
       *        \|          ‚îÄ‚îÄ‚îÄ(‚óè‚îÄ‚îÄ‚îÄ
       *  -x <---|---> x           bodyTied
       *         |\                (e.g. Upper-Arm)
       *         ‚Üì -y
       *        -z
       * ```
       * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointSpherical extends FudgeCore.Joint {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointSpherical); }
        #springDamping;
        #springFrequency;
        #springDamper;
        constructor(_bodyAnchor = null, _bodyTied = null, _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.config = new OIMO.SphericalJointConfig();
            this.#springDamping = 0;
            this.#springFrequency = 0;
            this.anchor = new FudgeCore.Vector3(_localAnchor.x, _localAnchor.y, _localAnchor.z);
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDamping() {
            return this.#springDamping;
        }
        set springDamping(_value) {
            this.#springDamping = _value;
            if (this.joint != null)
                this.joint.getSpringDamper().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequency() {
            return this.#springFrequency;
        }
        set springFrequency(_value) {
            this.#springFrequency = _value;
            if (this.joint != null)
                this.joint.getSpringDamper().frequency = _value;
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                springDamping: this.springDamping,
                springFrequency: this.springFrequency,
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            this.springDamping = _serialization.springDamping;
            this.springFrequency = _serialization.springFrequency;
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        getMutator() {
            let mutator = super.getMutator();
            mutator.springDamping = this.springDamping;
            mutator.springFrequency = this.springFrequency;
            return mutator;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            this.mutateBase(_mutator, ["springDamping", "springFrequency"]);
            delete _mutator.springDamping;
            delete _mutator.springFrequency;
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        //#endregion
        constructJoint() {
            this.#springDamper = new OIMO.SpringDamper().setSpring(this.springFrequency, this.springDamping);
            this.config = new OIMO.SphericalJointConfig();
            super.constructJoint();
            this.config.springDamper = this.#springDamper;
            this.joint = new OIMO.SphericalJoint(this.config);
            super.configureJoint();
        }
    }
    FudgeCore.JointSpherical = JointSpherical;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with two defined axis (normally e.g. (0,0,1) and rotation(1,0,0)), they share the same anchor and have free rotation, but transfer the twist.
       * In reality used in cars to transfer the more stable stationary force on the velocity axis to the bumping, damped moving wheel. Two RigidBodies need to be defined to use it.
       * The two motors can be defined for the two rotation axis, along with springs.
       * ```text
       *
       *                      anchor - twist is transfered between bodies
       *         z                   |
       *         ‚Üë            -----  |  ------------
       *         |           |     | ‚Üì |            |
       *  -x <---|---> x     |     | x |            |           e.g. wheel can still turn up/down,
       *         |           |     |   |            |           left right but transfering it's rotation on to the wheel-axis.
       *         ‚Üì            -----     ------------
       *        -z
       *                 attachedRB          connectedRB
       *                (e.g. wheel)       (e.g. wheel-axis)
       * ```
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointUniversal extends FudgeCore.Joint {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointUniversal); }
        #springDampingFirst;
        #springFrequencyFirst;
        #springDampingSecond;
        #springFrequencySecond;
        #maxRotorFirst;
        #minRotorFirst;
        #rotorTorqueFirst;
        #rotorSpeedFirst;
        #maxRotorSecond;
        #minRotorSecond;
        #rotorTorqueSecond;
        #rotorSpeedSecond;
        #motorFirst;
        #motorSecond;
        #axisSpringDamperFirst;
        #axisSpringDamperSecond;
        #axisFirst;
        #axisSecond;
        constructor(_bodyAnchor = null, _bodyTied = null, _axisFirst = new FudgeCore.Vector3(1, 0, 0), _axisSecond = new FudgeCore.Vector3(0, 0, 1), _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.config = new OIMO.UniversalJointConfig();
            this.#springDampingFirst = 0;
            this.#springFrequencyFirst = 0;
            this.#springDampingSecond = 0;
            this.#springFrequencySecond = 0;
            this.#maxRotorFirst = 360;
            this.#minRotorFirst = 0;
            this.#rotorTorqueFirst = 0;
            this.#rotorSpeedFirst = 0;
            this.#maxRotorSecond = 360;
            this.#minRotorSecond = 0;
            this.#rotorTorqueSecond = 0;
            this.#rotorSpeedSecond = 0;
            this.#getMutator = () => {
                let mutator = {
                    springDampingFirst: this.#springDampingFirst,
                    springFrequencyFirst: this.#springFrequencyFirst,
                    springDampingSecond: this.#springDampingSecond,
                    springFrequencySecond: this.#springFrequencySecond,
                    maxRotorFirst: this.#maxRotorFirst,
                    minRotorFirst: this.#minRotorFirst,
                    rotorSpeedFirst: this.#rotorSpeedFirst,
                    rotorTorqueFirst: this.#rotorTorqueFirst,
                    maxRotorSecond: this.#maxRotorSecond,
                    minRotorSecond: this.#minRotorSecond,
                    rotorSpeedSecond: this.#rotorSpeedSecond,
                    rotorTorqueSecond: this.#rotorTorqueSecond
                };
                return mutator;
            };
            this.#mutate = (_mutator) => {
                this.mutateBase(_mutator, [
                    "springDampingFirst", "springFrequencyFirst", "springDampingSecond", "springFrequencySecond",
                    "maxRotorFirst", "minRotorFirst", "rotorSpeedFirst", "rotorTorqueFirst",
                    "maxRotorSecond", "minRotorSecond", "rotorSpeedSecond", ".rotorTorqueSecond"
                ]);
            };
            this.axisFirst = _axisFirst;
            this.axisSecond = _axisSecond;
            this.anchor = _localAnchor;
        }
        //#region Get/Set transfor of fudge properties to the physics engine
        /**
         * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
         *  When changed after initialization the joint needs to be reconnected.
         */
        get axisFirst() {
            return new FudgeCore.Vector3(this.#axisFirst.x, this.#axisFirst.y, this.#axisFirst.z);
        }
        set axisFirst(_value) {
            this.#axisFirst = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
        * The axis connecting the the two {@link Node}s e.g. Vector3(0,1,0) to have a upward connection.
        *  When changed after initialization the joint needs to be reconnected.
        */
        get axisSecond() {
            return new FudgeCore.Vector3(this.#axisSecond.x, this.#axisSecond.y, this.#axisSecond.z);
        }
        set axisSecond(_value) {
            this.#axisSecond = new OIMO.Vec3(_value.x, _value.y, _value.z);
            this.disconnect();
            this.dirtyStatus();
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingFirst() {
            return this.#springDampingFirst;
        }
        set springDampingFirst(_value) {
            this.#springDampingFirst = _value;
            if (this.joint != null)
                this.joint.getSpringDamper1().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencyFirst() {
            return this.#springFrequencyFirst;
        }
        set springFrequencyFirst(_value) {
            this.#springFrequencyFirst = _value;
            if (this.joint != null)
                this.joint.getSpringDamper1().frequency = _value;
        }
        /**
         * The damping of the spring. 1 equals completly damped.
         */
        get springDampingSecond() {
            return this.#springDampingSecond;
        }
        set springDampingSecond(_value) {
            this.#springDampingSecond = _value;
            if (this.joint != null)
                this.joint.getSpringDamper2().dampingRatio = _value;
        }
        /**
         * The frequency of the spring in Hz. At 0 the spring is rigid, equals no spring. The smaller the value the less restrictive is the spring.
        */
        get springFrequencySecond() {
            return this.#springFrequencySecond;
        }
        set springFrequencySecond(_value) {
            this.#springFrequencySecond = _value;
            if (this.joint != null)
                this.joint.getSpringDamper2().frequency = _value;
        }
        /**
          * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxRotorFirst() {
            return this.#maxRotorFirst;
        }
        set maxRotorFirst(_value) {
            this.#maxRotorFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().upperLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotorFirst() {
            return this.#minRotorFirst;
        }
        set minRotorFirst(_value) {
            this.#minRotorFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().lowerLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeedFirst() {
            return this.#rotorSpeedFirst;
        }
        set rotorSpeedFirst(_value) {
            this.#rotorSpeedFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().motorSpeed = _value;
        }
        /**
         * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorqueFirst() {
            return this.#rotorTorqueFirst;
        }
        set rotorTorqueFirst(_value) {
            this.#rotorTorqueFirst = _value;
            if (this.joint != null)
                this.joint.getLimitMotor1().motorTorque = _value;
        }
        /**
         * The Upper Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis-Angle measured in Degree.
         */
        get maxRotorSecond() {
            return this.#maxRotorSecond;
        }
        set maxRotorSecond(_value) {
            this.#maxRotorSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().upperLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The Lower Limit of movement along the axis of this joint. The limiter is disable if lowerLimit > upperLimit. Axis Angle measured in Degree.
         */
        get minRotorSecond() {
            return this.#minRotorSecond;
        }
        set minRotorSecond(_value) {
            this.#minRotorSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().lowerLimit = _value * FudgeCore.Calc.deg2rad;
        }
        /**
          * The target rotational speed of the motor in m/s.
         */
        get rotorSpeedSecond() {
            return this.#rotorSpeedSecond;
        }
        set rotorSpeedSecond(_value) {
            this.#rotorSpeedSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().motorSpeed = _value;
        }
        /**
          * The maximum motor torque in Newton. force <= 0 equals disabled.
         */
        get rotorTorqueSecond() {
            return this.#rotorTorqueSecond;
        }
        set rotorTorqueSecond(_value) {
            this.#rotorTorqueSecond = _value;
            if (this.joint != null)
                this.joint.getLimitMotor2().motorTorque = _value;
        }
        /**
          * If the two connected RigidBodies collide with eath other. (Default = false)
         */
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = this.#getMutator();
            serialization.firstAxis = this.axisFirst.serialize();
            serialization.secondAxis = this.axisSecond.serialize();
            serialization[super.constructor.name] = super.serialize();
            return serialization;
        }
        async deserialize(_serialization) {
            this.axisFirst = await new FudgeCore.Vector3().deserialize(_serialization.axisFirst);
            this.axisSecond = await new FudgeCore.Vector3().deserialize(_serialization.axisSecond);
            this.#mutate(_serialization);
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        async mutate(_mutator, _selection = null, _dispatchMutate = true) {
            if (typeof (_mutator.axisFirst) !== "undefined")
                this.axisFirst = new FudgeCore.Vector3(...(Object.values(_mutator.axisFirst)));
            if (typeof (_mutator.axisSecond) !== "undefined")
                this.axisSecond = new FudgeCore.Vector3(...(Object.values(_mutator.axisSecond)));
            delete _mutator.axisFirst;
            delete _mutator.axisSecond;
            this.#mutate(_mutator);
            this.deleteFromMutator(_mutator, this.#getMutator());
            await super.mutate(_mutator, _selection, _dispatchMutate);
        }
        getMutator() {
            let mutator = super.getMutator();
            Object.assign(mutator, this.#getMutator());
            mutator.axisFirst = this.axisFirst.getMutator();
            mutator.axisSecond = this.axisSecond.getMutator();
            return mutator;
        }
        //#endregion
        constructJoint() {
            this.#axisSpringDamperFirst = new OIMO.SpringDamper().setSpring(this.#springFrequencyFirst, this.#springDampingFirst);
            this.#axisSpringDamperSecond = new OIMO.SpringDamper().setSpring(this.#springFrequencySecond, this.#springDampingSecond);
            this.#motorFirst = new OIMO.RotationalLimitMotor().setLimits(this.#minRotorFirst * FudgeCore.Calc.deg2rad, this.#maxRotorFirst * FudgeCore.Calc.deg2rad);
            this.#motorFirst.setMotor(this.#rotorSpeedFirst, this.#rotorTorqueFirst);
            this.#motorSecond = new OIMO.RotationalLimitMotor().setLimits(this.#minRotorFirst * FudgeCore.Calc.deg2rad, this.#maxRotorFirst * FudgeCore.Calc.deg2rad);
            this.#motorSecond.setMotor(this.#rotorSpeedFirst, this.#rotorTorqueFirst);
            this.config = new OIMO.UniversalJointConfig();
            super.constructJoint(this.#axisFirst, this.#axisSecond);
            this.config.limitMotor1 = this.#motorFirst;
            this.config.limitMotor2 = this.#motorSecond;
            this.config.springDamper1 = this.#axisSpringDamperFirst;
            this.config.springDamper2 = this.#axisSpringDamperSecond;
            this.joint = new OIMO.UniversalJoint(this.config);
            super.configureJoint();
        }
        #getMutator;
        #mutate;
    }
    FudgeCore.JointUniversal = JointUniversal;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
       * A physical connection between two bodies with no movement.
       * Best way to simulate convex objects like a chair seat connected to chair legs.
       * The actual anchor point does not matter that much, only in very specific edge cases.
       * Because welding means they simply do not disconnect. (unless you add Breakability)
     * @author Marko Fehrenbach, HFU, 2020 | Jirka Dell'Oro-Friedl, HFU, 2021
       */
    class JointWelding extends FudgeCore.Joint {
        static { this.iSubclass = FudgeCore.Joint.registerSubclass(JointWelding); }
        constructor(_bodyAnchor = null, _bodyTied = null, _localAnchor = new FudgeCore.Vector3(0, 0, 0)) {
            super(_bodyAnchor, _bodyTied);
            this.config = new OIMO.GenericJointConfig();
            this.anchor = new FudgeCore.Vector3(_localAnchor.x, _localAnchor.y, _localAnchor.z);
        }
        //#endregion
        //#region Saving/Loading
        serialize() {
            let serialization = {
                [super.constructor.name]: super.serialize()
            };
            return serialization;
        }
        async deserialize(_serialization) {
            super.deserialize(_serialization[super.constructor.name]);
            return this;
        }
        //#endregion
        constructJoint() {
            this.config = new OIMO.GenericJointConfig();
            super.constructJoint(new OIMO.Mat3(), new OIMO.Mat3());
            this.joint = new OIMO.GenericJoint(this.config);
            this.joint.setAllowCollision(this.internalCollision);
        }
    }
    FudgeCore.JointWelding = JointWelding;
})(FudgeCore || (FudgeCore = {}));
/// <reference path="../../../Distribution/OimoPhysics.d.ts"/>
var FudgeCore;
/// <reference path="../../../Distribution/OimoPhysics.d.ts"/>
(function (FudgeCore) {
    /**
      * Manages the OIMO physics engine for FUDGE. Multiple instances may be created, one is active at a time.
      * All methods are static and use the currently active instance. At startup, a default instance is created and become the active instance
      * Attaching a {@link ComponentRigidbody} to a {@link Node} places a physics collider in the physics instance active at that time.
      * @author Marko Fehrenbach, HFU 2020
      */
    class Physics {
        /** The SETTINGS that apply to the physical world. Ranging from things like sleeping, collisionShapeThickness and others */
        static { this.settings = new FudgeCore.PhysicsSettings(FudgeCore.COLLISION_GROUP.DEFAULT, (FudgeCore.COLLISION_GROUP.DEFAULT | FudgeCore.COLLISION_GROUP.GROUP_1 | FudgeCore.COLLISION_GROUP.GROUP_2 | FudgeCore.COLLISION_GROUP.GROUP_3 | FudgeCore.COLLISION_GROUP.GROUP_4)); }
        static { this.∆íactive = new Physics(); }
        /** The rendering of physical debug informations. Used internally no interaction needed.*/
        #debugDraw;
        /** The camera/viewport the physics are debugged to. Used internally no interaction needed. */
        #mainCam;
        constructor() {
            this.bodyList = new Array();
            this.jointList = new Array();
            if (typeof OIMO == "undefined") { // Check if OIMO Namespace was loaded, else do not use any physics. Check is needed to ensure FUDGE can be used without Physics
                FudgeCore.Debug.error("OIMO physics engine not connected!");
                return null;
            }
            this.oimoWorld = new OIMO.World();
            this.#debugDraw = new FudgeCore.PhysicsDebugDraw(); //Create a FUDGE Physics debugging handling object
            this.oimoWorld.setDebugDraw(this.#debugDraw.oimoDebugDraw); //Tell OimoPhysics where to debug to and how it will be handled
        }
        /**
         * Define the currently active Physics instance
         */
        static set activeInstance(_physics) {
            Physics.∆íactive = _physics;
        }
        /** Get the currently active Physics instance */
        static get activeInstance() {
            return Physics.∆íactive;
        }
        static get debugDraw() {
            return Physics.∆íactive.#debugDraw;
        }
        static get mainCam() {
            return Physics.∆íactive.#mainCam;
        }
        /**
        * Cast a RAY into the physical world from a origin point in a certain direction. Receiving informations about the hit object and the
        * hit point. Do not specify a _group to raycast the whole world, else only bodies within the specific group can be hit.
        */
        static raycast(_origin, _direction, _length = 1, _debugDraw = false, _group = FudgeCore.COLLISION_GROUP.DEFAULT) {
            let hitInfo = new FudgeCore.RayHitInfo();
            let ray = new OIMO.RayCastClosest();
            let begin = new OIMO.Vec3(_origin.x, _origin.y, _origin.z);
            let end = this.getRayEndPoint(begin, new FudgeCore.Vector3(_direction.x, _direction.y, _direction.z), _length);
            ray.clear();
            if (_group == FudgeCore.COLLISION_GROUP.DEFAULT) { //Case 1: Raycasting the whole world, normal mode
                Physics.∆íactive.oimoWorld.rayCast(begin, end, ray);
            }
            else { //Case2: Raycasting on each body in a specific group
                let allHits = new Array();
                Physics.∆íactive.bodyList.forEach(function (_value) {
                    if (_value.collisionGroup == _group) {
                        hitInfo = _value.raycastThisBody(_origin, _direction, _length);
                        if (hitInfo.hit == true) { //Every hit is could potentially be the closest
                            allHits.push(hitInfo);
                        }
                    }
                });
                allHits.forEach(function (_value) {
                    if (_value.hitDistance < hitInfo.hitDistance || hitInfo.hit == false) {
                        hitInfo = _value;
                    }
                });
            }
            if (ray.hit) { //Fill in informations on the hit
                hitInfo.hit = true;
                hitInfo.hitPoint = new FudgeCore.Vector3(ray.position.x, ray.position.y, ray.position.z);
                hitInfo.hitNormal = new FudgeCore.Vector3(ray.normal.x, ray.normal.y, ray.normal.z);
                hitInfo.hitDistance = this.getRayDistance(_origin, hitInfo.hitPoint);
                hitInfo.rigidbodyComponent = ray.shape.userData;
                hitInfo.rayEnd = new FudgeCore.Vector3(end.x, end.y, end.z);
                hitInfo.rayOrigin = _origin;
            }
            else {
                hitInfo.rayOrigin = _origin;
                hitInfo.hitPoint = new FudgeCore.Vector3(end.x, end.y, end.z);
            }
            if (_debugDraw) { //Handle debugging
                Physics.∆íactive.#debugDraw.debugRay(hitInfo.rayOrigin, hitInfo.hitPoint, new FudgeCore.Color(0, 1, 0, 1));
            }
            return hitInfo;
        }
        /**
        * Simulates the physical world. _deltaTime is the amount of time between physical steps in seconds. Default is {@link Loop.timeFrameGame} / 1000 to run in sync with the {@link Loop}.
        * The maximum value is 1/30 of a second, to have more consistent frame calculations.
        */
        static simulate(_deltaTime = FudgeCore.Loop.timeFrameGame / 1000) {
            if (Physics.∆íactive.jointList.length > 0)
                Physics.connectJoints(); // Connect joints if anything has happened between the last call to any of the two paired rigidbodies
            if (_deltaTime == 0) // No time passed, no need to update the physics world
                return;
            _deltaTime = _deltaTime > 1 / 30 ? 1 / 30 : _deltaTime; // If instead of a fixed rate the game framerate is used, make sure irregular timings are fixed to 30fps
            Physics.∆íactive.oimoWorld.step(_deltaTime); // Update the simulation by the given deltaTime
        }
        /**
         * Draw information about the currently active instance using the {@link ComponentCamera} given
         */
        static draw(_cmpCamera, _mode) {
            Physics.∆íactive.#debugDraw.setDebugMode(_mode);
            Physics.∆íactive.#mainCam = _cmpCamera;
            Physics.∆íactive.oimoWorld.debugDraw(); //Filling the physics world debug informations into the debug rendering handler
            Physics.∆íactive.#debugDraw.drawBuffers();
            Physics.∆íactive.#debugDraw.clearBuffers(); //Updates info about the current projection, resetting the points/lines/triangles that need to be drawn from debug
        }
        /**
          * Adjusts the transforms of the {@link ComponentRigidbody}s in the given branch to match their nodes or meshes
          */
        static adjustTransforms(_branch, _toMesh = false) {
            FudgeCore.Render.prepare(_branch, { ignorePhysics: true });
            for (let node of FudgeCore.Render.nodesPhysics)
                node.getComponent(FudgeCore.ComponentRigidbody).initialize();
        }
        /**
        * Get the applied gravitational force of the active instance. Default earth gravity = 9.81 m/s
        */
        static getGravity() {
            let tmpVec = Physics.∆íactive.oimoWorld.getGravity();
            return new FudgeCore.Vector3(tmpVec.x, tmpVec.y, tmpVec.z);
        }
        /**
        * Set the applied gravitational force of the active instance. Default earth gravity = 9.81 m/s
        */
        static setGravity(_value) {
            let tmpVec = new OIMO.Vec3(_value.x, _value.y, _value.z);
            Physics.∆íactive.oimoWorld.setGravity(tmpVec);
        }
        /**
        * Add a new OIMO Rigidbody to the active instance, happens automatically when adding a FUDGE Rigidbody Component.
        */
        static addRigidbody(_cmpRB) {
            Physics.∆íactive.bodyList.push(_cmpRB);
            Physics.∆íactive.oimoWorld.addRigidBody(_cmpRB.getOimoRigidbody());
        }
        /**
        * Remove the OIMO Rigidbody to the active instance, happens automatically when removing a FUDGE Rigidbody Component
        */
        static removeRigidbody(_cmpRB) {
            // TODO: two lists are being managed, info might deviate. Cleanup!
            let oimoRigidBody = _cmpRB.getOimoRigidbody();
            if (oimoRigidBody._world)
                oimoRigidBody._world.removeRigidBody(oimoRigidBody);
            // what if the rigidbodys oimo-world does not belong to the active instance?
            let id = Physics.∆íactive.bodyList.indexOf(_cmpRB);
            if (id > -1)
                Physics.∆íactive.bodyList.splice(id, 1);
        }
        /**
        * Add a new OIMO Joint/Constraint to the active instance, happens automatically when adding a FUDGE Joint Component
        */
        static addJoint(_cmpJoint) {
            Physics.∆íactive.oimoWorld.addJoint(_cmpJoint.getOimoJoint());
        }
        /**
        * Called internally to inform the physics system that a joint has a change of core properties and needs to be recreated.
        */
        static changeJointStatus(_cmpJoint) {
            if (Physics.∆íactive.jointList.indexOf(_cmpJoint) < 0)
                Physics.∆íactive.jointList.push(_cmpJoint);
        }
        /**
          * Remove the OIMO Joint/Constraint to the active instance, happens automatically when removing a FUDGE Joint Component
          */
        static removeJoint(_cmpJoint) {
            try {
                Physics.∆íactive.oimoWorld.removeJoint(_cmpJoint.getOimoJoint());
            }
            catch (_error) {
                FudgeCore.Debug.fudge(_error);
            }
        }
        /** Returns all the ComponentRigidbodies that are known to the active instance. */
        static getBodyList() {
            return Physics.∆íactive.bodyList;
        }
        /** Giving a ComponentRigidbody a specific identification number so it can be referenced in the loading process. And removed rb's can receive a new id. */
        static distributeBodyID() {
            let freeId = 0;
            let free = false;
            Physics.∆íactive.bodyList.forEach((_value) => {
                if (_value.id != freeId) {
                    free = true;
                }
                else {
                    free = false;
                }
                if (!free) {
                    freeId++;
                }
            });
            return freeId;
        }
        /**
         * Connect all joints that are not connected yet. Used internally no user interaction needed. This functionality is called and needed to make sure joints connect/disconnect
         * if any of the two paired ComponentRigidbodies change.
         */
        static connectJoints() {
            let jointsToConnect = Physics.∆íactive.jointList;
            Physics.∆íactive.jointList = [];
            jointsToConnect.forEach((_joint) => {
                if (_joint.isConnected() == false)
                    if (_joint.isActive)
                        _joint.connect();
                    else
                        Physics.∆íactive.jointList.push(_joint);
            });
        }
        /** Remove all oimo joints and rigidbodies, so that they can be reused in another world  */
        static cleanup() {
            let oimoWorld = Physics.∆íactive.oimoWorld;
            if (oimoWorld != null) {
                //Resetting the world so a new world can be created, fix for re-opening a project in editor, making sure there are no old things calculated
                let jointsWorld = oimoWorld.getNumJoints();
                let bodiesWorld = oimoWorld.getNumRigidBodies();
                for (let body of Physics.∆íactive.bodyList)
                    body.isInitialized = false;
                Physics.∆íactive.jointList = new Array(); // TODO: see if it would be smarter, do use these arrays. Definitely more intuitive...
                for (let i = 0; i < jointsWorld; i++) {
                    let oimoJoint = Physics.∆íactive.oimoWorld.getJointList();
                    oimoWorld.removeJoint(oimoJoint);
                }
                for (let i = 0; i < bodiesWorld; i++) {
                    let oimoBody = oimoWorld.getRigidBodyList();
                    oimoWorld.removeRigidBody(oimoBody);
                }
            }
        }
        // /** Returns the ComponentRigidbody with the given id. Used internally to reconnect joints on loading in the editor. */
        // private static getBodyByID(_id: number): ComponentRigidbody {
        //   let body: ComponentRigidbody = null;
        //   Physics.#activePhysics.bodyList.forEach((value: ComponentRigidbody): void => {
        //     if (value.id == _id) {
        //       body = value;
        //     }
        //   });
        //   return body;
        // }
        /** Internal function to calculate the endpoint of mathematical ray. By adding the multiplied direction to the origin.
           * Used because OimoPhysics defines ray by start/end. But GameEngines commonly use origin/direction.
           */
        static getRayEndPoint(_start, _direction, _length) {
            let origin = FudgeCore.Recycler.get(FudgeCore.Vector3);
            origin.set(_start.x, _start.y, _start.z);
            let scaledDirection = _direction.clone;
            scaledDirection.scale(_length);
            let endpoint = FudgeCore.Vector3.SUM(scaledDirection, origin);
            FudgeCore.Recycler.store(scaledDirection);
            FudgeCore.Recycler.store(endpoint);
            FudgeCore.Recycler.store(origin);
            return new OIMO.Vec3(endpoint.x, endpoint.y, endpoint.z);
        }
        /** Internal function to get the distance in which a ray hit by subtracting points from each other and get the square root of the squared product of each component. */
        static getRayDistance(_origin, _hitPoint) {
            let dx = _origin.x - _hitPoint.x;
            let dy = _origin.y - _hitPoint.y;
            let dz = _origin.z - _hitPoint.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
        /** Returns the actual used world of the OIMO physics engine. No user interaction needed - Only for advanced users that need to access it directly */
        getOimoWorld() {
            return Physics.∆íactive.oimoWorld;
        }
    }
    FudgeCore.Physics = Physics;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defines a threedimensional box by two corner-points, one with minimal values and one with maximum values
     */
    class Box {
        constructor(_min = FudgeCore.Vector3.ONE(Infinity), _max = FudgeCore.Vector3.ONE(-Infinity)) {
            this.set(_min, _max);
        }
        /**
         * Define the corners of this box, standard values are Infinity for min, and -Infinity for max,
         * creating an impossible inverted box that can not contain any points
         */
        set(_min = FudgeCore.Vector3.ONE(Infinity), _max = FudgeCore.Vector3.ONE(-Infinity)) {
            this.min = _min;
            this.max = _max;
        }
        /**
         * Expand the box if necessary to include the given point
         */
        expand(_include) {
            this.min.min(_include);
            this.max.max(_include);
        }
        recycle() {
            this.min.set(Infinity, Infinity, Infinity);
            this.max.set(-Infinity, -Infinity, -Infinity);
        }
    }
    FudgeCore.Box = Box;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Stores information provided by {@link Render}-picking e.g. using {@link Picker} and provides methods for further calculation of positions and normals etc.
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Pick {
        #mtxViewToWorld;
        #posWorld;
        #posMesh;
        constructor(_node) {
            this.node = _node;
        }
        /**
         * Accessor to calculate and store world position of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get posWorld() {
            if (this.#posWorld)
                return this.#posWorld;
            let pointInClipSpace = FudgeCore.Vector3.Z(this.zBuffer);
            let m = this.#mtxViewToWorld.getArray();
            let result = FudgeCore.Vector3.TRANSFORMATION(pointInClipSpace, this.#mtxViewToWorld, true);
            let w = m[3] * pointInClipSpace.x + m[7] * pointInClipSpace.y + m[11] * pointInClipSpace.z + m[15];
            result.scale(1 / w);
            this.#posWorld = result;
            return result;
        }
        /**
         * Accessor to calculate and store position in mesh-space of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get posMesh() {
            if (this.#posMesh)
                return this.#posMesh;
            let mtxWorldToMesh = FudgeCore.Matrix4x4.INVERSE(this.node.getComponent(FudgeCore.ComponentMesh).mtxWorld);
            let posMesh = FudgeCore.Vector3.TRANSFORMATION(this.posWorld, mtxWorldToMesh);
            this.#posMesh = posMesh;
            return posMesh;
        }
        /**
         * Accessor to calculate and store the face normal in world-space at the point of intersection of {@link Ray} and {@link Mesh} only when used.
         */
        get normal() {
            let cmpMesh = this.node.getComponent(FudgeCore.ComponentMesh);
            let result;
            for (let face of cmpMesh.mesh.faces) {
                if (face.isInside(this.posMesh)) {
                    result = face.normal.clone;
                    break;
                }
            }
            result.transform(cmpMesh.mtxWorld, false);
            result.normalize();
            return result;
        }
        /**
         * Called solely by the renderer to enable calculation of the world coordinates of this {@link Pick}
         */
        set mtxViewToWorld(_mtxViewToWorld) {
            this.#mtxViewToWorld = _mtxViewToWorld;
        }
    }
    FudgeCore.Pick = Pick;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Provides static methods for picking using {@link Render}
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Picker {
        static pickRay(_from, _ray, _min, _max) {
            if (_from.length == 0)
                return [];
            let cmpCameraPick = FudgeCore.Recycler.reuse(FudgeCore.ComponentCamera);
            cmpCameraPick.mtxWorld.translation = _ray.origin;
            cmpCameraPick.mtxWorld.lookAt(FudgeCore.Vector3.SUM(_ray.origin, _ray.direction));
            cmpCameraPick.projectCentral(1, 0.001, FudgeCore.FIELD_OF_VIEW.DIAGONAL, _min, _max);
            let picks;
            if (_from[0] instanceof FudgeCore.Node)
                picks = FudgeCore.Render.pick(_from, cmpCameraPick);
            else
                picks = FudgeCore.Gizmos.pick(_from, cmpCameraPick);
            FudgeCore.Recycler.store(cmpCameraPick);
            return picks;
        }
        static pickCamera(_from, _cmpCamera, _posProjection) {
            let ray = new FudgeCore.Ray(new FudgeCore.Vector3(-_posProjection.x, _posProjection.y, 1));
            let length = ray.direction.magnitude;
            if (_cmpCamera.node) {
                let mtxCamera = FudgeCore.Matrix4x4.PRODUCT(_cmpCamera.node.mtxWorld, _cmpCamera.mtxPivot);
                ray.transform(mtxCamera);
                FudgeCore.Recycler.store(mtxCamera);
            }
            else
                ray.transform(_cmpCamera.mtxPivot);
            let picks = Picker.pickRay(_from, ray, length * _cmpCamera.near, length * _cmpCamera.far);
            return picks;
        }
        /**
         * Takes the camera of the given viewport and a point the client surface to construct the picker-camera,
         * then renders the pick-texture and returns an unsorted {@link Pick}-array with information about the hits of the ray.
         */
        static pickViewport(_viewport, _posClient) {
            let posProjection = _viewport.pointClientToProjection(_posClient);
            let nodes = Array.from(_viewport.getBranch().getIterator(true));
            let picks = Picker.pickCamera(nodes, _viewport.camera, posProjection);
            if (_viewport.gizmosEnabled)
                picks = picks.concat(Picker.pickCamera(_viewport.getGizmos(nodes), _viewport.camera, posProjection)); // this is kind of wasteful because we do the same calculations twice
            return picks;
        }
    }
    FudgeCore.Picker = Picker;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Defined by an origin and a direction of type {@link Pick}, rays are used to calculate picking and intersections
     * @authors Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class Ray {
        constructor(_direction = FudgeCore.Vector3.Z(1), _origin = FudgeCore.Vector3.ZERO(), _length = 1) {
            this.origin = _origin;
            this.direction = _direction;
            this.length = _length;
        }
        /**
         * Returns the point of intersection of this ray with a plane defined by
         * the given point of origin and the planes normal. All values and calculations
         * must be relative to the same coordinate system, preferably the world
         */
        intersectPlane(_origin, _normal) {
            let difference = FudgeCore.Vector3.DIFFERENCE(_origin, this.origin);
            let factor = FudgeCore.Vector3.DOT(difference, _normal) / FudgeCore.Vector3.DOT(this.direction, _normal);
            let intersect = FudgeCore.Vector3.SUM(this.origin, FudgeCore.Vector3.SCALE(this.direction, factor));
            return intersect;
        }
        /**
         * Returns the point of intersection of this ray with a plane defined by the face.
         * All values and calculations must be relative to the same coordinate system, preferably the world
         */
        intersectFacePlane(_face) {
            return this.intersectPlane(_face.getPosition(0), _face.normal);
        }
        /**
         * Returns the shortest distance from the ray to the given target point.
         * All values and calculations must be relative to the same coordinate system, preferably the world.
         */
        getDistance(_target) {
            let originToTarget = FudgeCore.Vector3.DIFFERENCE(_target, this.origin);
            let raySection = FudgeCore.Vector3.NORMALIZATION(this.direction, 1);
            let projectedLength = FudgeCore.Vector3.DOT(originToTarget, raySection);
            raySection.scale(projectedLength);
            raySection.add(this.origin);
            let distance = FudgeCore.Vector3.DIFFERENCE(_target, raySection);
            return distance;
        }
        /**
         * Transform the ray by the given matrix
         */
        transform(_mtxTransform) {
            this.origin.transform(_mtxTransform);
            this.direction.transform(_mtxTransform, false);
        }
        /**
         * Returns a readable string representation of this ray
         */
        toString() {
            return `origin: ${this.origin.toString()}, direction: ${this.direction.toString()}, length: ${this.length.toPrecision(5)}`;
        }
    }
    FudgeCore.Ray = Ray;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The gizmos drawing interface. {@link Component}s can use this to draw visual aids inside {@link Component.drawGizmos} and {@link Component.drawGizmosSelected}.
     */
    class Gizmos {
        /**
         * The default opacity of occluded gizmo parts. Use this to control the visibility of gizmos behind objects.
         * Set to 0 to make occluded gizmo parts disappear. Set to 1 to make occluded gizmo parts fully visible.
         */
        static { this.alphaOccluded = 0.3; } // currently gizmos can always be picked even if this is set to 0...
        static { this.arrayBuffer = FudgeCore.RenderWebGL.assert(FudgeCore.RenderWebGL.getRenderingContext().createBuffer()); }
        static { this.posIcons = new Set(); } // cache the positions of icons to avoid drawing them within each other
        static #camera;
        static #meshes = {};
        static #mapMeshToWireBuffers = new WeakMap();
        // TODO: think about drawing these on the fly instead of caching them. Then we could accept a position, radius etc. parameter and draw them independent from the mtxWorld
        static get wireCircle() {
            const radius = 0.5;
            const segments = 45;
            const circle = new Array(segments).fill(null).map(() => FudgeCore.Recycler.get(FudgeCore.Vector3));
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * 2 * Math.PI;
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                circle[i].set(x, y, 0);
            }
            const lines = [];
            for (let i = 0; i < segments; i++)
                lines.push(circle[i], circle[(i + 1) % segments]);
            Reflect.defineProperty(Gizmos, "wireCircle", { value: lines });
            return Gizmos.wireCircle;
        }
        static get wireSphere() {
            let lines = Gizmos.wireCircle.concat();
            let mtxRotation = FudgeCore.Matrix4x4.ROTATION_X(90);
            lines.push(...Gizmos.wireCircle.map((_point) => FudgeCore.Vector3.TRANSFORMATION(_point, mtxRotation)));
            mtxRotation.rotateY(90);
            lines.push(...Gizmos.wireCircle.map((_point) => FudgeCore.Vector3.TRANSFORMATION(_point, mtxRotation)));
            Reflect.defineProperty(Gizmos, "wireSphere", { value: lines });
            return Gizmos.wireSphere;
        }
        static get wireCone() {
            const radius = 0.5;
            const height = 1;
            const apex = FudgeCore.Vector3.ZERO();
            const quad = [
                new FudgeCore.Vector3(radius, 0, height),
                new FudgeCore.Vector3(-radius, 0, height),
                new FudgeCore.Vector3(0, radius, height),
                new FudgeCore.Vector3(0, -radius, height)
            ];
            let lines = Gizmos.wireCircle.map((_point) => FudgeCore.Vector3.TRANSFORMATION(_point, FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Vector3.Z(1))));
            lines.push(...[apex, quad[0], apex, quad[1], apex, quad[2], apex, quad[3]]);
            Reflect.defineProperty(Gizmos, "wireCone", { value: lines });
            return Gizmos.wireCone;
        }
        static get wireCube() {
            const halfSize = 0.5;
            const cube = [
                new FudgeCore.Vector3(halfSize, halfSize, halfSize), new FudgeCore.Vector3(-halfSize, halfSize, halfSize),
                new FudgeCore.Vector3(-halfSize, -halfSize, halfSize), new FudgeCore.Vector3(halfSize, -halfSize, halfSize),
                new FudgeCore.Vector3(halfSize, halfSize, -halfSize), new FudgeCore.Vector3(-halfSize, halfSize, -halfSize),
                new FudgeCore.Vector3(-halfSize, -halfSize, -halfSize), new FudgeCore.Vector3(halfSize, -halfSize, -halfSize)
            ];
            const lines = [
                cube[0], cube[1], cube[1], cube[2], cube[2], cube[3], cube[3], cube[0],
                cube[4], cube[5], cube[5], cube[6], cube[6], cube[7], cube[7], cube[4],
                cube[0], cube[4], cube[1], cube[5], cube[2], cube[6], cube[3], cube[7]
            ];
            Reflect.defineProperty(Gizmos, "wireCube", { value: lines });
            return Gizmos.wireCube;
        }
        /**
         * Are we currently rendering for picking?
         */
        static get #picking() {
            return this.pickId != null;
        }
        /**
         * Draws the given gizmos from the point of view of the given camera.
         */
        static draw(_gizmos, _cmpCamera, _selected) {
            for (const gizmo of _gizmos)
                if (gizmo.node)
                    Reflect.set(gizmo.node, "zCamera", _cmpCamera.pointWorldToClip(gizmo.node.mtxWorld.translation).z);
            _gizmos = _gizmos.sort((_a, _b) => (_b.node ? Reflect.get(_b.node, "zCamera") : 2) -
                (_a.node ? Reflect.get(_a.node, "zCamera") : 2));
            Gizmos.#camera = _cmpCamera;
            Gizmos.posIcons.clear();
            FudgeCore.RenderWebGLComponentCamera.useRenderbuffer(_cmpCamera);
            for (const gizmo of _gizmos) {
                gizmo.drawGizmos?.(_cmpCamera, Gizmos.#picking);
                if (_selected?.includes(gizmo.node))
                    gizmo.drawGizmosSelected?.(_cmpCamera);
            }
        }
        /**
         * Picks all gizmos in the line of sight and returns an unsorted array of {@link Pick}s each associated with the gizmo the pick ray hit.
         */
        static pick(_gizmos, _cmpCamera) {
            return FudgeCore.RenderWebGLPicking.pickFrom(_gizmos, _cmpCamera, Gizmos.pickGizmos);
        }
        /**
         * Draws a camera frustum for the given parameters. The frustum is oriented along the z-axis, with the tip of the truncated pyramid at the origin.
         */
        static drawWireFrustum(_aspect, _fov, _near, _far, _direction, _mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            const f = Math.tan(FudgeCore.Calc.deg2rad * _fov / 2);
            let scaleX = f;
            let scaleY = f;
            switch (_direction) {
                case FudgeCore.FIELD_OF_VIEW.HORIZONTAL:
                    scaleY = f / _aspect;
                    break;
                case FudgeCore.FIELD_OF_VIEW.VERTICAL:
                    scaleX = f * _aspect;
                    break;
                case FudgeCore.FIELD_OF_VIEW.DIAGONAL:
                    const diagonalAspect = Math.sqrt(_aspect);
                    scaleX = f * diagonalAspect;
                    scaleY = f / diagonalAspect;
                    break;
            }
            const nearX = _near * scaleX;
            const nearY = _near * scaleY;
            const farX = _far * scaleX;
            const farY = _far * scaleY;
            const frustum = new Array(8).fill(null).map(() => FudgeCore.Recycler.get(FudgeCore.Vector3));
            frustum[0].set(-nearX, nearY, _near);
            frustum[1].set(nearX, nearY, _near);
            frustum[2].set(nearX, -nearY, _near);
            frustum[3].set(-nearX, -nearY, _near);
            frustum[4].set(-farX, farY, _far);
            frustum[5].set(farX, farY, _far);
            frustum[6].set(farX, -farY, _far);
            frustum[7].set(-farX, -farY, _far);
            Gizmos.drawLines([
                frustum[0], frustum[1], frustum[1], frustum[2], frustum[2], frustum[3], frustum[3], frustum[0], // near plane
                frustum[4], frustum[5], frustum[5], frustum[6], frustum[6], frustum[7], frustum[7], frustum[4], // far plane
                frustum[0], frustum[4], frustum[1], frustum[5], frustum[2], frustum[6], frustum[3], frustum[7] // sides
            ], _mtxWorld, _color, _alphaOccluded);
            FudgeCore.Recycler.store(frustum);
        }
        /**
         * Draws a wireframe cube. The cube has a side-length of 1 and is centered around the origin.
         */
        static drawWireCube(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawLines(Gizmos.wireCube, _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws a wireframe sphere. The sphere has a diameter of 1 and is centered around the origin.
         */
        static drawWireSphere(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            let mtxWorld = _mtxWorld.clone;
            Gizmos.drawLines(Gizmos.wireSphere, mtxWorld, _color, _alphaOccluded);
            mtxWorld.lookAt(Gizmos.#camera.mtxWorld.translation);
            Gizmos.drawWireCircle(mtxWorld, _color, _alphaOccluded);
            FudgeCore.Recycler.store(mtxWorld);
        }
        /**
         * Draws a cone with a height and diameter of 1. The cone is oriented along the z-axis with the tip at the origin.
         */
        static drawWireCone(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawLines(Gizmos.wireCone, _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws a circle with a diameter of 1. The circle lies in the x-y plane, with its center at the origin.
         */
        static drawWireCircle(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawLines(Gizmos.wireCircle, _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws lines between each pair of the given vertices.
         * Vertices are paired sequentially, so for example, lines will be drawn between vertices 0 and 1, 2 and 3, 4 and 5, etc.
         */
        static drawLines(_vertices, _mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            const shader = Gizmos.#picking ? FudgeCore.ShaderPick : FudgeCore.ShaderGizmo;
            shader.useProgram();
            const lineData = new Float32Array(_vertices.length * 3);
            for (let i = 0; i < _vertices.length; i++) {
                const point = _vertices[i];
                lineData.set(point.get(), i * 3);
            }
            crc3.bindVertexArray(null);
            crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, Gizmos.arrayBuffer);
            crc3.enableVertexAttribArray(FudgeCore.SHADER_ATTRIBUTE.POSITION);
            crc3.vertexAttribPointer(FudgeCore.SHADER_ATTRIBUTE.POSITION, 3, WebGL2RenderingContext.FLOAT, false, 0, 0);
            Gizmos.bufferMatrix(shader, _mtxWorld);
            crc3.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, lineData, WebGL2RenderingContext.DYNAMIC_DRAW);
            Gizmos.drawGizmos(shader, Gizmos.drawArrays, _vertices.length, _color, _alphaOccluded);
        }
        /**
         * Draws a wireframe mesh.
         */
        static drawWireMesh(_mesh, _mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            const shader = Gizmos.#picking ? FudgeCore.ShaderPick : FudgeCore.ShaderGizmo;
            shader.useProgram();
            const wireBuffers = Gizmos.#mapMeshToWireBuffers.get(_mesh) ?? {};
            if (!Gizmos.#mapMeshToWireBuffers.has(_mesh)) {
                const indices = [];
                const renderBuffers = _mesh.getRenderBuffers();
                const renderMesh = _mesh.renderMesh;
                for (let i = 0; i < renderMesh.indices.length; i += 3) { // TODO: think about caching this in the mesh
                    const a = renderMesh.indices[i];
                    const b = renderMesh.indices[i + 1];
                    const c = renderMesh.indices[i + 2];
                    // Add the line segments for the triangle to the line indices
                    indices.push(a, b, b, c, c, a);
                }
                // set up vertex attribute object
                wireBuffers.vao = FudgeCore.RenderWebGL.assert(crc3.createVertexArray());
                wireBuffers.indices = FudgeCore.RenderWebGL.assert(FudgeCore.RenderWebGL.getRenderingContext().createBuffer());
                wireBuffers.positions = renderBuffers.positions;
                wireBuffers.nIndices = indices.length;
                crc3.bindVertexArray(wireBuffers.vao);
                crc3.bindBuffer(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, wireBuffers.indices);
                crc3.bufferData(WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), WebGL2RenderingContext.STATIC_DRAW);
                crc3.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, renderBuffers.positions);
                crc3.enableVertexAttribArray(FudgeCore.SHADER_ATTRIBUTE.POSITION);
                crc3.vertexAttribPointer(FudgeCore.SHADER_ATTRIBUTE.POSITION, 3, WebGL2RenderingContext.FLOAT, false, 0, 0);
            }
            Gizmos.bufferMatrix(shader, _mtxWorld);
            crc3.bindVertexArray(wireBuffers.vao);
            Gizmos.drawGizmos(shader, Gizmos.drawElementsLines, wireBuffers.nIndices, _color, _alphaOccluded);
        }
        /**
         * Draws an arrow at the given world position, facing in the given forward-direction with the given length and width.
         * Size refers to the size of the arrow head: the height of the pyramid; the size of the cube; the diameter of the sphere.
         * @param _forward A unit vector indicating the desired forward-direction.
         * @param _up A unit vector indicating the up-direction.
         */
        static drawArrow(_position, _color, _forward, _up, _length, _width, _size, _head = FudgeCore.MeshPyramid, _alphaOccluded = Gizmos.alphaOccluded) {
            const scaling = FudgeCore.Recycler.reuse(FudgeCore.Vector3).set(_width, _width, _length - _size);
            const mtxWorld = FudgeCore.Matrix4x4.COMPOSITION(_position);
            mtxWorld.scaling = scaling;
            mtxWorld.lookIn(_forward, _up);
            mtxWorld.translateZ(0.5);
            Gizmos.drawCube(mtxWorld, _color, _alphaOccluded);
            mtxWorld.translateZ(0.5);
            if (_head == FudgeCore.MeshPyramid) {
                const widthHead = _size / 2;
                mtxWorld.scaling = scaling.set(widthHead, widthHead, _size);
                mtxWorld.rotateX(90); // rotate the pyramid so it points in the right direction
            }
            else {
                mtxWorld.scaling = scaling.set(_size, _size, _size);
                mtxWorld.translateZ(0.5); // translate cube/sphere so it sits on top of the arrow
            }
            Gizmos.drawMesh(Gizmos.getMesh(_head), mtxWorld, _color, _alphaOccluded);
            FudgeCore.Recycler.store(mtxWorld);
            FudgeCore.Recycler.store(scaling);
        }
        /**
         * Draws a solid cube.
         */
        static drawCube(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawMesh(Gizmos.getMesh(FudgeCore.MeshCube), _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws a solid sphere.
         */
        static drawSphere(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawMesh(Gizmos.getMesh(FudgeCore.MeshSphere), _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws a solid quad.
         */
        static drawQuad(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawMesh(Gizmos.getMesh(FudgeCore.MeshQuad), _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws a solid double sided quad.
         */
        static drawSprite(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawMesh(Gizmos.getMesh(FudgeCore.MeshSprite), _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws a solid pyramid.
         */
        static drawPyramid(_mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            Gizmos.drawMesh(Gizmos.getMesh(FudgeCore.MeshPyramid), _mtxWorld, _color, _alphaOccluded);
        }
        /**
         * Draws a solid mesh.
         */
        static drawMesh(_mesh, _mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            const shader = Gizmos.#picking ? FudgeCore.ShaderPick : FudgeCore.ShaderGizmo;
            shader.useProgram();
            FudgeCore.RenderWebGL.useNodeUniforms(shader, _mtxWorld, null, null, Gizmos.pickId);
            const renderBuffers = _mesh.useRenderBuffers();
            Gizmos.drawGizmos(shader, Gizmos.drawElementsTrianlges, renderBuffers.nIndices, _color, _alphaOccluded);
        }
        /**
         * Draws an icon from a {@link Texture} on a {@link MeshQuad}. The icon is affected by the given transform and color.
         */
        static drawIcon(_texture, _mtxWorld, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            let position = _mtxWorld.translation.toString();
            if (Gizmos.posIcons.has(position))
                return;
            Gizmos.posIcons.add(position);
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            const shader = Gizmos.#picking ? FudgeCore.ShaderPickTextured : FudgeCore.ShaderGizmoTextured;
            shader.useProgram();
            let mtxWorld = _mtxWorld.clone;
            let color = _color.clone;
            let back = Gizmos.#camera.mtxWorld.getForward().negate();
            let up = Gizmos.#camera.mtxWorld.getUp();
            mtxWorld.lookIn(back, up);
            let distance = FudgeCore.Vector3.DIFFERENCE(Gizmos.#camera.mtxWorld.translation, mtxWorld.translation).magnitude;
            let fadeFar = 4;
            let fadeNear = 1.5;
            if (distance > 0 && distance < fadeFar) {
                distance = (distance - fadeNear) / (fadeFar - fadeNear);
                color.a = FudgeCore.Calc.lerp(0, color.a, distance);
            }
            _texture.useRenderData(FudgeCore.TEXTURE_LOCATION.COLOR.UNIT);
            crc3.uniform1i(shader.uniforms[FudgeCore.TEXTURE_LOCATION.COLOR.UNIFORM], FudgeCore.TEXTURE_LOCATION.COLOR.INDEX);
            FudgeCore.RenderWebGL.useNodeUniforms(shader, mtxWorld, null, null, Gizmos.pickId);
            const renderBuffers = Gizmos.getMesh(FudgeCore.MeshQuad).useRenderBuffers();
            Gizmos.drawGizmos(shader, Gizmos.drawElementsTrianlges, renderBuffers.nIndices, color, _alphaOccluded);
            FudgeCore.Recycler.store(mtxWorld);
            FudgeCore.Recycler.store(back);
            FudgeCore.Recycler.store(up);
            FudgeCore.Recycler.store(color);
        }
        static bufferColor(_shader, _color) {
            FudgeCore.RenderWebGL.getRenderingContext().uniform4fv(_shader.uniforms["u_vctColor"], _color.get());
        }
        static bufferMatrix(_shader, _mtxWorld) {
            FudgeCore.RenderWebGL.getRenderingContext().uniformMatrix4fv(_shader.uniforms["u_mtxMeshToWorld"], false, _mtxWorld.getArray());
        }
        static drawGizmos(_shader, _draw, _count, _color, _alphaOccluded = Gizmos.alphaOccluded) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            if (_alphaOccluded > 0) {
                let color = _color.clone;
                color.a *= _alphaOccluded;
                // draw occluded parts where the depth test failed (by inverting the depth test + no depth write)
                crc3.depthFunc(WebGL2RenderingContext.GEQUAL);
                crc3.depthMask(false);
                Gizmos.bufferColor(_shader, color);
                _draw(_count);
                crc3.depthFunc(WebGL2RenderingContext.LESS);
                crc3.depthMask(true);
                FudgeCore.Recycler.store(color);
            }
            Gizmos.bufferColor(_shader, _color);
            _draw(_count);
        }
        static drawElementsTrianlges(_count) {
            FudgeCore.RenderWebGL.getRenderingContext().drawElements(WebGL2RenderingContext.TRIANGLES, _count, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
        }
        static drawElementsLines(_count) {
            FudgeCore.RenderWebGL.getRenderingContext().drawElements(WebGL2RenderingContext.LINES, _count, WebGL2RenderingContext.UNSIGNED_SHORT, 0);
        }
        static drawArrays(_count) {
            FudgeCore.RenderWebGL.getRenderingContext().drawArrays(WebGL2RenderingContext.LINES, 0, _count);
        }
        static getMesh(_constructor) {
            let key = _constructor.name;
            let mesh = Gizmos.#meshes[key];
            if (mesh)
                return mesh;
            mesh = new _constructor(key);
            FudgeCore.Project.deregister(mesh);
            Gizmos.#meshes[key] = mesh;
            return mesh;
        }
        static pickGizmos(_gizmos, _cmpCamera) {
            const crc3 = FudgeCore.RenderWebGL.getRenderingContext();
            crc3.uniformMatrix3fv(FudgeCore.ShaderPickTextured.uniforms["u_mtxPivot"], false, FudgeCore.Matrix3x3.IDENTITY().getArray()); // only needed for textured pick shader, but gizmos have no pivot
            Gizmos.#camera = _cmpCamera;
            Gizmos.posIcons.clear();
            let picks = [];
            for (let gizmo of _gizmos) {
                if (!gizmo.drawGizmos)
                    continue;
                Gizmos.pickId = picks.length;
                gizmo.drawGizmos(_cmpCamera, Gizmos.#picking);
                let pick = new FudgeCore.Pick(gizmo.node);
                pick.gizmo = gizmo;
                picks.push(pick);
            }
            Gizmos.pickId = null;
            return picks;
        }
    }
    FudgeCore.Gizmos = Gizmos;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * The main interface to the render engine, here WebGL (see superclass {@link RenderWebGL} and the RenderInjectors
     */
    class Render extends FudgeCore.RenderWebGL {
        static { this.rectClip = new FudgeCore.Rectangle(-1, 1, 2, -2); }
        static { this.nodesPhysics = new FudgeCore.RecycableArray(); }
        static { this.componentsPick = new FudgeCore.RecycableArray(); }
        static { this.lights = new Map(); }
        static { this.nodesSimple = new FudgeCore.RecycableArray(); }
        static { this.nodesAlpha = new FudgeCore.RecycableArray(); }
        static { this.componentsSkeleton = new FudgeCore.RecycableArray(); }
        // cache events to avoid frequent recycling
        static #eventPrepare = FudgeCore.RecyclableEvent.get("renderPrepare" /* EVENT.RENDER_PREPARE */);
        static #eventPrepareStart = FudgeCore.RecyclableEvent.get("renderPrepareStart" /* EVENT.RENDER_PREPARE_START */);
        static #eventPrepareEnd = FudgeCore.RecyclableEvent.get("renderPrepareEnd" /* EVENT.RENDER_PREPARE_END */);
        static #defaultRootNode = new FudgeCore.Node("Root");
        static #defaultOptions = {};
        static #mapNodeToParent = new WeakMap();
        /**
         * Recursively iterates over the branch starting with the node given, recalculates all world transforms,
         * collects all lights and feeds the renderbuffers with the neccessary node and component data to draw a frame. Sorts nodes for different
         * render passes.
         * @param _recalculate - set true to force recalculation of all world transforms in the given branch, even if their local transforms haven't changed
         */
        static prepare(_branch, _options = Render.#defaultOptions, _recalculate = false) {
            Render.timestampUpdate = performance.now();
            Render.nodesSimple.reset();
            Render.nodesAlpha.reset();
            Render.nodesPhysics.reset();
            Render.componentsPick.reset();
            Render.componentsSkeleton.reset();
            for (const cmpLights of Render.lights.values())
                cmpLights.reset();
            FudgeCore.Node.resetRenderData();
            FudgeCore.Coat.resetRenderData();
            _branch.dispatchEvent(Render.#eventPrepareStart);
            this.prepareBranch(_branch, _options, _branch.getParent() ?? Render.#defaultRootNode, _recalculate);
            _branch.dispatchEvent(Render.#eventPrepareEnd);
            for (const cmpSkeleton of Render.componentsSkeleton)
                cmpSkeleton.updateRenderBuffer();
            FudgeCore.Node.updateRenderbuffer();
            FudgeCore.Coat.updateRenderbuffer();
            FudgeCore.ComponentLight.updateRenderbuffer(Render.lights);
        }
        static addLights(_cmpLights) {
            for (let cmpLight of _cmpLights) {
                if (!cmpLight.isActive)
                    continue;
                let type = cmpLight.lightType;
                let lightsOfType = Render.lights.get(type);
                if (!lightsOfType) {
                    lightsOfType = new FudgeCore.RecycableArray();
                    Render.lights.set(type, lightsOfType);
                }
                lightsOfType.push(cmpLight);
            }
        }
        /**
         * Draws the scene from the point of view of the given camera
         */
        static draw(_cmpCamera) {
            let nodesAlpha;
            if (Render.nodesAlpha.length > 0) { // TODO: avoid object and function creation in loop
                for (let node of Render.nodesAlpha)
                    Reflect.set(node, "zCamera", _cmpCamera.pointWorldToClip(node.getComponent(FudgeCore.ComponentMesh).mtxWorld.translation).z);
                nodesAlpha = Render.nodesAlpha.getSorted((_a, _b) => Reflect.get(_b, "zCamera") - Reflect.get(_a, "zCamera"));
            }
            Render.drawNodes(Render.nodesSimple, nodesAlpha ?? Render.nodesAlpha, _cmpCamera);
        }
        static prepareBranch(_branch, _options, _parent, _recalculate) {
            if (!_branch.isActive)
                return; // don't add branch to render list if not active
            _branch.nNodesInBranch = 1;
            _branch.radius = 0;
            // PerformanceMonitor.startMeasure("Render.prepareBranch dispatch prepare");
            _branch.dispatchEventToTargetOnly(Render.#eventPrepare);
            // PerformanceMonitor.endMeasure("Render.prepareBranch dispatch prepare");
            _branch.timestampUpdate = Render.timestampUpdate;
            const mtxWorldParent = _parent.mtxWorld;
            const mtxWorldBranch = _branch.mtxWorld;
            let previousParent = Render.#mapNodeToParent.get(_branch);
            if (_parent != previousParent) {
                Render.#mapNodeToParent.set(_branch, _parent);
                _recalculate = true;
            }
            // PerformanceMonitor.startMeasure("Render.prepareBranch cmpTransform");
            const cmpTransform = _branch.getComponent(FudgeCore.ComponentTransform);
            if (cmpTransform?.isActive) {
                if ((_recalculate ||= cmpTransform.mtxLocal.modified)) {
                    FudgeCore.Matrix4x4.PRODUCT(mtxWorldParent, cmpTransform.mtxLocal, mtxWorldBranch);
                    cmpTransform.mtxLocal.modified = false;
                }
            }
            else
                mtxWorldBranch.copy(mtxWorldParent); // overwrite readonly mtxWorld of the current node
            // PerformanceMonitor.endMeasure("Render.prepareBranch cmpTransform");
            // PerformanceMonitor.startMeasure("Render.prepareBranch cmpRigidbody");
            const cmpRigidbody = _branch.getComponent(FudgeCore.ComponentRigidbody);
            if (cmpRigidbody?.isActive) { //TODO: support de-/activation throughout
                Render.nodesPhysics.push(_branch); // add this node to physics list
                if (!_options?.ignorePhysics)
                    this.transformByPhysics(_branch, cmpRigidbody);
            }
            // PerformanceMonitor.endMeasure("Render.prepareBranch cmpRigidbody");
            // PerformanceMonitor.startMeasure("Render.prepareBranch cmpPick");
            const cmpPick = _branch.getComponent(FudgeCore.ComponentPick);
            if (cmpPick?.isActive) {
                Render.componentsPick.push(cmpPick); // add this component to pick list
            }
            // PerformanceMonitor.endMeasure("Render.prepareBranch cmpPick");
            // PerformanceMonitor.startMeasure("Render.prepareBranch cmpLight");
            const cmpLights = _branch.getComponents(FudgeCore.ComponentLight);
            Render.addLights(cmpLights);
            // PerformanceMonitor.endMeasure("Render.prepareBranch cmpLight");
            // PerformanceMonitor.startMeasure("Render.prepareBranch cmpMesh cmpMaterial");
            const cmpMesh = _branch.getComponent(FudgeCore.ComponentMesh);
            const cmpMaterial = _branch.getComponent(FudgeCore.ComponentMaterial);
            if (cmpMesh?.isActive && cmpMaterial?.isActive) {
                if (cmpMesh.mtxPivot.modified || _recalculate) {
                    FudgeCore.Matrix4x4.PRODUCT(mtxWorldBranch, cmpMesh.mtxPivot, cmpMesh.mtxWorld);
                    cmpMesh.mtxPivot.modified = false;
                }
                let cmpFaceCamera = _branch.getComponent(FudgeCore.ComponentFaceCamera);
                let cmpParticleSystem = _branch.getComponent(FudgeCore.ComponentParticleSystem);
                _branch.updateRenderData(cmpMesh, cmpMaterial, cmpFaceCamera, cmpParticleSystem);
                _branch.radius = cmpMesh.radius;
                if (cmpMaterial.sortForAlpha || _branch.getComponent(FudgeCore.ComponentText)) // always sort text for alpha
                    Render.nodesAlpha.push(_branch); // add this node to render list
                else
                    Render.nodesSimple.push(_branch); // add this node to render list
                let material = cmpMaterial.material;
                if (material?.timestampUpdate < Render.timestampUpdate) {
                    material.timestampUpdate = Render.timestampUpdate;
                    material.coat.updateRenderData();
                }
            }
            // PerformanceMonitor.endMeasure("Render.prepareBranch cmpMesh cmpMaterial");
            const cmpCamera = _branch.getComponent(FudgeCore.ComponentCamera) ?? _branch.getComponent(FudgeCore.ComponentVRDevice); // checking for both of these is rather slow, maybe only update used cameras after all?
            if (cmpCamera && cmpCamera.isActive && (cmpCamera.mtxPivot.modified || _recalculate)) {
                FudgeCore.Matrix4x4.PRODUCT(mtxWorldBranch, cmpCamera.mtxPivot, cmpCamera.mtxWorld);
                cmpCamera.mtxPivot.modified = false;
            }
            // PerformanceMonitor.startMeasure("Render.prepareBranch cmpSkeleton");
            const cmpSkeletons = _branch.getComponents(FudgeCore.ComponentSkeleton);
            for (let cmpSkeleton of cmpSkeletons)
                if (cmpSkeleton?.isActive)
                    Render.componentsSkeleton.push(cmpSkeleton);
            // PerformanceMonitor.endMeasure("Render.prepareBranch cmpSkeleton");
            for (let child of _branch.getChildren()) {
                Render.prepareBranch(child, _options, _branch, _recalculate);
                _branch.nNodesInBranch += child.nNodesInBranch;
                _branch.radius = Math.max(_branch.radius, (child.getComponent(FudgeCore.ComponentMesh)?.mtxWorld.translation ?? child.mtxWorld.translation).getDistance(mtxWorldBranch.translation) + child.radius);
            }
        }
        static transformByPhysics(_node, _cmpRigidbody) {
            if (!_cmpRigidbody.isInitialized) // || Project.mode == MODE.EDITOR)
                _cmpRigidbody.initialize();
            if (!FudgeCore.Physics.getBodyList().length)
                return;
            if (!_node.mtxLocal) {
                throw (new Error("ComponentRigidbody requires ComponentTransform at the same Node"));
            }
            // _cmpRigidbody.checkCollisionEvents();
            if (_cmpRigidbody.typeBody == FudgeCore.BODY_TYPE.KINEMATIC || FudgeCore.Project.mode == FudgeCore.MODE.EDITOR) { //Case of Kinematic Rigidbody
                let mtxPivotWorld = FudgeCore.Matrix4x4.PRODUCT(_node.mtxWorld, _cmpRigidbody.mtxPivotUnscaled);
                _cmpRigidbody.setPosition(mtxPivotWorld.translation);
                _cmpRigidbody.setRotation(mtxPivotWorld.rotation);
                FudgeCore.Recycler.store(mtxPivotWorld);
                return;
            }
            let mtxWorld = FudgeCore.Matrix4x4.COMPOSITION(_cmpRigidbody.getPosition(), _cmpRigidbody.getRotation());
            mtxWorld.multiply(_cmpRigidbody.mtxPivotInverse);
            _node.mtxWorld.translation = mtxWorld.translation;
            _node.mtxWorld.rotation = mtxWorld.rotation;
            let parent = _node.getParent();
            let mtxLocal = parent ?
                FudgeCore.Matrix4x4.RELATIVE(_node.mtxWorld, parent.mtxWorld, parent.mtxWorldInverse) :
                _node.mtxWorld.clone;
            _node.mtxLocal.copy(mtxLocal);
            FudgeCore.Recycler.store(mtxWorld);
            FudgeCore.Recycler.store(mtxLocal);
        }
    }
    FudgeCore.Render = Render;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Inserted into a {@link Mesh}, an instance of this class calculates and represents the mesh data in the form needed by the render engine
     */
    class RenderMesh {
        /** indices to create faces from the vertices, rotation determines direction of face-normal */
        #indices;
        /** vertices of the actual point cloud, some points might be in the same location in order to refer to different texels */
        #positions;
        /** vertex normals for smooth shading, interpolated between vertices during rendering */
        #normals;
        /** texture coordinates associated with the vertices by the position in the array */
        #textureUVs;
        /* colors */
        #colors;
        /** vertex tangents for normal mapping, based on the vertex normals and the UV coordinates */
        #tangents;
        #bones;
        #weights;
        constructor(_mesh) {
            this.mesh = _mesh;
        }
        get positions() {
            return this.#positions || ( // return cache or ...
            // ... flatten all vertex positions from cloud into a typed array
            this.#positions = new Float32Array(this.mesh.vertices.flatMap((_vertex, _index) => {
                return [...this.mesh.vertices.position(_index).get()];
            })));
        }
        set positions(_vertices) {
            this.#positions = _vertices;
        }
        get indices() {
            return this.#indices || ( // return cache or ...
            // ... flatten all indices from the faces into a typed array
            this.#indices = new Uint16Array(this.mesh.faces.flatMap((_face) => _face.indices)));
        }
        set indices(_indices) {
            this.#indices = _indices;
        }
        get normals() {
            if (this.#normals == null) {
                // TODO: implement a check similiar to the one for tangents below, to see if normals are already present in the vertices
                // sum up all unscaled normals of faces connected to one vertex, weighted by the angle between the two neighbour vertices...
                this.mesh.vertices.forEach(_vertex => _vertex.normal.set(0, 0, 0));
                for (let face of this.mesh.faces)
                    face.indices.forEach((_iVertex, _iFaceVertex) => {
                        this.mesh.vertices.normal(_iVertex).add(FudgeCore.Vector3.SCALE(face.normalUnscaled, face.angles[_iFaceVertex]));
                    });
                // ... and normalize them
                this.mesh.vertices.forEach(_vertex => {
                    // some vertices might be unused and yield a zero-normal...
                    if (_vertex.normal.magnitudeSquared > 0)
                        _vertex.normal.normalize();
                });
                // this.∆ínormalsVertex = new Float32Array(normalsVertex.flatMap((_normal: Vector3) => [..._normal.get()]));
                this.#normals = new Float32Array(this.mesh.vertices.flatMap((_vertex, _index) => [...this.mesh.vertices.normal(_index).get()]));
            }
            return this.#normals;
        }
        set normals(_normals) {
            this.#normals = _normals;
        }
        get tangents() {
            if (this.#tangents == null) {
                if (this.mesh.vertices.some(_vertex => !_vertex.uv)) { // assume all vertices have texture coordinates or none
                    this.#tangents = new Float32Array(); // no texture coordinates, no tangents
                    return this.#tangents;
                }
                if (this.mesh.vertices.some(_vertex => !_vertex.tangent)) { // assume all vertices have tangents or none
                    const tangents = new Array(this.mesh.vertices.length);
                    const bitangents = new Array(this.mesh.vertices.length);
                    for (let i = 0; i < tangents.length; i++) {
                        tangents[i] = FudgeCore.Vector3.ZERO();
                        bitangents[i] = FudgeCore.Vector3.ZERO();
                    }
                    // this.mesh.vertices.forEach(_vertex => _vertex.tangent.set(0, 0, 0));
                    for (let face of this.mesh.faces) {
                        let i0 = face.indices[0];
                        let i1 = face.indices[1];
                        let i2 = face.indices[2];
                        //vertices surrounding one triangle
                        let v0 = this.mesh.vertices.position(i0);
                        let v1 = this.mesh.vertices.position(i1);
                        let v2 = this.mesh.vertices.position(i2);
                        //their UVs
                        let uv0 = this.mesh.vertices.uv(i0);
                        let uv1 = this.mesh.vertices.uv(i1);
                        let uv2 = this.mesh.vertices.uv(i2);
                        //We compute the edges of the triangle...
                        let deltaPos0 = FudgeCore.Vector3.DIFFERENCE(v1, v0);
                        let deltaPos1 = FudgeCore.Vector3.DIFFERENCE(v2, v0);
                        //...and the edges of the triangles in UV space...
                        let deltaUV0 = FudgeCore.Vector2.DIFFERENCE(uv1, uv0);
                        let deltaUV1 = FudgeCore.Vector2.DIFFERENCE(uv2, uv0);
                        //...and compute the tangent
                        let r = 1 / FudgeCore.Vector2.CROSS(deltaUV0, deltaUV1);
                        let faceTangent = FudgeCore.Vector3.SCALE(FudgeCore.Vector3.DIFFERENCE(FudgeCore.Vector3.SCALE(deltaPos0, deltaUV1.y), FudgeCore.Vector3.SCALE(deltaPos1, deltaUV0.y)), r);
                        let faceBitangent = FudgeCore.Vector3.SCALE(FudgeCore.Vector3.DIFFERENCE(FudgeCore.Vector3.SCALE(deltaPos1, -deltaUV0.x), FudgeCore.Vector3.SCALE(deltaPos0, -deltaUV1.x)), r); // for winding order counter clockwise
                        tangents[i0].add(FudgeCore.Vector3.SCALE(faceTangent, face.angles[0]));
                        tangents[i1].add(FudgeCore.Vector3.SCALE(faceTangent, face.angles[1]));
                        tangents[i2].add(FudgeCore.Vector3.SCALE(faceTangent, face.angles[2]));
                        bitangents[i0].add(FudgeCore.Vector3.SCALE(faceBitangent, face.angles[0]));
                        bitangents[i1].add(FudgeCore.Vector3.SCALE(faceBitangent, face.angles[1]));
                        bitangents[i2].add(FudgeCore.Vector3.SCALE(faceBitangent, face.angles[2]));
                    }
                    this.mesh.vertices.forEach((_vertex, _index) => {
                        let normal = this.mesh.vertices.normal(_index);
                        let tangent = tangents[_index];
                        let bitangent = bitangents[_index];
                        // reorthogonalize
                        tangent.add(FudgeCore.Vector3.SCALE(normal, -FudgeCore.Vector3.DOT(normal, tangent)));
                        if (tangent.magnitudeSquared > 0) // some vertices might be unused and yield a zero-tangent...
                            tangent.normalize();
                        let handedness = (FudgeCore.Vector3.DOT(FudgeCore.Vector3.CROSS(normal, tangent), bitangent) < 0) ? -1 : 1;
                        _vertex.tangent = new FudgeCore.Vector4(tangent.x, tangent.y, tangent.z, handedness);
                    });
                }
                this.#tangents = new Float32Array(this.mesh.vertices.flatMap(_vertex => _vertex.tangent.get()));
            }
            return this.#tangents;
        }
        set tangents(_tangents) {
            this.#tangents = _tangents;
        }
        get textureUVs() {
            return this.#textureUVs || ( // return cache or ...
            // ... flatten all uvs from the clous into a typed array
            this.#textureUVs = new Float32Array(this.mesh.vertices
                .filter(_vertex => _vertex.uv)
                .flatMap((_vertex) => [..._vertex.uv.get()])));
        }
        set textureUVs(_textureUVs) {
            this.#textureUVs = _textureUVs;
        }
        get colors() {
            return this.#colors || (this.#colors = new Float32Array(this.mesh.vertices
                .filter(_vertex => _vertex.color)
                .flatMap(_vertex => [..._vertex.color.get()])));
        }
        set colors(_colors) {
            this.#colors = _colors;
        }
        get bones() {
            return this.#bones || ( // return cache or ...
            this.#bones = this.mesh.vertices.some(_vertex => _vertex.bones) ?
                new Uint8Array(this.mesh.vertices.flatMap((_vertex, _index) => {
                    const bones = this.mesh.vertices.bones(_index);
                    return [bones?.[0]?.index || 0, bones?.[1]?.index || 0, bones?.[2]?.index || 0, bones?.[3]?.index || 0];
                })) :
                undefined);
        }
        set bones(_iBones) {
            this.#bones = _iBones;
        }
        get weights() {
            return this.#weights || ( // return cache or ...
            this.#weights = this.mesh.vertices.some(_vertex => _vertex.bones) ?
                new Float32Array(this.mesh.vertices.flatMap((_vertex, _index) => {
                    const bones = this.mesh.vertices.bones(_index);
                    return [bones?.[0]?.weight || 0, bones?.[1]?.weight || 0, bones?.[2]?.weight || 0, bones?.[3]?.weight || 0];
                })) :
                undefined);
        }
        set weights(_weights) {
            this.#weights = _weights;
        }
        /**
         * Clears this render mesh and all its buffers
         */
        clear() {
            this.#positions = null;
            this.#indices = null;
            this.#textureUVs = null;
            this.#normals = null;
            this.#colors = null;
            this.#tangents = null;
            this.#bones = null;
            this.#weights = null;
        }
    }
    FudgeCore.RenderMesh = RenderMesh;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Controls the rendering of a branch, using the given {@link ComponentCamera},
     * and the propagation of the rendered image from the offscreen renderbuffer to the target canvas
     * through a series of {@link Framing} objects. The stages involved are in order of rendering
     * {@link Render}.viewport -> {@link Viewport}.source -> {@link Viewport}.destination -> DOM-Canvas -> Client(CSS)
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019-2022 | Jonas Plotzky, HFU, 2023
     * @link https://github.com/hs-furtwangen/FUDGE/wiki/Viewport
     */
    class Viewport extends FudgeCore.EventTargetUnified {
        constructor() {
            super(...arguments);
            this.name = "Viewport"; // The name to call this viewport by.
            this.camera = null; // The camera representing the view parameters to render the branch.
            // TODO: verify if client to canvas should be in Viewport or somewhere else (Window, Container?)
            // Multiple viewports using the same canvas shouldn't differ here...
            // different framing methods can be used, this is the default
            this.frameClientToCanvas = new FudgeCore.FramingScaled();
            this.frameCanvasToDestination = new FudgeCore.FramingComplex();
            this.frameDestinationToSource = new FudgeCore.FramingScaled();
            this.frameSourceToRender = new FudgeCore.FramingScaled();
            this.adjustingFrames = true;
            this.adjustingCamera = true;
            this.physicsDebugMode = FudgeCore.PHYSICS_DEBUGMODE.NONE;
            this.gizmosEnabled = false;
            this.gizmosFilter = Object.fromEntries(FudgeCore.Component.subclasses // TODO: maybe make this lazy
                .filter((_class) => (_class.prototype).drawGizmos || (_class.prototype).drawGizmosSelected)
                .map((_class) => [_class.name, true]));
            this.componentsPick = new FudgeCore.RecycableArray();
            this.#branch = null; // The to render with all its descendants.
            this.#crc2 = null;
            this.#canvas = null;
            this.#rectCanvas = FudgeCore.Rectangle.GET(0, 0, 0, 0);
            this.#rectClient = FudgeCore.Rectangle.GET(0, 0, 0, 0);
            this.#canvasResizeObserver = new ResizeObserver(() => {
                this.#rectClient.width = this.#canvas.clientWidth;
                this.#rectClient.height = this.#canvas.clientHeight;
            });
        }
        #branch; // The to render with all its descendants.
        #crc2;
        #canvas;
        #rectCanvas;
        #rectClient;
        #canvasResizeObserver;
        // readonly #canvasMutationObserver: MutationObserver = new MutationObserver(() => { // TODO: think about using a mutation observer to keep track of the canvas size.
        //   this.#rectCanvas.width = this.#canvas.width;
        //   this.#rectCanvas.height = this.#canvas.height;
        // });
        //#endregion
        // #region Events (passing from canvas to viewport and from there into branch)
        /**
         * Returns true if this viewport currently has focus and thus receives keyboard events
         */
        get hasFocus() {
            return (Viewport.focus == this);
        }
        /**
         * Retrieve the destination canvas
         */
        get canvas() {
            return this.#canvas;
        }
        /**
         * Retrieve the 2D-context attached to the destination canvas
         */
        get context() {
            return this.#crc2;
        }
        /**
         * The rectangle of the canvas area in CSS pixels. Use this to access the canvas width and height,
         * but without incuring browser internal garbage collection.
         *
         * Adjusted internally by {@link adjustFrames}, do not modify.
         */
        get rectCanvas() {
            return this.#rectCanvas;
        }
        /**
         * The rectangle of the canvas area as displayed (considering css). Use this to access canvas clientWidth and clientHeight,
         * but without incuring browser internal garbage collection.
         *
         * Adjusted automatically on canvas resize, do not modify.
         */
        get rectClient() {
            return this.#rectClient;
        }
        /**
         * Connects the viewport to the given canvas to render the given branch to using the given camera-component, and names the viewport as given.
         */
        initialize(_name, _branch, _camera, _canvas) {
            this.name = _name;
            this.camera = _camera;
            this.#canvas = _canvas;
            this.#crc2 = _canvas.getContext("2d");
            this.#crc2.imageSmoothingEnabled = false;
            this.#canvas.tabIndex = 0; // can get focus and receive keyboard events
            this.#rectCanvas.width = _canvas.width;
            this.#rectCanvas.height = _canvas.height;
            this.#rectClient.width = _canvas.clientWidth;
            this.#rectClient.height = _canvas.clientHeight;
            this.rectSource = FudgeCore.Render.getCanvasRectangle().clone;
            this.rectDestination = FudgeCore.Rectangle.GET(0, 0, this.#canvas.clientWidth, this.#canvas.clientHeight);
            // this.#canvasMutationObserver.disconnect();
            // this.#canvasMutationObserver.observe(this.#canvas, { attributes: true, attributeFilter: ["width", "height"] });
            this.#canvasResizeObserver.disconnect();
            this.#canvasResizeObserver.observe(this.#canvas); // TODO: if viewport is garbage collected, this observer should be disconnected as well...
            this.setBranch(_branch);
        }
        /**
         * Disconnect the resize observer from the canvas to allow garbage collection of the viewport.
         */
        disconnect() {
            // this.#canvasMutationObserver.disconnect();
            this.#canvasResizeObserver.disconnect();
        }
        /**
         * Retrieve the size of the destination canvas as a rectangle, x and y are always 0.
         * @deprecated Use {@link rectCanvas} instead.
         */
        getCanvasRectangle() {
            return FudgeCore.Rectangle.GET(0, 0, this.#canvas.width, this.#canvas.height);
        }
        /**
         * Retrieve the client rectangle the canvas is displayed and fit in, x and y are always 0.
         * @deprecated Use {@link rectClient} instead.
         */
        getClientRectangle() {
            // FUDGE doesn't care about where the client rect is, only about the size matters.
            // return Rectangle.GET(this.canvas.offsetLeft, this.canvas.offsetTop, this.canvas.clientWidth, this.canvas.clientHeight);
            return FudgeCore.Rectangle.GET(0, 0, this.#canvas.clientWidth, this.#canvas.clientHeight);
        }
        /**
         * Set the branch to be drawn in the viewport.
         */
        setBranch(_branch) {
            if (_branch) {
                const event = FudgeCore.RecyclableEvent.get("attachBranch" /* EVENT.ATTACH_BRANCH */);
                _branch.broadcastEvent(event);
                FudgeCore.Recycler.store(event);
            }
            this.#branch = _branch;
        }
        /**
         * Retrieve the branch this viewport renders
         */
        getBranch() {
            return this.#branch;
        }
        // #region Drawing
        /**
         * Draw this viewport displaying its branch. By default, the transforms in the branch are recalculated first.
         * Pass `false` if calculation was already done for this frame
         */
        // @PerformanceMonitor.measure("Viewport.draw")
        draw(_prepareBranch = true) {
            this.prepare(_prepareBranch);
            FudgeCore.Render.resetFramebuffer();
            FudgeCore.Render.clear(this.camera.clrBackground);
            if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.PHYSIC_OBJECTS_ONLY) {
                FudgeCore.Render.draw(this.camera);
                if (this.gizmosEnabled)
                    FudgeCore.Gizmos.draw(this.getGizmos(), this.camera, this.gizmosSelected);
            }
            if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.NONE) {
                FudgeCore.Physics.draw(this.camera, this.physicsDebugMode);
            }
            const eventRenderEnd = FudgeCore.RecyclableEvent.get("renderEnd" /* EVENT.RENDER_END */);
            this.dispatchEvent(eventRenderEnd);
            FudgeCore.RecyclableEvent.store(eventRenderEnd);
            // this.#crc2.clearRect(0, 0, this.#rectCanvas.width, this.#rectCanvas.height); // for now don't clear to allow mulltiple viewport draw on same canvas
            this.#crc2.drawImage(// <- costs a lot of performance in firefox
            FudgeCore.Render.getCanvas(), this.rectSource.x, this.rectSource.y, this.rectSource.width, this.rectSource.height, this.rectDestination.x, this.rectDestination.y, this.rectDestination.width, this.rectDestination.height);
        }
        /**
        * Adjusts all frames and the camera to fit the current size of the canvas. Prepares the branch for rendering.
        */
        // @PerformanceMonitor.measure("Viewport.prepare")
        prepare(_prepareBranch = true) {
            if (!this.#branch)
                return;
            if (!this.camera.isActive)
                return;
            // PerformanceMonitor.startMeasure("Viewport.prepare cmpCamera.mtxWorld * cmpCamera.mtxPivot");
            if (!this.camera.node) //TODO: find an elegant way to handle cameras that are either attached to a node or not...
                this.camera.mtxWorld.copy(this.camera.mtxPivot);
            // PerformanceMonitor.endMeasure("Viewport.prepare cmpCamera.mtxWorld * cmpCamera.mtxPivot");
            if (this.adjustingFrames)
                this.adjustFrames();
            if (this.adjustingCamera)
                this.adjustCamera();
            if (_prepareBranch)
                this.prepareBranch();
        }
        /**
         * Prepares all nodes in the branch for rendering by updating their world transforms and supplying the gpu renderbuffers with the neccessary node and component data to draw a frame.
         */
        // @PerformanceMonitor.measure("Viewport.prepareBranch")
        prepareBranch() {
            const eventPrepareStart = FudgeCore.RecyclableEvent.get("renderPrepareStart" /* EVENT.RENDER_PREPARE_START */);
            this.dispatchEvent(eventPrepareStart);
            FudgeCore.RecyclableEvent.store(eventPrepareStart);
            FudgeCore.Render.prepare(this.#branch);
            const eventPrepareEnd = FudgeCore.RecyclableEvent.get("renderPrepareEnd" /* EVENT.RENDER_PREPARE_END */);
            this.dispatchEvent(eventPrepareEnd);
            FudgeCore.RecyclableEvent.store(eventPrepareEnd);
            this.componentsPick = FudgeCore.Render.componentsPick;
        }
        /**
         * Performs a pick on all {@link ComponentPick}s in the branch of this viewport
         * using a ray from its camera through the client coordinates given in the event.
         * Dispatches the event to all nodes hit.
         * If {@link PICK.CAMERA} was chosen as the method to pick, a pick property gets added to the event,
         * which holds the detailed information, but is overwritten for each node.
         */
        dispatchPointerEvent(_event) {
            let posClient = new FudgeCore.Vector2(_event.clientX, _event.clientY);
            let ray = this.getRayFromClient(posClient);
            // let cameraPicks: RecycableArray<Node> = Recycler.get(RecycableArray); //TODO: think about optimization later
            let cameraPicks = [];
            let otherPicks = [];
            for (let cmpPick of this.componentsPick)
                if (cmpPick.pick == FudgeCore.PICK.CAMERA)
                    cameraPicks.push(cmpPick.node);
                else
                    otherPicks.push(cmpPick);
            if (cameraPicks.length) {
                let picks = FudgeCore.Picker.pickCamera(cameraPicks, this.camera, this.pointClientToProjection(posClient));
                for (let pick of picks) {
                    Reflect.set(_event, "pick", pick);
                    pick.node.dispatchEvent(_event);
                }
            }
            for (let cmpPick of otherPicks) {
                cmpPick.pickAndDispatch(ray, _event);
            }
        }
        /**
         * Adjust all frames involved in the rendering process from the display area in the client up to the renderer canvas.
         */
        adjustFrames() {
            // adjust the canvas size according to the given framing applied to client
            const rectCanvas = this.frameClientToCanvas.getRect(this.#rectClient);
            if (this.#rectClient.width != this.#rectCanvas.width) {
                this.#rectCanvas.width = rectCanvas.width;
                this.#canvas.width = rectCanvas.width; // setting width or height of canvas causes side effects, so only do it if neccessary, see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/width
            }
            if (this.#rectClient.height != this.#rectCanvas.height) {
                this.#rectCanvas.height = rectCanvas.height;
                this.#canvas.height = rectCanvas.height;
            }
            // adjust the destination area on the target-canvas to render to by applying the framing to canvas
            this.frameCanvasToDestination.getRect(rectCanvas, this.rectDestination);
            // adjust the area on the source-canvas to render from by applying the framing to destination area
            this.frameDestinationToSource.getRect(this.rectDestination, this.rectSource);
            // having an offset source does make sense only when multiple viewports display parts of the same rendering. For now: shift it to 0,0
            this.rectSource.x = this.rectSource.y = 0;
            // still, a partial image of the rendering may be retrieved by moving and resizing the render viewport. For now, it's always adjusted to the current viewport
            const rectRender = this.frameSourceToRender.getRect(this.rectSource);
            FudgeCore.Render.setRenderRectangle(rectRender);
            // no more transformation after this for now, offscreen canvas and render-viewport have the same size
            FudgeCore.Render.setCanvasSize(rectRender.width, rectRender.height);
            FudgeCore.Recycler.store(rectCanvas);
            FudgeCore.Recycler.store(rectRender);
        }
        /**
         * Adjust the camera parameters to fit the rendering into the render viewport.
         */
        adjustCamera() {
            const rectRender = FudgeCore.Render.getRenderRectangle();
            this.camera.projectCentral(rectRender.width / rectRender.height, this.camera.fieldOfView, this.camera.direction, this.camera.near, this.camera.far);
            // const projection: PROJECTION = this.camera.projection;
            // switch (projection) {
            // case PROJECTION.CENTRAL:
            // this.camera.projectCentral(rectRender.width / rectRender.height, this.camera.fieldOfView, this.camera.direction, this.camera.near, this.camera.far);
            // break;
            // case PROJECTION.ORTHOGRAPHIC:
            //   this.camera.projectOrthographic();
            //   // this.camera.projectOrthographic(-rectRender.width / 20, rectRender.width / 20, rectRender.height / 20, -rectRender.height / 20);
            //   break;
            // }
        }
        // #endregion
        //#region Points
        /**
         * Returns a {@link Ray} in world coordinates from this camera through the point given in client space
         */
        getRayFromClient(_point) {
            let posProjection = this.pointClientToProjection(_point);
            let ray = new FudgeCore.Ray(new FudgeCore.Vector3(-posProjection.x, posProjection.y, 1));
            // ray.direction.scale(camera.distance);
            ray.transform(this.camera.mtxPivot);
            let cameraNode = this.camera.node;
            if (cameraNode)
                ray.transform(cameraNode.mtxWorld);
            return ray;
        }
        /**
         * Returns a point on the client rectangle matching the projection of the given point in world space
         */
        pointWorldToClient(_position) {
            let projection = this.camera.pointWorldToClip(_position);
            let posClient = this.pointClipToClient(projection.toVector2());
            return posClient;
        }
        /**
         * Returns a point on the source-rectangle matching the given point on the client rectangle
         */
        pointClientToSource(_client) {
            let result = this.frameClientToCanvas.getPoint(_client, this.#rectClient);
            result = this.frameCanvasToDestination.getPoint(result, this.#rectCanvas);
            result = this.frameDestinationToSource.getPoint(result, this.rectSource);
            //TODO: when Source, Render and RenderViewport deviate, continue transformation 
            return result;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the source rectangle
         */
        pointSourceToRender(_source) {
            let projectionRectangle = this.camera.getProjectionRectangle();
            let point = this.frameSourceToRender.getPoint(_source, projectionRectangle);
            // console.log(projectionRectangle.toString());
            return point;
        }
        /**
         * Returns a point on the render-rectangle matching the given point on the client rectangle
         */
        pointClientToRender(_client) {
            let point = this.pointClientToSource(_client);
            point = this.pointSourceToRender(point);
            //TODO: when Render and RenderViewport deviate, continue transformation 
            return point;
        }
        /**
         * Returns a point on a projection surface in the hypothetical distance of 1 to the camera
         * matching the given point on the client rectangle
         * TODO: examine, if this should be a camera-method. Current implementation is for central-projection
         */
        pointClientToProjection(_client) {
            let posRender = this.pointClientToRender(_client);
            let rectRender = this.frameSourceToRender.getRect(this.rectSource);
            let rectProjection = this.camera.getProjectionRectangle();
            let posProjection = new FudgeCore.Vector2(rectProjection.width * posRender.x / rectRender.width, rectProjection.height * posRender.y / rectRender.height);
            posProjection.subtract(new FudgeCore.Vector2(rectProjection.width / 2, rectProjection.height / 2));
            posProjection.y *= -1;
            return posProjection;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToClient(_normed) {
            // let rectClient: Rectangle = this.getClientRectangle();
            // let result: Vector2 = Vector2.ONE(0.5);
            // result.x *= (_normed.x + 1) * rectClient.width;
            // result.y *= (1 - _normed.y) * rectClient.height;
            // result.add(rectClient.position);
            //TODO: check if rectDestination can safely (and more perfomant) be used instead getClientRectangle
            let pointClient = FudgeCore.Render.rectClip.pointToRect(_normed, this.rectDestination);
            return pointClient;
        }
        /**
         * Returns a point in the client rectangle matching the given point in normed clipspace rectangle,
         * which stretches from -1 to 1 in both dimensions, y pointing up
         */
        pointClipToCanvas(_normed) {
            let pointCanvas = FudgeCore.Render.rectClip.pointToRect(_normed, this.#rectCanvas);
            return pointCanvas;
        }
        /**
         * Returns a point in the browser page matching the given point of the viewport
         */
        pointClientToScreen(_client) {
            let screen = new FudgeCore.Vector2(this.#canvas.offsetLeft + _client.x, this.#canvas.offsetTop + _client.y);
            return screen;
        }
        // #endregion
        /**
         * Returns all the gizmos in the branch of this viewport that are active, filtered by {@link gizmosFilter}
         */
        getGizmos(_nodes = Array.from(this.#branch.getIterator(true))) {
            return _nodes
                .flatMap(_node => _node.getAllComponents())
                .filter(_component => _component.isActive && (_component.drawGizmos || _component.drawGizmosSelected) && this.gizmosFilter[_component.type]);
        }
    }
    FudgeCore.Viewport = Viewport;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Different xr session modes available. Could be expand with more modes in the future.
     * @authors Valentin Schmidberger, HFU, 2022 | Jonas Plotzky, HFU, 2023
     */
    let XR_SESSION_MODE;
    (function (XR_SESSION_MODE) {
        XR_SESSION_MODE["IMMERSIVE_VR"] = "immersive-vr";
        //IMMERSIVE_AR = "immersive-ar",
        //INLINE = "inline"
    })(XR_SESSION_MODE = FudgeCore.XR_SESSION_MODE || (FudgeCore.XR_SESSION_MODE = {}));
    /**
     * Different reference vr-spaces available, creator has to check if the space is supported with its device.
     * Could be expand with more available space types in the future.
     */
    let XR_REFERENCE_SPACE;
    (function (XR_REFERENCE_SPACE) {
        XR_REFERENCE_SPACE["VIEWER"] = "viewer";
        XR_REFERENCE_SPACE["LOCAL"] = "local";
        // LOCAL_FLOOR = "local-floor",
        // BOUNDED_FLOOR = "bounded-floor",
        // UNBOUNDED = "unbounded"
    })(XR_REFERENCE_SPACE = FudgeCore.XR_REFERENCE_SPACE || (FudgeCore.XR_REFERENCE_SPACE = {}));
    /**
     * XRViewport (webXR)-extension of Viewport, to displaying its branch on Head Mounted and AR (not implemted yet) Devices
     */
    class XRViewport extends FudgeCore.Viewport {
        static { this.xrViewportInstance = null; }
        // private poseMtx: Matrix4x4 = new Matrix4x4();
        constructor() {
            super();
            this.vrDevice = null;
            this.session = null;
            this.referenceSpace = null;
            this.useVRController = false;
            XRViewport.xrViewportInstance = this;
        }
        /**
         * To retrieve private static instance of xr viewport, readonly.
         */
        static get default() {
            return this.xrViewportInstance;
        }
        /**
          * Connects the viewport to the given canvas to render the given branch to using the given camera-component, and names the viewport as given.
          */
        initialize(_name, _branch, _cameraXR /* | ComponentCameraAR*/, _canvas) {
            super.initialize(_name, _branch, _cameraXR, _canvas);
        }
        /**
         * The VR Session is initialized here, also VR - Controller are initialized, if boolean is true.
         * Creator has to call FrameRequestXR after this Method to run the viewport in virtual reality.
         */
        async initializeVR(_vrSessionMode = XR_SESSION_MODE.IMMERSIVE_VR, _vrReferenceSpaceType = XR_REFERENCE_SPACE.LOCAL, _vrController = false) {
            let session = await navigator.xr.requestSession(_vrSessionMode);
            this.referenceSpace = await session.requestReferenceSpace(_vrReferenceSpaceType);
            await FudgeCore.Render.getRenderingContext().makeXRCompatible();
            let nativeScaleFactor = XRWebGLLayer.getNativeFramebufferScaleFactor(session);
            //TODO:  Field of view k√∂nnte an der Stelle noch ver√§ndert werden.
            let baseLayer = new XRWebGLLayer(session, FudgeCore.Render.getRenderingContext(), { framebufferScaleFactor: nativeScaleFactor });
            await session.updateRenderState({ baseLayer: baseLayer });
            FudgeCore.Render.setFramebufferTarget(baseLayer.framebuffer);
            FudgeCore.Render.setCanvasSize(baseLayer.framebufferWidth, baseLayer.framebufferHeight);
            FudgeCore.Render.setRenderRectangle(FudgeCore.Rectangle.GET(0, 0, baseLayer.framebufferWidth, baseLayer.framebufferHeight));
            FudgeCore.Render.adjustAttachments();
            this.adjustingFrames = false; // web xr handles this now
            this.vrDevice = this.camera;
            this.initializeReferenceSpace();
            this.useVRController = _vrController;
            if (_vrController) {
                this.vrDevice.rightCntrl.cmpTransform = new FudgeCore.ComponentTransform();
                this.vrDevice.leftCntrl.cmpTransform = new FudgeCore.ComponentTransform();
            }
            this.session = session;
            this.prepareBranch();
        }
        /**
         * The AR session could be initialized here. Up till now not implemented.
         */
        async initializeAR(_arSessionMode = null, _arReferenceSpaceType = null) {
            FudgeCore.Debug.error("NOT IMPLEMENTED YET! Check out initializeVR!");
        }
        /**
         * Draw the xr viewport displaying its branch. By default, the transforms in the branch are recalculated first.
         * Pass `false` if calculation was already done for this frame
         * Called from loop method {@link Loop} again with the xrFrame parameter handover, as soon as FRAME_REQUEST_XR is called from creator.
         */
        draw(_prepareBranch = true, _xrFrame = null) {
            if (!this.session) {
                super.draw(_prepareBranch);
                return;
            }
            let pose = _xrFrame?.getViewerPose(this.referenceSpace);
            if (!pose)
                return;
            this.vrDevice.mtxLocal.setArray(pose.transform.matrix);
            this.vrDevice.mtxLocal.rotateY(180); // rotate back because the XR Rig is looking in the direction of negative z
            super.prepare(_prepareBranch);
            FudgeCore.Render.resetFramebuffer();
            FudgeCore.Render.clear(this.camera.clrBackground);
            let glLayer = this.session.renderState.baseLayer;
            for (let view of pose.views) {
                let viewport = glLayer.getViewport(view);
                FudgeCore.Render.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);
                FudgeCore.Render.setScissorTest(true, viewport.x, viewport.y, viewport.width, viewport.height);
                if (this.useVRController)
                    this.setControllerConfigs(_xrFrame);
                this.camera.mtxProjection.setArray(view.projectionMatrix);
                this.camera.mtxCameraInverse.setArray(view.transform.inverse.matrix);
                if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.PHYSIC_OBJECTS_ONLY)
                    FudgeCore.Render.draw(this.camera);
                if (this.physicsDebugMode != FudgeCore.PHYSICS_DEBUGMODE.NONE)
                    FudgeCore.Physics.draw(this.camera, this.physicsDebugMode);
            }
            // reset for other render operations e.g. picking
            FudgeCore.Render.setScissorTest(false);
            FudgeCore.Render.setRenderRectangle(FudgeCore.Render.getRenderRectangle());
        }
        /**
         * Move the reference space to set the initial position/orientation of the vr device in accordance to the node the vr device is attached to.
         */
        initializeReferenceSpace() {
            let mtxWorld = this.vrDevice.node?.getComponent(FudgeCore.ComponentVRDevice)?.mtxWorld;
            if (!mtxWorld)
                return;
            mtxWorld = mtxWorld.clone;
            mtxWorld.rotateY(180); // rotate because the XR Rig is looking in the direction of negative z
            let invMtxTransfom = FudgeCore.Matrix4x4.INVERSE(mtxWorld); // inverse because we are moving the reference space
            XRViewport.default.referenceSpace = XRViewport.default.referenceSpace.getOffsetReferenceSpace(new XRRigidTransform(invMtxTransfom.translation, invMtxTransfom.quaternion));
        }
        //Sets controller matrices and thumbsticks movements.
        setControllerConfigs(_xrFrame) {
            if (_xrFrame) {
                if (XRViewport.default.session.inputSources.length > 0) {
                    XRViewport.default.session.inputSources.forEach(_controller => {
                        try {
                            switch (_controller.handedness) {
                                case ("right"):
                                    this.vrDevice.rightCntrl.cmpTransform.mtxLocal.setArray(_xrFrame.getPose(_controller.targetRaySpace, XRViewport.default.referenceSpace).transform.matrix);
                                    if (!this.vrDevice.rightCntrl.gamePad)
                                        this.vrDevice.rightCntrl.gamePad = _controller.gamepad;
                                    else {
                                        this.vrDevice.rightCntrl.thumbstickX = _controller.gamepad.axes[2];
                                        this.vrDevice.rightCntrl.thumbstickY = _controller.gamepad.axes[3];
                                    }
                                    break;
                                case ("left"):
                                    this.vrDevice.leftCntrl.cmpTransform.mtxLocal.setArray(_xrFrame.getPose(_controller.targetRaySpace, XRViewport.default.referenceSpace).transform.matrix);
                                    if (!this.vrDevice.leftCntrl.gamePad)
                                        this.vrDevice.leftCntrl.gamePad = _controller.gamepad;
                                    else {
                                        this.vrDevice.leftCntrl.thumbstickX = _controller.gamepad.axes[2];
                                        this.vrDevice.leftCntrl.thumbstickY = _controller.gamepad.axes[3];
                                    }
                                    break;
                            }
                        }
                        catch (e) {
                            FudgeCore.Debug.error("Input Sources Error: " + e);
                        }
                    });
                }
            }
        }
    }
    FudgeCore.XRViewport = XRViewport;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Handles file transfer from a FUDGE-Browserapp to the local filesystem without a local server.
     * Saves to the download-path given by the browser, loads from the player's choice.
     */
    class FileIoBrowserLocal extends FudgeCore.EventTargetStatic {
        // TODO: refactor to async function to be handled using promise, instead of using event target
        /**
         * Open file select dialog to load files from local filesystem into browser application.
         */
        static async load(_multiple = false) {
            FileIoBrowserLocal.selector = document.createElement("input");
            FileIoBrowserLocal.selector.type = "file";
            FileIoBrowserLocal.selector.multiple = _multiple;
            FileIoBrowserLocal.selector.hidden = true;
            FileIoBrowserLocal.selector.addEventListener("change", FileIoBrowserLocal.handleFileSelect);
            document.body.appendChild(FileIoBrowserLocal.selector);
            return new Promise(_resolve => {
                function hndLoaded(_event) {
                    FileIoBrowserLocal.removeEventListener("fileLoaded" /* EVENT.FILE_LOADED */, hndLoaded);
                    _resolve(_event.detail.mapFilenameToContent);
                }
                FileIoBrowserLocal.addEventListener("fileLoaded" /* EVENT.FILE_LOADED */, hndLoaded);
                FileIoBrowserLocal.selector.click();
            });
        }
        // TODO: refactor to async function to be handled using promise, instead of using event target
        /**
         * Open a file download dialog to save files to local filesystem.
         */
        static save(_toSave, _type = "text/plain") {
            for (let filename in _toSave) {
                let content = _toSave[filename];
                let blob = new Blob([content], { type: _type });
                let url = window.URL.createObjectURL(blob);
                //*/ using anchor element for download
                let downloader;
                downloader = document.createElement("a");
                downloader.setAttribute("href", url);
                downloader.setAttribute("download", filename);
                document.body.appendChild(downloader);
                downloader.click();
                document.body.removeChild(downloader);
                window.URL.revokeObjectURL(url);
            }
            return new Promise(_resolve => {
                _resolve(_toSave);
                // function hndSaved(_event: Event): void {
                //   FileIoBrowserLocal.removeEventListener(EVENT.FILE_SAVED, hndSaved);
                //   _resolve((<CustomEvent>_event).detail);
                // }
                // FileIoBrowserLocal.addEventListener(EVENT.FILE_SAVED, hndSaved);
                // let event: CustomEvent = new CustomEvent(EVENT.FILE_SAVED, { detail: { mapFilenameToContent: _toSave } });
                // FileIoBrowserLocal.targetStatic.dispatchEvent(event);
            });
        }
        /**
         * Load the the files referenced in {@link FileList} into the provided {@link MapFilenameToContent}
         */
        static async loadFiles(_fileList, _loaded) {
            for (let file of _fileList) {
                const content = await new Response(file).text();
                _loaded[file.name] = content;
            }
        }
        static async handleFileSelect(_event) {
            FudgeCore.Debug.fudge("-------------------------------- handleFileSelect");
            document.body.removeChild(FileIoBrowserLocal.selector);
            let fileList = _event.target.files;
            FudgeCore.Debug.fudge(fileList, fileList.length);
            if (fileList.length == 0)
                return;
            let loaded = {};
            await FileIoBrowserLocal.loadFiles(fileList, loaded);
            let event = new CustomEvent("fileLoaded" /* EVENT.FILE_LOADED */, { detail: { mapFilenameToContent: loaded } });
            FileIoBrowserLocal.targetStatic.dispatchEvent(event);
        }
    }
    FudgeCore.FileIoBrowserLocal = FileIoBrowserLocal;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Mutable array of {@link Mutable}s. The {@link Mutator}s of the entries are included as array in the {@link Mutator}
     * @author Jirka Dell'Oro-Friedl, HFU, 2021
     */
    class MutableArray extends Array {
        #type;
        constructor(_type, ..._args) {
            super(..._args);
            this.#type = _type;
        }
        get type() {
            return this.#type;
        }
        /**
         * Rearrange the entries of the array according to the given sequence of indices
         */
        rearrange(_sequence) {
            let length = this.length;
            for (let index of _sequence) {
                let original = this[index];
                // TODO: optimize, copy only double entries
                //@ts-ignore
                let copy = new original.constructor();
                copy.mutate(original.getMutator());
                this.push(copy);
            }
            this.splice(0, length);
        }
        /**
         * Returns an associative array with this arrays elements corresponding types as string-values
         */
        getMutatorAttributeTypes(_mutator) {
            let types = {};
            for (let entry in this)
                types[entry] = this[entry].constructor.name;
            return types;
        }
        /**
         * Returns an array with each elements mutator by invoking {@link Mutable.getMutator} on them
         */
        getMutator() {
            return this.map((_value) => _value.getMutator());
        }
        /**
         * See {@link Mutable.getMutatorForUserInterface}
         */
        getMutatorForUserInterface() {
            return this.getMutator();
        }
        async mutate(_mutator) {
            for (let entry in _mutator)
                await this[entry].mutate(_mutator[entry]);
        }
        /**
         * Updates the values of the given mutator according to the current state of the instance
         */
        updateMutator(_mutator) {
            for (let entry in this) {
                let mutatorValue = _mutator[entry];
                if (!mutatorValue)
                    continue;
                if (this[entry] instanceof FudgeCore.Mutable)
                    _mutator[entry] = this[entry].getMutator();
                else
                    _mutator[entry] = this[entry];
            }
        }
    }
    FudgeCore.MutableArray = MutableArray;
})(FudgeCore || (FudgeCore = {}));
var FBX;
(function (FBX) {
    /**
     * Reader to read data from an array buffer more conveniently.
     * It saves a current offset which is updated when data is read due to its bytelength.
     * despite getSequence it is mostly a copy of the reference: https://github.com/picode7/binary-reader
     * @author Matthias Roming, HFU, 2023
     */
    class BufferReader {
        constructor(_buffer) {
            this.view = new DataView(_buffer);
            this.offset = 0;
        }
        getChar(_offset = this.offset) {
            return String.fromCharCode(this.getUint8(_offset));
        }
        getBool(_offset = this.offset) {
            return this.getUint8(_offset) != 0;
        }
        getUint8(_offset = this.offset) {
            this.offset = _offset + 1;
            return this.view.getUint8(_offset);
        }
        getUint32(_offset = this.offset) {
            this.offset = _offset + 4;
            return this.view.getUint32(_offset, true);
        }
        getUint64(_offset = this.offset) {
            this.offset = _offset + 8;
            return this.view.getBigUint64(_offset, true);
        }
        getInt16(_offset = this.offset) {
            this.offset = _offset + 2;
            return this.view.getInt16(_offset, true);
        }
        getInt32(_offset = this.offset) {
            this.offset = _offset + 4;
            return this.view.getInt32(_offset, true);
        }
        getInt64(_offset = this.offset) {
            this.offset = _offset + 8;
            return this.view.getBigInt64(_offset, true);
        }
        getFloat32(_offset = this.offset) {
            this.offset = _offset + 4;
            return this.view.getFloat32(_offset, true);
        }
        getFloat64(_offset = this.offset) {
            this.offset = _offset + 8;
            return this.view.getFloat64(_offset, true);
        }
        getString(_length, _offset = this.offset) {
            return String.fromCharCode(...this.getSequence(this.getUint8, _length, _offset));
        }
        *getSequence(_getter, _length, _offset = this.offset) {
            this.offset = _offset;
            for (let i = 0; i < _length; i++) {
                yield _getter.call(this);
            }
        }
    }
    FBX.BufferReader = BufferReader;
})(FBX || (FBX = {}));
var FBX;
(function (FBX) {
    let MAPPING_INFORMATION_TYPE;
    (function (MAPPING_INFORMATION_TYPE) {
        MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["BY_VERTEX"] = 0] = "BY_VERTEX";
        MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["BY_POLYGON"] = 1] = "BY_POLYGON";
        MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["BY_POLYGON_VERTEX"] = 2] = "BY_POLYGON_VERTEX";
        MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["BY_EDGE"] = 3] = "BY_EDGE";
        MAPPING_INFORMATION_TYPE[MAPPING_INFORMATION_TYPE["ALL_SAME"] = 4] = "ALL_SAME";
    })(MAPPING_INFORMATION_TYPE = FBX.MAPPING_INFORMATION_TYPE || (FBX.MAPPING_INFORMATION_TYPE = {}));
    let REFERENCE_INFORMATION_TYPE;
    (function (REFERENCE_INFORMATION_TYPE) {
        REFERENCE_INFORMATION_TYPE[REFERENCE_INFORMATION_TYPE["DIRECT"] = 0] = "DIRECT";
        REFERENCE_INFORMATION_TYPE[REFERENCE_INFORMATION_TYPE["INDEX_TO_DIRECT"] = 1] = "INDEX_TO_DIRECT";
    })(REFERENCE_INFORMATION_TYPE = FBX.REFERENCE_INFORMATION_TYPE || (FBX.REFERENCE_INFORMATION_TYPE = {}));
})(FBX || (FBX = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Asset loader for Filmbox files.
     * @author Matthias Roming, HFU, 2023
     */
    class FBXLoader {
        static #defaultMaterial;
        static #defaultSkinMaterial;
        #scenes;
        #nodes;
        #meshes;
        #materials;
        #skinMaterials = [];
        #textures;
        #skeletons;
        #animations;
        constructor(_buffer, _uri) {
            this.uri = _uri;
            this.nodes = FBX.parseNodesFromBinary(_buffer);
            FudgeCore.Debug.log(this.nodes);
            this.fbx = FBX.loadFromNodes(this.nodes);
            FudgeCore.Debug.log(this.fbx);
        }
        static get defaultMaterial() {
            return this.#defaultMaterial || (this.#defaultMaterial =
                new FudgeCore.Material("FBXDefaultMaterial", FudgeCore.ShaderGouraud, new FudgeCore.CoatRemissive(FudgeCore.Color.CSS("white"))));
        }
        static get defaultSkinMaterial() {
            return this.#defaultSkinMaterial || (this.#defaultSkinMaterial =
                new FudgeCore.Material("FBXDefaultSkinMaterial", FudgeCore.ShaderGouraudSkin, new FudgeCore.CoatRemissive(FudgeCore.Color.CSS("white"))));
        }
        static async LOAD(_uri) {
            if (!this.loaders)
                this.loaders = {};
            if (!this.loaders[_uri]) {
                const response = await fetch(_uri);
                const binary = await response.arrayBuffer();
                this.loaders[_uri] = new FBXLoader(binary, _uri);
            }
            return this.loaders[_uri];
        }
        async getScene(_index = 0) {
            if (!this.#scenes)
                this.#scenes = [];
            if (!this.#scenes[_index]) {
                const documentFBX = this.fbx.documents[_index].load();
                const scene = new FudgeCore.Graph(documentFBX.name);
                for (const childFBX of documentFBX.children) {
                    if (childFBX.type == "Model") {
                        scene.addChild(await this.getNode(this.fbx.objects.models.indexOf(childFBX)));
                    }
                }
                if (this.fbx.objects.animStacks && this.fbx.objects.animStacks.length > 0) {
                    const animation = await this.getAnimation(documentFBX.ActiveAnimStackName.length > 0 ?
                        this.fbx.objects.animStacks.findIndex(_animStack => _animStack.name == documentFBX.ActiveAnimStackName) : 0);
                    if (animation)
                        scene.addComponent(new FudgeCore.ComponentAnimation(animation));
                }
                for (const skeleton of this.#skeletons)
                    scene.addComponent(skeleton);
                FudgeCore.Project.register(scene);
                this.#scenes[_index] = scene;
            }
            return this.#scenes[_index];
        }
        async getNode(_index) {
            if (!this.#nodes)
                this.#nodes = [];
            if (!this.#nodes[_index]) {
                // create node with transform
                const modelFBX = this.fbx.objects.models[_index].load();
                const node = new FudgeCore.Node(modelFBX.name);
                await this.generateTransform(modelFBX, node);
                this.#nodes[_index] = node;
                // attach children and components
                if (modelFBX.children)
                    for (const childFBX of modelFBX.children) {
                        if (childFBX.type == "Model") {
                            node.addChild(await this.getNode(this.fbx.objects.models.indexOf(childFBX)));
                        }
                        else if (childFBX.type == "Geometry") {
                            const mesh = await this.getMesh(this.fbx.objects.geometries.indexOf(childFBX));
                            const cmpMesh = new FudgeCore.ComponentMesh(mesh);
                            node.addComponent(new FudgeCore.ComponentMaterial(FBXLoader.defaultMaterial));
                            if (mesh.renderMesh.bones) {
                                cmpMesh.skeleton = await this.getSkeleton(childFBX.children[0].children[0].children[0]);
                                // for (const subDeformerFBX of childFBX.children[0].children as FBX.SubDeformer[]) {
                                //   const bone: Node = cmpMesh.skeleton.bones[subDeformerFBX.children[0].name];
                                //   bone.mtxLocal.set(subDeformerFBX.TransformLink);
                                //   if (bone.getParent())
                                //     bone.mtxLocal.multiply(bone.getParent().mtxWorldInverse);
                                // }
                                node.getComponent(FudgeCore.ComponentMaterial).material = FBXLoader.defaultSkinMaterial;
                            }
                            node.addComponent(cmpMesh);
                        }
                        else if (childFBX.type == "Material") {
                            // TODO: additional skin materials get created here, check if the original material is still needed
                            const iMaterial = this.fbx.objects.materials.indexOf(childFBX);
                            const material = await this.getMaterial(iMaterial);
                            node.getComponent(FudgeCore.ComponentMaterial).material = node.getComponent(FudgeCore.ComponentMesh).mesh.renderMesh.bones ?
                                this.#skinMaterials[iMaterial] || (this.#skinMaterials[iMaterial] = new FudgeCore.Material(material.name, material.getShader() == FudgeCore.ShaderPhong ?
                                    FudgeCore.ShaderPhongSkin :
                                    FudgeCore.ShaderPhongTexturedSkin, material.coat)) :
                                material;
                        }
                    }
            }
            return this.#nodes[_index];
        }
        async getMesh(_index) {
            if (!this.#meshes)
                this.#meshes = [];
            if (!this.#meshes[_index])
                this.#meshes[_index] = await new FudgeCore.MeshFBX().load(this.uri, _index);
            return this.#meshes[_index];
        }
        async getMaterial(_index) {
            if (!this.#materials)
                this.#materials = [];
            if (!this.#materials[_index]) {
                const materialFBX = this.fbx.objects.materials[_index].load();
                if (!(materialFBX.DiffuseColor instanceof FudgeCore.Vector3))
                    materialFBX.DiffuseColor?.children[0].load();
                // FBX supports lambert and phong shading, either way fudge has no lambert shader so we always use phong.
                // In DiffuseColor the texture of the material color is stored, if it's defined we use a texture shader.
                // TODO: materialFBX also contains additional values like shininess and reflectivity (and others) which are not suppported.
                this.#materials[_index] = new FudgeCore.Material(materialFBX.name, materialFBX.DiffuseColor && !(materialFBX.DiffuseColor instanceof FudgeCore.Vector3) ?
                    FudgeCore.ShaderPhongTextured :
                    FudgeCore.ShaderPhong, materialFBX.DiffuseColor && !(materialFBX.DiffuseColor instanceof FudgeCore.Vector3) ?
                    new FudgeCore.CoatRemissiveTextured(new FudgeCore.Color(...materialFBX.Diffuse.get()), await this.getTexture(this.fbx.objects.textures.indexOf(materialFBX.DiffuseColor)), materialFBX.DiffuseFactor ?? 1, materialFBX.SpecularFactor ?? average(materialFBX.Specular?.get()) ?? 0) :
                    new FudgeCore.CoatRemissive(new FudgeCore.Color(...(materialFBX.DiffuseColor ?? materialFBX.Diffuse).get()), materialFBX.DiffuseFactor ?? 1, materialFBX.SpecularFactor ?? average(materialFBX.Specular?.get()) ?? 0));
            }
            return this.#materials[_index];
            function average(_array) {
                if (_array)
                    return _array.reduce((_a, _b) => _a + _b) / _array.length;
                else
                    return undefined;
            }
        }
        async getTexture(_index) {
            return new Promise((_resolve, _reject) => {
                if (!this.#textures)
                    this.#textures = [];
                if (this.#textures[_index])
                    return _resolve(this.#textures[_index]);
                const videoFBX = this.fbx.objects.textures[_index].children[0];
                const texture = new FudgeCore.TextureImage();
                texture.image = new Image();
                texture.image.onload = () => _resolve(texture);
                texture.image.onerror = _reject;
                texture.image.src = URL.createObjectURL(new Blob([videoFBX.Content], { type: "image/png" }));
                this.#textures[_index] = texture;
                // TODO: get and set mipmap information ???
            });
        }
        // Problem: mehrere Deformer verweisen auf das selbe Skelett aber nutzen dabei nicht immer alle Knochen
        // => Problem besteht auch im GLTFLoader
        /**
         * Retriefs the skeleton containing the given limb node.
         */
        async getSkeleton(_fbxLimbNode) {
            if (!this.#skeletons)
                this.#skeletons = [];
            return this.#skeletons.find(_skeleton => _fbxLimbNode.name in _skeleton.bones) || await (async () => {
                const skeleton = new FudgeCore.ComponentSkeleton(); // new Skeleton(`Skeleton${this.#skeletons.length}`);
                let rootNode = _fbxLimbNode;
                while (rootNode.parents && rootNode.parents.some(_parent => _parent.subtype == "LimbNode"))
                    rootNode = rootNode.parents.find(_parent => _parent.subtype == "LimbNode");
                const iRootNode = this.fbx.objects.models.findIndex(_model => _model.name == rootNode.name);
                for (const node of await this.getNode(iRootNode)) {
                    // TODO: maybe move this into the component, as this is probably needed in gltf import aswell
                    if (this.fbx.objects.models[this.#nodes.indexOf(node)].subtype == "LimbNode") {
                        const parent = node.getParent();
                        if (parent)
                            node.mtxWorld.copy(node.cmpTransform ?
                                FudgeCore.Matrix4x4.PRODUCT(parent.mtxWorld, node.mtxLocal) :
                                parent.mtxWorld);
                        node.mtxWorldInverse.copy(FudgeCore.Matrix4x4.INVERSE(node.mtxWorld));
                        skeleton.addBone(node);
                    }
                }
                this.#skeletons.push(skeleton);
                return skeleton;
            })();
        }
        async getAnimation(_index) {
            if (!this.#animations)
                this.#animations = [];
            if (!this.#animations[_index]) {
                const animStack = this.fbx.objects.animStacks[_index];
                const animNodesFBX = animStack.children[0].children;
                let fbxAnimNodeGrouped = new Map();
                for (const fbxAnimNode of animNodesFBX) {
                    const key = fbxAnimNode.parents.find(_parent => _parent.type == "Model");
                    if (key == undefined)
                        continue;
                    if (!fbxAnimNodeGrouped.has(key))
                        fbxAnimNodeGrouped.set(key, []);
                    fbxAnimNodeGrouped.get(key).push(fbxAnimNode);
                }
                const animationStructure = {};
                for (const [fbxModel, fbxAnimNodes] of fbxAnimNodeGrouped) {
                    let currentStructure = animationStructure;
                    let parent = fbxModel.parents.find(_parent => _parent.type == "Model");
                    let path = [];
                    path.push(fbxModel);
                    while (parent != undefined) {
                        path.push(parent);
                        parent = parent.parents.find(_parent => _parent.type == "Model");
                    }
                    for (const fbxPathModel of path.reverse()) {
                        if (currentStructure.children == undefined)
                            currentStructure.children = {};
                        if (currentStructure.children[fbxPathModel.name] == undefined)
                            currentStructure.children[fbxPathModel.name] = {};
                        currentStructure = currentStructure.children[fbxPathModel.name];
                        if (fbxPathModel == fbxModel) {
                            const mtxLocal = {};
                            for (const fbxAnimNode of fbxAnimNodes)
                                mtxLocal[{
                                    T: "translation",
                                    R: "rotation",
                                    S: "scale"
                                }[fbxAnimNode.name]] = this.getAnimationVector3(fbxAnimNode, fbxPathModel);
                            currentStructure.components = {
                                ComponentTransform: [
                                    { mtxLocal: mtxLocal }
                                ]
                            };
                        }
                    }
                }
                this.#animations[_index] = new FudgeCore.Animation(animStack.name, animationStructure);
            }
            return this.#animations[_index];
        }
        /**
         * fetched from three.js, adapted to FUDGE and optimized
         * https://github.com/mrdoob/three.js/blob/dev/examples/jsm/loaders/FBXLoader.js
         * line 3950
         */
        async generateTransform(_modelFBX, _node) {
            const parentIndex = this.fbx.objects.models.indexOf(_modelFBX.parents.find(_parent => _parent.type == "Model"));
            const parent = parentIndex >= 0 ? await this.getNode(parentIndex) : undefined;
            const mtxLocalRotation = _modelFBX.PreRotation || _modelFBX.LclRotation || _modelFBX.PostRotation ?
                FudgeCore.Matrix4x4.IDENTITY() :
                undefined;
            if (_modelFBX.PreRotation) {
                mtxLocalRotation.rotate(this.getOrdered(_modelFBX.PreRotation, _modelFBX));
            }
            if (_modelFBX.LclRotation) {
                mtxLocalRotation.rotate(this.getOrdered(this.getTransformVector(_modelFBX.LclRotation, FudgeCore.Vector3.ZERO), _modelFBX));
            }
            if (_modelFBX.PostRotation) {
                let mtxPostRotationInverse = FudgeCore.Matrix4x4.ROTATION(this.getOrdered(_modelFBX.PostRotation, _modelFBX));
                mtxPostRotationInverse = FudgeCore.Matrix4x4.INVERSE(mtxPostRotationInverse);
                mtxLocalRotation.multiply(mtxPostRotationInverse);
            }
            const mtxLocalScaling = _modelFBX.LclScaling ?
                FudgeCore.Matrix4x4.SCALING(this.getTransformVector(_modelFBX.LclScaling, FudgeCore.Vector3.ONE)) :
                undefined;
            const mtxParentWorldRotation = parent ? FudgeCore.Matrix4x4.ROTATION(parent.mtxWorld.rotation) : undefined;
            const mtxParentWorldScale = parent ? (() => {
                const mtxParentWorldScale = FudgeCore.Matrix4x4.INVERSE(mtxParentWorldRotation);
                mtxParentWorldScale.translate(FudgeCore.Vector3.SCALE(parent.mtxWorld.translation, -1));
                mtxParentWorldScale.multiply(parent.mtxWorld);
                return mtxParentWorldScale;
            })() : undefined;
            const mtxWorldRotationScale = parent || mtxLocalRotation || mtxLocalScaling ? FudgeCore.Matrix4x4.IDENTITY() : undefined;
            if (parent || mtxLocalRotation || mtxLocalScaling) {
                const inheritType = _modelFBX.InheritType || 0;
                if (inheritType == 0) {
                    if (parent)
                        mtxWorldRotationScale.multiply(mtxParentWorldRotation);
                    if (mtxLocalRotation)
                        mtxWorldRotationScale.multiply(mtxLocalRotation);
                    if (parent)
                        mtxWorldRotationScale.multiply(mtxParentWorldScale);
                    if (mtxLocalScaling)
                        mtxWorldRotationScale.multiply(mtxLocalScaling);
                }
                else if (inheritType == 1) {
                    if (parent) {
                        mtxWorldRotationScale.multiply(mtxParentWorldRotation);
                        mtxWorldRotationScale.multiply(mtxParentWorldScale);
                    }
                    if (mtxLocalRotation)
                        mtxWorldRotationScale.multiply(mtxLocalRotation);
                    if (mtxLocalScaling)
                        mtxWorldRotationScale.multiply(mtxLocalScaling);
                }
                else {
                    if (parent)
                        mtxWorldRotationScale.multiply(mtxParentWorldRotation);
                    if (mtxLocalRotation)
                        mtxWorldRotationScale.multiply(mtxLocalRotation);
                    if (parent) {
                        mtxWorldRotationScale.multiply(mtxParentWorldScale);
                        let mtxParentLocalScalingInverse = FudgeCore.Matrix4x4.SCALING(parent.mtxLocal.scaling);
                        mtxParentLocalScalingInverse = FudgeCore.Matrix4x4.INVERSE(mtxParentLocalScalingInverse);
                        mtxWorldRotationScale.multiply(mtxParentLocalScalingInverse);
                    }
                    if (mtxLocalScaling)
                        mtxWorldRotationScale.multiply(mtxLocalScaling);
                }
            }
            // Calculate the local transform matrix
            let translation;
            translation = FudgeCore.Vector3.ZERO();
            if (_modelFBX.LclTranslation)
                translation.add(this.getTransformVector(_modelFBX.LclTranslation, FudgeCore.Vector3.ZERO));
            if (_modelFBX.RotationOffset)
                translation.add(_modelFBX.RotationOffset);
            if (_modelFBX.RotationPivot)
                translation.add(_modelFBX.RotationPivot);
            const mtxTransform = FudgeCore.Matrix4x4.TRANSLATION(translation);
            if (mtxLocalRotation)
                mtxTransform.multiply(mtxLocalRotation);
            translation = FudgeCore.Vector3.ZERO();
            if (_modelFBX.RotationPivot)
                translation.subtract(_modelFBX.RotationPivot);
            if (_modelFBX.ScalingOffset)
                translation.add(_modelFBX.ScalingOffset);
            if (_modelFBX.ScalingPivot)
                translation.add(_modelFBX.ScalingPivot);
            mtxTransform.translate(translation);
            if (mtxLocalScaling)
                mtxTransform.multiply(mtxLocalScaling);
            if (_modelFBX.ScalingPivot)
                mtxTransform.translate(FudgeCore.Vector3.SCALE(_modelFBX.ScalingPivot, -1));
            const mtxWorldTranslation = parent ?
                FudgeCore.Matrix4x4.TRANSLATION(FudgeCore.Matrix4x4.PRODUCT(parent.mtxWorld, FudgeCore.Matrix4x4.TRANSLATION(mtxTransform.translation)).translation) :
                FudgeCore.Matrix4x4.TRANSLATION(mtxTransform.translation);
            mtxTransform.copy(mtxWorldTranslation);
            mtxTransform.multiply(mtxWorldRotationScale);
            _node.mtxWorld.copy(mtxTransform);
            if (parent)
                mtxTransform.multiply(FudgeCore.Matrix4x4.INVERSE(parent.mtxWorld), true);
            _node.addComponent(new FudgeCore.ComponentTransform(mtxTransform));
        }
        getTransformVector(_vector, _default) {
            return (_vector == undefined ?
                _default() :
                _vector instanceof FudgeCore.Vector3 ?
                    _vector :
                    new FudgeCore.Vector3(typeof (_vector = _vector.load()).dX == "number" ?
                        _vector.dX :
                        _vector.dX.load().Default, typeof _vector.dY == "number" ?
                        _vector.dY :
                        _vector.dY.load().Default, typeof _vector.dZ == "number" ?
                        _vector.dZ :
                        _vector.dZ.load().Default));
        }
        getAnimationVector3(_animNode, _target) {
            const vectorSequence = {};
            for (const valueName in _animNode)
                if (valueName == "dX" || valueName == "dY" || valueName == "dZ") {
                    const value = _animNode[valueName];
                    if (typeof value != "number") {
                        const sequence = new FudgeCore.AnimationSequence([], Number);
                        for (let i = 0; i < value.KeyTime.length; ++i) {
                            // According to the reference time is defined as a signed int64, unit being 1/46186158000 seconds
                            // ref: https://archive.blender.org/wiki/index.php/User:Mont29/Foundation/FBX_File_Structure/#Some_Specific_Property_Types
                            sequence.addKey(new FudgeCore.AnimationKey(Number((value.KeyTime[i] - value.KeyTime.reduce((_min, _v) => _v < _min ? _v : _min)) / BigInt("46186158")), value.KeyValueFloat[i]));
                        }
                        vectorSequence[valueName[1].toLowerCase()] = sequence;
                    }
                }
            if (_animNode.name == "R" && (_target.PreRotation || _target.PostRotation)) {
                let preRototation;
                if (_target.PreRotation)
                    preRototation = FudgeCore.Matrix4x4.ROTATION(_target.PreRotation);
                let postRotation;
                if (_target.PostRotation)
                    postRotation = FudgeCore.Matrix4x4.ROTATION(_target.PostRotation);
                [vectorSequence.x, vectorSequence.y, vectorSequence.z]
                    .flatMap(_seq => _seq?.getKeys())
                    .map(_key => _key?.time)
                    .sort((_timeA, _timeB) => _timeA - _timeB) // sort times
                    .filter((_time, _index, _times) => _time != _times[_index + 1]) // remove duplicates
                    .map(_time => {
                    return { x: findKey(vectorSequence.x), y: findKey(vectorSequence.y), z: findKey(vectorSequence.z) };
                    function findKey(_sequence) {
                        return _sequence?.getKeys().find(_key => _key.time == _time);
                    }
                })
                    .forEach(_frame => {
                    let vctEulerAngles = FudgeCore.Recycler.get(FudgeCore.Vector3);
                    vctEulerAngles.set(_frame.x?.value ?? 0, _frame.y?.value ?? 0, _frame.z?.value ?? 0);
                    const mtxRotation = FudgeCore.Matrix4x4.ROTATION(vctEulerAngles);
                    if (preRototation)
                        mtxRotation.multiply(preRototation, true);
                    if (postRotation)
                        mtxRotation.multiply(postRotation);
                    vctEulerAngles = mtxRotation.rotation;
                    if (_frame.x)
                        _frame.x.value = vctEulerAngles.x;
                    if (_frame.y)
                        _frame.y.value = vctEulerAngles.y;
                    if (_frame.z)
                        _frame.z.value = vctEulerAngles.z;
                });
            }
            return vectorSequence;
        }
        getOrdered(_rotation, _modelFBX) {
            if (!_modelFBX.EulerOrder)
                return _rotation;
            const data = _rotation.get();
            const result = FudgeCore.Recycler.get(FudgeCore.Vector3);
            result.set(data[_modelFBX.EulerOrder.indexOf("Z")], data[_modelFBX.EulerOrder.indexOf("Y")], data[_modelFBX.EulerOrder.indexOf("X")]);
            return result;
        }
    }
    FudgeCore.FBXLoader = FBXLoader;
})(FudgeCore || (FudgeCore = {}));
var FBX;
(function (FBX) {
    /**
     * Interface to represent fbx-nodes containing its name, children and properties.
     * Children and properites are lazy.
     * @author Matthias Roming, HFU, 2023
     */
    class Node {
        #children;
        #properties;
        constructor(_name, _loadProperties, _loadChildren) {
            this.name = _name;
            this.loadProperties = _loadProperties;
            this.loadChildren = _loadChildren;
        }
        get properties() {
            return this.#properties || (this.#properties = this.loadProperties());
        }
        get children() {
            return this.#children || (this.#children = this.loadChildren());
        }
    }
    FBX.Node = Node;
    let ARRAY_ENCODING;
    (function (ARRAY_ENCODING) {
        ARRAY_ENCODING[ARRAY_ENCODING["UNCOMPRESSED"] = 0] = "UNCOMPRESSED";
        ARRAY_ENCODING[ARRAY_ENCODING["COMPRESSED"] = 1] = "COMPRESSED";
    })(ARRAY_ENCODING = FBX.ARRAY_ENCODING || (FBX.ARRAY_ENCODING = {}));
})(FBX || (FBX = {}));
var FBX;
(function (FBX) {
    /**
     * Loads an fbx file from its fbx-node array which may be retrieved by parseNodesFromBinary.
     * @author Matthias Roming, HFU, 2023
     */
    function loadFromNodes(_nodes) {
        const fbx = {
            documents: undefined,
            objects: {
                all: undefined,
                models: [],
                geometries: [],
                materials: [],
                poses: [],
                textures: [],
                animStacks: []
            },
            connections: undefined
        };
        for (const node of _nodes) {
            if (node.name == "Documents")
                fbx.documents = node.children
                    .filter(_documentNode => _documentNode.name == "Document")
                    .map(_documentNode => getDocument(_documentNode));
            else if (node.name == "Objects")
                fbx.objects.all = node.children.map(_objectNode => getObject(_objectNode, fbx));
            else if (node.name == "Connections")
                fbx.connections = node.children.map(_connectionNode => getConnection(_connectionNode));
            if (fbx.documents && fbx.objects.all && fbx.connections)
                break;
        }
        groupObjects(fbx);
        applyConnections(fbx.connections, fbx.documents, fbx.objects.all);
        return fbx;
    }
    FBX.loadFromNodes = loadFromNodes;
    function getDocument(_node) {
        const document = {
            uid: _node.properties[0],
            name: _node.properties[2],
            loaded: false,
            load: () => loadObjectProperties(_node, document)
        };
        return document;
    }
    function getObject(_node, _fbx) {
        const nameAndType = _node.properties[1].split("::");
        const object = {
            uid: _node.properties[0],
            name: nameAndType[0],
            type: nameAndType[1],
            subtype: _node.properties[2],
            loaded: false,
            load: () => loadObjectProperties(_node, object)
        };
        return object;
    }
    function groupObjects(_fbx) {
        for (const object of _fbx.objects.all) {
            if (object.type == "Model")
                _fbx.objects.models.push(object);
            else if (object.type == "Geometry")
                _fbx.objects.geometries.push(object);
            else if (object.type == "Material")
                _fbx.objects.materials.push(object);
            else if (object.type == "Pose")
                _fbx.objects.poses.push(object);
            else if (object.type == "Texture")
                _fbx.objects.textures.push(object);
            else if (object.type == "AnimStack")
                _fbx.objects.animStacks.push(object);
        }
    }
    function getConnection(_node) {
        if (!(_node.properties[0] == "OO" || _node.properties[0] == "OP")) {
            console.warn(`Connection type ${_node.properties[0]} is not supported`);
            return null;
        }
        return {
            childUID: _node.properties[1],
            parentUID: _node.properties[2],
            propertyName: _node.properties[0] == "OP" ? _node.properties[3] : null
        };
    }
    function applyConnections(_connections, _documents, _objects) {
        for (const connection of _connections) {
            let parent = _documents.find(_document => _document.load().RootNode == connection.parentUID);
            let child;
            for (const object of _objects) {
                if (parent == undefined && object.uid == connection.parentUID)
                    parent = object;
                if (child == undefined && object.uid == connection.childUID)
                    child = object;
                if (parent != undefined && child != undefined)
                    break;
            }
            if (child)
                (child.parents || (child.parents = [])).push(parent);
            if (connection.propertyName == null)
                (parent.children || (parent.children = [])).push(child);
            else
                parent[formatPropertyName(connection.propertyName)] = child;
        }
    }
    function loadObjectProperties(_node, _object) {
        if (_object.loaded)
            return _object;
        for (const child of _node.children) {
            if (child.name == "Properties70")
                for (const property70 of child.children) {
                    const name = formatPropertyName(property70.properties[0]);
                    if (!_object[name])
                        _object[name] = getProperty70Value(property70);
                }
            else {
                const name = formatPropertyName(child.name);
                if (!_object[name])
                    _object[name] = getPropertyValue(child);
            }
        }
        _object.loaded = true;
        return _object;
    }
    function getPropertyValue(_node) {
        return _node.children.length > 0
            ? _node.children.reduce((_subProperties, _subProperty) => {
                const name = formatPropertyName(_subProperty.name);
                if (_subProperties[name] == undefined)
                    _subProperties[name] = getPropertyValue(_subProperty);
                else {
                    if (!(_subProperties[name] instanceof Array))
                        _subProperties[name] = [_subProperties[name]];
                    _subProperties[name].push(getPropertyValue(_subProperty));
                }
                return _subProperties;
            }, {})
            : _node.properties[0];
    }
    function getProperty70Value(_node) {
        switch (_node.properties[1]) {
            case "bool":
                return _node.properties[4];
            case "int":
            case "enum":
            case "ULongLong":
            case "double":
            case "Number":
            case "FieldOfView":
                return _node.properties[4];
            case "Color":
            case "ColorRGB":
            case "Vector3D":
            case "Lcl Translation":
            case "Lcl Rotation":
            case "Lcl Scaling":
                return new FudgeCore.Vector3(..._node.properties.slice(4, 7));
            case "KString":
            default:
                return _node.properties[4];
        }
    }
    function formatPropertyName(_name) {
        return _name.replace(/[^a-zA-Z]/, "");
    }
})(FBX || (FBX = {}));
var FBX;
(function (FBX) {
    /**
     * Parses fbx-nodes array from a binary fbx-file.
     * despite the lazy node implementation it is mostly a copy of the reference: https://github.com/picode7/fbx-parser
     * @author Matthias Roming, HFU, 2023
     */
    function parseNodesFromBinary(_buffer) {
        if (_buffer.byteLength < binaryStartChars.length)
            throw "Not a binary FBX file";
        const data = new FBX.BufferReader(_buffer);
        const firstChars = new Uint8Array(data.getSequence(data.getUint8, binaryStartChars.length));
        const matchesFBXBinaryFirstChars = firstChars.every((_value, _index) => _value == binaryStartChars[_index]);
        if (!matchesFBXBinaryFirstChars)
            throw "Not a binary FBX file";
        const version = data.getUint32();
        const nodeAttributesAsUInt64 = version >= 7500; // Warum >= 7500?
        const nodes = [];
        while (true) {
            const node = readNode(data, nodeAttributesAsUInt64);
            if (node == null)
                break;
            nodes.push(node);
        }
        return nodes;
    }
    FBX.parseNodesFromBinary = parseNodesFromBinary;
    function readNode(_data, _attributesAsUint64) {
        const endOffset = _attributesAsUint64 ? Number(_data.getUint64()) : _data.getUint32();
        if (endOffset == 0)
            return null;
        const propertiesLength = _attributesAsUint64 ? Number(_data.getUint64()) : _data.getUint32();
        const propertiesByteLength = _attributesAsUint64 ? Number(_data.getUint64()) : _data.getUint32();
        const nameLength = _data.getUint8();
        const name = _data.getString(nameLength);
        const propertiesOffset = _data.offset;
        const childrenOffset = propertiesOffset + propertiesByteLength;
        const node = new FBX.Node(name, () => {
            _data.offset = propertiesOffset;
            const properties = [];
            for (let iProperty = 0; iProperty < propertiesLength; iProperty++) {
                properties.push(readProperty(_data));
            }
            return properties;
        }, () => {
            _data.offset = childrenOffset;
            const children = [];
            while (endOffset - _data.offset > nullCountAtNodeEnd) {
                const child = readNode(_data, _attributesAsUint64);
                if (child)
                    children.push(child);
            }
            return children;
        });
        _data.offset = endOffset;
        return node;
    }
    function readProperty(_data) {
        const typeCode = _data.getChar();
        const value = {
            C: _data.getBool,
            Y: _data.getInt16,
            I: _data.getInt32,
            L: _data.getInt64,
            F: _data.getFloat32,
            D: _data.getFloat64,
            S: () => _data.getString(_data.getUint32()).replace("\x00\x01", "::"),
            s: () => _data.getString(_data.getUint32()).replace("\x00\x01", "::"),
            R: () => new Uint8Array(readRaw(_data, _data.getUint8)),
            r: () => new Uint8Array(readArray(_data, _data.getUint8)),
            b: () => new Uint8Array(readArray(_data, _data.getUint8)),
            i: () => new Int32Array(readArray(_data, _data.getInt32)),
            l: () => new BigInt64Array(readArray(_data, _data.getInt64)),
            f: () => new Float32Array(readArray(_data, _data.getFloat32)),
            d: () => new Float32Array(readArray(_data, _data.getFloat64))
        }[typeCode]?.call(_data);
        if (value == null)
            FudgeCore.Debug.warn(`Unknown property type ${typeCode.charCodeAt(0)}`);
        return value;
    }
    function readArray(_data, _getter) {
        const length = _data.getUint32();
        const encoding = _data.getUint32();
        const byteLength = _data.getUint32();
        const endOffset = _data.offset + byteLength;
        const iterable = encoding == FBX.ARRAY_ENCODING.COMPRESSED ?
            (() => {
                const arrayData = new Uint8Array(_data.view.buffer, _data.offset, byteLength);
                const inflatedData = (Reflect.get(globalThis, "pako") ? pako.inflate : fflate.inflateSync)(arrayData);
                return new FBX.BufferReader(inflatedData.buffer).getSequence(_getter, length);
            })() :
            _data.getSequence(_getter, length);
        _data.offset = endOffset;
        return iterable;
    }
    function readRaw(_data, _getter) {
        // raw binary data needs to be interpreted in a special way see:
        // https://code.blender.org/2013/08/fbx-binary-file-format-specification/
        const length = _data.getUint32();
        return _data.getSequence(_getter, length);
        ;
    }
    const binaryStartChars = Uint8Array.from("Kaydara FBX Binary\x20\x20\x00\x1a\x00".split(""), _v => _v.charCodeAt(0));
    const nullCountAtNodeEnd = 13;
})(FBX || (FBX = {}));
var GLTF;
(function (GLTF) {
    /**
     * https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#accessor-data-types
     */
    let COMPONENT_TYPE;
    (function (COMPONENT_TYPE) {
        COMPONENT_TYPE[COMPONENT_TYPE["BYTE"] = 5120] = "BYTE";
        COMPONENT_TYPE[COMPONENT_TYPE["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
        COMPONENT_TYPE[COMPONENT_TYPE["SHORT"] = 5122] = "SHORT";
        COMPONENT_TYPE[COMPONENT_TYPE["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
        COMPONENT_TYPE[COMPONENT_TYPE["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
        COMPONENT_TYPE[COMPONENT_TYPE["FLOAT"] = 5126] = "FLOAT";
    })(COMPONENT_TYPE = GLTF.COMPONENT_TYPE || (GLTF.COMPONENT_TYPE = {}));
    let ACCESSOR_TYPE;
    (function (ACCESSOR_TYPE) {
        ACCESSOR_TYPE["SCALAR"] = "SCALAR";
        ACCESSOR_TYPE["VEC2"] = "VEC2";
        ACCESSOR_TYPE["VEC3"] = "VEC3";
        ACCESSOR_TYPE["VEC4"] = "VEC4";
        ACCESSOR_TYPE["MAT2"] = "MAT2";
        ACCESSOR_TYPE["MAT3"] = "MAT3";
        ACCESSOR_TYPE["MAT4"] = "MAT4";
    })(ACCESSOR_TYPE = GLTF.ACCESSOR_TYPE || (GLTF.ACCESSOR_TYPE = {}));
    let MESH_PRIMITIVE_MODE;
    (function (MESH_PRIMITIVE_MODE) {
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["POINTS"] = 0] = "POINTS";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["LINES"] = 1] = "LINES";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["LINE_LOOP"] = 2] = "LINE_LOOP";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["LINE_STRIP"] = 3] = "LINE_STRIP";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["TRIANGLES"] = 4] = "TRIANGLES";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
        MESH_PRIMITIVE_MODE[MESH_PRIMITIVE_MODE["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    })(MESH_PRIMITIVE_MODE = GLTF.MESH_PRIMITIVE_MODE || (GLTF.MESH_PRIMITIVE_MODE = {}));
})(GLTF || (GLTF = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Asset loader for gl Transfer Format files.
     * @authors Matthias Roming, HFU, 2022 | Jonas Plotzky, HFU, 2023-2025
     */
    class GLTFLoader {
        static #defaultMaterial;
        static #defaultSkinMaterial;
        #url;
        #gltf;
        #resources = {};
        #buffers;
        constructor(_gltf, _url, _bufferChunk) {
            this.#gltf = _gltf;
            this.#url = _url;
            if (_bufferChunk)
                this.#buffers = [_bufferChunk];
        }
        static get defaultMaterial() {
            if (!this.#defaultMaterial) {
                this.#defaultMaterial = new FudgeCore.Material("GLTFDefaultMaterial", FudgeCore.ShaderPhong, new FudgeCore.CoatRemissive(FudgeCore.Color.CSS("white"), 1, 0.5));
                FudgeCore.Project.deregister(this.#defaultMaterial);
            }
            return this.#defaultMaterial;
        }
        static get defaultSkinMaterial() {
            if (!this.#defaultSkinMaterial) {
                this.#defaultSkinMaterial = new FudgeCore.Material("GLTFDefaultSkinMaterial", FudgeCore.ShaderPhongSkin, new FudgeCore.CoatRemissive(FudgeCore.Color.CSS("white"), 1, 0.5));
                FudgeCore.Project.deregister(this.#defaultSkinMaterial);
            }
            return this.#defaultSkinMaterial;
        }
        /**
         * Handles the loading of an external resource from a glTF file. Used by the {@link SerializableResourceExternal}GLTF specializations to load themselves.
         * @internal
         */
        static async loadResource(_resource, _url) {
            const loader = await GLTFLoader.LOAD((_resource.url ?? _url).toString());
            if (!loader) {
                if (!(_resource instanceof FudgeCore.GraphInstance))
                    _resource.status = FudgeCore.RESOURCE_STATUS.ERROR;
                return _resource;
            }
            let loaded;
            if (_resource instanceof FudgeCore.GraphInstance)
                loaded = await loader.getGraph(_resource.get().name, _resource);
            else if (_resource instanceof FudgeCore.GraphGLTF)
                loaded = await loader.getGraph(_resource.name, _resource);
            else if (_resource instanceof FudgeCore.MeshGLTF)
                loaded = await loader.getMesh(_resource.name, _resource.iPrimitive, _resource);
            else if (_resource instanceof FudgeCore.MaterialGLTF)
                loaded = await loader.getMaterial(_resource.name, _resource);
            else if (_resource instanceof FudgeCore.AnimationGLTF)
                loaded = await loader.getAnimation(_resource.name, _resource);
            if (!loaded) {
                FudgeCore.Debug.error(`${_resource.constructor.name} | ${_resource instanceof FudgeCore.GraphInstance ? _resource.idSource : _resource.idResource}: Failed to load resource.`);
                if (!(_resource instanceof FudgeCore.GraphInstance))
                    _resource.status = FudgeCore.RESOURCE_STATUS.ERROR;
                return _resource;
            }
            if (!(loaded instanceof FudgeCore.GraphInstance)) {
                loaded.status = FudgeCore.RESOURCE_STATUS.READY;
            }
            // if (cached && !(_resource instanceof GraphInstance)) {
            //   if (!Project.resources[cached.idResource])
            //     cached.idResource = _resource.idResource; // change the id of the cached resource to the id of the resource that requested it
            //   if (cached.idResource != _resource.idResource) {
            //     // two different resources have requested the same cached resource
            //     Debug.error(`${_resource.idResource}: Failed to load resource. ${_resource.type} with name '${_resource.name}' from '${loader.name}' has already been loaded by '${cached.idResource}'. Please delete the duplicate '${_resource.idResource}' from the project.`);
            //     return _resource;
            //   }
            // }
            return loaded;
        }
        /**
         * Returns a {@link GLTFLoader} instance for the given url or null if the url can't be resolved.
         */
        static async LOAD(_url, _registerResources = false) {
            if (!this.loaders)
                GLTFLoader.loaders = {};
            if (!this.loaders[_url]) {
                let gltf;
                let buffer;
                try {
                    const response = await fetch(new URL(_url, FudgeCore.Project.baseURL));
                    const fileExtension = _url.split('.').pop()?.toLowerCase();
                    if (fileExtension == "gltf")
                        gltf = await response.json();
                    if (fileExtension == "glb") {
                        const arrayBuffer = await response.arrayBuffer();
                        const dataView = new DataView(arrayBuffer);
                        const magic = dataView.getUint32(0, true);
                        if (magic !== 0x46546C67)
                            throw new Error(`${GLTFLoader.name} | ${_url}: Invalid magic number in GLB file.`);
                        const version = dataView.getUint32(4, true);
                        if (version != 2)
                            throw new Error(`${GLTFLoader.name} | ${_url}: Unsupported version in GLB file.`);
                        const jsonLength = dataView.getUint32(12, true);
                        const jsonFormat = dataView.getUint32(16, true);
                        if (jsonFormat !== 0x4E4F534A)
                            throw new Error('Invalid format. The first chunk of the file is not in JSON format.');
                        const decoder = new TextDecoder();
                        const jsonChunk = decoder.decode(new Uint8Array(arrayBuffer, 20, jsonLength));
                        gltf = JSON.parse(jsonChunk);
                        if (arrayBuffer.byteLength >= 20 + jsonLength) {
                            const binaryLength = dataView.getUint32(20 + jsonLength, true);
                            const binaryFormat = dataView.getUint32(24 + jsonLength, true);
                            if (binaryFormat !== 0x004E4942)
                                throw new Error('Invalid format. The second chunk of the file is not in binary format.');
                            buffer = arrayBuffer.slice(28 + jsonLength, 28 + jsonLength + binaryLength);
                        }
                    }
                }
                catch (error) {
                    FudgeCore.Debug.error(`${GLTFLoader.name} | ${_url}: Failed to load file. ${error}`);
                    return null;
                }
                GLTFLoader.checkCompatibility(gltf, _url);
                GLTFLoader.preProcess(gltf, _url);
                GLTFLoader.loaders[_url] = new GLTFLoader(gltf, _url, buffer);
            }
            return GLTFLoader.loaders[_url];
        }
        static checkCompatibility(_gltf, _url) {
            if (_gltf.asset.version != "2.0")
                FudgeCore.Debug.warn(`${GLTFLoader.name} | ${_url}: This loader was developed for glTF 2.0. It may not work as intended with version ${_gltf.asset.version}.`);
            if (_gltf.asset.minVersion != undefined && _gltf.asset.minVersion != "2.0")
                throw new Error(`${GLTFLoader.name} | ${_url}: This loader was developed for glTF 2.0. It does not work with required min version ${_gltf.asset.minVersion}.`);
            if (_gltf.extensionsUsed?.length > 0)
                FudgeCore.Debug.warn(`${GLTFLoader.name} | ${_url}: This loader does not support glTF extensions. It may not work as intended with extensions ${_gltf.extensionsUsed.toString()}.`);
            if (_gltf.extensionsRequired?.length > 0)
                throw new Error(`${GLTFLoader.name} | ${_url}: This loader does not support glTF extensions. It does not work with required extensions ${_gltf.extensionsRequired.toString()}.`);
        }
        static preProcess(_gltf, _url) {
            // add a name to each scene
            if (_gltf.scenes) {
                _gltf.scene = _gltf.scene ?? 0;
                addNames("Scene", _gltf.scenes);
            }
            if (_gltf.nodes) {
                // mark all nodes that are animated
                _gltf.animations?.forEach(_animation => {
                    _animation.channels.forEach(_channel => {
                        const iNode = _channel.target.node;
                        if (iNode != undefined)
                            _gltf.nodes[iNode].isAnimated = true;
                    });
                });
                // mark parent of each node
                _gltf.nodes.forEach((_node, _iNode) => _node.children?.forEach(_iChild => _gltf.nodes[_iChild].parent = _iNode));
                _gltf.nodes.forEach((_node, _iNode) => {
                    // add names to nodes that don't have one
                    if (_node.name == undefined)
                        _node.name = `Node${_iNode}`;
                    if (_node.isAnimated) {
                        // add path to each animated node
                        let iParent = _node.parent;
                        let path = [];
                        path.push(_iNode);
                        while (iParent != undefined) {
                            path.push(iParent);
                            iParent = _gltf.nodes[iParent].parent;
                        }
                        _node.path = path.reverse();
                    }
                });
            }
            if (_gltf.materials)
                addNames("Material", _gltf.materials);
            if (_gltf.meshes)
                addNames("Mesh", _gltf.meshes);
            if (_gltf.animations)
                addNames("Animation", _gltf.animations);
            function addNames(_template, _target) {
                _target.forEach((_item, _index) => {
                    if (_item.name == undefined)
                        _item.name = `${_template}${_index}`;
                });
            }
        }
        /**
         * Returns the glTF file name.
         */
        get name() {
            return this.#url.split("\\").pop();
        }
        /**
         * Returns new instances of all resources of the given type.
         */
        async loadResources(_class) {
            let resources = [];
            switch (_class.name) {
                case FudgeCore.Graph.name:
                    for (let iScene = 0; iScene < this.#gltf.scenes?.length; iScene++)
                        resources.push(await this.getGraph(iScene, new FudgeCore.GraphGLTF()));
                    break;
                case FudgeCore.Mesh.name:
                    for (let iMesh = 0; iMesh < this.#gltf.meshes?.length; iMesh++)
                        for (let iPrimitive = 0; iPrimitive < this.#gltf.meshes[iMesh].primitives.length; iPrimitive++)
                            resources.push(await this.getMesh(iMesh, iPrimitive, new FudgeCore.MeshGLTF()));
                    break;
                case FudgeCore.Material.name:
                    for (let iMaterial = 0; iMaterial < this.#gltf.materials?.length; iMaterial++)
                        resources.push(await this.getMaterial(iMaterial, new FudgeCore.MaterialGLTF("Hi :)")));
                    break;
                case FudgeCore.Animation.name:
                    for (let iAnimation = 0; iAnimation < this.#gltf.animations?.length; iAnimation++)
                        resources.push(await this.getAnimation(iAnimation, new FudgeCore.AnimationGLTF()));
                    break;
            }
            for (const resource of resources) {
                if (!FudgeCore.Project.resources[resource.idResource])
                    FudgeCore.Project.register(resource);
                resource.status = FudgeCore.RESOURCE_STATUS.READY;
            }
            return resources;
        }
        async getGraph(_iScene = this.#gltf.scene, _graphOut) {
            _iScene = this.getIndex(_iScene, this.#gltf.scenes);
            if (_iScene == -1)
                return null;
            const id = `${FudgeCore.GraphGLTF.name}|${_iScene}`;
            if (!_graphOut && this.#resources[id])
                return this.#resources[id];
            let cache = {
                nodes: [],
                skeletons: []
            };
            const gltfScene = this.#gltf.scenes[_iScene];
            const graph = _graphOut ?? new FudgeCore.GraphGLTF();
            graph.name = gltfScene.name;
            if (graph instanceof FudgeCore.GraphGLTF)
                graph.url = this.#url;
            if (_graphOut) {
                _graphOut.removeAllChildren();
                _graphOut.removeComponents(FudgeCore.ComponentSkeleton);
            }
            for (const iNode of gltfScene.nodes)
                graph.addChild(await this.getNodeByIndex(iNode, cache));
            // if (this.#gltf.animations?.length > 0 && !graph.getComponent(ComponentAnimation)) {
            //   let animation: Animation = await this.getAnimation(0);
            //   Project.register(animation);
            //   graph.addComponent(new ComponentAnimation(animation));
            // }
            for (const skeleton of cache.skeletons)
                graph.addComponent(skeleton);
            if (!_graphOut)
                this.#resources[id] = graph;
            return graph;
        }
        async getAnimation(_iAnimation, _animationOut) {
            _iAnimation = this.getIndex(_iAnimation, this.#gltf.animations);
            if (_iAnimation == -1)
                return null;
            const id = `${FudgeCore.Animation.name}|${_iAnimation}`;
            if (!_animationOut && this.#resources[id])
                return this.#resources[id];
            const gltfAnimation = this.#gltf.animations?.[_iAnimation];
            if (!gltfAnimation)
                throw new Error(`${this}: Couldn't find animation with index ${_iAnimation}.`);
            const animationStructure = {};
            for (const gltfChannel of gltfAnimation.channels) {
                if (gltfChannel.target.path == "weights") {
                    FudgeCore.Debug.warn(`${this}: Animation with index ${_iAnimation} has a target path of 'weights'. FUDGE does not support morph targets.`);
                    continue;
                }
                const gltfNode = this.#gltf.nodes[gltfChannel.target.node];
                if (!gltfNode)
                    continue;
                let node = animationStructure;
                for (const iNode of gltfNode.path) {
                    const childName = this.#gltf.nodes[iNode].name;
                    // node.children[childName]
                    node = (node.children ??= {})[childName] ??= {};
                }
                let mtxLocal = ((((node.components ??= {}).ComponentTransform ??= [])[0] ??= {}).mtxLocal ??= {});
                mtxLocal[toInternTransformation[gltfChannel.target.path]] =
                    await this.getAnimationSequence(gltfAnimation.samplers[gltfChannel.sampler], gltfChannel.target.path);
            }
            const animation = _animationOut ?? new FudgeCore.AnimationGLTF();
            animation.animationStructure = animationStructure;
            animation.clearCache();
            animation.name = gltfAnimation.name;
            animation.calculateTotalTime();
            if (animation instanceof FudgeCore.AnimationGLTF)
                animation.url = this.#url;
            if (!_animationOut) {
                FudgeCore.Project.deregister(animation);
                this.#resources[id] = animation;
            }
            return animation;
        }
        async getMesh(_iMesh, _iPrimitive = 0, _meshOut) {
            _iMesh = this.getIndex(_iMesh, this.#gltf.meshes);
            if (_iMesh == -1)
                return null;
            const id = `${FudgeCore.MeshGLTF.name}|${_iMesh}|${_iPrimitive}`;
            if (!_meshOut && this.#resources[id])
                return this.#resources[id];
            const gltfMesh = this.#gltf.meshes[_iMesh];
            const gltfPrimitive = gltfMesh.primitives[_iPrimitive];
            if (gltfPrimitive.indices == undefined)
                FudgeCore.Debug.warn(`${this}: Mesh with index ${_iMesh} primitive ${_iPrimitive} has no indices. FUDGE does not support non-indexed meshes.`);
            if (gltfPrimitive.attributes.POSITION == undefined)
                FudgeCore.Debug.warn(`${this}: Mesh with index ${_iMesh} primitive ${_iPrimitive} has no position attribute. Primitive will be ignored.`);
            if (gltfPrimitive.mode != undefined && gltfPrimitive.mode != GLTF.MESH_PRIMITIVE_MODE.TRIANGLES)
                FudgeCore.Debug.warn(`${this}: Mesh with index ${_iMesh} primitive ${_iPrimitive} has topology type mode ${GLTF.MESH_PRIMITIVE_MODE[gltfPrimitive.mode]}. FUDGE only supports ${GLTF.MESH_PRIMITIVE_MODE[4]}.`);
            checkMaxSupport(this, "TEXCOORD", 2);
            checkMaxSupport(this, "COLOR", 1);
            checkMaxSupport(this, "JOINTS", 1);
            checkMaxSupport(this, "WEIGHTS", 1);
            let positions, indices;
            let normals, tangents;
            let colors, textureUVs;
            let bones, weights;
            if (gltfPrimitive.indices != undefined) {
                indices = await this.getVertexIndices(gltfPrimitive.indices);
                for (let i = 0; i < indices.length; i += 3) {
                    const temp = indices[i + 2];
                    indices[i + 2] = indices[i + 0];
                    indices[i + 0] = indices[i + 1];
                    indices[i + 1] = temp;
                }
            }
            else {
                FudgeCore.Debug.warn(`${this}: Mesh with index ${_iMesh} primitive ${_iPrimitive} has no indices. FUDGE does not support non-indexed meshes.`);
            }
            if (gltfPrimitive.attributes.POSITION != undefined)
                positions = await this.getFloat32Array(gltfPrimitive.attributes.POSITION);
            else
                FudgeCore.Debug.warn(`${this}: Mesh with index ${_iMesh} primitive ${_iPrimitive} has no position attribute. Primitive will be ignored.`);
            if (gltfPrimitive.attributes.NORMAL != undefined)
                normals = await this.getFloat32Array(gltfPrimitive.attributes.NORMAL);
            // TODO: calculate flat normals if not provided, fudge will calculate smooth normals if not provided
            if (gltfPrimitive.attributes.TANGENT != undefined)
                tangents = await this.getFloat32Array(gltfPrimitive.attributes.TANGENT);
            if (gltfPrimitive.attributes.TEXCOORD_1 != undefined)
                textureUVs = await this.getFloat32Array(gltfPrimitive.attributes.TEXCOORD_1);
            else if (gltfPrimitive.attributes.TEXCOORD_0 != undefined)
                textureUVs = await this.getFloat32Array(gltfPrimitive.attributes.TEXCOORD_0);
            if (gltfPrimitive.attributes.COLOR_0 != undefined)
                colors = await this.getVertexColors(gltfPrimitive.attributes.COLOR_0);
            if (gltfPrimitive.attributes.JOINTS_0 != undefined && gltfPrimitive.attributes.WEIGHTS_0 != undefined) {
                bones = await this.getBoneIndices(gltfPrimitive.attributes.JOINTS_0);
                weights = await this.getFloat32Array(gltfPrimitive.attributes.WEIGHTS_0);
            }
            const mesh = _meshOut ?? new FudgeCore.MeshGLTF();
            mesh.name = gltfMesh.name;
            if (mesh instanceof FudgeCore.MeshGLTF) {
                mesh.iPrimitive = _iPrimitive;
                mesh.url = this.#url;
            }
            if (_meshOut) {
                _meshOut.clear();
                _meshOut.faces = [];
                _meshOut.vertices = new FudgeCore.Vertices();
            }
            if (!normals || !tangents) {
                // Create mesh vertices and faces so that normals and tangents can be calculated if either is missing.
                for (let iVector2 = 0, iVector3 = 0, iVector4 = 0; iVector3 < positions?.length; iVector2 += 2, iVector3 += 3, iVector4 += 4) {
                    mesh.vertices.push(new FudgeCore.Vertex(new FudgeCore.Vector3(positions[iVector3 + 0], positions[iVector3 + 1], positions[iVector3 + 2]), textureUVs ?
                        new FudgeCore.Vector2(textureUVs[iVector2 + 0], textureUVs[iVector2 + 1]) :
                        undefined, normals ?
                        new FudgeCore.Vector3(normals[iVector3 + 0], normals[iVector3 + 1], normals[iVector3 + 2]) :
                        undefined, tangents ?
                        new FudgeCore.Vector4(tangents[iVector4 + 0], tangents[iVector4 + 1], tangents[iVector4 + 2], tangents[iVector4 + 3]) :
                        undefined, colors ?
                        new FudgeCore.Color(colors[iVector4 + 0], colors[iVector4 + 1], colors[iVector4 + 2], colors[iVector4 + 3]) :
                        undefined, bones && weights ?
                        [
                            { index: bones[iVector4 + 0], weight: weights[iVector4 + 0] },
                            { index: bones[iVector4 + 1], weight: weights[iVector4 + 1] },
                            { index: bones[iVector4 + 2], weight: weights[iVector4 + 2] },
                            { index: bones[iVector4 + 3], weight: weights[iVector4 + 3] }
                        ] :
                        undefined));
                }
                for (let iFaceVertexIndex = 0; iFaceVertexIndex < indices?.length; iFaceVertexIndex += 3) {
                    try {
                        mesh.faces.push(new FudgeCore.Face(mesh.vertices, indices[iFaceVertexIndex + 0], indices[iFaceVertexIndex + 1], indices[iFaceVertexIndex + 2]));
                    }
                    catch (_e) {
                        FudgeCore.Debug.fudge("Face excluded", _e.message);
                    }
                }
            }
            const renderMesh = mesh.renderMesh;
            renderMesh.positions = positions;
            renderMesh.indices = indices;
            renderMesh.normals = normals;
            renderMesh.tangents = tangents;
            renderMesh.textureUVs = textureUVs;
            renderMesh.colors = colors;
            renderMesh.bones = bones;
            renderMesh.weights = weights;
            if (!_meshOut) {
                FudgeCore.Project.deregister(mesh);
                // mesh.idResource = id;
                this.#resources[id] = mesh;
            }
            return mesh;
            function checkMaxSupport(_loader, _check, _max) {
                if (Object.keys(gltfPrimitive.attributes).filter((_key) => _key.startsWith(_check)).length > _max)
                    FudgeCore.Debug.warn(`${_loader}: Mesh with index ${_iMesh} primitive ${_iPrimitive} has more than ${_max} sets of '${_check}' associated with it. FUGDE only supports up to ${_max} ${_check} sets per primitive.`);
            }
        }
        async getMaterial(_iMaterial, _materialOut, _skin = false) {
            _iMaterial = this.getIndex(_iMaterial, this.#gltf.materials);
            if (_iMaterial == -1)
                return null;
            const id = `${FudgeCore.Material.name}|${_iMaterial}`;
            if (this.#resources[id] && !_materialOut)
                return this.#resources[id];
            // TODO: in the future create an appropriate shader based on the glTF material properties
            const gltfMaterial = this.#gltf.materials[_iMaterial];
            if (!gltfMaterial)
                throw new Error(`${this}: Couldn't find material with index ${_iMaterial}.`);
            // TODO: add support for other glTF material properties: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-material
            // e.g. occlusion and emissive textures; doubleSided
            const gltfBaseColorFactor = gltfMaterial.pbrMetallicRoughness?.baseColorFactor ?? [1, 1, 1, 1];
            const gltfMetallicFactor = gltfMaterial.pbrMetallicRoughness?.metallicFactor ?? 1;
            const gltfRoughnessFactor = gltfMaterial.pbrMetallicRoughness?.roughnessFactor ?? 1;
            const gltfEmissiveFactor = gltfMaterial.emissiveFactor ?? [0, 0, 0];
            const gltfBaseColorTexture = gltfMaterial.pbrMetallicRoughness?.baseColorTexture;
            const gltfNormalTexture = gltfMaterial.normalTexture;
            // The diffuse contribution in the Phong shading model. Represents how much light is scattered in different directions due to the material's surface properties.
            const diffuse = 1;
            // The shininess of the material. Influences the sharpness or broadness of the specular highlight. Higher specular values result in a sharper and more concentrated specular highlight.
            const specular = 1.8 * (1 - gltfRoughnessFactor) + 0.6 * gltfMetallicFactor;
            // The strength/intensity of the specular reflection
            const intensity = 0.7 * (1 - gltfRoughnessFactor) + gltfMetallicFactor;
            // Influences how much the material's color affects the specular reflection. When metallic is higher, the specular reflection takes on the color of the material, creating a metallic appearance. Range from 0.0 to 1.0.
            const metallic = gltfMetallicFactor;
            const isLit = gltfEmissiveFactor[0] > 0 || gltfEmissiveFactor[1] > 0 || gltfEmissiveFactor[2] > 0;
            const color = new FudgeCore.Color(...gltfBaseColorFactor);
            if (isLit)
                color.add(new FudgeCore.Color(...gltfEmissiveFactor, 0));
            const coat = gltfBaseColorTexture ?
                isLit ? new FudgeCore.CoatTextured(color, await this.getTexture(gltfBaseColorTexture.index)) :
                    gltfNormalTexture ?
                        new FudgeCore.CoatRemissiveTexturedNormals(color, await this.getTexture(gltfBaseColorTexture.index), await this.getTexture(gltfNormalTexture.index), diffuse, specular, intensity, metallic) :
                        new FudgeCore.CoatRemissiveTextured(color, await this.getTexture(gltfBaseColorTexture.index), diffuse, specular, intensity, metallic) :
                isLit ? new FudgeCore.CoatColored(color) : new FudgeCore.CoatRemissive(color, diffuse, specular, intensity, metallic);
            if (gltfMaterial.alphaCutoff != undefined)
                coat.alphaClip = gltfMaterial.alphaCutoff;
            let shader;
            if (isLit) {
                shader = gltfBaseColorTexture ?
                    (_skin ? FudgeCore.ShaderLitTexturedSkin : FudgeCore.ShaderLitTextured) :
                    (_skin ? FudgeCore.ShaderLitSkin : FudgeCore.ShaderLit);
            }
            else {
                shader = gltfBaseColorTexture ?
                    gltfNormalTexture ?
                        (_skin ? FudgeCore.ShaderPhongTexturedNormalsSkin : FudgeCore.ShaderPhongTexturedNormals) :
                        (_skin ? FudgeCore.ShaderPhongTexturedSkin : FudgeCore.ShaderPhongTextured) :
                    (_skin ? FudgeCore.ShaderPhongSkin : FudgeCore.ShaderPhong);
            }
            const material = _materialOut ?? new FudgeCore.MaterialGLTF(gltfMaterial.name);
            material.name = gltfMaterial.name;
            material.coat = coat;
            Reflect.set(material, "shaderType", shader);
            // material.setShader(shader);
            if (material instanceof FudgeCore.MaterialGLTF)
                material.url = this.#url;
            if (!_materialOut) {
                FudgeCore.Project.deregister(material);
                this.#resources[id] = material;
            }
            return material;
        }
        /**
         * Returns the {@link Texture} for the given texture index.
         */
        async getTexture(_iTexture) {
            const id = `${FudgeCore.Texture.name}|${_iTexture}`;
            if (this.#resources[id])
                return this.#resources[id];
            const gltfTexture = this.#gltf.textures[_iTexture];
            const gltfSampler = this.#gltf.samplers?.[gltfTexture.sampler];
            const gltfImage = this.#gltf.images?.[gltfTexture.source];
            if (gltfImage == undefined) {
                FudgeCore.Debug.warn(`${this}: Texture with index ${_iTexture} has no image.`);
                return FudgeCore.TextureDefault.color;
            }
            let url = new URL(gltfImage.uri, new URL(this.#url, FudgeCore.Project.baseURL)).toString();
            if (!gltfImage.uri && gltfImage.bufferView) {
                // TODO: this is duplicate code from getBufferData, maybe refactor getBufferData to handle bufferViewIndex input
                const gltfBufferView = this.#gltf.bufferViews[gltfImage.bufferView];
                const buffer = await this.getBuffer(gltfBufferView.buffer);
                const byteOffset = gltfBufferView.byteOffset || 0;
                const byteLength = gltfBufferView.byteLength || 0;
                url = URL.createObjectURL(new Blob([new Uint8Array(buffer, byteOffset, byteLength / Uint8Array.BYTES_PER_ELEMENT)], { type: gltfImage.mimeType }));
            }
            const texture = new FudgeCore.TextureImage();
            await texture.load(url);
            if (gltfSampler) {
                gltfSampler.magFilter = gltfSampler.magFilter ?? WebGL2RenderingContext.NEAREST; // default value
                gltfSampler.minFilter = gltfSampler.minFilter ?? WebGL2RenderingContext.NEAREST; // default value
                if (gltfSampler.magFilter == WebGL2RenderingContext.NEAREST && gltfSampler.minFilter == WebGL2RenderingContext.NEAREST)
                    texture.mipmap = FudgeCore.MIPMAP.CRISP;
                else if (gltfSampler.magFilter == WebGL2RenderingContext.NEAREST && gltfSampler.minFilter == WebGL2RenderingContext.NEAREST_MIPMAP_LINEAR)
                    texture.mipmap = FudgeCore.MIPMAP.MEDIUM;
                else if (gltfSampler.magFilter == WebGL2RenderingContext.LINEAR && gltfSampler.minFilter == WebGL2RenderingContext.LINEAR_MIPMAP_LINEAR)
                    texture.mipmap = FudgeCore.MIPMAP.BLURRY;
                else
                    FudgeCore.Debug.warn(`${this}: Texture with index ${_iTexture} has a magFilter and minFilter of '${getWebGLParameterName(gltfSampler.magFilter)}' and '${getWebGLParameterName(gltfSampler.minFilter)}' respectively. FUDGE only supports the following combinations: NEAREST and NEAREST | NEAREST and NEAREST_MIPMAP_LINEAR | LINEAR and LINEAR_MIPMAP_LINEAR.`);
                gltfSampler.wrapS = gltfSampler.wrapS ?? WebGL2RenderingContext.REPEAT; // default value
                gltfSampler.wrapT = gltfSampler.wrapT ?? WebGL2RenderingContext.REPEAT; // default value
                if (gltfSampler.wrapS == WebGL2RenderingContext.REPEAT && gltfSampler.wrapT == WebGL2RenderingContext.REPEAT)
                    texture.wrap = FudgeCore.WRAP.REPEAT;
                else if (gltfSampler.wrapS == WebGL2RenderingContext.CLAMP_TO_EDGE && gltfSampler.wrapT == WebGL2RenderingContext.CLAMP_TO_EDGE)
                    texture.wrap = FudgeCore.WRAP.CLAMP;
                else if (gltfSampler.wrapS == WebGL2RenderingContext.MIRRORED_REPEAT && gltfSampler.wrapT == WebGL2RenderingContext.MIRRORED_REPEAT)
                    texture.wrap = FudgeCore.WRAP.MIRROR;
                else
                    FudgeCore.Debug.warn(`${this}: Texture with index ${_iTexture} has a wrapS and wrapT of '${getWebGLParameterName(gltfSampler.wrapS)}' and '${getWebGLParameterName(gltfSampler.wrapT)}' respectively. FUDGE only supports the following combinations: REPEAT and REPEAT | CLAMP_TO_EDGE and CLAMP_TO_EDGE | MIRRORED_REPEAT and MIRRORED_REPEAT.`);
            }
            FudgeCore.Project.deregister(texture);
            this.#resources[id] = texture;
            return texture;
        }
        toString() {
            return `${GLTFLoader.name} | ${this.#url}`;
        }
        /**
         * Returns the {@link Node} for the given index.
         */
        async getNodeByIndex(_iNode, _cache) {
            if (!_cache.nodes[_iNode]) {
                const gltfNode = this.#gltf.nodes[_iNode];
                const node = new FudgeCore.Node(gltfNode.name);
                _cache.nodes[_iNode] = node;
                // check for children
                if (gltfNode.children)
                    for (const iNode of gltfNode.children)
                        node.addChild(await this.getNodeByIndex(iNode, _cache));
                // check for transformation
                if (gltfNode.matrix || gltfNode.rotation || gltfNode.scale || gltfNode.translation || gltfNode.isAnimated) {
                    node.addComponent(new FudgeCore.ComponentTransform());
                    if (gltfNode.matrix) {
                        node.mtxLocal.setArray(gltfNode.matrix);
                    }
                    else {
                        if (gltfNode.translation) {
                            const translation = FudgeCore.Recycler.get(FudgeCore.Vector3);
                            translation.set(gltfNode.translation[0], gltfNode.translation[1], gltfNode.translation[2]);
                            node.mtxLocal.translation = translation;
                            FudgeCore.Recycler.store(translation);
                        }
                        if (gltfNode.rotation) {
                            const rotation = FudgeCore.Recycler.get(FudgeCore.Quaternion);
                            rotation.set(gltfNode.rotation[0], gltfNode.rotation[1], gltfNode.rotation[2], gltfNode.rotation[3]);
                            node.mtxLocal.rotation = rotation;
                            FudgeCore.Recycler.store(rotation);
                        }
                        if (gltfNode.scale) {
                            const scale = FudgeCore.Recycler.get(FudgeCore.Vector3);
                            scale.set(gltfNode.scale[0], gltfNode.scale[1], gltfNode.scale[2]);
                            node.mtxLocal.scaling = scale;
                            FudgeCore.Recycler.store(scale);
                        }
                    }
                }
                // check for camera
                if (gltfNode.camera != undefined) {
                    node.addComponent(await this.getCameraByIndex(gltfNode.camera));
                }
                // check for mesh and material
                if (gltfNode.mesh != undefined) {
                    const gltfMesh = this.#gltf.meshes?.[gltfNode.mesh];
                    // TODO: review this
                    const subComponents = [];
                    for (let iPrimitive = 0; iPrimitive < gltfMesh.primitives.length; iPrimitive++) {
                        const cmpMesh = new FudgeCore.ComponentMesh(await this.getMesh(gltfNode.mesh, iPrimitive));
                        const isSkin = gltfNode.skin != undefined;
                        if (isSkin)
                            cmpMesh.skeleton = await this.getSkeletonByIndex(gltfNode.skin, _cache);
                        let cmpMaterial;
                        const iMaterial = gltfMesh.primitives?.[iPrimitive]?.material;
                        if (iMaterial == undefined) {
                            cmpMaterial = new FudgeCore.ComponentMaterial(isSkin ?
                                GLTFLoader.defaultSkinMaterial :
                                GLTFLoader.defaultMaterial);
                        }
                        else {
                            cmpMaterial = new FudgeCore.ComponentMaterial(await this.getMaterial(iMaterial, null, isSkin));
                            // TODO: maybe this should be a fudge material property
                            const gltfMaterial = this.#gltf.materials[iMaterial];
                            if (gltfMaterial)
                                cmpMaterial.sortForAlpha = gltfMaterial.alphaMode == "BLEND";
                        }
                        subComponents.push([cmpMesh, cmpMaterial]);
                    }
                    if (subComponents.length == 1) {
                        node.addComponent(subComponents[0][0]);
                        node.addComponent(subComponents[0][1]);
                    }
                    else {
                        subComponents.forEach(([_cmpMesh, _cmpMaterial], _i) => {
                            const nodePart = new FudgeCore.Node(`${node.name}_Primitive${_i}`);
                            nodePart.addComponent(_cmpMesh);
                            nodePart.addComponent(_cmpMaterial);
                            node.addChild(nodePart);
                        });
                    }
                }
            }
            return _cache.nodes[_iNode];
        }
        /**
        * Returns the {@link ComponentSkeleton} for the given skeleton index.
        */
        async getSkeletonByIndex(_iSkeleton, _cache) {
            if (!_cache.skeletons[_iSkeleton]) {
                const gltfSkin = this.#gltf.skins[_iSkeleton];
                const bones = [];
                // convert float array to array of matrices and register bones
                let mtxData;
                if (gltfSkin.inverseBindMatrices != undefined)
                    mtxData = await this.getFloat32Array(gltfSkin.inverseBindMatrices);
                const mtxDataSpan = 16; // size of matrix
                const mtxBindInverses = [];
                // iterate over joints and get corresponding matrix from float array
                for (let iBone = 0; iBone < gltfSkin.joints.length; iBone++) {
                    let mtxBindInverse;
                    if (mtxData)
                        mtxBindInverse = new FudgeCore.Matrix4x4(mtxData.slice(iBone * mtxDataSpan, (iBone + 1) * mtxDataSpan));
                    bones.push(await this.getNodeByIndex(gltfSkin.joints[iBone], _cache));
                    mtxBindInverses.push(mtxBindInverse);
                }
                _cache.skeletons[_iSkeleton] = new FudgeCore.ComponentSkeleton(bones, mtxBindInverses);
            }
            return _cache.skeletons[_iSkeleton];
        }
        /**
         * Returns the {@link ComponentCamera} for the given camera index.
         */
        async getCameraByIndex(_iCamera) {
            const gltfCamera = this.#gltf.cameras[_iCamera];
            const camera = new FudgeCore.ComponentCamera();
            if (gltfCamera.perspective)
                camera.projectCentral(gltfCamera.perspective.aspectRatio, gltfCamera.perspective.yfov * FudgeCore.Calc.rad2deg, null, gltfCamera.perspective.znear, gltfCamera.perspective.zfar);
            else
                camera.projectOrthographic(-gltfCamera.orthographic.xmag, gltfCamera.orthographic.xmag, -gltfCamera.orthographic.ymag, gltfCamera.orthographic.ymag);
            return camera;
        }
        getIndex(_nameOrIndex, _array) {
            let index = typeof _nameOrIndex == "number" ?
                _nameOrIndex :
                _array.findIndex(_object => _object.name == _nameOrIndex);
            if (index == -1) {
                let arrayName = Object.entries(this.#gltf).find(([_key, _value]) => _value == _array)?.[0];
                FudgeCore.Debug.error(`${this}: Couldn't find name '${_nameOrIndex}' in glTF ${arrayName}.`);
            }
            return index;
        }
        /**
         * Returns a {@link Uint8Array} for the given accessor index.
         * @internal
         */
        async getBoneIndices(_iAccessor) {
            const array = await this.getBufferData(_iAccessor);
            const componentType = this.#gltf.accessors[_iAccessor]?.componentType;
            if (componentType == GLTF.COMPONENT_TYPE.UNSIGNED_BYTE)
                return array;
            if (componentType == GLTF.COMPONENT_TYPE.UNSIGNED_SHORT) {
                FudgeCore.Debug.log(`${this}: Bone indices are stored as '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.UNSIGNED_SHORT]}'. FUDGE will convert them to '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.UNSIGNED_BYTE]}'. FUDGE only supports skeletons with up to 256 bones, so make sure your skeleton has no more than 256 bones.`);
                return Uint8Array.from(array);
            }
            throw new Error(`${this}: Invalid component type '${GLTF.COMPONENT_TYPE[componentType]}' for bone indices. Expected '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.UNSIGNED_BYTE]}' or '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.UNSIGNED_SHORT]}'.`);
        }
        /**
         * Returns a {@link Float32Array} for the given accessor index.
         * @internal
         */
        async getFloat32Array(_iAccessor) {
            const array = await this.getBufferData(_iAccessor);
            const gltfAccessor = this.#gltf.accessors[_iAccessor];
            if (gltfAccessor.componentType == GLTF.COMPONENT_TYPE.FLOAT)
                return array;
            if (gltfAccessor.normalized) {
                switch (gltfAccessor.componentType) {
                    case GLTF.COMPONENT_TYPE.BYTE:
                        return Float32Array.from(array, _value => Math.max(_value / 127, -1));
                    case GLTF.COMPONENT_TYPE.UNSIGNED_BYTE:
                        return Float32Array.from(array, _value => _value / 255);
                    case GLTF.COMPONENT_TYPE.SHORT:
                        return Float32Array.from(array, _value => Math.max(_value / 32767, -1));
                    case GLTF.COMPONENT_TYPE.UNSIGNED_SHORT:
                        return Float32Array.from(array, _value => _value / 65535);
                    default:
                        throw new Error(`${this}: Invalid component type '${GLTF.COMPONENT_TYPE[gltfAccessor.componentType]}' for normalized accessor.`);
                    // https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#_accessor_normalized
                }
            }
            FudgeCore.Debug.warn(`${this}: Expected component type '${GLTF.COMPONENT_TYPE[GLTF.COMPONENT_TYPE.FLOAT]}' but was '${GLTF.COMPONENT_TYPE[gltfAccessor?.componentType]}'.`);
            return Float32Array.from(array);
        }
        /**
         * Returns a {@link Uint16Array} for the given accessor index. Only used to get the vertex indices.
         * @internal
         */
        async getVertexIndices(_iAccessor) {
            const array = await this.getBufferData(_iAccessor);
            const gltfAccessor = this.#gltf.accessors[_iAccessor];
            if (gltfAccessor.componentType == GLTF.COMPONENT_TYPE.UNSIGNED_SHORT)
                return array;
            if (gltfAccessor.count > 65535 && gltfAccessor.type == "SCALAR")
                throw new Error(`${this}: File includes a mesh with more than 65535 vertices. FUDGE does not support meshes with more than 65535 vertices.`);
            if (gltfAccessor.componentType == GLTF.COMPONENT_TYPE.UNSIGNED_BYTE || gltfAccessor.componentType == GLTF.COMPONENT_TYPE.UNSIGNED_INT)
                return Uint16Array.from(array);
            FudgeCore.Debug.warn(`${this}: Expected an unsigned integer component type but was '${GLTF.COMPONENT_TYPE[this.#gltf.accessors[_iAccessor]?.componentType]}'.`);
            return Uint16Array.from(array);
        }
        /**
         * Return a {@link Float32Array} for the given accessor index. The array contains the vertex colors in RGBA format.
         * @internal
         */
        async getVertexColors(_iAccessor) {
            const array = await this.getFloat32Array(_iAccessor);
            const gltfAccessor = this.#gltf.accessors[_iAccessor];
            if (gltfAccessor.type == GLTF.ACCESSOR_TYPE.VEC3) {
                const rgbaArray = new Float32Array(array.length * 4 / 3);
                for (let iVec3 = 0, iVec4 = 0; iVec3 < array.length; iVec3 += 3, iVec4 += 4) {
                    rgbaArray[iVec4] = array[iVec3];
                    rgbaArray[iVec4 + 1] = array[iVec3 + 1];
                    rgbaArray[iVec4 + 2] = array[iVec3 + 2];
                    rgbaArray[iVec4 + 3] = 1;
                }
                return rgbaArray;
            }
            return array;
        }
        async getBufferData(_iAccessor) {
            const gltfAccessor = this.#gltf.accessors[_iAccessor];
            if (!gltfAccessor)
                throw new Error(`${this}: Couldn't find accessor with index ${_iAccessor}.`);
            let array;
            const componentType = gltfAccessor.componentType;
            const accessorType = gltfAccessor.type;
            if (gltfAccessor.bufferView != undefined)
                array = await this.getBufferViewData(this.#gltf.bufferViews[gltfAccessor.bufferView], gltfAccessor.byteOffset, componentType, accessorType);
            if (gltfAccessor.sparse) {
                const gltfBufferViewIndices = this.#gltf.bufferViews[gltfAccessor.sparse.indices.bufferView];
                const gltfBufferViewValues = this.#gltf.bufferViews[gltfAccessor.sparse.values.bufferView];
                if (!gltfBufferViewIndices || !gltfBufferViewValues)
                    throw new Error(`${this}: Couldn't find buffer views for sparse indices or values of accessor with index ${_iAccessor}.`);
                const arrayIndices = await this.getBufferViewData(gltfBufferViewIndices, gltfAccessor.sparse.indices.byteOffset, gltfAccessor.sparse.indices.componentType, GLTF.ACCESSOR_TYPE.SCALAR);
                const arrayValues = await this.getBufferViewData(gltfBufferViewValues, gltfAccessor.sparse.values.byteOffset, componentType, accessorType);
                const accessorTypeLength = toAccessorTypeLength[gltfAccessor.type];
                if (gltfAccessor.bufferView == undefined)
                    array = new toArrayConstructor[gltfAccessor.componentType](gltfAccessor.count * accessorTypeLength);
                for (let i = 0; i < gltfAccessor.sparse.count; i++) {
                    array.set(arrayValues.slice(i * accessorTypeLength, (i + 1) * accessorTypeLength), arrayIndices[i] * accessorTypeLength);
                }
            }
            return array;
        }
        async getBufferViewData(_bufferView, _byteOffset, _componentType, _accessorType) {
            const buffer = await this.getBuffer(_bufferView.buffer);
            const byteOffset = (_bufferView.byteOffset ?? 0) + (_byteOffset ?? 0);
            const byteLength = _bufferView.byteLength ?? 0;
            const byteStride = _bufferView.byteStride;
            const arrayConstructor = toArrayConstructor[_componentType];
            //@ts-ignore because the TypedArrayConstructor type is not assignable to the TypedArray type
            const array = new arrayConstructor(buffer, byteOffset, byteLength / arrayConstructor.BYTES_PER_ELEMENT);
            if (byteStride != undefined) {
                // TODO: instead of creating new buffers maybe rather pass stride into the render mesh? and set it when data is passed to the gpu?
                const nComponentsPerElement = toAccessorTypeLength[_accessorType]; // amount of components per element of the accessor type, e.g. 3 for VEC3
                const nElements = byteLength / byteStride; // amount of elements, e.g. n*VEC3 
                const stride = byteStride / arrayConstructor.BYTES_PER_ELEMENT;
                const newArray = new arrayConstructor(nElements * nComponentsPerElement);
                for (let iNewElement = 0; iNewElement < nElements; iNewElement++) {
                    const iElement = iNewElement * stride;
                    // TODO: check if loop is faster than set + slice
                    for (let iComponent = 0; iComponent < nComponentsPerElement; iComponent++)
                        newArray[iNewElement * nComponentsPerElement + iComponent] = array[iElement + iComponent];
                    // newArray.set(array.slice(iElement, iElement + nComponentsPerElement), iNewElement * nComponentsPerElement);
                }
                return newArray;
            }
            return array;
        }
        async getBuffer(_iBuffer) {
            const gltfBuffer = this.#gltf.buffers[_iBuffer];
            if (!gltfBuffer)
                throw new Error(`${this}: Couldn't find buffer with index ${_iBuffer}.`);
            if (!this.#buffers)
                this.#buffers = [];
            if (!this.#buffers[_iBuffer]) {
                const response = await fetch(new URL(gltfBuffer.uri, new URL(this.#url, FudgeCore.Project.baseURL)));
                this.#buffers[_iBuffer] = await response.arrayBuffer();
            }
            return this.#buffers[_iBuffer];
        }
        async getAnimationSequence(_sampler, _transformationType) {
            const input = await this.getFloat32Array(_sampler.input);
            const output = await this.getFloat32Array(_sampler.output);
            const millisPerSecond = 1000;
            const isRotation = _transformationType == "rotation";
            const vectorLength = isRotation ? 4 : 3; // rotation is stored as quaternion
            const interpolation = this.toInternInterpolation(_sampler.interpolation);
            const isCubic = interpolation == FudgeCore.ANIMATION_INTERPOLATION.CUBIC;
            const vectorsPerInput = isCubic ? 3 : 1; // cubic interpolation uses 3 values per input: in-tangent, property value and out-tangent. https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#interpolation-cubic
            // used only for rotation interpolation
            let lastRotation;
            let nextRotation;
            const sequence = [];
            if (isRotation) {
                lastRotation = FudgeCore.Recycler.get(FudgeCore.Quaternion);
                nextRotation = FudgeCore.Recycler.get(FudgeCore.Quaternion);
            }
            for (let iInput = 0; iInput < input.length; iInput++) {
                const iOutput = iInput * vectorsPerInput * vectorLength + (isCubic ? vectorLength : 0);
                const iOutputSlopeIn = iOutput - vectorLength;
                const iOutputSlopeOut = iOutput + vectorLength;
                const time = millisPerSecond * input[iInput];
                let value;
                let slopeIn;
                let slopeOut;
                if (isRotation) {
                    // Take the shortest path between two rotations, i.e. if the dot product is negative then the next quaternion needs to be negated.
                    // q and -q represent the same rotation but interpolation will take either the long way or the short way around the sphere depending on which we use.
                    nextRotation.set(output[iOutput + 0], output[iOutput + 1], output[iOutput + 2], output[iOutput + 3]);
                    if (FudgeCore.Quaternion.DOT(lastRotation, nextRotation) < 0)
                        nextRotation.negate();
                    lastRotation.set(nextRotation.x, nextRotation.y, nextRotation.z, nextRotation.w);
                    value = nextRotation.clone;
                    if (isCubic) {
                        slopeIn = new FudgeCore.Quaternion(output[iOutputSlopeIn + 0], output[iOutputSlopeIn + 1], output[iOutputSlopeIn + 2], output[iOutputSlopeIn + 3]);
                        slopeOut = new FudgeCore.Quaternion(output[iOutputSlopeOut + 0], output[iOutputSlopeOut + 1], output[iOutputSlopeOut + 2], output[iOutputSlopeOut + 3]);
                    }
                }
                else {
                    value = new FudgeCore.Vector3(output[iOutput + 0], output[iOutput + 1], output[iOutput + 2]);
                    if (isCubic) {
                        slopeIn = new FudgeCore.Vector3(output[iOutputSlopeIn + 0], output[iOutputSlopeIn + 1], output[iOutputSlopeIn + 2]);
                        slopeOut = new FudgeCore.Vector3(output[iOutputSlopeOut + 0], output[iOutputSlopeOut + 1], output[iOutputSlopeOut + 2]);
                    }
                }
                sequence.push(new FudgeCore.AnimationKey(time, value, interpolation, slopeIn, slopeOut));
            }
            if (isRotation) {
                FudgeCore.Recycler.store(lastRotation);
                FudgeCore.Recycler.store(nextRotation);
            }
            return new FudgeCore.AnimationSequence(sequence, isRotation ? FudgeCore.Quaternion : FudgeCore.Vector3);
        }
        toInternInterpolation(_interpolation) {
            switch (_interpolation) {
                case "LINEAR":
                    return FudgeCore.ANIMATION_INTERPOLATION.LINEAR;
                case "STEP":
                    return FudgeCore.ANIMATION_INTERPOLATION.CONSTANT;
                case "CUBICSPLINE":
                    return FudgeCore.ANIMATION_INTERPOLATION.CUBIC;
                default:
                    if (_interpolation != undefined)
                        FudgeCore.Debug.warn(`${this}: Unknown interpolation type ${_interpolation}.`);
                    return FudgeCore.ANIMATION_INTERPOLATION.LINEAR;
            }
        }
    }
    FudgeCore.GLTFLoader = GLTFLoader;
    function getWebGLParameterName(_value) {
        return Object.keys(WebGL2RenderingContext).find(_key => Reflect.get(WebGL2RenderingContext, _key) == _value);
    }
    const toInternTransformation = {
        "translation": "translation",
        "rotation": "rotation",
        "scale": "scaling"
    };
    // number of components defined by 'type'
    const toAccessorTypeLength = {
        "SCALAR": 1,
        "VEC2": 2,
        "VEC3": 3,
        "VEC4": 4,
        "MAT2": 4,
        "MAT3": 9,
        "MAT4": 16
    };
    const toArrayConstructor = {
        [GLTF.COMPONENT_TYPE.UNSIGNED_BYTE]: Uint8Array,
        [GLTF.COMPONENT_TYPE.BYTE]: Int8Array,
        [GLTF.COMPONENT_TYPE.UNSIGNED_SHORT]: Uint16Array,
        [GLTF.COMPONENT_TYPE.SHORT]: Int16Array,
        [GLTF.COMPONENT_TYPE.UNSIGNED_INT]: Uint32Array,
        [GLTF.COMPONENT_TYPE.FLOAT]: Float32Array
    };
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    FudgeCore.shaderSources = {};
    FudgeCore.shaderSources["ShaderAmbientOcclusion.frag"] = /*glsl*/ `#version 300 es
/**
 * Calculates ambient occlusion for a given fragment
 * @authors Roland Heer, HFU, 2023 | Jonas Plotzky, HFU, 2023
 * adaption of https://github.com/tsherif/webgl2examples/blob/da1153a15ebc09bb13498e5f732ef2036507740c/ssao.html
 * see here for an in depth explanation: 
*/
precision mediump float;
precision highp int;

const float sin45 = 0.707107; // 45 degrees in radians
const vec2 kernel[4] = vec2[4](vec2(0.0, 1.0), vec2(1.0, 0.0), vec2(0.0, -1.0), vec2(-1.0, 0.0));

uniform float u_fNear;
uniform float u_fFar;
uniform float u_fSampleRadius;
uniform float u_fBias;
uniform float u_fAttenuationConstant;
uniform float u_fAttenuationLinear;
uniform float u_fAttenuationQuadratic;
uniform vec2 u_vctResolution;
uniform vec3 u_vctCamera;
// uniform mat4 u_mtxViewProjectionInverse;

uniform sampler2D u_texPosition;
uniform sampler2D u_texNormal;
uniform sampler2D u_texNoise;
// uniform sampler2D u_texDepth;

in vec2 v_vctTexture;
out vec4 vctFrag;

layout(std140) uniform Fog {
  bool u_bFogActive;
  float u_fFogNear;
  float u_fFogFar;
  float pading;
  vec4 u_vctFogColor;
};

// This function could be used to calculate the position from the depth texture, but mobile devices seems to lack in precision to do this
// vec3 getPosition(vec2 _vctTexture) {
//   float fDepth = texture(u_texDepth, _vctTexture).r;
//   vec4 clipSpacePosition = vec4(_vctTexture * 2.0 - 1.0, fDepth * 2.0 - 1.0, 1.0);
//   vec4 worldSpacePosition = u_mtxViewProjectionInverse * clipSpacePosition;
//   return worldSpacePosition.xyz / worldSpacePosition.w;
// }

float getOcclusion(vec3 _vctPosition, vec3 _vctNormal, vec2 _vctTexture) {
  vec3 vctOccluder = texture(u_texPosition, _vctTexture).xyz;

  if (vctOccluder.x == 0.0 && vctOccluder.y == 0.0 && vctOccluder.z == 0.0) // no occluder at this position
    return 0.0;

  vec3 vctDistance = vctOccluder - _vctPosition;
  float fIntensity = max(dot(_vctNormal, normalize(vctDistance)) - u_fBias, 0.0);

  float fDistance = length(vctDistance);
  float fAttenuation = 1.0 / (u_fAttenuationConstant + u_fAttenuationLinear * fDistance + u_fAttenuationQuadratic * fDistance * fDistance);

  return fIntensity * fAttenuation;
}

float getFog(vec3 _vctPosition) {
  float fDistance = length(_vctPosition - u_vctCamera); // maybe use z-depth instead of euclidean depth
  float fFog = clamp((fDistance - u_fFogNear) / (u_fFogFar - u_fFogNear), 0.0, 1.0);
  fFog = -pow(fFog, 2.0) + (2.0 * fFog); // lets fog appear quicker and fall off slower results in a more gradual falloff
  return fFog * u_vctFogColor.a;
}

void main() {
  vec3 vctPosition = texture(u_texPosition, v_vctTexture).xyz;
  vec3 vctNormal = texture(u_texNormal, v_vctTexture).xyz;
  vec2 vctRandom = normalize(texture(u_texNoise, v_vctTexture).xy * 2.0 - 1.0);
  float fDepth = (length(vctPosition - u_vctCamera) - u_fNear) / (u_fFar - u_fNear); // linear euclidean depth in range [0,1], when changing to view space, don't subtract camera position
  float fKernelRadius = u_fSampleRadius * (1.0 - fDepth);

  float fOcclusion = 0.0;
  for (int i = 0; i < 4; ++i) {
    vec2 vctK1 = reflect(kernel[i], vctRandom);
    vec2 vctK2 = vec2(vctK1.x * sin45 - vctK1.y * sin45, vctK1.x * sin45 + vctK1.y * sin45);

    vctK1 /= u_vctResolution;
    vctK2 /= u_vctResolution;

    vctK1 *= fKernelRadius;
    vctK2 *= fKernelRadius;

    fOcclusion += getOcclusion(vctPosition, vctNormal, v_vctTexture + vctK1);
    fOcclusion += getOcclusion(vctPosition, vctNormal, v_vctTexture + vctK2 * 0.75);
    fOcclusion += getOcclusion(vctPosition, vctNormal, v_vctTexture + vctK1 * 0.5);
    fOcclusion += getOcclusion(vctPosition, vctNormal, v_vctTexture + vctK2 * 0.25);
  }

  fOcclusion = clamp(fOcclusion / 16.0, 0.0, 1.0);

  if (u_bFogActive && fOcclusion > 0.0) // correct occlusion by fog factor
    fOcclusion = mix(fOcclusion, 0.0, getFog(vctPosition));
  
  vctFrag.rgb = vec3(fOcclusion);
  vctFrag.a = 1.0;
}`;
    FudgeCore.shaderSources["ShaderBloom.frag"] = /*glsl*/ `#version 300 es
/**
 * Extracts colors, downsamples and upsamples a texture
 * Adaption of the "dual filtering kawase" method described in SIGGRAPH 2015 by Marius Bj√∏rge
 * https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_marius_2D00_notes.pdf
 * @authors Roland Heer, HFU, 2023 | Jirka Dell'Oro-Friedl, HFU, 2023 | Jonas Plotzky, HFU, 2023
 */
precision mediump float;
precision highp int;

uniform int u_iMode; // 0: extract, 1: downsample, 2: upsample, 3: apply
uniform float u_fThreshold;
uniform float u_fIntensity;
uniform float u_fHighlightDesaturation;
uniform vec2 u_vctTexel;

uniform sampler2D u_texSource;

in vec2 v_vctTexture;
out vec4 vctFrag;

// old gaussian blur
// flat in vec2[9] v_vctOffsets;
// const float gaussianKernel[9] = float[](0.045, 0.122, 0.045, 0.122, 0.332, 0.122, 0.045, 0.122, 0.045);
// vec4 downsample(vec2 _vctTexture) {
//   vec4 vctColor = vec4(0.0);
//   for (int i = 0; i < 9; i++) 
//     vctColor += texture(u_texSource, v_vctTexture + v_vctOffsets[i]) * gaussianKernel[i];
//   return vctColor;
// }
// vec4 upsample(vec2 _vctTexture) {
//   vec4 vctColor = vec4(0.0);
//   for (int i = 0; i < 9; i++) 
//     vctColor += texture(u_texSource, _vctTexture + v_vctOffsets[i]) * gaussianKernel[i];
//   return vctColor;
// }

// vec3 extract(vec2 _vctTexture) {
//   vec3 vctColor = texture(u_texSource, _vctTexture).rgb;
//   if(any(greaterThan(vctColor, vec3(u_fThreshold))))
//     return vctColor;
//   discard;
// }

// vec3 extract(vec2 _vctTexture) {
//   vec3 vctColor = texture(u_texSource, _vctTexture).rgb;
//   float luminance = dot(vctColor, vec3(0.299, 0.587, 0.114));
//   if(luminance > u_fThreshold)
//     return vctColor;
//   discard;
// }

// old extraction with average brightness
vec3 extract(vec2 _vctTexture) {
  vec3 vctColor = texture(u_texSource, _vctTexture).rgb;
  float fThreshold = u_fThreshold;
  if(fThreshold >= 1.0)
    fThreshold = 0.999999;

  vctColor = vctColor - fThreshold;
  vctColor = vctColor / (1.0 - fThreshold); // negative values might receive values above 1.0...
  
  float averageBrightness = (((vctColor.r + vctColor.g + vctColor.b) / 3.0) * 0.2) + 0.8; //the effect is reduced by first setting it to a 0.0-0.2 range and then adding 0.8
  vctColor = clamp(vctColor, 0.0, 1.0) * clamp(averageBrightness, 0.0, 1.0);
  return vctColor;
}

vec4 downsample(vec2 _vctTexture) {
  vec4 sum = texture(u_texSource, _vctTexture) * 4.0;
  sum += texture(u_texSource, _vctTexture - u_vctTexel.xy);
  sum += texture(u_texSource, _vctTexture + u_vctTexel.xy);
  sum += texture(u_texSource, _vctTexture + vec2(u_vctTexel.x, -u_vctTexel.y));
  sum += texture(u_texSource, _vctTexture - vec2(u_vctTexel.x, -u_vctTexel.y));

  return sum / 8.0;
}

vec4 upsample(vec2 _vctTexture) {
  vec4 sum = texture(u_texSource, _vctTexture + vec2(-u_vctTexel.x * 2.0, 0.0));
  sum += texture(u_texSource, _vctTexture + vec2(-u_vctTexel.x, u_vctTexel.y)) * 2.0;
  sum += texture(u_texSource, _vctTexture + vec2(0.0, u_vctTexel.y * 2.0));
  sum += texture(u_texSource, _vctTexture + vec2(u_vctTexel.x, u_vctTexel.y)) * 2.0;
  sum += texture(u_texSource, _vctTexture + vec2(u_vctTexel.x * 2.0, 0.0));
  sum += texture(u_texSource, _vctTexture + vec2(u_vctTexel.x, -u_vctTexel.y)) * 2.0;
  sum += texture(u_texSource, _vctTexture + vec2(0.0, -u_vctTexel.y * 2.0));
  sum += texture(u_texSource, _vctTexture + vec2(-u_vctTexel.x, -u_vctTexel.y)) * 2.0;
  return sum / 12.0;
}

vec3 apply(vec2 _vctTexture) {
  vec3 vctBloom = texture(u_texSource, _vctTexture).rgb;
  if (vctBloom.r >= 1.0 || vctBloom.g >= 1.0 || vctBloom.b >= 1.0) // maybe use threshold instead of 1.0?
    vctBloom = mix(vctBloom, vec3(1.0), u_fHighlightDesaturation);
  vctBloom = clamp(vctBloom * u_fIntensity, 0.0, 1.0);
  return vctBloom;
}

void main() {
  switch(u_iMode) {
    case 0:
      vctFrag.rgb = extract(v_vctTexture);
      vctFrag.a = 1.0;
      return;
    case 1:
      vctFrag = downsample(v_vctTexture);
      return;
    case 2:
      vctFrag = upsample(v_vctTexture);
      return;
    case 3:
      vctFrag.rgb = apply(v_vctTexture);
      vctFrag.a = 1.0;
      return;
    default:
      vctFrag = texture(u_texSource, v_vctTexture);
      return;
  }
}`;
    FudgeCore.shaderSources["ShaderGizmo.frag"] = /*glsl*/ `#version 300 es
/**
* ...
* @authors Jonas Plotzky, HFU, 2023
*/
precision mediump float;
precision highp int;

uniform vec4 u_vctColor;

out vec4 vctFrag;

// uniform sampler2D u_texDepthStencil;
#if defined(TEXTURE)

  uniform sampler2D u_texColor;
  in vec2 v_vctTexture;
  
#endif

// // 4x4 Bayer matrix for dithering
// const float mtxDither[16] = float[](
//   1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
//   13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
//   4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
//   16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
// );

void main() {
  vctFrag = u_vctColor;

  #if defined(TEXTURE)

      vctFrag *= texture(u_texColor, v_vctTexture);

  #endif

  // int x = int(gl_FragCoord.x) % 4;
  // int y = int(gl_FragCoord.y) % 4;
  // int index = y * 4 + x;
  // // Discard the fragment if its alpha is less than the corresponding value in the dithering matrix
  // if (vctFrag.a < mtxDither[index]) 
  //   discard;

  // // Discard the fragment if its alpha is 0
  // if (vctFrag.a == 0.0)
  //   discard;

  // // Create a checkerboard pattern for alpha values less than 0.5
  // else if (vctFrag.a < 0.5 && ((x + y) % 2 == 0))
  //   discard;

  // vctFrag.a = 1.0;

  if (vctFrag.a < 0.01)
    discard;
}`;
    FudgeCore.shaderSources["ShaderGizmo.vert"] = /*glsl*/ `#version 300 es
/**
* ...
* @authors Jonas Plotzky, HFU, 2023
*/
precision mediump float;
precision highp int;

uniform mat4 u_mtxMeshToWorld; // u_mtxModel

layout(std140) uniform Camera {
  mat4 u_mtxWorldToCamera; // u_mtxView
  mat4 u_mtxProjection; 
  mat4 u_mtxWorldToView; // u_mtxViewProjection
  vec3 u_vctCamera;
};

layout(location = 0) in vec3 a_vctPosition;

#if defined(TEXTURE)

  layout(location = 2) in vec2 a_vctTexture;
  out vec2 v_vctTexture;

#endif

void main() {
  gl_Position = u_mtxWorldToView * u_mtxMeshToWorld * vec4(a_vctPosition, 1.0);

  #if defined(TEXTURE)

    v_vctTexture = a_vctTexture;

  #endif
}`;
    FudgeCore.shaderSources["ShaderOutline.frag"] = /*glsl*/ `#version 300 es
/**
 * @authors Jonas Plotzky, HFU, 2025
 */
precision mediump float;
precision highp int;

uniform vec2 u_vctTexel;
uniform vec4 u_vctColor;
uniform vec4 u_vctColorOccluded;

uniform sampler2D u_texDepthOutline;
uniform sampler2D u_texDepthScene;

in vec2 v_vctTexture;
out vec4 vctFrag;

float getDepth(vec2 _vctTexture) {
  return texture(u_texDepthOutline, _vctTexture).r;
}

void main() {
  float fDepth = getDepth(v_vctTexture);

  if (fDepth != 1.0)
    discard;

  float fDepthTop = getDepth(v_vctTexture + vec2(0, u_vctTexel.y));
  float fDepthRight = getDepth(v_vctTexture + vec2(u_vctTexel.x, 0));
  float fDepthBottom = getDepth(v_vctTexture + vec2(0, -u_vctTexel.y));
  float fDepthLeft = getDepth(v_vctTexture + vec2(-u_vctTexel.x, 0));

  float fDepthMin = min(min(fDepthTop, fDepthRight), min(fDepthBottom, fDepthLeft));
  float fDepthDelta = abs(fDepth - fDepthMin);

  if (fDepthDelta == 0.0)
    discard;

  float fDepthScene = texture(u_texDepthScene, v_vctTexture).r;
  if (fDepthMin < fDepthScene)
    vctFrag = u_vctColor;
  else
    vctFrag = u_vctColorOccluded;
}`;
    FudgeCore.shaderSources["ShaderPhong.frag"] = /*glsl*/ `#version 300 es
/**
* Phong shading
* @authors Jirka Dell'Oro-Friedl, HFU, 2022 | Roland Heer, HFU, 2023 | Jonas Plotzky, HFU, 2023
*/

precision mediump float;
precision highp int;

uniform vec4 u_vctColor;
uniform float u_fDiffuse;
uniform float u_fSpecular;
uniform float u_fIntensity;
uniform float u_fMetallic;
uniform vec3 u_vctCamera;

uniform bool u_bFog;
uniform vec4 u_vctFogColor;
uniform float u_fFogNear;
uniform float u_fFogFar;

in vec4 v_vctColor;
in vec3 v_vctPosition;

layout(location = 0) out vec4 vctFrag;
layout(location = 1) out vec4 vctFragPosition;
layout(location = 2) out vec4 vctFragNormal;

#ifdef PHONG

  in vec3 v_vctNormal;

#endif

#ifdef FLAT

  flat in vec3 v_vctPositionFlat;

#endif

struct Light {
  vec4 vctColor;
  mat4 mtxShape;
  mat4 mtxShapeInverse;
};

const uint MAX_LIGHTS_DIRECTIONAL = 15u;
const uint MAX_LIGHTS_POINT = 100u;
const uint MAX_LIGHTS_SPOT = 100u;

layout(std140) uniform Lights {
  uint u_nLightsDirectional;
  uint u_nLightsPoint;
  uint u_nLightsSpot;
  uint padding; // Add padding to align to 16 bytes
  Light u_ambient;
  Light u_directional[MAX_LIGHTS_DIRECTIONAL];
  Light u_point[MAX_LIGHTS_POINT];
  Light u_spot[MAX_LIGHTS_SPOT];
};

// TEXTURE: input UVs and texture
#ifdef TEXTURE

  in vec2 v_vctTexture;
  uniform sampler2D u_texColor;

#endif

// NORMALMAP: input UVs and texture
#ifdef NORMALMAP

  in vec3 v_vctTangent;
  in vec3 v_vctBitangent;
  uniform sampler2D u_texNormal;

#endif

// Returns a vector for visualizing on model. Great for debugging
vec4 showVectorAsColor(vec3 _vector, bool _clamp) {
  if(_clamp) {
    _vector *= 0.5;
    _vector += 0.5;
  }
  return vec4(_vector.x, _vector.y, _vector.z, 1);
}

void illuminateDirected(vec3 _vctDirection, vec3 _vctView, vec3 _vctNormal, vec3 _vctColor, inout vec3 _vctDiffuse, inout vec3 _vctSpecular) {
  vec3 vctDirection = normalize(_vctDirection);
  float fIllumination = -dot(_vctNormal, vctDirection);
  if(fIllumination > 0.0) {
    _vctDiffuse += u_fDiffuse * fIllumination * _vctColor;

    if(u_fSpecular <= 0.0)
      return;
      
    //BLINN-Phong Shading
    vec3 halfwayDir = normalize(-vctDirection - _vctView);
    float factor = max(dot(-vctDirection, _vctNormal), 0.0); //Factor for smoothing out transition from surface facing the lightsource to surface facing away from the lightsource
    factor = 1.0 - (pow(factor - 1.0, 8.0));                 //The factor is altered in order to clearly see the specular highlight even at steep angles, while still preventing artifacts

    _vctSpecular += pow(max(dot(_vctNormal, halfwayDir), 0.0), exp2(u_fSpecular * 5.0)) * u_fSpecular * u_fIntensity * factor * _vctColor;
  }
}

float getFog(vec3 _vctPosition) {
  float fDistance = length(_vctPosition - u_vctCamera); // maybe use z-depth instead of euclidean depth
  float fFog = clamp((fDistance - u_fFogNear) / (u_fFogFar - u_fFogNear), 0.0, 1.0);
  fFog = -pow(fFog, 2.0) + (2.0 * fFog); // lets fog appear quicker and fall off slower results in a more gradual falloff
  return fFog;
}

void main() {
  #if defined(PHONG) && !defined(FLAT)

    #ifdef NORMALMAP

      mat3 mtxTBN = mat3(normalize(v_vctTangent), normalize(v_vctBitangent), normalize(v_vctNormal));
      vec3 vctNormal = texture(u_texNormal, v_vctTexture).xyz * 2.0 - 1.0;
      vctNormal = normalize(mtxTBN * vctNormal);

    #else

      vec3 vctNormal = normalize(v_vctNormal);

    #endif

    vec3 vctView = normalize(v_vctPosition - u_vctCamera);
    vec3 vctPosition = v_vctPosition;

  #endif

  #ifdef FLAT

    vec3 vctFdx = dFdx(v_vctPosition);
    vec3 vctFdy = dFdy(v_vctPosition);
    vec3 vctNormal = normalize(cross(vctFdx, vctFdy));
    vec3 vctView = normalize(v_vctPositionFlat - u_vctCamera);
    vec3 vctPosition = v_vctPositionFlat;

  #endif

  vec3 vctDiffuse = u_fDiffuse * u_ambient.vctColor.rgb;
  vec3 vctSpecular = vec3(0, 0, 0);

  // calculate directional light effect
  for(uint i = 0u; i < u_nLightsDirectional; i++) {
    vec3 vctDirection = vec3(u_directional[i].mtxShape * vec4(0.0, 0.0, 1.0, 1.0));
    illuminateDirected(vctDirection, vctView, vctNormal, u_directional[i].vctColor.rgb, vctDiffuse, vctSpecular);
  }

  // calculate point light effect
  for(uint i = 0u; i < u_nLightsPoint; i++) {
    vec3 vctPositionLight = vec3(u_point[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
    vec3 vctDirection = vctPosition - vctPositionLight;
    float fIntensity = 1.0 - length(mat3(u_point[i].mtxShapeInverse) * vctDirection);
    if(fIntensity < 0.0)
      continue;

    illuminateDirected(vctDirection, vctView, vctNormal, u_point[i].vctColor.rgb * fIntensity, vctDiffuse, vctSpecular);
  }

  // calculate spot light effect
  for(uint i = 0u; i < u_nLightsSpot; i++) {
    vec3 vctPositionLight = vec3(u_spot[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
    vec3 vctDirection = vctPosition - vctPositionLight;
    vec3 vctDirectionInverted = mat3(u_spot[i].mtxShapeInverse) * vctDirection;
    if(vctDirectionInverted.z <= 0.0)
      continue;

    float fIntensity = 1.0 - min(1.0, 2.0 * length(vctDirectionInverted.xy) / vctDirectionInverted.z);    //Coneshape that is brightest in the center. Possible TODO: "Variable Spotlightsoftness"
    fIntensity *= 1.0 - pow(vctDirectionInverted.z, 2.0);                                                 //Prevents harsh lighting artifacts at boundary of the given spotlight
    if(fIntensity < 0.0)
      continue;

    illuminateDirected(vctDirection, vctView, vctNormal, u_spot[i].vctColor.rgb * fIntensity, vctDiffuse, vctSpecular);
  }

  vctFrag.rgb = vctDiffuse + vctSpecular * u_fMetallic;
  vctFrag.a = 1.0;

  #ifdef TEXTURE

    vec4 vctColorTexture = texture(u_texColor, v_vctTexture);
    vctFrag *= vctColorTexture;

  #endif

  vctFrag *= u_vctColor * v_vctColor;
  vctFrag.rgb += vctSpecular * (1.0 - u_fMetallic);

  vctFragPosition = vec4(v_vctPosition, 1.0); // don't use flat here, because we want to interpolate the position
  vctFragNormal = vec4(vctNormal, 1.0);

  if (u_bFog) 
    vctFrag.rgb = mix(vctFrag.rgb, u_vctFogColor.rgb, getFog(vctPosition) * u_vctFogColor.a);

  vctFrag.rgb *= vctFrag.a;

  if(vctFrag.a < 0.01)
    discard;
}`;
    FudgeCore.shaderSources["ShaderPick.frag"] = /*glsl*/ `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
precision mediump float;
precision highp int;

uniform int u_id;
uniform int u_size;
uniform vec4 u_vctColor;
out ivec4 vctFrag;

#if defined(TEXTURE)

  uniform sampler2D u_texColor;
  in vec2 v_vctTexture;

#endif

void main() {
  int pixel = int(gl_FragCoord.x) + u_size * int(gl_FragCoord.y);

  if (pixel != u_id)
    discard;
  
  vec4 vctColor = u_vctColor;
  
  #if defined(TEXTURE)

    vctColor *= texture(u_texColor, v_vctTexture);

  #endif

  uint icolor = uint(vctColor.r * 255.0) << 24 | uint(vctColor.g * 255.0) << 16 | uint(vctColor.b * 255.0) << 8 | uint(vctColor.a * 255.0);
  
  vctFrag = ivec4(floatBitsToInt(gl_FragCoord.z), icolor, 0, 0);

  #if defined(TEXTURE)

    vctFrag.b = floatBitsToInt(v_vctTexture.x);
    vctFrag.a = floatBitsToInt(v_vctTexture.y);

  #endif
}`;
    FudgeCore.shaderSources["ShaderPick.vert"] = /*glsl*/ `#version 300 es
/**
* Renders for Raycasting
* @authors Jirka Dell'Oro-Friedl, HFU, 2019
*/
uniform mat4 u_mtxMeshToWorld; // u_mtxModel

layout(std140) uniform Camera {
  mat4 u_mtxWorldToCamera; // u_mtxView
  mat4 u_mtxProjection; 
  mat4 u_mtxWorldToView; // u_mtxViewProjection
  vec3 u_vctCamera;
};

layout(location = 0) in vec3 a_vctPosition;

#if defined(TEXTURE)

  layout(location = 2) in vec2 a_vctTexture;
  out vec2 v_vctTexture;

#endif

void main() {
  gl_Position = u_mtxWorldToView * u_mtxMeshToWorld * vec4(a_vctPosition, 1.0);

  #if defined(TEXTURE)

    v_vctTexture = a_vctTexture;

  #endif
}`;
    FudgeCore.shaderSources["ShaderScreen.vert"] = /*glsl*/ `#version 300 es
precision mediump float;
precision highp int;
/**
 * Creates a fullscreen triangle which cotains the screen quad and sets the texture coordinates accordingly.
 * @authors Roland Heer, HFU, 2023 | Jirka Dell'Oro-Friedl, HFU, 2023 | Jonas Plotzky, HFU, 2023
 *
 *  2  3 .
 *       .  .
 *       .     .  
 *       .        .
 *  1  1 ..........  .
 *       . screen .     .
 *       .  quad  .        .
 *  0 -1 ..........  .  .  .  .
 *    p -1        1           3
 *  t    0        1           2
 *  
 *  p == postion
 *  t == texture coordinate
 */

// uniform vec2 u_vctResolution;

out vec2 v_vctTexture;

// #ifdef SAMPLE

//   flat out vec2[9] v_vctOffsets;

// #endif

void main() {
  float x = float((gl_VertexID % 2) * 4); // 0, 4, 0
  float y = float((gl_VertexID / 2) * 4); // 0, 0, 4
  gl_Position = vec4(x - 1.0, y - 1.0, 0.0, 1.0); // (-1, -1), (3, -1), (-1, 3)
  v_vctTexture = vec2(x / 2.0, y / 2.0);  // (0, 0), (2, 0), (0, 2) -> interpolation will yield (0, 0), (1, 0), (0, 1) as the positions are double the size of the screen

  // #ifdef SAMPLE

  //   vec2 offset = vec2(1.0 / u_vctResolution.x, 1.0 / u_vctResolution.y);
  //   v_vctOffsets = vec2[](
  //     vec2(-offset.x, offset.y),  vec2(0.0, offset.y),  vec2(offset.x, offset.y),
  //     vec2(-offset.x, 0.0),       vec2(0.0, 0.0),       vec2(offset.x, 0.0),
  //     vec2(-offset.x, -offset.y), vec2(0.0, -offset.y),  vec2(offset.x, -offset.y)
  //   );

  // #endif
}`;
    FudgeCore.shaderSources["ShaderUniversal.frag"] = /*glsl*/ `#version 300 es
/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors Jirka Dell'Oro-Friedl, HFU, 2021 | Jonas Plotzky, HFU, 2023
*/
precision mediump float;
precision highp int;

layout(std140) uniform Node {
  uniform mat4 u_mtxMeshToWorld; // u_mtxModel
  uniform mat3 u_mtxPivot; // texture pivot matrix
  uniform vec4 u_vctColorPrimary; // component material color

  uniform uint u_iBlendMode;
  uniform float u_fParticleSystemDuration;
  uniform float u_fParticleSystemSize;
  uniform float u_fParticleSystemTime;

  uniform bool u_bFaceCameraActive;
  uniform bool u_bFaceCameraRestrict;
};

layout(std140) uniform Camera {
  mat4 u_mtxWorldToCamera; // u_mtxView
  mat4 u_mtxProjection; 
  mat4 u_mtxWorldToView; // u_mtxViewProjection
  vec3 u_vctCamera;
};

layout(std140) uniform Material {
  uniform vec4 u_vctColor;

  uniform float u_fDiffuse;
  uniform float u_fSpecular;
  uniform float u_fIntensity;
  uniform float u_fMetallic;

  uniform float u_fAlphaClip;
};

layout(std140) uniform Fog {
  bool u_bFogActive;
  float u_fFogNear;
  float u_fFogFar;
  float fogPadding; // add padding to align to 16 bytes
  vec4 u_vctFogColor;
};

in vec3 v_vctPosition;
in vec4 v_vctColor;

layout(location = 0) out vec4 vctFrag;
layout(location = 1) out vec4 vctFragPosition; // TODO: make these optional?
layout(location = 2) out vec4 vctFragNormal;

#if defined(FLAT) || defined(GOURAUD) || defined(PHONG)

  in vec3 v_vctNormal;

#endif

#if defined(FLAT)

  flat in vec3 v_vctPositionFlat;

#endif

#if defined(GOURAUD)

  in vec3 v_vctDiffuse;
  in vec3 v_vctSpecular;

#endif

#if defined(TOON)

  uniform sampler2D u_texToon;

#endif

#if defined(PHONG) || defined(FLAT)

  struct Light {
    vec4 vctColor;
    mat4 mtxShape;
    mat4 mtxShapeInverse;
  };

  #define MAX_LIGHTS_DIRECTIONAL 15u
  #define MAX_LIGHTS_POINT 100u
  #define MAX_LIGHTS_SPOT 100u

  layout(std140) uniform Lights { // TODO: put ambient color in header
    uint u_nLightsDirectional;
    uint u_nLightsPoint;
    uint u_nLightsSpot;
    vec4 u_vctAmbientColor; 

    Light u_directional[MAX_LIGHTS_DIRECTIONAL];
    Light u_point[MAX_LIGHTS_POINT];
    Light u_spot[MAX_LIGHTS_SPOT];
  };

  /**
   * _vctLight: direction from position to light
   * _vctView: direction from position to camera
   * _vctNormal: surface normal at position
   * _vctColor: color of the light
   */
  void illuminateDirected(vec3 _vctLightDirection, vec3 _vctViewDirection, vec3 _vctNormal, vec3 _vctColor, inout vec3 _vctDiffuse, inout vec3 _vctSpecular) {
    vec3 vctLightDirection = normalize(_vctLightDirection);

    float fDiffuse = dot(_vctNormal, vctLightDirection);

    if(fDiffuse > 0.0) {

      #if defined(TOON)
      
        fDiffuse = texture(u_texToon, vec2(fDiffuse, 0)).r;

      #endif

      _vctDiffuse += u_fDiffuse * fDiffuse * _vctColor;

      if(u_fSpecular <= 0.0 || u_fIntensity <= 0.0)
        return;
      
      //BLINN-Phong Shading
      vec3 halfwayDir = normalize(vctLightDirection + _vctViewDirection);
      float factor = fDiffuse;                  // Factor for smoothing out transition from surface facing the lightsource to surface facing away from the lightsource
      factor = 1.0 - (pow(factor - 1.0, 8.0));  // The factor is altered in order to clearly see the specular highlight even at steep angles, while still preventing artifacts

      float fSpecular = pow(max(dot(_vctNormal, halfwayDir), 0.0), exp2(u_fSpecular * 5.0)) * factor; // TODO: remove magic numbers?

      #if defined(TOON)
        
        fSpecular = texture(u_texToon, vec2(fSpecular, 0.0)).g * fDiffuse;

      #endif

      _vctSpecular += fSpecular * u_fIntensity * _vctColor;
    }
  }

#endif

#if defined(TEXTURE) || defined(MATCAP)

  uniform sampler2D u_texColor;
  in vec2 v_vctTexture;

#endif

#if defined(NORMALMAP)

  uniform sampler2D u_texNormal;
  in vec3 v_vctTangent;
  in vec3 v_vctBitangent;

#endif

float getFog(vec3 _vctPosition) {
  float fDistance = length(_vctPosition - u_vctCamera); // maybe use z-depth instead of euclidean depth
  float fFog = clamp((fDistance - u_fFogNear) / (u_fFogFar - u_fFogNear), 0.0, 1.0);
  fFog = -pow(fFog, 2.0) + (2.0 * fFog); // lets fog appear quicker and fall off slower results in a more gradual falloff
  return fFog * u_vctFogColor.a;
}

void main() {

  #if defined(FLAT)

    vec3 vctFdx = dFdx(v_vctPosition);
    vec3 vctFdy = dFdy(v_vctPosition);
    vec3 vctNormal = normalize(cross(vctFdx, vctFdy));
    vec3 vctViewDirection = normalize(u_vctCamera - v_vctPositionFlat);
    vec3 vctPosition = v_vctPositionFlat;

  #endif

  #if (defined(PHONG) || defined(GOURAUD)) && !defined(NORMALMAP)

    vec3 vctNormal = normalize(v_vctNormal);

  #endif

  #if defined(PHONG)

    vec3 vctViewDirection = normalize(u_vctCamera - v_vctPosition);
    vec3 vctPosition = v_vctPosition;

  #endif

  #if defined(NORMALMAP)

    mat3 mtxTBN = mat3(normalize(v_vctTangent), normalize(v_vctBitangent), normalize(v_vctNormal));
    vec3 vctNormal = texture(u_texNormal, v_vctTexture).xyz * 2.0 - 1.0;
    vctNormal = normalize(mtxTBN * vctNormal);

  #endif
  
  #if defined(FLAT) || defined(PHONG)

    vec3 vctDiffuse = u_fDiffuse * u_vctAmbientColor.rgb;
    vec3 vctSpecular = vec3(0, 0, 0);

    // directional lights
    for(uint i = 0u; i < u_nLightsDirectional; i++) {
      vec3 vctLightDirection = vec3(u_directional[i].mtxShape * vec4(0.0, 0.0, -1.0, 1.0));
      illuminateDirected(vctLightDirection, vctViewDirection, vctNormal, u_directional[i].vctColor.rgb, vctDiffuse, vctSpecular);
    }

    // point lights
    for(uint i = 0u; i < u_nLightsPoint; i++) {
      vec3 vctLightPosition = vec3(u_point[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
      vec3 vctLightDirection = vctLightPosition - vctPosition;
      float fIntensity = 1.0 - length(mat3(u_point[i].mtxShapeInverse) * vctLightDirection);
      if(fIntensity < 0.0)
        continue;

      illuminateDirected(vctLightDirection, vctViewDirection, vctNormal, u_point[i].vctColor.rgb * fIntensity, vctDiffuse, vctSpecular);
    }

    // spot lights
    for(uint i = 0u; i < u_nLightsSpot; i++) {
      vec3 vctLightPosition = vec3(u_spot[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
      vec3 vctLightDirection = vctLightPosition - vctPosition;
      vec3 vctLightDirectionInverted = mat3(u_spot[i].mtxShapeInverse) * -vctLightDirection;
      if(vctLightDirectionInverted.z <= 0.0)
        continue;

      float fIntensity = 1.0 - min(1.0, 2.0 * length(vctLightDirectionInverted.xy) / vctLightDirectionInverted.z);    // Coneshape that is brightest in the center. Possible TODO: "Variable Spotlightsoftness"
      fIntensity *= 1.0 - pow(vctLightDirectionInverted.z, 2.0);                                                      // Prevents harsh lighting artifacts at boundary of the given spotlight
      if(fIntensity < 0.0)
        continue;

      illuminateDirected(vctLightDirection, vctViewDirection, vctNormal, u_spot[i].vctColor.rgb * fIntensity, vctDiffuse, vctSpecular);
    }

  #endif

  vec4 vctColor = u_vctColor * u_vctColorPrimary * v_vctColor;

  #if defined(GOURAUD)

    vec3 vctDiffuse = v_vctDiffuse;
    vec3 vctSpecular = v_vctSpecular;

  #endif

  #if defined(FLAT) || defined(GOURAUD) || defined(PHONG)

    vctFrag.rgb = vctDiffuse + vctSpecular * u_fMetallic;
    vctFrag.a = 1.0;

  #else

    // MINIMAL: set the base color
    vctFrag = vctColor;

  #endif

  #if defined(TEXTURE) || defined(MATCAP)
    
    // TEXTURE: multiply with texel color
    vec4 vctColorTexture = texture(u_texColor, v_vctTexture); // has premultiplied alpha by webgl for correct filtering
    if (vctColorTexture.a > 0.0) // unpremultiply alpha
      vctColorTexture.rgb /= vctColorTexture.a; 
    vctFrag *= vctColorTexture;

  #endif

  #if defined(FLAT) || defined(GOURAUD) || defined(PHONG)

    vctFrag *= vctColor;
    vctFrag.rgb += vctSpecular * (1.0 - u_fMetallic);

    vctFragPosition = vec4(v_vctPosition, 1.0);
    vctFragNormal = vec4(vctNormal, 1.0);
  
  #endif

  #if !defined(PHONG) && !defined(FLAT) && !defined(GOURAUD) // MINIMAL

    vctFragPosition = vec4(0.0, 0.0, 0.0, 1.0); // (0, 0, 0) will treat occluders as non existing in ssao
    vctFragNormal = vec4(0.0, 0.0, 0.0, 1.0); // (0, 0, 0) normal will yield not occlusion in ssao
  
  #endif

  // discard pixel alltogether when transparent: don't show in Z-Buffer
  if(vctFrag.a < u_fAlphaClip)
    discard;

  if (u_bFogActive) {
    float fFog = getFog(v_vctPosition);
    vctFrag.rgb = mix(vctFrag.rgb, u_vctFogColor.rgb, fFog);

    #if defined(PARTICLE)

      if (u_iBlendMode == 2u || u_iBlendMode == 3u || u_iBlendMode == 4u)  // for blend additive, subtractive, modulate
        vctFrag.a = mix(vctFrag.a, 0.0, fFog);                          // fade out particle when in fog to make it disappear completely

    #endif
  }
}`;
    FudgeCore.shaderSources["ShaderUniversal.vert"] = /*glsl*/ `#version 300 es
/**
* Universal Shader as base for many others. Controlled by compiler directives
* @authors 2021, Luis Keck, HFU, 2021 | Jirka Dell'Oro-Friedl, HFU, 2021 | Jonas Plotzky, HFU, 2023
*/
precision mediump float;
precision highp int;

layout(std140) uniform Node {
  uniform mat4 u_mtxMeshToWorld; // u_mtxModel
  uniform mat3 u_mtxPivot; // texture pivot matrix
  uniform vec4 u_vctColorPrimary; // component material color

  uniform uint u_iBlendMode;
  uniform float u_fParticleSystemDuration;
  uniform float u_fParticleSystemSize;
  uniform float u_fParticleSystemTime;

  uniform bool u_bFaceCameraActive;
  uniform bool u_bFaceCameraRestrict;
};

layout(std140) uniform Camera {
  mat4 u_mtxWorldToCamera; // u_mtxView
  mat4 u_mtxProjection; 
  mat4 u_mtxWorldToView; // u_mtxViewProjection
  vec3 u_vctCamera;
};

layout(std140) uniform Material {
  uniform vec4 u_vctColor;

  uniform float u_fDiffuse;
  uniform float u_fSpecular;
  uniform float u_fIntensity;
  uniform float u_fMetallic;

  uniform float u_fAlphaClip;
};

layout(location = 0) in vec3 a_vctPosition;
layout(location = 3) in vec4 a_vctColor; // TODO: think about making vertex color optional

out vec3 v_vctPosition;
out vec4 v_vctColor;

#if defined(FLAT) || defined(GOURAUD) || defined(PHONG)

  layout(location = 1) in vec3 a_vctNormal;
  out vec3 v_vctNormal;

#endif

#if defined(FLAT)

  flat out vec3 v_vctPositionFlat;

#endif

#if defined(GOURAUD)

  out vec3 v_vctDiffuse;
  out vec3 v_vctSpecular;

  struct Light {
    vec4 vctColor;
    mat4 mtxShape;
    mat4 mtxShapeInverse;
  };

  #define MAX_LIGHTS_DIRECTIONAL 15u
  #define MAX_LIGHTS_POINT 100u
  #define MAX_LIGHTS_SPOT 100u

  layout(std140) uniform Lights { // TODO: put ambient color in header
    uint u_nLightsDirectional;
    uint u_nLightsPoint;
    uint u_nLightsSpot;
    vec4 u_vctAmbientColor;

    Light u_directional[MAX_LIGHTS_DIRECTIONAL];
    Light u_point[MAX_LIGHTS_POINT];
    Light u_spot[MAX_LIGHTS_SPOT];
  };

  void illuminateDirected(vec3 _vctDirection, vec3 _vctView, vec3 _vctNormal, vec3 _vctColor, inout vec3 _vctDiffuse, inout vec3 _vctSpecular) {
    vec3 vctDirection = normalize(_vctDirection);
    float fIllumination = -dot(_vctNormal, vctDirection);
    if(fIllumination > 0.0) {
      _vctDiffuse += u_fDiffuse * fIllumination * _vctColor;

      if(u_fSpecular <= 0.0)
        return;

      //BLINN
      vec3 halfwayDir = normalize(-vctDirection - _vctView);
      float factor = max(dot(-vctDirection, _vctNormal), 0.0); //Factor for smoothing out transition from surface facing the lightsource to surface facing away from the lightsource
      factor = 1.0 - (pow(factor - 1.0, 8.0));                 //The factor is altered in order to clearly see the specular highlight even at steep angles, while still preventing artifacts

      _vctSpecular += pow(max(dot(_vctNormal, halfwayDir), 0.0), exp2(u_fSpecular * 5.0)) * u_fSpecular * u_fIntensity * factor * _vctColor;

      //PHONG (old)
      // vec3 vctReflection = normalize(reflect(-vctDirection, _vctNormal));
      // float fHitCamera = dot(vctReflection, _vctView);
      // _vctSpecular += pow(max(fHitCamera, 0.0), u_fSpecular * 10.0) * u_fSpecular * _vctColor; // 10.0 = magic number, looks good... 
    }
  }

#endif

#if defined(TEXTURE) || defined(NORMALMAP)

  layout(location = 2) in vec2 a_vctTexture;
  out vec2 v_vctTexture;

#endif

#if defined(NORMALMAP)

  layout(location = 4) in vec4 a_vctTangent;
  out vec3 v_vctTangent;
  out vec3 v_vctBitangent;

#endif

// MATCAP: offer buffers for UVs and pivot matrix
#if defined(MATCAP) // MatCap-shader generates texture coordinates from surface normals

  layout(location = 1) in vec3 a_vctNormal;
  out vec2 v_vctTexture;

#endif

#if defined(SKIN)

  // Bones https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl.js
  layout(location = 5) in uvec4 a_vctBones;
  layout(location = 6) in vec4 a_vctWeights;

  const uint MAX_BONES = 256u; // CAUTION: this number must be the same as in RenderInjectorSkeletonInstance where the corresponding buffers are created
  layout(std140) uniform Skin {
    mat4 u_mtxBones[MAX_BONES];
  };

#endif

#if defined(PARTICLE)

  uniform sampler2D u_particleSystemRandomNumbers;

  float fetchRandomNumber(int _iOffset, int _iParticleSystemRandomNumbersSize, int _iParticleSystemRandomNumbersLength) {
    _iOffset = gl_InstanceID + _iOffset % _iParticleSystemRandomNumbersLength;
    return texelFetch(u_particleSystemRandomNumbers, ivec2(_iOffset % _iParticleSystemRandomNumbersSize, _iOffset / _iParticleSystemRandomNumbersSize), 0).r;
  }

#endif

mat4 lookAtCamera(mat4 _mtxWorld, bool _bRestrict) {
  vec3 vctUp = vec3(0.0, 1.0, 0.0);

  vec3 vctPosition = _mtxWorld[3].xyz;

  // vec3 zAxis = normalize(u_vctCamera - vctPosition); // look at camera position
  vec3 zAxis = normalize(-vec3(u_mtxWorldToCamera[0].z, u_mtxWorldToCamera[1].z, u_mtxWorldToCamera[2].z)); // look in camera direction

  vec3 xAxis = normalize(cross(vctUp, zAxis));
  vec3 yAxis = _bRestrict ? vctUp : normalize(cross(zAxis, xAxis));
  zAxis = _bRestrict ? normalize(cross(xAxis, vctUp)) : zAxis;

  vec3 vctScale = vec3(length(_mtxWorld[0].xyz), length(_mtxWorld[1].xyz), length(_mtxWorld[2].xyz));

  mat4 billboardMatrix = mat4(
    vec4(xAxis * vctScale.x, 0.0),
    vec4(yAxis * vctScale.y, 0.0),
    vec4(zAxis * vctScale.z, 0.0),
    vec4(vctPosition, 1.0)
  );

  return billboardMatrix;
}

void main() {

  vec4 vctPosition = vec4(a_vctPosition, 1.0);
  mat4 mtxMeshToWorld = u_mtxMeshToWorld;

  // if (u_bBillboardActive) 
  //   mtxMeshToWorld = lookAtCamera(mtxMeshToWorld, u_bBillboardRestrict);

  #if defined(PARTICLE)
  
    float fParticleId = float(gl_InstanceID);
    int iParticleSystemRandomNumbersSize = textureSize(u_particleSystemRandomNumbers, 0).x; // the dimension of the quadratic texture
    int iParticleSystemRandomNumbersLength = iParticleSystemRandomNumbersSize * iParticleSystemRandomNumbersSize; // the total number of texels in the texture
    /*$variables*/
    /*$mtxLocal*/
    /*$mtxWorld*/
    mtxMeshToWorld = /*$mtxWorld*/ mtxMeshToWorld /*$mtxLocal*/;
    if(u_bFaceCameraActive) 
      mtxMeshToWorld = lookAtCamera(mtxMeshToWorld, u_bFaceCameraRestrict);

  #endif

  #if defined(SKIN)

    mtxMeshToWorld = a_vctWeights.x * u_mtxBones[a_vctBones.x] +
      a_vctWeights.y * u_mtxBones[a_vctBones.y] +
      a_vctWeights.z * u_mtxBones[a_vctBones.z] +
      a_vctWeights.w * u_mtxBones[a_vctBones.w];

  #endif

  mat4 mtxMeshToView = u_mtxWorldToView * mtxMeshToWorld;

  #if defined(FLAT) || defined(GOURAUD) || defined(PHONG) || defined(MATCAP) // only these work with particle and skinning

    mat4 mtxNormalMeshToWorld = transpose(inverse(mtxMeshToWorld));

  #endif

  gl_Position = mtxMeshToView * vctPosition; 
  vctPosition = mtxMeshToWorld * vctPosition;

  v_vctColor = a_vctColor;
  v_vctPosition = vctPosition.xyz;

  #if defined(PARTICLE_COLOR)

    v_vctColor *= /*$color*/;

  #endif

  #if defined(FLAT)

    v_vctPositionFlat = v_vctPosition;
    
  #endif

  #if defined(FLAT) || defined(GOURAUD) || defined(PHONG)

    v_vctNormal = mat3(mtxNormalMeshToWorld) * a_vctNormal; // unnormalized as it must be normalized in the fragment shader anyway

  #endif 

  #if defined(NORMALMAP)

    v_vctTangent = mat3(mtxNormalMeshToWorld) * a_vctTangent.xyz;
    v_vctBitangent = cross(v_vctNormal, v_vctTangent) * a_vctTangent.w;

  #endif

  #if defined(GOURAUD)
  
    vec3 vctView = normalize(vctPosition.xyz - u_vctCamera);
    vec3 vctNormal = normalize(v_vctNormal);
    v_vctDiffuse = u_fDiffuse * u_vctAmbientColor.rgb;
    v_vctSpecular = vec3(0, 0, 0);

    // calculate directional light effect
    for(uint i = 0u; i < u_nLightsDirectional; i ++) {
      vec3 vctDirection = vec3(u_directional[i].mtxShape * vec4(0.0, 0.0, 1.0, 1.0));
      illuminateDirected(vctDirection, vctView, vctNormal, u_directional[i].vctColor.rgb, v_vctDiffuse, v_vctSpecular);
    }

    // calculate point light effect
    for(uint i = 0u;i < u_nLightsPoint;i ++) {
      vec3 vctPositionLight = vec3(u_point[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
      vec3 vctDirection = vctPosition.xyz - vctPositionLight;
      float fIntensity = 1.0 - length(mat3(u_point[i].mtxShapeInverse) * vctDirection);
      if(fIntensity < 0.0) continue;

      illuminateDirected(vctDirection, vctView, vctNormal, u_point[i].vctColor.rgb * fIntensity, v_vctDiffuse, v_vctSpecular);
    }

    // calculate spot light effect
    for(uint i = 0u;i < u_nLightsSpot;i ++) {
      vec3 vctPositionLight = vec3(u_spot[i].mtxShape * vec4(0.0, 0.0, 0.0, 1.0));
      vec3 vctDirection = vctPosition.xyz - vctPositionLight;
      vec3 vctDirectionInverted = mat3(u_spot[i].mtxShapeInverse) * vctDirection;
      if(vctDirectionInverted.z <= 0.0) continue;

      float fIntensity = 1.0 - min(1.0, 2.0 * length(vctDirectionInverted.xy) / vctDirectionInverted.z);    //Coneshape that is brightest in the center. Possible TODO: "Variable Spotlightsoftness"
      fIntensity *= 1.0 - pow(vctDirectionInverted.z, 2.0);                                                 //Prevents harsh lighting artifacts at boundary of the given spotlight
      if(fIntensity < 0.0) continue;

      illuminateDirected(vctDirection, vctView, vctNormal, u_spot[i].vctColor.rgb * fIntensity, v_vctDiffuse, v_vctSpecular);
    }

  #endif

    // TEXTURE: transform UVs
  #if defined(TEXTURE) || defined(NORMALMAP)

    v_vctTexture = vec2(u_mtxPivot * vec3(a_vctTexture, 1.0)).xy;

  #endif

  #if defined(MATCAP)

    vec4 vctVertexInCamera = normalize(u_mtxWorldToCamera * vctPosition);
    vctVertexInCamera.xy *= - 1.0;
    mat4 mtx_RotX = mat4(1, 0, 0, 0, 0, vctVertexInCamera.z, vctVertexInCamera.y, 0, 0, - vctVertexInCamera.y, vctVertexInCamera.z, 0, 0, 0, 0, 1);
    mat4 mtx_RotY = mat4(vctVertexInCamera.z, 0, - vctVertexInCamera.x, 0, 0, 1, 0, 0, vctVertexInCamera.x, 0, vctVertexInCamera.z, 0, 0, 0, 0, 1);

    vec3 vctNormal = mat3(mtxNormalMeshToWorld) * a_vctNormal;

    // adds correction for things being far and to the side, but distortion for things being close
    vctNormal = mat3(mtx_RotX * mtx_RotY) * vctNormal;

    vec3 vctReflection = normalize(mat3(u_mtxWorldToCamera) * normalize(vctNormal));
    vctReflection.y = - vctReflection.y;

    v_vctTexture = 0.5 * vctReflection.xy + 0.5;

  #endif
}`;
})(FudgeCore || (FudgeCore = {}));
// / <reference path="../Coat/Coat.ts"/>
var FudgeCore;
// / <reference path="../Coat/Coat.ts"/>
(function (FudgeCore) {
    /**
     * Static superclass for the representation of WebGl shaderprograms.
     * @authors Jascha Karag√∂l, HFU, 2019 | Jirka Dell'Oro-Friedl, HFU, 2019
     */
    // TODO: define uniforms as layout and use those consistently in shaders
    let Shader = (() => {
        var _a;
        let _classDecorators = [(_a = FudgeCore.RenderInjectorShader).decorate.bind(_a)];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        var Shader = class {
            static { _classThis = this; }
            static {
                const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
                __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                Shader = _classThis = _classDescriptor.value;
                if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            }
            /** refers back to this class from any subclass e.g. in order to find compatible other resources*/
            static { this.baseClass = Shader; }
            /** list of all the subclasses derived from this class, if they registered properly*/
            static { this.subclasses = []; }
            /** The type of coat that can be used with this shader to create a material */
            static getCoat() { return FudgeCore.CoatColored; }
            /** Returns the vertex shader source code for the render engine */
            static getVertexShaderSource() {
                return this.insertDefines(FudgeCore.shaderSources["ShaderUniversal.vert"], this.define);
            }
            /** Returns the fragment shader source code for the render engine */
            static getFragmentShaderSource() {
                return this.insertDefines(FudgeCore.shaderSources["ShaderUniversal.frag"], this.define);
            }
            /** @internal Injected by {@link RenderInjectorShader}. Used by the render system. */
            static deleteProgram() { }
            /** @internal Injected by {@link RenderInjectorShader}. Used by the render system. */
            static useProgram() { }
            /** @internal Injected by {@link RenderInjectorShader}. Used by the render system. */ // TODO: maybe don't flag this as internal, so shaders can be precompiled in future FUDGE apps. Or create an API to precompile shaders, load textures etc.
            static createProgram() { }
            static registerSubclass(_subclass) { return Shader.subclasses.push(_subclass) - 1; }
            // replace the mandatory header of the shader with itself plus the definitions given
            static insertDefines(_shader, _defines) {
                if (!_defines)
                    return _shader;
                let code = "#version 300 es\n";
                for (let define of _defines)
                    code += `#define ${define}\n`;
                return _shader.replace("#version 300 es", code);
            }
            static {
                __runInitializers(_classThis, _classExtraInitializers);
            }
        };
        return Shader = _classThis;
    })();
    FudgeCore.Shader = Shader;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderAmbientOcclusion extends FudgeCore.Shader {
        static { this.define = []; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderScreen.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderAmbientOcclusion.frag"], this.define);
        }
    }
    FudgeCore.ShaderAmbientOcclusion = ShaderAmbientOcclusion;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderBloom extends FudgeCore.Shader {
        static { this.define = []; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderScreen.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderBloom.frag"], this.define);
        }
    }
    FudgeCore.ShaderBloom = ShaderBloom;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderFlat extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlat); }
        static { this.define = [
            "FLAT"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
    }
    FudgeCore.ShaderFlat = ShaderFlat;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderFlatSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlatSkin); }
        static { this.define = [
            "FLAT",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
    }
    FudgeCore.ShaderFlatSkin = ShaderFlatSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderFlatTextured extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlatTextured); }
        static { this.define = [
            "FLAT",
            "TEXTURE"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
    }
    FudgeCore.ShaderFlatTextured = ShaderFlatTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderFlatTexturedSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderFlatTexturedSkin); }
        static { this.define = [
            "FLAT",
            "TEXTURE",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
    }
    FudgeCore.ShaderFlatTexturedSkin = ShaderFlatTexturedSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGizmo extends FudgeCore.Shader {
        static { this.define = []; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderGizmo.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderGizmo.frag"], this.define);
        }
    }
    FudgeCore.ShaderGizmo = ShaderGizmo;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGizmoTextured extends FudgeCore.Shader {
        static { this.define = ["TEXTURE"]; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderGizmo.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderGizmo.frag"], this.define);
        }
    }
    FudgeCore.ShaderGizmoTextured = ShaderGizmoTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGouraud extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraud); }
        static { this.define = [
            "GOURAUD"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
    }
    FudgeCore.ShaderGouraud = ShaderGouraud;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGouraudSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraudSkin); }
        static { this.define = [
            "GOURAUD",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
    }
    FudgeCore.ShaderGouraudSkin = ShaderGouraudSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGouraudTextured extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraudTextured); }
        static { this.define = [
            "GOURAUD",
            "TEXTURE"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
    }
    FudgeCore.ShaderGouraudTextured = ShaderGouraudTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderGouraudTexturedSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderGouraudTexturedSkin); }
        static { this.define = [
            "GOURAUD",
            "TEXTURE",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
    }
    FudgeCore.ShaderGouraudTexturedSkin = ShaderGouraudTexturedSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderLit extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLit); }
        static { this.define = []; }
    }
    FudgeCore.ShaderLit = ShaderLit;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderLitSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLitSkin); }
        static { this.define = [
            "SKIN"
        ]; }
    }
    FudgeCore.ShaderLitSkin = ShaderLitSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderLitTextured extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLitTextured); }
        static { this.define = [
            "TEXTURE"
        ]; }
        static getCoat() { return FudgeCore.CoatTextured; }
    }
    FudgeCore.ShaderLitTextured = ShaderLitTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderLitTexturedSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderLitTexturedSkin); }
        static { this.define = [
            "TEXTURE",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatTextured; }
    }
    FudgeCore.ShaderLitTexturedSkin = ShaderLitTexturedSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderMatCap extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderMatCap); }
        static { this.define = [
            "MATCAP"
        ]; }
        static getCoat() { return FudgeCore.CoatTextured; }
    }
    FudgeCore.ShaderMatCap = ShaderMatCap;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderOutline extends FudgeCore.Shader {
        static { this.define = []; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderScreen.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderOutline.frag"], this.define);
        }
    }
    FudgeCore.ShaderOutline = ShaderOutline;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhong extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhong); }
        static { this.define = [
            "PHONG"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
    }
    FudgeCore.ShaderPhong = ShaderPhong;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhongSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhongSkin); }
        static { this.define = [
            "PHONG",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissive; }
    }
    FudgeCore.ShaderPhongSkin = ShaderPhongSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhongTextured extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhongTextured); }
        static { this.define = [
            "PHONG",
            "TEXTURE"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
    }
    FudgeCore.ShaderPhongTextured = ShaderPhongTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhongTexturedNormals extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhongTexturedNormals); }
        static { this.define = [
            "PHONG",
            "TEXTURE",
            "NORMALMAP"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTexturedNormals; }
    }
    FudgeCore.ShaderPhongTexturedNormals = ShaderPhongTexturedNormals;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhongTexturedNormalsSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhongTexturedNormalsSkin); }
        static { this.define = [
            "PHONG",
            "TEXTURE",
            "NORMALMAP",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTexturedNormals; }
    }
    FudgeCore.ShaderPhongTexturedNormalsSkin = ShaderPhongTexturedNormalsSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPhongTexturedSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderPhongTexturedSkin); }
        static { this.define = [
            "PHONG",
            "TEXTURE",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatRemissiveTextured; }
    }
    FudgeCore.ShaderPhongTexturedSkin = ShaderPhongTexturedSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPick extends FudgeCore.Shader {
        static { this.define = []; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPick.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPick.frag"], this.define);
        }
    }
    FudgeCore.ShaderPick = ShaderPick;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderPickTextured extends FudgeCore.Shader {
        static { this.define = ["TEXTURE"]; }
        static getVertexShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPick.vert"], this.define);
        }
        static getFragmentShaderSource() {
            return this.insertDefines(FudgeCore.shaderSources["ShaderPick.frag"], this.define);
        }
    }
    FudgeCore.ShaderPickTextured = ShaderPickTextured;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class ShaderToon extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderToon); }
        static { this.define = [
            "PHONG",
            "TOON"
        ]; }
        static getCoat() { return FudgeCore.CoatToon; }
    }
    FudgeCore.ShaderToon = ShaderToon;
    class ShaderToonSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderToonSkin); }
        static { this.define = [
            "PHONG",
            "TOON",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatToon; }
    }
    FudgeCore.ShaderToonSkin = ShaderToonSkin;
    class ShaderToonTextured extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderToonTextured); }
        static { this.define = [
            "PHONG",
            "TOON",
            "TEXTURE"
        ]; }
        static getCoat() { return FudgeCore.CoatToonTextured; }
    }
    FudgeCore.ShaderToonTextured = ShaderToonTextured;
    class ShaderToonTexturedSkin extends FudgeCore.Shader {
        static { this.iSubclass = FudgeCore.Shader.registerSubclass(ShaderToonTexturedSkin); }
        static { this.define = [
            "PHONG",
            "TOON",
            "TEXTURE",
            "SKIN"
        ]; }
        static getCoat() { return FudgeCore.CoatToonTextured; }
    }
    FudgeCore.ShaderToonTexturedSkin = ShaderToonTexturedSkin;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    class TextureDefault extends FudgeCore.TextureBase64 {
        static { this.color = new TextureDefault("TextureDefault", TextureDefault.getColor(), FudgeCore.MIPMAP.MEDIUM); }
        static { this.normal = new TextureDefault("TextureNormalDefault", TextureDefault.getNormal(), FudgeCore.MIPMAP.MEDIUM); }
        static { this.toon = new TextureDefault("TextureToonDefault", TextureDefault.getToon(), FudgeCore.MIPMAP.SMOOTH, FudgeCore.WRAP.CLAMP); }
        // TODO: maybe make these lazy
        static { this.iconLight = new TextureDefault("IconDefaultLight", TextureDefault.getIconLight(), FudgeCore.MIPMAP.BLURRY, FudgeCore.WRAP.CLAMP, 256, 256); }
        static { this.iconCamera = new TextureDefault("IconDefaultCamera", TextureDefault.getIconCamera(), FudgeCore.MIPMAP.BLURRY, FudgeCore.WRAP.CLAMP, 256, 256); }
        static { this.iconAudio = new TextureDefault("IconDefaultAudio", TextureDefault.getIconAudio(), FudgeCore.MIPMAP.BLURRY, FudgeCore.WRAP.CLAMP, 256, 256); }
        // public static iconParticles: TextureBase64 = new TextureDefault("IconDefaultParticle", TextureDefault.getIconParticles(), MIPMAP.BLURRY, 256, 256);
        static getColor() {
            return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGQCAYAAACAvzbMAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAADWLSURBVHhe7d0HnFTlvf/xH9uXZYGl9yrSRJpEUexYsJIba8Re498WNcZEb+41epOIsWs0Niyxm2g0duwaewO7oqJCAGnSt7H/8304B4dldpk5Z3b3zO7nzeu85pwzM8vMs7PPb35PO61qPBZjrVq18vfiKebFR/lFRPlFQ/lFE/fyy/FvAQBICwEEABAKAQQAEAp9IBHRhhoN5RcN5RdNSyg//YzCwkJr3bq1O169erXbMoEAEhF/wNFQftFQftE09/LLzc21Ll262E9+8hMbP368VVdX2+uvv27Tp093QSTq+yeARMQfcDSUXzSUXzTNtfxycnKspKTEBg0aZEceeaQdeuihtmLFCvvss89s3rx59vjjj9vDDz8cOROJHECqqqps9uzZtmzZMlu5cqVLldq1a2d9+/Z1+1HxAYyG8ouG8ouG8osmTPnl5+db9+7dbffdd7dTTz3V1cXvvvuuvfzyyy4DkVWrVtmNN95oS5YsccdhhQ4g5eXl9uyzz9qMGTNszZo1/tkfKQIq+u29995WWlrqn00fH8BoKL9oKL9oKL9o0ik/PbZNmza2xRZb2HHHHWeTJ0+2hQsX2pNPPmmLFy/2H7XOf/7zH7v11ltdPR5FqACyYMECu+eee1KKXmvXrrX99tvPRo8e7YJKuvgARkP5RROUnz67+iKUl5dnlZWVtnz58li8dj5/0TSn8lOT1b777msXXHCBde7c2V577TV78803k77Hb7/91u644w6rqKjwz4STdgBRtqHUJ4hoChCffPKJffXVV649rX379jZgwAC3BZQuTZo0ybbbbjuXXqWDD2A0lF80Qfl17NjRjjnmGOvUqZN988039sADD7gvUk39+vn8RdOcyq9r1642depU23rrre3RRx91X3JEdbSasIqLi23YsGHuXKYCSNopgXrvg+Ch/o/77rvPvVi9+J///Od29NFH29ChQ90LDGj4mNIlBZm4/8LQssycOdM1xb766qtJm2JF2UfPnj3t17/+tU2YMMF23XVXO/bYY11QQfM1f/58u+mmm1zfgfp44071sV6zPstB8FA9rC/8Tz31lOsXybS0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";
        }
        static getNormal() {
            return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAFDmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgeG1wOkNyZWF0ZURhdGU9IjIwMjMtMDUtMDZUMjI6Mjg6MDYrMDIwMCIKICAgeG1wOk1vZGlmeURhdGU9IjIwMjMtMDUtMDZUMjI6MzA6MjErMDI6MDAiCiAgIHhtcDpNZXRhZGF0YURhdGU9IjIwMjMtMDUtMDZUMjI6MzA6MjErMDI6MDAiCiAgIHBob3Rvc2hvcDpEYXRlQ3JlYXRlZD0iMjAyMy0wNS0wNlQyMjoyODowNiswMjAwIgogICBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIgogICBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiCiAgIGV4aWY6UGl4ZWxYRGltZW5zaW9uPSIxIgogICBleGlmOlBpeGVsWURpbWVuc2lvbj0iMSIKICAgZXhpZjpDb2xvclNwYWNlPSIxIgogICB0aWZmOkltYWdlV2lkdGg9IjEiCiAgIHRpZmY6SW1hZ2VMZW5ndGg9IjEiCiAgIHRpZmY6UmVzb2x1dGlvblVuaXQ9IjIiCiAgIHRpZmY6WFJlc29sdXRpb249IjcyLzEiCiAgIHRpZmY6WVJlc29sdXRpb249IjcyLzEiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJwcm9kdWNlZCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWZmaW5pdHkgUGhvdG8gMiAyLjAuNCIKICAgICAgc3RFdnQ6d2hlbj0iMjAyMy0wNS0wNlQyMjozMDoyMSswMjowMCIvPgogICAgPC9yZGY6U2VxPgogICA8L3htcE1NOkhpc3Rvcnk+CiAgPC9yZGY6RGVzY3JpcHRpb24+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+0IgVxAAAAYBpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHPK0RRFMc/M37mR6NYKBYvDauhQYmNxcivwmKMMtjMvPml5o3Xe2/SZKtsFSU2fi34C9gqa6WIlGxZExv0nOepkcy5nXs+93vvOd17LngjWVUzy4Og5SwjPBpSZqNzStUjFVTSRAu+mGrqk9MjEUra2w0eJ151OrVKn/vXahNJUwVPtfCgqhuW8JjwxLKlO7wp3KRmYgnhY+GAIRcUvnb0uMtPDqdd/nDYiISHwNsgrKR/cfwXqxlDE5aX49eyefXnPs5L6pK5mWmJbeKtmIQZJYTCOMMM0Uc3AzL30UkPXbKiRH7wO3+KJclVZdYpYLBImgwWAVHzUj0pMSV6UkaWgtP/v301U709bvW6EFQ82PZLO1RtwOe6bb/v2/bnAZTdw1mumL+0B/2voq8XNf8u+Fbh5LyoxbfgdA2a7/SYEfuWysS9qRQ8H0F9FBovoWbe7dnPPoe3EFmRr7qA7R3okPO+hS824WfQgxGCcgAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAxJREFUCJljaGj4DwADgwIAVbjWPwAAAABJRU5ErkJggg==";
        }
        static getToon() {
            return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAP8AAAABCAYAAAARkHijAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV/TSotUBO0g4pChOtlFRRxLFYtgobQVWnUwufQLmjQkKS6OgmvBwY/FqoOLs64OroIg+AHi7OCk6CIl/i8ptIjx4Lgf7+497t4BQqvGVDMQB1TNMjLJhJgvrIrBVwQRQBghDEnM1FPZxRw8x9c9fHy9i/Es73N/jgGlaDLAJxLHmW5YxBvEs5uWznmfOMIqkkJ8Tjxp0AWJH7kuu/zGueywwDMjRi4zTxwhFss9LPcwqxgq8QxxVFE1yhfyLiuctzirtQbr3JO/MFzUVrJcpzmGJJaQQhoiZDRQRQ0WYrRqpJjI0H7Cwz/q+NPkkslVBSPHAupQITl+8D/43a1Zmp5yk8IJoO/Ftj/GgeAu0G7a9vexbbdPAP8zcKV1/fUWMPdJerOrRY+AwW3g4rqryXvA5Q4w8qRLhuRIfppCqQS8n9E3FYDhW6B/ze2ts4/TByBHXS3fAAeHwESZstc93h3q7e3fM53+fgA4OXKPt/7K/gAAAAZiS0dEAP8AAAAAMyd88wAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+gHBAwdJ1j9WBsAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAVUlEQVQoz2NkYGD4zzAKhh5gZWBg4GBgYOBEo2FsKJ+Xk4FBipOBQZoDQktxMjCIsDEwSHFAMReE5sVmDhcWO1gYGBgYGMlINvj0MI7wZEis/6kbhgC04Qj/w7/HZgAAAABJRU5ErkJggg==";
        }
        static getIconLight() {
            return "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3Csvg viewBox='0 0 16 16' version='1.1' width='16' height='16' id='Light' xmlns='http://www.w3.org/2000/svg'%3E%3Cstyle%3E .s%7Bfill:%23fff;stroke:%23000;stroke-width:.1px;%7D %3C/style%3E%3Crect class='s' x='0.17039293' y='10.002448' width='3.9000568' height='0.90009934' id='NNE' transform='rotate(-67.5)' /%3E%3Crect x='8.8295078' y='10.002447' width='3.9000568' height='0.90009934' id='ENE' transform='rotate(-22.5)' class='s' /%3E%3Crect x='14.952469' y='3.8795717' width='3.9000139' height='0.90009987' id='ESE' transform='rotate(22.5)' class='s' /%3E%3Crect x='14.95247' y='-4.7795429' width='3.9000139' height='0.90009987' id='SSE' transform='rotate(67.5)' class='s' /%3E%3Crect x='-12.729565' y='10.002447' width='3.9000139' height='0.90009987' id='SSW' transform='rotate(-67.5)' class='s' /%3E%3Crect x='-4.0704498' y='10.002447' width='3.9000139' height='0.90009987' id='WSW' transform='rotate(-22.5)' class='s' /%3E%3Crect x='2.0524685' y='3.8795717' width='3.9000139' height='0.90009987' id='WNW' transform='rotate(22.5)' class='s' /%3E%3Crect x='2.0524685' y='-4.7795429' width='3.9000139' height='0.90009987' id='NNW' transform='rotate(67.5)' class='s' /%3E%3Cellipse id='CENTER' cx='8.000082' cy='8.0002575' rx='3.4500823' ry='3.4502573' class='s' /%3E%3C/svg%3E";
        }
        static getIconCamera() {
            return "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3Csvg id='Camera' viewBox='0 0 16 16' version='1.1' width='16' height='16' xmlns='http://www.w3.org/2000/svg'%3E%3Cstyle id='style1'%3E.s%7Bfill:%23fff;stroke:%23000;stroke-width:.1px;%7D %3C/style%3E%3Cpath class='s' d='M 13.857322,8.8755297 H 12.413424 L 12.413,6.787 h -1.425311 c 0.227026,-0.4494693 0.363243,-0.9453919 0.363243,-1.4885008 0,-1.7978775 -1.4075727,-3.2492893 -3.1511466,-3.2492893 -1.7435746,0 -3.1511479,1.4514118 -3.1511479,3.2492893 v 0.028093 C 4.5764194,5.0363118 4.0315524,4.8583968 3.4503606,4.8583968 1.7067863,4.8677567 0.29921298,6.3191723 0.29921298,8.107686 c 0,1.7885135 1.66538582,3.311789 3.42458512,3.249289 L 3.732,13.976 h 8.681 v -2.113368 h 1.444322 z' id='path1' /%3E%3Crect class='s' x='12.80391' y='8.3979683' width='2.8968766' height='3.8860376' rx='0' ry='0' id='rect1' /%3E%3C/svg%3E%0A";
        }
        static getIconAudio() {
            return "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3Csvg id='Audio' viewBox='0 0 16 16' version='1.1' width='16' height='16' xmlns='http://www.w3.org/2000/svg'%3E%3Cstyle%3E.s%7Bfill:%23fff;stroke:%23000;stroke-width:.1px;%7D %3C/style%3E%3Cpath class='s' d='M 9.1563588,1.0804006 3.6729341,4.642017 H 0.54364971 v 6.784031 H 3.7590612 l 5.3972976,3.493776 z' id='path1' /%3E%3Cpath class='s' d='m 13.347518,13.676645 -0.765157,-0.563566 c 4.227485,-5.5605241 0.210418,-9.881202 0.03825,-10.0596648 l 0.698204,-0.6481019 c 0.04782,0.046964 4.75353,5.0627076 0.03825,11.2713327 z' id='path2' /%3E%3Cpath class='s' d='m 11.321868,11.79809 -0.822541,-0.479032 c 2.142434,-3.5786474 0.114773,-6.35891 0.02869,-6.4716232 l 0.765156,-0.5635666 c 0.105208,0.1408915 2.505883,3.3814001 0.02869,7.5048298 z' id='path3' /%3E%3C/svg%3E%0A";
        }
    }
    FudgeCore.TextureDefault = TextureDefault;
})(FudgeCore || (FudgeCore = {}));
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
var FudgeCore;
// /<reference path="../Event/Event.ts"/>
// /<reference path="../Time/Time.ts"/>
(function (FudgeCore) {
    /**
     * Determines the mode a loop runs in
     */
    let LOOP_MODE;
    (function (LOOP_MODE) {
        /** Loop cycles controlled by window.requestAnimationFrame */
        LOOP_MODE["FRAME_REQUEST"] = "frameRequest";
        /** Loop cycles controlled by xrSession.requestAnimationFrame */
        LOOP_MODE["FRAME_REQUEST_XR"] = "frameRequestXR";
        /** Loop cycles with the given framerate in {@link Time.game} */
        LOOP_MODE["TIME_GAME"] = "timeGame";
        /** Loop cycles with the given framerate in realtime, independent of {@link Time.game} */
        LOOP_MODE["TIME_REAL"] = "timeReal";
    })(LOOP_MODE = FudgeCore.LOOP_MODE || (FudgeCore.LOOP_MODE = {}));
    /**
     * Core loop of a FUDGE application. Initializes automatically and must be started explicitly.
     * It then fires {@link EVENT.LOOP_FRAME} to all added listeners at each frame
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Loop extends FudgeCore.EventTargetStatic {
        static { this.∆íTimeStartGame = 0; }
        static { this.∆íTimeStartReal = 0; }
        static { this.∆íTimeFrameGame = 0; }
        static { this.∆íTimeFrameReal = 0; }
        static { this.∆íTimeFrameStartGame = 0; }
        static { this.∆íTimeFrameStartReal = 0; }
        static { this.∆íTimeLastFrameGameAvg = 0; }
        static { this.∆íTimeLastFrameRealAvg = 0; }
        static { this.∆íFrames = 0; }
        static { this.running = false; }
        static { this.mode = LOOP_MODE.FRAME_REQUEST; }
        static { this.idIntervall = 0; }
        static { this.idRequest = 0; }
        static { this.fpsDesired = 30; }
        static { this.framesToAverage = 30; }
        static { this.syncWithAnimationFrame = false; }
        /** The gametime the loop was started, overwritten at each start */
        static get timeStartGame() { return Loop.∆íTimeStartGame; }
        /** The realtime the loop was started, overwritten at each start */
        static get timeStartReal() { return Loop.∆íTimeStartReal; }
        /** The gametime elapsed since the last loop cycle */
        static get timeFrameGame() { return Loop.∆íTimeFrameGame; }
        /** The realtime elapsed since the last loop cycle */
        static get timeFrameReal() { return Loop.∆íTimeFrameReal; }
        /** The gametime the last loop cycle started*/
        static get timeFrameStartGame() { return Loop.∆íTimeFrameStartGame; }
        /** The realtime the last loop cycle started*/
        static get timeFrameStartReal() { return Loop.∆íTimeFrameStartReal; }
        /** The average number of frames per second in gametime */
        static get fpsGameAverage() { return 1000 / Loop.∆íTimeLastFrameGameAvg; }
        /** The average number of frames per second in realtime */
        static get fpsRealAverage() { return 1000 / Loop.∆íTimeLastFrameRealAvg; }
        /** The number of frames triggered so far */
        static get frames() { return Loop.∆íFrames; }
        /**
         * Starts the loop with the given mode and fps.
         * The default for _mode is FRAME_REQUEST, see {@link LOOP_MODE}, hooking the loop to the browser's animation frame.
         * Is only applicable in TIME-modes.
         * _syncWithAnimationFrame is experimental and only applicable in TIME-modes, deferring the loop-cycle until the next possible animation frame.
         */
        static start(_mode = LOOP_MODE.FRAME_REQUEST, _fps = 60, _syncWithAnimationFrame = false) {
            Loop.stop();
            Loop.∆íTimeStartGame = FudgeCore.Time.game.get();
            Loop.∆íTimeStartReal = performance.now();
            Loop.∆íTimeFrameStartGame = Loop.∆íTimeStartGame;
            Loop.∆íTimeFrameStartReal = Loop.∆íTimeStartReal;
            Loop.fpsDesired = (_mode == LOOP_MODE.FRAME_REQUEST) ? 60 : _fps;
            Loop.framesToAverage = Loop.fpsDesired;
            Loop.∆íTimeLastFrameGameAvg = Loop.∆íTimeLastFrameRealAvg = 1000 / Loop.fpsDesired;
            Loop.mode = _mode;
            Loop.syncWithAnimationFrame = _syncWithAnimationFrame;
            let log = `Loop starting in mode ${Loop.mode}`;
            if (Loop.mode != LOOP_MODE.FRAME_REQUEST)
                log += ` with attempted ${_fps} fps`;
            FudgeCore.Debug.fudge(log);
            switch (_mode) {
                case LOOP_MODE.FRAME_REQUEST:
                    Loop.loopFrame();
                    break;
                case LOOP_MODE.FRAME_REQUEST_XR:
                    Loop.loopFrameXR();
                    break;
                case LOOP_MODE.TIME_REAL:
                    Loop.idIntervall = window.setInterval(Loop.loopTime, 1000 / Loop.fpsDesired);
                    Loop.loopTime();
                    break;
                case LOOP_MODE.TIME_GAME:
                    Loop.idIntervall = FudgeCore.Time.game.setTimer(1000 / Loop.fpsDesired, 0, Loop.loopTime);
                    Loop.loopTime();
                    break;
                default:
                    break;
            }
            Loop.running = true;
        }
        /**
         * Stops the loop
         */
        static stop() {
            if (!Loop.running)
                return;
            switch (Loop.mode) {
                case LOOP_MODE.FRAME_REQUEST:
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                case LOOP_MODE.FRAME_REQUEST_XR:
                    FudgeCore.XRViewport.default.session.cancelAnimationFrame(Loop.idRequest);
                    FudgeCore.XRViewport.default.session = null;
                    break;
                case LOOP_MODE.TIME_REAL:
                    window.clearInterval(Loop.idIntervall);
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                case LOOP_MODE.TIME_GAME:
                    FudgeCore.Time.game.deleteTimer(Loop.idIntervall);
                    window.cancelAnimationFrame(Loop.idRequest);
                    break;
                default:
                    break;
            }
            Loop.running = false;
            FudgeCore.Debug.fudge("Loop stopped!");
        }
        /**
         * Continue running the loop
         */
        static continue() {
            if (Loop.running)
                return;
            Loop.start(Loop.mode, Loop.fpsDesired, Loop.syncWithAnimationFrame);
        }
        static loop() {
            let time;
            time = performance.now();
            Loop.∆íTimeFrameReal = time - Loop.∆íTimeFrameStartReal;
            Loop.∆íTimeFrameStartReal = time;
            time = FudgeCore.Time.game.get();
            Loop.∆íTimeFrameGame = time - Loop.∆íTimeFrameStartGame;
            Loop.∆íTimeFrameStartGame = time;
            Loop.∆íTimeLastFrameGameAvg = ((Loop.framesToAverage - 1) * Loop.∆íTimeLastFrameGameAvg + Loop.∆íTimeFrameGame) / Loop.framesToAverage;
            Loop.∆íTimeLastFrameRealAvg = ((Loop.framesToAverage - 1) * Loop.∆íTimeLastFrameRealAvg + Loop.∆íTimeFrameReal) / Loop.framesToAverage;
            // TODO: consider LoopEvent which conveys information such as timeElapsed etc...
            Loop.∆íFrames++;
            const event = FudgeCore.RecyclableEvent.get("loopFrame" /* EVENT.LOOP_FRAME */);
            Loop.dispatchEvent(event);
            FudgeCore.RecyclableEvent.store(event);
        }
        static loopFrame() {
            Loop.loop();
            Loop.idRequest = window.requestAnimationFrame(Loop.loopFrame);
        }
        static loopFrameXR(_time = null, _xrFrame = null) {
            Loop.loop();
            FudgeCore.XRViewport.default.draw(true, _xrFrame);
            Loop.idRequest = FudgeCore.XRViewport.default.session.requestAnimationFrame(Loop.loopFrameXR);
        }
        static loopTime() {
            if (Loop.syncWithAnimationFrame)
                Loop.idRequest = window.requestAnimationFrame(Loop.loop);
            else
                Loop.loop();
        }
    }
    FudgeCore.Loop = Loop;
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * Instances of this class generate a timestamp that correlates with the time elapsed since the start of the program but allows for resetting and scaling.
     * Supports {@link Timer}s similar to window.setInterval but with respect to the scaled time.
     * All time values are given in milliseconds
     *
     * @authors Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Time extends FudgeCore.EventTargetUnified {
        /** Standard game time starting automatically with the application */
        static { this.game = new Time(); }
        constructor() {
            super();
            this.timers = {};
            this.idTimerAddedLast = 0;
            this.start = performance.now();
            this.scale = 1.0;
            this.offset = 0.0;
            this.lastCallToElapsed = 0.0;
        }
        /**
         * Returns representions of the time given in milliseconds in various formats defined in {@link TimeUnits}
         */
        static getUnits(_milliseconds) {
            let units = {};
            units.asSeconds = _milliseconds / 1000;
            units.asMinutes = units.asSeconds / 60;
            units.asHours = units.asMinutes / 60;
            units.hours = Math.floor(units.asHours);
            units.minutes = Math.floor(units.asMinutes) % 60;
            units.seconds = Math.floor(units.asSeconds) % 60;
            units.fraction = _milliseconds % 1000;
            units.thousands = _milliseconds % 10;
            units.hundreds = _milliseconds % 100 - units.thousands;
            units.tenths = units.fraction - units.hundreds - units.thousands;
            return units;
        }
        //#region Get/Set time and scaling
        /**
         * Retrieves the current scaled timestamp of this instance in milliseconds
         */
        get() {
            return this.offset + this.scale * (performance.now() - this.start);
        }
        /**
         * Returns the remaining time to the given point of time
         */
        getRemainder(_to) {
            return _to - this.get();
        }
        /**
         * (Re-) Sets the timestamp of this instance
         * @param _time The timestamp to represent the current time (default 0.0)
         */
        set(_time = 0) {
            this.offset = _time;
            this.start = performance.now();
            this.getElapsedSincePreviousCall();
        }
        /**
         * Sets the scaling of this time, allowing for slowmotion (<1) or fastforward (>1)
         * @param _scale The desired scaling (default 1.0)
         */
        setScale(_scale = 1.0) {
            this.set(this.get());
            this.scale = _scale;
            //TODO: catch scale=0
            this.rescaleAllTimers();
            this.getElapsedSincePreviousCall();
            this.dispatchEvent(new Event("timeScaled" /* EVENT.TIME_SCALED */));
        }
        /**
         * Retrieves the current scaling of this time
         */
        getScale() {
            return this.scale;
        }
        /**
         * Retrieves the offset of this time
         */
        getOffset() {
            return this.offset;
        }
        /**
         * Retrieves the scaled time in milliseconds passed since the last call to this method
         * Automatically reset at every call to set(...) and setScale(...)
         */
        getElapsedSincePreviousCall() {
            let current = this.get();
            let elapsed = current - this.lastCallToElapsed;
            this.lastCallToElapsed = current;
            return elapsed;
        }
        //#endregion
        //#region Timers
        /**
         * Returns a Promise<void> to be resolved after the time given. To be used with async/await
         */
        delay(_lapse) {
            return new Promise(_resolve => this.setTimer(_lapse, 1, () => _resolve()));
        }
        // TODO: examine if web-workers would enhance performance here!
        /**
         * Stops and deletes all {@link Timer}s attached. Should be called before this Time-object leaves scope
         */
        clearAllTimers() {
            for (let id in this.timers) {
                this.deleteTimer(Number(id));
            }
        }
        /**
         * Deletes {@link Timer} found using the internal id of the connected interval-object
         * @param _id
         */
        deleteTimerByItsInternalId(_id) {
            for (let id in this.timers) {
                let timer = this.timers[id];
                if (timer.id == _id) {
                    timer.clear();
                    delete this.timers[id];
                    // TODO: check if an early out is OK here... should be!
                }
            }
        }
        /**
         * Installs a timer at this time object
         * @param _lapse The object-time to elapse between the calls to _callback
         * @param _count The number of calls desired, 0 = Infinite
         * @param _handler The function to call each the given lapse has elapsed
         * @param _arguments Additional parameters to pass to callback function
         */
        setTimer(_lapse, _count, _handler, ..._arguments) {
            // tslint:disable-next-line: no-unused-expression
            new FudgeCore.Timer(this, _lapse, _count, _handler, ..._arguments); // TODO: reuse time instances to avoid garbage collection
            //this.addTimer(timer);
            return this.idTimerAddedLast;
        }
        /**
         * This method is called internally by {@link Time} and {@link Timer} and must not be called otherwise
         */
        addTimer(_timer) {
            this.timers[++this.idTimerAddedLast] = _timer;
            return this.idTimerAddedLast;
        }
        /**
         * Deletes the timer with the id given by this time object
         */
        deleteTimer(_id) {
            let timer = this.timers[_id];
            if (!timer)
                return;
            timer.clear();
            delete this.timers[_id];
        }
        /**
         * Returns a reference to the timer with the given id or null if not found.
         */
        getTimer(_id) {
            return this.timers[_id];
        }
        /**
         * Returns a copy of the list of timers currently installed on this time object
         */
        getTimers() {
            let result = {};
            return Object.assign(result, this.timers);
        }
        /**
         * Returns true if there are {@link Timers} installed to this
         */
        hasTimers() {
            return (Object.keys(this.timers).length > 0);
        }
        /**
         * Recreates {@link Timer}s when scaling changes
         */
        rescaleAllTimers() {
            for (let id in this.timers) {
                let timer = this.timers[id];
                timer.clear();
                delete this.timers[id];
                if (!this.scale)
                    // Time has stopped, no need to replace cleared timers
                    continue;
                /* this.timers[id] =  */
                timer = timer.installCopy(); // the timer is automatically added to this time instance
                delete this.timers[this.idTimerAddedLast]; // remove the copy again ...
                this.timers[id] = timer; // ... and place it at the id of the original
            }
        }
    }
    FudgeCore.Time = Time;
    //#endregion
})(FudgeCore || (FudgeCore = {}));
var FudgeCore;
(function (FudgeCore) {
    /**
     * A {@link Timer}-instance internally uses window.setInterval to call a given handler with a given frequency a given number of times,
     * passing an {@link EventTimer}-instance with additional information and given arguments.
     * The frequency scales with the {@link Time}-instance the {@link Timer}-instance is attached to.
     *
     * @author Jirka Dell'Oro-Friedl, HFU, 2019
     */
    class Timer {
        /**
         * Creates a {@link Timer} instance.
         * @param _time The {@link Time} instance, the timer attaches to
         * @param _elapse The time in milliseconds to elapse, to the next call of _handler, measured in _time
         * @param _count The desired number of calls to _handler, Timer deinstalls automatically after last call. Passing 0 invokes infinite calls
         * @param _handler The {@link TimerHandler} instance to call
         * @param _arguments Additional arguments to pass to _handler
         *
         * TODO: for proper handling and deletion, use Time.setTimer instead of instantiating timers yourself.
         */
        constructor(_time, _elapse, _count, _handler, ..._arguments) {
            this.time = _time;
            this.elapse = _elapse;
            this.event = new FudgeCore.EventTimer(this, ..._arguments);
            this.handler = _handler;
            this.count = _count;
            let scale = Math.abs(_time.getScale());
            if (!scale) {
                // Time is stopped, timer won't be active
                this.active = false;
                return;
            }
            this.timeoutReal = this.elapse / scale;
            let callback = () => {
                if (!this.active)
                    return;
                this.event.count = this.count;
                this.event.lastCall = (this.count == 1);
                _handler(this.event);
                this.event.firstCall = false;
                if (this.count > 0)
                    if (--this.count == 0)
                        _time.deleteTimerByItsInternalId(this.idWindow);
            };
            this.idWindow = window.setInterval(callback, this.timeoutReal, ..._arguments);
            this.active = true;
            _time.addTimer(this);
        }
        /**
         * Returns the window-id of the timer, which was returned by setInterval
         */
        get id() {
            return this.idWindow;
        }
        /**
         * Returns the time-intervall for calls to the handler
         */
        get lapse() {
            return this.elapse;
        }
        /**
         * Attaches a copy of this at its current state to the same {@link Time}-instance. Used internally when rescaling {@link Time}
         */
        installCopy() {
            return new Timer(this.time, this.elapse, this.count, this.handler, this.event.arguments);
        }
        /**
         * Clears the timer, removing it from the interval-timers handled by window
         */
        clear() {
            // if (this.type == TIMER_TYPE.TIMEOUT) {
            //     if (this.active)
            //         // save remaining time to timeout as new timeout for restart
            //         this.timeout = this.timeout * (1 - (performance.now() - this.startTimeReal) / this.timeoutReal);
            //     window.clearTimeout(this.id);
            // }
            // else
            // TODO: reusing timer starts interval anew. Should be remaining interval as timeout, then starting interval anew 
            window.clearInterval(this.idWindow);
            this.active = false;
        }
    }
    FudgeCore.Timer = Timer;
})(FudgeCore || (FudgeCore = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVkZ2VDb3JlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vU291cmNlL0NvcmUvRGVidWcvUGVyZm9ybWFuY2UudHMiLCIuLi9Tb3VyY2UvQ29yZS9EZWJ1Zy9EZWJ1Z1RhcmdldC50cyIsIi4uL1NvdXJjZS9Db3JlL0RlYnVnL0RlYnVnSW50ZXJmYWNlcy50cyIsIi4uL1NvdXJjZS9Db3JlL0RlYnVnL0RlYnVnQ29uc29sZS50cyIsIi4uL1NvdXJjZS9Db3JlL0RlYnVnL0RlYnVnLnRzIiwiLi4vU291cmNlL0NvcmUvRXZlbnQvRXZlbnQudHMiLCIuLi9Tb3VyY2UvQ29yZS9SZWN5Y2xlL1JlY3ljbGFibGVFdmVudC50cyIsIi4uL1NvdXJjZS9Db3JlL1NlcmlhbGl6YXRpb24vTXV0YWJsZS50cyIsIi4uL1NvdXJjZS9Db3JlL1NlcmlhbGl6YXRpb24vU2VyaWFsaXplci50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9SZW5kZXJCdWZmZXJNYW5hZ2VyLnRzIiwiLi4vU291cmNlL0NvcmUvUmVuZGVyL1JlbmRlck1hbmFnZXJDb2F0LnRzIiwiLi4vU291cmNlL0NvcmUvUmVuZGVyL1JlbmRlck1hbmFnZXJOb2RlLnRzIiwiLi4vU291cmNlL0NvcmUvUmVuZGVyL1JlbmRlcldlYkdMUGlja2luZy50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9SZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LnRzIiwiLi4vU291cmNlL0NvcmUvUmVuZGVyL1JlbmRlcldlYkdMQ29tcG9uZW50Rm9nLnRzIiwiLi4vU291cmNlL0NvcmUvUmVuZGVyL1JlbmRlcldlYkdMQ29tcG9uZW50Q2FtZXJhLnRzIiwiLi4vU291cmNlL0NvcmUvUmVuZGVyL1JlbmRlcldlYkdMQ29tcG9uZW50QW1iaWVudE9jY2x1c2lvbi50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9SZW5kZXJXZWJHTENvbXBvbmVudEJsb29tLnRzIiwiLi4vU291cmNlL0NvcmUvUmVuZGVyL1JlbmRlcldlYkdMQ29tcG9uZW50T3V0bGluZS50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9SZW5kZXJJbmplY3RvclNoYWRlci50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9SZW5kZXJJbmplY3Rvck1lc2gudHMiLCIuLi9Tb3VyY2UvQ29yZS9SZW5kZXIvUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9SZW5kZXJJbmplY3RvckNvbXBvbmVudFBhcnRpY2xlU3lzdGVtLnRzIiwiLi4vU291cmNlL0NvcmUvUmVjeWNsZS9SZWN5Y2xlci50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvVmVjdG9yMi50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvUmVjdGFuZ2xlLnRzIiwiLi4vU291cmNlL0NvcmUvUmVuZGVyL1JlbmRlcldlYkdMLnRzIiwiLi4vU291cmNlL0NvcmUvUmVuZGVyL1JlbmRlckluamVjdG9yVGV4dHVyZS50cyIsIi4uL1NvdXJjZS9Db3JlL0dyYXBoL05vZGUudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50LnRzIiwiLi4vU291cmNlL0NvcmUvUmVjeWNsZS9SZWN5Y2FibGVBcnJheS50cyIsIi4uL1NvdXJjZS9Db3JlL1BoeXNpY3MvSGVscGVyc1BoeXNpY3MudHMiLCIuLi9Tb3VyY2UvQ29yZS9QaHlzaWNzL0pvaW50LnRzIiwiLi4vU291cmNlL0NvcmUvUGh5c2ljcy9Kb2ludEF4aWFsLnRzIiwiLi4vU291cmNlL0NvcmUvU2VyaWFsaXphdGlvbi9Qcm9qZWN0LnRzIiwiLi4vU291cmNlL0NvcmUvVGV4dHVyZS9UZXh0dXJlLnRzIiwiLi4vU291cmNlL0NvcmUvTWVzaC9NZXNoLnRzIiwiLi4vU291cmNlL0NvcmUvTWF0ZXJpYWwvTWF0ZXJpYWwudHMiLCIuLi9Tb3VyY2UvQ29yZS9QYXJ0aWNsZVN5c3RlbS9QYXJ0aWNsZVN5c3RlbS50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9SZW5kZXJJbmplY3RvckNvbXBvbmVudFNrZWxldG9uLnRzIiwiLi4vU291cmNlL0NvcmUvQ29tcG9uZW50L0NvbXBvbmVudFNrZWxldG9uLnRzIiwiLi4vU291cmNlL0NvcmUvUmVmZXJlbmNlcy50cyIsIi4uL1NvdXJjZS9Db3JlL0FuaW1hdGlvbi9BbmltYXRpb24udHMiLCIuLi9Tb3VyY2UvQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uRnVuY3Rpb24udHMiLCIuLi9Tb3VyY2UvQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uR0xURi50cyIsIi4uL1NvdXJjZS9Db3JlL0FuaW1hdGlvbi9BbmltYXRpb25LZXkudHMiLCIuLi9Tb3VyY2UvQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uTm9kZS50cyIsIi4uL1NvdXJjZS9Db3JlL0FuaW1hdGlvbi9BbmltYXRpb25TZXF1ZW5jZS50cyIsIi4uL1NvdXJjZS9Db3JlL0FuaW1hdGlvbi9BbmltYXRpb25TcHJpdGUudHMiLCIuLi9Tb3VyY2UvQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uVGFyZ2V0QmluZGluZy50cyIsIi4uL1NvdXJjZS9Db3JlL0F1ZGlvL0F1ZGlvLnRzIiwiLi4vU291cmNlL0NvcmUvRXZlbnQvRXZlbnRBdWRpby50cyIsIi4uL1NvdXJjZS9Db3JlL0F1ZGlvL0F1ZGlvTWFuYWdlci50cyIsIi4uL1NvdXJjZS9Db3JlL0F1ZGlvL0F1ZGlvT3NjaWxsYXRvci50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRBbWJpZW50T2NjbHVzaW9uLnRzIiwiLi4vU291cmNlL0NvcmUvQ29tcG9uZW50L0NvbXBvbmVudEFuaW1hdGlvbi50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRBbmltYXRpb25HcmFwaC50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRBdWRpby50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRBdWRpb0xpc3RlbmVyLnRzIiwiLi4vU291cmNlL0NvcmUvQ29tcG9uZW50L0NvbXBvbmVudEJsb29tLnRzIiwiLi4vU291cmNlL0NvcmUvQ29tcG9uZW50L0NvbXBvbmVudENhbWVyYS50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRGYWNlQ2FtZXJhLnRzIiwiLi4vU291cmNlL0NvcmUvQ29tcG9uZW50L0NvbXBvbmVudEZvZy50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRHcmFwaEZpbHRlci50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRMaWdodC50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRNYXRlcmlhbC50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRNZXNoLnRzIiwiLi4vU291cmNlL0NvcmUvQ29tcG9uZW50L0NvbXBvbmVudE91dGxpbmUudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50UGFydGljbGVTeXN0ZW0udHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50UGljay50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRTY3JpcHQudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50VGV4dC50cyIsIi4uL1NvdXJjZS9Db3JlL0NvbXBvbmVudC9Db21wb25lbnRUcmFuc2Zvcm0udHMiLCIuLi9Tb3VyY2UvQ29yZS9Db21wb25lbnQvQ29tcG9uZW50VlJEZXZpY2UudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db250cm9sL0NvbnRyb2wudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db250cm9sL0F4aXMudHMiLCIuLi9Tb3VyY2UvQ29yZS9Db250cm9sL0tleWJvYXJkLnRzIiwiLi4vU291cmNlL0NvcmUvRGVidWcvRGVidWdBbGVydC50cyIsIi4uL1NvdXJjZS9Db3JlL0RlYnVnL0RlYnVnRGlhbG9nLnRzIiwiLi4vU291cmNlL0NvcmUvRGVidWcvRGVidWdUZXh0QXJlYS50cyIsIi4uL1NvdXJjZS9Db3JlL0V2ZW50L0V2ZW50S2V5Ym9hcmQudHMiLCIuLi9Tb3VyY2UvQ29yZS9FdmVudC9FdmVudFRpbWVyLnRzIiwiLi4vU291cmNlL0NvcmUvRXZlbnQvRXZlbnRUb3VjaC50cyIsIi4uL1NvdXJjZS9Db3JlL0dyYXBoL0dyYXBoLnRzIiwiLi4vU291cmNlL0NvcmUvR3JhcGgvR3JhcGhHTFRGLnRzIiwiLi4vU291cmNlL0NvcmUvR3JhcGgvR3JhcGhJbnN0YW5jZS50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGVyaWFsL0NvYXQudHMiLCIuLi9Tb3VyY2UvQ29yZS9NYXRlcmlhbC9Db2F0Q29sb3JlZC50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGVyaWFsL0NvYXRSZW1pc3NpdmUudHMiLCIuLi9Tb3VyY2UvQ29yZS9NYXRlcmlhbC9Db2F0VGV4dHVyZWQudHMiLCIuLi9Tb3VyY2UvQ29yZS9NYXRlcmlhbC9Db2F0UmVtaXNzaXZlVGV4dHVyZWQudHMiLCIuLi9Tb3VyY2UvQ29yZS9NYXRlcmlhbC9Db2F0UmVtaXNzaXZlVGV4dHVyZWROb3JtYWxzLnRzIiwiLi4vU291cmNlL0NvcmUvTWF0ZXJpYWwvQ29hdFRvb24udHMiLCIuLi9Tb3VyY2UvQ29yZS9NYXRlcmlhbC9Db2xvci50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGVyaWFsL01hdGVyaWFsR0xURi50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvQ2FsYy50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvRnJhbWluZy50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvR2VvMi50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvR2VvMy50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvTEZJQjQudHMiLCIuLi9Tb3VyY2UvQ29yZS9NYXRoL01hdHJpeDN4My50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvTWF0cml4NHg0LnRzIiwiLi4vU291cmNlL0NvcmUvTWF0aC9Ob2lzZS50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvTm9pc2UyLnRzIiwiLi4vU291cmNlL0NvcmUvTWF0aC9Ob2lzZTMudHMiLCIuLi9Tb3VyY2UvQ29yZS9NYXRoL05vaXNlNC50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvUXVhdGVybmlvbi50cyIsIi4uL1NvdXJjZS9Db3JlL01hdGgvUmFuZG9tLnRzIiwiLi4vU291cmNlL0NvcmUvTWF0aC9WZWN0b3IzLnRzIiwiLi4vU291cmNlL0NvcmUvTWF0aC9WZWN0b3I0LnRzIiwiLi4vU291cmNlL0NvcmUvTWVzaC9GYWNlLnRzIiwiLi4vU291cmNlL0NvcmUvTWVzaC9NZXNoQ3ViZS50cyIsIi4uL1NvdXJjZS9Db3JlL01lc2gvTWVzaFBvbHlnb24udHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL01lc2hFeHRydXNpb24udHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL01lc2hGQlgudHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL01lc2hGcm9tRGF0YS50cyIsIi4uL1NvdXJjZS9Db3JlL01lc2gvTWVzaEdMVEYudHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL01lc2hPQkoudHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL01lc2hQeXJhbWlkLnRzIiwiLi4vU291cmNlL0NvcmUvTWVzaC9NZXNoUXVhZC50cyIsIi4uL1NvdXJjZS9Db3JlL01lc2gvTWVzaFRlcnJhaW4udHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL01lc2hSZWxpZWYudHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL01lc2hSb3RhdGlvbi50cyIsIi4uL1NvdXJjZS9Db3JlL01lc2gvTWVzaFNwaGVyZS50cyIsIi4uL1NvdXJjZS9Db3JlL01lc2gvTWVzaFNwcml0ZS50cyIsIi4uL1NvdXJjZS9Db3JlL01lc2gvTWVzaFRvcnVzLnRzIiwiLi4vU291cmNlL0NvcmUvTWVzaC9RdWFkLnRzIiwiLi4vU291cmNlL0NvcmUvTWVzaC9WZXJ0ZXgudHMiLCIuLi9Tb3VyY2UvQ29yZS9NZXNoL1ZlcnRpY2VzLnRzIiwiLi4vU291cmNlL0NvcmUvUGFydGljbGVTeXN0ZW0vU2hhZGVyUGFydGljbGVTeXN0ZW0udHMiLCIuLi9Tb3VyY2UvQ29yZS9QYXRoaW5nL0NvbXBvbmVudFdhbGtlci50cyIsIi4uL1NvdXJjZS9Db3JlL1BhdGhpbmcvQ29tcG9uZW50V2F5cG9pbnQudHMiLCIuLi9Tb3VyY2UvQ29yZS9QYXRoaW5nL0Nvbm5lY3Rpb24udHMiLCIuLi9Tb3VyY2UvQ29yZS9QaHlzaWNzL0NvbXBvbmVudFJpZ2lkYm9keS50cyIsIi4uL1NvdXJjZS9Db3JlL1BoeXNpY3MvRGVidWdQaHlzaWNzRHJhdy50cyIsIi4uL1NvdXJjZS9Db3JlL1BoeXNpY3MvSm9pbnRDeWxpbmRyaWNhbC50cyIsIi4uL1NvdXJjZS9Db3JlL1BoeXNpY3MvSm9pbnRQcmlzbWF0aWMudHMiLCIuLi9Tb3VyY2UvQ29yZS9QaHlzaWNzL0pvaW50UmFnZG9sbC50cyIsIi4uL1NvdXJjZS9Db3JlL1BoeXNpY3MvSm9pbnRSZXZvbHV0ZS50cyIsIi4uL1NvdXJjZS9Db3JlL1BoeXNpY3MvSm9pbnRTcGhlcmljYWwudHMiLCIuLi9Tb3VyY2UvQ29yZS9QaHlzaWNzL0pvaW50VW5pdmVyc2FsLnRzIiwiLi4vU291cmNlL0NvcmUvUGh5c2ljcy9Kb2ludFdlbGRpbmcudHMiLCIuLi9Tb3VyY2UvQ29yZS9QaHlzaWNzL1BoeXNpY3MudHMiLCIuLi9Tb3VyY2UvQ29yZS9SYXkvQm94LnRzIiwiLi4vU291cmNlL0NvcmUvUmF5L1BpY2sudHMiLCIuLi9Tb3VyY2UvQ29yZS9SYXkvUGlja2VyLnRzIiwiLi4vU291cmNlL0NvcmUvUmF5L1JheS50cyIsIi4uL1NvdXJjZS9Db3JlL1JlbmRlci9HaXptb3MudHMiLCIuLi9Tb3VyY2UvQ29yZS9SZW5kZXIvUmVuZGVyLnRzIiwiLi4vU291cmNlL0NvcmUvUmVuZGVyL1JlbmRlck1lc2gudHMiLCIuLi9Tb3VyY2UvQ29yZS9SZW5kZXIvVmlld3BvcnQudHMiLCIuLi9Tb3VyY2UvQ29yZS9SZW5kZXIvWFJWaWV3cG9ydC50cyIsIi4uL1NvdXJjZS9Db3JlL1NlcmlhbGl6YXRpb24vRmlsZUlvQnJvd3NlckxvY2FsLnRzIiwiLi4vU291cmNlL0NvcmUvU2VyaWFsaXphdGlvbi9NdXRhYmxlQXJyYXkudHMiLCIuLi9Tb3VyY2UvQ29yZS9TZXJpYWxpemF0aW9uL0ZCWC9CdWZmZXJSZWFkZXIudHMiLCIuLi9Tb3VyY2UvQ29yZS9TZXJpYWxpemF0aW9uL0ZCWC9GQlgudHMiLCIuLi9Tb3VyY2UvQ29yZS9TZXJpYWxpemF0aW9uL0ZCWC9GQlhMb2FkZXIudHMiLCIuLi9Tb3VyY2UvQ29yZS9TZXJpYWxpemF0aW9uL0ZCWC9GQlhOb2RlLnRzIiwiLi4vU291cmNlL0NvcmUvU2VyaWFsaXphdGlvbi9GQlgvbG9hZEZyb21Ob2Rlcy50cyIsIi4uL1NvdXJjZS9Db3JlL1NlcmlhbGl6YXRpb24vRkJYL3BhcnNlTm9kZXNGcm9tQmluYXJ5LnRzIiwiLi4vU291cmNlL0NvcmUvU2VyaWFsaXphdGlvbi9HTFRGL0dMVEYudHMiLCIuLi9Tb3VyY2UvQ29yZS9TZXJpYWxpemF0aW9uL0dMVEYvR0xURkxvYWRlci50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9NZXJnZWRTaGFkZXJTb3VyY2VzLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlci50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJBbWJpZW50T2NjbHVzaW9uLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckJsb29tLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckZsYXQudHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyRmxhdFNraW4udHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyRmxhdFRleHR1cmVkLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckZsYXRUZXh0dXJlZFNraW4udHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyR2l6bW8udHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyR2l6bW9UZXh0dXJlZC50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJHb3VyYXVkLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckdvdXJhdWRTa2luLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckdvdXJhdWRUZXh0dXJlZC50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJHb3VyYXVkVGV4dHVyZWRTa2luLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckxpdC50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJMaXRTa2luLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckxpdFRleHR1cmVkLnRzIiwiLi4vU291cmNlL0NvcmUvU2hhZGVyL1NoYWRlckxpdFRleHR1cmVkU2tpbi50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJNYXRDYXAudHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyT3V0bGluZS50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJQaG9uZy50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJQaG9uZ1NraW4udHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyUGhvbmdUZXh0dXJlZC50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJQaG9uZ1RleHR1cmVkTm9ybWFscy50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJQaG9uZ1RleHR1cmVkTm9ybWFsc1NraW4udHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyUGhvbmdUZXh0dXJlZFNraW4udHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyUGljay50cyIsIi4uL1NvdXJjZS9Db3JlL1NoYWRlci9TaGFkZXJQaWNrVGV4dHVyZWQudHMiLCIuLi9Tb3VyY2UvQ29yZS9TaGFkZXIvU2hhZGVyVG9vbi50cyIsIi4uL1NvdXJjZS9Db3JlL1RleHR1cmUvVGV4dHVyZURlZmF1bHQudHMiLCIuLi9Tb3VyY2UvQ29yZS9UaW1lL0xvb3AudHMiLCIuLi9Tb3VyY2UvQ29yZS9UaW1lL1RpbWUudHMiLCIuLi9Tb3VyY2UvQ29yZS9UaW1lL1RpbWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBVSxTQUFTLENBdUdsQjtBQXZHRCxXQUFVLFNBQVM7SUFZakIsTUFBYSxrQkFBa0I7UUFFN0I7WUFDRSxNQUFNLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLGtCQUFrQixFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzFILENBQUM7aUJBRWEsaUJBQVksR0FBOEMsRUFBRSxDQUFDO2lCQUVuRCxvQkFBZSxHQUFXLEVBQUUsQ0FBQztRQUU5QyxNQUFNLENBQUMsWUFBWSxDQUFDLE1BQWM7WUFDdkMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztnQkFDL0IsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsR0FBRztvQkFDMUIsWUFBWSxFQUFFLE1BQU0sQ0FBQyxTQUFTO29CQUM5QixZQUFZLEVBQUUsQ0FBQyxNQUFNLENBQUMsU0FBUztvQkFDL0IsWUFBWSxFQUFFLENBQUM7b0JBRWYsYUFBYSxFQUFFLENBQUM7b0JBQ2hCLElBQUksRUFBRSxDQUFDO29CQUNQLEtBQUssRUFBRSxDQUFDO2lCQUNULENBQUM7WUFDSixDQUFDO1lBQ0QsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3RELENBQUM7UUFFTSxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQWM7WUFDckMsTUFBTSxXQUFXLEdBQTJCLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdEUsSUFBSSxDQUFDLFdBQVcs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QUssQ0FBQyxJQUFJLENBQUM7WUFFcEQsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsSUFBSSxVQUFBLHVCQUF1QixDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUMvRCxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQzNELElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDM0QsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUUzRCxPQUFPO1lBQ1QsQ0FBQztZQUVELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRTNDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN6SSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDekksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRXpJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUN2RyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFDdkcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQ3pHLENBQUM7S0FDRjtJQTlDWSxrQ0FBd0IsMkJBOENwQyxDQUFBO0lBRUQsTUFBYSwyQkFBNEIsU0FBUSxpQkFBb0M7UUFDNUUsUUFBUSxDQUFDLEtBQWEsRUFBRSxPQUE2QyxFQUFFO1lBQzVFLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztZQUN6QixJQUFJLEtBQUssR0FBVyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQ2xDLElBQUksS0FBSyxHQUFXLEtBQUssR0FBRyxLQUFLLENBQUM7WUFFbEMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzRSxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNFLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDM0UsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzRSxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFTSxTQUFTO1lBQ2QsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUNwQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7WUFDcEMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUVwQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUs7Z0JBQ2IsT0FBTztZQUVULE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBRXhDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxJQUFJLFVBQUEsdUJBQXVCLENBQUMsUUFBUTtnQkFDOUUsT0FBTztZQUVULElBQUksRUFBRSxHQUFXLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO1lBRXBELElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLElBQUksVUFBQSx1QkFBdUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDL0QsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUMzRCxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQzNELElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDM0QsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUUzRCxPQUFPO1lBQ1QsQ0FBQztZQUVELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRTNDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN6SSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDekksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3pJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUV6SSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFDdkcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMs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O1FBRUQ7OztXQUdHO1FBQ0ksTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFZLEVBQUUsS0FBWSxFQUFFLE9BQWMsVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztZQUMvRSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDOUYsQ0FBQztRQUVEOzs7V0FHRztRQUNJLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBWSxFQUFFLEtBQVksRUFBRSxPQUFjLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7WUFDdEYsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEosQ0FBQztRQUVEOzs7V0FHRztRQUNJLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBWSxFQUFFLEtBQVksRUFBRSxPQUFjLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7WUFDbkYsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsS0FB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QUMsQ0FBQztZQUVyRyxNQUFNLEdBQUcsR0FBVyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFXLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQVcsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBVyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckcsTUFBTSxHQUFHLEdBQVcsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBVyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFXLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQVcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JHLE1BQU0sR0FBRyxHQUFXLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQVcsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBVyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxHQUFXLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUN2RyxNQUFNLEdBQUcsR0FBVyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxHQUFXLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEdBQVcsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsR0FBVyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7WUFFekcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDdkQsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDdkQsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDdkQsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDdkQsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDdkQsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDdkQsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDdkQsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDdkQsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDdkQsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDdkQsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDeEQsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDeEQsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDeEQsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDeEQsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFDeEQsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7WUFFeEQsT0FBTyxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBRXJCLE9BQU8sT0FBTyxDQUFDO1FBQ2pCLENBQUM7UUFFRDs7O1dBR0c7UUFDSSxNQUFNLENBQUMsU0FBUyxDQUFDLElBQWUsRUFBRSxVQUFxQixVQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDO1lBQ3JGLE1BQU0sQ0FBQyxHQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ2xDLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FDaEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVB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QUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFDM0YsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQzNGLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFDM0YsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUMzRixDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsR0FBRyxH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QUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDM0IsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDMUIsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFFMUIsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO3dCQUM1RixFQUFFLEdBQUcsRUFBRSxDQUFDO3dCQUNSLEVBQUUsR0FBRyxFQUFFLENBQUM7d0JBQ1IsRUFBRSxHQUFHLEVBQUUsQ0FBQztvQkFDVixDQUFDO2dCQUNILENBQUM7cUJBQU0sQ0FBQztvQkFDTixFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDckUsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7b0JBQy9DLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ1QsQ0FBQztnQkFFRCxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxF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QUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ25ELE1BQU0sS0FBSyxHQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNuRCxNQUFNLEtBQUssR0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDbkQsTUFBTSxLQUFLLEdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRWxELE1BQU0sR0FBRyxHQUNQLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO2dCQUNuRCxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztnQkFDbkQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7Z0JBQ25ELENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxD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QUFDLEdBQXdCLFFBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUF3QixRQUFTLENBQUMsQ0FBQyxDQUFDO29CQUM3SixNQUFNLEVBQUUsR0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUNqRSxNQUFNLEVBQUUsR0FBVyxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBVyxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUNwRSxNQUFNLEVBQUUsR0FBVyxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBVyxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUNwRSxNQUFNLEVBQUUsR0FBVyxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBVyxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUVwRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7b0JBQzVCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7b0JBQ3RCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7b0JBRXRCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7b0JBQ3RCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztvQkFDNUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFH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Q0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDbkQsTUFBTSxLQUFLLEdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ25ELE1BQU0sS0FBSyxHQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNuRCxNQUFNLEtBQUssR0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7WUFFbEQsTUFBTSxHQUFHLEdBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7Z0JBQ25ELENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO2dCQUNuRCxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztnQkFDbkQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQztZQUV0RCxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUM7UUFFRDs7O1dBR0c7UUFDSSxJQUFJLENBQUMsVUFBbUIsVUFBQSxRQUFRLENBQUMsS0FBSyxDQUFDLFVBQUEsT0FBTyxDQUFDO1lBQ3BELE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQUEsQ0FBQztRQUNoRSxDQUFDO1FBQ0Q7OztXQUdHO1FBQ0ksSUFBSSxDQUFDLFVBQW1CLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxVQUFBLE9BQU8sQ0FBQztZQUNwRCxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvRCxDQUFDO1FBQ0Q7OztXQUdHO1FBQ0ksSUFBSSxDQUFDLFVBQW1CLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxVQUFBLE9BQU8sQ0FBQztZQUNwRCxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNoRSxDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksUUFBUSxDQUFDLFVBQW1CLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxVQUFBLE9BQU8sQ0FBQztZQUN4RCxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUMzRSxDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksS0FBSyxDQUFDLFVBQW1CLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxVQUFBLE9BQU8sQ0FBQztZQUNyRCxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUMzRSxDQUFDO1FBRUQ7OztXQUdHO1FBQ0ksVUFBVSxDQUFDLFVBQW1CLFVBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxVQUFBLE9BQU8sQ0FBQztZQUMxRCxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUM1RSxDQUFDO1FBRUQ7O1dBRUc7UUFDSSxNQUFNO1lBQ1gsTUFBTSxDQUFDLEdBQWlCLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDbEMsTUFBTSxLQUFLLEdBQVksSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsZUFBZTtZQUNuRCxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQUMsQ0FBQyxDQUFDLENBQUMs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QUFDO2dCQUVyRyx5REFBeUQ7Z0JBQ3pELE1BQU0sRUFBRSxHQUFXLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDckQsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLENBQUM7b0JBQ3ZCLENBQUMsQ0FBQyxHQUFHO29CQUNMLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQzdELE1BQU0sRUFBRSxHQUFXLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDckQsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLENBQUM7b0JBQ3ZCLENBQUMsQ0FBQyxHQUFHO29CQUNMLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQzdELE1BQU0sRUFBRSxHQUFXLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDckQsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLENBQUM7b0JBQ3ZCLENBQUMsQ0FBQyxHQUFHO29CQUNMLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQzdELE1BQU0sRUFBRSxHQUFXLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDckQsTUFBTSxFQUFFLEdBQVcsRUFBRSxHQUFHLENBQUM7b0JBQ3ZCLENBQUMsQ0FBQyxHQUFHO29CQUNMLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBRTdELG1FQUFtRTtnQkFDbkUsa0RBQWtEO2dCQUNsRCxPQUFPLGlCQUFpQixHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFDakQsQ0FBQyxDQUFDO1FBQ0osQ0FBQzs7SUE3RlUsZ0JBQU0sU0FrR2xCLENBQUE7QUFDSCxDQUFDLEVBakhTLFNBQVMsS0FBVCxTQUFTLFFBaUhsQjtBQ2pIRCxJQUFVLFNBQVMsQ0E4SmxCO0FBOUpELFdBQVUsU0FBUztJQUNqQixhQUFhO0lBQ2I7Ozs7Ozs7Ozs7O09BV0c7SUFDSCxNQUFhLE1BQU8sU0FBUSxVQUFBLEtBQUs7aUJBQ2hCLFdBQU0sR0FBVyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxBQUF4QyxDQUF5QztpQkFDL0MsYUFBUSxHQUFlLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEFBQS9mLENBQWdnQjtRQUN2aEIsT0FBTyxDQUFvRTtR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VyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDNUMsT0FBTztZQUNULENBQUM7WUFFRCxJQUFJLEtBQUssR0FBYyxNQUFNLENBQUM7WUFFOUIsSUFBSSxHQUFHLEdBQVksVUFBQSxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDbEMsSUFBSSxHQUFHLEdBQVksVUFBQSxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDbEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLFVBQUEsUUFBUSxFQUFFLENBQUM7WUFDL0IsS0FBSyxJQUFJLE1BQU0sSUFBSSxLQUFLLEVBQUUsQ0FBQztnQkFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxVQUFBLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUVuRCxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2xDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbEMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNsQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEMsQ0FBQztZQUNELElBQUksSUFBSSxHQUFZLElBQUksVUFBQSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRTlELElBQUksSUFBSSxDQUFDLFVBQVUs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QyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDM0MsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDM0MsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDM0MsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDM0MsS0FBSyxDQUNOLENBQUMsQ0FBQztvQkFDSCxLQUFLLEdBQUcsQ0FBQyxLQUFLLElBQUksVUFBQSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQUEsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsVUFBQSxTQUFTLENBQUMsSUFBSSxDQUFDO2dCQUN0RSxDQUFDO2dCQUNELElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxvREFBb0Q7b0JBQ2xGLEtBQUssR0FBRyxDQUFDLEtBQUssSUFBSSxVQUFBLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBQSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFBLFNBQVMsQ0FBQyxJQUFJLENBQUM7WUFDeEUsQ0FBQztZQUNELElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQVcsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUss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LFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUM7Z0JBQ3ZGLElBQUksVUFBQSxPQUFPLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLElBQUksVUFBQSxPQUFPLENBQUMsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLENBQUMsUUFBUSxDQUFDO2dCQUN2RixJQUFJLFVBQUEsT0FBTyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsSUFBSSxVQUFBLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLENBQUM7YUFDMUYsQ0FBQztZQUVGLE1BQU0sS0FBSyxHQUFjO2dCQUN2QixJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFDdEUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ3RFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FB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bEMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ2pDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ2xDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFFbkMsTUFBTSxDQUFDLFNBQVMsQ0FBQztnQkFDZixPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLGFBQWE7Z0JBQzdHLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsWUFBWTtnQkFDNUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBRSxRQUFR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LENBQUMsQ0FBQztZQUMxQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3JDLENBQUM7UUFFTSxTQUFTLENBQUMsVUFBa0IsSUFBSSxDQUFDLE1BQU07WUFDNUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1lBQzFCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzVDLENBQUM7UUFFTSxTQUFTLENBQUMsVUFBa0IsSUFBSSxDQUFDLE1BQU07WUFDNUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1lBQzFCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQy9DLENBQUM7UUFFTSxRQUFRLENBQUMsVUFBa0IsSUFBSSxDQUFDLE1BQU07WUFDM0MsSUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1lBQzFCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzNDLENBQUM7UUFFTSxRQUFRLENBQUMsVUFBa0IsSUFBSSxDQUFDLE1BQU07WUFDM0MsSUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1lBQzFCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzNDLENBQUM7UUFFTSxRQUFRLENBQUMsVUFBa0IsSUFBSSxDQUFDLE1BQU07WUFDM0MsSUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1lBQzFCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzlDLENBQUM7UUFFTSxVQUFVLENBQUMsVUFBa0IsSUFBSSxD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R0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQztZQUNyRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQztZQUNyRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxVQUFVLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDdkQsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksVUFBVSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3pELENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN6RCxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxVQUFVLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDekQsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksYUFBYSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzVELENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLFlBQVksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUM3RCxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxZQUFZLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDOUQsQ0FBQyxRQUFRLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFekIs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Q0FBQztRQUN2QixDQUFDO1FBRUQ7O1dBRUc7UUFDSCxJQUFXLEVBQUU7WUFDWCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDdkIsQ0FBQztRQUVEOztXQUVHO1FBQ0gsSUFBVyxLQUFLO1lBQ2QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3JCLENBQUM7UUFFRDs7V0FFRztRQUNJLFdBQVc7WUFDaEIsT0FBTyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDM0YsQ0FBQztRQUVEOztXQUVHO1FBQ0ksS0FBSztZQUNWLHlDQUF5QztZQUN6Qyx1QkFBdUI7WUFDdkIsdUVBQXVFO1lBQ3ZFLDJHQUEyRztZQUMzRyxvQ0FBb0M7WUFDcEMsSUFBSTtZQUNKLE9BQU87WUFDUCxrSEFBa0g7WUFDbEgsTUFBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDcEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDdEIsQ0FBQztLQUNGO0lBN0ZZLGVBQUssUUE2RmpCLENBQUE7QUFDSCxDQUFDLEVBM0dTLFNBQVMsS0FBVCxTQUFTLFFBMkdsQiIsInNvdXJjZXNDb250ZW50IjpbIlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIFBlcmZvcm1hbmNlTWVhc3VyZW1lbnQge1xyXG4gICAgc3RhcnQ/OiBudW1iZXI7XHJcbiAgICBmcmFtZVRpbWVNaW46IG51bWJlcjtcclxuICAgIGZyYW1lVGltZU1heDogbnVtYmVyO1xyXG4gICAgZnJhbWVUaW1lQXZnOiBudW1iZXI7XHJcbiAgICBjYWxsc1BlckZyYW1lOiBudW1iZXI7XHJcblxyXG4gICAgdGltZTogbnVtYmVyO1xyXG4gICAgY2FsbHM6IG51bWJlcjtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBjbGFzcyBQZXJmb3JtYW5jZU1vbml0b3Ige1xyXG4gICAgcHVibGljIHN0YXRpYyBkaXNwbGF5OiBIVE1MUHJlRWxlbWVudDtcclxuICAgIHN0YXRpYyB7XHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiBQZXJmb3JtYW5jZU1vbml0b3IuZGlzcGxheSA9IGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobmV3IFBlcmZvcm1hbmNlRGlzcGxheSgpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBtZWFzdXJlbWVudHM6IHsgW2tleTogc3RyaW5nXTogUGVyZm9ybWFuY2VNZWFzdXJlbWVudCB9ID0ge307XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgZnJhbWVzVG9BdmVyYWdlOiBudW1iZXIgPSA2MDtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHN0YXJ0TWVhc3VyZShfbGFiZWw6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMubWVhc3VyZW1lbnRzW19sYWJlbF0pIHtcclxuICAgICAgICB0aGlzLm1lYXN1cmVtZW50c1tfbGFiZWxdID0ge1xyXG4gICAgICAgICAgZnJhbWVUaW1lTWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgZnJhbWVUaW1lTWF4OiAtTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgIGZyYW1lVGltZUF2ZzogMCxcclxuXHJcbiAgICAgICAgICBjYWxsc1BlckZyYW1lOiAwLFxyXG4gICAgICAgICAgdGltZTogMCxcclxuICAgICAgICAgIGNhbGxzOiAwXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1lYXN1cmVtZW50c1tfbGFiZWxdLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBlbmRNZWFzdXJlKF9sYWJlbDogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgICAgY29uc3QgbWVhc3VyZW1lbnQ6IFBlcmZvcm1hbmNlTWVhc3VyZW1lbnQgPSB0aGlzLm1lYXN1cmVtZW50c1tfbGFiZWxdO1xyXG4gICAgICBpZiAoIW1lYXN1cmVtZW50Py5zdGFydCkgcmV0dXJuIDA7XHJcblxyXG4gICAgICBjb25zdCBkdXJhdGlvbjogbnVtYmVyID0gcGVyZm9ybWFuY2Uubm93KCkgLSBtZWFzdXJlbWVudC5zdGFydDtcclxuICAgICAgbWVhc3VyZW1lbnQudGltZSArPSBkdXJhdGlvbjtcclxuICAgICAgbWVhc3VyZW1lbnQuY2FsbHMrKztcclxuXHJcbiAgICAgIHJldHVybiBkdXJhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHN0YXJ0RnJhbWUoKTogdm9pZCB7XHJcbiAgICAgIFBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE1lYXN1cmUoXCJGcmFtZVwiKTtcclxuICAgICAgZm9yIChjb25zdCBsYWJlbCBpbiB0aGlzLm1lYXN1cmVtZW50cykge1xyXG4gICAgICAgIHRoaXMubWVhc3VyZW1lbnRzW2xhYmVsXS50aW1lID0gMDtcclxuICAgICAgICB0aGlzLm1lYXN1cmVtZW50c1tsYWJlbF0uY2FsbHMgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBlbmRGcmFtZSgpOiB2b2lkIHtcclxuICAgICAgUGVyZm9ybWFuY2VNb25pdG9yLmVuZE1lYXN1cmUoXCJGcmFtZVwiKTtcclxuICAgICAgZm9yIChjb25zdCBsYWJlbCBpbiB0aGlzLm1lYXN1cmVtZW50cykge1xyXG4gICAgICAgIGNvbnN0IG1lYXN1cmVtZW50OiBQZXJmb3JtYW5jZU1lYXN1cmVtZW50ID0gdGhpcy5tZWFzdXJlbWVudHNbbGFiZWxdO1xyXG4gICAgICAgIGlmIChtZWFzdXJlbWVudC5jYWxscyA+IDApIHtcclxuICAgICAgICAgIGNvbnN0IGZyYW1lVG90YWw6IG51bWJlciA9IG1lYXN1cmVtZW50LnRpbWU7XHJcbiAgICAgICAgICBtZWFzdXJlbWVudC5mcmFtZVRpbWVNaW4gPSBNYXRoLm1pbihtZWFzdXJlbWVudC5mcmFtZVRpbWVNaW4sIGZyYW1lVG90YWwpO1xyXG4gICAgICAgICAgbWVhc3VyZW1lbnQuZnJhbWVUaW1lTWF4ID0gTWF0aC5tYXgobWVhc3VyZW1lbnQuZnJhbWVUaW1lTWF4LCBmcmFtZVRvdGFsKTtcclxuICAgICAgICAgIG1lYXN1cmVtZW50LmZyYW1lVGltZUF2ZyA9ICgodGhpcy5mcmFtZXNUb0F2ZXJhZ2UgLSAxKSAqIG1lYXN1cmVtZW50LmZyYW1lVGltZUF2ZyArIGZyYW1lVG90YWwpIC8gdGhpcy5mcmFtZXNUb0F2ZXJhZ2U7XHJcbiAgICAgICAgICBtZWFzdXJlbWVudC5jYWxsc1BlckZyYW1lID0gbWVhc3VyZW1lbnQuY2FsbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGxldCBsb25nZXN0U3RyaW5nOiBudW1iZXIgPSBPYmplY3Qua2V5cyhQZXJmb3JtYW5jZU1vbml0b3IubWVhc3VyZW1lbnRzKS5yZWR1Y2UoKF9hLCBfYikgPT4gX2EubGVuZ3RoID4gX2IubGVuZ3RoID8gX2EgOiBfYikubGVuZ3RoO1xyXG5cclxuICAgICAgbGV0IHRleHQ6IHN0cmluZyA9IGAke1wiUGVyZm9ybWFuY2UgTW9uaXRvclwiLnBhZEVuZChsb25nZXN0U3RyaW5nKX0gfCAgdGltZSAgfCAgY2FsbHNcXG5gO1xyXG4gICAgICBmb3IgKGxldCBrZXkgaW4gUGVyZm9ybWFuY2VNb25pdG9yLm1lYXN1cmVtZW50cykge1xyXG4gICAgICAgIGxldCBtZWFzdXJlbWVudDogUGVyZm9ybWFuY2VNZWFzdXJlbWVudCA9IFBlcmZvcm1hbmNlTW9uaXRvci5tZWFzdXJlbWVudHNba2V5XTtcclxuICAgICAgICBsZXQgYXZnOiBzdHJpbmcgPSBtZWFzdXJlbWVudC5mcmFtZVRpbWVBdmcudG9GaXhlZCgyKS5wYWRTdGFydCg0KTtcclxuICAgICAgICBsZXQgY2FsbHM6IHN0cmluZyA9IG1lYXN1cmVtZW50LmNhbGxzUGVyRnJhbWUudG9TdHJpbmcoKS5wYWRTdGFydCgzKTtcclxuICAgICAgICB0ZXh0ICs9IGAke2tleS5wYWRFbmQobG9uZ2VzdFN0cmluZyl9IHwgJHthdmd9bXMgfCAke2NhbGxzfWNwZlxcbmA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZGlzcGxheS50ZXh0Q29udGVudCA9IHRleHQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgUGVyZm9ybWFuY2VEaXNwbGF5IGV4dGVuZHMgSFRNTFByZUVsZW1lbnQge1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnN0eWxlLmNzc1RleHQgPSBgXHJcbiAgICAgIGZvbnQtZmFtaWx5OiBDb25zb2xhcywgXCJDb3VyaWVyIE5ld1wiLCBtb25vc3BhY2U7XHJcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgICBjb2xvcjogeWVsbG93O1xyXG4gICAgICB0ZXh0LXNoYWRvdzogLTFweCAtMXB4IDAgYmxhY2ssIDFweCAtMXB4IDAgYmxhY2ssIC0xcHggMXB4IDAgYmxhY2ssIDFweCAxcHggMCBibGFjaztcclxuICAgICAgcGFkZGluZzogMC4ycmVtO1xyXG4gICAgICBtYXJnaW46IDA7XHJcbiAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC43KTtcclxuICAgICAgd2lkdGg6IG1pbi1jb250ZW50O1xyXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgIGxlZnQ6IDA7XHJcbiAgICAgIHRvcDogMDtcclxuICAgICAgei1pbmRleDogMTAwMDtcclxuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7YDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcInVpLXBlcmZvcm1hbmNlXCIsIFBlcmZvcm1hbmNlRGlzcGxheSwgeyBleHRlbmRzOiBcInByZVwiIH0pO1xyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEJhc2UgY2xhc3MgZm9yIHRoZSBkaWZmZXJlbnQgRGVidWdUYXJnZXRzLCBtYWlubHkgZm9yIHRlY2huaWNhbCBwdXJwb3NlIG9mIGluaGVyaXRhbmNlXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIERlYnVnVGFyZ2V0IHtcclxuICAgIHB1YmxpYyBkZWxlZ2F0ZXM6IE1hcERlYnVnRmlsdGVyVG9EZWxlZ2F0ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1lcmdlIHRoZSBnaXZlbiBtZXNzYWdlIGFuZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBzdHJpbmcsIHNlcGFyYXRlZCBieSAnLCAnXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgbWVyZ2VBcmd1bWVudHMoX21lc3NhZ2U6IE9iamVjdCwgLi4uX2FyZ3M6IE9iamVjdFtdKTogc3RyaW5nIHtcclxuICAgICAgbGV0IG91dDogc3RyaW5nID0gX21lc3NhZ2UudG9TdHJpbmcoKTsgLy9KU09OLnN0cmluZ2lmeShfbWVzc2FnZSk7XHJcbiAgICAgIGZvciAobGV0IGFyZyBvZiBfYXJncylcclxuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgTnVtYmVyKVxyXG4gICAgICAgICAgb3V0ICs9IFwiLCBcIiArIGFyZy50b1ByZWNpc2lvbigyKS50b1N0cmluZygpOyAvL0pTT04uc3RyaW5naWZ5KGFyZywgbnVsbCwgMik7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgb3V0ICs9IFwiLCBcIiArIGFyZy50b1N0cmluZygpOyAvL0pTT04uc3RyaW5naWZ5KGFyZywgbnVsbCwgMik7XHJcbiAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdBbGVydC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogVGhlIGZpbHRlcnMgY29ycmVzcG9uZGluZyB0byBkZWJ1ZyBhY3Rpdml0aWVzLCBtb3JlIHRvIGNvbWVcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBERUJVR19GSUxURVIge1xyXG4gICAgTk9ORSA9IDB4MDAsXHJcbiAgICBJTkZPID0gMHgwMSxcclxuICAgIExPRyA9IDB4MDIsXHJcbiAgICBXQVJOID0gMHgwNCxcclxuICAgIEVSUk9SID0gMHgwOCxcclxuICAgIEZVREdFID0gMHgxMCxcclxuICAgIENMRUFSID0gMHgxMDAsXHJcbiAgICBHUk9VUCA9IDB4MTAxLFxyXG4gICAgR1JPVVBDT0xMQVBTRUQgPSAweDEwMixcclxuICAgIEdST1VQRU5EID0gMHgxMDQsXHJcbiAgICBTT1VSQ0UgPSAweDIwMCxcclxuICAgIE1FU1NBR0VTID0gSU5GTyB8IExPRyB8IFdBUk4gfCBFUlJPUiB8IEZVREdFLFxyXG4gICAgRk9STUFUID0gQ0xFQVIgfCBHUk9VUCB8IEdST1VQQ09MTEFQU0VEIHwgR1JPVVBFTkQsXHJcbiAgICBBTEwgPSBNRVNTQUdFUyB8IEZPUk1BVFxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNvbnN0IERFQlVHX1NZTUJPTDogeyBbZmlsdGVyOiBudW1iZXJdOiBzdHJpbmcgfSA9IHtcclxuICAgIFtERUJVR19GSUxURVIuSU5GT106IFwi4pyTXCIsXHJcbiAgICBbREVCVUdfRklMVEVSLkxPR106IFwi4pyOXCIsXHJcbiAgICBbREVCVUdfRklMVEVSLldBUk5dOiBcIuKaoFwiLFxyXG4gICAgW0RFQlVHX0ZJTFRFUi5FUlJPUl06IFwi4p2MXCIsXHJcbiAgICBbREVCVUdfRklMVEVSLkZVREdFXTogXCLwn46yXCIsXHJcbiAgICBbREVCVUdfRklMVEVSLlNPVVJDRV06IFwi8J+Ul1wiXHJcbiAgfTtcclxuXHJcbiAgZXhwb3J0IHR5cGUgTWFwRGVidWdUYXJnZXRUb0RlbGVnYXRlID0gTWFwPERlYnVnVGFyZ2V0LCBGdW5jdGlvbj47XHJcbiAgZXhwb3J0IGludGVyZmFjZSBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGUgeyBbZmlsdGVyOiBudW1iZXJdOiBGdW5jdGlvbiB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnVGFyZ2V0LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBSb3V0aW5nIHRvIHRoZSBzdGFuZGFyZC1jb25zb2xlXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIERlYnVnQ29uc29sZSBleHRlbmRzIERlYnVnVGFyZ2V0IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZWdhdGVzOiBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGUgPSB7XHJcbiAgICAgIFtERUJVR19GSUxURVIuSU5GT106IGNvbnNvbGUuaW5mbyxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5MT0ddOiBjb25zb2xlLmxvZyxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5XQVJOXTogY29uc29sZS53YXJuLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkVSUk9SXTogY29uc29sZS5lcnJvcixcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5GVURHRV06IERlYnVnQ29uc29sZS5mdWRnZSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5DTEVBUl06IGNvbnNvbGUuY2xlYXIsXHJcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBdOiBjb25zb2xlLmdyb3VwLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQQ09MTEFQU0VEXTogY29uc29sZS5ncm91cENvbGxhcHNlZCxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUEVORF06IGNvbnNvbGUuZ3JvdXBFbmQsXHJcbiAgICAgIFtERUJVR19GSUxURVIuU09VUkNFXTogRGVidWdDb25zb2xlLnNvdXJjZVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3VsZCBiZSB1c2VkIHRvIGRpc3BsYXkgdW5jcml0aWNhbCBzdGF0ZSBpbmZvcm1hdGlvbiBvZiBGVURHRSwgb25seSB2aXNpYmxlIGluIGJyb3dzZXIncyB2ZXJib3NlIG1vZGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBmdWRnZShfbWVzc2FnZTogT2JqZWN0LCAuLi5fYXJnczogT2JqZWN0W10pOiB2b2lkIHtcclxuICAgICAgY29uc29sZS5kZWJ1ZyhERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkZVREdFXSwgX21lc3NhZ2UsIC4uLl9hcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc3BsYXlzIGFuIGV4dHJhIGxpbmUgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc291cmNlIG9mIHRoZSBkZWJ1ZyBtZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc291cmNlKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICBjb25zb2xlLmxvZyhERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLlNPVVJDRV0sIF9tZXNzYWdlLCAuLi5fYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Z1RhcmdldC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnSW50ZXJmYWNlcy50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnQ29uc29sZS50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogVGhlIERlYnVnLUNsYXNzIG9mZmVycyBmdW5jdGlvbnMga25vd24gZnJvbSB0aGUgY29uc29sZS1vYmplY3QgYW5kIGFkZGl0aW9ucywgXHJcbiAgICogcm91dGluZyB0aGUgaW5mb3JtYXRpb24gdG8gdmFyaW91cyB7QGxpbmsgRGVidWdUYXJnZXR9cyB0aGF0IGNhbiBiZSBlYXNpbHkgZGVmaW5lZCBieSB0aGUgZGV2ZWxvcGVycyBhbmQgcmVnaXN0ZXJkIGJ5IHVzZXJzXHJcbiAgICogT3ZlcnJpZGUgZnVuY3Rpb25zIGluIHN1YmNsYXNzZXMgb2Yge0BsaW5rIERlYnVnVGFyZ2V0fSBhbmQgcmVnaXN0ZXIgdGhlbSBhcyB0aGVpciBkZWxlZ2F0ZXNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRGVidWcge1xyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgZWFjaCBzZXQgZmlsdGVyLCB0aGlzIGFzc29jaWF0aXZlIGFycmF5IGtlZXBzIHJlZmVyZW5jZXMgdG8gdGhlIHJlZ2lzdGVyZWQgZGVsZWdhdGUgZnVuY3Rpb25zIG9mIHRoZSBjaG9zZW4ge0BsaW5rIERlYnVnVGFyZ2V0fXNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZGVsZWdhdGVzOiB7IFtmaWx0ZXI6IG51bWJlcl06IE1hcERlYnVnVGFyZ2V0VG9EZWxlZ2F0ZSB9ID0gRGVidWcuc2V0dXBDb25zb2xlKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZS0gLyBBY3RpdmF0ZSBhIGZpbHRlciBmb3IgdGhlIGdpdmVuIERlYnVnVGFyZ2V0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXRGaWx0ZXIoX3RhcmdldDogRGVidWdUYXJnZXQsIF9maWx0ZXI6IERFQlVHX0ZJTFRFUik6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBmaWx0ZXIgaW4gRGVidWcuZGVsZWdhdGVzKVxyXG4gICAgICAgIERlYnVnLmRlbGVnYXRlc1tmaWx0ZXJdLmRlbGV0ZShfdGFyZ2V0KTtcclxuXHJcbiAgICAgIGZvciAobGV0IGZpbHRlciBpbiBERUJVR19GSUxURVIpIHtcclxuICAgICAgICBsZXQgcGFyc2VkOiBudW1iZXIgPSBwYXJzZUludChmaWx0ZXIpO1xyXG4gICAgICAgIGlmIChpc05hTihwYXJzZWQpKVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgaWYgKFtERUJVR19GSUxURVIuTUVTU0FHRVMsIERFQlVHX0ZJTFRFUi5GT1JNQVQsIERFQlVHX0ZJTFRFUi5BTExdLmluZGV4T2YocGFyc2VkKSAhPSAtMSlcclxuICAgICAgICAgIC8vIGRvbnQgZGVsZWdhdGUgY29tYm9zLi4uIFxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKF9maWx0ZXIgJiBwYXJzZWQpXHJcbiAgICAgICAgICBEZWJ1Zy5kZWxlZ2F0ZXNbcGFyc2VkXS5zZXQoX3RhcmdldCwgX3RhcmdldC5kZWxlZ2F0ZXNbcGFyc2VkXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZmlsdGVyKHMpIGZvciB0aGUgZ2l2ZW4gRGVidWdUYXJnZXQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEZpbHRlcihfdGFyZ2V0OiBEZWJ1Z1RhcmdldCk6IERFQlVHX0ZJTFRFUiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IERFQlVHX0ZJTFRFUiA9IDA7XHJcbiAgICAgIGZvciAobGV0IGZpbHRlciBpbiBfdGFyZ2V0LmRlbGVnYXRlcylcclxuICAgICAgICByZXN1bHQgfD0gcGFyc2VJbnQoZmlsdGVyKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGZpbHRlciB0byB0aGUgZ2l2ZW4gRGVidWdUYXJnZXQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFkZEZpbHRlcihfdGFyZ2V0OiBEZWJ1Z1RhcmdldCwgX2ZpbHRlcjogREVCVUdfRklMVEVSKTogdm9pZCB7XHJcbiAgICAgIGxldCBjdXJyZW50OiBERUJVR19GSUxURVIgPSBEZWJ1Zy5nZXRGaWx0ZXIoX3RhcmdldCk7XHJcbiAgICAgIERlYnVnLnNldEZpbHRlcihfdGFyZ2V0LCBjdXJyZW50IHwgX2ZpbHRlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYSBmaWx0ZXIgZnJvbSB0aGUgZ2l2ZW4gRGVidWdUYXJnZXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVtb3ZlRmlsdGVyKF90YXJnZXQ6IERlYnVnVGFyZ2V0LCBfZmlsdGVyOiBERUJVR19GSUxURVIpOiB2b2lkIHtcclxuICAgICAgbGV0IGN1cnJlbnQ6IERFQlVHX0ZJTFRFUiA9IERlYnVnLmdldEZpbHRlcihfdGFyZ2V0KTtcclxuICAgICAgRGVidWcuc2V0RmlsdGVyKF90YXJnZXQsIGN1cnJlbnQgXiBfZmlsdGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZm8oLi4uKSBkaXNwbGF5cyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHdpdGggbG93IHByaW9yaXR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaW5mbyhfbWVzc2FnZTogdW5rbm93biwgLi4uX2FyZ3M6IHVua25vd25bXSk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuSU5GTywgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgaW5mb3JtYXRpb24gd2l0aCBtZWRpdW0gcHJpb3JpdHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBsb2coX21lc3NhZ2U6IHVua25vd24sIC4uLl9hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkxPRywgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgaW5mb3JtYXRpb24gYWJvdXQgbm9uLWNvbmZvcm1pdGllcyBpbiB1c2FnZSwgd2hpY2ggaXMgZW1waGFzaXplZCBlLmcuIGJ5IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgd2FybihfbWVzc2FnZTogdW5rbm93biwgLi4uX2FyZ3M6IHVua25vd25bXSk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuV0FSTiwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgY3JpdGljYWwgaW5mb3JtYXRpb24gYWJvdXQgZmFpbHVyZXMsIHdoaWNoIGlzIGVtcGhhc2l6ZWQgZS5nLiBieSBjb2xvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGVycm9yKF9tZXNzYWdlOiB1bmtub3duLCAuLi5fYXJnczogdW5rbm93bltdKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5FUlJPUiwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGxheXMgbWVzc2FnZXMgZnJvbSBGVURHRVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGZ1ZGdlKF9tZXNzYWdlOiB1bmtub3duLCAuLi5fYXJnczogdW5rbm93bltdKTogdm9pZCB7XHJcbiAgICAgIERlYnVnLmRlbGVnYXRlKERFQlVHX0ZJTFRFUi5GVURHRSwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBvdXRwdXQgYW5kIHJlbW92ZXMgcHJldmlvdXMgbWVzc2FnZXMgaWYgcG9zc2libGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGVhcigpOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLkNMRUFSLCBudWxsLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgYSBuZXcgZ3JvdXAgZm9yIG1lc3NhZ2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXAoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuR1JPVVAsIF9uYW1lLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgYSBuZXcgZ3JvdXAgZm9yIG1lc3NhZ2VzIHRoYXQgaXMgY29sbGFwc2VkIGF0IGZpcnN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXBDb2xsYXBzZWQoX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuR1JPVVBDT0xMQVBTRUQsIF9uYW1lLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoZSB5b3VuZ2VzdCBncm91cFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdyb3VwRW5kKCk6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5kZWxlZ2F0ZShERUJVR19GSUxURVIuR1JPVVBFTkQsIG51bGwsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgYSBicmFuY2ggb2YgdGhlIG5vZGUgaGllcmFyY2h5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYnJhbmNoKF9icmFuY2g6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgaWYgKF9icmFuY2gubkNoaWxkcmVuID4gMClcclxuICAgICAgICBEZWJ1Zy5ncm91cChfYnJhbmNoLm5hbWUpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgRGVidWcuZnVkZ2UoX2JyYW5jaC5uYW1lKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIF9icmFuY2guZ2V0Q2hpbGRyZW4oKSkgRGVidWcuYnJhbmNoKGNoaWxkKTtcclxuXHJcbiAgICAgIGlmIChfYnJhbmNoLm5DaGlsZHJlbiA+IDApXHJcbiAgICAgICAgRGVidWcuZ3JvdXBFbmQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc3BsYXlzIG1lc3NhZ2VzIGFib3V0IHRoZSBzb3VyY2Ugb2YgdGhlIGRlYnVnIGNhbGxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzb3VyY2UoX21lc3NhZ2U6IHVua25vd24sIC4uLl9hcmdzOiB1bmtub3duW10pOiB2b2lkIHtcclxuICAgICAgRGVidWcuZGVsZWdhdGUoREVCVUdfRklMVEVSLlNPVVJDRSwgX21lc3NhZ2UsIF9hcmdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvb2t1cCBhbGwgZGVsZWdhdGVzIHJlZ2lzdGVyZWQgdG8gdGhlIGZpbHRlciBhbmQgY2FsbCB0aGVtIHVzaW5nIHRoZSBnaXZlbiBhcmd1bWVudHNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZGVsZWdhdGUoX2ZpbHRlcjogREVCVUdfRklMVEVSLCBfbWVzc2FnZTogdW5rbm93biwgX2FyZ3M6IHVua25vd25bXSk6IHZvaWQge1xyXG4gICAgICBpZiAoX2ZpbHRlciA9PSBERUJVR19GSUxURVIuTE9HIHx8IF9maWx0ZXIgPT0gREVCVUdfRklMVEVSLldBUk4gfHwgX2ZpbHRlciA9PSBERUJVR19GSUxURVIuRVJST1IpIHtcclxuICAgICAgICBpZiAoRGVidWcuZGVsZWdhdGVzW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdKVxyXG4gICAgICAgICAgZm9yIChsZXQgZGVsZWdhdGUgb2YgRGVidWcuZGVsZWdhdGVzW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdLnZhbHVlcygpKVxyXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcclxuICAgICAgICAgICAgICBsZXQgdHJhY2U6IHN0cmluZ1tdID0gbmV3IEVycm9yKFwiVGVzdFwiKS5zdGFjay5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICAgICAgICBkZWxlZ2F0ZSh0cmFjZVszXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBsZXQgZGVsZWdhdGVzOiBNYXBEZWJ1Z1RhcmdldFRvRGVsZWdhdGUgPSBEZWJ1Zy5kZWxlZ2F0ZXNbX2ZpbHRlcl07XHJcbiAgICAgIGZvciAobGV0IGRlbGVnYXRlIG9mIGRlbGVnYXRlcy52YWx1ZXMoKSlcclxuICAgICAgICBpZiAoZGVsZWdhdGUpXHJcbiAgICAgICAgICBpZiAoX2FyZ3MgJiYgX2FyZ3MubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgZGVsZWdhdGUoX21lc3NhZ2UsIC4uLl9hcmdzKTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZGVsZWdhdGUoX21lc3NhZ2UpO1xyXG5cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogc2V0dXAgcm91dGluZyB0byBzdGFuZGFyZCBjb25zb2xlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHNldHVwQ29uc29sZSgpOiB7fSB7XHJcbiAgICAgIGxldCByZXN1bHQ6IHsgW2ZpbHRlcjogbnVtYmVyXTogTWFwRGVidWdUYXJnZXRUb0RlbGVnYXRlIH0gPSB7fTtcclxuICAgICAgbGV0IGZpbHRlcnM6IERFQlVHX0ZJTFRFUltdID0gW1xyXG4gICAgICAgIERFQlVHX0ZJTFRFUi5JTkZPLCBERUJVR19GSUxURVIuTE9HLCBERUJVR19GSUxURVIuV0FSTiwgREVCVUdfRklMVEVSLkVSUk9SLCBERUJVR19GSUxURVIuRlVER0UsXHJcbiAgICAgICAgREVCVUdfRklMVEVSLkNMRUFSLCBERUJVR19GSUxURVIuR1JPVVAsIERFQlVHX0ZJTFRFUi5HUk9VUENPTExBUFNFRCwgREVCVUdfRklMVEVSLkdST1VQRU5ELFxyXG4gICAgICAgIERFQlVHX0ZJTFRFUi5TT1VSQ0VcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGZvciAobGV0IGZpbHRlciBvZiBmaWx0ZXJzKVxyXG4gICAgICAgIHJlc3VsdFtmaWx0ZXJdID0gbmV3IE1hcChbW0RlYnVnQ29uc29sZSwgRGVidWdDb25zb2xlLmRlbGVnYXRlc1tmaWx0ZXJdXV0pO1xyXG5cclxuICAgICAgcmVzdWx0W0RFQlVHX0ZJTFRFUi5TT1VSQ0VdLmRlbGV0ZShEZWJ1Z0NvbnNvbGUpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIE1hcEV2ZW50VHlwZVRvTGlzdGVuZXJzIHtcclxuICAgIFtldmVudFR5cGU6IHN0cmluZ106IFNldDxFdmVudExpc3RlbmVyVW5pZmllZD47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUeXBlcyBvZiBldmVudHMgc3BlY2lmaWMgdG8gRlVER0UsIGluIGFkZGl0aW9uIHRvIHRoZSBzdGFuZGFyZCBET00vQnJvd3Nlci1UeXBlcyBhbmQgY3VzdG9tIHN0cmluZ3NcclxuICAgKi9cclxuICBleHBvcnQgY29uc3QgZW51bSBFVkVOVCB7XHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB0YXJnZXRzIHJlZ2lzdGVyZWQgYXQge0BsaW5rIExvb3B9LCB3aGVuIHJlcXVlc3RlZCBhbmltYXRpb24gZnJhbWUgc3RhcnRzICovXHJcbiAgICBMT09QX0ZSQU1FID0gXCJsb29wRnJhbWVcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEge0BsaW5rIENvbXBvbmVudH0gd2hlbiBpdHMgYmVpbmcgYWRkZWQgdG8gYSB7QGxpbmsgTm9kZX0gKi9cclxuICAgIENPTVBPTkVOVF9BREQgPSBcImNvbXBvbmVudEFkZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gYSB7QGxpbmsgQ29tcG9uZW50fSB3aGVuIGl0cyBiZWluZyByZW1vdmVkIGZyb20gYSB7QGxpbmsgTm9kZX0gKi9cclxuICAgIENPTVBPTkVOVF9SRU1PVkUgPSBcImNvbXBvbmVudFJlbW92ZVwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gYSB7QGxpbmsgQ29tcG9uZW50fSB3aGVuIGl0cyBiZWluZyBhY3RpdmF0ZWQgKi9cclxuICAgIENPTVBPTkVOVF9BQ1RJVkFURSA9IFwiY29tcG9uZW50QWN0aXZhdGVcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEge0BsaW5rIENvbXBvbmVudH0gd2hlbiBpdHMgYmVpbmcgZGVhY3RpdmF0ZWQgKi9cclxuICAgIENPTVBPTkVOVF9ERUFDVElWQVRFID0gXCJjb21wb25lbnREZWFjdGl2YXRlXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIHtAbGluayBOb2RlfSwgaXQncyBzdWNjZXNzb3JzIGFuZCBhbmNlc3RvcnMgd2hlbiBpdHMgYmVpbmcgYWN0aXZhdGVkICovXHJcbiAgICBOT0RFX0FDVElWQVRFID0gXCJub2RlQWN0aXZhdGVcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEge0BsaW5rIE5vZGV9LCBpdCdzIHN1Y2Nlc3NvcnMgYW5kIGFuY2VzdG9ycyB3aGVuIGl0cyBiZWluZyBkZWFjdGl2YXRlZCAqL1xyXG4gICAgTk9ERV9ERUFDVElWQVRFID0gXCJub2RlRGVhY3RpdmF0ZVwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8gYSBjaGlsZCB7QGxpbmsgTm9kZX0gYW5kIGl0cyBhbmNlc3RvcnMgYWZ0ZXIgaXQgd2FzIGFwcGVuZGVkIHRvIGEgcGFyZW50ICovXHJcbiAgICBDSElMRF9BUFBFTkQgPSBcImNoaWxkQXBwZW5kXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byBhIGNoaWxkIHtAbGluayBOb2RlfSBhbmQgaXRzIGFuY2VzdG9ycyBqdXN0IGJlZm9yZSBpdHMgYmVpbmcgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgKi9cclxuICAgIENISUxEX1JFTU9WRSA9IFwiY2hpbGRSZW1vdmVcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIGEge0BsaW5rIE11dGFibGV9IHdoZW4gaXQgbXV0YXRlcyAqL1xyXG4gICAgTVVUQVRFID0gXCJtdXRhdGVcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIGJ5IGEge0BsaW5rIEdyYXBofSB3aGVuIGl0IG11dGF0ZXMsIHtAbGluayBHcmFwaEluc3RhbmNlfXMgY29ubmVjdGVkIHRvIHRoZSBncmFwaCBsaXN0ZW4gKi9cclxuICAgIE1VVEFURV9HUkFQSCA9IFwibXV0YXRlR3JhcGhcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIGJ5IGEge0BsaW5rIEdyYXBoSW5zdGFuY2V9IHdoZW4gaXQgcmVmbGVjdGVkIHRoZSBtdXRhdGlvbiBvZiB0aGUge0BsaW5rIEdyYXBofSBpdCdzIGNvbm5lY3RlZCB0byAqL1xyXG4gICAgTVVUQVRFX0lOU1RBTkNFID0gXCJtdXRhdGVHcmFwaERvbmVcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBWaWV3cG9ydH0gd2hlbiBpdCBnZXRzIHRoZSBmb2N1cyB0byByZWNlaXZlIGtleWJvYXJkIGlucHV0ICovXHJcbiAgICBGT0NVU19JTiA9IFwiZm9jdXNpblwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIFZpZXdwb3J0fSB3aGVuIGl0IGxvc2VzIHRoZSBmb2N1cyB0byByZWNlaXZlIGtleWJvYXJkIGlucHV0ICovXHJcbiAgICBGT0NVU19PVVQgPSBcImZvY3Vzb3V0XCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgTm9kZX0gd2hlbiBpdCdzIGRvbmUgc2VyaWFsaXppbmcgKi9cclxuICAgIE5PREVfU0VSSUFMSVpFRCA9IFwibm9kZVNlcmlhbGl6ZWRcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBOb2RlfSBhbmQgYWxsIGl0cyB7QGxpbmsgQ29tcG9uZW50fXMgd2hlbiBpdCdzIGRvbmUgZGVzZXJpYWxpemluZywgc28gYWxsIGNvbXBvbmVudHMsIGNoaWxkcmVuIGFuZCBhdHRyaWJ1dGVzIGFyZSBhdmFpbGFibGUgKi9cclxuICAgIE5PREVfREVTRVJJQUxJWkVEID0gXCJub2RlRGVzZXJpYWxpemVkXCIsXHJcbiAgICAvKiogYnJvYWRjYXN0IGZyb20gYSB7QGxpbmsgR3JhcGhJbnN0YW5jZX0gdG8gYWxsIGl0cyBkZXNjZW5kYW50cyB3aGVuIGl0J3MgY29udGVudCBpcyBzZXQgYWNjb3JkaW5nIHRvIGEgc2VyaWFsaXphdGlvbiBvZiBhIHtAbGluayBHcmFwaH0uIEJyb2FkY2FzdGVkLCBzbyBuZWVkcyB0byBiZSBjYXVnaHQgaW4gY2FwdHVyZS4gKi9cclxuICAgIEdSQVBIX0lOU1RBTlRJQVRFRCA9IFwiZ3JhcGhJbnN0YW50aWF0ZWRcIixcclxuICAgIC8qKiBicm9hZGNhc3QgZnJvbSBhIHtAbGluayBHcmFwaH0gdG8gYWxsIGl0cyBkZXNjZW5kYW50cyB3aGVuIGl0J3MgZmluaXNoZWQgZGVzZXJpYWxpemluZy4gQnJvYWRjYXN0ZWQsIHNvIG5lZWRzIHRvIGJlIGNhdWdodCBpbiBjYXB0dXJlLiAqL1xyXG4gICAgR1JBUEhfREVTRVJJQUxJWkVEID0gXCJncmFwaERlc2VyaWFsaXplZFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgYnkgYSB7QGxpbmsgR3JhcGh9IHdoZW4gaXQgYW5kIGl0cyBjb25uZWN0ZWQgaW5zdGFuY2VzIGhhdmUgZmluaXNoZWQgbXV0YXRpbmcgICovXHJcbiAgICBHUkFQSF9NVVRBVEVEID0gXCJncmFwaE11dGF0ZWRcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBUaW1lfSB3aGVuIGl0J3Mgc2NhbGluZyBjaGFuZ2VkICAqL1xyXG4gICAgVElNRV9TQ0FMRUQgPSBcInRpbWVTY2FsZWRcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBGaWxlSW9Ccm93c2VyTG9jYWx9IHdoZW4gYSBsaXN0IG9mIGZpbGVzIGhhcyBiZWVuIGxvYWRlZCAgKi9cclxuICAgIEZJTEVfTE9BREVEID0gXCJmaWxlTG9hZGVkXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgRmlsZUlvQnJvd3NlckxvY2FsfSB3aGVuIGEgbGlzdCBvZiBmaWxlcyBoYXMgYmVlbiBzYXZlZCAqL1xyXG4gICAgRklMRV9TQVZFRCA9IFwiZmlsZVNhdmVkXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgTm9kZX0gd2hlbiByZWNhbGN1bGF0aW5nIHRyYW5zZm9ybXMgZm9yIHJlbmRlciAqL1xyXG4gICAgUkVOREVSX1BSRVBBUkUgPSBcInJlbmRlclByZXBhcmVcIixcclxuICAgIC8qKiBkaXNwYXRjaGVkIHRvIHtAbGluayBWaWV3cG9ydH0gYW5kIHtAbGluayBOb2RlfSB3aGVuIHJlY2FsY3VsYXRpb24gb2YgdGhlIGJyYW5jaCB0byByZW5kZXIgc3RhcnRzLiAqL1xyXG4gICAgUkVOREVSX1BSRVBBUkVfU1RBUlQgPSBcInJlbmRlclByZXBhcmVTdGFydFwiLFxyXG4gICAgLyoqIGRpc3BhdGNoZWQgdG8ge0BsaW5rIFZpZXdwb3J0fSBhbmQge0BsaW5rIE5vZGV9IHdoZW4gcmVjYWxjdWxhdGlvbiBvZiB0aGUgYnJhbmNoIHRvIHJlbmRlciBlbmRzLiBUaGUgYnJhbmNoIGRpc3BhdGNoZXMgYmVmb3JlIHRoZSBsaWdodHMgYXJlIHRyYW5zbWl0dGVkIHRvIHRoZSBzaGFkZXJzICAqL1xyXG4gICAgUkVOREVSX1BSRVBBUkVfRU5EID0gXCJyZW5kZXJQcmVwYXJlRW5kXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgVmlld3BvcnR9IGF0IHRoZSBlbmQgb2YgYSByZW5kZXJlZCBmcmFtZSByaWdodCBiZWZvcmUgaXQgZ2V0cyBkaXNwbGF5ZWQuIEF0IHRoaXMgcG9pbnQge0BsaW5rIEdpem1vc30gY2FuIHN0aWxsIGJlIGRyYXduLiAqL1xyXG4gICAgUkVOREVSX0VORCA9IFwicmVuZGVyRW5kXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgSm9pbnR9LUNvbXBvbmVudHMgaW4gb3JkZXIgdG8gZGlzY29ubmVjdCAqL1xyXG4gICAgRElTQ09OTkVDVF9KT0lOVCA9IFwiZGlzY29ubmVjdEpvaW50XCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgTm9kZX0gd2hlbiBpdCBnZXRzIGF0dGFjaGVkIHRvIGEgdmlld3BvcnQgZm9yIHJlbmRlcmluZy4gQnJvYWRjYXN0ZWQsIHNvIG5lZWRzIHRvIGJlIGNhdWdodCBpbiBjYXB0dXJlLiAqL1xyXG4gICAgQVRUQUNIX0JSQU5DSCA9IFwiYXR0YWNoQnJhbmNoXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgUHJvamVjdH0gd2hlbiBpdCdzIGRvbmUgbG9hZGluZyByZXNvdXJjZXMgZnJvbSBhIHVybCAqL1xyXG4gICAgUkVTT1VSQ0VTX0xPQURFRCA9IFwicmVzb3VyY2VzTG9hZGVkXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgQ29tcG9uZW50V2Fsa2VyfSBhbmQge0BsaW5rIENvbXBvbmVudFdheXBvaW50fSB3aGVuIGEge0BsaW5rIENvbXBvbmVudFdhbGtlcn0gcmVhY2hlcyBhIHtAbGluayBXYXlwb2ludH0gb3Ige0BsaW5rIENvbXBvbmVudFdheXBvaW50fSAqL1xyXG4gICAgV0FZUE9JTlRfUkVBQ0hFRCA9IFwid2F5cG9pbnRSZWFjaGVkXCIsXHJcbiAgICAvKiogZGlzcGF0Y2hlZCB0byB7QGxpbmsgQ29tcG9uZW50V2Fsa2VyfSB3aGVuIHRoZSBmaW5hbCB7QGxpbmsgV2F5cG9pbnR9IGluIHRoZSBjdXJyZW50IHBhdGggaGFzIGJlZW4gcmVhY2hlZCAqL1xyXG4gICAgUEFUSElOR19DT05DTFVERUQgPSBcInBhdGhpbmdDb25jbHVkZWRcIlxyXG4gIH1cclxuXHJcbiAgLyoqIFVuaW9uIHR5cGUgb2Ygb3RoZXIgZXZlbnQgdHlwZXMgc2VydmluZyBhcyBhbm5vdGF0aW9uIGZvciBsaXN0ZW5lcnMgYW5kIGhhbmRsZXJzICovXHJcbiAgZXhwb3J0IHR5cGUgRXZlbnRVbmlmaWVkID0gRXZlbnQgfCBDdXN0b21FdmVudCB8IEV2ZW50UGh5c2ljcztcclxuXHJcbiAgLyoqIFVuaWZpZWQgbGlzdGVuZXIgdHlwZSBleHRlbmRpbmcgRXZlbnRMaXN0ZW5lciBhbmQgRXZlbnRMaXN0ZW5lck9iamVjdCBmb3IgQ3VzdG9tRXZlbnQgYW5kIG90aGVycyAqL1xyXG4gIGV4cG9ydCB0eXBlIEV2ZW50TGlzdGVuZXJVbmlmaWVkID1cclxuICAgICgoX2V2ZW50OiBFdmVudCkgPT4gdm9pZCkgfFxyXG4gICAgKChfZXZlbnQ6IEN1c3RvbUV2ZW50KSA9PiB2b2lkKSB8XHJcbiAgICAoKF9ldmVudDogRXZlbnRQaHlzaWNzKSA9PiB2b2lkKSB8XHJcbiAgICAoKF9ldmVudDogRXZlbnRUaW1lcikgPT4gdm9pZCkgfFxyXG4gICAgRXZlbnRMaXN0ZW5lciB8XHJcbiAgICBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0O1xyXG5cclxuICAvKiogRXh0ZW5kcyBFdmVudFRhcmdldCB0byB3b3JrIHdpdGgge0BsaW5rIEV2ZW50TGlzdGVuZXJVbmlmaWVkfSBhbmQge0BsaW5rIEV2ZW50VW5pZmllZH0gKi9cclxuICBleHBvcnQgY2xhc3MgRXZlbnRUYXJnZXRVbmlmaWVkIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWUge0BsaW5rIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXJ9IGZvciByZWZlcmVuY2UuIFdvcmtzIHdpdGgge0BsaW5rIEV2ZW50TGlzdGVuZXJVbmlmaWVkfSBhbmQge0BsaW5rIEV2ZW50VW5pZmllZH1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZEV2ZW50TGlzdGVuZXIoX3R5cGU6IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXJVbmlmaWVkLCBfb3B0aW9ucz86IGJvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICBzdXBlci5hZGRFdmVudExpc3RlbmVyKF90eXBlLCA8RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdD5faGFuZGxlciwgX29wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VlIHtAbGluayBFdmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyfSBmb3IgcmVmZXJlbmNlLiBXb3JrcyB3aXRoIHtAbGluayBFdmVudExpc3RlbmVyVW5pZmllZH0gYW5kIHtAbGluayBFdmVudFVuaWZpZWR9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVFdmVudExpc3RlbmVyKF90eXBlOiBzdHJpbmcsIF9oYW5kbGVyOiBFdmVudExpc3RlbmVyVW5pZmllZCwgX29wdGlvbnM/OiBib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdHlwZSwgPEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3Q+X2hhbmRsZXIsIF9vcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlZSB7QGxpbmsgRXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudH0gZm9yIHJlZmVyZW5jZS4gV29ya3Mgd2l0aCB3aXRoIHtAbGluayBFdmVudFVuaWZpZWR9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkaXNwYXRjaEV2ZW50KF9ldmVudDogRXZlbnRVbmlmaWVkKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiBzdXBlci5kaXNwYXRjaEV2ZW50KF9ldmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCYXNlIGNsYXNzIGZvciBFdmVudFRhcmdldCBzaW5nbGV0b25zLCB3aGljaCBhcmUgZml4ZWQgZW50aXRpZXMgaW4gdGhlIHN0cnVjdHVyZSBvZiBGVURHRSwgc3VjaCBhcyB0aGUgY29yZSBsb29wIFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBFdmVudFRhcmdldFN0YXRpYyBleHRlbmRzIEV2ZW50VGFyZ2V0VW5pZmllZCB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHRhcmdldFN0YXRpYzogRXZlbnRUYXJnZXRTdGF0aWMgPSBuZXcgRXZlbnRUYXJnZXRTdGF0aWMoKTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8ge0BsaW5rIHRhcmdldFN0YXRpY30uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYWRkRXZlbnRMaXN0ZW5lcihfdHlwZTogc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lciwgX29wdGlvbnM/OiBib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpOiB2b2lkIHtcclxuICAgICAgRXZlbnRUYXJnZXRTdGF0aWMudGFyZ2V0U3RhdGljLmFkZEV2ZW50TGlzdGVuZXIoX3R5cGUsIF9oYW5kbGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIHtAbGluayB0YXJnZXRTdGF0aWN9LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlbW92ZUV2ZW50TGlzdGVuZXIoX3R5cGU6IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXIsIF9vcHRpb25zPzogYm9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgIEV2ZW50VGFyZ2V0U3RhdGljLnRhcmdldFN0YXRpYy5yZW1vdmVFdmVudExpc3RlbmVyKF90eXBlLCBfaGFuZGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYXRjaCBhbiBldmVudCBvbiB7QGxpbmsgdGFyZ2V0U3RhdGljfS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkaXNwYXRjaEV2ZW50KF9ldmVudDogRXZlbnQpOiBib29sZWFuIHtcclxuICAgICAgRXZlbnRUYXJnZXRTdGF0aWMudGFyZ2V0U3RhdGljLmRpc3BhdGNoRXZlbnQoX2V2ZW50KTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQSBzdWJjbGFzcyBvZiB7QGxpbmsgRXZlbnR9IHRoYXQgY2FuIGJlIChyZSl1c2VkIHZpYSB7QGxpbmsgUmVjeWNsYWJsZUV2ZW50LmdldH0gYW5kIHtAbGluayBSZWN5Y2xhYmxlRXZlbnQuc3RvcmV9IHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbi5cclxuICAgKiBJZiBkaXNwYXRjaGVkIHJlcGVhdGVkbHkgd2l0aG91dCByZWN5Y2xpbmcgdGhyb3VnaCBnZXQvc3RvcmUsIGNhbGwge0BsaW5rIHJlY3ljbGV9IG1hbnVhbGx5IGJlZm9yZSBlYWNoIGRpc3BhdGNoLlxyXG4gICAqIEV4cG9zZXMgc29tZSByZWFkb25seSBwcm9wZXJ0aWVzIG9mIHRoZSBldmVudCBjbGFzcyBhcyB3cml0YWJsZSBwcm9wZXJ0aWVzIGZvciB0aGUgZXZlbnQgc3lzdGVtLlxyXG4gICAqIFxyXG4gICAqICoqRXhhbXBsZSBnZXQvc3RvcmUqKjpcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogaW1wb3J0IGYgPSBGdWRnZUNvcmU7XHJcbiAgICogY29uc3Qgbm9kZTogZi5Ob2RlID0gbmV3IGYuTm9kZShcIk5vZGVcIik7XHJcbiAgICogY29uc3QgZXZlbnQ6IGYuUmVjeWNsYWJsZUV2ZW50ID0gZi5SZWN5Y2xhYmxlRXZlbnQuZ2V0KFwibXlldmVudFwiLCB0cnVlKTsgLy8gZ2V0IGV2ZW50IGZyb20gZGVwb3RcclxuICAgKiBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAqIGYuUmVjeWNsYWJsZUV2ZW50LnN0b3JlKGV2ZW50KTsgLy8gc3RvcmUgZXZlbnQgaW4gZGVwb3QgZm9yIHJldXNlXHJcbiAgICogYGBgXHJcbiAgICogXHJcbiAgICogKipFeGFtcGxlIG1hbnVhbCByZWN5Y2xlKio6XHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGltcG9ydCBmID0gRnVkZ2VDb3JlO1xyXG4gICAqIGNvbnN0IG5vZGU6IGYuTm9kZSA9IG5ldyBmLk5vZGUoXCJOb2RlXCIpO1xyXG4gICAqIGNvbnN0IGV2ZW50OiBmLlJlY3ljbGFibGVFdmVudCA9IGYuUmVjeWNsYWJsZUV2ZW50LmdldChcIm15ZXZlbnRcIiwgdHJ1ZSk7IC8vIGdldCBldmVudCBhbmQgY2FjaGUgaXRcclxuICAgKlxyXG4gICAqIC8vIGNhbGxlZCByZXBlYXRlZGx5LCBlLmcuIGluIGEgbG9vcFxyXG4gICAqIGZ1bmN0aW9uIHVwZGF0ZSgpOiB2b2lkIHtcclxuICAgKiAgIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudC5yZWN5Y2xlKCkpOyAvLyByZWN5Y2xlIHRoZSBldmVudCBiZWZvcmUgZWFjaCBkaXNwYXRjaFxyXG4gICAqIH1cclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9yIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZWN5Y2xhYmxlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XHJcbiAgICBzdGF0aWMgI2RlcG90OiB7IFt0eXBlOiBzdHJpbmddOiBSZWN5Y2FibGVBcnJheTxSZWN5Y2xhYmxlRXZlbnQ+IH0gPSB7fTtcclxuICAgIHN0YXRpYyAjaW5pdDogRXZlbnRJbml0ID0ge307XHJcblxyXG4gICAgcHVibGljIHJlYWRvbmx5IHBhdGg6IEV2ZW50VGFyZ2V0W10gPSBbXTsgLy8gZm9yIG5vdyB1c2UgYXJyYXksIGlmIGNvbnN0YW50IHJlc2l6aW5nIGJlY29tZXMgYSBtZXJtb3J5IHByb2JsZW0gZmluZCBhIGJldHRlciBzb2x1dGlvblxyXG5cclxuICAgICN0YXJnZXQ6IEV2ZW50VGFyZ2V0O1xyXG4gICAgI2N1cnJlbnRUYXJnZXQ6IEV2ZW50VGFyZ2V0O1xyXG4gICAgI2V2ZW50UGhhc2U6IEV2ZW50W1wiZXZlbnRQaGFzZVwiXTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3R5cGU6IHN0cmluZywgX2J1YmJsZXM6IGJvb2xlYW4gPSBmYWxzZSwgX2NhbmNlbGFibGU6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgICBSZWN5Y2xhYmxlRXZlbnQuI2luaXQuYnViYmxlcyA9IF9idWJibGVzO1xyXG4gICAgICBSZWN5Y2xhYmxlRXZlbnQuI2luaXQuY2FuY2VsYWJsZSA9IF9jYW5jZWxhYmxlO1xyXG4gICAgICBzdXBlcihfdHlwZSwgUmVjeWNsYWJsZUV2ZW50LiNpbml0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoZXMgYW4gZXZlbnQgb2YgdGhlIHJlcXVlc3RlZCB0eXBlIGFuZCBpbml0aWFsaXphdGlvbiBmcm9tIHRoZSBkZXBvdC4gSWYgdGhlIGRlcG90IGZvciB0aGUgcmVxdWVzdGVkIHR5cGUgaXMgZW1wdHkgaXQgcmV0dXJucyBhIG5ldyBpbnN0YW5jZS5cclxuICAgICAqIFVzZSB7QGxpbmsgUmVjeWNsYWJsZUV2ZW50LnN0b3JlfSBhZnRlciBkaXNwYXRjaGluZyB0aGUgZXZlbnQgdG8gc3RvcmUgaXQgZm9yIHJldXNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldChfdHlwZTogc3RyaW5nLCBfYnViYmxlczogYm9vbGVhbiA9IGZhbHNlLCBfY2FuY2VsYWJsZTogYm9vbGVhbiA9IGZhbHNlKTogUmVjeWNsYWJsZUV2ZW50IHtcclxuICAgICAgcmV0dXJuIFJlY3ljbGFibGVFdmVudC4jZGVwb3RbYCR7X3R5cGV9JHtfYnViYmxlc30ke19jYW5jZWxhYmxlfWBdPy5wb3AoKT8ucmVjeWNsZSgpID8/IG5ldyBSZWN5Y2xhYmxlRXZlbnQoX3R5cGUsIF9idWJibGVzLCBfY2FuY2VsYWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9yZXMgdGhlIGV2ZW50IGluIHRoZSBkZXBvdCBmb3IgbGF0ZXIgcmV1c2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc3RvcmUoX2V2ZW50OiBSZWN5Y2xhYmxlRXZlbnQpOiB2b2lkIHtcclxuICAgICAgKFJlY3ljbGFibGVFdmVudC4jZGVwb3RbYCR7X2V2ZW50LnR5cGV9JHtfZXZlbnQuYnViYmxlc30ke19ldmVudC5jYW5jZWxhYmxlfWBdID8/PSBuZXcgUmVjeWNhYmxlQXJyYXk8UmVjeWNsYWJsZUV2ZW50PigpKS5wdXNoKF9ldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbXB0eXMgdGhlIGRlcG90IG9mIGEgZ2l2ZW4gdHlwZSwgbGVhdmluZyB0aGUgZXZlbnRzIGZvciB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHVtcChfdHlwZTogc3RyaW5nLCBfYnViYmxlczogYm9vbGVhbiA9IGZhbHNlLCBfY2FuY2VsYWJsZTogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSBSZWN5Y2xhYmxlRXZlbnQuI2RlcG90W2Ake190eXBlfSR7X2J1YmJsZXN9JHtfY2FuY2VsYWJsZX1gXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVtcHR5cyBhbGwgZGVwb3RzLCBsZWF2aW5nIGFsbCBldmVudHMgdG8gdGhlIGdhcmJhZ2UgY29sbGVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGR1bXBBbGwoKTogdm9pZCB7XHJcbiAgICAgIFJlY3ljbGFibGVFdmVudC4jZGVwb3QgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKF9pbnN0YW5jZTogdW5rbm93bik6IGJvb2xlYW4geyAvLyBtdWNoIGZhc3RlciB0aGFuIGRlZmF1bHQgaW5zdGFuY2VvZlxyXG4gICAgICByZXR1cm4gKDxSZWN5Y2xhYmxlRXZlbnQ+X2luc3RhbmNlKS5pc1JlY3ljbGFibGVFdmVudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZsYWcgZm9yIGZhc3QgdHlwZSBjaGVja2luZy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBpc1JlY3ljbGFibGVFdmVudCgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB0YXJnZXQoKTogRXZlbnRUYXJnZXQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jdGFyZ2V0ID8/IHN1cGVyLnRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGN1cnJlbnRUYXJnZXQoKTogRXZlbnRUYXJnZXQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY3VycmVudFRhcmdldCA/PyBzdXBlci5jdXJyZW50VGFyZ2V0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgZXZlbnRQaGFzZSgpOiBFdmVudFtcImV2ZW50UGhhc2VcIl0ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jZXZlbnRQaGFzZSA/PyBzdXBlci5ldmVudFBoYXNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB0YXJnZXQgb2YgdGhlIGV2ZW50LiBVc2VkIGJ5IHRoZSBldmVudCBzeXN0ZW0uXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0VGFyZ2V0KF90YXJnZXQ6IEV2ZW50VGFyZ2V0KTogUmVjeWNsYWJsZUV2ZW50IHtcclxuICAgICAgdGhpcy4jdGFyZ2V0ID0gX3RhcmdldDtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGN1cnJlbnQgdGFyZ2V0IG9mIHRoZSBldmVudC4gVXNlZCBieSB0aGUgZXZlbnQgc3lzdGVtLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBldmVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEN1cnJlbnRUYXJnZXQoX2N1cnJlbnRUYXJnZXQ6IEV2ZW50VGFyZ2V0KTogUmVjeWNsYWJsZUV2ZW50IHtcclxuICAgICAgdGhpcy4jY3VycmVudFRhcmdldCA9IF9jdXJyZW50VGFyZ2V0O1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZXZlbnQgcGhhc2Ugb2YgdGhlIGV2ZW50LiBVc2VkIGJ5IHRoZSBldmVudCBzeXN0ZW0uXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0RXZlbnRQaGFzZShfZXZlbnRQaGFzZTogRXZlbnRbXCJOT05FXCJdIHwgRXZlbnRbXCJDQVBUVVJJTkdfUEhBU0VcIl0gfCBFdmVudFtcIkFUX1RBUkdFVFwiXSB8IEV2ZW50W1wiQlVCQkxJTkdfUEhBU0VcIl0pOiBSZWN5Y2xhYmxlRXZlbnQge1xyXG4gICAgICB0aGlzLiNldmVudFBoYXNlID0gX2V2ZW50UGhhc2U7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGV2ZW50IHRvIGRlZmF1bHQgdmFsdWVzLiBVc2VkIGJ5IHRoZSBldmVudCBzeXN0ZW0uXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiBSZWN5Y2xhYmxlRXZlbnQge1xyXG4gICAgICB0aGlzLiN0YXJnZXQgPSBudWxsO1xyXG4gICAgICB0aGlzLiNjdXJyZW50VGFyZ2V0ID0gbnVsbDtcclxuICAgICAgdGhpcy4jZXZlbnRQaGFzZSA9IG51bGw7XHJcbiAgICAgIHRoaXMucGF0aC5sZW5ndGggPSAwO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBJbnRlcmZhY2UgZGVzY3JpYmluZyB0aGUgZGF0YXR5cGVzIG9mIHRoZSBhdHRyaWJ1dGVzIGEgbXV0YXRvciBhcyBzdHJpbmdzIFxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgIFthdHRyaWJ1dGU6IHN0cmluZ106IHN0cmluZyB8IE9iamVjdDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogSW50ZXJmYWNlIGRlc2NyaWJpbmcgYSBtdXRhdG9yLCB3aGljaCBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSB3aXRoIG5hbWVzIG9mIGF0dHJpYnV0ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgdmFsdWVzXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNdXRhdG9yIHtcclxuICAgIFthdHRyaWJ1dGU6IHN0cmluZ106IEdlbmVyYWw7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIEludGVyZmFjZXMgZGVkaWNhdGVkIGZvciBlYWNoIHB1cnBvc2UuIEV4dHJhIGF0dHJpYnV0ZSBuZWNlc3NhcnkgZm9yIGNvbXBpbGV0aW1lIHR5cGUgY2hlY2tpbmcsIG5vdCBleGlzdGVudCBhdCBydW50aW1lXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNdXRhdG9yRm9yQW5pbWF0aW9uIGV4dGVuZHMgTXV0YXRvciB7IHJlYWRvbmx5IGZvckFuaW1hdGlvbjogbnVsbCB9XHJcbiAgZXhwb3J0IGludGVyZmFjZSBNdXRhdG9yRm9yVXNlckludGVyZmFjZSBleHRlbmRzIE11dGF0b3IgeyByZWFkb25seSBmb3JVc2VySW50ZXJmYWNlOiBudWxsIH1cclxuICAvLyBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JGb3JDb21wb25lbnQgZXh0ZW5kcyBNdXRhdG9yIHsgcmVhZG9ubHkgZm9yVXNlckNvbXBvbmVudDogbnVsbDsgfVxyXG5cclxuICAvKipcclxuICAgKiBDb2xsZWN0IGFwcGxpY2FibGUgYXR0cmlidXRlcyBvZiB0aGUgaW5zdGFuY2UgYW5kIGNvcGllcyBvZiB0aGVpciB2YWx1ZXMgaW4gYSBNdXRhdG9yLW9iamVjdFxyXG4gICAqL1xyXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRNdXRhdG9yT2ZBcmJpdHJhcnkoX29iamVjdDogT2JqZWN0KTogTXV0YXRvciB7XHJcbiAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHt9O1xyXG4gICAgbGV0IGF0dHJpYnV0ZXM6IChzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpW10gPSBSZWZsZWN0Lm93bktleXMoUmVmbGVjdC5nZXRQcm90b3R5cGVPZihfb2JqZWN0KSk7XHJcbiAgICBmb3IgKGxldCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xyXG4gICAgICBsZXQgdmFsdWU6IE9iamVjdCA9IFJlZmxlY3QuZ2V0KF9vYmplY3QsIGF0dHJpYnV0ZSk7XHJcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAvLyBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpKVxyXG4gICAgICAvLyAgIGNvbnRpbnVlO1xyXG4gICAgICBtdXRhdG9yW2F0dHJpYnV0ZS50b1N0cmluZygpXSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgfVxyXG5cclxuICAvLyBAdHMtaWdub3JlIC0gYXMgb2Ygbm93IHdlIG5lZWQgdG8gcG9seWZpbGwgdGhlIHN5bWJvbCB0byBtYWtlIGRlY29yYXRvciBtZXRhZGF0YSB3b3JrLCBzZWUgaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTUtMi5odG1sI2RlY29yYXRvci1tZXRhZGF0YVxyXG4gIFN5bWJvbC5tZXRhZGF0YSA/Pz0gU3ltYm9sKFwiU3ltYm9sLm1ldGFkYXRhXCIpO1xyXG5cclxuICAvKipcclxuICAgKiBBc3NvY2lhdGlvbiBvZiBhbiBhdHRyaWJ1dGUgd2l0aCBpdHMgc3BlY2lmaWVkIHR5cGUgKGNvbnN0cnVjdG9yKS5cclxuICAgKiBAc2VlIHtAbGluayBNZXRhZGF0YX0uXHJcbiAgICovXHJcbiAgZXhwb3J0IHR5cGUgTWV0YUF0dHJpYnV0ZVR5cGVzID0gUmVjb3JkPFByb3BlcnR5S2V5LCBGdW5jdGlvbiB8IE9iamVjdD47XHJcblxyXG4gIC8qKlxyXG4gICAqIE1ldGFkYXRhIGZvciBjbGFzc2VzIGV4dGVuZGluZyB7QGxpbmsgTXV0YWJsZX0uIE1ldGFkYXRhIG5lZWRzIHRvIGJlIGV4cGxpY2l0bHkgc3BlY2lmaWVkIHVzaW5nIGRlY29yYXRvcnMuXHJcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTUtMi5odG1sI2RlY29yYXRvci1tZXRhZGF0YSB8IHR5cGUgc2NyaXB0IDUuMiBmZWF0dXJlIFwiZGVjb3JhdG9yIG1ldGFkYXRhXCJ9IGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWV0YWRhdGEgZXh0ZW5kcyBEZWNvcmF0b3JNZXRhZGF0YU9iamVjdCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzcGVjaWZpZWQgdHlwZXMgb2YgdGhlIGF0dHJpYnV0ZXMgb2YgYSBjbGFzcy4gVXNlIHRoZSB7QGxpbmsgdHlwZX0gZGVjb3JhdG9yIHRvIGFkZCB0eXBlIGluZm9ybWF0aW9uIHRvIHRoZSBtZXRhZGF0YSBvZiBhIGNsYXNzLlxyXG4gICAgICovXHJcbiAgICBhdHRyaWJ1dGVUeXBlcz86IE1ldGFBdHRyaWJ1dGVUeXBlcztcclxuICAgIGVudW1lcmF0ZUtleXM/OiBQcm9wZXJ0eUtleVtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIG9mIHByb3BlcnR5IG5hbWVzIHRvIHRoZSB0eXBlIG9mIHNlcmlhbGl6YXRpb24gdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhhdCBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgc2VyaWFsaXphYmxlcz86IHsgW2tleTogc3RyaW5nXTogXCJwcmltaXRpdmVcIiB8IFwic2VyaWFsaXphYmxlXCIgfCBcInJlc291cmNlXCIgfCBcIm5vZGVcIiB9O1xyXG4gICAgaW1wbGVtZW50cz86IFNldDxGdW5jdGlvbj47XHJcbiAgfVxyXG5cclxuICAvKioge0BsaW5rIENsYXNzRmllbGREZWNvcmF0b3JDb250ZXh0fSBvciB7QGxpbmsgQ2xhc3NHZXR0ZXJEZWNvcmF0b3JDb250ZXh0fSBvciB7QGxpbmsgQ2xhc3NBY2Nlc3NvckRlY29yYXRvckNvbnRleHR9ICovXHJcbiAgZXhwb3J0IHR5cGUgQ2xhc3NQcm9wZXJ0eUNvbnRleHQ8VGhpcyA9IHVua25vd24sIFZhbHVlID0gdW5rbm93bj4gPSBDbGFzc0ZpZWxkRGVjb3JhdG9yQ29udGV4dDxUaGlzLCBWYWx1ZT4gfCBDbGFzc0dldHRlckRlY29yYXRvckNvbnRleHQ8VGhpcywgVmFsdWU+IHwgQ2xhc3NBY2Nlc3NvckRlY29yYXRvckNvbnRleHQ8VGhpcywgVmFsdWU+O1xyXG4gIC8qKlxyXG4gICAqIERlY29yYXRvciB0byBzcGVjaWZ5IGEgdHlwZSAoY29uc3RydWN0b3IpIGZvciBhbiBhdHRyaWJ1dGUgd2l0aGluIGEgY2xhc3MncyB7QGxpbmsgTWV0YWRhdGEgfCBtZXRhZGF0YX0uXHJcbiAgICogVGhpcyBhbGxvd3MgdGhlIGludGVuZGVkIHR5cGUgb2YgYW4gYXR0cmlidXRlIHRvIGJlIGtub3duIGF0IHJ1bnRpbWUsIG1ha2luZyBpdCBhIHZhbGlkIGRyb3AgdGFyZ2V0IGluIHRoZSBlZGl0b3IuXHJcbiAgICpcclxuICAgKiAqKk5vdGU6KiogQXR0cmlidXRlcyB3aXRoIGEgc3BlY2lmaWVkIG1ldGEtdHlwZSB3aWxsIGFsd2F5cyBiZSBpbmNsdWRlZCBpbiB0aGUge0BsaW5rIE11dGF0b3IgYmFzZS1tdXRhdG9yfSBcclxuICAgKiAodmlhIHtAbGluayBNdXRhYmxlLmdldE11dGF0b3J9KSwgcmVnYXJkbGVzcyBvZiB0aGVpciBvd24gdHlwZS4gTm9uLXtAbGluayBNdXRhYmxlIG11dGFibGV9IG9iamVjdHMgXHJcbiAgICogd2lsbCBiZSBkaXNwbGF5ZWQgdmlhIHRoZWlyIHtAbGluayB0b1N0cmluZ30gbWV0aG9kIGluIHRoZSBlZGl0b3IuXHJcbiAgICogQGF1dGhvciBKb25hcyBQbG90emt5LCBIRlUsIDIwMjQtMjAyNVxyXG4gICAqL1xyXG4gIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBhcnJheXMgYW5kIG1heWJlIG90aGVyIGNvbGxlY3Rpb25zP1xyXG4gIC8vIG9iamVjdCB0eXBlXHJcbiAgZXhwb3J0IGZ1bmN0aW9uIHR5cGU8VCwgQyBleHRlbmRzIGFic3RyYWN0IG5ldyAoLi4uYXJnczogR2VuZXJhbFtdKSA9PiBUPihfY29uc3RydWN0b3I6IEMpOiAoX3ZhbHVlOiB1bmtub3duLCBfY29udGV4dDogQ2xhc3NQcm9wZXJ0eUNvbnRleHQ8VCBleHRlbmRzIE5vZGUgPyBOb2RlIGV4dGVuZHMgVCA/IENvbXBvbmVudCA6IFNlcmlhbGl6YWJsZSA6IFNlcmlhbGl6YWJsZSwgVD4pID0+IHZvaWQ7XHJcbiAgLy8gcHJpbWl0aXZlIHR5cGVcclxuICBleHBvcnQgZnVuY3Rpb24gdHlwZTxUIGV4dGVuZHMgQm9vbGVhbiB8IE51bWJlciB8IFN0cmluZz4oX2NvbnN0cnVjdG9yOiBhYnN0cmFjdCBuZXcgKC4uLmFyZ3M6IEdlbmVyYWxbXSkgPT4gVCk6IChfdmFsdWU6IHVua25vd24sIF9jb250ZXh0OiBDbGFzc1Byb3BlcnR5Q29udGV4dDxTZXJpYWxpemFibGUsIFQ+KSA9PiB2b2lkO1xyXG4gIC8vIGVudW0gdHlwZVxyXG4gIGV4cG9ydCBmdW5jdGlvbiB0eXBlPFQsIEUgZXh0ZW5kcyBSZWNvcmQ8a2V5b2YgRSwgVD4+KF9lbnVtOiBFKTogKF92YWx1ZTogdW5rbm93biwgX2NvbnRleHQ6IENsYXNzUHJvcGVydHlDb250ZXh0PFNlcmlhbGl6YWJsZSwgVD4pID0+IHZvaWQ7XHJcbiAgZXhwb3J0IGZ1bmN0aW9uIHR5cGUoX2NvbnN0cnVjdG9yOiBGdW5jdGlvbiB8IE9iamVjdCk6IChfdmFsdWU6IHVua25vd24sIF9jb250ZXh0OiBDbGFzc1Byb3BlcnR5Q29udGV4dCkgPT4gdm9pZCB7XHJcbiAgICByZXR1cm4gKF92YWx1ZSwgX2NvbnRleHQpID0+IHsgLy8gY291bGQgY2FjaGUgdGhlIGRlY29yYXRvciBmdW5jdGlvbiBmb3IgZWFjaCBjbGFzc1xyXG4gICAgICBsZXQgbWV0YTogTWV0YWRhdGEgPSBfY29udGV4dC5tZXRhZGF0YTtcclxuICAgICAgaWYgKCFPYmplY3QuaGFzT3duKG1ldGEsIFwiYXR0cmlidXRlVHlwZXNcIikpXHJcbiAgICAgICAgbWV0YS5hdHRyaWJ1dGVUeXBlcyA9IHsgLi4ubWV0YS5hdHRyaWJ1dGVUeXBlcyB9O1xyXG4gICAgICBtZXRhLmF0dHJpYnV0ZVR5cGVzW19jb250ZXh0Lm5hbWVdID0gX2NvbnN0cnVjdG9yO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlY29yYXRvciBmb3IgbWFraW5nIGdldHRlcnMgaW4gYSB7QGxpbmsgTXV0YWJsZX0gY2xhc3MgZW51bWVyYWJsZS4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGdldHRlcnMgYXJlIGluY2x1ZGVkIGluIG11dGF0b3JzIGFuZCBhcmUgc3Vic2VxdWVudGx5IGRpc3BsYXllZCBpbiB0aGUgZWRpdG9yLlxyXG4gICAqIFxyXG4gICAqICoqVXNhZ2UqKjogQXBwbHkgdGhpcyBkZWNvcmF0b3IgdG8gYm90aCB0aGUgZ2V0dGVyIG1ldGhvZCBhbmQgdGhlIGNsYXNzIHRvIG1ha2UgaXQgZWZmZWN0aXZlLlxyXG4gICAqIFxyXG4gICAqICoqRXhhbXBsZSoqOlxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiBAxpIuZW51bWVyYXRlIC8vIGFwcGx5IHRoZSBkZWNvcmF0b3IgdG8gdGhlIGNsYXNzLlxyXG4gICAqIGV4cG9ydCBjbGFzcyBTb21lU2NyaXB0IGV4dGVuZHMgxpIuQ29tcG9uZW50U2NyaXB0IHtcclxuICAgKiAgICNzaXplOiBudW1iZXIgPSAxO1xyXG4gICAqIFxyXG4gICAqICAgQMaSLmVudW1lcmF0ZSAvLyBhcHBseSB0aGUgZGVjb3JhdG9yIHRvIHRoZSBnZXR0ZXJcclxuICAgKiAgIHB1YmxpYyBnZXQgc2l6ZSgpOiBudW1iZXIge1xyXG4gICAqICAgICByZXR1cm4gdGhpcy4jc2l6ZTtcclxuICAgKiAgIH1cclxuICAgKiBcclxuICAgKiAgIC8vIGRlZmluZSBhIHNldHRlciB0byBhbGxvdyB3cml0aW5nLCBvciBvbWl0IGl0IHRvIGxlYXZlIHRoZSBwcm9wZXJ0eSByZWFkLW9ubHlcclxuICAgKiAgIHB1YmxpYyBzZXQgc2l6ZShfc2l6ZTogbnVtYmVyKSB7XHJcbiAgICogICAgIHRoaXMuI3NpemUgPSBfc2l6ZTtcclxuICAgKiAgIH1cclxuICAgKiB9XHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgZXhwb3J0IGZ1bmN0aW9uIGVudW1lcmF0ZShfdmFsdWU6IHVua25vd24sIF9jb250ZXh0OiBDbGFzc0RlY29yYXRvckNvbnRleHQ8bmV3ICguLi5hcmdzOiBHZW5lcmFsW10pID0+IE11dGFibGU+KTogdm9pZDtcclxuICBleHBvcnQgZnVuY3Rpb24gZW51bWVyYXRlKF92YWx1ZTogdW5rbm93biwgX2NvbnRleHQ6IENsYXNzR2V0dGVyRGVjb3JhdG9yQ29udGV4dDxNdXRhYmxlPiB8IENsYXNzQWNjZXNzb3JEZWNvcmF0b3JDb250ZXh0PE11dGFibGU+KTogdm9pZDtcclxuICBleHBvcnQgZnVuY3Rpb24gZW51bWVyYXRlKF92YWx1ZTogdW5rbm93biwgX2NvbnRleHQ6IENsYXNzRGVjb3JhdG9yQ29udGV4dCB8IENsYXNzR2V0dGVyRGVjb3JhdG9yQ29udGV4dCB8IENsYXNzQWNjZXNzb3JEZWNvcmF0b3JDb250ZXh0KTogdm9pZCB7XHJcbiAgICAvLyBfY29udGV4dC5hZGRJbml0aWFsaXplcihmdW5jdGlvbiAodGhpczogdW5rbm93bikgeyAvLyB0aGlzIGlzIHJ1biBwZXIgaW5zdGFuY2UuLi4gaWRlYWxseSB3ZSB3b3VsZCB3YW50IHRvIHJ1biB0aGlzIG9uY2UgcGVyIGNsYXNzXHJcbiAgICAvLyAgIGNvbnN0IHByb3RvdHlwZTogdW5rbm93biA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcclxuICAgIC8vICAgY29uc3QgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsIF9jb250ZXh0Lm5hbWUpO1xyXG4gICAgLy8gICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGUgPT0gZmFsc2UpXHJcbiAgICAvLyAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgX2NvbnRleHQubmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xyXG4gICAgLy8gfSk7XHJcblxyXG4gICAgbGV0IG1ldGFkYXRhOiBNZXRhZGF0YSA9IF9jb250ZXh0Lm1ldGFkYXRhO1xyXG4gICAgaWYgKF9jb250ZXh0LmtpbmQgPT0gXCJnZXR0ZXJcIiB8fCBfY29udGV4dC5raW5kID09IFwiYWNjZXNzb3JcIikge1xyXG4gICAgICBpZiAodHlwZW9mIF9jb250ZXh0Lm5hbWUgIT0gXCJzdHJpbmdcIilcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBpZiAoIU9iamVjdC5oYXNPd24obWV0YWRhdGEsIFwiZW51bWVyYXRlS2V5c1wiKSlcclxuICAgICAgICBtZXRhZGF0YS5lbnVtZXJhdGVLZXlzID0gW107XHJcblxyXG4gICAgICBtZXRhZGF0YS5lbnVtZXJhdGVLZXlzLnB1c2goX2NvbnRleHQubmFtZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoX2NvbnRleHQua2luZCA9PSBcImNsYXNzXCIpIHtcclxuICAgICAgaWYgKG1ldGFkYXRhLmVudW1lcmF0ZUtleXMpIHtcclxuICAgICAgICBjb25zdCBkZXNjcmlwdG9yOiBQcm9wZXJ0eURlc2NyaXB0b3IgPSB7IGVudW1lcmFibGU6IHRydWUgfTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBtZXRhZGF0YS5lbnVtZXJhdGVLZXlzKVxyXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCg8RnVuY3Rpb24+X3ZhbHVlKS5wcm90b3R5cGUsIGtleSwgZGVzY3JpcHRvcik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmFzZSBjbGFzcyBmb3IgYWxsIHR5cGVzIHRoYXQgYXJlIG11dGFibGUgdXNpbmcge0BsaW5rIE11dGF0b3J9LW9iamVjdHMsIHRodXMgcHJvdmlkaW5nIGFuZCB1c2luZyBpbnRlcmZhY2VzIGNyZWF0ZWQgYXQgcnVudGltZS5cclxuICAgKiBcclxuICAgKiBNdXRhYmxlcyBwcm92aWRlIGEge0BsaW5rIE11dGF0b3J9IGJ1aWx0IGJ5IGNvbGxlY3RpbmcgYWxsIHRoZWlyIGFwcGxpY2FibGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBCeSBkZWZhdWx0LCB0aGlzIGluY2x1ZGVzIG9ubHkgcHJpbWl0aXZlIHR5cGVzIGFuZCBuZXN0ZWQgbXV0YWJsZSBvYmplY3RzLlxyXG4gICAqIFVzaW5nIHRoZSB7QGxpbmsgdHlwZX0tZGVjb3JhdG9yIGNhbiBhbHNvIGluY2x1ZGUgbm9uLW11dGFibGUgb2JqZWN0cywgd2hpY2ggd2lsbCBiZSBkaXNwbGF5ZWQgdmlhIHRoZWlyIHtAbGluayB0b1N0cmluZ30gbWV0aG9kIGluIHRoZSBlZGl0b3IuXHJcbiAgICogXHJcbiAgICogU3ViY2xhc3NlcyBjYW4gZWl0aGVyIHJlZHVjZSB0aGUgc3RhbmRhcmQge0BsaW5rIE11dGF0b3J9IGJ1aWx0IGJ5IHRoaXMgYmFzZSBjbGFzcyBieSBkZWxldGluZyBwcm9wZXJ0aWVzIG9yIGltcGxlbWVudCBhbiBpbmRpdmlkdWFsIGdldE11dGF0b3IgbWV0aG9kLlxyXG4gICAqIFRoZSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9mIHRoZSB7QGxpbmsgTXV0YXRvcn0gbXVzdCBtYXRjaCBwdWJsaWMgcHJvcGVydGllcyBvciBnZXR0ZXJzL3NldHRlcnMgb2YgdGhlIG9iamVjdC5cclxuICAgKiBPdGhlcndpc2UsIHRoZXkgd2lsbCBiZSBpZ25vcmVkIHVubGVzcyBoYW5kbGVkIGJ5IGFuIG92ZXJyaWRlIG9mIHRoZSBtdXRhdGUgbWV0aG9kIGluIHRoZSBzdWJjbGFzcywgYW5kIHdpbGwgdGhyb3cgZXJyb3JzIGluIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIHVzZXIgaW50ZXJmYWNlIGZvciB0aGUgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNdXRhYmxlIGV4dGVuZHMgRXZlbnRUYXJnZXRVbmlmaWVkIHtcclxuICAgIC8qKlxyXG4gICAgICogRGVjb3JhdG9yIGFsbG93cyB0byBhdHRhY2gge0BsaW5rIE11dGFibGV9IGZ1bmN0aW9uYWxpdHkgdG8gZXhpc3RpbmcgY2xhc3Nlcy4gXHJcbiAgICAgKi9cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgZGVjb3JhdGUoX2NvbnN0cnVjdG9yOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgLy8gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJ1c2VSZW5kZXJEYXRhXCIsIHtcclxuICAgIC8vICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TXV0YXRvcih0aGlzOiBNdXRhYmxlRm9yVXNlckludGVyZmFjZSk6IE11dGF0b3Ige1xyXG4gICAgLy8gICAgICAgcmV0dXJuIGdldE11dGF0b3JPZkFyYml0cmFyeSh0aGlzKTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyAgIH0pO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0TXV0YXRvckZyb21QYXRoKF9tdXRhdG9yOiBNdXRhdG9yLCBfcGF0aDogc3RyaW5nW10pOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IGtleTogc3RyaW5nID0gX3BhdGhbMF07XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge307XHJcbiAgICAgIGlmIChfbXV0YXRvcltrZXldID09IHVuZGVmaW5lZCkgLy8gaWYgdGhlIHBhdGggZGV2aWF0ZXMgZnJvbSBtdXRhdG9yIHN0cnVjdHVyZSwgcmV0dXJuIHRoZSBtdXRhdG9yXHJcbiAgICAgICAgcmV0dXJuIF9tdXRhdG9yO1xyXG4gICAgICBtdXRhdG9yW2tleV0gPSBfbXV0YXRvcltrZXldO1xyXG4gICAgICBpZiAoX3BhdGgubGVuZ3RoID4gMSlcclxuICAgICAgICBtdXRhdG9yW2tleV0gPSBNdXRhYmxlLmdldE11dGF0b3JGcm9tUGF0aChtdXRhdG9yW2tleV0sIF9wYXRoLnNsaWNlKDEsIF9wYXRoLmxlbmd0aCkpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgdHlwZSBvZiB0aGlzIG11dGFibGUgc3ViY2xhc3MgYXMgdGhlIG5hbWUgb2YgdGhlIHJ1bnRpbWUgY2xhc3NcclxuICAgICAqIEByZXR1cm5zIFRoZSB0eXBlIG9mIHRoZSBtdXRhYmxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgdHlwZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdCBhcHBsaWNhYmxlIGF0dHJpYnV0ZXMgb2YgdGhlIGluc3RhbmNlIGFuZCBjb3BpZXMgb2YgdGhlaXIgdmFsdWVzIGluIGEgTXV0YXRvci1vYmplY3QuXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBhIG11dGF0b3IgY2Fubm90IGJlIGV4dGVuZGVkLCBzaW5jZSBleHRlbnNpb25zIGFyZSBub3QgYXZhaWxhYmxlIGluIHRoZSBvYmplY3QgdGhlIG11dGF0b3IgYmVsb25ncyB0by5cclxuICAgICAqIEEgbXV0YXRvciBtYXkgYmUgcmVkdWNlZCBieSB0aGUgZGVzY2VuZGFudHMgb2Yge0BsaW5rIE11dGFibGV9IHRvIGNvbnRhaW4gb25seSB0aGUgcHJvcGVydGllcyBuZWVkZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKF9leHRlbmRhYmxlOiBib29sZWFuID0gZmFsc2UpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7fTtcclxuXHJcbiAgICAgIC8vIGNvbGxlY3QgcHJpbWl0aXZlIGFuZCBtdXRhYmxlIGF0dHJpYnV0ZXNcclxuICAgICAgZm9yIChsZXQgYXR0cmlidXRlIGluIHRoaXMpIHtcclxuICAgICAgICBsZXQgdmFsdWU6IE9iamVjdCA9IHRoaXNbYXR0cmlidXRlXTtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbilcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTXV0YWJsZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGVBcnJheSkgJiYgISh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShcImlkUmVzb3VyY2VcIikpICYmIHRoaXMuZ2V0TWV0YUF0dHJpYnV0ZVR5cGVzKClbYXR0cmlidXRlXSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBtdXRhdG9yW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFfZXh0ZW5kYWJsZSlcclxuICAgICAgICAvLyBtdXRhdG9yIGNhbiBiZSByZWR1Y2VkIGJ1dCBub3QgZXh0ZW5kZWQhXHJcbiAgICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKG11dGF0b3IpO1xyXG4gICAgICAvLyBkZWxldGUgdW53YW50ZWQgYXR0cmlidXRlc1xyXG4gICAgICB0aGlzLnJlZHVjZU11dGF0b3IobXV0YXRvcik7XHJcblxyXG4gICAgICAvLyByZXBsYWNlIHJlZmVyZW5jZXMgdG8gbXV0YWJsZSBvYmplY3RzIHdpdGggcmVmZXJlbmNlcyB0byBtdXRhdG9yc1xyXG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gbXV0YXRvcikge1xyXG4gICAgICAgIGxldCB2YWx1ZTogT2JqZWN0ID0gbXV0YXRvclthdHRyaWJ1dGVdO1xyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpXHJcbiAgICAgICAgICBtdXRhdG9yW2F0dHJpYnV0ZV0gPSB2YWx1ZS5nZXRNdXRhdG9yKCk7XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTXV0YWJsZUFycmF5KVxyXG4gICAgICAgICAgbXV0YXRvclthdHRyaWJ1dGVdID0gdmFsdWUubWFwKChfdmFsdWUpID0+IF92YWx1ZS5nZXRNdXRhdG9yKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3QgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGluc3RhbmNlIGFuZCB0aGVpciB2YWx1ZXMgYXBwbGljYWJsZSBmb3IgYW5pbWF0aW9uLlxyXG4gICAgICogQmFzaWMgZnVuY3Rpb25hbGl0eSBpcyBpZGVudGljYWwgdG8ge0BsaW5rIGdldE11dGF0b3J9LCByZXR1cm5lZCBtdXRhdG9yIHNob3VsZCB0aGVuIGJlIHJlZHVjZWQgYnkgdGhlIHN1YmNsYXNzZWQgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE11dGF0b3JGb3JBbmltYXRpb24oX2V4dGVuZGFibGU6IGJvb2xlYW4gPSBmYWxzZSk6IE11dGF0b3JGb3JBbmltYXRpb24ge1xyXG4gICAgICByZXR1cm4gPE11dGF0b3JGb3JBbmltYXRpb24+dGhpcy5nZXRNdXRhdG9yKF9leHRlbmRhYmxlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3QgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGluc3RhbmNlIGFuZCB0aGVpciB2YWx1ZXMgYXBwbGljYWJsZSBmb3IgdGhlIHVzZXIgaW50ZXJmYWNlLlxyXG4gICAgICogQmFzaWMgZnVuY3Rpb25hbGl0eSBpcyBpZGVudGljYWwgdG8ge0BsaW5rIGdldE11dGF0b3J9LCByZXR1cm5lZCBtdXRhdG9yIHNob3VsZCB0aGVuIGJlIHJlZHVjZWQgYnkgdGhlIHN1YmNsYXNzZWQgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE11dGF0b3JGb3JVc2VySW50ZXJmYWNlKF9leHRlbmRhYmxlOiBib29sZWFuID0gZmFsc2UpOiBNdXRhdG9yRm9yVXNlckludGVyZmFjZSB7XHJcbiAgICAgIHJldHVybiA8TXV0YXRvckZvclVzZXJJbnRlcmZhY2U+dGhpcy5nZXRNdXRhdG9yKF9leHRlbmRhYmxlKTsgIC8vIFRPRE86IGJvdGggb2YgdGhlc2UgKHRoaXMgYW5kIGdldE11dGF0b3JGb3JBbmltYXRpb24pIGRvbid0IHJlYWxseSB3b3JrIGFzIHRoZXkgZG9uJ3QgcmVjdXJzaXZlbHkgY2FsbCBnZXRNdXRhdG9yRm9yVXNlckludGVyZmFjZSBvbiBzdWItbXV0YWJsZSBvYmplY3RzLCBtYXliZSBpbnN0ZWFkIGltcGxlbWVudCBhIHJlZHVjZU11dGF0b3JGb3JVc2VySW50ZXJmYWNlPz8/XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBpbnN0YW5jZSBhbmQgdGhlaXIgdmFsdWVzIGFwcGxpY2FibGUgZm9yIGluZGl2aXVhbGl6YXRpb24gYnkgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEJhc2ljIGZ1bmN0aW9uYWxpdHkgaXMgaWRlbnRpY2FsIHRvIHtAbGluayBnZXRNdXRhdG9yfSwgcmV0dXJuZWQgbXV0YXRvciBzaG91bGQgdGhlbiBiZSByZWR1Y2VkIGJ5IHRoZSBzdWJjbGFzc2VkIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIC8vIHB1YmxpYyBnZXRNdXRhdG9yRm9yQ29tcG9uZW50KCk6IE11dGF0b3JGb3JDb21wb25lbnQge1xyXG4gICAgLy8gICAgIHJldHVybiA8TXV0YXRvckZvckNvbXBvbmVudD50aGlzLmdldE11dGF0b3IoKTtcclxuICAgIC8vIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhc3NvY2lhdGl2ZSBhcnJheSB3aXRoIHRoZSBzYW1lIGF0dHJpYnV0ZXMgYXMgdGhlIGdpdmVuIG11dGF0b3IsIGJ1dCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHR5cGVzIGFzIHN0cmluZy12YWx1ZXMuXHJcbiAgICAgKiBEb2VzIG5vdCByZWN1cnNlIGludG8gb2JqZWN0cyEgVGhpcyB3aWxsIHJldHVybiB0aGUgZGVjb3JhdGVkIHtAbGluayBNZXRhZGF0YSBtZXRhLXR5cGV9IGluc3RlYWQgb2YgdGhlIHJ1bnRpbWUtdHlwZSBvZiB0aGUgb2JqZWN0LCBpZiBhdmFpbGFibGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHt9O1xyXG4gICAgICBsZXQgbWV0YVR5cGVzOiBNZXRhQXR0cmlidXRlVHlwZXMgPSB0aGlzLmdldE1ldGFBdHRyaWJ1dGVUeXBlcygpO1xyXG4gICAgICBmb3IgKGxldCBhdHRyaWJ1dGUgaW4gX211dGF0b3IpIHtcclxuICAgICAgICBsZXQgbWV0YVR5cGU6IEZ1bmN0aW9uIHwgT2JqZWN0ID0gbWV0YVR5cGVzW2F0dHJpYnV0ZV07IC8vIGNvbnN0cnVjdG9yIG9yIGVudW1cclxuICAgICAgICBsZXQgdHlwZTogc3RyaW5nIHwgT2JqZWN0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWV0YVR5cGUgPT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgdHlwZSA9IG1ldGFUeXBlLm5hbWU7XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1ldGFUeXBlID09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICB0eXBlID0gbWV0YVR5cGU7XHJcblxyXG4gICAgICAgIGxldCB2YWx1ZTogbnVtYmVyIHwgYm9vbGVhbiB8IHN0cmluZyB8IG9iamVjdCB8IEZ1bmN0aW9uID0gX211dGF0b3JbYXR0cmlidXRlXTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlICE9IHVuZGVmaW5lZCAmJiB0eXBlID09IHVuZGVmaW5lZClcclxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIilcclxuICAgICAgICAgICAgdHlwZSA9ICg8R2VuZXJhbD50aGlzKVthdHRyaWJ1dGVdLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICB0eXBlID0gdmFsdWUubmFtZTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdHlwZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XHJcblxyXG4gICAgICAgIHR5cGVzW2F0dHJpYnV0ZV0gPSB0eXBlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgc3BlY2lmaWVkIHtAbGluayBNZXRhZGF0YS5hdHRyaWJ1dGVUeXBlcyB8IGF0dHJpYnV0ZSB0eXBlc30gZnJvbSB0aGUge0BsaW5rIE1ldGFkYXRhIHwgbWV0YWRhdGF9IG9mIHRoaXMgaW5zdGFuY2UncyBjbGFzcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE1ldGFBdHRyaWJ1dGVUeXBlcygpOiBNZXRhQXR0cmlidXRlVHlwZXMge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRNZXRhZGF0YSgpLmF0dHJpYnV0ZVR5cGVzID8/PSB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHtAbGluayBNZXRhZGF0YSB8IG1ldGFkYXRhfSBvZiB0aGlzIGluc3RhbmNlJ3MgY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRNZXRhZGF0YSgpOiBNZXRhZGF0YSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yW1N5bWJvbC5tZXRhZGF0YV0gPz89IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBtdXRhdG9yIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSBfbXV0YXRvciBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgYXR0cmlidXRlIGluIF9tdXRhdG9yKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBPYmplY3QgPSBSZWZsZWN0LmdldCh0aGlzLCBhdHRyaWJ1dGUpO1xyXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE11dGFibGUpXHJcbiAgICAgICAgICB2YWx1ZS51cGRhdGVNdXRhdG9yKF9tdXRhdG9yW2F0dHJpYnV0ZV0pO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIF9tdXRhdG9yW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgYXR0cmlidXRlIHZhbHVlcyBvZiB0aGUgaW5zdGFuY2UgYWNjb3JkaW5nIHRvIHRoZSBzdGF0ZSBvZiB0aGUgbXV0YXRvci5cclxuICAgICAqIFRoZSBtdXRhdGlvbiBtYXkgYmUgcmVzdHJpY3RlZCB0byBhIHN1YnNldCBvZiB0aGUgbXV0YXRvciBhbmQgdGhlIGV2ZW50IGRpc3BhdGNoaW5nIHN1cHByZXNzZWQuXHJcbiAgICAgKiBVc2VzIG11dGF0ZUJhc2UsIGJ1dCBjYW4gYmUgb3ZlcndyaXR0ZW4gaW4gc3ViY2xhc3Nlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uPzogc3RyaW5nW10sIF9kaXNwYXRjaE11dGF0ZT86IGJvb2xlYW4pOiB2b2lkIHwgUHJvbWlzZTx2b2lkPjsgLy8gYWxsb3cgc3luYyBvciBhc3luYyBvdmVycmlkZXNcclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBhd2FpdCB0aGlzLm11dGF0ZUJhc2UoX211dGF0b3IsIF9zZWxlY3Rpb24pO1xyXG4gICAgICBpZiAoX2Rpc3BhdGNoTXV0YXRlKVxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuTVVUQVRFLCB7IGJ1YmJsZXM6IHRydWUsIGRldGFpbDogeyBtdXRhdG9yOiBfbXV0YXRvciB9IH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN5bmNocm9ub3VzIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBtdXRhdGV9LlxyXG4gICAgICogT3ZlcnJpZGUge0BsaW5rIG11dGF0ZX0gd2l0aCBhIHN5bmMgaW1wbGVtZW50YXRpb24gYW5kIGNhbGwgdGhpcyBtZXRob2QgZnJvbSBpdCB0byBtdXRhdGUgc3luY2hyb25vdXNseS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG11dGF0ZVN5bmMoX211dGF0b3I6IE11dGF0b3IsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBfbXV0YXRvcjtcclxuXHJcbiAgICAgIGZvciAobGV0IGF0dHJpYnV0ZSBpbiBtdXRhdG9yKSB7XHJcbiAgICAgICAgbGV0IG11dGFudDogT2JqZWN0ID0gUmVmbGVjdC5nZXQodGhpcywgYXR0cmlidXRlKTtcclxuICAgICAgICBpZiAobXV0YW50IGluc3RhbmNlb2YgTXV0YWJsZUFycmF5IHx8IG11dGFudCBpbnN0YW5jZW9mIE11dGFibGUpXHJcbiAgICAgICAgICBtdXRhbnQubXV0YXRlKG11dGF0b3JbYXR0cmlidXRlXSwgbnVsbCwgZmFsc2UpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIFJlZmxlY3Quc2V0KHRoaXMsIGF0dHJpYnV0ZSwgbXV0YXRvclthdHRyaWJ1dGVdKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKF9kaXNwYXRjaE11dGF0ZSlcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KEVWRU5ULk1VVEFURSwgeyBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHsgbXV0YXRvcjogX211dGF0b3IgfSB9KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQmFzZSBtZXRob2QgZm9yIG11dGF0aW9uLCBhbHdheXMgYXZhaWxhYmxlIHRvIHN1YmNsYXNzZXMuIERvIG5vdCBvdmVyd3JpdGUgaW4gc3ViY2xhc3NlcyFcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFzeW5jIG11dGF0ZUJhc2UoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb24/OiBzdHJpbmdbXSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IF9tdXRhdG9yO1xyXG5cclxuICAgICAgaWYgKF9zZWxlY3Rpb24pIHsgLy8gVE9ETzogdGhpcyBkb2Vzbid0IHdvcmsgYXMgaXQgZG9lcyBub3QgcmVjdXJzZSBpbnRvIG9iamVjdHNcclxuICAgICAgICBtdXRhdG9yID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgYXR0cmlidXRlIG9mIF9zZWxlY3Rpb24pIC8vIHJlZHVjZSB0aGUgbXV0YXRvciB0byB0aGUgc2VsZWN0aW9uXHJcbiAgICAgICAgICBpZiAodHlwZW9mIChfbXV0YXRvclthdHRyaWJ1dGVdKSAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICAgICAgbXV0YXRvclthdHRyaWJ1dGVdID0gX211dGF0b3JbYXR0cmlidXRlXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgYXR0cmlidXRlIGluIG11dGF0b3IpIHtcclxuICAgICAgICBpZiAoIVJlZmxlY3QuaGFzKHRoaXMsIGF0dHJpYnV0ZSkpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBsZXQgbXV0YW50OiBPYmplY3QgPSBSZWZsZWN0LmdldCh0aGlzLCBhdHRyaWJ1dGUpO1xyXG4gICAgICAgIGxldCB2YWx1ZTogTXV0YXRvciA9IDxNdXRhdG9yPm11dGF0b3JbYXR0cmlidXRlXTtcclxuICAgICAgICBpZiAobXV0YW50IGluc3RhbmNlb2YgTXV0YWJsZUFycmF5IHx8IG11dGFudCBpbnN0YW5jZW9mIE11dGFibGUpXHJcbiAgICAgICAgICBhd2FpdCBtdXRhbnQubXV0YXRlKHZhbHVlLCBudWxsLCBmYWxzZSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgUmVmbGVjdC5zZXQodGhpcywgYXR0cmlidXRlLCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZHVjZXMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGdlbmVyYWwgbXV0YXRvciBhY2NvcmRpbmcgdG8gZGVzaXJlZCBvcHRpb25zIGZvciBtdXRhdGlvbi4gVG8gYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xyXG4gICAgICogQHBhcmFtIF9tdXRhdG9yIFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQ7XHJcblxyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gIGV4cG9ydCB0eXBlIEdlbmVyYWwgPSBhbnk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEhvbGRzIGluZm9ybWF0aW9uIG5lZWRlZCB0byByZWNyZWF0ZSBhbiBvYmplY3QgaWRlbnRpY2FsIHRvIHRoZSBvbmUgaXQgb3JpZ2luYXRlZCBmcm9tLiBcclxuICAgKiBBIHNlcmlhbGl6YXRpb24gaXMgdXNlZCB0byBjcmVhdGUgY29waWVzIG9mIGV4aXN0aW5nIG9iamVjdHMgYXQgcnVudGltZSBvciB0byBzdG9yZSBvYmplY3RzIGFzIHN0cmluZ3Mgb3IgcmVjcmVhdGUgdGhlbS5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YXRpb24ge1xyXG4gICAgW3R5cGU6IHN0cmluZ106IEdlbmVyYWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBYnN0cmFjdCBjbGFzcyBzZXJ2aW5nIGFzIGEgYmFzZSBmb3IgaW50ZXJmYWNlLWxpa2UgcHVyZSBhYnN0cmFjdCBjbGFzc2VzIHRoYXQgd29yayB3aXRoIHRoZSBcImluc3RhbmNlb2ZcIi1vcGVyYXRvci4gXHJcbiAgICogXHJcbiAgICogKipVc2FnZSoqOlxyXG4gICAqICogQ3JlYXRlIGEgcHVyZSBhYnN0cmFjdCBjbGFzcyB0aGF0IGV4dGVuZHMge0BsaW5rIEltcGxlbWVudGFibGV9IHRoYXQgd2lsbCBzZXJ2ZSBhcyB5b3VyIGludGVyZmFjZS4gU3BlY2lmeSB0aGUgcmVxdWlyZWQgYXR0cmlidXRlcyBhbmQgbWV0aG9kcyB3aXRoaW4gaXQgYXMgYWJzdHJhY3QuIFxyXG4gICAqICogVXNlIHlvdXIgYWJzdHJhY3QgY2xhc3MgdmlhIHRoZSBgaW1wbGVtZW50c2Aga2V5d29yZCBleGFjdGx5IGhvdyB5b3Ugd291bGQgdXNlIGEgcmVndWxhciBgaW50ZXJmYWNlYC5cclxuICAgKiAqIERlY29yYXRlIHRoZSBjbGFzcyB0aGF0IGltcGxlbWVudHMgeW91ciBhYnN0cmFjdCBjbGFzcyB1c2luZyB0aGUgc3RhdGljIGBZT1VSX0FCU1RSQUNUX0NMQVNTYC57QGxpbmsgcmVnaXN0ZXJ9IG1ldGhvZC5cclxuICAgKiAqIE5vdyB5b3UgY2FuIHVzZSB0aGUgYGluc3RhbmNlb2ZgLW9wZXJhdG9yIHdpdGggeW91ciBhYnN0cmFjdCBjbGFzcy5cclxuICAgKiBcclxuICAgKiAqKkV4YW1wbGUqKjpcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogaW1wb3J0IMaSID0gRnVkZ2VDb3JlO1xyXG4gICAqIFxyXG4gICAqIGFic3RyYWN0IGNsYXNzIE15SW50ZXJmYWNlIGV4dGVuZHMgxpIuSW1wbGVtZW50YWJsZSB7XHJcbiAgICogICBwdWJsaWMgYWJzdHJhY3QgbXlBdHRyaWJ1dGU6IHN0cmluZztcclxuICAgKiAgIHB1YmxpYyBhYnN0cmFjdCBteU1ldGhvZCgpOiB2b2lkO1xyXG4gICAqIH1cclxuICAgKiBcclxuICAgKiBATXlJbnRlcmZhY2UucmVnaXN0ZXJcclxuICAgKiBjbGFzcyBNeUNsYXNzIGltcGxlbWVudHMgTXlJbnRlcmZhY2Uge1xyXG4gICAqICAgcHVibGljIG15QXR0cmlidXRlOiBzdHJpbmc7XHJcbiAgICogICBwdWJsaWMgbXlNZXRob2QoKTogdm9pZCB7fVxyXG4gICAqIH1cclxuICAgKiBcclxuICAgKiBsZXQgbXlJbnN0YW5jZTogTXlJbnRlcmZhY2UgPSBuZXcgTXlDbGFzcygpO1xyXG4gICAqIGNvbnNvbGUubG9nKG15SW5zdGFuY2UgaW5zdGFuY2VvZiBNeUludGVyZmFjZSk7IC8vIHRydWVcclxuICAgKiBjb25zb2xlLmxvZyhNeUNsYXNzLnByb3RvdHlwZSBpbnN0YW5jZW9mIE15SW50ZXJmYWNlKTsgLy8gdHJ1ZVxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbXBsZW1lbnRhYmxlIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXI8VCBleHRlbmRzIHR5cGVvZiBJbXBsZW1lbnRhYmxlPih0aGlzOiBULCBfY2xhc3M6IGFic3RyYWN0IG5ldyAoLi4uYXJnczogR2VuZXJhbFtdKSA9PiBJbnN0YW5jZVR5cGU8VD4sIF9jb250ZXh0OiBDbGFzc0RlY29yYXRvckNvbnRleHQpOiB2b2lkIHtcclxuICAgICAgbGV0IG1ldGE6IE1ldGFkYXRhID0gX2NvbnRleHQubWV0YWRhdGE7XHJcbiAgICAgIGlmICghT2JqZWN0Lmhhc093bihtZXRhLCBcImltcGxlbWVudHNcIikpXHJcbiAgICAgICAgbWV0YS5pbXBsZW1lbnRzID0gbmV3IFNldChtZXRhLmltcGxlbWVudHMpO1xyXG5cclxuICAgICAgbGV0IGltcGxlbWVudDogR2VuZXJhbCA9IHRoaXM7XHJcbiAgICAgIHdoaWxlIChpbXBsZW1lbnQgIT0gSW1wbGVtZW50YWJsZSkge1xyXG4gICAgICAgIG1ldGEuaW1wbGVtZW50cy5hZGQoaW1wbGVtZW50KTtcclxuICAgICAgICBpbXBsZW1lbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW1wbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgW1N5bWJvbC5oYXNJbnN0YW5jZV0oX2luc3RhbmNlOiB1bmtub3duKTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBtZXRhOiBNZXRhZGF0YSA9IF9pbnN0YW5jZS5jb25zdHJ1Y3RvcltTeW1ib2wubWV0YWRhdGFdO1xyXG4gICAgICByZXR1cm4gbWV0YT8uaW1wbGVtZW50cz8uaGFzKHRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBTZXJpYWxpemFibGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIFNlcmlhbGl6YXRpb259IG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbjtcclxuICAgIC8qKlxyXG4gICAgICogUmVjcmVhdGVzIHRoaXMgaW5zdGFuY2Ugb2Yge0BsaW5rIFNlcmlhbGl6YWJsZX0gd2l0aCB0aGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgZ2l2ZW4ge0BsaW5rIFNlcmlhbGl6YXRpb259LlxyXG4gICAgICovXHJcbiAgICBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPjtcclxuICB9XHJcblxyXG4gIGludGVyZmFjZSBOYW1lc3BhY2VSZWdpc3RlciB7XHJcbiAgICBbbmFtZTogc3RyaW5nXTogT2JqZWN0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVjb3JhdG9yIHRvIG1hcmsgcHJvcGVydGllcyBvZiBhIHtAbGluayBTZXJpYWxpemFibGV9IGZvciBhdXRvbWF0aWMgc2VyaWFsaXphdGlvbiBhbmQgZWRpdG9yIGNvbmZpZ3VyYXRpb24uXHJcbiAgICogXHJcbiAgICogKipFZGl0b3IgQ29uZmlndXJhdGlvbjoqKlxyXG4gICAqIFNwZWNpZnkgYSB0eXBlIChjb25zdHJ1Y3RvcikgZm9yIGFuIGF0dHJpYnV0ZSB3aXRoaW4gYSBjbGFzcydzIHtAbGluayBNZXRhZGF0YSB8IG1ldGFkYXRhfS5cclxuICAgKiBUaGlzIGFsbG93cyB0aGUgaW50ZW5kZWQgdHlwZSBvZiBhbiBhdHRyaWJ1dGUgdG8gYmUga25vd24gYnkgdGhlIGVkaXRvciAoYXQgcnVudGltZSksIG1ha2luZyBpdDpcclxuICAgKiAtIEEgdmFsaWQgZHJvcCB0YXJnZXQgKGUuZy4sIGZvciBvYmplY3RzIGxpa2Uge0BsaW5rIE5vZGV9LCB7QGxpbmsgVGV4dHVyZX0sIHtAbGluayBNZXNofSkuXHJcbiAgICogLSBEaXNwbGF5IHRoZSBhcHByb3ByaWF0ZSBpbnB1dCBlbGVtZW50LCBldmVuIGlmIHRoZSBhdHRyaWJ1dGUgaGFzIG5vdCBiZWVuIHNldCAoYHVuZGVmaW5lZGApLlxyXG4gICAqIFxyXG4gICAqICoqU2VyaWFsaXphdGlvbjoqKlxyXG4gICAqIFRoZSBhdXRvbWF0aWMgc2VyaWFsaXphdGlvbiBvY2N1cnMgYWZ0ZXIgYW4gaW5zdGFuY2UncyB7QGxpbmsgU2VyaWFsaXphYmxlLnNlcmlhbGl6ZX0gLyB7QGxpbmsgU2VyaWFsaXphYmxlLmRlc2VyaWFsaXplfSBtZXRob2Qgd2FzIGNhbGxlZC5cclxuICAgKiAtIFByaW1pdGl2ZXMgYW5kIGVudW1zIHdpbGwgYmUgc2VyaWFsaXplZCBhcyBpcy5cclxuICAgKiAtIHtAbGluayBTZXJpYWxpemFibGV9cyB3aWxsIGJlIHNlcmlhbGl6ZWQgbmVzdGVkLiBcclxuICAgKiAtIHtAbGluayBTZXJpYWxpemFibGVSZXNvdXJjZX1zIHdpbGwgYmUgc2VyaWFsaXplZCB2aWEgdGhlaXIgcmVzb3VyY2UgaWQgYW5kIGZldGNoZWQgd2l0aCBpdCBmcm9tIHRoZSBwcm9qZWN0IHdoZW4gZGVzZXJpYWxpemVkLlxyXG4gICAqIC0ge0BsaW5rIE5vZGV9cyB3aWxsIGJlIHNlcmlhbGl6ZWQgYXMgYSBwYXRoIGNvbm5lY3RpbmcgdGhlbSB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGlmIGZvdW5kLiBEdXJpbmcgZGVzZXJpYWxpemF0aW9uLCB0aGUgcGF0aCB3aWxsIGJlIHVud291bmQgdG8gZmluZCB0aGUgaW5zdGFuY2UgaW4gdGhlIGN1cnJlbnQgaGllcmFyY2h5LiBUaGV5IHdpbGwgYmUgYXZhaWxhYmxlICoqKmFmdGVyKioqIHtAbGluayBFVkVOVC5HUkFQSF9ERVNFUklBTElaRUR9IC8ge0BsaW5rIEVWRU5ULkdSQVBIX0lOU1RBTlRJQVRFRH0gd2FzIGJyb2FkY2FzdCB0aHJvdWdoIHRoZSBoaWVyYXJjaHkuIE5vZGUgcmVmZXJlbmNlcyBjYW4gb25seSBiZSBzZXJpYWxpemVkIGZyb20gYSB7QGxpbmsgQ29tcG9uZW50fS5cclxuICAgKiBcclxuICAgKiAqKkV4YW1wbGU6KipcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogaW1wb3J0IMaSID0gRnVkZ2VDb3JlO1xyXG4gICAqXHJcbiAgICogQMaSLnNlcmlhbGl6ZVxyXG4gICAqIGV4cG9ydCBjbGFzcyBNeVNjcmlwdCBleHRlbmRzIMaSLkNvbXBvbmVudFNjcmlwdCB7XHJcbiAgICogICAjc2l6ZTogbnVtYmVyID0gMTtcclxuICAgKiBcclxuICAgKiAgIEDGki5zZXJpYWxpemUoU3RyaW5nKSAvLyBkaXNwbGF5IGEgc3RyaW5nIGluIHRoZSBlZGl0b3JcclxuICAgKiAgIHB1YmxpYyBpbmZvOiBzdHJpbmc7XHJcbiAgICpcclxuICAgKiAgIEDGki5zZXJpYWxpemUoxpIuVmVjdG9yMykgLy8gZGlzcGxheSBhIHZlY3RvciBpbiB0aGUgZWRpdG9yXHJcbiAgICogICBwdWJsaWMgcG9zaXRpb246IMaSLlZlY3RvcjMgPSBuZXcgxpIuVmVjdG9yMygxLCAyLCAzKTtcclxuICAgKlxyXG4gICAqICAgQMaSLnNlcmlhbGl6ZSjGki5NYXRlcmlhbCkgLy8gZHJvcCBhIG1hdGVyaWFsIGluc2lkZSB0aGUgZWRpdG9yIHRvIHJlZmVyZW5jZSBpdFxyXG4gICAqICAgcHVibGljIHJlc291cmNlOiDGki5NYXRlcmlhbDtcclxuICAgKlxyXG4gICAqICAgQMaSLnNlcmlhbGl6ZSjGki5Ob2RlKSAvLyBkcm9wIGEgbm9kZSBpbnNpZGUgdGhlIGVkaXRvciB0byByZWZlcmVuY2UgaXRcclxuICAgKiAgIHB1YmxpYyByZWZlcmVuY2U6IMaSLk5vZGVcclxuICAgKiBcclxuICAgKiAgIEDGki5zZXJpYWxpemUoTnVtYmVyKSAvLyBkaXNwbGF5IGEgbnVtYmVyIGluIHRoZSBlZGl0b3JcclxuICAgKiAgIHB1YmxpYyBnZXQgc2l6ZSgpOiBudW1iZXIge1xyXG4gICAqICAgICByZXR1cm4gdGhpcy4jc2l6ZTtcclxuICAgKiAgIH1cclxuICAgKiBcclxuICAgKiAgIC8vIGRlZmluZSBhIHNldHRlciB0byBhbGxvdyB3cml0aW5nIHRvIHNpemUsIG9yIG9taXQgaXQgdG8gbGVhdmUgdGhlIHByb3BlcnR5IHJlYWQtb25seVxyXG4gICAqICAgcHVibGljIHNldCBzaXplKF9zaXplOiBudW1iZXIpIHtcclxuICAgKiAgICAgdGhpcy4jc2l6ZSA9IF9zaXplO1xyXG4gICAqICAgfVxyXG4gICAqIH1cclxuICAgKiBgYGBcclxuICAgKiBcclxuICAgKiAqKlNpZGUgZWZmZWN0czoqKlxyXG4gICAqICogQXR0cmlidXRlcyB3aXRoIGEgc3BlY2lmaWVkIHR5cGUgd2lsbCBhbHdheXMgYmUgaW5jbHVkZWQgaW4gdGhlIHtAbGluayBNdXRhdG9yIGJhc2UtbXV0YXRvcn0gXHJcbiAgICogKHZpYSB7QGxpbmsgTXV0YWJsZS5nZXRNdXRhdG9yfSksIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgb3duIHR5cGUuIE5vbi17QGxpbmsgTXV0YWJsZSBtdXRhYmxlfSBvYmplY3RzIFxyXG4gICAqIHdpbGwgYmUgZGlzcGxheWVkIHZpYSB0aGVpciB7QGxpbmsgdG9TdHJpbmd9IG1ldGhvZCBpbiB0aGUgZWRpdG9yLlxyXG4gICAqICogRGVjb3JhdGVkIGdldHRlcnMgd2lsbCBiZSBtYWRlIGVudW1lcmFibGUsIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0VudW1lcmFiaWxpdHlfYW5kX293bmVyc2hpcF9vZl9wcm9wZXJ0aWVzXHJcbiAgICogXHJcbiAgICogQGF1dGhvciBKb25hcyBQbG90emt5LCBIRlUsIDIwMjQtMjAyNVxyXG4gICAqL1xyXG4gIC8vIGNsYXNzIGRlY29yYXRvclxyXG4gIGV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemUoX3ZhbHVlOiBhYnN0cmFjdCBuZXcgKC4uLmFyZ3M6IEdlbmVyYWxbXSkgPT4gU2VyaWFsaXphYmxlLCBfY29udGV4dDogQ2xhc3NEZWNvcmF0b3JDb250ZXh0KTogdm9pZDtcclxuICAvLyBvYmplY3QgdHlwZSwgY2hlY2sgaWYgdGhlIGFjdHVhbCB0eXBlIGlzIGFzc2lnbmFibGUgdG8gdGhlIGdpdmVuIHR5cGVcclxuICBleHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplPFQsIEMgZXh0ZW5kcyBhYnN0cmFjdCBuZXcgKC4uLmFyZ3M6IEdlbmVyYWxbXSkgPT4gVD4oX2NvbnN0cnVjdG9yOiBDKTogKF92YWx1ZTogdW5rbm93biwgX2NvbnRleHQ6IENsYXNzUHJvcGVydHlDb250ZXh0PFQgZXh0ZW5kcyBOb2RlID8gTm9kZSBleHRlbmRzIFQgPyBDb21wb25lbnQgOiBTZXJpYWxpemFibGUgOiBTZXJpYWxpemFibGUsIFQ+KSA9PiB2b2lkO1xyXG4gIC8vIHByaW1pdGl2ZSB0eXBlLCBjaGVjayBpZiB0aGUgZ2l2ZW4gdHlwZSAoYSBwcmltaXRpdmUgY29uc3RydWN0b3IpIGlzIGFzc2lnbmFibGUgdG8gdGhlIGFjdHVhbCB0eXBlIChwcmltaXRpdmUpLlxyXG4gIGV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemU8VCBleHRlbmRzIE51bWJlciB8IFN0cmluZyB8IEJvb2xlYW4+KF9jb25zdHJ1Y3RvcjogYWJzdHJhY3QgbmV3ICguLi5hcmdzOiBHZW5lcmFsW10pID0+IFQpOiAoX3ZhbHVlOiB1bmtub3duLCBfY29udGV4dDogQ2xhc3NQcm9wZXJ0eUNvbnRleHQ8U2VyaWFsaXphYmxlLCBUPikgPT4gdm9pZDtcclxuICAvLyBlbnVtIHR5cGVcclxuICBleHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplPFQsIEUgZXh0ZW5kcyBSZWNvcmQ8a2V5b2YgRSwgVD4+KF9lbnVtOiBFKTogKF92YWx1ZTogdW5rbm93biwgX2NvbnRleHQ6IENsYXNzUHJvcGVydHlDb250ZXh0PFNlcmlhbGl6YWJsZSwgVD4pID0+IHZvaWQ7XHJcbiAgZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShfY29uc3RydWN0b3I6IEZ1bmN0aW9uIHwgT2JqZWN0LCBfY29udGV4dD86IENsYXNzRGVjb3JhdG9yQ29udGV4dCk6ICgoX3ZhbHVlOiB1bmtub3duLCBfY29udGV4dDogQ2xhc3NQcm9wZXJ0eUNvbnRleHQpID0+IHZvaWQpIHwgdm9pZCB7XHJcbiAgICAvLyBkZWNvcmF0ZSBjbGFzc1xyXG4gICAgaWYgKF9jb250ZXh0KSB7XHJcbiAgICAgIGxldCBtZXRhOiBNZXRhZGF0YSA9IF9jb250ZXh0Lm1ldGFkYXRhO1xyXG5cclxuICAgICAgY29uc3QgcHJvdG90eXBlOiBTZXJpYWxpemFibGUgPSAoPEZ1bmN0aW9uPl9jb25zdHJ1Y3RvcikucHJvdG90eXBlO1xyXG5cclxuICAgICAgLy8gbWFrZSBnZXR0ZXJzIGVudW1lcmFibGVcclxuICAgICAgaWYgKG1ldGEuZW51bWVyYXRlS2V5cykge1xyXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvciA9IHsgZW51bWVyYWJsZTogdHJ1ZSB9O1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIG1ldGEuZW51bWVyYXRlS2V5cylcclxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIGtleSwgZGVzY3JpcHRvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIG92ZXJyaWRlIHNlcmlhbGl6ZSBhbmQgZGVzZXJpYWxpemUgbWV0aG9kc1xyXG4gICAgICBjb25zdCBvcmlnaW5hbFNlcmlhbGl6ZTogU2VyaWFsaXphYmxlW1wic2VyaWFsaXplXCJdID0gcHJvdG90eXBlLnNlcmlhbGl6ZTtcclxuICAgICAgY29uc3Qgb3JpZ2luYWxEZXNlcmlhbGl6ZTogU2VyaWFsaXphYmxlW1wiZGVzZXJpYWxpemVcIl0gPSBwcm90b3R5cGUuZGVzZXJpYWxpemU7XHJcbiAgICAgIGNvbnN0IHNlcmlhbGl6YWJsZXM6IE1ldGFkYXRhW1wic2VyaWFsaXphYmxlc1wiXSA9IG1ldGEuc2VyaWFsaXphYmxlcztcclxuXHJcbiAgICAgIHByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAodGhpczogU2VyaWFsaXphYmxlKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgICAgY29uc3Qgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IG9yaWdpbmFsU2VyaWFsaXplPy5jYWxsKHRoaXMpID8/IHt9O1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzZXJpYWxpemFibGVzKSB7XHJcbiAgICAgICAgICBsZXQgdmFsdWU6IEdlbmVyYWwgPSBSZWZsZWN0LmdldCh0aGlzLCBrZXkpO1xyXG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgIHN3aXRjaCAoc2VyaWFsaXphYmxlc1trZXldKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwcmltaXRpdmVcIjpcclxuICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInNlcmlhbGl6YWJsZVwiOlxyXG4gICAgICAgICAgICAgIHNlcmlhbGl6YXRpb25ba2V5XSA9IHZhbHVlLnNlcmlhbGl6ZSgpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicmVzb3VyY2VcIjpcclxuICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uW2tleV0gPSB2YWx1ZS5pZFJlc291cmNlO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibm9kZVwiOlxyXG4gICAgICAgICAgICAgIHNlcmlhbGl6YXRpb25ba2V5XSA9IE5vZGUuUEFUSF9GUk9NX1RPKDxDb21wb25lbnQ+dGhpcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBwcm90b3R5cGUuZGVzZXJpYWxpemUgPSBhc3luYyBmdW5jdGlvbiAodGhpczogU2VyaWFsaXphYmxlLCBfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsRGVzZXJpYWxpemUpXHJcbiAgICAgICAgICBhd2FpdCBvcmlnaW5hbERlc2VyaWFsaXplLmNhbGwodGhpcywgX3NlcmlhbGl6YXRpb24pO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzZXJpYWxpemFibGVzKSB7XHJcbiAgICAgICAgICBsZXQgdmFsdWU6IEdlbmVyYWwgPSBfc2VyaWFsaXphdGlvbltrZXldO1xyXG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgIHN3aXRjaCAoc2VyaWFsaXphYmxlc1trZXldKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwcmltaXRpdmVcIjpcclxuICAgICAgICAgICAgICBSZWZsZWN0LnNldCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInNlcmlhbGl6YWJsZVwiOlxyXG4gICAgICAgICAgICAgIGF3YWl0IFJlZmxlY3QuZ2V0KHRoaXMsIGtleSkuZGVzZXJpYWxpemUodmFsdWUpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicmVzb3VyY2VcIjpcclxuICAgICAgICAgICAgICBSZWZsZWN0LnNldCh0aGlzLCBrZXksIFByb2plY3QucmVzb3VyY2VzW3ZhbHVlXSA/PyBhd2FpdCBQcm9qZWN0LmdldFJlc291cmNlKHZhbHVlKSk7IC8vIGF3YWl0IGlzIGNvc3RseSBzbyBmaXJzdCB0cnkgdG8gZ2V0IHJlc291cmNlIGRpcmVjdGx5XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJub2RlXCI6XHJcbiAgICAgICAgICAgICAgbGV0IGluc3RhbmNlOiBDb21wb25lbnQgPSA8Q29tcG9uZW50PnRoaXM7XHJcbiAgICAgICAgICAgICAgY29uc3QgaG5kTm9kZURlc2VyaWFsaXplZDogRXZlbnRMaXN0ZW5lclVuaWZpZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBobmRHcmFwaERlc2VyaWFsaXplZDogRXZlbnRMaXN0ZW5lclVuaWZpZWQgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LnNldCh0aGlzLCBrZXksIE5vZGUuRklORChpbnN0YW5jZSwgdmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULkdSQVBIX0RFU0VSSUFMSVpFRCwgaG5kR3JhcGhEZXNlcmlhbGl6ZWQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZS5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuR1JBUEhfSU5TVEFOVElBVEVELCBobmRHcmFwaERlc2VyaWFsaXplZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQsIGhuZE5vZGVEZXNlcmlhbGl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5HUkFQSF9ERVNFUklBTElaRUQsIGhuZEdyYXBoRGVzZXJpYWxpemVkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5HUkFQSF9JTlNUQU5USUFURUQsIGhuZEdyYXBoRGVzZXJpYWxpemVkLCB0cnVlKTtcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIGluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQsIGhuZE5vZGVEZXNlcmlhbGl6ZWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZGVjb3JhdGUgcHJvcGVydHlcclxuICAgIHJldHVybiAoX3ZhbHVlLCBfY29udGV4dCkgPT4geyAvLyBjb3VsZCBjYWNoZSB0aGUgZGVjb3JhdG9yIGZ1bmN0aW9uIGZvciBlYWNoIGNsYXNzXHJcbiAgICAgIGlmICh0eXBlb2YgX2NvbnRleHQubmFtZSAhPSBcInN0cmluZ1wiKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBtZXRhOiBNZXRhZGF0YSA9IF9jb250ZXh0Lm1ldGFkYXRhO1xyXG5cclxuICAgICAgLy8gYWRkIGF0dHJpYnV0ZSB0eXBlIHRvIG1ldGFkYXRhXHJcbiAgICAgIGlmICghT2JqZWN0Lmhhc093bihtZXRhLCBcImF0dHJpYnV0ZVR5cGVzXCIpKVxyXG4gICAgICAgIG1ldGEuYXR0cmlidXRlVHlwZXMgPSB7IC4uLm1ldGEuYXR0cmlidXRlVHlwZXMgfTtcclxuICAgICAgbWV0YS5hdHRyaWJ1dGVUeXBlc1tfY29udGV4dC5uYW1lXSA9IF9jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICAgIC8vIGRldGVybWluZSBzZXJpYWxpemF0aW9uIHR5cGUgYW5kIGFkZCB0byBtZXRhZGF0YVxyXG4gICAgICBsZXQgdHlwZTogTWV0YWRhdGFbXCJzZXJpYWxpemFibGVzXCJdW3N0cmluZ107XHJcblxyXG4gICAgICBpZiAoX2NvbnN0cnVjdG9yID09IFN0cmluZyB8fCBfY29uc3RydWN0b3IgPT0gTnVtYmVyIHx8IF9jb25zdHJ1Y3RvciA9PSBCb29sZWFuIHx8IHR5cGVvZiBfY29uc3RydWN0b3IgPT0gXCJvYmplY3RcIikgLy8gcHJpbWl0aXZlIG9yIGVudW1cclxuICAgICAgICB0eXBlID0gXCJwcmltaXRpdmVcIjtcclxuICAgICAgZWxzZSBpZiAoX2NvbnN0cnVjdG9yID09IE5vZGUpXHJcbiAgICAgICAgdHlwZSA9IFwibm9kZVwiO1xyXG4gICAgICBlbHNlIGlmICgoPEZ1bmN0aW9uPl9jb25zdHJ1Y3RvcikucHJvdG90eXBlIGluc3RhbmNlb2YgU2VyaWFsaXphYmxlUmVzb3VyY2UpXHJcbiAgICAgICAgdHlwZSA9IFwicmVzb3VyY2VcIjtcclxuICAgICAgZWxzZSBpZiAoKDxGdW5jdGlvbj5fY29uc3RydWN0b3IpLnByb3RvdHlwZS5zZXJpYWxpemUgJiYgKDxGdW5jdGlvbj5fY29uc3RydWN0b3IpLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSlcclxuICAgICAgICB0eXBlID0gXCJzZXJpYWxpemFibGVcIjtcclxuXHJcbiAgICAgIGlmICghdHlwZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBpZiAoIU9iamVjdC5oYXNPd24obWV0YSwgXCJzZXJpYWxpemFibGVzXCIpKVxyXG4gICAgICAgIG1ldGEuc2VyaWFsaXphYmxlcyA9IHsgLi4ubWV0YS5zZXJpYWxpemFibGVzIH07XHJcbiAgICAgIG1ldGEuc2VyaWFsaXphYmxlc1tfY29udGV4dC5uYW1lXSA9IHR5cGU7XHJcblxyXG4gICAgICBpZiAoX2NvbnRleHQua2luZCAhPSBcImdldHRlclwiKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIC8vIG1hcmsgZ2V0dGVyIHRvIGJlIG1hZGUgZW51bWVyYWJsZVxyXG4gICAgICBpZiAoIU9iamVjdC5oYXNPd24obWV0YSwgXCJlbnVtZXJhdGVLZXlzXCIpKVxyXG4gICAgICAgIG1ldGEuZW51bWVyYXRlS2V5cyA9IFtdO1xyXG5cclxuICAgICAgbWV0YS5lbnVtZXJhdGVLZXlzLnB1c2goX2NvbnRleHQubmFtZSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyB0aGUgZXh0ZXJuYWwgc2VyaWFsaXphdGlvbiBhbmQgZGVzZXJpYWxpemF0aW9uIG9mIHtAbGluayBTZXJpYWxpemFibGV9IG9iamVjdHMuIFRoZSBpbnRlcm5hbCBwcm9jZXNzIGlzIGhhbmRsZWQgYnkgdGhlIG9iamVjdHMgdGhlbXNlbHZlcy4gIFxyXG4gICAqIEEge0BsaW5rIFNlcmlhbGl6YXRpb259IG9iamVjdCBjYW4gYmUgY3JlYXRlZCBmcm9tIGEge0BsaW5rIFNlcmlhbGl6YWJsZX0gb2JqZWN0IGFuZCBhIEpTT04tU3RyaW5nIG1heSBiZSBjcmVhdGVkIGZyb20gdGhhdC4gIFxyXG4gICAqIFZpY2UgdmVyc2EsIGEgSlNPTi1TdHJpbmcgY2FuIGJlIHBhcnNlZCB0byBhIHtAbGluayBTZXJpYWxpemF0aW9ufSB3aGljaCBjYW4gYmUgZGVzZXJpYWxpemVkIHRvIGEge0BsaW5rIFNlcmlhbGl6YWJsZX0gb2JqZWN0LlxyXG4gICAqIGBgYHRleHRcclxuICAgKiAgW1NlcmlhbGl6YWJsZV0g4oaSIChzZXJpYWxpemUpIOKGkiBbU2VyaWFsaXphdGlvbl0g4oaSIChzdHJpbmdpZnkpIOKGkiBbU3RyaW5nXSDihpIgKHNhdmUgb3Igc2VuZClcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpMgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaTICAgICAgICAgICAgICAgICAg4oaTICAgICAgICAgXHJcbiAgICogICAgICAgICAgICAgICAgW1NlcmlhbGl6YWJsZV0g4oaQIChkZXNlcmlhbGl6ZSkg4oaQIFtTZXJpYWxpemF0aW9uXSDihpAgKHBhcnNlKSDihpAgKGxvYWQpIOKGkCBbTWVkaXVtXVxyXG4gICAqIGBgYCAgICAgIFxyXG4gICAqIFdoaWxlIHRoZSBpbnRlcm5hbCBzZXJpYWxpemUvZGVzZXJpYWxpemUgbWV0aG9kMXMgb2YgdGhlIG9iamVjdHMgY2FyZSBvZiB0aGUgc2VsZWN0aW9uIG9mIGluZm9ybWF0aW9uIG5lZWRlZCB0byByZWNyZWF0ZSB0aGUgb2JqZWN0IGFuZCBpdHMgc3RydWN0dXJlLCAgXHJcbiAgICogdGhlIHtAbGluayBTZXJpYWxpemVyfSBrZWVwcyB0cmFjayBvZiB0aGUgbmFtZXNwYWNlcyBhbmQgY2xhc3NlcyBpbiBvcmRlciB0byByZWNyZWF0ZSB7QGxpbmsgU2VyaWFsaXphYmxlfSBvYmplY3RzLiBUaGUgZ2VuZXJhbCBzdHJ1Y3R1cmUgb2YgYSB7QGxpbmsgU2VyaWFsaXphdGlvbn0gaXMgYXMgZm9sbG93cyAgXHJcbiAgICogYGBgdGV4dFxyXG4gICAqIHtcclxuICAgKiAgICAgIG5hbWVzcGFjZU5hbWUuY2xhc3NOYW1lOiB7XHJcbiAgICogICAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eVZhbHVlLFxyXG4gICAqICAgICAgICAgIC4uLixcclxuICAgKiAgICAgICAgICBwcm9wZXJ0eU5hbWVPZlJlZmVyZW5jZTogU2VyaWFsaXphdGlvbk9mVGhlUmVmZXJlbmNlZE9iamVjdCxcclxuICAgKiAgICAgICAgICAuLi4sXHJcbiAgICogICAgICAgICAgY29uc3RydWN0b3JOYW1lT2ZTdXBlcmNsYXNzOiBTZXJpYWxpemF0aW9uT2ZTdXBlckNsYXNzXHJcbiAgICogICAgICB9XHJcbiAgICogfVxyXG4gICAqIGBgYFxyXG4gICAqIFNpbmNlIHRoZSBpbnN0YW5jZSBvZiB0aGUgc3VwZXJjbGFzcyBpcyBjcmVhdGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhbiBvYmplY3QgaXMgY3JlYXRlZCwgXHJcbiAgICogdGhlIFNlcmlhbGl6YXRpb25PZlN1cGVyQ2xhc3Mgb21pdHMgdGhlIHRoZSBuYW1lc3BhY2VOYW1lLmNsYXNzTmFtZSBrZXkgYW5kIGNvbnNpc3RzIG9ubHkgb2YgaXRzIHZhbHVlLiBcclxuICAgKiBUaGUgY29uc3RydWN0b3JOYW1lT2ZTdXBlcmNsYXNzIGlzIGdpdmVuIGluc3RlYWQgYXMgYSBwcm9wZXJ0eSBuYW1lIGluIHRoZSBzZXJpYWxpemF0aW9uIG9mIHRoZSBzdWJjbGFzcy5cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2VyaWFsaXplciB7XHJcbiAgICAvKiogSW4gb3JkZXIgZm9yIHRoZSBTZXJpYWxpemVyIHRvIGNyZWF0ZSBjbGFzcyBpbnN0YW5jZXMsIGl0IG5lZWRzIGFjY2VzcyB0byB0aGUgYXBwcm9wcmlhdGUgbmFtZXNwYWNlcyAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbmFtZXNwYWNlczogTmFtZXNwYWNlUmVnaXN0ZXIgPSB7IFwixpJcIjogRnVkZ2VDb3JlIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYSBuYW1lc3BhY2UgdG8gdGhlIHtAbGluayBTZXJpYWxpemVyfSwgdG8gZW5hYmxlIGF1dG9tYXRpYyBpbnN0YW50aWF0aW9uIG9mIGNsYXNzZXMgZGVmaW5lZCB3aXRoaW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWdpc3Rlck5hbWVzcGFjZShfbmFtZXNwYWNlOiBPYmplY3QpOiBzdHJpbmcge1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIFNlcmlhbGl6ZXIubmFtZXNwYWNlcylcclxuICAgICAgICBpZiAoU2VyaWFsaXplci5uYW1lc3BhY2VzW25hbWVdID09IF9uYW1lc3BhY2UpXHJcbiAgICAgICAgICByZXR1cm4gbmFtZTtcclxuXHJcbiAgICAgIGxldCBuYW1lOiBzdHJpbmcgPSBTZXJpYWxpemVyLmZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlLCB3aW5kb3cpO1xyXG4gICAgICBpZiAoIW5hbWUpXHJcbiAgICAgICAgZm9yIChsZXQgcGFyZW50TmFtZSBpbiBTZXJpYWxpemVyLm5hbWVzcGFjZXMpIHtcclxuICAgICAgICAgIG5hbWUgPSBTZXJpYWxpemVyLmZpbmROYW1lc3BhY2VJbihfbmFtZXNwYWNlLCBTZXJpYWxpemVyLm5hbWVzcGFjZXNbcGFyZW50TmFtZV0pO1xyXG4gICAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgbmFtZSA9IHBhcmVudE5hbWUgKyBcIi5cIiArIG5hbWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIGlmICghbmFtZSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lc3BhY2Ugbm90IGZvdW5kLiBNYXliZSBwYXJlbnQgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQgYmVmb3JlP1wiKTtcclxuXHJcbiAgICAgIFNlcmlhbGl6ZXIubmFtZXNwYWNlc1tuYW1lXSA9IF9uYW1lc3BhY2U7XHJcbiAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6YWJsZSBGVURHRS1vYmplY3QgZ2l2ZW4sXHJcbiAgICAgKiBpbmNsdWRpbmcgYXR0YWNoZWQgY29tcG9uZW50cywgY2hpbGRyZW4sIHN1cGVyY2xhc3Mtb2JqZWN0cyBhbGwgaW5mb3JtYXRpb24gbmVlZGVkIGZvciByZWNvbnN0cnVjdGlvblxyXG4gICAgICogQHBhcmFtIF9vYmplY3QgQW4gb2JqZWN0IHRvIHNlcmlhbGl6ZSwgaW1wbGVtZW50aW5nIHRoZSB7QGxpbmsgU2VyaWFsaXphYmxlfSBpbnRlcmZhY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXJpYWxpemUoX29iamVjdDogU2VyaWFsaXphYmxlKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIC8vIFRPRE86IHNhdmUgdGhlIG5hbWVzcGFjZSB3aXRoIHRoZSBjb25zdHJ1Y3RvcnMgbmFtZVxyXG4gICAgICBsZXQgcGF0aDogc3RyaW5nID0gdGhpcy5nZXRGdWxsUGF0aChfb2JqZWN0KTtcclxuICAgICAgaWYgKCFwYXRoKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTmFtZXNwYWNlIG9mIHNlcmlhbGl6YWJsZSBvYmplY3Qgb2YgdHlwZSAke19vYmplY3QuY29uc3RydWN0b3IubmFtZX0gbm90IGZvdW5kLiBNYXliZSB0aGUgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQgb3IgdGhlIGNsYXNzIG5vdCBleHBvcnRlZD9gKTtcclxuXHJcbiAgICAgIHJldHVybiB7IFtwYXRoXTogX29iamVjdC5zZXJpYWxpemUoKSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIEZVREdFLW9iamVjdCByZWNvbnN0cnVjdGVkIGZyb20gdGhlIGluZm9ybWF0aW9uIGluIHRoZSB7QGxpbmsgU2VyaWFsaXphdGlvbn0gZ2l2ZW4sXHJcbiAgICAgKiBpbmNsdWRpbmcgYXR0YWNoZWQgY29tcG9uZW50cywgY2hpbGRyZW4sIHN1cGVyY2xhc3Mtb2JqZWN0c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgbGV0IHJlY29uc3RydWN0OiBTZXJpYWxpemFibGU7XHJcbiAgICAgIGxldCBwYXRoOiBzdHJpbmc7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gbG9vcCBjb25zdHJ1Y3RlZCBzb2xlbHkgdG8gYWNjZXNzIHR5cGUtcHJvcGVydHkuIE9ubHkgb25lIGV4cGVjdGVkIVxyXG4gICAgICAgIGZvciAocGF0aCBpbiBfc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgICAgcmVjb25zdHJ1Y3QgPSBTZXJpYWxpemVyLnJlY29uc3RydWN0KHBhdGgpO1xyXG4gICAgICAgICAgcmVjb25zdHJ1Y3QgPSBhd2FpdCByZWNvbnN0cnVjdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltwYXRoXSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgbGV0IG1lc3NhZ2U6IHN0cmluZyA9IGBEZXNlcmlhbGl6YXRpb24gb2YgJHtwYXRofSwgJHtyZWNvbnN0cnVjdCA/IFJlZmxlY3QuZ2V0KHJlY29uc3RydWN0LCBcImlkUmVzb3VyY2VcIikgOiBcIlwifSBmYWlsZWQ6IGAgKyBfZXJyb3I7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBBcnJheSBvZiBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcmlhbGl6YWJsZSBGVURHRS1vYmplY3RzIGdpdmVuIGluIHRoZSBhcnJheSxcclxuICAgICAqIGluY2x1ZGluZyBhdHRhY2hlZCBjb21wb25lbnRzLCBjaGlsZHJlbiwgc3VwZXJjbGFzcy1vYmplY3RzIGFsbCBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIHJlY29uc3RydWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2VyaWFsaXplQXJyYXk8VCBleHRlbmRzIFNlcmlhbGl6YWJsZT4oX3R5cGU6IG5ldyAoKSA9PiBULCBfb2JqZWN0czogU2VyaWFsaXphYmxlW10pOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb25zOiBTZXJpYWxpemF0aW9uW10gPSBbXTtcclxuICAgICAgbGV0IHBhdGg6IHN0cmluZyA9IHRoaXMuZ2V0RnVsbFBhdGgobmV3IF90eXBlKCkpO1xyXG4gICAgICBpZiAoIXBhdGgpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOYW1lc3BhY2Ugb2Ygc2VyaWFsaXphYmxlIG9iamVjdCBvZiB0eXBlICR7X3R5cGUubmFtZX0gbm90IGZvdW5kLiBNYXliZSB0aGUgbmFtZXNwYWNlIGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQgb3IgdGhlIGNsYXNzIG5vdCBleHBvcnRlZD9gKTtcclxuXHJcbiAgICAgIGZvciAobGV0IG9iamVjdCBvZiBfb2JqZWN0cylcclxuICAgICAgICBzZXJpYWxpemF0aW9ucy5wdXNoKG9iamVjdC5zZXJpYWxpemUoKSk7XHJcblxyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHt9O1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3BhdGhdID0gc2VyaWFsaXphdGlvbnM7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBBcnJheSBvZiBGVURHRS1vYmplY3RzIHJlY29uc3RydWN0ZWQgZnJvbSB0aGUgaW5mb3JtYXRpb24gaW4gdGhlIGFycmF5IG9mIHtAbGluayBTZXJpYWxpemF0aW9ufXMgZ2l2ZW4sXHJcbiAgICAgKiBpbmNsdWRpbmcgYXR0YWNoZWQgY29tcG9uZW50cywgY2hpbGRyZW4sIHN1cGVyY2xhc3Mtb2JqZWN0c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplQXJyYXkoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVtdPiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemFibGVzOiBTZXJpYWxpemFibGVbXSA9IFtdO1xyXG4gICAgICBsZXQgY29uc3RydWN0OiBuZXcgKCkgPT4gU2VyaWFsaXphYmxlO1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbnM6IFNlcmlhbGl6YXRpb25bXSA9IFtdO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIGxvb3AgY29uc3RydWN0ZWQgc29sZWx5IHRvIGFjY2VzcyB0eXBlLXByb3BlcnR5LiBPbmx5IG9uZSBleHBlY3RlZCFcclxuICAgICAgICBmb3IgKGxldCBwYXRoIGluIF9zZXJpYWxpemF0aW9uKSB7XHJcbiAgICAgICAgICBjb25zdHJ1Y3QgPSBTZXJpYWxpemVyLmdldENvbnN0cnVjdG9yKHBhdGgpO1xyXG4gICAgICAgICAgc2VyaWFsaXphdGlvbnMgPSBfc2VyaWFsaXphdGlvbltwYXRoXTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVzZXJpYWxpemF0aW9uIGZhaWxlZDogXCIgKyBfZXJyb3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGxldCBzZXJpYWxpemF0aW9uIG9mIHNlcmlhbGl6YXRpb25zKSB7XHJcbiAgICAgICAgbGV0IHNlcmlhbGl6YWJsZTogU2VyaWFsaXphYmxlID0gbmV3IGNvbnN0cnVjdCgpO1xyXG4gICAgICAgIGF3YWl0IHNlcmlhbGl6YWJsZS5kZXNlcmlhbGl6ZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgICBzZXJpYWxpemFibGVzLnB1c2goc2VyaWFsaXphYmxlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YWJsZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy9UT0RPOiBpbXBsZW1lbnQgcHJldHRpZmllciB0byBtYWtlIEpTT04tU3RyaW5naWZpY2F0aW9uIG9mIHNlcmlhbGl6YXRpb25zIG1vcmUgcmVhZGFibGUsIGUuZy4gcGxhY2luZyB4LCB5IGFuZCB6IGluIG9uZSBsaW5lXHJcbiAgICAvKipcclxuICAgICAqIFByZXR0aWZ5IGEgSlNPTi1TdHJpbmcsIHRvIG1ha2UgaXQgbW9yZSByZWFkYWJsZS5cclxuICAgICAqIG5vdCBpbXBsZW1lbnRlZCB5ZXRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBwcmV0dGlmeShfanNvbjogc3RyaW5nKTogc3RyaW5nIHsgcmV0dXJuIF9qc29uOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkLCBodW1hbiByZWFkYWJsZSBKU09OLVN0cmluZywgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB7QGxpbmsgU2VyaWFsaXphdGlvbn0gdGhhdCBtYXkgaGF2ZSBiZWVuIGNyZWF0ZWQgYnkge0BsaW5rIFNlcmlhbGl6ZXJ9LnNlcmlhbGl6ZVxyXG4gICAgICogQHBhcmFtIF9zZXJpYWxpemF0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc3RyaW5naWZ5KF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogc3RyaW5nIHtcclxuICAgICAgLy8gYWRqdXN0bWVudHMgdG8gc2VyaWFsaXphdGlvbiBjYW4gYmUgbWFkZSBoZXJlIGJlZm9yZSBzdHJpbmdpZmljYXRpb24sIGlmIGRlc2lyZWRcclxuICAgICAgbGV0IGpzb246IHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KF9zZXJpYWxpemF0aW9uLCBudWxsLCAyKTtcclxuICAgICAgbGV0IHByZXR0eTogc3RyaW5nID0gU2VyaWFsaXplci5wcmV0dGlmeShqc29uKTtcclxuICAgICAgcmV0dXJuIHByZXR0eTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgU2VyaWFsaXphdGlvbn0gY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBKU09OLVN0cmluZy4gUmVzdWx0IG1heSBiZSBwYXNzZWQgdG8ge0BsaW5rIFNlcmlhbGl6ZXIuZGVzZXJpYWxpemV9XHJcbiAgICAgKiBAcGFyYW0gX2pzb24gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2UoX2pzb246IHN0cmluZyk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShfanNvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBvZiB0aGUgY2xhc3MgZGVmaW5lZCB3aXRoIHRoZSBmdWxsIHBhdGggaW5jbHVkaW5nIHRoZSBuYW1lc3BhY2VOYW1lKHMpIGFuZCB0aGUgY2xhc3NOYW1lIHNlcGVyYXRlZCBieSBkb3RzKC4pIFxyXG4gICAgICogQHBhcmFtIF9wYXRoIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlY29uc3RydWN0KF9wYXRoOiBzdHJpbmcpOiBTZXJpYWxpemFibGUge1xyXG4gICAgICBsZXQgY29uc3RydWN0b3I6IG5ldyAoKSA9PiBTZXJpYWxpemFibGUgPSBTZXJpYWxpemVyLmdldENvbnN0cnVjdG9yKF9wYXRoKTtcclxuICAgICAgbGV0IHJlY29uc3RydWN0aW9uOiBTZXJpYWxpemFibGUgPSBuZXcgY29uc3RydWN0b3IoKTtcclxuICAgICAgcmV0dXJuIHJlY29uc3RydWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgZ2V0Q29uc3RydWN0b3I8VCBleHRlbmRzIFNlcmlhbGl6YWJsZT4oX3R5cGU6IHN0cmluZywgX25hbWVzcGFjZTogT2JqZWN0ID0gRnVkZ2VDb3JlKTogbmV3ICgpID0+IFQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25zdHJ1Y3RvciBmcm9tIHRoZSBnaXZlbiBwYXRoIHRvIGEgY2xhc3NcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb25zdHJ1Y3RvcjxUIGV4dGVuZHMgU2VyaWFsaXphYmxlPihfcGF0aDogc3RyaW5nKTogbmV3ICgpID0+IFQge1xyXG4gICAgICBsZXQgdHlwZU5hbWU6IHN0cmluZyA9IF9wYXRoLnN1YnN0cmluZyhfcGF0aC5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcclxuICAgICAgbGV0IG5hbWVzcGFjZTogT2JqZWN0ID0gU2VyaWFsaXplci5nZXROYW1lc3BhY2UoX3BhdGgpO1xyXG4gICAgICBpZiAoIW5hbWVzcGFjZSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnN0cnVjdG9yIG9mIHNlcmlhbGl6YWJsZSBvYmplY3Qgb2YgdHlwZSAke19wYXRofSBub3QgZm91bmQuIE1heWJlIHRoZSBuYW1lc3BhY2UgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZD9gKTtcclxuICAgICAgcmV0dXJuICg8R2VuZXJhbD5uYW1lc3BhY2UpW3R5cGVOYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGZ1bGwgcGF0aCB0byB0aGUgY2xhc3Mgb2YgdGhlIG9iamVjdCwgaWYgZm91bmQgaW4gdGhlIHJlZ2lzdGVyZWQgbmFtZXNwYWNlc1xyXG4gICAgICogQHBhcmFtIF9vYmplY3QgXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGdldEZ1bGxQYXRoKF9vYmplY3Q6IFNlcmlhbGl6YWJsZSk6IHN0cmluZyB7XHJcbiAgICAgIGxldCB0eXBlTmFtZTogc3RyaW5nID0gX29iamVjdC5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAvLyBEZWJ1Zy5sb2coXCJTZWFyY2hpbmcgbmFtZXNwYWNlIG9mOiBcIiArIHR5cGVOYW1lKTtcclxuICAgICAgZm9yIChsZXQgbmFtZXNwYWNlTmFtZSBpbiBTZXJpYWxpemVyLm5hbWVzcGFjZXMpIHtcclxuICAgICAgICBsZXQgZm91bmQ6IEdlbmVyYWwgPSAoPEdlbmVyYWw+U2VyaWFsaXplci5uYW1lc3BhY2VzKVtuYW1lc3BhY2VOYW1lXVt0eXBlTmFtZV07XHJcbiAgICAgICAgaWYgKGZvdW5kICYmIF9vYmplY3QgaW5zdGFuY2VvZiBmb3VuZClcclxuICAgICAgICAgIHJldHVybiBuYW1lc3BhY2VOYW1lICsgXCIuXCIgKyB0eXBlTmFtZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5hbWVzcGFjZS1vYmplY3QgZGVmaW5lZCB3aXRoaW4gdGhlIGZ1bGwgcGF0aCwgaWYgcmVnaXN0ZXJlZFxyXG4gICAgICogQHBhcmFtIF9wYXRoXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIGdldE5hbWVzcGFjZShfcGF0aDogc3RyaW5nKTogT2JqZWN0IHtcclxuICAgICAgbGV0IG5hbWVzcGFjZU5hbWU6IHN0cmluZyA9IF9wYXRoLnN1YnN0cigwLCBfcGF0aC5sYXN0SW5kZXhPZihcIi5cIikpO1xyXG4gICAgICByZXR1cm4gU2VyaWFsaXplci5uYW1lc3BhY2VzW25hbWVzcGFjZU5hbWVdIHx8IEZ1ZGdlQ29yZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIHRoZSBuYW1lc3BhY2Utb2JqZWN0IGluIHByb3BlcnRpZXMgb2YgdGhlIHBhcmVudC1vYmplY3QgKGUuZy4gd2luZG93KSwgaWYgcHJlc2VudFxyXG4gICAgICogQHBhcmFtIF9uYW1lc3BhY2UgXHJcbiAgICAgKiBAcGFyYW0gX3BhcmVudCBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmluZE5hbWVzcGFjZUluKF9uYW1lc3BhY2U6IE9iamVjdCwgX3BhcmVudDogT2JqZWN0KTogc3RyaW5nIHtcclxuICAgICAgZm9yIChsZXQgcHJvcCBpbiBfcGFyZW50KVxyXG4gICAgICAgIGlmICgoPEdlbmVyYWw+X3BhcmVudClbcHJvcF0gPT0gX25hbWVzcGFjZSlcclxuICAgICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgKGFic3RyYWN0KSBjbGFzcyBpbXBsZW1lbnRpbmcge0BsaW5rIFNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWx9IGZyb20gYW55IGNsYXNzIHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgU2VyaWFsaXphYmxlUmVzb3VyY2V9IGJ5IG1peGluZyBpbiB0aGUgZnVuY3Rpb25hbGl0eSB0byBsb2FkIHRoZSByZXNvdXJjZSBmcm9tIGFuIGV4dGVybmFsIHNvdXJjZS5cclxuICAgKiBAaW50ZXJuYWwgXHJcbiAgICogQGF1dGhvcnMgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDI0XHJcbiAgICovXHJcbiAgZXhwb3J0IGZ1bmN0aW9uIG1peGluU2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbDxUQmFzZSBleHRlbmRzIGFic3RyYWN0IG5ldyAoLi4uYXJnczogR2VuZXJhbFtdKSA9PiBTZXJpYWxpemFibGVSZXNvdXJjZT4oX2Jhc2U6IFRCYXNlKTogKGFic3RyYWN0IG5ldyAoLi4uYXJnczogR2VuZXJhbFtdKSA9PiBTZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsKSAmIFRCYXNlIHtcclxuICAgIGFic3RyYWN0IGNsYXNzIFNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWxNaXhpbiBleHRlbmRzIF9iYXNlIHtcclxuICAgICAgcHVibGljIHVybDogUmVxdWVzdEluZm87XHJcblxyXG4gICAgICBwdWJsaWMgc3RhdHVzOiBSRVNPVVJDRV9TVEFUVVMgPSBSRVNPVVJDRV9TVEFUVVMuUEVORElORztcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXR1cm5zIGEge0BsaW5rIFNlcmlhbGl6YXRpb259IG9mIHRoaXMgcmVzb3VyY2UuIE9ubHkgdGhlIGRhdGEgbmVlZGVkIHRvIGxvYWQgaXQgZnJvbSB0aGUgZXh0ZXJuYWwgc291cmNlIGlzIHNlcmlhbGl6ZWQgKFwidXJsXCIsIFwibmFtZVwiLCBcImlkUmVzb3VyY2VcIikuXHJcbiAgICAgICAqL1xyXG4gICAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2UsXHJcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXHJcbiAgICAgICAgICB1cmw6IHRoaXMudXJsLnRvU3RyaW5nKClcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcywgX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XHJcbiAgICAgICAgdGhpcy51cmwgPSBfc2VyaWFsaXphdGlvbi51cmw7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gX3NlcmlhbGl6YXRpb24ubmFtZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHB1YmxpYyBhYnN0cmFjdCBsb2FkKCk6IFByb21pc2U8U2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbD47XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChfYmFzZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBNdXRhYmxlKSB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBNaXhpbiB0aGUge0BsaW5rIE11dGFibGV9IGZ1bmN0aW9uYWxpdHkgaW50byB0aGUgY2xhc3MgXHJcbiAgICAgICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNFxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gbWl4aW5NdXRhYmxlU2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbDxUQmFzZSBleHRlbmRzIChhYnN0cmFjdCBuZXcgKC4uLmFyZ3M6IEdlbmVyYWxbXSkgPT4gU2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbCAmIE11dGFibGUpPihfYmFzZTogVEJhc2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgICAgIGFic3RyYWN0IGNsYXNzIE11dGFibGVTZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsIGV4dGVuZHMgX2Jhc2Uge1xyXG4gICAgICAgICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoX211dGF0b3IudXJsICE9IHVuZGVmaW5lZCB8fCBfbXV0YXRvci5uYW1lICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxvYWQoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAgICAgICBkZWxldGUgX211dGF0b3Iuc3RhdHVzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIE11dGFibGVTZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbWl4aW5NdXRhYmxlU2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbCg8VEJhc2UgJiAoYWJzdHJhY3QgbmV3ICguLi5hcmdzOiBHZW5lcmFsW10pID0+IFNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWwgJiBNdXRhYmxlKT5TZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsTWl4aW4pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBTZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsTWl4aW47XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogTWFuYWdlcyB1bmlmb3JtIGRhdGEgdG8gYmUgdHJhbnNtaXR0ZWQgZHVyaW5nIHJlbmRlcmluZy4gQWxsIGRhdGEgaXMgY29sbGVjdGVkIGluIG9uZSBjb250aWd1b3VzIGJ1ZmZlciBhbmQgc2VudCB0byB0aGUgR1BVIGluIGEgc2luZ2xlIG9wZXJhdGlvbi5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAYXV0aG9ycyBKb25hcyBQbG90emt5LCBIRlUsIDIwMjVcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyQnVmZmVyTWFuYWdlciB7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIG1hcE9iamVjdFRvT2Zmc2V0OiBXZWFrTWFwPFdlYWtLZXksIG51bWJlcj4gPSBuZXcgV2Vha01hcDxXZWFrS2V5LCBudW1iZXI+KCk7IC8vIE1hcHMgdGhlIG9iamVjdHMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBieXRlIG9mZnNldCBpbiB0aGUgZ3B1IGJ1ZmZlclxyXG5cclxuICAgIC8qKiBUaGUgdW5pZm9ybSBibG9jayBzaXplIChpbnNpZGUgdGhlIHNoYWRlcikgaW4gYnl0ZXMsIGluY2x1ZGVzIGxheW91dCBzdGQxNDAgcGFkZGluZyAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBibG9ja1NpemU6IG51bWJlcjtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgYmxvY2tCaW5kaW5nOiBudW1iZXI7XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBidWZmZXI6IFdlYkdMQnVmZmVyO1xyXG4gICAgLyoqIFRoZSBvZmZzZXQgaW4gYnl0ZXMgYmV0d2VlbiB0aGUgYmVnaW5uaW5nIG9mIGNvbnNlY3V0aXZlIG9iamVjdCBibG9jayBkYXRhLCBzZXQgdG8gYSBtdWx0aXBsZSBvZiB7QGxpbmsgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUl9PRkZTRVRfQUxJR05NRU5UfSAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBzcGFjZUJ1ZmZlcjogbnVtYmVyO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZGF0YTogRmxvYXQzMkFycmF5O1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkYXRhVUludDogVWludDMyQXJyYXk7XHJcblxyXG4gICAgLyoqIFRoZSBvZmZzZXQgaW4gZWxlbWVudHMgYmV0d2VlbiB0aGUgYmVnaW5uaW5nIG9mIGNvbnNlY3V0aXZlIG9iamVjdCBibG9jayBkYXRhICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHNwYWNlRGF0YTogbnVtYmVyO1xyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgY291bnQ6IG51bWJlcjtcclxuXHJcbiAgICAvKiogQGludGVybmFsIFJlcGxhY2VzIHRoZSBkZWNvcmF0ZWQgbWV0aG9kIHdpdGggdGhlIG1hbmFnZXLigJlzIGltcGxlbWVudGF0aW9uIG9mIHRoZSBzYW1lIG5hbWUuICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlPE0gZXh0ZW5kcyAodGhpczogR2VuZXJhbCwgLi4uYXJnczogR2VuZXJhbCkgPT4gR2VuZXJhbD4oX21ldGhvZDogTSwgX2NvbnRleHQ6IENsYXNzTWV0aG9kRGVjb3JhdG9yQ29udGV4dDxhYnN0cmFjdCBuZXcgKC4uLmFyZ3M6IEdlbmVyYWxbXSkgPT4gR2VuZXJhbCwgTT4pOiBNIHtcclxuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRoaXMsIF9jb250ZXh0Lm5hbWUpLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBpbml0aWFsaXplKF9yZW5kZXJXZWJHTDogdHlwZW9mIFJlbmRlcldlYkdMLCBfYmxvY2tCaW5kaW5nOiBudW1iZXIsIF9ibG9ja1NpemU6IG51bWJlciwgX21heE9iamVjdHM6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmJsb2NrU2l6ZSA9IF9ibG9ja1NpemU7XHJcbiAgICAgIHRoaXMuYmxvY2tCaW5kaW5nID0gX2Jsb2NrQmluZGluZztcclxuXHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBfcmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjb25zdCBhbGlnbm1lbnQ6IG51bWJlciA9IGNyYzMuZ2V0UGFyYW1ldGVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVJfT0ZGU0VUX0FMSUdOTUVOVCk7XHJcbiAgICAgIHRoaXMuc3BhY2VCdWZmZXIgPSBNYXRoLmNlaWwodGhpcy5ibG9ja1NpemUgLyBhbGlnbm1lbnQpICogYWxpZ25tZW50OyAvLyByb3VuZCB0byBtdWx0aXBsZSBvZiBhbGlnbm1lbnRcclxuICAgICAgdGhpcy5zcGFjZURhdGEgPSB0aGlzLnNwYWNlQnVmZmVyIC8gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuc3BhY2VEYXRhICogX21heE9iamVjdHMpO1xyXG4gICAgICB0aGlzLmRhdGFVSW50ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuZGF0YS5idWZmZXIpO1xyXG4gICAgICB0aGlzLmNvdW50ID0gMDtcclxuXHJcbiAgICAgIHRoaXMuYnVmZmVyID0gX3JlbmRlcldlYkdMLmFzc2VydDxXZWJHTEJ1ZmZlcj4oY3JjMy5jcmVhdGVCdWZmZXIoKSk7XHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XHJcbiAgICAgIGNyYzMuYnVmZmVyRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCB0aGlzLmRhdGEuYnl0ZUxlbmd0aCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5EWU5BTUlDX0RSQVcpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVzZXRSZW5kZXJEYXRhKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVwZGF0ZVJlbmRlcmJ1ZmZlcigpOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuICAgICAgY3JjMy5idWZmZXJTdWJEYXRhKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIDAsIHRoaXMuZGF0YSwgMCwgdGhpcy5jb3VudCAqIHRoaXMuc3BhY2VEYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVzZVJlbmRlckRhdGEoX29iamVjdDogV2Vha0tleSk6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjcmMzLmJpbmRCdWZmZXJSYW5nZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCB0aGlzLmJsb2NrQmluZGluZywgdGhpcy5idWZmZXIsIHRoaXMubWFwT2JqZWN0VG9PZmZzZXQuZ2V0KF9vYmplY3QpLCB0aGlzLmJsb2NrU2l6ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBzdG9yZShfb2JqZWN0OiBXZWFrS2V5KTogbnVtYmVyIHtcclxuICAgICAgY29uc3Qgb2Zmc2V0RGF0YTogbnVtYmVyID0gdGhpcy5jb3VudCAqIHRoaXMuc3BhY2VEYXRhO1xyXG4gICAgICB0aGlzLm1hcE9iamVjdFRvT2Zmc2V0LnNldChfb2JqZWN0LCB0aGlzLmNvdW50ICogdGhpcy5zcGFjZUJ1ZmZlcik7IC8vIG9mZnNldCBpbiBieXRlc1xyXG4gICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgIGlmIChvZmZzZXREYXRhICsgdGhpcy5zcGFjZURhdGEgPiB0aGlzLmRhdGEubGVuZ3RoKVxyXG4gICAgICAgIHRoaXMuZ3JvdygpO1xyXG5cclxuICAgICAgcmV0dXJuIG9mZnNldERhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyB1cGRhdGVSZW5kZXJEYXRhKF9vYmplY3Q6IFdlYWtLZXksIC4uLl9kYXRhOiBHZW5lcmFsW10pOiB2b2lkIHtcclxuICAgICAgLyoqIG92ZXJyaWRlbiBpbiBzdWJjbGFzc2VzICovXHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdyb3coKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5kYXRhLmxlbmd0aCAqIDEuNSk7XHJcbiAgICAgIGRhdGEuc2V0KHRoaXMuZGF0YSk7XHJcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgIHRoaXMuZGF0YVVJbnQgPSBuZXcgVWludDMyQXJyYXkodGhpcy5kYXRhLmJ1ZmZlcik7XHJcblxyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG4gICAgICBjcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgdGhpcy5kYXRhLmJ5dGVMZW5ndGgsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFlOQU1JQ19EUkFXKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogTWFuYWdlcyB7QGxpbmsgQ29hdH0gZGF0YSB0byBiZSB0cmFuc21pdHRlZCBkdXJpbmcgcmVuZGVyaW5nLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJNYW5hZ2VyQ29hdCBleHRlbmRzIFJlbmRlckJ1ZmZlck1hbmFnZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyBvdmVycmlkZSBpbml0aWFsaXplKF9yZW5kZXJXZWJHTDogdHlwZW9mIFJlbmRlcldlYkdMKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IG1heE1hdGVyaWFsczogbnVtYmVyID0gMTI4O1xyXG4gICAgICBjb25zdCBibG9ja1NpemU6IG51bWJlciA9ICg0ICsgMSArIDEgKyAxICsgMSArIDEpICogNDsgLy8gdmN0NCBjb2xvciwgZmxvYXQgZGlmZnVzZSwgZmxvYXQgc3BlY3VsYXIsIGZsb2F0IGludGVuc2l0eSwgZmxvYXQgbWV0YWxsaWMsIGZsb2F0IGFscGhhQ2xpcFxyXG4gICAgICBzdXBlci5pbml0aWFsaXplKF9yZW5kZXJXZWJHTCwgVU5JRk9STV9CTE9DSy5NQVRFUklBTC5CSU5ESU5HLCBibG9ja1NpemUsIG1heE1hdGVyaWFscyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBvdmVycmlkZSB1cGRhdGVSZW5kZXJEYXRhKF9jb2F0OiBDb2F0KTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IG9mZnNldDogbnVtYmVyID0gdGhpcy5zdG9yZShfY29hdCk7XHJcblxyXG4gICAgICBjb25zdCBkYXRhOiBGbG9hdDMyQXJyYXkgPSB0aGlzLmRhdGE7XHJcblxyXG4gICAgICBpZiAoX2NvYXQgaW5zdGFuY2VvZiBDb2F0Q29sb3JlZCkgeyAvLyBUT0RPOiB1c2UgaW5oZXJpdGFuY2UgdG8gYXZvaWQgY2hlY2s/XHJcbiAgICAgICAgY29uc3QgY29sb3I6IENvbG9yID0gX2NvYXQuY29sb3I7XHJcbiAgICAgICAgZGF0YVtvZmZzZXRdID0gY29sb3IucjtcclxuICAgICAgICBkYXRhW29mZnNldCArIDFdID0gY29sb3IuZztcclxuICAgICAgICBkYXRhW29mZnNldCArIDJdID0gY29sb3IuYjtcclxuICAgICAgICBkYXRhW29mZnNldCArIDNdID0gY29sb3IuYTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKF9jb2F0IGluc3RhbmNlb2YgQ29hdFJlbWlzc2l2ZSB8fCBfY29hdCBpbnN0YW5jZW9mIENvYXRSZW1pc3NpdmVUZXh0dXJlZCkge1xyXG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgNF0gPSBfY29hdC5kaWZmdXNlO1xyXG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgNV0gPSBfY29hdC5zcGVjdWxhcjtcclxuICAgICAgICBkYXRhW29mZnNldCArIDZdID0gX2NvYXQuaW50ZW5zaXR5O1xyXG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgN10gPSBfY29hdC5tZXRhbGxpYztcclxuICAgICAgfVxyXG5cclxuICAgICAgZGF0YVtvZmZzZXQgKyA4XSA9IF9jb2F0LmFscGhhQ2xpcDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIG92ZXJyaWRlIHVzZVJlbmRlckRhdGEoX2NvYXQ6IENvYXQpOiB2b2lkIHtcclxuICAgICAgc3VwZXIudXNlUmVuZGVyRGF0YShfY29hdCk7XHJcblxyXG4gICAgICBpZiAoX2NvYXQgaW5zdGFuY2VvZiBDb2F0VGV4dHVyZWQpXHJcbiAgICAgICAgX2NvYXQudGV4dHVyZS51c2VSZW5kZXJEYXRhKFRFWFRVUkVfTE9DQVRJT04uQ09MT1IuVU5JVCk7XHJcblxyXG4gICAgICBpZiAoX2NvYXQgaW5zdGFuY2VvZiBDb2F0UmVtaXNzaXZlVGV4dHVyZWROb3JtYWxzKVxyXG4gICAgICAgIF9jb2F0Lm5vcm1hbE1hcC51c2VSZW5kZXJEYXRhKFRFWFRVUkVfTE9DQVRJT04uTk9STUFMLlVOSVQpO1xyXG5cclxuICAgICAgaWYgKF9jb2F0IGluc3RhbmNlb2YgQ29hdFRvb24pXHJcbiAgICAgICAgX2NvYXQudGV4VG9vbi51c2VSZW5kZXJEYXRhKFRFWFRVUkVfTE9DQVRJT04uVE9PTi5VTklUKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIE1hbmFnZXMge0BsaW5rIE5vZGV9IGRhdGEgKGRhdGEgdGhhdCBpcyB1bmlxdWUgZm9yIGVhY2ggbm9kZSwgaS5lLiB7QGxpbmsgQ29tcG9uZW50fSBkYXRhKSB0byBiZSB0cmFuc21pdHRlZCBkdXJpbmcgcmVuZGVyaW5nLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZW5kZXJNYW5hZ2VyTm9kZSBleHRlbmRzIFJlbmRlckJ1ZmZlck1hbmFnZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyBvdmVycmlkZSBpbml0aWFsaXplKF9yZW5kZXJXZWJHTDogdHlwZW9mIFJlbmRlcldlYkdMKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IG1heE5vZGVzOiBudW1iZXIgPSAyNTY7XHJcbiAgICAgIGNvbnN0IGJsb2NrU2l6ZTogbnVtYmVyID0gKDE2ICsgMTIgKyA0ICsgMSArIDEgKyAxICsgMSArIDEgKyAxKSAqIDQ7IC8vIG1hdDQgbXR4V29ybGQsIG1hdDMgbXR4UGl2b3QsIHZlYzQgY29sb3IsIGZsb2F0IGJsZW5kTW9kZSwgZmxvYXQgZHVyYXRpb24sIGZsb2F0IHNpemUsIGZsb2F0IHRpbWUsIGJvb2wgZmFjZUNhbWVyYUFjdGl2ZSwgYm9vbCBmYWNlQ2FtZXJhUmVzdHJpY3QsIFxyXG4gICAgICBzdXBlci5pbml0aWFsaXplKF9yZW5kZXJXZWJHTCwgVU5JRk9STV9CTE9DSy5OT0RFLkJJTkRJTkcsIGJsb2NrU2l6ZSwgbWF4Tm9kZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgb3ZlcnJpZGUgdXBkYXRlUmVuZGVyRGF0YShfbm9kZTogTm9kZSwgX2NtcE1lc2g6IENvbXBvbmVudE1lc2gsIF9jbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwsIF9jbXBGYWNlQ2FtZXJhPzogQ29tcG9uZW50RmFjZUNhbWVyYSwgX2NtcFBhcnRpY2xlU3lzdGVtPzogQ29tcG9uZW50UGFydGljbGVTeXN0ZW0pOiB2b2lkIHtcclxuICAgICAgY29uc3Qgb2Zmc2V0OiBudW1iZXIgPSB0aGlzLnN0b3JlKF9ub2RlKTtcclxuXHJcbiAgICAgIGNvbnN0IGRhdGE6IEZsb2F0MzJBcnJheSA9IHRoaXMuZGF0YTtcclxuICAgICAgLy8gbXR4IHdvcmxkXHJcbiAgICAgIGRhdGEuc2V0KF9jbXBNZXNoLm10eFdvcmxkLmdldEFycmF5KCksIG9mZnNldCk7XHJcblxyXG4gICAgICAvLyBtdHggcGl2b3RcclxuICAgICAgbGV0IGRhdGFQaXZvdDogQXJyYXlMaWtlPG51bWJlcj4gPSBfY21wTWF0ZXJpYWwubXR4UGl2b3QuZ2V0QXJyYXkoKTtcclxuICAgICAgZGF0YVtvZmZzZXQgKyAxNl0gPSBkYXRhUGl2b3RbMF07XHJcbiAgICAgIGRhdGFbb2Zmc2V0ICsgMTddID0gZGF0YVBpdm90WzFdO1xyXG4gICAgICBkYXRhW29mZnNldCArIDE4XSA9IGRhdGFQaXZvdFsyXTtcclxuICAgICAgLy8gZGF0YVtvZmZzZXRQaXZvdCArIDE5XSA9IHBhZGRpbmdcclxuICAgICAgZGF0YVtvZmZzZXQgKyAyMF0gPSBkYXRhUGl2b3RbM107XHJcbiAgICAgIGRhdGFbb2Zmc2V0ICsgMjFdID0gZGF0YVBpdm90WzRdO1xyXG4gICAgICBkYXRhW29mZnNldCArIDIyXSA9IGRhdGFQaXZvdFs1XTtcclxuICAgICAgLy8gZGF0YVtvZmZzZXRQaXZvdCArIDIzXSA9IHBhZGRpbmdcclxuICAgICAgZGF0YVtvZmZzZXQgKyAyNF0gPSBkYXRhUGl2b3RbNl07XHJcbiAgICAgIGRhdGFbb2Zmc2V0ICsgMjVdID0gZGF0YVBpdm90WzddO1xyXG4gICAgICBkYXRhW29mZnNldCArIDI2XSA9IGRhdGFQaXZvdFs4XTtcclxuICAgICAgLy8gZGF0YVtvZmZzZXRQaXZvdCArIDI3XSA9IHBhZGRpbmdcclxuXHJcbiAgICAgIC8vIGNvbG9yXHJcbiAgICAgIGxldCBjb2xvcjogQ29sb3IgPSBfY21wTWF0ZXJpYWwuY2xyUHJpbWFyeTtcclxuICAgICAgZGF0YVtvZmZzZXQgKyAyOF0gPSBjb2xvci5yO1xyXG4gICAgICBkYXRhW29mZnNldCArIDI5XSA9IGNvbG9yLmc7XHJcbiAgICAgIGRhdGFbb2Zmc2V0ICsgMzBdID0gY29sb3IuYjtcclxuICAgICAgZGF0YVtvZmZzZXQgKyAzMV0gPSBjb2xvci5hO1xyXG5cclxuICAgICAgaWYgKF9jbXBQYXJ0aWNsZVN5c3RlbSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGFVaW50OiBVaW50MzJBcnJheSA9IHRoaXMuZGF0YVVJbnQ7XHJcbiAgICAgICAgZGF0YVVpbnRbb2Zmc2V0ICsgMzJdID0gX2NtcFBhcnRpY2xlU3lzdGVtLmJsZW5kTW9kZTtcclxuICAgICAgICBkYXRhW29mZnNldCArIDMzXSA9IF9jbXBQYXJ0aWNsZVN5c3RlbS5kdXJhdGlvbjtcclxuICAgICAgICBkYXRhW29mZnNldCArIDM0XSA9IF9jbXBQYXJ0aWNsZVN5c3RlbS5zaXplO1xyXG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMzVdID0gX2NtcFBhcnRpY2xlU3lzdGVtLnRpbWU7XHJcbiAgICAgICAgZGF0YVVpbnRbb2Zmc2V0ICsgMzZdID0gX2NtcEZhY2VDYW1lcmE/LmlzQWN0aXZlID8gMSA6IDA7XHJcbiAgICAgICAgZGF0YVVpbnRbb2Zmc2V0ICsgMzddID0gX2NtcEZhY2VDYW1lcmE/LnJlc3RyaWN0ID8gMSA6IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIG92ZXJyaWRlIHVzZVJlbmRlckRhdGEoX25vZGU6IE5vZGUsIF9tdHhXb3JsZE92ZXJyaWRlPzogTWF0cml4NHg0KTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBsZXQgb2Zmc2V0OiBudW1iZXIgPSB0aGlzLm1hcE9iamVjdFRvT2Zmc2V0LmdldChfbm9kZSk7XHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlclJhbmdlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIHRoaXMuYmxvY2tCaW5kaW5nLCB0aGlzLmJ1ZmZlciwgb2Zmc2V0LCB0aGlzLmJsb2NrU2l6ZSk7XHJcblxyXG4gICAgICBpZiAoX210eFdvcmxkT3ZlcnJpZGUpIC8vIHRoaXMgaXMgcmVsYXRpdmVseSBzbG93LCBidXQgc2luY2UgcHJlcGFyZSBoYXMgbm8gY2FtZXJhIGluZm9ybWF0aW9uLCB3ZSBtYXkgbmVlZCB0byBvdmVycmlkZSB0aGUgd29ybGQgbWF0cml4IGhlcmVcclxuICAgICAgICBjcmMzLmJ1ZmZlclN1YkRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgb2Zmc2V0LCBfbXR4V29ybGRPdmVycmlkZS5nZXRBcnJheSgpKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBwaWNraW5nLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJXZWJHTFBpY2tpbmcge1xyXG4gICAgcHVibGljIHN0YXRpYyBmYm9QaWNrOiBXZWJHTEJ1ZmZlcjtcclxuICAgIHB1YmxpYyBzdGF0aWMgdGV4UGljazogV2ViR0xUZXh0dXJlO1xyXG4gICAgcHVibGljIHN0YXRpYyB0ZXhEZXB0aDogV2ViR0xUZXh0dXJlO1xyXG5cclxuICAgIHN0YXRpYyAjc2l6ZU1heDogbnVtYmVyOyAvLyB0aGUgZGltZW5zaW9uIG9mIHRoZSBzcXVhcmUgcGljayB0ZXh0dXJlXHJcbiAgICBzdGF0aWMgI2RhdGE6IEludDMyQXJyYXk7XHJcbiAgICBzdGF0aWMgI2RhdGFDbGVhckNvbG9yOiBudW1iZXJbXSA9IFswLCAwLCAwLCAwXTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBJbml0aWFsaXplIGZyYW1lYnVmZmVycyBhbmQgcmVuZGVyIGF0dGFjaG1lbnRzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGluaXRpYWxpemUoX3JlbmRlcldlYkdMOiB0eXBlb2YgUmVuZGVyV2ViR0wpOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IF9yZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTFBpY2tpbmcuZmJvUGljayA9IF9yZW5kZXJXZWJHTC5hc3NlcnQoY3JjMy5jcmVhdGVGcmFtZWJ1ZmZlcigpKTtcclxuICAgICAgUmVuZGVyV2ViR0xQaWNraW5nLnRleFBpY2sgPSBfcmVuZGVyV2ViR0wuY3JlYXRlVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgIFJlbmRlcldlYkdMUGlja2luZy50ZXhEZXB0aCA9IF9yZW5kZXJXZWJHTC5jcmVhdGVUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKTtcclxuXHJcbiAgICAgIGNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFJlbmRlcldlYkdMUGlja2luZy5mYm9QaWNrKTtcclxuICAgICAgY3JjMy5mcmFtZWJ1ZmZlclRleHR1cmUyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNPTE9SX0FUVEFDSE1FTlQwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFJlbmRlcldlYkdMUGlja2luZy50ZXhQaWNrLCAwKTtcclxuICAgICAgY3JjMy5mcmFtZWJ1ZmZlclRleHR1cmUyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX0FUVEFDSE1FTlQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0xQaWNraW5nLnRleERlcHRoLCAwKTtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMUGlja2luZy5yZXNpemUoX3JlbmRlcldlYkdMLCAxMCk7IC8vIGluaXRpYWwgc2l6ZVxyXG5cclxuICAgICAgY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHdpdGggYSB7QGxpbmsgUGlja2VyfS1jYW1lcmEsIHRoaXMgbWV0aG9kIHJlbmRlcnMgb25lIHBpeGVsIHdpdGggcGlja2luZyBpbmZvcm1hdGlvbiBcclxuICAgICAqIGZvciBlYWNoIHBpY2thYmxlIG9iamVjdCBpbiB0aGUgbGluZSBvZiBzaWdodCBhbmQgcmV0dXJucyB0aGF0IGFzIGFuIHVuc29ydGVkIGFycmF5IG9mIHtAbGluayBQaWNrfXMuXHJcbiAgICAgKiBUaGUgZnVuY3Rpb24gdG8gcmVuZGVyIHRoZSBvYmplY3RzIGludG8gdGhlIHBpY2sgYnVmZmVyIG11c3QgYmUgcHJvdmlkZWQgYnkgdGhlIGNhbGxlci5cclxuICAgICAqIEBwYXJhbSBfcGljayBUaGUgZnVuY3Rpb24gd2hpY2ggcmVuZGVycyBvYmplY3RzIGludG8gdGhlIHBpY2sgYnVmZmVyLiBSZXR1cm5zIGEge0BsaW5rIFBpY2t9IGZvciBlYWNoIHJlbmRlcmVkIG9iamVjdC4gXHJcbiAgICAgKiAqKk1VU1QqKiB1c2Uge0BsaW5rIFNoYWRlclBpY2t9IG9yIHtAbGluayBTaGFkZXJQaWNrVGV4dHVyZWR9IHRvIHJlbmRlciBvYmplY3RzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHBpY2tGcm9tPFQ+KF9mcm9tOiByZWFkb25seSBUW10sIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX3BpY2s6IChfZnJvbTogcmVhZG9ubHkgVFtdLCBfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEpID0+IFBpY2tbXSk6IFBpY2tbXSB7IC8vIFRPRE86IHNlZSBpZiB0aGlyZCBwYXJhbWV0ZXIgX3dvcmxkPzogTWF0cml4NHg0IHdvdWxkIGJlIHVzZWZ1bGxcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHJcbiAgICAgIC8vIGFkanVzdCBidWZmZXIgc2l6ZVxyXG4gICAgICBjb25zdCBzaXplOiBudW1iZXIgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KF9mcm9tLmxlbmd0aCkpO1xyXG4gICAgICBpZiAoc2l6ZSA+IFJlbmRlcldlYkdMUGlja2luZy4jc2l6ZU1heClcclxuICAgICAgICBSZW5kZXJXZWJHTFBpY2tpbmcucmVzaXplKFJlbmRlcldlYkdMLCBzaXplKTtcclxuXHJcbiAgICAgIGNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFJlbmRlcldlYkdMUGlja2luZy5mYm9QaWNrKTtcclxuICAgICAgY3JjMy52aWV3cG9ydCgwLCAwLCBzaXplLCBzaXplKTtcclxuXHJcbiAgICAgIC8vIGNsZWFyIGJ1ZmZlclxyXG4gICAgICBjcmMzLmNsZWFyQnVmZmVyaXYoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUiwgMCwgUmVuZGVyV2ViR0xQaWNraW5nLiNkYXRhQ2xlYXJDb2xvcik7XHJcbiAgICAgIGNyYzMuY2xlYXJCdWZmZXJmaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX1NURU5DSUwsIDAsIDEsIDApO1xyXG5cclxuICAgICAgUmVuZGVyV2ViR0xDb21wb25lbnRDYW1lcmEudXNlUmVuZGVyYnVmZmVyKF9jbXBDYW1lcmEpO1xyXG5cclxuICAgICAgLy8gYnVmZmVyIHNpemUgaW50byBwaWNrIHNoYWRlcnNcclxuICAgICAgU2hhZGVyUGljay51c2VQcm9ncmFtKCk7XHJcbiAgICAgIGNyYzMudW5pZm9ybTFpKFNoYWRlclBpY2sudW5pZm9ybXNbXCJ1X3NpemVcIl0sIHNpemUpO1xyXG5cclxuICAgICAgU2hhZGVyUGlja1RleHR1cmVkLnVzZVByb2dyYW0oKTtcclxuICAgICAgY3JjMy51bmlmb3JtMWkoU2hhZGVyUGlja1RleHR1cmVkLnVuaWZvcm1zW1widV9zaXplXCJdLCBzaXplKTtcclxuXHJcbiAgICAgIC8vIHJlbmRlciBwaWNrcyBpbnRvIHBpY2sgYnVmZmVyXHJcbiAgICAgIFJlbmRlcldlYkdMLnNldEJsZW5kTW9kZShCTEVORC5PUEFRVUUpO1xyXG4gICAgICBjb25zdCBwaWNrczogUGlja1tdID0gX3BpY2soX2Zyb20sIF9jbXBDYW1lcmEpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5zZXRCbGVuZE1vZGUoQkxFTkQuVFJBTlNQQVJFTlQpO1xyXG5cclxuICAgICAgLy8gZ2V0L2ZpbHRlciBwaWNrc1xyXG4gICAgICAvLyBldmFsdWF0ZSB0ZXh0dXJlIGJ5IHJlYWRpbmcgcGl4ZWxzIGFuZCBleHRyYWN0LCBjb252ZXJ0IGFuZCBzdG9yZSB0aGUgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBtZXNoIGhpdFxyXG4gICAgICBjb25zdCBkYXRhOiBJbnQzMkFycmF5ID0gUmVuZGVyV2ViR0xQaWNraW5nLiNkYXRhO1xyXG4gICAgICBjcmMzLnJlYWRQaXhlbHMoMCwgMCwgc2l6ZSwgc2l6ZSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBX0lOVEVHRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuSU5ULCBkYXRhKTtcclxuXHJcbiAgICAgIGNvbnN0IHBpY2tlZDogUGlja1tdID0gW107XHJcbiAgICAgIGNvbnN0IG10eFZpZXdUb1dvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSU5WRVJTRShfY21wQ2FtZXJhLm10eFdvcmxkVG9WaWV3KTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHBpY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHpCdWZmZXI6IG51bWJlciA9IGRhdGFbNCAqIGkgKyAwXSArIGRhdGFbNCAqIGkgKyAxXSAvIDI1NjtcclxuICAgICAgICBpZiAoekJ1ZmZlciA9PSAwKSAvLyBkaXNjYXJkIG1pc3NlcyBcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGxldCBwaWNrOiBQaWNrID0gcGlja3NbaV07XHJcbiAgICAgICAgcGljay56QnVmZmVyID0gUmVuZGVyV2ViR0xQaWNraW5nLmNvbnZlcnRJbnQzMnRvRmxvYXQzMihkYXRhLCA0ICogaSArIDApICogMiAtIDE7XHJcbiAgICAgICAgcGljay5jb2xvciA9IFJlbmRlcldlYkdMUGlja2luZy5jb252ZXJ0SW50MzJ0b0NvbG9yKGRhdGEsIDQgKiBpICsgMSk7XHJcbiAgICAgICAgcGljay50ZXh0dXJlVVYgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IyKTtcclxuICAgICAgICBwaWNrLnRleHR1cmVVVi5zZXQoUmVuZGVyV2ViR0xQaWNraW5nLmNvbnZlcnRJbnQzMnRvRmxvYXQzMihkYXRhLCA0ICogaSArIDIpLCBSZW5kZXJXZWJHTFBpY2tpbmcuY29udmVydEludDMydG9GbG9hdDMyKGRhdGEsIDQgKiBpICsgMykpO1xyXG4gICAgICAgIHBpY2subXR4Vmlld1RvV29ybGQgPSBtdHhWaWV3VG9Xb3JsZDtcclxuXHJcbiAgICAgICAgcGlja2VkLnB1c2gocGljayk7XHJcbiAgICAgIH1cclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4Vmlld1RvV29ybGQpO1xyXG5cclxuICAgICAgLy8gcmVzZXRcclxuICAgICAgUmVuZGVyV2ViR0wucmVzZXRGcmFtZWJ1ZmZlcigpO1xyXG4gICAgICBjb25zdCBjYW52YXNSZWN0YW5nbGU6IFJlY3RhbmdsZSA9IFJlbmRlcldlYkdMLmdldENhbnZhc1JlY3RhbmdsZSgpO1xyXG4gICAgICBjcmMzLnZpZXdwb3J0KDAsIDAsIGNhbnZhc1JlY3RhbmdsZS53aWR0aCwgY2FudmFzUmVjdGFuZ2xlLmhlaWdodCk7XHJcblxyXG4gICAgICByZXR1cm4gcGlja2VkO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGNvbnZlcnRJbnQzMnRvRmxvYXQzMihfaW50MzJBcnJheTogSW50MzJBcnJheSwgX2luZGV4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICBsZXQgYnVmZmVyOiBBcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcclxuICAgICAgbGV0IHZpZXc6IERhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XHJcbiAgICAgIHZpZXcuc2V0SW50MzIoMCwgX2ludDMyQXJyYXlbX2luZGV4XSk7XHJcbiAgICAgIHJldHVybiB2aWV3LmdldEZsb2F0MzIoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY29udmVydEludDMydG9Db2xvcihfaW50MzJBcnJheTogSW50MzJBcnJheSwgX2luZGV4OiBudW1iZXIpOiBDb2xvciB7XHJcbiAgICAgIGxldCBidWZmZXI6IEFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpO1xyXG4gICAgICBsZXQgdmlldzogRGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcclxuICAgICAgdmlldy5zZXRJbnQzMigwLCBfaW50MzJBcnJheVtfaW5kZXhdKTtcclxuICAgICAgbGV0IGNvbG9yOiBDb2xvciA9IENvbG9yLkNTUyhgcmdiKCR7dmlldy5nZXRVaW50OCgwKX0sICR7dmlldy5nZXRVaW50OCgxKX0sICR7dmlldy5nZXRVaW50OCgyKX0pYCwgdmlldy5nZXRVaW50OCgzKSAvIDI1NSk7XHJcbiAgICAgIHJldHVybiBjb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyByZXNpemUoX3JlbmRlcldlYkdMOiB0eXBlb2YgUmVuZGVyV2ViR0wsIF9zaXplOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IF9yZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTFBpY2tpbmcuI3NpemVNYXggPSBfc2l6ZTtcclxuICAgICAgUmVuZGVyV2ViR0xQaWNraW5nLiNkYXRhID0gbmV3IEludDMyQXJyYXkoX3NpemUgKiBfc2l6ZSAqIDQpO1xyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0xQaWNraW5nLnRleFBpY2spO1xyXG4gICAgICBjcmMzLnRleEltYWdlMkQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEzMkksIF9zaXplLCBfc2l6ZSwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBX0lOVEVHRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuSU5ULCBudWxsKTsgLy8gY291bGQgdXNlIFJCR0EzMkYgaW4gdGhlIGZ1dHVyZSBlLmcuIFdlYkdQVVxyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0xQaWNraW5nLnRleERlcHRoKTtcclxuICAgICAgY3JjMy50ZXhJbWFnZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9DT01QT05FTlQyNCwgX3NpemUsIF9zaXplLCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX0NPTVBPTkVOVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9JTlQsIG51bGwpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBNYW5hZ2VzIHtAbGluayBDb21wb25lbnRMaWdodH0gZGF0YSB0byBiZSB0cmFuc21pdHRlZCBkdXJpbmcgcmVuZGVyaW5nLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0IHtcclxuICAgIHN0YXRpYyAjYnVmZmVyOiBXZWJHTEJ1ZmZlcjtcclxuICAgIHN0YXRpYyAjZGF0YTogRmxvYXQzMkFycmF5O1xyXG5cclxuICAgIHN0YXRpYyAjZGF0YUhlYWRlcjogVWludDMyQXJyYXk7XHJcbiAgICBzdGF0aWMgI2RhdGFBbWJpZW50OiBGbG9hdDMyQXJyYXk7XHJcbiAgICBzdGF0aWMgI2RhdGFQb2ludDogRmxvYXQzMkFycmF5O1xyXG4gICAgc3RhdGljICNkYXRhU3BvdDogRmxvYXQzMkFycmF5O1xyXG4gICAgc3RhdGljICNkYXRhRGlyZWN0aW9uYWw6IEZsb2F0MzJBcnJheTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgdGhlIGxpZ2h0IHVuaWZvcm0gYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGluaXRpYWxpemUoX3JlbmRlcldlYkdMOiB0eXBlb2YgUmVuZGVyV2ViR0wpOiB2b2lkIHtcclxuICAgICAgY29uc3QgTUFYX0xJR0hUU19ESVJFQ1RJT05BTDogbnVtYmVyID0gMTU7XHJcbiAgICAgIGNvbnN0IE1BWF9MSUdIVFNfUE9JTlQ6IG51bWJlciA9IDEwMDtcclxuICAgICAgY29uc3QgTUFYX0xJR0hUU19TUE9UOiBudW1iZXIgPSAxMDA7XHJcblxyXG4gICAgICBjb25zdCBIRUFERVJfVUlOVFM6IG51bWJlciA9IDQ7XHJcbiAgICAgIGNvbnN0IENPTE9SX0ZMT0FUUzogbnVtYmVyID0gNDtcclxuICAgICAgY29uc3QgTUFUUklYX0ZMT0FUUzogbnVtYmVyID0gMTY7XHJcbiAgICAgIGNvbnN0IExJR0hUX0ZMT0FUUzogbnVtYmVyID0gQ09MT1JfRkxPQVRTICsgTUFUUklYX0ZMT0FUUyArIE1BVFJJWF9GTE9BVFM7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LiNkYXRhID0gbmV3IEZsb2F0MzJBcnJheShIRUFERVJfVUlOVFMgKyBDT0xPUl9GTE9BVFMgKyAoTUFYX0xJR0hUU19ESVJFQ1RJT05BTCArIE1BWF9MSUdIVFNfUE9JTlQgKyBNQVhfTElHSFRTX1NQT1QpICogTElHSFRfRkxPQVRTKTtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50TGlnaHQuI2RhdGFIZWFkZXIgPSBuZXcgVWludDMyQXJyYXkoUmVuZGVyV2ViR0xDb21wb25lbnRMaWdodC4jZGF0YS5idWZmZXIsIDAsIEhFQURFUl9VSU5UUyk7XHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50TGlnaHQuI2RhdGFBbWJpZW50ID0gbmV3IEZsb2F0MzJBcnJheShSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LiNkYXRhLmJ1ZmZlciwgUmVuZGVyV2ViR0xDb21wb25lbnRMaWdodC4jZGF0YUhlYWRlci5ieXRlT2Zmc2V0ICsgUmVuZGVyV2ViR0xDb21wb25lbnRMaWdodC4jZGF0YUhlYWRlci5ieXRlTGVuZ3RoLCBDT0xPUl9GTE9BVFMpOyAvLyBhbWJpZW50IGxpZ2h0IGNvbG9yXHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50TGlnaHQuI2RhdGFEaXJlY3Rpb25hbCA9IG5ldyBGbG9hdDMyQXJyYXkoUmVuZGVyV2ViR0xDb21wb25lbnRMaWdodC4jZGF0YS5idWZmZXIsIFJlbmRlcldlYkdMQ29tcG9uZW50TGlnaHQuI2RhdGFBbWJpZW50LmJ5dGVPZmZzZXQgKyBSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LiNkYXRhQW1iaWVudC5ieXRlTGVuZ3RoLCBNQVhfTElHSFRTX0RJUkVDVElPTkFMICogTElHSFRfRkxPQVRTKTtcclxuICAgICAgUmVuZGVyV2ViR0xDb21wb25lbnRMaWdodC4jZGF0YVBvaW50ID0gbmV3IEZsb2F0MzJBcnJheShSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LiNkYXRhLmJ1ZmZlciwgUmVuZGVyV2ViR0xDb21wb25lbnRMaWdodC4jZGF0YURpcmVjdGlvbmFsLmJ5dGVPZmZzZXQgKyBSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LiNkYXRhRGlyZWN0aW9uYWwuYnl0ZUxlbmd0aCwgTUFYX0xJR0hUU19QT0lOVCAqIExJR0hUX0ZMT0FUUyk7XHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50TGlnaHQuI2RhdGFTcG90ID0gbmV3IEZsb2F0MzJBcnJheShSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LiNkYXRhLmJ1ZmZlciwgUmVuZGVyV2ViR0xDb21wb25lbnRMaWdodC4jZGF0YVBvaW50LmJ5dGVPZmZzZXQgKyBSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LiNkYXRhUG9pbnQuYnl0ZUxlbmd0aCwgTUFYX0xJR0hUU19TUE9UICogTElHSFRfRkxPQVRTKTtcclxuXHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBfcmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LiNidWZmZXIgPSBfcmVuZGVyV2ViR0wuYXNzZXJ0KGNyYzMuY3JlYXRlQnVmZmVyKCkpO1xyXG5cclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIFJlbmRlcldlYkdMQ29tcG9uZW50TGlnaHQuI2J1ZmZlcik7XHJcbiAgICAgIGNyYzMuYnVmZmVyRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCBSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LiNkYXRhLmJ5dGVMZW5ndGgsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFlOQU1JQ19EUkFXKTtcclxuICAgICAgY3JjMy5iaW5kQnVmZmVyQmFzZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCBVTklGT1JNX0JMT0NLLkxJR0hUUy5CSU5ESU5HLCBSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LiNidWZmZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXBsYWNlcyB0aGUgZGVjb3JhdGVkIG1ldGhvZCB3aXRoIHRoZSBtYW5hZ2Vy4oCZcyBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc2FtZSBuYW1lLiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWNvcmF0ZTxNIGV4dGVuZHMgKHRoaXM6IHR5cGVvZiBDb21wb25lbnRMaWdodCwgLi4uYXJnczogR2VuZXJhbCkgPT4gR2VuZXJhbD4oX21ldGhvZDogTSwgX2NvbnRleHQ6IENsYXNzTWV0aG9kRGVjb3JhdG9yQ29udGV4dDx0eXBlb2YgQ29tcG9uZW50TGlnaHQsIE0+KTogTSB7XHJcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0aGlzLCBfY29udGV4dC5uYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1ZmZlciB0aGUgbGlnaHQgZGF0YSB0byB0aGUgdW5pZm9ybSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgdXBkYXRlUmVuZGVyYnVmZmVyKHRoaXM6IHR5cGVvZiBDb21wb25lbnRMaWdodCwgX2xpZ2h0czogTWFwTGlnaHRUeXBlVG9MaWdodExpc3QpOiB2b2lkIHtcclxuICAgICAgLy8gZmlsbCB0aGUgYnVmZmVyIHdpdGggdGhlIGFtYmllbnQgbGlnaHQgY29sb3JcclxuICAgICAgbGV0IGNtcExpZ2h0czogUmVjeWNhYmxlQXJyYXk8Q29tcG9uZW50TGlnaHQ+ID0gX2xpZ2h0cy5nZXQoTElHSFRfVFlQRS5BTUJJRU5UKTtcclxuICAgICAgaWYgKGNtcExpZ2h0cz8ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGxldCBjbHJTdW06IENvbG9yID0gUmVjeWNsZXIuZ2V0KENvbG9yKS5zZXQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgbGV0IGNsckxpZ2h0OiBDb2xvciA9IFJlY3ljbGVyLmdldChDb2xvcik7XHJcbiAgICAgICAgZm9yIChsZXQgY21wTGlnaHQgb2YgY21wTGlnaHRzKVxyXG4gICAgICAgICAgY2xyU3VtLmFkZChDb2xvci5TQ0FMRShjbXBMaWdodC5jb2xvciwgY21wTGlnaHQuaW50ZW5zaXR5LCBjbHJMaWdodCkpO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKGNsclN1bSk7XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUoY2xyTGlnaHQpO1xyXG4gICAgICAgIGNsclN1bS50b0FycmF5KFJlbmRlcldlYkdMQ29tcG9uZW50TGlnaHQuI2RhdGFBbWJpZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgY21wTGlnaHRzRGlyZWN0aW9uYWw6IFJlY3ljYWJsZUFycmF5PENvbXBvbmVudExpZ2h0PiA9IF9saWdodHMuZ2V0KExJR0hUX1RZUEUuRElSRUNUSU9OQUwpO1xyXG4gICAgICBjb25zdCBjbXBMaWdodHNQb2ludDogUmVjeWNhYmxlQXJyYXk8Q29tcG9uZW50TGlnaHQ+ID0gX2xpZ2h0cy5nZXQoTElHSFRfVFlQRS5QT0lOVCk7XHJcbiAgICAgIGNvbnN0IGNtcExpZ2h0c1Nwb3Q6IFJlY3ljYWJsZUFycmF5PENvbXBvbmVudExpZ2h0PiA9IF9saWdodHMuZ2V0KExJR0hUX1RZUEUuU1BPVCk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LiNkYXRhSGVhZGVyWzBdID0gY21wTGlnaHRzRGlyZWN0aW9uYWw/Lmxlbmd0aCA/PyAwO1xyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LiNkYXRhSGVhZGVyWzFdID0gY21wTGlnaHRzUG9pbnQ/Lmxlbmd0aCA/PyAwO1xyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LiNkYXRhSGVhZGVyWzJdID0gY21wTGlnaHRzU3BvdD8ubGVuZ3RoID8/IDA7XHJcblxyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgUmVuZGVyV2ViR0xDb21wb25lbnRMaWdodC4jYnVmZmVyKTtcclxuICAgICAgY3JjMy5idWZmZXJTdWJEYXRhKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIDAsIFJlbmRlcldlYkdMQ29tcG9uZW50TGlnaHQuI2RhdGEsIDAsIFJlbmRlcldlYkdMQ29tcG9uZW50TGlnaHQuI2RhdGFIZWFkZXIubGVuZ3RoICsgUmVuZGVyV2ViR0xDb21wb25lbnRMaWdodC4jZGF0YUFtYmllbnQubGVuZ3RoKTsgLy8gaGVhZGVyICsgYW1iaWVudCBjb2xvclxyXG5cclxuICAgICAgY29uc3QgY2xyT3V0OiBDb2xvciA9IFJlY3ljbGVyLmdldChDb2xvcik7IC8vIHN0b3JlcyBpbnRlcm1lZGlhdGUgY29sb3JcclxuICAgICAgY29uc3QgbXR4T3V0OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTsgLy8gc3RvcmVzIGludGVybWVkaWF0ZSBtYXRyaXhcclxuICAgICAgUmVuZGVyV2ViR0xDb21wb25lbnRMaWdodC5idWZmZXJMaWdodHMoY3JjMywgY21wTGlnaHRzRGlyZWN0aW9uYWwsIFJlbmRlcldlYkdMQ29tcG9uZW50TGlnaHQuI2RhdGFEaXJlY3Rpb25hbCwgY2xyT3V0LCBtdHhPdXQpO1xyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LmJ1ZmZlckxpZ2h0cyhjcmMzLCBjbXBMaWdodHNQb2ludCwgUmVuZGVyV2ViR0xDb21wb25lbnRMaWdodC4jZGF0YVBvaW50LCBjbHJPdXQsIG10eE91dCk7XHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50TGlnaHQuYnVmZmVyTGlnaHRzKGNyYzMsIGNtcExpZ2h0c1Nwb3QsIFJlbmRlcldlYkdMQ29tcG9uZW50TGlnaHQuI2RhdGFTcG90LCBjbHJPdXQsIG10eE91dCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKGNsck91dCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eE91dCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgYnVmZmVyTGlnaHRzKF9jcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LCBfY21wTGlnaHRzOiBSZWN5Y2FibGVBcnJheTxDb21wb25lbnRMaWdodD4sIF9kYXRhOiBGbG9hdDMyQXJyYXksIF9jbHJPdXQ6IENvbG9yLCBfbXR4T3V0OiBNYXRyaXg0eDQpOiB2b2lkIHtcclxuICAgICAgaWYgKCFfY21wTGlnaHRzKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBpTGlnaHQ6IG51bWJlciA9IDA7XHJcbiAgICAgIGZvciAobGV0IGNtcExpZ2h0IG9mIF9jbXBMaWdodHMpIHtcclxuICAgICAgICAvLyBzZXQgdmN0Q29sb3JcclxuICAgICAgICBDb2xvci5TQ0FMRShjbXBMaWdodC5jb2xvciwgY21wTGlnaHQuaW50ZW5zaXR5LCBfY2xyT3V0KS50b0FycmF5KF9kYXRhLCBpTGlnaHQpO1xyXG5cclxuICAgICAgICAvLyBzZXQgbXR4U2hhcGVcclxuICAgICAgICBNYXRyaXg0eDQuUFJPRFVDVChjbXBMaWdodC5ub2RlLm10eFdvcmxkLCBjbXBMaWdodC5tdHhQaXZvdCwgX210eE91dCk7XHJcbiAgICAgICAgaWYgKGNtcExpZ2h0LmxpZ2h0VHlwZSA9PSBMSUdIVF9UWVBFLkRJUkVDVElPTkFMKVxyXG4gICAgICAgICAgX210eE91dC50cmFuc2xhdGlvbiA9IF9tdHhPdXQudHJhbnNsYXRpb24uc2V0KDAsIDAsIDApO1xyXG4gICAgICAgIF9tdHhPdXQudG9BcnJheShfZGF0YSwgaUxpZ2h0ICsgNCk7XHJcblxyXG4gICAgICAgIC8vIHNldCBtdHhTaGFwZUludmVyc2VcclxuICAgICAgICBpZiAoY21wTGlnaHQubGlnaHRUeXBlICE9IExJR0hUX1RZUEUuRElSRUNUSU9OQUwpXHJcbiAgICAgICAgICBNYXRyaXg0eDQuSU5WRVJTRShfbXR4T3V0LCBfbXR4T3V0KS50b0FycmF5KF9kYXRhLCBpTGlnaHQgKyAyMCk7XHJcblxyXG4gICAgICAgIGlMaWdodCArPSAzNjtcclxuICAgICAgfVxyXG5cclxuICAgICAgX2NyYzMuYnVmZmVyU3ViRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCBfZGF0YS5ieXRlT2Zmc2V0LCBfZGF0YSwgMCwgaUxpZ2h0KTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogTWFuYWdlcyB7QGxpbmsgQ29tcG9uZW50Rm9nfSBkYXRhIHRvIGJlIHRyYW5zbWl0dGVkIGR1cmluZyByZW5kZXJpbmcuXHJcbiAgICogQGludGVybmFsXHJcbiAgICogQGF1dGhvcnMgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDI1XHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlbmRlcldlYkdMQ29tcG9uZW50Rm9nIHtcclxuICAgIHN0YXRpYyAjYnVmZmVyOiBXZWJHTEJ1ZmZlcjtcclxuICAgIHN0YXRpYyAjZGF0YTogRmxvYXQzMkFycmF5O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgZm9nIHVuaWZvcm0gYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGluaXRpYWxpemUoX3JlbmRlcldlYkdMOiB0eXBlb2YgUmVuZGVyV2ViR0wpOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IF9yZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudEZvZy4jYnVmZmVyID0gX3JlbmRlcldlYkdMLmFzc2VydChjcmMzLmNyZWF0ZUJ1ZmZlcigpKTtcclxuICAgICAgUmVuZGVyV2ViR0xDb21wb25lbnRGb2cuI2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDgpO1xyXG5cclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIFJlbmRlcldlYkdMQ29tcG9uZW50Rm9nLiNidWZmZXIpO1xyXG4gICAgICBjcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgUmVuZGVyV2ViR0xDb21wb25lbnRGb2cuI2RhdGEuYnl0ZUxlbmd0aCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5EWU5BTUlDX0RSQVcpO1xyXG4gICAgICBjcmMzLmJpbmRCdWZmZXJCYXNlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIFVOSUZPUk1fQkxPQ0suRk9HLkJJTkRJTkcsIFJlbmRlcldlYkdMQ29tcG9uZW50Rm9nLiNidWZmZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVmZmVyIHRoZSBmb2cgZGF0YSB0byB0aGUgdW5pZm9ybSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgdXNlUmVuZGVyYnVmZmVyKF9jbXBGb2c6IENvbXBvbmVudEZvZyk6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjb25zdCBkYXRhOiBGbG9hdDMyQXJyYXkgPSBSZW5kZXJXZWJHTENvbXBvbmVudEZvZy4jZGF0YTtcclxuXHJcbiAgICAgIGRhdGFbMF0gPSBfY21wRm9nPy5pc0FjdGl2ZSA/IDEgOiAwO1xyXG4gICAgICBpZiAoX2NtcEZvZykge1xyXG4gICAgICAgIGRhdGFbMV0gPSBfY21wRm9nLm5lYXI7XHJcbiAgICAgICAgZGF0YVsyXSA9IF9jbXBGb2cuZmFyO1xyXG4gICAgICAgIGRhdGEuc2V0KF9jbXBGb2cuY29sb3IuZ2V0KCksIDQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgUmVuZGVyV2ViR0xDb21wb25lbnRGb2cuI2J1ZmZlcik7XHJcbiAgICAgIGNyYzMuYnVmZmVyU3ViRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCAwLCBSZW5kZXJXZWJHTENvbXBvbmVudEZvZy4jZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBNYW5hZ2VzIHtAbGluayBDb21wb25lbnRDYW1lcmF9IGRhdGEgdG8gYmUgdHJhbnNtaXR0ZWQgZHVyaW5nIHJlbmRlcmluZy5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAYXV0aG9ycyBKb25hcyBQbG90emt5LCBIRlUsIDIwMjVcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyV2ViR0xDb21wb25lbnRDYW1lcmEge1xyXG4gICAgc3RhdGljICNidWZmZXI6IFdlYkdMQnVmZmVyO1xyXG4gICAgc3RhdGljICNkYXRhOiBGbG9hdDMyQXJyYXk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIHRoZSBjYW1lcmEgdW5pZm9ybSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaW5pdGlhbGl6ZShfcmVuZGVyV2ViR0w6IHR5cGVvZiBSZW5kZXJXZWJHTCk6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gX3JlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50Q2FtZXJhLiNidWZmZXIgPSBfcmVuZGVyV2ViR0wuYXNzZXJ0KGNyYzMuY3JlYXRlQnVmZmVyKCkpO1xyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudENhbWVyYS4jZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMTYgKyAxNiArIDE2ICsgMyk7XHJcblxyXG4gICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgUmVuZGVyV2ViR0xDb21wb25lbnRDYW1lcmEuI2J1ZmZlcik7XHJcbiAgICAgIGNyYzMuYnVmZmVyRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCBSZW5kZXJXZWJHTENvbXBvbmVudENhbWVyYS4jZGF0YS5ieXRlTGVuZ3RoLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRZTkFNSUNfRFJBVyk7XHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlckJhc2UoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgVU5JRk9STV9CTE9DSy5DQU1FUkEuQklORElORywgUmVuZGVyV2ViR0xDb21wb25lbnRDYW1lcmEuI2J1ZmZlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWZmZXIgdGhlIGNhbWVyYSBkYXRhIHRvIHRoZSB1bmlmb3JtIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyB1c2VSZW5kZXJidWZmZXIoX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGNvbnN0IGRhdGE6IEZsb2F0MzJBcnJheSA9IFJlbmRlcldlYkdMQ29tcG9uZW50Q2FtZXJhLiNkYXRhO1xyXG5cclxuICAgICAgY29uc3QgbXR4VmlldzogTWF0cml4NHg0ID0gX2NtcENhbWVyYS5tdHhDYW1lcmFJbnZlcnNlO1xyXG4gICAgICBjb25zdCBtdHhQcm9qZWN0aW9uOiBNYXRyaXg0eDQgPSBfY21wQ2FtZXJhLm10eFByb2plY3Rpb247XHJcbiAgICAgIGNvbnN0IG10eFZpZXdQcm9qZWN0aW9uOiBNYXRyaXg0eDQgPSBfY21wQ2FtZXJhLm10eFdvcmxkVG9WaWV3O1xyXG4gICAgICBjb25zdCB2Y3RQb3NpdGlvbjogVmVjdG9yMyA9IF9jbXBDYW1lcmEubXR4V29ybGQudHJhbnNsYXRpb247XHJcblxyXG4gICAgICBkYXRhLnNldChtdHhWaWV3LmdldEFycmF5KCksIDApO1xyXG4gICAgICBkYXRhLnNldChtdHhQcm9qZWN0aW9uLmdldEFycmF5KCksIDE2KTtcclxuICAgICAgZGF0YS5zZXQobXR4Vmlld1Byb2plY3Rpb24uZ2V0QXJyYXkoKSwgMzIpO1xyXG4gICAgICB2Y3RQb3NpdGlvbi50b0FycmF5KGRhdGEsIDQ4KTtcclxuXHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCBSZW5kZXJXZWJHTENvbXBvbmVudENhbWVyYS4jYnVmZmVyKTtcclxuICAgICAgY3JjMy5idWZmZXJTdWJEYXRhKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIDAsIFJlbmRlcldlYkdMQ29tcG9uZW50Q2FtZXJhLiNkYXRhKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIENvbXBvbmVudEFtYmllbnRPY2NsdXNpb24gYW1iaWVudCBvY2NsdXNpb259IHBvc3QtcHJvY2Vzc2luZyBlZmZlY3QuXHJcbiAgICogQGludGVybmFsXHJcbiAgICogQGF1dGhvcnMgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDI1XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFJlbmRlcldlYkdMQ29tcG9uZW50QW1iaWVudE9jY2x1c2lvbiB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHNzYW9TdXBwb3J0OiBib29sZWFuOyAvLyBUT0RPOlxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZmJvT3V0OiBXZWJHTEZyYW1lYnVmZmVyO1xyXG4gICAgcHVibGljIHN0YXRpYyB0ZXhPdXQ6IFdlYkdMVGV4dHVyZTtcclxuICAgIHB1YmxpYyBzdGF0aWMgdGV4Tm9pc2U6IFdlYkdMVGV4dHVyZTsgLy8gc3RvcmVzIHJhbmRvbSB2YWx1ZXMgZm9yIGVhY2ggcGl4ZWxcclxuXHJcbiAgICBzdGF0aWMgI2RhdGFDYW1lcmE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogSW5pdGlhbGl6ZSBmcmFtZWJ1ZmZlcnMgYW5kIHJlbmRlciBhdHRhY2htZW50cy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpbml0aWFsaXplKF9yZW5kZXJXZWJHTDogdHlwZW9mIFJlbmRlcldlYkdMKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBfcmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG5cclxuICAgICAgUmVuZGVyV2ViR0xDb21wb25lbnRBbWJpZW50T2NjbHVzaW9uLnRleE91dCA9IF9yZW5kZXJXZWJHTC50ZXhDb2xvcjtcclxuICAgICAgUmVuZGVyV2ViR0xDb21wb25lbnRBbWJpZW50T2NjbHVzaW9uLnRleE5vaXNlID0gX3JlbmRlcldlYkdMLmNyZWF0ZVRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNULCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNMQU1QX1RPX0VER0UpO1xyXG5cclxuICAgICAgUmVuZGVyV2ViR0xDb21wb25lbnRBbWJpZW50T2NjbHVzaW9uLmZib091dCA9IF9yZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xGcmFtZWJ1ZmZlcj4oY3JjMy5jcmVhdGVGcmFtZWJ1ZmZlcigpKTtcclxuICAgICAgY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgUmVuZGVyV2ViR0xDb21wb25lbnRBbWJpZW50T2NjbHVzaW9uLmZib091dCk7XHJcbiAgICAgIGNyYzMuZnJhbWVidWZmZXJUZXh0dXJlMkQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9BVFRBQ0hNRU5UMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBSZW5kZXJXZWJHTENvbXBvbmVudEFtYmllbnRPY2NsdXNpb24udGV4T3V0LCAwKTtcclxuICAgICAgY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoZSBhbWJpZW50IG9jY2x1c2lvbiBlZmZlY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhdyhfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEsIF9jbXBBbWJpZW50T2NjbHVzaW9uOiBDb21wb25lbnRBbWJpZW50T2NjbHVzaW9uKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIFNoYWRlckFtYmllbnRPY2NsdXNpb24udXNlUHJvZ3JhbSgpO1xyXG5cclxuICAgICAgUmVuZGVyV2ViR0wuYmluZFRleHR1cmUoU2hhZGVyQW1iaWVudE9jY2x1c2lvbiwgUmVuZGVyV2ViR0wudGV4UG9zaXRpb24sIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTAsIFwidV90ZXhQb3NpdGlvblwiKTtcclxuICAgICAgUmVuZGVyV2ViR0wuYmluZFRleHR1cmUoU2hhZGVyQW1iaWVudE9jY2x1c2lvbiwgUmVuZGVyV2ViR0wudGV4Tm9ybWFsLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkUxLCBcInVfdGV4Tm9ybWFsXCIpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5iaW5kVGV4dHVyZShTaGFkZXJBbWJpZW50T2NjbHVzaW9uLCBSZW5kZXJXZWJHTENvbXBvbmVudEFtYmllbnRPY2NsdXNpb24udGV4Tm9pc2UsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTIsIFwidV90ZXhOb2lzZVwiKTtcclxuXHJcbiAgICAgIGNyYzMudW5pZm9ybTFmKFNoYWRlckFtYmllbnRPY2NsdXNpb24udW5pZm9ybXNbXCJ1X2ZOZWFyXCJdLCBfY21wQ2FtZXJhLm5lYXIpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0xZihTaGFkZXJBbWJpZW50T2NjbHVzaW9uLnVuaWZvcm1zW1widV9mRmFyXCJdLCBfY21wQ2FtZXJhLmZhcik7XHJcbiAgICAgIGNyYzMudW5pZm9ybTFmKFNoYWRlckFtYmllbnRPY2NsdXNpb24udW5pZm9ybXNbXCJ1X2ZCaWFzXCJdLCBfY21wQW1iaWVudE9jY2x1c2lvbi5iaWFzKTtcclxuICAgICAgY3JjMy51bmlmb3JtMWYoU2hhZGVyQW1iaWVudE9jY2x1c2lvbi51bmlmb3Jtc1tcInVfZlNhbXBsZVJhZGl1c1wiXSwgX2NtcEFtYmllbnRPY2NsdXNpb24uc2FtcGxlUmFkaXVzKTtcclxuICAgICAgY3JjMy51bmlmb3JtMWYoU2hhZGVyQW1iaWVudE9jY2x1c2lvbi51bmlmb3Jtc1tcInVfZkF0dGVudWF0aW9uQ29uc3RhbnRcIl0sIF9jbXBBbWJpZW50T2NjbHVzaW9uLmF0dGVudWF0aW9uQ29uc3RhbnQpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0xZihTaGFkZXJBbWJpZW50T2NjbHVzaW9uLnVuaWZvcm1zW1widV9mQXR0ZW51YXRpb25MaW5lYXJcIl0sIF9jbXBBbWJpZW50T2NjbHVzaW9uLmF0dGVudWF0aW9uTGluZWFyKTtcclxuICAgICAgY3JjMy51bmlmb3JtMWYoU2hhZGVyQW1iaWVudE9jY2x1c2lvbi51bmlmb3Jtc1tcInVfZkF0dGVudWF0aW9uUXVhZHJhdGljXCJdLCBfY21wQW1iaWVudE9jY2x1c2lvbi5hdHRlbnVhdGlvblF1YWRyYXRpYyk7XHJcbiAgICAgIGNyYzMudW5pZm9ybTJmKFNoYWRlckFtYmllbnRPY2NsdXNpb24udW5pZm9ybXNbXCJ1X3ZjdFJlc29sdXRpb25cIl0sIFJlbmRlcldlYkdMLmdldENhbnZhc1JlY3RhbmdsZSgpLndpZHRoLCBSZW5kZXJXZWJHTC5nZXRDYW52YXNSZWN0YW5nbGUoKS5oZWlnaHQpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0zZnYoU2hhZGVyQW1iaWVudE9jY2x1c2lvbi51bmlmb3Jtc1tcInVfdmN0Q2FtZXJhXCJdLCBfY21wQ2FtZXJhLm10eFdvcmxkLnRyYW5zbGF0aW9uLnRvQXJyYXkoUmVuZGVyV2ViR0xDb21wb25lbnRBbWJpZW50T2NjbHVzaW9uLiNkYXRhQ2FtZXJhKSk7XHJcblxyXG4gICAgICBjcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBSZW5kZXJXZWJHTENvbXBvbmVudEFtYmllbnRPY2NsdXNpb24uZmJvT3V0KTtcclxuICAgICAgUmVuZGVyV2ViR0wuc2V0QmxlbmRNb2RlKEJMRU5ELlNVQlRSQUNUSVZFKTtcclxuICAgICAgY3JjMy5kcmF3QXJyYXlzKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLCAwLCAzKTtcclxuICAgICAgUmVuZGVyV2ViR0wuc2V0QmxlbmRNb2RlKEJMRU5ELlRSQU5TUEFSRU5UKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBSZXNpemUgdGhlIHJlbmRlciBhdHRhY2htZW50cy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZXNpemUoX3JlbmRlcldlYkdMOiB0eXBlb2YgUmVuZGVyV2ViR0wsIF93aWR0aDogbnVtYmVyLCBfaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IF9yZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGNvbnN0IGNhbnZhc1dpZHRoOiBudW1iZXIgPSBfd2lkdGggfHwgMTtcclxuICAgICAgY29uc3QgY2FudmFzSGVpZ2h0OiBudW1iZXIgPSBfaGVpZ2h0IHx8IDE7XHJcblxyXG4gICAgICBjcmMzLmFjdGl2ZVRleHR1cmUoY3JjMy5URVhUVVJFMCk7XHJcblxyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0xDb21wb25lbnRBbWJpZW50T2NjbHVzaW9uLnRleE91dCk7XHJcbiAgICAgIGNyYzMudGV4SW1hZ2UyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQSwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0JZVEUsIG51bGwpO1xyXG5cclxuICAgICAgY29uc3QgblZhbHVlczogbnVtYmVyID0gY2FudmFzV2lkdGggKiBjYW52YXNIZWlnaHQgKiA0O1xyXG4gICAgICBjb25zdCBub2lzZURhdGE6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShuVmFsdWVzKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBuVmFsdWVzOyBpICs9IDQpIHtcclxuICAgICAgICBub2lzZURhdGFbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpO1xyXG4gICAgICAgIG5vaXNlRGF0YVtpICsgMV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpO1xyXG4gICAgICAgIG5vaXNlRGF0YVtpICsgMl0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpO1xyXG4gICAgICAgIG5vaXNlRGF0YVtpICsgM10gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKGNyYzMuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0xDb21wb25lbnRBbWJpZW50T2NjbHVzaW9uLnRleE5vaXNlKTtcclxuICAgICAgY3JjMy50ZXhJbWFnZTJEKGNyYzMuVEVYVFVSRV8yRCwgMCwgY3JjMy5SR0JBLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0LCAwLCBjcmMzLlJHQkEsIGNyYzMuVU5TSUdORURfQllURSwgbm9pc2VEYXRhKTtcclxuICAgICAgY3JjMy5iaW5kVGV4dHVyZShjcmMzLlRFWFRVUkVfMkQsIG51bGwpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIENvbXBvbmVudEJsb29tIGJsb29tfSBwb3N0LXByb2Nlc3NpbmcgZWZmZWN0LlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJXZWJHTENvbXBvbmVudEJsb29tIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgc3Nhb1N1cHBvcnQ6IGJvb2xlYW47IC8vIFRPRE86XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBmYm9PdXQ6IFdlYkdMRnJhbWVidWZmZXI7XHJcbiAgICBwdWJsaWMgc3RhdGljIHRleE91dDogV2ViR0xUZXh0dXJlO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZmJvczogV2ViR0xGcmFtZWJ1ZmZlcltdOyAvLyBzdG9yZXMgZG93bnNhbXBsZWQgRkJPcyBmb3IgZWFjaCBibG9vbSBsZXZlbFxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdGV4dHVyZXM6IFdlYkdMVGV4dHVyZVtdOyAvLyBzdG9yZXMgZG93biBhbmQgdXBzYW1wbGVkIHZlcnNpb25zIG9mIHRoZSBjb2xvciB0ZXh0dXJlLCB1c2VkIGZvciBibG9vbVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEluaXRpYWxpemUgZnJhbWVidWZmZXJzIGFuZCByZW5kZXIgYXR0YWNobWVudHMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaW5pdGlhbGl6ZShfcmVuZGVyV2ViR0w6IHR5cGVvZiBSZW5kZXJXZWJHTCk6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gX3JlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50Qmxvb20udGV4dHVyZXMgPSBuZXcgQXJyYXkoNik7XHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50Qmxvb20uZmJvcyA9IG5ldyBBcnJheSg2KTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IFJlbmRlcldlYkdMQ29tcG9uZW50Qmxvb20udGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBSZW5kZXJXZWJHTENvbXBvbmVudEJsb29tLnRleHR1cmVzW2ldID0gX3JlbmRlcldlYkdMLmNyZWF0ZVRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5MSU5FQVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgUmVuZGVyV2ViR0xDb21wb25lbnRCbG9vbS5mYm9zW2ldID0gX3JlbmRlcldlYkdMLmFzc2VydDxXZWJHTEZyYW1lYnVmZmVyPihjcmMzLmNyZWF0ZUZyYW1lYnVmZmVyKCkpO1xyXG4gICAgICAgIGNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFJlbmRlcldlYkdMQ29tcG9uZW50Qmxvb20uZmJvc1tpXSk7XHJcbiAgICAgICAgY3JjMy5mcmFtZWJ1ZmZlclRleHR1cmUyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNPTE9SX0FUVEFDSE1FTlQwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFJlbmRlcldlYkdMQ29tcG9uZW50Qmxvb20udGV4dHVyZXNbaV0sIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudEJsb29tLmZib091dCA9IF9yZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xGcmFtZWJ1ZmZlcj4oY3JjMy5jcmVhdGVGcmFtZWJ1ZmZlcigpKTtcclxuICAgICAgY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgUmVuZGVyV2ViR0xDb21wb25lbnRCbG9vbS5mYm9PdXQpO1xyXG4gICAgICBjcmMzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgX3JlbmRlcldlYkdMLnRleENvbG9yLCAwKTtcclxuICAgICAgY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoZSBibG9vbSBlZmZlY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhdyhfY21wQmxvb206IENvbXBvbmVudEJsb29tKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIFNoYWRlckJsb29tLnVzZVByb2dyYW0oKTtcclxuXHJcbiAgICAgIC8vIGV4dHJhY3QgYnJpZ2h0IGNvbG9ycywgY291bGQgbW92ZSB0aGlzIHRvIG1haW4gcmVuZGVyIHBhc3Mgc28gdGhhdCBpbmRpdmlkdWFsIG9iamVjdHMgY2FuIGJlIGV4ZW1wdCBmcm9tIGJsb29tXHJcbiAgICAgIGNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFJlbmRlcldlYkdMQ29tcG9uZW50Qmxvb20uZmJvc1swXSk7XHJcbiAgICAgIC8vIGNyYzMuZnJhbWVidWZmZXJUZXh0dXJlMkQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9BVFRBQ0hNRU5UMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBSZW5kZXJXZWJHTENvbXBvbmVudEJsb29tLnRleHR1cmVzWzBdLCAwKTtcclxuICAgICAgUmVuZGVyV2ViR0wuY2xlYXIoKTtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMLmJpbmRUZXh0dXJlKFNoYWRlckJsb29tLCBSZW5kZXJXZWJHTC50ZXhDb2xvciwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMCwgXCJ1X3RleFNvdXJjZVwiKTtcclxuICAgICAgY3JjMy51bmlmb3JtMWYoU2hhZGVyQmxvb20udW5pZm9ybXNbXCJ1X2ZUaHJlc2hvbGRcIl0sIF9jbXBCbG9vbS50aHJlc2hvbGQpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0xaShTaGFkZXJCbG9vbS51bmlmb3Jtc1tcInVfaU1vZGVcIl0sIDApO1xyXG4gICAgICBjcmMzLmRyYXdBcnJheXMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsIDAsIDMpO1xyXG5cclxuICAgICAgY29uc3QgY2FudmFzUmVjdGFuZ2xlOiBSZWN0YW5nbGUgPSBSZW5kZXJXZWJHTC5nZXRDYW52YXNSZWN0YW5nbGUoKTtcclxuICAgICAgY29uc3QgY2FudmFzV2lkdGg6IG51bWJlciA9IGNhbnZhc1JlY3RhbmdsZS53aWR0aDtcclxuICAgICAgY29uc3QgY2FudmFzSGVpZ2h0OiBudW1iZXIgPSBjYW52YXNSZWN0YW5nbGUuaGVpZ2h0O1xyXG5cclxuICAgICAgLy8gZG93bnNhbXBsZVxyXG4gICAgICBjb25zdCBpdGVyYXRpb25zOiBudW1iZXIgPSBSZW5kZXJXZWJHTENvbXBvbmVudEJsb29tLnRleHR1cmVzLmxlbmd0aDtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMSwgZGl2aXNvcjogbnVtYmVyID0gMjsgaSA8IGl0ZXJhdGlvbnM7IGkrKywgZGl2aXNvciAqPSAyKSB7XHJcbiAgICAgICAgbGV0IHdpZHRoOiBudW1iZXIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGNhbnZhc1dpZHRoIC8gZGl2aXNvciksIDEpO1xyXG4gICAgICAgIGxldCBoZWlnaHQ6IG51bWJlciA9IE1hdGgubWF4KE1hdGgucm91bmQoY2FudmFzSGVpZ2h0IC8gZGl2aXNvciksIDEpO1xyXG5cclxuICAgICAgICBjcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBSZW5kZXJXZWJHTENvbXBvbmVudEJsb29tLmZib3NbaV0pO1xyXG4gICAgICAgIGNyYzMudmlld3BvcnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIFJlbmRlcldlYkdMLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIFJlbmRlcldlYkdMLmJpbmRUZXh0dXJlKFNoYWRlckJsb29tLCBSZW5kZXJXZWJHTENvbXBvbmVudEJsb29tLnRleHR1cmVzW2kgLSAxXSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMCwgXCJ1X3RleFNvdXJjZVwiKTtcclxuICAgICAgICBjcmMzLnVuaWZvcm0xaShTaGFkZXJCbG9vbS51bmlmb3Jtc1tcInVfaU1vZGVcIl0sIDEpO1xyXG4gICAgICAgIGNyYzMudW5pZm9ybTJmKFNoYWRlckJsb29tLnVuaWZvcm1zW1widV92Y3RUZXhlbFwiXSwgMC41IC8gd2lkdGgsIDAuNSAvIGhlaWdodCk7IC8vIGhhbGYgdGV4ZWwgc2l6ZVxyXG4gICAgICAgIGNyYzMuZHJhd0FycmF5cyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUywgMCwgMyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFJlbmRlcldlYkdMLnNldEJsZW5kTW9kZShCTEVORC5BRERJVElWRSk7XHJcblxyXG4gICAgICAvLyB1cHNhbXBsZVxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSBpdGVyYXRpb25zIC0gMSwgZGl2aXNvcjogbnVtYmVyID0gMiAqKiAoaXRlcmF0aW9ucyAtIDIpOyBpID4gMDsgaS0tLCBkaXZpc29yIC89IDIpIHtcclxuICAgICAgICBsZXQgd2lkdGg6IG51bWJlciA9IE1hdGgubWF4KE1hdGgucm91bmQoY2FudmFzV2lkdGggLyBkaXZpc29yKSwgMSk7XHJcbiAgICAgICAgbGV0IGhlaWdodDogbnVtYmVyID0gTWF0aC5tYXgoTWF0aC5yb3VuZChjYW52YXNIZWlnaHQgLyBkaXZpc29yKSwgMSk7XHJcblxyXG4gICAgICAgIGNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFJlbmRlcldlYkdMQ29tcG9uZW50Qmxvb20uZmJvc1tpIC0gMV0pO1xyXG4gICAgICAgIGNyYzMudmlld3BvcnQoMCwgMCwgTWF0aC5yb3VuZCh3aWR0aCksIE1hdGgucm91bmQoaGVpZ2h0KSk7XHJcblxyXG4gICAgICAgIFJlbmRlcldlYkdMLmJpbmRUZXh0dXJlKFNoYWRlckJsb29tLCBSZW5kZXJXZWJHTENvbXBvbmVudEJsb29tLnRleHR1cmVzW2ldLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkUwLCBcInVfdGV4U291cmNlXCIpO1xyXG4gICAgICAgIGNyYzMudW5pZm9ybTFpKFNoYWRlckJsb29tLnVuaWZvcm1zW1widV9pTW9kZVwiXSwgMik7XHJcbiAgICAgICAgY3JjMy51bmlmb3JtMmYoU2hhZGVyQmxvb20udW5pZm9ybXNbXCJ1X3ZjdFRleGVsXCJdLCAwLjUgLyB3aWR0aCwgMC41IC8gaGVpZ2h0KTsgLy8gaGFsZiB0ZXhlbCBzaXplXHJcbiAgICAgICAgY3JjMy5kcmF3QXJyYXlzKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLCAwLCAzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY3JjMy52aWV3cG9ydCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcclxuXHJcbiAgICAgIGNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFJlbmRlcldlYkdMQ29tcG9uZW50Qmxvb20uZmJvT3V0KTtcclxuICAgICAgUmVuZGVyV2ViR0wuYmluZFRleHR1cmUoU2hhZGVyQmxvb20sIFJlbmRlcldlYkdMQ29tcG9uZW50Qmxvb20udGV4dHVyZXNbMF0sIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTAsIFwidV90ZXhTb3VyY2VcIik7XHJcbiAgICAgIGNyYzMudW5pZm9ybTFpKFNoYWRlckJsb29tLnVuaWZvcm1zW1widV9pTW9kZVwiXSwgMyk7XHJcbiAgICAgIGNyYzMudW5pZm9ybTFmKFNoYWRlckJsb29tLnVuaWZvcm1zW1widV9mSW50ZW5zaXR5XCJdLCBfY21wQmxvb20uaW50ZW5zaXR5KTtcclxuICAgICAgY3JjMy51bmlmb3JtMWYoU2hhZGVyQmxvb20udW5pZm9ybXNbXCJ1X2ZIaWdobGlnaHREZXNhdHVyYXRpb25cIl0sIF9jbXBCbG9vbS5oaWdobGlnaHREZXNhdHVyYXRpb24pO1xyXG4gICAgICBjcmMzLmRyYXdBcnJheXMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsIDAsIDMpO1xyXG5cclxuICAgICAgUmVuZGVyV2ViR0wuc2V0QmxlbmRNb2RlKEJMRU5ELlRSQU5TUEFSRU5UKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBSZXNpemUgdGhlIHJlbmRlciBhdHRhY2htZW50cy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZXNpemUoX3JlbmRlcldlYkdMOiB0eXBlb2YgUmVuZGVyV2ViR0wsIF93aWR0aDogbnVtYmVyLCBfaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IF9yZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGNvbnN0IGNhbnZhc1dpZHRoOiBudW1iZXIgPSBfd2lkdGggfHwgMTtcclxuICAgICAgY29uc3QgY2FudmFzSGVpZ2h0OiBudW1iZXIgPSBfaGVpZ2h0IHx8IDE7XHJcblxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwLCBkaXZpc29yOiBudW1iZXIgPSAxOyBpIDwgUmVuZGVyV2ViR0xDb21wb25lbnRCbG9vbS50ZXh0dXJlcy5sZW5ndGg7IGkrKywgZGl2aXNvciAqPSAyKSB7XHJcbiAgICAgICAgbGV0IHdpZHRoOiBudW1iZXIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGNhbnZhc1dpZHRoIC8gZGl2aXNvciksIDEpO1xyXG4gICAgICAgIGxldCBoZWlnaHQ6IG51bWJlciA9IE1hdGgubWF4KE1hdGgucm91bmQoY2FudmFzSGVpZ2h0IC8gZGl2aXNvciksIDEpO1xyXG4gICAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBSZW5kZXJXZWJHTENvbXBvbmVudEJsb29tLnRleHR1cmVzW2ldKTtcclxuICAgICAgICBjcmMzLnRleEltYWdlMkQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIHdpZHRoLCBoZWlnaHQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9CWVRFLCBudWxsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY3JjMy5iaW5kVGV4dHVyZShjcmMzLlRFWFRVUkVfMkQsIG51bGwpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIENvbXBvbmVudE91dGxpbmUgb3V0bGluZX0gcG9zdC1wcm9jZXNzaW5nIGVmZmVjdC5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAYXV0aG9ycyBKb25hcyBQbG90emt5LCBIRlUsIDIwMjVcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUmVuZGVyV2ViR0xDb21wb25lbnRPdXRsaW5lIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgc3Nhb1N1cHBvcnQ6IGJvb2xlYW47IC8vIFRPRE86XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBmYm9EZXB0aFBhc3M6IFdlYkdMRnJhbWVidWZmZXI7XHJcbiAgICBwdWJsaWMgc3RhdGljIHRleERlcHRoU3RlbmNpbDogV2ViR0xUZXh0dXJlO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZmJvT3V0OiBXZWJHTEZyYW1lYnVmZmVyO1xyXG4gICAgcHVibGljIHN0YXRpYyB0ZXhPdXQ6IFdlYkdMVGV4dHVyZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBJbml0aWFsaXplIGZyYW1lYnVmZmVycyBhbmQgcmVuZGVyIGF0dGFjaG1lbnRzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGluaXRpYWxpemUoX3JlbmRlcldlYkdMOiB0eXBlb2YgUmVuZGVyV2ViR0wpOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IF9yZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudE91dGxpbmUudGV4RGVwdGhTdGVuY2lsID0gX3JlbmRlcldlYkdMLmNyZWF0ZVRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNULCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudE91dGxpbmUuZmJvRGVwdGhQYXNzID0gX3JlbmRlcldlYkdMLmFzc2VydDxXZWJHTEZyYW1lYnVmZmVyPihjcmMzLmNyZWF0ZUZyYW1lYnVmZmVyKCkpO1xyXG4gICAgICBjcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBSZW5kZXJXZWJHTENvbXBvbmVudE91dGxpbmUuZmJvRGVwdGhQYXNzKTtcclxuICAgICAgY3JjMy5mcmFtZWJ1ZmZlclRleHR1cmUyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBSZW5kZXJXZWJHTENvbXBvbmVudE91dGxpbmUudGV4RGVwdGhTdGVuY2lsLCAwKTtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50T3V0bGluZS50ZXhPdXQgPSBfcmVuZGVyV2ViR0wudGV4Q29sb3I7XHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50T3V0bGluZS5mYm9PdXQgPSBfcmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMRnJhbWVidWZmZXI+KGNyYzMuY3JlYXRlRnJhbWVidWZmZXIoKSk7XHJcbiAgICAgIGNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFJlbmRlcldlYkdMQ29tcG9uZW50T3V0bGluZS5mYm9PdXQpO1xyXG4gICAgICBjcmMzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0xDb21wb25lbnRPdXRsaW5lLnRleE91dCwgMCk7XHJcblxyXG4gICAgICBjcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhlIG91dGxpbmUgZWZmZWN0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXcoX25vZGVzOiBJdGVyYWJsZTxOb2RlPiwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhLCBfY21wT3V0bGluZTogQ29tcG9uZW50T3V0bGluZSk6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG5cclxuICAgICAgY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgUmVuZGVyV2ViR0xDb21wb25lbnRPdXRsaW5lLmZib0RlcHRoUGFzcyk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTC5jbGVhcigpO1xyXG5cclxuICAgICAgY3JjMy5kaXNhYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQkxFTkQpO1xyXG4gICAgICBmb3IgKGxldCBzZWxlY3RlZCBvZiBfbm9kZXMpXHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHNlbGVjdGVkKSB7XHJcbiAgICAgICAgICBpZiAobm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCk/LmlzQWN0aXZlICYmIG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1hdGVyaWFsKT8uaXNBY3RpdmUpXHJcbiAgICAgICAgICAgIFJlbmRlcldlYkdMLmRyYXdOb2RlKG5vZGUsIF9jbXBDYW1lcmEpO1xyXG4gICAgICAgIH1cclxuICAgICAgY3JjMy5lbmFibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5CTEVORCk7XHJcblxyXG4gICAgICBTaGFkZXJPdXRsaW5lLnVzZVByb2dyYW0oKTtcclxuICAgICAgY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgUmVuZGVyV2ViR0xDb21wb25lbnRPdXRsaW5lLmZib091dCk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTC5iaW5kVGV4dHVyZShTaGFkZXJPdXRsaW5lLCBSZW5kZXJXZWJHTENvbXBvbmVudE91dGxpbmUudGV4RGVwdGhTdGVuY2lsLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkUwLCBcInVfdGV4RGVwdGhPdXRsaW5lXCIpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5iaW5kVGV4dHVyZShTaGFkZXJPdXRsaW5lLCBSZW5kZXJXZWJHTC50ZXhEZXB0aFN0ZW5jaWwsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTEsIFwidV90ZXhEZXB0aFNjZW5lXCIpO1xyXG5cclxuICAgICAgY3JjMy51bmlmb3JtNGZ2KFNoYWRlck91dGxpbmUudW5pZm9ybXNbXCJ1X3ZjdENvbG9yXCJdLCBfY21wT3V0bGluZS5jb2xvci5nZXQoKSk7XHJcbiAgICAgIGNyYzMudW5pZm9ybTRmdihTaGFkZXJPdXRsaW5lLnVuaWZvcm1zW1widV92Y3RDb2xvck9jY2x1ZGVkXCJdLCBfY21wT3V0bGluZS5jb2xvck9jY2x1ZGVkLmdldCgpKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlY3RDYW52YXM6IFJlY3RhbmdsZSA9IFJlbmRlcldlYkdMLmdldENhbnZhc1JlY3RhbmdsZSgpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0yZihTaGFkZXJPdXRsaW5lLnVuaWZvcm1zW1widV92Y3RUZXhlbFwiXSwgMSAvIE1hdGgucm91bmQocmVjdENhbnZhcy53aWR0aCksIDEgLyBNYXRoLnJvdW5kKHJlY3RDYW52YXMuaGVpZ2h0KSk7IC8vIGhhbGYgdGV4ZWwgc2l6ZVxyXG5cclxuICAgICAgY3JjMy5kcmF3QXJyYXlzKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLCAwLCAzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBSZXNpemUgdGhlIHJlbmRlciBhdHRhY2htZW50cy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZXNpemUoX3JlbmRlcldlYkdMOiB0eXBlb2YgUmVuZGVyV2ViR0wsIF93aWR0aDogbnVtYmVyLCBfaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IF9yZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGNvbnN0IGNhbnZhc1dpZHRoOiBudW1iZXIgPSBfd2lkdGggfHwgMTtcclxuICAgICAgY29uc3QgY2FudmFzSGVpZ2h0OiBudW1iZXIgPSBfaGVpZ2h0IHx8IDE7XHJcblxyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0xDb21wb25lbnRPdXRsaW5lLnRleERlcHRoU3RlbmNpbCk7XHJcbiAgICAgIGNyYzMudGV4SW1hZ2UyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEgyNF9TVEVOQ0lMOCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9TVEVOQ0lMLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0lOVF8yNF84LCBudWxsKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEdpdmVzIFdlYkdMIEJ1ZmZlciB0aGUgZGF0YSBmcm9tIHRoZSB7QGxpbmsgU2hhZGVyfVxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvclNoYWRlciB7XHJcbiAgICAvKipcclxuICAgICAqIEluamVjdHMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhpcyBjbGFzcyBpbnRvIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZ2l2ZW4ge0BsaW5rIFNoYWRlcn0tc3ViY2xhc3NcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWNvcmF0ZShfY29uc3RydWN0b3I6IHR5cGVvZiBTaGFkZXIsIF9jb250ZXh0OiBDbGFzc0RlY29yYXRvckNvbnRleHQpOiB2b2lkIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3RvciwgX2NvbnN0cnVjdG9yLnVzZVByb2dyYW0ubmFtZSwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvclNoYWRlci51c2VQcm9ncmFtXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLCBfY29uc3RydWN0b3IuY3JlYXRlUHJvZ3JhbS5uYW1lLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yU2hhZGVyLmNyZWF0ZVByb2dyYW1cclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IsIF9jb25zdHJ1Y3Rvci5kZWxldGVQcm9ncmFtLm5hbWUsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JTaGFkZXIuZGVsZXRlUHJvZ3JhbVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGlzIHByb2dyYW0gdG8gdXNlIGFzIHRoZSBhY3RpdmUgcHJvZ3JhbSBpbiBXZWJHTFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHVzZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMucHJvZ3JhbSlcclxuICAgICAgICB0aGlzLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjcmMzLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhpcyBwcm9ncmFtIGZyb20gV2ViR0wsIGNsZWFyaW5nIHRoZSB1c2VkIG1lbW9yeSBvbiB0aGUgR1BVLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlbGV0ZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQge1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgaWYgKHRoaXMucHJvZ3JhbSkge1xyXG4gICAgICAgIGNyYzMuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnVuaWZvcm1zO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnByb2dyYW07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGNyZWF0ZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQge1xyXG4gICAgICBEZWJ1Zy5mdWRnZShcIkNyZWF0ZSBzaGFkZXIgcHJvZ3JhbVwiLCB0aGlzLm5hbWUpO1xyXG4gICAgICBsZXQgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgbGV0IHByb2dyYW06IFdlYkdMUHJvZ3JhbSA9IGNyYzMuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsZXQgc2hkVmVydGV4OiBXZWJHTFNoYWRlciA9IGNvbXBpbGVTaGFkZXIodGhpcy5nZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5WRVJURVhfU0hBREVSKTtcclxuICAgICAgICBsZXQgc2hkRnJhZ21lbnQ6IFdlYkdMU2hhZGVyID0gY29tcGlsZVNoYWRlcih0aGlzLmdldEZyYWdtZW50U2hhZGVyU291cmNlKCksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBR01FTlRfU0hBREVSKTtcclxuXHJcbiAgICAgICAgY3JjMy5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMU2hhZGVyPihzaGRWZXJ0ZXgpKTtcclxuICAgICAgICBjcmMzLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xTaGFkZXI+KHNoZEZyYWdtZW50KSk7XHJcbiAgICAgICAgY3JjMy5saW5rUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcbiAgICAgICAgbGV0IGVycm9yOiBzdHJpbmcgPSBSZW5kZXJXZWJHTC5hc3NlcnQ8c3RyaW5nPihjcmMzLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcclxuICAgICAgICBpZiAoZXJyb3IgIT09IFwiXCIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGxpbmtpbmcgU2hhZGVyOiBcIiArIGVycm9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XHJcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IGRldGVjdFVuaWZvcm1zKCk7XHJcblxyXG4gICAgICAgIGJpbmRVbmlmb3JtQmxvY2socHJvZ3JhbSwgVU5JRk9STV9CTE9DSy5MSUdIVFMuTkFNRSwgVU5JRk9STV9CTE9DSy5MSUdIVFMuQklORElORyk7XHJcbiAgICAgICAgYmluZFVuaWZvcm1CbG9jayhwcm9ncmFtLCBVTklGT1JNX0JMT0NLLkNBTUVSQS5OQU1FLCBVTklGT1JNX0JMT0NLLkNBTUVSQS5CSU5ESU5HKTtcclxuICAgICAgICBiaW5kVW5pZm9ybUJsb2NrKHByb2dyYW0sIFVOSUZPUk1fQkxPQ0suTUFURVJJQUwuTkFNRSwgVU5JRk9STV9CTE9DSy5NQVRFUklBTC5CSU5ESU5HKTtcclxuICAgICAgICBiaW5kVW5pZm9ybUJsb2NrKHByb2dyYW0sIFVOSUZPUk1fQkxPQ0suTk9ERS5OQU1FLCBVTklGT1JNX0JMT0NLLk5PREUuQklORElORyk7XHJcbiAgICAgICAgYmluZFVuaWZvcm1CbG9jayhwcm9ncmFtLCBVTklGT1JNX0JMT0NLLlNLSU4uTkFNRSwgVU5JRk9STV9CTE9DSy5TS0lOLkJJTkRJTkcpO1xyXG4gICAgICAgIGJpbmRVbmlmb3JtQmxvY2socHJvZ3JhbSwgVU5JRk9STV9CTE9DSy5GT0cuTkFNRSwgVU5JRk9STV9CTE9DSy5GT0cuQklORElORyk7XHJcblxyXG4gICAgICAgIGNyYzMudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIGxldCB1bmlmb3JtOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiA9IHRoaXMudW5pZm9ybXNbVEVYVFVSRV9MT0NBVElPTi5DT0xPUi5VTklGT1JNXTtcclxuICAgICAgICBpZiAodW5pZm9ybSlcclxuICAgICAgICAgIGNyYzMudW5pZm9ybTFpKHVuaWZvcm0sIFRFWFRVUkVfTE9DQVRJT04uQ09MT1IuSU5ERVgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW1RFWFRVUkVfTE9DQVRJT04uTk9STUFMLlVOSUZPUk1dO1xyXG4gICAgICAgIGlmICh1bmlmb3JtKVxyXG4gICAgICAgICAgY3JjMy51bmlmb3JtMWkodW5pZm9ybSwgVEVYVFVSRV9MT0NBVElPTi5OT1JNQUwuSU5ERVgpO1xyXG5cclxuICAgICAgICB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1tURVhUVVJFX0xPQ0FUSU9OLlRPT04uVU5JRk9STV07XHJcbiAgICAgICAgaWYgKHVuaWZvcm0pXHJcbiAgICAgICAgICBjcmMzLnVuaWZvcm0xaSh1bmlmb3JtLCBURVhUVVJFX0xPQ0FUSU9OLlRPT04uSU5ERVgpO1xyXG5cclxuICAgICAgICB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1tURVhUVVJFX0xPQ0FUSU9OLlBBUlRJQ0xFLlVOSUZPUk1dO1xyXG4gICAgICAgIGlmICh1bmlmb3JtKVxyXG4gICAgICAgICAgY3JjMy51bmlmb3JtMWkodW5pZm9ybSwgVEVYVFVSRV9MT0NBVElPTi5QQVJUSUNMRS5JTkRFWCk7XHJcblxyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICBEZWJ1Zy5lcnJvcihfZXJyb3IpO1xyXG4gICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21waWxlU2hhZGVyKF9zaGFkZXJDb2RlOiBzdHJpbmcsIF9zaGFkZXJUeXBlOiBHTGVudW0pOiBXZWJHTFNoYWRlciB8IG51bGwge1xyXG4gICAgICAgIGxldCB3ZWJHTFNoYWRlcjogV2ViR0xTaGFkZXIgPSBjcmMzLmNyZWF0ZVNoYWRlcihfc2hhZGVyVHlwZSk7XHJcbiAgICAgICAgY3JjMy5zaGFkZXJTb3VyY2Uod2ViR0xTaGFkZXIsIF9zaGFkZXJDb2RlKTtcclxuICAgICAgICBjcmMzLmNvbXBpbGVTaGFkZXIod2ViR0xTaGFkZXIpO1xyXG4gICAgICAgIGxldCBlcnJvcjogc3RyaW5nID0gUmVuZGVyV2ViR0wuYXNzZXJ0PHN0cmluZz4oY3JjMy5nZXRTaGFkZXJJbmZvTG9nKHdlYkdMU2hhZGVyKSk7XHJcbiAgICAgICAgaWYgKGVycm9yICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICBEZWJ1Zy5sb2coX3NoYWRlckNvZGUpO1xyXG5cclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGNvbXBpbGluZyBzaGFkZXI6IFwiICsgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBmb3IgYW55IGNvbXBpbGF0aW9uIGVycm9ycy5cclxuICAgICAgICBpZiAoIWNyYzMuZ2V0U2hhZGVyUGFyYW1ldGVyKHdlYkdMU2hhZGVyLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNPTVBJTEVfU1RBVFVTKSkge1xyXG4gICAgICAgICAgYWxlcnQoY3JjMy5nZXRTaGFkZXJJbmZvTG9nKHdlYkdMU2hhZGVyKSk7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdlYkdMU2hhZGVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBkZXRlY3RVbmlmb3JtcygpOiB7IFtuYW1lOiBzdHJpbmddOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB9IHtcclxuICAgICAgICBsZXQgZGV0ZWN0ZWRVbmlmb3JtczogeyBbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfSA9IHt9O1xyXG4gICAgICAgIGxldCB1bmlmb3JtQ291bnQ6IG51bWJlciA9IGNyYzMuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFDVElWRV9VTklGT1JNUyk7XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHVuaWZvcm1Db3VudDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgaW5mbzogV2ViR0xBY3RpdmVJbmZvID0gUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMQWN0aXZlSW5mbz4oY3JjMy5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpKTtcclxuICAgICAgICAgIGlmICghaW5mbykge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxldCBsb2NhdGlvbjogV2ViR0xVbmlmb3JtTG9jYXRpb24gPSBjcmMzLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBpbmZvLm5hbWUpO1xyXG4gICAgICAgICAgaWYgKGxvY2F0aW9uKVxyXG4gICAgICAgICAgICBkZXRlY3RlZFVuaWZvcm1zW2luZm8ubmFtZV0gPSBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xVbmlmb3JtTG9jYXRpb24+KGxvY2F0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRldGVjdGVkVW5pZm9ybXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGJpbmRVbmlmb3JtQmxvY2soX3Byb2dyYW06IFdlYkdMUHJvZ3JhbSwgX3VuaWZvcm1CbG9ja05hbWU6IHN0cmluZywgX3VuaWZvcm1CbG9ja0JpbmRpbmc6IEdMdWludCk6IHZvaWQge1xyXG4gICAgICAgIGxldCBibG9ja0luZGV4OiBudW1iZXIgPSBjcmMzLmdldFVuaWZvcm1CbG9ja0luZGV4KF9wcm9ncmFtLCBfdW5pZm9ybUJsb2NrTmFtZSk7XHJcbiAgICAgICAgaWYgKGJsb2NrSW5kZXggPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5JTlZBTElEX0lOREVYKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgcmVmZXJlbmNlZEJ5VmVydGV4U2hhZGVyOiBib29sZWFuID0gY3JjMy5nZXRBY3RpdmVVbmlmb3JtQmxvY2tQYXJhbWV0ZXIoX3Byb2dyYW0sIGJsb2NrSW5kZXgsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CTE9DS19SRUZFUkVOQ0VEX0JZX1ZFUlRFWF9TSEFERVIpO1xyXG4gICAgICAgIGxldCByZWZlcmVuY2VkQnlGcmFnbWVudFNoYWRlcjogYm9vbGVhbiA9IGNyYzMuZ2V0QWN0aXZlVW5pZm9ybUJsb2NrUGFyYW1ldGVyKF9wcm9ncmFtLCBibG9ja0luZGV4LCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQkxPQ0tfUkVGRVJFTkNFRF9CWV9GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgICAgIGlmICghcmVmZXJlbmNlZEJ5VmVydGV4U2hhZGVyICYmICFyZWZlcmVuY2VkQnlGcmFnbWVudFNoYWRlcilcclxuICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgY3JjMy51bmlmb3JtQmxvY2tCaW5kaW5nKF9wcm9ncmFtLCBibG9ja0luZGV4LCBfdW5pZm9ybUJsb2NrQmluZGluZyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQnVmZmVycyB0aGUgZGF0YSBmcm9tIHRoZSB7QGxpbmsgTWVzaH0gaW50byBhIFdlYkdMIEJ1ZmZlclxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3Rvck1lc2gge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbmplY3RzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIHRoaXMgY2xhc3MgaW50byB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGdpdmVuIHtAbGluayBNZXNofS1zdWJjbGFzc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlY29yYXRlKF9jb25zdHJ1Y3RvcjogdHlwZW9mIE1lc2gsIF9jb250ZXh0OiBDbGFzc0RlY29yYXRvckNvbnRleHQpOiB2b2lkIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUudXNlUmVuZGVyQnVmZmVycy5uYW1lLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yTWVzaC51c2VSZW5kZXJCdWZmZXJzXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgX2NvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRSZW5kZXJCdWZmZXJzLm5hbWUsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JNZXNoLmdldFJlbmRlckJ1ZmZlcnNcclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBfY29uc3RydWN0b3IucHJvdG90eXBlLmRlbGV0ZVJlbmRlckJ1ZmZlcnMubmFtZSwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3Rvck1lc2guZGVsZXRlUmVuZGVyQnVmZmVyc1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGdldFJlbmRlckJ1ZmZlcnModGhpczogTWVzaCk6IFJlbmRlckJ1ZmZlcnMge1xyXG4gICAgICBsZXQgYnVmZmVyczogUmVuZGVyQnVmZmVycyA9IHRoaXMucmVuZGVyTWVzaC5idWZmZXJzO1xyXG4gICAgICBpZiAoYnVmZmVycylcclxuICAgICAgICByZXR1cm4gYnVmZmVycztcclxuXHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGNvbnN0IHZhbzogV2ViR0xWZXJ0ZXhBcnJheU9iamVjdCA9IFJlbmRlcldlYkdMLmFzc2VydDxXZWJHTFZlcnRleEFycmF5T2JqZWN0PihjcmMzLmNyZWF0ZVZlcnRleEFycmF5KCkpO1xyXG4gICAgICBjcmMzLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xyXG5cclxuICAgICAgYnVmZmVycyA9IHtcclxuICAgICAgICBpbmRpY2VzOiBjcmVhdGVCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJNZXNoLmluZGljZXMpLFxyXG4gICAgICAgIHBvc2l0aW9uczogY3JlYXRlQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlck1lc2gucG9zaXRpb25zKSxcclxuICAgICAgICBub3JtYWxzOiBjcmVhdGVCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMucmVuZGVyTWVzaC5ub3JtYWxzKSxcclxuICAgICAgICB0ZXh0dXJlVVZzOiBjcmVhdGVCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMucmVuZGVyTWVzaC50ZXh0dXJlVVZzKSxcclxuICAgICAgICBjb2xvcnM6IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJNZXNoLmNvbG9ycyksXHJcbiAgICAgICAgdGFuZ2VudHM6IGNyZWF0ZUJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgdGhpcy5yZW5kZXJNZXNoLnRhbmdlbnRzKSxcclxuICAgICAgICBuSW5kaWNlczogdGhpcy5yZW5kZXJNZXNoLmluZGljZXMubGVuZ3RoLFxyXG4gICAgICAgIHZhbzogdmFvXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAodGhpcy5yZW5kZXJNZXNoLmJvbmVzKVxyXG4gICAgICAgIGJ1ZmZlcnMuYm9uZXMgPSBjcmVhdGVCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMucmVuZGVyTWVzaC5ib25lcyk7XHJcblxyXG4gICAgICBpZiAodGhpcy5yZW5kZXJNZXNoLndlaWdodHMpXHJcbiAgICAgICAgYnVmZmVycy53ZWlnaHRzID0gY3JlYXRlQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLnJlbmRlck1lc2gud2VpZ2h0cyk7XHJcblxyXG4gICAgICBzZXRBdHRyaWJ1dGVCdWZmZXIoYnVmZmVycy5wb3NpdGlvbnMsIFNIQURFUl9BVFRSSUJVVEUuUE9TSVRJT04sIDMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRkxPQVQpO1xyXG4gICAgICBzZXRBdHRyaWJ1dGVCdWZmZXIoYnVmZmVycy5ub3JtYWxzLCBTSEFERVJfQVRUUklCVVRFLk5PUk1BTCwgMywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCk7XHJcbiAgICAgIHNldEF0dHJpYnV0ZUJ1ZmZlcihidWZmZXJzLnRleHR1cmVVVnMsIFNIQURFUl9BVFRSSUJVVEUuVEVYQ09PUkRTLCAyLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FUKTtcclxuICAgICAgc2V0QXR0cmlidXRlQnVmZmVyKGJ1ZmZlcnMuY29sb3JzLCBTSEFERVJfQVRUUklCVVRFLkNPTE9SLCA0LCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FUKTtcclxuICAgICAgc2V0QXR0cmlidXRlQnVmZmVyKGJ1ZmZlcnMudGFuZ2VudHMsIFNIQURFUl9BVFRSSUJVVEUuVEFOR0VOVCwgNCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCk7XHJcbiAgICAgIGlmIChidWZmZXJzLmJvbmVzKVxyXG4gICAgICAgIHNldEF0dHJpYnV0ZUJ1ZmZlcihidWZmZXJzLmJvbmVzLCBTSEFERVJfQVRUUklCVVRFLkJPTkVTLCA0LCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0JZVEUpO1xyXG4gICAgICBpZiAoYnVmZmVycy53ZWlnaHRzKVxyXG4gICAgICAgIHNldEF0dHJpYnV0ZUJ1ZmZlcihidWZmZXJzLndlaWdodHMsIFNIQURFUl9BVFRSSUJVVEUuV0VJR0hUUywgNCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJNZXNoLmJ1ZmZlcnMgPSBidWZmZXJzO1xyXG5cclxuICAgICAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyKF90eXBlOiBHTGVudW0sIF9hcnJheTogRmxvYXQzMkFycmF5IHwgVWludDE2QXJyYXkgfCBVaW50OEFycmF5KTogV2ViR0xCdWZmZXIge1xyXG4gICAgICAgIGxldCBidWZmZXI6IFdlYkdMQnVmZmVyID0gUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMQnVmZmVyPihjcmMzLmNyZWF0ZUJ1ZmZlcigpKTtcclxuICAgICAgICBjcmMzLmJpbmRCdWZmZXIoX3R5cGUsIGJ1ZmZlcik7XHJcbiAgICAgICAgY3JjMy5idWZmZXJEYXRhKF90eXBlLCBfYXJyYXksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHNldEF0dHJpYnV0ZUJ1ZmZlcihfYnVmZmVyOiBXZWJHTEJ1ZmZlciwgX2xvY2F0aW9uOiBudW1iZXIsIF9zaXplOiBudW1iZXIsIF90eXBlOiBHTGVudW0pOiB2b2lkIHtcclxuICAgICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIF9idWZmZXIpO1xyXG4gICAgICAgIGNyYzMuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoX2xvY2F0aW9uKTtcclxuICAgICAgICBpZiAoX3R5cGUgPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVClcclxuICAgICAgICAgIGNyYzMudmVydGV4QXR0cmliUG9pbnRlcihfbG9jYXRpb24sIF9zaXplLCBfdHlwZSwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgIGlmIChfdHlwZSA9PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0JZVEUpXHJcbiAgICAgICAgICBjcmMzLnZlcnRleEF0dHJpYklQb2ludGVyKF9sb2NhdGlvbiwgX3NpemUsIF90eXBlLCAwLCAwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgdXNlUmVuZGVyQnVmZmVycyh0aGlzOiBNZXNoKTogUmVuZGVyQnVmZmVycyB7XHJcbiAgICAgIGNvbnN0IGJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMgPSB0aGlzLmdldFJlbmRlckJ1ZmZlcnMoKTtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgY3JjMy5iaW5kVmVydGV4QXJyYXkoYnVmZmVycy52YW8pO1xyXG4gICAgICByZXR1cm4gYnVmZmVycztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlbGV0ZVJlbmRlckJ1ZmZlcnMoX3JlbmRlckJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMpOiB2b2lkIHtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGlmIChfcmVuZGVyQnVmZmVycykge1xyXG4gICAgICAgIGNyYzMuZGVsZXRlVmVydGV4QXJyYXkoX3JlbmRlckJ1ZmZlcnMudmFvKTtcclxuICAgICAgICBjcmMzLmJpbmRCdWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICBPYmplY3QudmFsdWVzKF9yZW5kZXJCdWZmZXJzKVxyXG4gICAgICAgICAgLmZpbHRlcihfdmFsdWUgPT4gX3ZhbHVlIGluc3RhbmNlb2YgV2ViR0xCdWZmZXIpXHJcbiAgICAgICAgICAuZm9yRWFjaChfYnVmZmVyID0+IGNyYzMuZGVsZXRlQnVmZmVyKF9idWZmZXIpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIGV4cG9ydCBuYW1lc3BhY2UgUGFydGljbGVEYXRhIHtcclxuXHJcbiAgICBleHBvcnQgZW51bSBGVU5DVElPTiB7XHJcbiAgICAgIC8vIFZBTFVFID0gXCJ2YWx1ZVwiLFxyXG4gICAgICBBRERJVElPTiA9IFwiYWRkaXRpb25cIixcclxuICAgICAgU1VCVFJBQ1RJT04gPSBcInN1YnRyYWN0aW9uXCIsXHJcbiAgICAgIE1VTFRJUExJQ0FUSU9OID0gXCJtdWx0aXBsaWNhdGlvblwiLFxyXG4gICAgICBESVZJU0lPTiA9IFwiZGl2aXNpb25cIixcclxuICAgICAgTU9EVUxPID0gXCJtb2R1bG9cIixcclxuICAgICAgUE9XRVIgPSBcInBvd2VyXCIsXHJcbiAgICAgIFBPTFlOT01JQUwzID0gXCJwb2x5bm9taWFsM1wiLFxyXG4gICAgICBTUVVBUkVfUk9PVCA9IFwic3F1YXJlUm9vdFwiLFxyXG4gICAgICBSQU5ET00gPSBcInJhbmRvbVwiLFxyXG4gICAgICBSQU5ET01fUkFOR0UgPSBcInJhbmRvbVJhbmdlXCJcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgY29uc3QgRlVOQ1RJT05fTUlOSU1VTV9QQVJBTUVURVJTOiB7IFtrZXkgaW4gUGFydGljbGVEYXRhLkZVTkNUSU9OXTogbnVtYmVyIH0gPSB7XHJcbiAgICAgIC8vIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uVkFMVUVdOiAxLFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLkFERElUSU9OXTogMixcclxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5TVUJUUkFDVElPTl06IDIsXHJcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uTVVMVElQTElDQVRJT05dOiAyLFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLkRJVklTSU9OXTogMixcclxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5NT0RVTE9dOiAyLFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlBPV0VSXTogMixcclxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5QT0xZTk9NSUFMM106IDUsXHJcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uU1FVQVJFX1JPT1RdOiAxLFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlJBTkRPTV06IDAsXHJcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uUkFORE9NX1JBTkdFXTogMlxyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnQgY29uc3QgUFJFREVGSU5FRF9WQVJJQUJMRVM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XHJcbiAgICAgIHN5c3RlbUR1cmF0aW9uOiBcInVfZlBhcnRpY2xlU3lzdGVtRHVyYXRpb25cIixcclxuICAgICAgc3lzdGVtU2l6ZTogXCJ1X2ZQYXJ0aWNsZVN5c3RlbVNpemVcIixcclxuICAgICAgc3lzdGVtVGltZTogXCJ1X2ZQYXJ0aWNsZVN5c3RlbVRpbWVcIixcclxuICAgICAgcGFydGljbGVJZDogXCJmUGFydGljbGVJZFwiXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGlsZXMgcGFydGljbGUgc3lzdGVtIHNoYWRlcnMgKHtAbGluayBTaGFkZXJQYXJ0aWNsZVN5c3RlbX0pIGZyb20gc2hhZGVyIHVuaXZlcnNhbCBkZXJpdmF0ZXMgZm9yIFdlYkdMXHJcbiAgICogQGF1dGhvcnMgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIyXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0ge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBGVU5DVElPTlM6IHsgW2tleSBpbiBQYXJ0aWNsZURhdGEuRlVOQ1RJT05dOiBGdW5jdGlvbiB9ID0ge1xyXG4gICAgICAvLyBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlZBTFVFXTogKF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgICAvLyAgIHJldHVybiBgKCR7X3BhcmFtZXRlcnNbMF19KWA7XHJcbiAgICAgIC8vIH0sXHJcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uQURESVRJT05dOiAoX3BhcmFtZXRlcnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGAoJHtfcGFyYW1ldGVycy5yZWR1Y2UoKF9hY2N1bXVsYXRvcjogc3RyaW5nLCBfdmFsdWU6IHN0cmluZykgPT4gYCR7X2FjY3VtdWxhdG9yfSArICR7X3ZhbHVlfWApfSlgO1xyXG4gICAgICB9LFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlNVQlRSQUNUSU9OXTogKF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBgKCR7X3BhcmFtZXRlcnMucmVkdWNlKChfYWNjdW11bGF0b3I6IHN0cmluZywgX3ZhbHVlOiBzdHJpbmcpID0+IGAke19hY2N1bXVsYXRvcn0gLSAke192YWx1ZX1gKX0pYDtcclxuICAgICAgfSxcclxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5NVUxUSVBMSUNBVElPTl06IChfcGFyYW1ldGVyczogc3RyaW5nW10pID0+IHtcclxuICAgICAgICByZXR1cm4gYCgke19wYXJhbWV0ZXJzLnJlZHVjZSgoX2FjY3VtdWxhdG9yOiBzdHJpbmcsIF92YWx1ZTogc3RyaW5nKSA9PiBgJHtfYWNjdW11bGF0b3J9ICogJHtfdmFsdWV9YCl9KWA7XHJcbiAgICAgIH0sXHJcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uRElWSVNJT05dOiAoX3BhcmFtZXRlcnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGAoJHtfcGFyYW1ldGVyc1swXX0gLyAke19wYXJhbWV0ZXJzWzFdfSlgO1xyXG4gICAgICB9LFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLk1PRFVMT106IChfcGFyYW1ldGVyczogc3RyaW5nW10pID0+IHtcclxuICAgICAgICByZXR1cm4gYCgke19wYXJhbWV0ZXJzLnJlZHVjZSgoX2FjY3VtdWxhdG9yOiBzdHJpbmcsIF92YWx1ZTogc3RyaW5nKSA9PiBgbW9kKCR7X2FjY3VtdWxhdG9yfSwgJHtfdmFsdWV9KWApfSlgO1xyXG4gICAgICB9LFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlBPV0VSXTogKF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBgcG93KCR7X3BhcmFtZXRlcnNbMF19LCAke19wYXJhbWV0ZXJzWzFdfSlgO1xyXG4gICAgICB9LFxyXG4gICAgICBbUGFydGljbGVEYXRhLkZVTkNUSU9OLlBPTFlOT01JQUwzXTogKF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgICAgIGxldCB4OiBzdHJpbmcgPSBfcGFyYW1ldGVyc1swXTtcclxuICAgICAgICBsZXQgYTogc3RyaW5nID0gX3BhcmFtZXRlcnNbMV07XHJcbiAgICAgICAgbGV0IGI6IHN0cmluZyA9IF9wYXJhbWV0ZXJzWzJdO1xyXG4gICAgICAgIGxldCBjOiBzdHJpbmcgPSBfcGFyYW1ldGVyc1szXTtcclxuICAgICAgICBsZXQgZDogc3RyaW5nID0gX3BhcmFtZXRlcnNbNF07XHJcbiAgICAgICAgcmV0dXJuIGAoJHthfSAqIHBvdygke3h9LCAzLjApICsgJHtifSAqIHBvdygke3h9LCAyLjApICsgJHtjfSAqICR7eH0gKyAke2R9KWA7XHJcbiAgICAgIH0sXHJcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uU1FVQVJFX1JPT1RdOiAoX3BhcmFtZXRlcnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgbGV0IHg6IHN0cmluZyA9IF9wYXJhbWV0ZXJzWzBdO1xyXG4gICAgICAgIHJldHVybiBgc3FydCgke3h9KWA7XHJcbiAgICAgIH0sXHJcbiAgICAgIFtQYXJ0aWNsZURhdGEuRlVOQ1RJT04uUkFORE9NXTogKF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBgZmV0Y2hSYW5kb21OdW1iZXIoJHsoUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5yYW5kb21OdW1iZXJJbmRleE9mZnNldCsrKS50b0ZpeGVkKDApfSwgaVBhcnRpY2xlU3lzdGVtUmFuZG9tTnVtYmVyc1NpemUsIGlQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNMZW5ndGgpYDtcclxuICAgICAgfSxcclxuICAgICAgW1BhcnRpY2xlRGF0YS5GVU5DVElPTi5SQU5ET01fUkFOR0VdOiAoX3BhcmFtZXRlcnM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGAoJHtSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLkZVTkNUSU9OU1tcInJhbmRvbVwiXSgpfSAqICgke19wYXJhbWV0ZXJzWzFdfSAtICR7X3BhcmFtZXRlcnNbMF19KSArICR7X3BhcmFtZXRlcnNbMF19KWA7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmFuZG9tTnVtYmVySW5kZXhPZmZzZXQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWNvcmF0ZShfY29uc3RydWN0b3I6IHR5cGVvZiBTaGFkZXJQYXJ0aWNsZVN5c3RlbSwgX2NvbnRleHQ6IENsYXNzRGVjb3JhdG9yQ29udGV4dCk6IHZvaWQge1xyXG4gICAgICBSZW5kZXJJbmplY3RvclNoYWRlci5kZWNvcmF0ZSg8dHlwZW9mIFNoYWRlcj48R2VuZXJhbD5fY29uc3RydWN0b3IucHJvdG90eXBlLCBfY29udGV4dCk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBfY29uc3RydWN0b3IucHJvdG90eXBlLmdldFZlcnRleFNoYWRlclNvdXJjZS5uYW1lLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2V0VmVydGV4U2hhZGVyU291cmNlXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgX2NvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRGcmFnbWVudFNoYWRlclNvdXJjZS5uYW1lLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2VcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIHNvdXJjZSBjb2RlIGZvciB0aGUgdmVydGV4IHNoYWRlciBvZiB0aGUge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtfSBmcm9tIHRoZSBzZXQge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtLmRhdGF9IGFuZCB0aGUgb3JpZ2luYWwge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtLnZlcnRleFNoYWRlclNvdXJjZX0uXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKHRoaXM6IFNoYWRlclBhcnRpY2xlU3lzdGVtKTogc3RyaW5nIHtcclxuICAgICAgbGV0IGRhdGE6IFBhcnRpY2xlRGF0YS5TeXN0ZW0gPSB0aGlzLmRhdGE7XHJcbiAgICAgIGxldCBtdHhMb2NhbDogUGFydGljbGVEYXRhLlRyYW5zZm9ybWF0aW9uW10gPSBkYXRhPy5tdHhMb2NhbDtcclxuICAgICAgbGV0IG10eFdvcmxkOiBQYXJ0aWNsZURhdGEuVHJhbnNmb3JtYXRpb25bXSA9IGRhdGE/Lm10eFdvcmxkO1xyXG5cclxuICAgICAgUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5yYW5kb21OdW1iZXJJbmRleE9mZnNldCA9IDA7XHJcblxyXG4gICAgICBsZXQgc291cmNlOiBzdHJpbmcgPSB0aGlzLnZlcnRleFNoYWRlclNvdXJjZVxyXG4gICAgICAgIC5yZXBsYWNlKFwiI3ZlcnNpb24gMzAwIGVzXCIsIGAjdmVyc2lvbiAzMDAgZXNcXG4jZGVmaW5lICR7dGhpcy5kZWZpbmVbMF19JHtkYXRhLmNvbG9yID8gXCJcXG4jZGVmaW5lIFBBUlRJQ0xFX0NPTE9SXCIgOiBcIlwifWApXHJcbiAgICAgICAgLnJlcGxhY2UoXCIvKiR2YXJpYWJsZXMqL1wiLCBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLmdlbmVyYXRlVmFyaWFibGVzKGRhdGE/LnZhcmlhYmxlcywgZGF0YT8udmFyaWFibGVOYW1lcykpXHJcbiAgICAgICAgLnJlcGxhY2UoXCIvKiRtdHhMb2NhbCovXCIsIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2VuZXJhdGVUcmFuc2Zvcm1hdGlvbnMobXR4TG9jYWwsIFwiTG9jYWxcIikpXHJcbiAgICAgICAgLnJlcGxhY2UoXCIvKiRtdHhMb2NhbCovXCIsIG10eExvY2FsICYmIG10eExvY2FsLmxlbmd0aCA+IDAgPyBcIiogbXR4TG9jYWxcIiA6IFwiXCIpXHJcbiAgICAgICAgLnJlcGxhY2UoXCIvKiRtdHhXb3JsZCovXCIsIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2VuZXJhdGVUcmFuc2Zvcm1hdGlvbnMobXR4V29ybGQsIFwiV29ybGRcIikpXHJcbiAgICAgICAgLnJlcGxhY2UoXCIvKiRtdHhXb3JsZCovXCIsIG10eFdvcmxkICYmIG10eFdvcmxkLmxlbmd0aCA+IDAgPyBcIm10eFdvcmxkICpcIiA6IFwiXCIpXHJcbiAgICAgICAgLnJlcGxhY2VBbGwoXCIvKiRjb2xvciovXCIsIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2VuZXJhdGVDb2xvcihkYXRhPy5jb2xvcikpO1xyXG4gICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHRoZSBzb3VyY2UgY29kZSBmb3IgdGhlIGZyYWdtZW50IHNoYWRlciBvZiB0aGUge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtfSBmcm9tIHRoZSBzZXQge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtLmRhdGF9IGFuZCB0aGUgb3JpZ2luYWwge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtLmZyYWdtZW50U2hhZGVyU291cmNlfS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSh0aGlzOiBTaGFkZXJQYXJ0aWNsZVN5c3RlbSk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50U2hhZGVyU291cmNlLnJlcGxhY2UoXCIjdmVyc2lvbiAzMDAgZXNcIiwgYCN2ZXJzaW9uIDMwMCBlc1xcbiNkZWZpbmUgJHt0aGlzLmRlZmluZVswXX0ke3RoaXMuZGF0YS5jb2xvciA/IFwiXFxuI2RlZmluZSBQQVJUSUNMRV9DT0xPUlwiIDogXCJcIn1gKVxyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBjb2RlIGdlbmVyYXRpb25cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZVZhcmlhYmxlcyhfdmFyaWFibGVzOiBQYXJ0aWNsZURhdGEuU3lzdGVtW1widmFyaWFibGVzXCJdLCBfdmFyaWFibGVOYW1lczogUGFydGljbGVEYXRhLlN5c3RlbVtcInZhcmlhYmxlTmFtZXNcIl0pOiBzdHJpbmcge1xyXG4gICAgICBpZiAoIV92YXJpYWJsZXMpIHJldHVybiBcIlwiO1xyXG5cclxuICAgICAgcmV0dXJuIF92YXJpYWJsZXNcclxuICAgICAgICAubWFwKChfdmFyaWFibGUsIF9pbmRleCkgPT4gKHsgbmFtZTogXCJmUGFydGljbGVTeXN0ZW1WYXJpYWJsZV9cIiArIF92YXJpYWJsZU5hbWVzW19pbmRleF0sIHZhbHVlOiBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLmdlbmVyYXRlRXhwcmVzc2lvbihfdmFyaWFibGUpIH0pKVxyXG4gICAgICAgIC5tYXAoX3ZhcmlhYmxlID0+IGBmbG9hdCAke192YXJpYWJsZS5uYW1lfSA9ICR7X3ZhcmlhYmxlLnZhbHVlfTtgKVxyXG4gICAgICAgIC5yZWR1Y2UoKF9hY2N1bXVsYXRvcjogc3RyaW5nLCBfY29kZTogc3RyaW5nKSA9PiBgJHtfYWNjdW11bGF0b3J9XFxuJHtfY29kZX1gLCBcIlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZVRyYW5zZm9ybWF0aW9ucyhfdHJhbnNmb3JtYXRpb25zOiBQYXJ0aWNsZURhdGEuU3lzdGVtW1wibXR4TG9jYWxcIl0sIF9sb2NhbE9yV29ybGQ6IFwiTG9jYWxcIiB8IFwiV29ybGRcIik6IHN0cmluZyB7XHJcbiAgICAgIGlmICghX3RyYW5zZm9ybWF0aW9ucyB8fCBfdHJhbnNmb3JtYXRpb25zLmxlbmd0aCA9PSAwKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAgIGxldCB0cmFuc2Zvcm1hdGlvbnM6IFtQYXJ0aWNsZURhdGEuVHJhbnNmb3JtYXRpb25bXCJ0cmFuc2Zvcm1hdGlvblwiXSwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZ11bXSA9IF90cmFuc2Zvcm1hdGlvbnNcclxuICAgICAgICAubWFwKF9kYXRhID0+IHtcclxuICAgICAgICAgIGxldCBpc1NjYWxlOiBib29sZWFuID0gX2RhdGEudHJhbnNmb3JtYXRpb24gPT09IFwic2NhbGVcIjtcclxuICAgICAgICAgIGxldCBbeCwgeSwgel0gPSBbX2RhdGEucGFyYW1ldGVyc1swXSwgX2RhdGEucGFyYW1ldGVyc1sxXSwgX2RhdGEucGFyYW1ldGVyc1syXV1cclxuICAgICAgICAgICAgLm1hcCgoX3ZhbHVlKSA9PiBfdmFsdWUgPyBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLmdlbmVyYXRlRXhwcmVzc2lvbihfdmFsdWUpIDogKGlzU2NhbGUgPyBcIjEuMFwiIDogXCIwLjBcIikpIGFzIFtzdHJpbmcsIHN0cmluZywgc3RyaW5nXTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gW19kYXRhLnRyYW5zZm9ybWF0aW9uLCB4LCB5LCB6XTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIGxldCBjb2RlOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICBjb2RlICs9IHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgICAgIC5tYXAoKFtfdHJhbnNmb3JtYXRpb24sIF94LCBfeSwgX3pdLCBfaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgbGV0IHJvdGF0ZUlkOiBzdHJpbmcgPSBfaW5kZXggKyBfbG9jYWxPcldvcmxkO1xyXG4gICAgICAgICAgaWYgKF90cmFuc2Zvcm1hdGlvbiA9PSBcInJvdGF0ZVwiKSB7XHJcbiAgICAgICAgICAgIGxldCB0b1JhZGlhbnM6IChfdmFsdWU6IHN0cmluZykgPT4gc3RyaW5nID0gKF92YWx1ZTogc3RyaW5nKSA9PiBgJHtfdmFsdWV9ICogJHtDYWxjLmRlZzJyYWR9YDtcclxuICAgICAgICAgICAgcmV0dXJuIGBmbG9hdCBmWFJhZGlhbnMke3JvdGF0ZUlkfSA9ICR7dG9SYWRpYW5zKF94KX07XHJcbiAgICAgICAgICAgICAgZmxvYXQgZllSYWRpYW5zJHtyb3RhdGVJZH0gPSAke3RvUmFkaWFucyhfeSl9O1xyXG4gICAgICAgICAgICAgIGZsb2F0IGZaUmFkaWFucyR7cm90YXRlSWR9ID0gJHt0b1JhZGlhbnMoX3opfTtcclxuICAgICAgICAgICAgICBmbG9hdCBmU2luWCR7cm90YXRlSWR9ID0gc2luKGZYUmFkaWFucyR7cm90YXRlSWR9KTtcclxuICAgICAgICAgICAgICBmbG9hdCBmQ29zWCR7cm90YXRlSWR9ID0gY29zKGZYUmFkaWFucyR7cm90YXRlSWR9KTsgXHJcbiAgICAgICAgICAgICAgZmxvYXQgZlNpblkke3JvdGF0ZUlkfSA9IHNpbihmWVJhZGlhbnMke3JvdGF0ZUlkfSk7XHJcbiAgICAgICAgICAgICAgZmxvYXQgZkNvc1kke3JvdGF0ZUlkfSA9IGNvcyhmWVJhZGlhbnMke3JvdGF0ZUlkfSk7XHJcbiAgICAgICAgICAgICAgZmxvYXQgZlNpbloke3JvdGF0ZUlkfSA9IHNpbihmWlJhZGlhbnMke3JvdGF0ZUlkfSk7XHJcbiAgICAgICAgICAgICAgZmxvYXQgZkNvc1oke3JvdGF0ZUlkfSA9IGNvcyhmWlJhZGlhbnMke3JvdGF0ZUlkfSk7XFxuYDtcclxuICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5maWx0ZXIoKF90cmFuc2Zvcm1hdGlvbjogc3RyaW5nKSA9PiBfdHJhbnNmb3JtYXRpb24gIT0gXCJcIilcclxuICAgICAgICAucmVkdWNlKChfYWNjdW11bGF0b3I6IHN0cmluZywgX2NvZGU6IHN0cmluZykgPT4gYCR7X2FjY3VtdWxhdG9yfVxcbiR7X2NvZGV9YCwgXCJcIik7XHJcbiAgICAgIGNvZGUgKz0gXCJcXG5cIjtcclxuXHJcbiAgICAgIGNvZGUgKz0gYG1hdDQgbXR4JHtfbG9jYWxPcldvcmxkfSA9IGA7XHJcbiAgICAgIGNvZGUgKz0gdHJhbnNmb3JtYXRpb25zXHJcbiAgICAgICAgLm1hcCgoW190cmFuc2Zvcm1hdGlvbiwgX3gsIF95LCBfel0sIF9pbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICBsZXQgcm90YXRlSWQ6IHN0cmluZyA9IF9pbmRleCArIF9sb2NhbE9yV29ybGQ7XHJcbiAgICAgICAgICBzd2l0Y2ggKF90cmFuc2Zvcm1hdGlvbikge1xyXG4gICAgICAgICAgICBjYXNlIFwidHJhbnNsYXRlXCI6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGBtYXQ0KFxyXG4gICAgICAgICAgICAgIDEuMCwgMC4wLCAwLjAsIDAuMCxcclxuICAgICAgICAgICAgICAwLjAsIDEuMCwgMC4wLCAwLjAsXHJcbiAgICAgICAgICAgICAgMC4wLCAwLjAsIDEuMCwgMC4wLFxyXG4gICAgICAgICAgICAgICR7X3h9LCAke195fSwgJHtfen0sIDEuMClgO1xyXG4gICAgICAgICAgICBjYXNlIFwicm90YXRlXCI6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGBtYXQ0KFxyXG4gICAgICAgICAgICAgIGZDb3NaJHtyb3RhdGVJZH0gKiBmQ29zWSR7cm90YXRlSWR9LCBmU2luWiR7cm90YXRlSWR9ICogZkNvc1kke3JvdGF0ZUlkfSwgLWZTaW5ZJHtyb3RhdGVJZH0sIDAuMCxcclxuICAgICAgICAgICAgICBmQ29zWiR7cm90YXRlSWR9ICogZlNpblkke3JvdGF0ZUlkfSAqIGZTaW5YJHtyb3RhdGVJZH0gLSBmU2luWiR7cm90YXRlSWR9ICogZkNvc1gke3JvdGF0ZUlkfSwgZlNpbloke3JvdGF0ZUlkfSAqIGZTaW5ZJHtyb3RhdGVJZH0gKiBmU2luWCR7cm90YXRlSWR9ICsgZkNvc1oke3JvdGF0ZUlkfSAqIGZDb3NYJHtyb3RhdGVJZH0sIGZDb3NZJHtyb3RhdGVJZH0gKiBmU2luWCR7cm90YXRlSWR9LCAwLjAsXHJcbiAgICAgICAgICAgICAgZkNvc1oke3JvdGF0ZUlkfSAqIGZTaW5ZJHtyb3RhdGVJZH0gKiBmQ29zWCR7cm90YXRlSWR9ICsgZlNpbloke3JvdGF0ZUlkfSAqIGZTaW5YJHtyb3RhdGVJZH0sIGZTaW5aJHtyb3RhdGVJZH0gKiBmU2luWSR7cm90YXRlSWR9ICogZkNvc1gke3JvdGF0ZUlkfSAtIGZDb3NaJHtyb3RhdGVJZH0gKiBmU2luWCR7cm90YXRlSWR9LCBmQ29zWSR7cm90YXRlSWR9ICogZkNvc1gke3JvdGF0ZUlkfSwgMC4wLFxyXG4gICAgICAgICAgICAgIDAuMCwgMC4wLCAwLjAsIDEuMFxyXG4gICAgICAgICAgICAgIClgO1xyXG4gICAgICAgICAgICBjYXNlIFwic2NhbGVcIjpcclxuICAgICAgICAgICAgICByZXR1cm4gYG1hdDQoXHJcbiAgICAgICAgICAgICAgJHtfeH0sIDAuMCwgMC4wLCAwLjAsXHJcbiAgICAgICAgICAgICAgMC4wLCAke195fSwgMC4wLCAwLjAsXHJcbiAgICAgICAgICAgICAgMC4wLCAwLjAsICR7X3p9LCAwLjAsXHJcbiAgICAgICAgICAgICAgMC4wLCAwLjAsIDAuMCwgMS4wXHJcbiAgICAgICAgICAgICAgKWA7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgdGhyb3cgYEVycm9yIGluICR7UGFydGljbGVTeXN0ZW0ubmFtZX06IFwiJHtfdHJhbnNmb3JtYXRpb259XCIgaXMgbm90IGEgdHJhbnNmb3JtYXRpb25gO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnJlZHVjZSgoX2FjY3VtdWxhdG9yOiBzdHJpbmcsIF9jb2RlOiBzdHJpbmcpID0+IGAke19hY2N1bXVsYXRvcn0gKiBcXG4ke19jb2RlfWApO1xyXG4gICAgICBjb2RlICs9IFwiO1xcblwiO1xyXG5cclxuICAgICAgcmV0dXJuIGNvZGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJhdGVDb2xvcihfY29sb3I6IFBhcnRpY2xlRGF0YS5FeHByZXNzaW9uW10pOiBzdHJpbmcge1xyXG4gICAgICBpZiAoIV9jb2xvcikgcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgICBsZXQgcmdiYTogc3RyaW5nID0gW19jb2xvclswXSwgX2NvbG9yWzFdLCBfY29sb3JbMl0sIF9jb2xvclszXV1cclxuICAgICAgICAubWFwKChfdmFsdWUpOiBzdHJpbmcgPT4gX3ZhbHVlID8gUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5nZW5lcmF0ZUV4cHJlc3Npb24oX3ZhbHVlKSA6IFwiMS4wXCIpXHJcbiAgICAgICAgLmpvaW4oXCIsIFwiKTtcclxuXHJcbiAgICAgIHJldHVybiBgdmVjNCgke3JnYmF9KTtgO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdlbmVyYXRlRXhwcmVzc2lvbihfZXhwcmVzc2lvbjogUGFydGljbGVEYXRhLkV4cHJlc3Npb24pOiBzdHJpbmcge1xyXG4gICAgICBpZiAoUGFydGljbGVEYXRhLmlzRnVuY3Rpb24oX2V4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgbGV0IHBhcmFtZXRlcnM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgcGFyYW0gb2YgX2V4cHJlc3Npb24ucGFyYW1ldGVycykge1xyXG4gICAgICAgICAgcGFyYW1ldGVycy5wdXNoKFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZ2VuZXJhdGVFeHByZXNzaW9uKHBhcmFtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtLmdlbmVyYXRlRnVuY3Rpb24oX2V4cHJlc3Npb24uZnVuY3Rpb24sIHBhcmFtZXRlcnMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoUGFydGljbGVEYXRhLmlzVmFyaWFibGUoX2V4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIFBhcnRpY2xlRGF0YS5QUkVERUZJTkVEX1ZBUklBQkxFU1tfZXhwcmVzc2lvbi52YWx1ZV0gfHwgXCJmUGFydGljbGVTeXN0ZW1WYXJpYWJsZV9cIiArIF9leHByZXNzaW9uLnZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoUGFydGljbGVEYXRhLmlzQ29uc3RhbnQoX2V4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlOiBzdHJpbmcgPSBfZXhwcmVzc2lvbi52YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX0ke3ZhbHVlLmluY2x1ZGVzKFwiLlwiKSA/IFwiXCIgOiBcIi4wXCJ9YDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKFBhcnRpY2xlRGF0YS5pc0NvZGUoX2V4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgbGV0IGNvZGU6IHN0cmluZyA9IF9leHByZXNzaW9uLmNvZGVcclxuICAgICAgICAgIC5yZXBsYWNlQWxsKC9cXGJbYS16QS16XStcXHcqKD8hXFwoKVxcYi9nLCAoX21hdGNoKSA9PiBQYXJ0aWNsZURhdGEuUFJFREVGSU5FRF9WQVJJQUJMRVNbX21hdGNoXSB8fCBcImZQYXJ0aWNsZVN5c3RlbVZhcmlhYmxlX1wiICsgX21hdGNoKVxyXG4gICAgICAgICAgLnJlcGxhY2VBbGwoLyg/PCFcXC4pXFxiXFxkK1xcYig/IVxcLikvZywgKF9tYXRjaCkgPT4gX21hdGNoICsgXCIuMFwiKTtcclxuICAgICAgICBjb2RlID0gUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5yZXBsYWNlRnVuY3Rpb25zKGNvZGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gY29kZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhyb3cgYEVycm9yIGluICR7UGFydGljbGVTeXN0ZW0ubmFtZX06IGludmFsaWQgbm9kZSBzdHJ1Y3R1cmUgaW4gcGFydGljbGUgc3lzdGVtIHNlcmlhbGl6YXRpb25gO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdlbmVyYXRlRnVuY3Rpb24oX2Z1bmN0aW9uOiBQYXJ0aWNsZURhdGEuRlVOQ1RJT04sIF9wYXJhbWV0ZXJzOiBzdHJpbmdbXSk6IHN0cmluZyB7XHJcbiAgICAgIGlmIChfcGFyYW1ldGVycy5sZW5ndGggPCBQYXJ0aWNsZURhdGEuRlVOQ1RJT05fTUlOSU1VTV9QQVJBTUVURVJTW19mdW5jdGlvbl0pXHJcbiAgICAgICAgdGhyb3cgYEVycm9yIGluICR7UGFydGljbGVTeXN0ZW0ubmFtZX06IFwiJHtfZnVuY3Rpb259XCIgbmVlZHMgYXQgbGVhc3QgJHtQYXJ0aWNsZURhdGEuRlVOQ1RJT05fTUlOSU1VTV9QQVJBTUVURVJTW19mdW5jdGlvbl19IHBhcmFtZXRlcnNgO1xyXG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhQYXJ0aWNsZURhdGEuRlVOQ1RJT04pLmluY2x1ZGVzKF9mdW5jdGlvbikpXHJcbiAgICAgICAgcmV0dXJuIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uRlVOQ1RJT05TW19mdW5jdGlvbl0oX3BhcmFtZXRlcnMpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhyb3cgYEVycm9yIGluICR7UGFydGljbGVTeXN0ZW0ubmFtZX06IFwiJHtfZnVuY3Rpb259XCIgaXMgbm90IGFuIG9wZXJhdGlvbmA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVwbGFjZUZ1bmN0aW9ucyhfY29kZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgbGV0IGZ1bmN0aW9uUmVnZXg6IFJlZ0V4cCA9IC9cXGJbYS16QS16X10rXFx3KlxcKC9nO1xyXG4gICAgICBsZXQgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheTtcclxuICAgICAgd2hpbGUgKChtYXRjaCA9IGZ1bmN0aW9uUmVnZXguZXhlYyhfY29kZSkpICE9IG51bGwpIHtcclxuICAgICAgICBsZXQgZnVuY3Rpb25HZW5lcmF0b3I6IEZ1bmN0aW9uID0gUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS5GVU5DVElPTlNbPFBhcnRpY2xlRGF0YS5GVU5DVElPTj5tYXRjaFswXS5zbGljZSgwLCAtMSldO1xyXG4gICAgICAgIGlmICghZnVuY3Rpb25HZW5lcmF0b3IpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgbGV0IGNvbW1hSW5kaWNlczogbnVtYmVyW10gPSBbXTtcclxuICAgICAgICBsZXQgb3BlbkJyYWNrZXRzOiBudW1iZXIgPSAxO1xyXG4gICAgICAgIGxldCBhcmd1bWVudHNMYXN0SW5kZXg6IG51bWJlciA9IGZ1bmN0aW9uUmVnZXgubGFzdEluZGV4O1xyXG4gICAgICAgIHdoaWxlIChvcGVuQnJhY2tldHMgPiAwKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKF9jb2RlW2FyZ3VtZW50c0xhc3RJbmRleF0pIHtcclxuICAgICAgICAgICAgY2FzZSBcIihcIjpcclxuICAgICAgICAgICAgICBvcGVuQnJhY2tldHMrKztcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIilcIjpcclxuICAgICAgICAgICAgICBvcGVuQnJhY2tldHMtLTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIixcIjpcclxuICAgICAgICAgICAgICBpZiAob3BlbkJyYWNrZXRzID09IDEpXHJcbiAgICAgICAgICAgICAgICBjb21tYUluZGljZXMucHVzaChhcmd1bWVudHNMYXN0SW5kZXgpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYXJndW1lbnRzTGFzdEluZGV4Kys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgYXJnczogc3RyaW5nW10gPVxyXG4gICAgICAgICAgW2Z1bmN0aW9uUmVnZXgubGFzdEluZGV4IC0gMSwgLi4uY29tbWFJbmRpY2VzLCBhcmd1bWVudHNMYXN0SW5kZXggLSAxXS5yZWR1Y2U8c3RyaW5nW10+KChfYWNjdW11bGF0b3IsIF9wb3NpdGlvbiwgX2luZGV4LCBfcG9zaXRpb25zKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBfaW5kZXggPT0gX3Bvc2l0aW9ucy5sZW5ndGggLSAxID9cclxuICAgICAgICAgICAgICBfYWNjdW11bGF0b3IgOlxyXG4gICAgICAgICAgICAgIF9hY2N1bXVsYXRvci5jb25jYXQoX2NvZGUuc2xpY2UoX3Bvc2l0aW9uICsgMSwgX3Bvc2l0aW9uc1tfaW5kZXggKyAxXSkudHJpbSgpKTtcclxuICAgICAgICAgIH0sIFtdKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb25SZWdleC5sYXN0SW5kZXggPSBtYXRjaC5pbmRleDtcclxuICAgICAgICBfY29kZSA9IGAke19jb2RlLnNsaWNlKDAsIG1hdGNoLmluZGV4KX0oJHtmdW5jdGlvbkdlbmVyYXRvcihhcmdzKX0pJHtfY29kZS5zbGljZShhcmd1bWVudHNMYXN0SW5kZXgpfWA7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIF9jb2RlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQnVmZmVycyB0aGUgcmFuZG9tIG51bWJlciBkYXRhIGZvciB0aGUgcGFydGljbGUgc3lzdGVtICh7QGxpbmsgQ29tcG9uZW50UGFydGljbGVTeXN0ZW19KSBpbnRvIGEgV2ViR0wgVGV4dHVyZVxyXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyMlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvckNvbXBvbmVudFBhcnRpY2xlU3lzdGVtIHtcclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZXMgdGhlIGRlY29yYXRlZCBtZXRob2Qgd2l0aCB0aGUgc3RhdGljIG1ldGhvZCBvZiB0aGUgc2FtZSBuYW1lIG9mIGNsYXNzLiBVc2VkIGluIHtAbGluayBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbX1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWNvcmF0ZTxNIGV4dGVuZHMgKHRoaXM6IEdlbmVyYWwsIC4uLmFyZ3M6IEdlbmVyYWwpID0+IEdlbmVyYWw+KF9tZXRob2Q6IE0sIF9jb250ZXh0OiBDbGFzc01ldGhvZERlY29yYXRvckNvbnRleHQ8Q29tcG9uZW50UGFydGljbGVTeXN0ZW0sIE0+KTogTSB7XHJcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0aGlzLCBfY29udGV4dC5uYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVzZVJlbmRlckRhdGEodGhpczogQ29tcG9uZW50UGFydGljbGVTeXN0ZW0pOiB2b2lkIHtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5yZW5kZXJEYXRhKSB7XHJcbiAgICAgICAgY3JjMy5hY3RpdmVUZXh0dXJlKFRFWFRVUkVfTE9DQVRJT04uUEFSVElDTEUuVU5JVCk7IC8vIEFUVEVOVElPTiE6IGNoYW5naW5nIHRoaXMgaWQgcmVxdWlyZXMgY2hhbmdpbmcgb2YgY29ycmVzcG9uZGluZyBpZCBpbiBwYXJ0aWNsZSByZW5kZXIgbWV0aG9kLCB1c2UgY3RybCArIHNoaWZ0ICsgZiBzZWFyY2ghXHJcbiAgICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRoaXMucmVuZGVyRGF0YSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUgPSBSZW5kZXIuYXNzZXJ0PFdlYkdMVGV4dHVyZT4oY3JjMy5jcmVhdGVUZXh0dXJlKCkpO1xyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcblxyXG4gICAgICBsZXQgdGV4dHVyZVNpemU6IG51bWJlciA9IE1hdGguY2VpbChNYXRoLnNxcnQodGhpcy5zaXplKSk7XHJcbiAgICAgIHRleHR1cmVTaXplID0gTWF0aC5taW4odGV4dHVyZVNpemUsIGNyYzMuZ2V0UGFyYW1ldGVyKGNyYzMuTUFYX1RFWFRVUkVfU0laRSkpO1xyXG5cclxuICAgICAgLy8gVE9ETzogdXNlIGludGVybmFsIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLCBhZGRpdGlvbmFsbHkgbWF5YmUgdXNlIGEgc2VlZCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIHJlY3JlYXRlIHRoZSBzYW1lIHJhbmRvbSBudW1iZXJzXHJcbiAgICAgIGxldCByYW5kb21OdW1iZXJzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGV4dHVyZVNpemUgKiB0ZXh0dXJlU2l6ZTsgaSsrKVxyXG4gICAgICAgIHJhbmRvbU51bWJlcnMucHVzaChNYXRoLnJhbmRvbSgpKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY3JjMy50ZXhJbWFnZTJEKFxyXG4gICAgICAgICAgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlIzMkYsIHRleHR1cmVTaXplLCB0ZXh0dXJlU2l6ZSwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SRUQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRkxPQVQsXHJcbiAgICAgICAgICBGbG9hdDMyQXJyYXkuZnJvbShyYW5kb21OdW1iZXJzKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIERlYnVnLmVycm9yKF9lcnJvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShjcmMzLlRFWFRVUkVfMkQsIGNyYzMuVEVYVFVSRV9NSU5fRklMVEVSLCBjcmMzLk5FQVJFU1QpO1xyXG4gICAgICBjcmMzLnRleFBhcmFtZXRlcmkoY3JjMy5URVhUVVJFXzJELCBjcmMzLlRFWFRVUkVfTUFHX0ZJTFRFUiwgY3JjMy5ORUFSRVNUKTtcclxuXHJcbiAgICAgIHRoaXMucmVuZGVyRGF0YSA9IHRleHR1cmU7XHJcblxyXG4gICAgICB0aGlzLnVzZVJlbmRlckRhdGEoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlbGV0ZVJlbmRlckRhdGEodGhpczogQ29tcG9uZW50UGFydGljbGVTeXN0ZW0pOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLnJlbmRlckRhdGEpIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgbnVsbCk7XHJcbiAgICAgIGNyYzMuZGVsZXRlVGV4dHVyZSh0aGlzLnJlbmRlckRhdGEpO1xyXG4gICAgICBkZWxldGUgdGhpcy5yZW5kZXJEYXRhO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBJbnRlcmZhY2UgdG8gYmUgaW1wbGVtZW50ZWQgYnkgb2JqZWN0cyB0aGF0IGNhbiBiZSByZWN5Y2xlZCwgaS5lLiB0byBhdm9pZCBnYXJiYWdlIGNvbGxlY3Rpb24gYnkgcmV1c2luZyB0aGUgb2JqZWN0IGluc3RlYWQgb2YgcmVwbGFjaW5nIGl0IHdpdGggYSBuZXcgb25lLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVjeWNhYmxlIHtcclxuICAgIC8qKlxyXG4gICAgICogUmVjeWNsZXMgdGhlIG9iamVjdCBmb3IgdGhlIG5leHQgcmV1c2UgYnkgc2V0dGluZyBpdHMgcHJvcGVydGllcyB0byB0aGVpciBkZWZhdWx0IHN0YXRlcy5cclxuICAgICAqL1xyXG4gICAgcmVjeWNsZSgpOiB2b2lkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogS2VlcHMgYSBkZXBvdCBvZiBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZCBmb3IgcmV1c2UsIHNvcnRlZCBieSB0eXBlLiAgXHJcbiAgICogVXNpbmcge0BsaW5rIFJlY3ljbGVyfSByZWR1Y2VzIGxvYWQgb24gdGhlIGNhcmJhZ2UgY29sbGVjdG9yIGFuZCB0aHVzIHN1cHBvcnRzIHNtb290aCBwZXJmb3JtYW5jZS5cclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2hzLWZ1cnR3YW5nZW4vRlVER0Uvd2lraS9SZWN5Y2xlclxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWN5Y2xlciB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBkZXBvdDogeyBbdHlwZTogc3RyaW5nXTogUmVjeWNhYmxlQXJyYXk8T2JqZWN0PiB9ID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaGVzIGFuIG9iamVjdCBvZiB0aGUgcmVxdWVzdGVkIHR5cGUgZnJvbSB0aGUgZGVwb3QsIGNhbGxzIGl0cyByZWN5Y2xlLW1ldGhvZCBhbmQgcmV0dXJucyBpdC5cclxuICAgICAqIElmIHRoZSBkZXBvdCBmb3IgdGhhdCB0eXBlIGlzIGVtcHR5IGl0IHJldHVybnMgYSBuZXcgb2JqZWN0IG9mIHRoZSByZXF1ZXN0ZWQgdHlwZS5cclxuICAgICAqIEBwYXJhbSBfdCBUaGUgY2xhc3MgaWRlbnRpZmllciBvZiB0aGUgZGVzaXJlZCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQ8VCBleHRlbmRzIFJlY3ljYWJsZSB8IFJlY3ljYWJsZUFycmF5PFQ+IHwgT2JqZWN0PihfdDogbmV3ICgpID0+IFQpOiBUIHtcclxuICAgICAgbGV0IGluc3RhbmNlczogUmVjeWNhYmxlQXJyYXk8T2JqZWN0PiA9IFJlY3ljbGVyLmRlcG90W190Lm5hbWVdO1xyXG4gICAgICBpZiAoaW5zdGFuY2VzPy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlOiBUID0gPFQ+aW5zdGFuY2VzLnBvcCgpO1xyXG4gICAgICAgICg8UmVjeWNhYmxlPmluc3RhbmNlKS5yZWN5Y2xlPy4oKTtcclxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICAgIH0gZWxzZVxyXG4gICAgICAgIHJldHVybiBuZXcgX3QoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoZXMgYW4gb2JqZWN0IG9mIHRoZSByZXF1ZXN0ZWQgdHlwZSBmcm9tIHRoZSBkZXBvdCBhbmQgcmV0dXJucyBpdC4g4pqg77iPKipET0VTIE5PVCoqIGNhbGwgaXRzIHJlY3ljbGUtbWV0aG9kLlxyXG4gICAgICogRmFzdGVyIHRoYW4ge0BsaW5rIFJlY3ljbGVyLmdldH0sIGJ1dCBzaG91bGQgYmUgdXNlZCB3aXRoIGNhdXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmV1c2U8VCBleHRlbmRzIE9iamVjdD4oX3Q6IG5ldyAoKSA9PiBUKTogVCB7XHJcbiAgICAgIHJldHVybiA8VD5SZWN5Y2xlci5kZXBvdFtfdC5uYW1lXT8ucG9wKCkgPz8gbmV3IF90KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9yZXMgdGhlIG9iamVjdCBpbiB0aGUgZGVwb3QgZm9yIGxhdGVyIHJlY3ljbGluZy4gVXNlcnMgYXJlIHJlc3BvbnNpYmxlIGZvciB0aHJvd2luZyBpbiBvYmplY3RzIHRoYXQgYXJlIGFib3V0IHRvIGxvb3NlIHNjb3BlIGFuZCBhcmUgbm90IHJlZmVyZW5jZWQgYnkgYW55IG90aGVyXHJcbiAgICAgKiBAcGFyYW0gX2luc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc3RvcmUoX2luc3RhbmNlOiBPYmplY3QpOiB2b2lkIHtcclxuICAgICAgKFJlY3ljbGVyLmRlcG90W19pbnN0YW5jZS5jb25zdHJ1Y3Rvci5uYW1lXSA/Pz0gbmV3IFJlY3ljYWJsZUFycmF5PE9iamVjdD4oKSkucHVzaChfaW5zdGFuY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW1wdHlzIHRoZSBkZXBvdCBvZiBhIGdpdmVuIHR5cGUsIGxlYXZpbmcgdGhlIG9iamVjdHMgZm9yIHRoZSBnYXJiYWdlIGNvbGxlY3Rvci4gTWF5IHJlc3VsdCBpbiBhIHNob3J0IHN0YWxsIHdoZW4gbWFueSBvYmplY3RzIHdlcmUgaW5cclxuICAgICAqIEBwYXJhbSBfdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGR1bXA8VD4oX3Q6IG5ldyAoKSA9PiBUKTogdm9pZCB7XHJcbiAgICAgIFJlY3ljbGVyLmRlcG90W190Lm5hbWVdID0gbmV3IFJlY3ljYWJsZUFycmF5PE9iamVjdD4oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVtcHR5cyBhbGwgZGVwb3RzLCBsZWF2aW5nIGFsbCBvYmplY3RzIHRvIHRoZSBnYXJiYWdlIGNvbGxlY3Rvci4gTWF5IHJlc3VsdCBpbiBhIHNob3J0IHN0YWxsIHdoZW4gbWFueSBvYmplY3RzIHdlcmUgaW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkdW1wQWxsKCk6IHZvaWQge1xyXG4gICAgICBSZWN5Y2xlci5kZXBvdCA9IHt9O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFN0b3JlcyBhbmQgbWFuaXB1bGF0ZXMgYSB0d29kaW1lbnNpb25hbCB2ZWN0b3IgY29tcHJpc2VkIG9mIHRoZSBjb21wb25lbnRzIHggYW5kIHlcclxuICAgKiBgYGB0ZXh0XHJcbiAgICogICAgICAgICAgICAreVxyXG4gICAqICAgICAgICAgICAgIHxfXyAreFxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEx1a2FzIFNjaGV1ZXJsZSwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTkgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjVcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVmVjdG9yMiBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUsIFJlY3ljYWJsZSB7XHJcbiAgICBwdWJsaWMgeDogbnVtYmVyO1xyXG4gICAgcHVibGljIHk6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2V0KF94LCBfeSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFN0YXRpY1xyXG4gICAgLyoqIFxyXG4gICAgICogQSBzaG9ydGhhbmQgZm9yIHdyaXRpbmcgYG5ldyBWZWN0b3IyKDAsIDApYC5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB3aXRoIHRoZSB2YWx1ZXMgKDAsIDApXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgWkVSTygpOiBWZWN0b3IyIHtcclxuICAgICAgcmV0dXJuIFJlY3ljbGVyLmdldChWZWN0b3IyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBIHNob3J0aGFuZCBmb3Igd3JpdGluZyBgbmV3IFZlY3RvcjIoX3NjYWxlLCBfc2NhbGUpYC5cclxuICAgICAqIEBwYXJhbSBfc2NhbGUgdGhlIHNjYWxlIG9mIHRoZSB2ZWN0b3IuIERlZmF1bHQ6IDFcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBPTkUoX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiBSZWN5Y2xlci5yZXVzZShWZWN0b3IyKS5zZXQoX3NjYWxlLCBfc2NhbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEEgc2hvcnRoYW5kIGZvciB3cml0aW5nIGBuZXcgVmVjdG9yMih4LCAwKWAuXHJcbiAgICAgKiBAcGFyYW0gX3NjYWxlIFRoZSBudW1iZXIgdG8gd3JpdGUgaW4gdGhlIHggY29vcmRpbmF0ZS4gRGVmYXVsdDogMVxyXG4gICAgICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHdpdGggdGhlIHZhbHVlcyAoX3NjYWxlLCAwKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFgoX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiBSZWN5Y2xlci5yZXVzZShWZWN0b3IyKS5zZXQoX3NjYWxlLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBIHNob3J0aGFuZCBmb3Igd3JpdGluZyBgbmV3IFZlY3RvcjIoMCwgeSlgLlxyXG4gICAgICogQHBhcmFtIF9zY2FsZSBUaGUgbnVtYmVyIHRvIHdyaXRlIGluIHRoZSB5IGNvb3JkaW5hdGUuIERlZmF1bHQ6IDFcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB3aXRoIHRoZSB2YWx1ZXMgKDAsIF9zY2FsZSlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBZKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjIge1xyXG4gICAgICByZXR1cm4gUmVjeWNsZXIucmV1c2UoVmVjdG9yMikuc2V0KDAsIF9zY2FsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIHRocm91Z2ggdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHZlY3RvciBieSB0aGUgZ2l2ZW4gbWF0cml4XHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUUkFOU0ZPUk1BVElPTihfdmVjdG9yOiBWZWN0b3IyLCBfbXR4VHJhbnNmb3JtOiBNYXRyaXgzeDMsIF9pbmNsdWRlVHJhbnNsYXRpb246IGJvb2xlYW4gPSB0cnVlLCBfb3V0OiBWZWN0b3IyID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMikpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IG06IEFycmF5TGlrZTxudW1iZXI+ID0gX210eFRyYW5zZm9ybS5nZXRBcnJheSgpO1xyXG5cclxuICAgICAgX291dC5zZXQoXHJcbiAgICAgICAgbVswXSAqIF92ZWN0b3IueCArIG1bM10gKiBfdmVjdG9yLnksXHJcbiAgICAgICAgbVsxXSAqIF92ZWN0b3IueCArIG1bNF0gKiBfdmVjdG9yLnlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmIChfaW5jbHVkZVRyYW5zbGF0aW9uKVxyXG4gICAgICAgIF9vdXQuYWRkKF9tdHhUcmFuc2Zvcm0udHJhbnNsYXRpb24pO1xyXG5cclxuICAgICAgcmV0dXJuIF9vdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIHdoaWNoIGlzIGEgY29weSBvZiB0aGUgZ2l2ZW4gdmVjdG9yIHNjYWxlZCB0byB0aGUgZ2l2ZW4gbGVuZ3RoLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTk9STUFMSVpBVElPTihfdmVjdG9yOiBWZWN0b3IyLCBfbGVuZ3RoOiBudW1iZXIgPSAxLCBfb3V0OiBWZWN0b3IyID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMikpOiBWZWN0b3IyIHtcclxuICAgICAgcmV0dXJuIF9vdXQuY29weShfdmVjdG9yKS5ub3JtYWxpemUoX2xlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIHNjYWxpbmcgZmFjdG9yXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTQ0FMRShfdmVjdG9yOiBWZWN0b3IyLCBfc2NhbGU6IG51bWJlciwgX291dDogVmVjdG9yMiA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjIpKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiBfb3V0LnNldChfdmVjdG9yLnggKiBfc2NhbGUsIF92ZWN0b3IueSAqIF9zY2FsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uIG9mIHR3byB2ZWN0b3JzLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU1VNKF9hOiBWZWN0b3IyLCBfYjogVmVjdG9yMiwgX291dDogVmVjdG9yMiA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjIpKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiBfb3V0LnNldChfYS54ICsgX2IueCwgX2EueSArIF9iLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbiBvZiB0d28gdmVjdG9ycy5cclxuICAgICAqIEBwYXJhbSBfb3V0IE9wdGlvbmFsIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERJRkZFUkVOQ0UoX21pbnVlbmQ6IFZlY3RvcjIsIF9zdWJ0cmFoZW5kOiBWZWN0b3IyLCBfb3V0OiBWZWN0b3IyID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMikpOiBWZWN0b3IyIHtcclxuICAgICAgcmV0dXJuIF9vdXQuc2V0KF9taW51ZW5kLnggLSBfc3VidHJhaGVuZC54LCBfbWludWVuZC55IC0gX3N1YnRyYWhlbmQueSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIHNjYWxpbmcgZmFjdG9yLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTkVHQVRJT04oX3ZlY3RvcjogVmVjdG9yMiwgX291dDogVmVjdG9yMiA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjIpKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiBfb3V0LnNldCgtX3ZlY3Rvci54LCAtX3ZlY3Rvci55KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIFZlY3RvcnMuIER1ZSB0byB0aGVtIGJlaW5nIG9ubHkgMiBEaW1lbnNpb25hbCwgdGhlIHJlc3VsdCBpcyBhIHNpbmdsZSBudW1iZXIsXHJcbiAgICAgKiB3aGljaCBpbXBsaWNpdGx5IGlzIG9uIHRoZSBaIGF4aXMuIEl0IGlzIGFsc28gdGhlIHNpZ25lZCBtYWduaXR1ZGUgb2YgdGhlIHJlc3VsdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBDUk9TUyhfYTogVmVjdG9yMiwgX2I6IFZlY3RvcjIpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gX2EueCAqIF9iLnkgLSBfYS55ICogX2IueDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBkb3Rwcm9kdWN0IG9mIDIgdmVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBET1QoX2E6IFZlY3RvcjIsIF9iOiBWZWN0b3IyKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIF9hLnggKiBfYi54ICsgX2EueSAqIF9iLnk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBvcnRob2dvbmFsIHZlY3RvciB0byB0aGUgZ2l2ZW4gdmVjdG9yLiBSb3RhdGVzIGNvdW50ZXJjbG9ja3dpc2UgYnkgZGVmYXVsdC5cclxuICAgICAqIGBgYHRleHRcclxuICAgICAqIOKGkSA9PiDihpAgPT4g4oaTID0+IOKGkiA9PiDihpFcclxuICAgICAqIGBgYFxyXG4gICAgICogQHBhcmFtIF92ZWN0b3IgVmVjdG9yIHRvIGdldCB0aGUgb3J0aG9nb25hbCBlcXVpdmFsZW50IG9mXHJcbiAgICAgKiBAcGFyYW0gX2Nsb2Nrd2lzZSBTaG91bGQgdGhlIHJvdGF0aW9uIGJlIGNsb2Nrd2lzZSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGNvdW50ZXJjbG9ja3dpc2U/IGRlZmF1bHQ6IGZhbHNlXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqIEByZXR1cm5zIEEgVmVjdG9yIHRoYXQgaXMgb3J0aG9nb25hbCB0byBhbmQgaGFzIHRoZSBzYW1lIG1hZ25pdHVkZSBhcyB0aGUgZ2l2ZW4gVmVjdG9yLiAgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgT1JUSE9HT05BTChfdmVjdG9yOiBWZWN0b3IyLCBfY2xvY2t3aXNlOiBib29sZWFuID0gZmFsc2UsIF9vdXQ6IFZlY3RvcjIgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IyKSk6IFZlY3RvcjIge1xyXG4gICAgICBpZiAoX2Nsb2Nrd2lzZSlcclxuICAgICAgICByZXR1cm4gX291dC5zZXQoX3ZlY3Rvci55LCAtX3ZlY3Rvci54KTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBfb3V0LnNldCgtX3ZlY3Rvci55LCBfdmVjdG9yLngpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNhcnRlc2lhbiB2ZWN0b3IgZnJvbSBwb2xhciBjb29yZGluYXRlcy5cclxuICAgICAqIEBwYXJhbSBfb3V0IE9wdGlvbmFsIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEdFTyhfYW5nbGU6IG51bWJlciA9IDAsIF9tYWduaXR1ZGU6IG51bWJlciA9IDEsIF9vdXQ6IFZlY3RvcjIgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IyKSk6IFZlY3RvcjIge1xyXG4gICAgICBjb25zdCBnZW86IEdlbzIgPSBSZWN5Y2xlci5yZXVzZShHZW8yKS5zZXQoX2FuZ2xlLCBfbWFnbml0dWRlKTtcclxuICAgICAgX291dC5nZW8gPSBnZW87XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKGdlbyk7XHJcbiAgICAgIHJldHVybiBfb3V0O1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIEFjY2Vzc29yc1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1hZ25pdHVkZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzcXVhcmUgb2YgdGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yIHdpdGhvdXQgY2FsY3VsYXRpbmcgYSBzcXVhcmUgcm9vdC4gRmFzdGVyIGZvciBzaW1wbGUgcHJveGltaXR5IGV2YWx1YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWFnbml0dWRlU3F1YXJlZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogLSBnZXQ6IFJldHVybnMgYSBwb2xhciByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZlY3RvclxyXG4gICAgICogLSBzZXQ6IEFkanVzdHMgdGhlIGNhcnRlc2lhbiB2YWx1ZXMgb2YgdGhpcyB2ZWN0b3IgdG8gcmVwcmVzZW50IHRoZSBnaXZlbiBhcyBwb2xhciBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGdlbygpOiBHZW8yIHtcclxuICAgICAgbGV0IGdlbzogR2VvMiA9IFJlY3ljbGVyLmdldChHZW8yKTtcclxuICAgICAgZ2VvLm1hZ25pdHVkZSA9IHRoaXMubWFnbml0dWRlO1xyXG5cclxuICAgICAgaWYgKGdlby5tYWduaXR1ZGUgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIGdlbztcclxuXHJcbiAgICAgIGdlby5hbmdsZSA9IDE4MCAqIE1hdGguYXRhbjIodGhpcy55IC8gZ2VvLm1hZ25pdHVkZSwgdGhpcy54IC8gZ2VvLm1hZ25pdHVkZSkgLyBNYXRoLlBJO1xyXG4gICAgICByZXR1cm4gZ2VvO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgZ2VvKF9nZW86IEdlbzIpIHtcclxuICAgICAgdGhpcy5zZXQoX2dlby5tYWduaXR1ZGUsIDApO1xyXG4gICAgICBjb25zdCByb3RhdGlvbjogTWF0cml4M3gzID0gTWF0cml4M3gzLlJPVEFUSU9OKF9nZW8uYW5nbGUpO1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybShyb3RhdGlvbik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJvdGF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBjbG9uZSBvZiB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBjbG9uZSgpOiBWZWN0b3IyIHtcclxuICAgICAgcmV0dXJuIFJlY3ljbGVyLnJldXNlKFZlY3RvcjIpLmNvcHkodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyB0aGUgY29tcG9uZW50cyBvZiB0aGUgZ2l2ZW4gdmVjdG9yIGludG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvcHkoX29yaWdpbmFsOiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIHRoaXMueCA9IF9vcmlnaW5hbC54O1xyXG4gICAgICB0aGlzLnkgPSBfb3JpZ2luYWwueTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwKTogVmVjdG9yMiB7XHJcbiAgICAgIHRoaXMueCA9IF94O1xyXG4gICAgICB0aGlzLnkgPSBfeTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0KDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb29yZGluYXRlcyBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yIGFyZSB0byBiZSBjb25zaWRlcmVkIGlkZW50aWNhbCB3aXRoaW4gdGhlIGdpdmVuIHRvbGVyYW5jZVxyXG4gICAgICogVE9ETzogZXhhbWluZSwgaWYgdG9sZXJhbmNlIGFzIGNyaXRlcml1bSBmb3IgdGhlIGRpZmZlcmVuY2UgaXMgYXBwcm9wcmlhdGUgd2l0aCB2ZXJ5IGxhcmdlIGNvb3JkaW5hdGUgdmFsdWVzIG9yIGlmIF90b2xlcmFuY2Ugc2hvdWxkIGJlIG11bHRpcGxpZWQgYnkgY29vcmRpbmF0ZSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZXF1YWxzKF9jb21wYXJlOiBWZWN0b3IyLCBfdG9sZXJhbmNlOiBudW1iZXIgPSBOdW1iZXIuRVBTSUxPTik6IGJvb2xlYW4ge1xyXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy54IC0gX2NvbXBhcmUueCkgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnkgLSBfY29tcGFyZS55KSA+IF90b2xlcmFuY2UpIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXd0d2VlbiB0aGlzIHZlY3RvciBhbmQgdGhlIGdpdmVuIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldERpc3RhbmNlKF90bzogVmVjdG9yMik6IG51bWJlciB7XHJcbiAgICAgIGxldCBkaWZmZXJlbmNlOiBWZWN0b3IyID0gVmVjdG9yMi5ESUZGRVJFTkNFKHRoaXMsIF90byk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKGRpZmZlcmVuY2UpO1xyXG4gICAgICByZXR1cm4gZGlmZmVyZW5jZS5tYWduaXR1ZGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZChfYWRkZW5kOiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIHRoaXMueCArPSBfYWRkZW5kLng7XHJcbiAgICAgIHRoaXMueSArPSBfYWRkZW5kLnk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIHRoZSBnaXZlbiB2ZWN0b3IgZnJvbSB0aGlzIHZlY3Rvci5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VidHJhY3QoX3N1YnRyYWhlbmQ6IFZlY3RvcjIpOiBWZWN0b3IyIHtcclxuICAgICAgdGhpcy54IC09IF9zdWJ0cmFoZW5kLng7XHJcbiAgICAgIHRoaXMueSAtPSBfc3VidHJhaGVuZC55O1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlcyB0aGUgVmVjdG9yIGJ5IHRoZSBnaXZlbiBfc2NhbGFyLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZShfc2NhbGFyOiBudW1iZXIpOiBWZWN0b3IyIHtcclxuICAgICAgdGhpcy54ICo9IF9zY2FsYXI7XHJcbiAgICAgIHRoaXMueSAqPSBfc2NhbGFyO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE5lZ2F0ZXMgdGhpcyB2ZWN0b3IgYnkgZmxpcHBpbmcgdGhlIHNpZ25zIG9mIGl0cyBjb21wb25lbnRzXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5lZ2F0ZSgpOiBWZWN0b3IyIHtcclxuICAgICAgdGhpcy54ID0gLXRoaXMueDtcclxuICAgICAgdGhpcy55ID0gLXRoaXMueTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemVzIHRoaXMgdG8gdGhlIGdpdmVuIGxlbmd0aCwgMSBieSBkZWZhdWx0XHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vcm1hbGl6ZShfbGVuZ3RoOiBudW1iZXIgPSAxKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBtYWduaXR1ZGVTcXVhcmVkOiBudW1iZXIgPSB0aGlzLm1hZ25pdHVkZVNxdWFyZWQ7XHJcbiAgICAgIGlmIChtYWduaXR1ZGVTcXVhcmVkID09IDApXHJcbiAgICAgICAgdGhyb3cgKG5ldyBSYW5nZUVycm9yKFwiSW1wb3NzaWJsZSBub3JtYWxpemF0aW9uXCIpKTtcclxuXHJcbiAgICAgIHRoaXMuc2NhbGUoX2xlbmd0aCAvIE1hdGguc3FydChtYWduaXR1ZGVTcXVhcmVkKSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtcyB0aGlzIHZlY3RvciBieSB0aGUgZ2l2ZW4gbWF0cml4LCBpbmNsdWRpbmcgb3IgZXhsdWRpbmcgdGhlIHRyYW5zbGF0aW9uLlxyXG4gICAgICogSW5jbHVkaW5nIGlzIHRoZSBkZWZhdWx0LCBleGNsdWRpbmcgd2lsbCBvbmx5IHJvdGF0ZSBhbmQgc2NhbGUgdGhpcyB2ZWN0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zZm9ybShfbXR4VHJhbnNmb3JtOiBNYXRyaXgzeDMsIF9pbmNsdWRlVHJhbnNsYXRpb246IGJvb2xlYW4gPSB0cnVlKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiBWZWN0b3IyLlRSQU5TRk9STUFUSU9OKHRoaXMsIF9tdHhUcmFuc2Zvcm0sIF9pbmNsdWRlVHJhbnNsYXRpb24sIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yIGVhY2ggZGltZW5zaW9uLCBtb3ZlcyB0aGUgY29tcG9uZW50IHRvIHRoZSBtaW5pbXVtIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiB2ZWN0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG1pbihfY29tcGFyZTogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICB0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIF9jb21wYXJlLngpO1xyXG4gICAgICB0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIF9jb21wYXJlLnkpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvciBlYWNoIGRpbWVuc2lvbiwgbW92ZXMgdGhlIGNvbXBvbmVudCB0byB0aGUgbWF4aW11bSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtYXgoX2NvbXBhcmU6IFZlY3RvcjIpOiBWZWN0b3IyIHtcclxuICAgICAgdGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCBfY29tcGFyZS54KTtcclxuICAgICAgdGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCBfY29tcGFyZS55KTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxscyBhIGRlZmluZWQgY2FsbGJhY2sgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvciwgYW5kIHJldHVybnMgYSBuZXcgdmVjdG9yIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdHMuIFNpbWlsYXIgdG8ge0BsaW5rIEFycmF5Lm1hcH0uXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG1hcChfZnVuY3Rpb246IChfdmFsdWU6IG51bWJlciwgX2luZGV4OiBudW1iZXIsIF9jb21wb25lbnQ6IFwieFwiIHwgXCJ5XCIsIF92ZWN0b3I6IFZlY3RvcjIpID0+IG51bWJlciwgX291dDogVmVjdG9yMiA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjIpKTogVmVjdG9yMiB7XHJcbiAgICAgIF9vdXQueCA9IF9mdW5jdGlvbih0aGlzLngsIDAsIFwieFwiLCB0aGlzKTtcclxuICAgICAgX291dC55ID0gX2Z1bmN0aW9uKHRoaXMueSwgMSwgXCJ5XCIsIHRoaXMpO1xyXG4gICAgICByZXR1cm4gX291dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIGEgZGVmaW5lZCBjYWxsYmFjayBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yIGFuZCBhc3NpZ25zIHRoZSByZXN1bHQgdG8gdGhlIGNvbXBvbmVudC4gU2ltaWxhciB0byB7QGxpbmsgVmVjdG9yMi5tYXB9IGJ1dCBtdXRhdGVzIHRoaXMgdmVjdG9yIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgb25lLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhcHBseShfZnVuY3Rpb246IChfdmFsdWU6IG51bWJlciwgX2luZGV4OiBudW1iZXIsIF9jb21wb25lbnQ6IFwieFwiIHwgXCJ5XCIsIF92ZWN0b3I6IFZlY3RvcjIpID0+IG51bWJlcik6IFZlY3RvcjIge1xyXG4gICAgICB0aGlzLnggPSBfZnVuY3Rpb24odGhpcy54LCAwLCBcInhcIiwgdGhpcyk7XHJcbiAgICAgIHRoaXMueSA9IF9mdW5jdGlvbih0aGlzLnksIDEsIFwieVwiLCB0aGlzKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0KCk6IEZsb2F0MzJBcnJheSB7IC8vIFRPRE86IHJlbmFtZSB0byBnZXRBcnJheSwgYWxsb3cgcGFzc2luZyBvZiBhbiBhcnJheSBpbnRvIHRoaXMgbWV0aG9kIHRvIGF2b2lkIGFsbG9jYXRpb25cclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW3RoaXMueCwgdGhpcy55XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5cyB0aGUgZWxlbWVudHMgb2YgdGhpcyB2ZWN0b3IgaW50byB0aGUgZ2l2ZW4gYXJyYXkgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIG9mZnNldC5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoZSBnaXZlbiBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvQXJyYXk8VCBleHRlbmRzIHsgW246IG51bWJlcl06IG51bWJlciB9Pihfb3V0OiBULCBfb2Zmc2V0OiBudW1iZXIgPSAwKTogVCB7XHJcbiAgICAgIF9vdXRbX29mZnNldF0gPSB0aGlzLng7XHJcbiAgICAgIF9vdXRbX29mZnNldCArIDFdID0gdGhpcy55O1xyXG5cclxuICAgICAgcmV0dXJuIF9vdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgei1jb21wb25lbnQgb2YgdGhlIGdpdmVuIG1hZ25pdHVkZSAoZGVmYXVsdD0wKSB0byB0aGUgdmVjdG9yIGFuZCByZXR1cm5zIGEgbmV3IFZlY3RvcjMuXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvVmVjdG9yMyhfejogbnVtYmVyID0gMCwgX291dDogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBfb3V0LnNldCh0aGlzLngsIHRoaXMueSwgX3opO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICBsZXQgcmVzdWx0OiBzdHJpbmcgPSBgKCR7dGhpcy54LnRvUHJlY2lzaW9uKDUpfSwgJHt0aGlzLnkudG9QcmVjaXNpb24oNSl9KWA7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgICAvLyBzZXJpYWxpemF0aW9uLnRvSlNPTiA9ICgpID0+IHsgcmV0dXJuIGB7IFwiclwiOiAke3RoaXMucn0sIFwiZ1wiOiAke3RoaXMuZ30sIFwiYlwiOiAke3RoaXMuYn0sIFwiYVwiOiAke3RoaXMuYX19YDsgfTtcclxuICAgICAgc2VyaWFsaXphdGlvbi50b0pTT04gPSAoKSA9PiB7IHJldHVybiBgWyR7dGhpcy54fSwgJHt0aGlzLnl9XWA7IH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8VmVjdG9yMj4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfc2VyaWFsaXphdGlvbikgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIFt0aGlzLngsIHRoaXMueV0gPSBKU09OLnBhcnNlKDxzdHJpbmc+PHVua25vd24+X3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB9IGVsc2VcclxuICAgICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB4OiB0aGlzLngsIHk6IHRoaXMueVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb3ZlcnJpZGUgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGlmIChfbXV0YXRvci54ICE9IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLnggPSBfbXV0YXRvci54O1xyXG4gICAgICBpZiAoX211dGF0b3IueSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy55ID0gX211dGF0b3IueTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCIuLi9SZWN5Y2xlL1JlY3ljbGVyLnRzXCIvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJWZWN0b3IyLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyB0aGUgb3JpZ2luIG9mIGEgcmVjdGFuZ2xlXHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gT1JJR0lOMkQge1xyXG4gICAgVE9QTEVGVCA9IDB4MDAsXHJcbiAgICBUT1BDRU5URVIgPSAweDAxLFxyXG4gICAgVE9QUklHSFQgPSAweDAyLFxyXG4gICAgQ0VOVEVSTEVGVCA9IDB4MTAsXHJcbiAgICBDRU5URVIgPSAweDExLFxyXG4gICAgQ0VOVEVSUklHSFQgPSAweDEyLFxyXG4gICAgQk9UVE9NTEVGVCA9IDB4MjAsXHJcbiAgICBCT1RUT01DRU5URVIgPSAweDIxLFxyXG4gICAgQk9UVE9NUklHSFQgPSAweDIyXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWZpbmVzIGEgcmVjdGFuZ2xlIHdpdGggcG9zaXRpb24gYW5kIHNpemUgYW5kIGFkZCBjb21mb3J0YWJsZSBtZXRob2RzIHRvIGl0XHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZWN0YW5nbGUgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgUmVjeWNhYmxlIHtcclxuICAgIHB1YmxpYyBwb3NpdGlvbjogVmVjdG9yMiA9IFJlY3ljbGVyLmdldChWZWN0b3IyKTtcclxuICAgIHB1YmxpYyBzaXplOiBWZWN0b3IyID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjIpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF93aWR0aDogbnVtYmVyID0gMSwgX2hlaWdodDogbnVtYmVyID0gMSwgX29yaWdpbjogT1JJR0lOMkQgPSBPUklHSU4yRC5UT1BMRUZUKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2V0UG9zaXRpb25BbmRTaXplKF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0LCBfb3JpZ2luKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIGNyZWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cclxuICAgICAqIEBwYXJhbSBfb3V0IE9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEdFVChfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF93aWR0aDogbnVtYmVyID0gMSwgX2hlaWdodDogbnVtYmVyID0gMSwgX29yaWdpbjogT1JJR0lOMkQgPSBPUklHSU4yRC5UT1BMRUZULCBfb3V0OiBSZWN0YW5nbGUgPSBSZWN5Y2xlci5yZXVzZShSZWN0YW5nbGUpKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIF9vdXQuc2V0UG9zaXRpb25BbmRTaXplKF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0LCBfb3JpZ2luKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHgoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHgoX3g6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnBvc2l0aW9uLnggPSBfeDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHkoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHkoX3k6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnBvc2l0aW9uLnkgPSBfeTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHdpZHRoKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNpemUueDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHdpZHRoKF93aWR0aDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS54ID0gX3dpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaGVpZ2h0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNpemUueTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGhlaWdodChfaGVpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zaXplLnkgPSBfaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0L3NldCB0aGUgbGVmdG1vc3QgZXhwYW5zaW9uLCByZXNwZWN0aW5nIGFsc28gbmVnYXRpdmUgdmFsdWVzIG9mIHdpZHRoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbGVmdCgpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5zaXplLnggPiAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XHJcbiAgICAgIHJldHVybiAodGhpcy5wb3NpdGlvbi54ICsgdGhpcy5zaXplLngpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgbGVmdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLnNpemUueCA9IHRoaXMucmlnaHQgLSBfdmFsdWU7XHJcbiAgICAgIHRoaXMucG9zaXRpb24ueCA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldC9zZXQgdGhlIHRvcG1vc3QgZXhwYW5zaW9uLCByZXNwZWN0aW5nIGFsc28gbmVnYXRpdmUgdmFsdWVzIG9mIGhlaWdodFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHRvcCgpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5zaXplLnkgPiAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XHJcbiAgICAgIHJldHVybiAodGhpcy5wb3NpdGlvbi55ICsgdGhpcy5zaXplLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgdG9wKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS55ID0gdGhpcy5ib3R0b20gLSBfdmFsdWU7XHJcbiAgICAgIHRoaXMucG9zaXRpb24ueSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldC9zZXQgdGhlIHJpZ2h0bW9zdCBleHBhbnNpb24sIHJlc3BlY3RpbmcgYWxzbyBuZWdhdGl2ZSB2YWx1ZXMgb2Ygd2lkdGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCByaWdodCgpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5zaXplLnggPiAwKVxyXG4gICAgICAgIHJldHVybiAodGhpcy5wb3NpdGlvbi54ICsgdGhpcy5zaXplLngpO1xyXG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgcmlnaHQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5zaXplLnggPSB0aGlzLnBvc2l0aW9uLnggKyBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQvc2V0IHRoZSBsb3dlc3QgZXhwYW5zaW9uLCByZXNwZWN0aW5nIGFsc28gbmVnYXRpdmUgdmFsdWVzIG9mIGhlaWdodFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGJvdHRvbSgpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy5zaXplLnkgPiAwKVxyXG4gICAgICAgIHJldHVybiAodGhpcy5wb3NpdGlvbi55ICsgdGhpcy5zaXplLnkpO1xyXG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgYm90dG9tKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS55ID0gdGhpcy5wb3NpdGlvbi55ICsgX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgY2xvbmUoKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIFJlY3ljbGVyLnJldXNlKFJlY3RhbmdsZSkuY29weSh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkFuZFNpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHJlY3RhbmdsZSBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gcmVjdGFnbmxlIHdpdGhpbiB0aGUgZ2l2ZW4gdG9sZXJhbmNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZXF1YWxzKF9jb21wYXJlOiBSZWN0YW5nbGUsIF90b2xlcmFuY2U6IG51bWJlciA9IE51bWJlci5FUFNJTE9OKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnggLSBfY29tcGFyZS54KSA8PSBfdG9sZXJhbmNlICYmXHJcbiAgICAgICAgTWF0aC5hYnModGhpcy55IC0gX2NvbXBhcmUueSkgPD0gX3RvbGVyYW5jZSAmJlxyXG4gICAgICAgIE1hdGguYWJzKHRoaXMud2lkdGggLSBfY29tcGFyZS53aWR0aCkgPD0gX3RvbGVyYW5jZSAmJlxyXG4gICAgICAgIE1hdGguYWJzKHRoaXMuaGVpZ2h0IC0gX2NvbXBhcmUuaGVpZ2h0KSA8PSBfdG9sZXJhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoaXMgcmVjdGFuZ2xlIHRvIHRoZSB2YWx1ZXMgZ2l2ZW4gYnkgdGhlIHJlY3RhbmdsZSBwcm92aWRlZC5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29weShfcmVjdDogUmVjdGFuZ2xlKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2V0UG9zaXRpb25BbmRTaXplKF9yZWN0LngsIF9yZWN0LnksIF9yZWN0LndpZHRoLCBfcmVjdC5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIHJlY3RhbmdsZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcGFyYW0gX29yaWdpbiBUaGUgb3JpZ2luIG9mIHRoZSByZWN0YW5nbGUuIFRoZSBkZWZhdWx0IGlzIHtAbGluayBPUklHSU4yRC5UT1BMRUZUfS5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgcmVjdGFuZ2xlLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBzZXR9IGluc3RlYWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRQb3NpdGlvbkFuZFNpemUoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfd2lkdGg6IG51bWJlciA9IDEsIF9oZWlnaHQ6IG51bWJlciA9IDEsIF9vcmlnaW46IE9SSUdJTjJEID0gT1JJR0lOMkQuVE9QTEVGVCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNldChfeCwgX3ksIF93aWR0aCwgX2hlaWdodCwgX29yaWdpbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgcmVjdGFuZ2xlIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cclxuICAgICAqIEBwYXJhbSBfb3JpZ2luIFRoZSBvcmlnaW4gb2YgdGhlIHJlY3RhbmdsZS4gVGhlIGRlZmF1bHQgaXMge0BsaW5rIE9SSUdJTjJELlRPUExFRlR9LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX3g6IG51bWJlciA9IDAsIF95OiBudW1iZXIgPSAwLCBfd2lkdGg6IG51bWJlciA9IDEsIF9oZWlnaHQ6IG51bWJlciA9IDEsIF9vcmlnaW46IE9SSUdJTjJEID0gT1JJR0lOMkQuVE9QTEVGVCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHRoaXMuc2l6ZS5zZXQoX3dpZHRoLCBfaGVpZ2h0KTtcclxuICAgICAgc3dpdGNoIChfb3JpZ2luICYgMHgwMykge1xyXG4gICAgICAgIGNhc2UgMHgwMDogdGhpcy5wb3NpdGlvbi54ID0gX3g7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMHgwMTogdGhpcy5wb3NpdGlvbi54ID0gX3ggLSBfd2lkdGggLyAyOyBicmVhaztcclxuICAgICAgICBjYXNlIDB4MDI6IHRoaXMucG9zaXRpb24ueCA9IF94IC0gX3dpZHRoOyBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKF9vcmlnaW4gJiAweDMwKSB7XHJcbiAgICAgICAgY2FzZSAweDAwOiB0aGlzLnBvc2l0aW9uLnkgPSBfeTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAweDEwOiB0aGlzLnBvc2l0aW9uLnkgPSBfeSAtIF9oZWlnaHQgLyAyOyBicmVhaztcclxuICAgICAgICBjYXNlIDB4MjA6IHRoaXMucG9zaXRpb24ueSA9IF95IC0gX2hlaWdodDsgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoaXMgcmVjdGFuZ2xlcyBzcGFjZSB0byB0aGUgdGFyZ2V0IHJlY3RhbmdsZXMgc3BhY2UuXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvaW50VG9SZWN0KF9wb2ludDogVmVjdG9yMiwgX3RhcmdldDogUmVjdGFuZ2xlLCBfb3V0OiBWZWN0b3IyID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMikpOiBWZWN0b3IyIHtcclxuICAgICAgX291dC5jb3B5KF9wb2ludCk7XHJcbiAgICAgIF9vdXQuc3VidHJhY3QodGhpcy5wb3NpdGlvbik7XHJcbiAgICAgIF9vdXQueCAqPSBfdGFyZ2V0LndpZHRoIC8gdGhpcy53aWR0aDtcclxuICAgICAgX291dC55ICo9IF90YXJnZXQuaGVpZ2h0IC8gdGhpcy5oZWlnaHQ7XHJcbiAgICAgIF9vdXQuYWRkKF90YXJnZXQucG9zaXRpb24pO1xyXG4gICAgICByZXR1cm4gX291dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIG9mIHRoaXMgcmVjdGFuZ2xlIG9yIG9uIHRoZSBib3JkZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc0luc2lkZShfcG9pbnQ6IFZlY3RvcjIpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIChfcG9pbnQueCA+PSB0aGlzLmxlZnQgJiYgX3BvaW50LnggPD0gdGhpcy5yaWdodCAmJiBfcG9pbnQueSA+PSB0aGlzLnRvcCAmJiBfcG9pbnQueSA8PSB0aGlzLmJvdHRvbSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyByZWN0YW5nbGUgY29sbGlkZXMgd2l0aCB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29sbGlkZXMoX3JlY3Q6IFJlY3RhbmdsZSk6IGJvb2xlYW4ge1xyXG4gICAgICBpZiAodGhpcy5sZWZ0ID4gX3JlY3QucmlnaHQpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMucmlnaHQgPCBfcmVjdC5sZWZ0KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLnRvcCA+IF9yZWN0LmJvdHRvbSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy5ib3R0b20gPCBfcmVjdC50b3ApIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyByZWN0YW5nbGUgY29tcGxldGVseSBlbmNsb3NlcyB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY292ZXJzKF9yZWN0OiBSZWN0YW5nbGUpOiBib29sZWFuIHtcclxuICAgICAgaWYgKHRoaXMubGVmdCA+IF9yZWN0LmxlZnQpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMucmlnaHQgPCBfcmVjdC5yaWdodCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy50b3AgPiBfcmVjdC50b3ApIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMuYm90dG9tIDwgX3JlY3QuYm90dG9tKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVjdGFuZ2xlIGNyZWF0ZWQgYnkgdGhlIGludGVyc2VjdGlvbiBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcmVjdGFuZ2xlIG9yIG51bGwsIGlmIHRoZXkgZG9uJ3QgY29sbGlkZS5cclxuICAgICAqIEBwYXJhbSBfb3V0IE9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0SW50ZXJzZWN0aW9uKF9yZWN0OiBSZWN0YW5nbGUsIF9vdXQ6IFJlY3RhbmdsZSA9IFJlY3ljbGVyLnJldXNlKFJlY3RhbmdsZSkpOiBSZWN0YW5nbGUge1xyXG4gICAgICBpZiAoIXRoaXMuY29sbGlkZXMoX3JlY3QpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgX291dC54ID0gTWF0aC5tYXgodGhpcy5sZWZ0LCBfcmVjdC5sZWZ0KTtcclxuICAgICAgX291dC55ID0gTWF0aC5tYXgodGhpcy50b3AsIF9yZWN0LnRvcCk7XHJcbiAgICAgIF9vdXQud2lkdGggPSBNYXRoLm1pbih0aGlzLnJpZ2h0LCBfcmVjdC5yaWdodCkgLSBfb3V0Lng7XHJcbiAgICAgIF9vdXQuaGVpZ2h0ID0gTWF0aC5taW4odGhpcy5ib3R0b20sIF9yZWN0LmJvdHRvbSkgLSBfb3V0Lnk7XHJcblxyXG4gICAgICByZXR1cm4gX291dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYMaSLlJlY3RhbmdsZShwb3NpdGlvbjoke3RoaXMucG9zaXRpb24udG9TdHJpbmcoKX0sIHNpemU6JHt0aGlzLnNpemUudG9TdHJpbmcoKX0sIGxlZnQ6JHt0aGlzLmxlZnQudG9QcmVjaXNpb24oNSl9LCB0b3A6JHt0aGlzLnRvcC50b1ByZWNpc2lvbig1KX0sIHJpZ2h0OiR7dGhpcy5yaWdodC50b1ByZWNpc2lvbig1KX0sIGJvdHRvbToke3RoaXMuYm90dG9tLnRvUHJlY2lzaW9uKDUpfSlgO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyogKi8gfVxyXG4gIH1cclxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlckJ1ZmZlck1hbmFnZXIudHNcIi8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlck1hbmFnZXJDb2F0LnRzXCIvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJSZW5kZXJNYW5hZ2VyTm9kZS50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVyV2ViR0xQaWNraW5nLnRzXCIvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LnRzXCIvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJSZW5kZXJXZWJHTENvbXBvbmVudEZvZy50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVyV2ViR0xDb21wb25lbnRDYW1lcmEudHNcIi8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlcldlYkdMQ29tcG9uZW50QW1iaWVudE9jY2x1c2lvbi50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVyV2ViR0xDb21wb25lbnRCbG9vbS50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVyV2ViR0xDb21wb25lbnRPdXRsaW5lLnRzXCIvPlxyXG5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVySW5qZWN0b3JTaGFkZXIudHNcIi8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlckluamVjdG9yTWVzaC50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbS50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiUmVuZGVySW5qZWN0b3JDb21wb25lbnRQYXJ0aWNsZVN5c3RlbS50c1wiLz5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi4vTWF0aC9SZWN0YW5nbGUudHNcIi8+XHJcblxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvLyBleHBvcnQgZGVjbGFyZSBsZXQgZnVkZ2VDb25maWc6IEdlbmVyYWw7XHJcblxyXG4gIGV4cG9ydCB0eXBlIFJlbmRlclRleHR1cmUgPSBXZWJHTFRleHR1cmU7XHJcblxyXG4gIGV4cG9ydCBlbnVtIEJMRU5EIHtcclxuICAgIE9QQVFVRSwgVFJBTlNQQVJFTlQsIEFERElUSVZFLCBTVUJUUkFDVElWRSwgTU9EVUxBVEVcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIERFUFRIX0ZVTkNUSU9OIHtcclxuICAgIE5FVkVSLCBMRVNTLCBFUVVBTCwgTEVTU19FUVVBTCwgR1JFQVRFUiwgTk9UX0VRVUFMLCBHUkVBVEVSX0VRVUFMLCBBTFdBWVNcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIFNIQURFUl9BVFRSSUJVVEUgeyAvLyBrZWVwIGluIHN5bmMgd2l0aCBzaGFkZXIgc291cmNlIGNvZGVcclxuICAgIFBPU0lUSU9OLFxyXG4gICAgTk9STUFMLFxyXG4gICAgVEVYQ09PUkRTLFxyXG4gICAgQ09MT1IsXHJcbiAgICBUQU5HRU5ULFxyXG4gICAgQk9ORVMsXHJcbiAgICBXRUlHSFRTXHJcbiAgfVxyXG5cclxuICAvLyB3ZSB3YW50IHR5cGUgaW5mZXJlbmNlIGhlcmUgc28gd2UgY2FuIHVzZSB2cyBjb2RlIHRvIHNlYXJjaCBmb3IgcmVmZXJlbmNlc1xyXG4gIGV4cG9ydCBjb25zdCBVTklGT1JNX0JMT0NLID0geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICBMSUdIVFM6IHtcclxuICAgICAgTkFNRTogXCJMaWdodHNcIixcclxuICAgICAgQklORElORzogMFxyXG4gICAgfSxcclxuICAgIENBTUVSQToge1xyXG4gICAgICBOQU1FOiBcIkNhbWVyYVwiLFxyXG4gICAgICBCSU5ESU5HOiAxXHJcbiAgICB9LFxyXG4gICAgTUFURVJJQUw6IHtcclxuICAgICAgTkFNRTogXCJNYXRlcmlhbFwiLFxyXG4gICAgICBCSU5ESU5HOiAyXHJcbiAgICB9LFxyXG4gICAgTk9ERToge1xyXG4gICAgICBOQU1FOiBcIk5vZGVcIixcclxuICAgICAgQklORElORzogM1xyXG4gICAgfSxcclxuICAgIFNLSU46IHtcclxuICAgICAgTkFNRTogXCJTa2luXCIsXHJcbiAgICAgIEJJTkRJTkc6IDRcclxuICAgIH0sXHJcbiAgICBGT0c6IHtcclxuICAgICAgTkFNRTogXCJGb2dcIixcclxuICAgICAgQklORElORzogNVxyXG4gICAgfVxyXG4gIH0gYXMgY29uc3Q7XHJcblxyXG4gIGV4cG9ydCBjb25zdCBURVhUVVJFX0xPQ0FUSU9OID0geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICBDT0xPUjoge1xyXG4gICAgICBVTklGT1JNOiBcInVfdGV4Q29sb3JcIixcclxuICAgICAgVU5JVDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMCxcclxuICAgICAgSU5ERVg6IDAgLy8gY291bGQgY29tcHV0ZSB0aGVzZSBieSBVTklUIC0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMCBcclxuICAgIH0sXHJcbiAgICBOT1JNQUw6IHtcclxuICAgICAgVU5JRk9STTogXCJ1X3RleE5vcm1hbFwiLFxyXG4gICAgICBVTklUOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkUxLFxyXG4gICAgICBJTkRFWDogMVxyXG4gICAgfSxcclxuICAgIFBBUlRJQ0xFOiB7XHJcbiAgICAgIFVOSUZPUk06IFwidV9wYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNcIixcclxuICAgICAgVU5JVDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFMixcclxuICAgICAgSU5ERVg6IDJcclxuICAgIH0sXHJcbiAgICBURVhUOiB7XHJcbiAgICAgIFVOSUZPUk06IFwidV90ZXhUZXh0XCIsIC8vIFRPRE86IGFkZCB0ZXh0IHVuaWZvcm0gdG8gc2hhZGVyLi4uXHJcbiAgICAgIFVOSVQ6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTMsXHJcbiAgICAgIElOREVYOiAzXHJcbiAgICB9LFxyXG4gICAgVE9PTjoge1xyXG4gICAgICBVTklGT1JNOiBcInVfdGV4VG9vblwiLFxyXG4gICAgICBVTklUOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkU0LFxyXG4gICAgICBJTkRFWDogNFxyXG4gICAgfVxyXG4gIH0gYXMgY29uc3Q7XHJcblxyXG4gIC8qKlxyXG4gICAqIEJhc2UgY2xhc3MgZm9yIFJlbmRlck1hbmFnZXIsIGhhbmRsaW5nIHRoZSBjb25uZWN0aW9uIHRvIHRoZSByZW5kZXJpbmcgc3lzdGVtLCBpbiB0aGlzIGNhc2UgV2ViR0wuXHJcbiAgICogTWV0aG9kcyBhbmQgYXR0cmlidXRlcyBvZiB0aGlzIGNsYXNzIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LCBvbmx5IHRocm91Z2gge0BsaW5rIFJlbmRlcn1cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyV2ViR0wgZXh0ZW5kcyBFdmVudFRhcmdldFN0YXRpYyB7XHJcbiAgICAvLyBUT0RPOiByZW5kZXIgYXR0YWNobWVudHMgY2FuJ3QgYmUgc3RhdGljIGFzIGRpZmZlcmVudCB2aWV3cG9ydCBtaWdodCBoYXZlIGRpZmZlcmVudCByZXNvbHV0aW9ucyBlYWNoIHZpZXdwb3J0IG5lZWRzIGl0cyBvd24gYXR0YWNobWVudHNcclxuICAgIHB1YmxpYyBzdGF0aWMgdGV4Q29sb3I6IFdlYkdMVGV4dHVyZTsgLy8gc3RvcmVzIHRoZSBjb2xvciBvZiBlYWNoIHBpeGVsIHJlbmRlcmVkXHJcbiAgICBwdWJsaWMgc3RhdGljIHRleFBvc2l0aW9uOiBXZWJHTFRleHR1cmU7IC8vIHN0b3JlcyB0aGUgcG9zaXRpb24gb2YgZWFjaCBwaXhlbCBpbiB3b3JsZCBzcGFjZVxyXG4gICAgcHVibGljIHN0YXRpYyB0ZXhOb3JtYWw6IFdlYkdMVGV4dHVyZTsgLy8gc3RvcmVzIHRoZSBub3JtYWwgb2YgZWFjaCBwaXhlbCBpbiB3b3JsZCBzcGFjZVxyXG4gICAgcHVibGljIHN0YXRpYyB0ZXhEZXB0aFN0ZW5jaWw6IFdlYkdMVGV4dHVyZTsgLy8gc3RvcmVzIHRoZSBkZXB0aCBvZiBlYWNoIHBpeGVsXHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmluaXRpYWxpemUoKTtcclxuXHJcbiAgICAvKiogVGhlIGFyZWEgb2YgdGhlIG9mZnNjcmVlbi1jYW52YXMgaW4gQ1NTIHBpeGVscy4gKi9cclxuICAgIHByaXZhdGUgc3RhdGljIHJlY3RDYW52YXM6IFJlY3RhbmdsZTtcclxuICAgIC8qKiBUaGUgYXJlYSBvbiB0aGUgb2Zmc2NyZWVuLWNhbnZhcyB0byByZW5kZXIgdG8uICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyByZWN0UmVuZGVyOiBSZWN0YW5nbGU7XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmJvU2NlbmU6IFdlYkdMRnJhbWVidWZmZXI7IC8vIHVzZWQgZm9yIGZvcndhcmQgcmVuZGVyaW5nIHBhc3NlcywgZS5nLiBvcGFxdWUgYW5kIHRyYW5zcGFyZW50IG9iamVjdHNcclxuICAgIHByaXZhdGUgc3RhdGljIGZib091dDogV2ViR0xGcmFtZWJ1ZmZlcjsgLy8gdXNlZCB0byByZW5kZXIgdGhlIGZpbmFsIGltYWdlIHRvLCB1c3VhbGx5IFwibnVsbFwiIHRvIHJlbmRlciB0byB0aGUgY2FudmFzIGRlZmF1bHQgZnJhbWVidWZmZXIuIFVzZWQgYnkgWFIgdG8gcmVuZGVyIHRvIHRoZSBYUldlYkdMTGF5ZXIgZnJhbWVidWZmZXIuXHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgYXR0YWNobWVudHNDb2xvclBvc2l0aW9uTm9ybWFsID0gW1dlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDJdIGFzIGNvbnN0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBhdHRhY2htZW50c0NvbG9yID0gW1dlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDBdIGFzIGNvbnN0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBvZmZzY3JlZW4tY2FudmFzLCByZW5kZXJpbmdjb250ZXh0IGFuZCBoYXJkd2FyZSB2aWV3cG9ydC4gQ2FsbCBvbmNlIGJlZm9yZSBjcmVhdGluZyBhbnkgcmVzb3VyY2VzIGxpa2UgbWVzaGVzIG9yIHNoYWRlcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpbml0aWFsaXplKF9hbnRpYWxpYXM/OiBib29sZWFuLCBfYWxwaGE/OiBib29sZWFuKTogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCB7XHJcbiAgICAgIGxldCBmdWRnZUNvbmZpZzogR2VuZXJhbCA9IFJlZmxlY3QuZ2V0KGdsb2JhbFRoaXMsIFwiZnVkZ2VDb25maWdcIikgfHwge307XHJcbiAgICAgIGNvbnN0IGFudGlhbGlhczogYm9vbGVhbiA9IChfYW50aWFsaWFzICE9IHVuZGVmaW5lZCkgPyBfYW50aWFsaWFzIDogZnVkZ2VDb25maWcuYW50aWFsaWFzIHx8IGZhbHNlO1xyXG4gICAgICBpZiAoYW50aWFsaWFzKVxyXG4gICAgICAgIERlYnVnLmVycm9yKFwiVGhlIGRlZmF1bHQgYW50aWFsaWFzaW5nIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgcG9zdC1wcm9jZXNzaW5nIGVmZmVjdHMgYW5kIHdpbGwgdGhlcmVmb3JlIGJlIGRpc2FibGVkLlwiKTtcclxuICAgICAgbGV0IGNvbnRleHRBdHRyaWJ1dGVzOiBXZWJHTENvbnRleHRBdHRyaWJ1dGVzID0geyAvLyBUT0RPOiBcclxuICAgICAgICBhbHBoYTogKF9hbHBoYSAhPSB1bmRlZmluZWQpID8gX2FscGhhIDogZnVkZ2VDb25maWcuYWxwaGEgfHwgZmFsc2UsXHJcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcclxuICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxyXG4gICAgICAgIHN0ZW5jaWw6IHRydWVcclxuICAgICAgfTtcclxuICAgICAgRGVidWcuZnVkZ2UoXCJJbml0aWFsaXplIFJlbmRlcldlYkdMXCIsIGNvbnRleHRBdHRyaWJ1dGVzKTtcclxuICAgICAgLy8gbGV0IGNhbnZhczogT2Zmc2NyZWVuQ2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKTsgLy8gVE9ETzogaW5zcGVjdCB1c2luZyBhIHJlYWwgT2Zmc2NyZWVuQ2FudmFzXHJcbiAgICAgIGxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgbGV0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICAgIGNyYzMgPSBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0wyUmVuZGVyaW5nQ29udGV4dD4oXHJcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgY29udGV4dEF0dHJpYnV0ZXMpLFxyXG4gICAgICAgIFwiV2ViR0wtY29udGV4dCBjb3VsZG4ndCBiZSBjcmVhdGVkXCJcclxuICAgICAgKTtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMyA9IGNyYzM7XHJcbiAgICAgIC8vIEVuYWJsZSBiYWNrZmFjZS0gYW5kIHpCdWZmZXItY3VsbGluZy5cclxuICAgICAgY3JjMy5lbmFibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DVUxMX0ZBQ0UpO1xyXG4gICAgICBjcmMzLmVuYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX1RFU1QpO1xyXG4gICAgICBjcmMzLmVuYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkJMRU5EKTtcclxuICAgICAgUmVuZGVyV2ViR0wuc2V0QmxlbmRNb2RlKEJMRU5ELlRSQU5TUEFSRU5UKTtcclxuICAgICAgUmVuZGVyV2ViR0wucmVjdENhbnZhcyA9IFJlY3RhbmdsZS5HRVQoMCwgMCwgUmVuZGVyV2ViR0wuY3JjMy5jYW52YXMud2lkdGgsIFJlbmRlcldlYkdMLmNyYzMuY2FudmFzLmhlaWdodCk7XHJcbiAgICAgIFJlbmRlcldlYkdMLnJlY3RSZW5kZXIgPSBSZW5kZXJXZWJHTC5nZXRDYW52YXNSZWN0YW5nbGUoKS5jbG9uZTtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMLmluaXRpYWxpemVBdHRhY2htZW50cygpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5hZGp1c3RBdHRhY2htZW50cygpO1xyXG5cclxuICAgICAgUmVuZGVyV2ViR0xDb21wb25lbnRDYW1lcmEuaW5pdGlhbGl6ZShSZW5kZXJXZWJHTCk7XHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50Rm9nLmluaXRpYWxpemUoUmVuZGVyV2ViR0wpO1xyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudExpZ2h0LmluaXRpYWxpemUoUmVuZGVyV2ViR0wpO1xyXG4gICAgICBSZW5kZXJNYW5hZ2VyTm9kZS5pbml0aWFsaXplKFJlbmRlcldlYkdMKTtcclxuICAgICAgUmVuZGVyTWFuYWdlckNvYXQuaW5pdGlhbGl6ZShSZW5kZXJXZWJHTCk7XHJcblxyXG4gICAgICByZXR1cm4gY3JjMztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQ2hlY2tzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgYW5kIHRocm93cyBhbiBleGNlcHRpb24gd2l0aCB0aGUgV2ViR0wtZXJyb3Jjb2RlIGlmIHRoZSB2YWx1ZSBpcyBudWxsXHJcbiAgICAqIEBwYXJhbSBfdmFsdWUgIHZhbHVlIHRvIGNoZWNrIGFnYWluc3QgbnVsbFxyXG4gICAgKiBAcGFyYW0gX21lc3NhZ2UgIG9wdGlvbmFsLCBhZGRpdGlvbmFsIG1lc3NhZ2UgZm9yIHRoZSBleGNlcHRpb25cclxuICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzc2VydDxUPihfdmFsdWU6IFQgfCBudWxsLCBfbWVzc2FnZTogc3RyaW5nID0gXCJcIik6IFQge1xyXG4gICAgICBpZiAoX3ZhbHVlID09PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzZXJ0aW9uIGZhaWxlZC4gJHtfbWVzc2FnZX0sIFdlYkdMLUVycm9yOiAke1JlbmRlcldlYkdMLmNyYzMgPyBSZW5kZXJXZWJHTC5jcmMzLmdldEVycm9yKCkgOiBcIlwifWApO1xyXG4gICAgICByZXR1cm4gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBvZmZzY3JlZW4tY2FudmFzLlxyXG4gICAgICogXHJcbiAgICAgKiAtIERvIG5vdCByZWFkIG9yIG1vZGlmeSB0aGUgY2FudmFzIGRpbWVuc2lvbnMgZGlyZWN0bHkuXHJcbiAgICAgKiAtIFVzZSB7QGxpbmsgZ2V0Q2FudmFzUmVjdGFuZ2xlfSB0byByZXRyaWV2ZSB0aGUgc2l6ZSBvZiB0aGUgb2Zmc2NyZWVuLWNhbnZhcy5cclxuICAgICAqIC0gVXNlIHtAbGluayBzZXRDYW52YXNTaXplfSB0byBzZXQgdGhlIHNpemUgb2YgdGhlIG9mZnNjcmVlbi1jYW52YXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q2FudmFzKCk6IEhUTUxDYW52YXNFbGVtZW50IHtcclxuICAgICAgcmV0dXJuIDxIVE1MQ2FudmFzRWxlbWVudD5SZW5kZXJXZWJHTC5jcmMzLmNhbnZhczsgLy8gVE9ETzogZW5hYmxlIE9mZnNjcmVlbkNhbnZhc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFJlbmRlcmluZ0NvbnRleHQoKTogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCB7XHJcbiAgICAgIHJldHVybiBSZW5kZXJXZWJHTC5jcmMzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgcmVjdGFuZ2xlIGRlc2NyaWJpbmcgdGhlIHNpemUgb2YgdGhlIG9mZnNjcmVlbi1jYW52YXMuIHgseSBhcmUgMCBhdCBhbGwgdGltZXMuXHJcbiAgICAgKiBcclxuICAgICAqIERvIG5vdCBtb2RpZnkgdGhlIHJlY3RhbmdsZSBkaXJlY3RseSwgdXNlIHtAbGluayBzZXRDYW52YXNTaXplfSBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENhbnZhc1JlY3RhbmdsZSgpOiBSZWN0YW5nbGUge1xyXG4gICAgICByZXR1cm4gUmVuZGVyV2ViR0wucmVjdENhbnZhcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgc2l6ZSBvZiB0aGUgb2Zmc2NyZWVuLWNhbnZhcy5cclxuICAgICAqIFxyXG4gICAgICog4pqg77iPIENBVVRJT046IElmIHNpemUgY2hhbmdlcyBpbnZva2VzIHtAbGluayBhZGp1c3RBdHRhY2htZW50c30gd2hpY2ggaXMgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXRDYW52YXNTaXplKF93aWR0aDogbnVtYmVyLCBfaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgbGV0IHNpemVDaGFuZ2VkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgICBpZiAoUmVuZGVyV2ViR0wucmVjdENhbnZhcy53aWR0aCAhPSBfd2lkdGgpIHtcclxuICAgICAgICBSZW5kZXJXZWJHTC5yZWN0Q2FudmFzLndpZHRoID0gX3dpZHRoO1xyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMuY2FudmFzLndpZHRoID0gX3dpZHRoO1xyXG4gICAgICAgIHNpemVDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKFJlbmRlcldlYkdMLnJlY3RDYW52YXMuaGVpZ2h0ICE9IF9oZWlnaHQpIHtcclxuICAgICAgICBSZW5kZXJXZWJHTC5yZWN0Q2FudmFzLmhlaWdodCA9IF9oZWlnaHQ7XHJcbiAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5jYW52YXMuaGVpZ2h0ID0gX2hlaWdodDtcclxuICAgICAgICBzaXplQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzaXplQ2hhbmdlZClcclxuICAgICAgICBSZW5kZXJXZWJHTC5hZGp1c3RBdHRhY2htZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIGFyZWEgb24gdGhlIG9mZnNjcmVlbi1jYW52YXMgdGhlIGNhbWVyYSBpbWFnZSBnZXRzIHJlbmRlcmVkIHRvLlxyXG4gICAgICogXHJcbiAgICAgKiBEbyBub3QgbW9kaWZ5IHRoZSByZWN0YW5nbGUgZGlyZWN0bHksIHVzZSB7QGxpbmsgc2V0UmVuZGVyUmVjdGFuZ2xlfSBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFJlbmRlclJlY3RhbmdsZSgpOiBSZWN0YW5nbGUge1xyXG4gICAgICByZXR1cm4gUmVuZGVyV2ViR0wucmVjdFJlbmRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgYXJlYSBvbiB0aGUgb2Zmc2NyZWVuLWNhbnZhcyB0byByZW5kZXIgdGhlIGNhbWVyYSBpbWFnZSB0by5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXRSZW5kZXJSZWN0YW5nbGUoX3JlY3Q6IFJlY3RhbmdsZSk6IHZvaWQge1xyXG4gICAgICBpZiAoUmVuZGVyV2ViR0wucmVjdFJlbmRlci5lcXVhbHMoX3JlY3QpKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMLnJlY3RSZW5kZXIuY29weShfcmVjdCk7XHJcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMudmlld3BvcnQoX3JlY3QueCwgX3JlY3QueSwgX3JlY3Qud2lkdGgsIF9yZWN0LmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciB0aGUgb2Zmc2NyZWVuIHJlbmRlcmJ1ZmZlciB3aXRoIHRoZSBnaXZlbiB7QGxpbmsgQ29sb3J9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYXIoX2NvbG9yPzogQ29sb3IsIF9jb2xvcnM6IGJvb2xlYW4gPSB0cnVlLCBfZGVwdGg6IGJvb2xlYW4gPSB0cnVlLCBfc3RlbmNpbDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5jbGVhckNvbG9yKF9jb2xvcj8uciA/PyAwLCBfY29sb3I/LmcgPz8gMCwgX2NvbG9yPy5iID8/IDAsIF9jb2xvcj8uYSA/PyAxKTtcclxuICAgICAgbGV0IG1hc2s6IG51bWJlciA9IDA7XHJcbiAgICAgIGlmIChfY29sb3JzKVxyXG4gICAgICAgIG1hc2sgfD0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9CVUZGRVJfQklUO1xyXG4gICAgICBpZiAoX2RlcHRoKVxyXG4gICAgICAgIG1hc2sgfD0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9CVUZGRVJfQklUO1xyXG4gICAgICBpZiAoX3N0ZW5jaWwpXHJcbiAgICAgICAgbWFzayB8PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNURU5DSUxfQlVGRkVSX0JJVDtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5jbGVhcihtYXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZmluYWwgZnJhbWVidWZmZXIgdG8gcmVuZGVyIHRvLiBJZiBudWxsLCB0aGUgY2FudmFzIGRlZmF1bHQgZnJhbWVidWZmZXIgaXMgdXNlZC5cclxuICAgICAqIFVzZWQgYnkgWFIgdG8gcmVuZGVyIHRvIHRoZSBYUldlYkdMTGF5ZXIgZnJhbWVidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0RnJhbWVidWZmZXJUYXJnZXQoX2J1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlcik6IHZvaWQge1xyXG4gICAgICBSZW5kZXJXZWJHTC5mYm9PdXQgPSBfYnVmZmVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGZyYW1lYnVmZmVyIHRvIHRoZSBtYWluIGNvbG9yIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZXNldEZyYW1lYnVmZmVyKCk6IHZvaWQge1xyXG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBSZW5kZXJXZWJHTC5mYm9TY2VuZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgLyBEaXNhYmxlIFdlYkdMcyBkZXB0aCB0ZXN0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldERlcHRoVGVzdChfdGVzdDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAoX3Rlc3QpXHJcbiAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5lbmFibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9URVNUKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMuZGlzYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX1RFU1QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjb21wYXJpc29uIG9wZXJhdGlvbiB1c2VkIHRvIHRlc3QgZnJhZ21lbnQgZGVwdGhzIGFnYWluc3QgY3VycmVudCBkZXB0aCBidWZmZXIgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldERlcHRoRnVuY3Rpb24oX2Z1bmN0aW9uOiBERVBUSF9GVU5DVElPTiA9IERFUFRIX0ZVTkNUSU9OLkxFU1MpOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5kZXB0aEZ1bmMoX2Z1bmN0aW9uICsgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORVZFUik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgLyBEaXNhYmxlIFdlYkdMcyBzY2lzc29yIHRlc3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0U2Npc3NvclRlc3QoX3Rlc3Q6IGJvb2xlYW4sIF94PzogbnVtYmVyLCBfeT86IG51bWJlciwgX3dpZHRoPzogbnVtYmVyLCBfaGVpZ2h0PzogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGlmIChfdGVzdClcclxuICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmVuYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNDSVNTT1JfVEVTVCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmRpc2FibGUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TQ0lTU09SX1RFU1QpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5jcmMzLnNjaXNzb3IoX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHdoaWNoIGNvbG9yIGNvbXBvbmVudHMgdG8gZW5hYmxlIG9yIHRvIGRpc2FibGUgd2hlbiByZW5kZXJpbmcgdG8gYSBjb2xvciBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0Q29sb3JXcml0ZU1hc2soX3I6IGJvb2xlYW4sIF9nOiBib29sZWFuLCBfYjogYm9vbGVhbiwgX2E6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5jb2xvck1hc2soX3IsIF9nLCBfYiwgX2EpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IFdlYkdMcyB2aWV3cG9ydC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXRWaWV3cG9ydChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfd2lkdGg6IG51bWJlciwgX2hlaWdodDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlcldlYkdMLmNyYzMudmlld3BvcnQoX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBibGVuZCBtb2RlIHRvIHJlbmRlciB3aXRoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0QmxlbmRNb2RlKF9tb2RlOiBCTEVORCk6IHZvaWQge1xyXG4gICAgICBzd2l0Y2ggKF9tb2RlKSB7XHJcbiAgICAgICAgY2FzZSBCTEVORC5PUEFRVUU6XHJcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRXF1YXRpb24oV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GVU5DX0FERCk7XHJcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5aRVJPKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQkxFTkQuVFJBTlNQQVJFTlQ6XHJcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRXF1YXRpb24oV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GVU5DX0FERCk7XHJcbiAgICAgICAgICAvLyBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU1JDX0FMUEhBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCTEVORC5BRERJVElWRTpcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRFcXVhdGlvbihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZVTkNfQUREKTtcclxuICAgICAgICAgIC8vIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuT05FLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORSk7XHJcbiAgICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNSQ19BTFBIQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5PTkUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCTEVORC5TVUJUUkFDVElWRTpcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRFcXVhdGlvbihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZVTkNfUkVWRVJTRV9TVUJUUkFDVCk7XHJcbiAgICAgICAgICAvLyBSZW5kZXJXZWJHTC5jcmMzLmJsZW5kRnVuYyhXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5PTkUpO1xyXG4gICAgICAgICAgUmVuZGVyV2ViR0wuY3JjMy5ibGVuZEZ1bmMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TUkNfQUxQSEEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuT05FKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQkxFTkQuTU9EVUxBVEU6IC8vIGNvbG9yIGdldHMgbXVsdGlwbGllZCwgdHJpZWQgdG8gY29weSB1bml0eXMgXCJQYXJ0aWNsZSBTaGFkZXI6IEJsZW5kaW5nIE9wdGlvbjogUmVuZGVyaW5nIE1vZGU6IE1vZHVsYXRlXCJcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRFcXVhdGlvbihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZVTkNfQUREKTtcclxuICAgICAgICAgIFJlbmRlcldlYkdMLmNyYzMuYmxlbmRGdW5jKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFNUX0NPTE9SLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCB0aGUgKHdvcmxkKSBwb3NpdGlvbiBmcm9tIHRoZSBwaXhlbCBhdCB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIHJlbmRlci1yZWN0YW5nbGUgKG9yaWdpbiB0b3AgbGVmdCkuXHJcbiAgICAgKiDimqDvuI8gQ0FVVElPTjogQ3VycmVudGx5IG9ubHkgd29ya3Mgd2hlbiBhbWJpZW50IG9jY2x1c2lvbiBpcyBhY3RpdmUgZHVlIHRvIHdyaXRpbmcgdG8gdGhlIHBvc2l0aW9uIHRleHR1cmUgYmVpbmcgZGlzYWJsZWQgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHBvaW50UmVuZGVyVG9Xb3JsZChfcmVuZGVyOiBWZWN0b3IyKTogVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGNvbnN0IGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XHJcbiAgICAgIGNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFJlbmRlcldlYkdMLmZib1NjZW5lKTtcclxuICAgICAgY3JjMy5yZWFkQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDEpO1xyXG4gICAgICBjcmMzLnJlYWRQaXhlbHMoX3JlbmRlci54LCBSZW5kZXJXZWJHTC5yZWN0UmVuZGVyLmhlaWdodCAtIF9yZW5kZXIueSwgMSwgMSwgY3JjMy5SR0JBLCBjcmMzLkZMT0FULCBkYXRhKTtcclxuICAgICAgY3JjMy5yZWFkQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDApO1xyXG4gICAgICBsZXQgcG9zaXRpb246IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgIHBvc2l0aW9uLnNldChkYXRhWzBdLCBkYXRhWzFdLCBkYXRhWzJdKTtcclxuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgZGlmZmVyZW50IGZyYW1lYnVmZmVycyBhc3dlbGwgYXMgdGV4dHVyZSBhdHRhY2htZW50cyB0byB1c2UgYXMgcmVuZGVyIHRhcmdldHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBpbml0aWFsaXplQXR0YWNobWVudHMoKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5jcmMzO1xyXG5cclxuICAgICAgY3JjMy5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpOyAvLyBUT0RPOiBkaXNhYmxlIHNzYW8gaWYgbm90IHN1cHBvcnRlZFxyXG5cclxuICAgICAgUmVuZGVyV2ViR0wuZmJvU2NlbmUgPSBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xGcmFtZWJ1ZmZlcj4oY3JjMy5jcmVhdGVGcmFtZWJ1ZmZlcigpKTtcclxuICAgICAgUmVuZGVyV2ViR0wuZmJvT3V0ID0gbnVsbDtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMLnRleENvbG9yID0gUmVuZGVyV2ViR0wuY3JlYXRlVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgIFJlbmRlcldlYkdMLnRleFBvc2l0aW9uID0gUmVuZGVyV2ViR0wuY3JlYXRlVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgIFJlbmRlcldlYkdMLnRleE5vcm1hbCA9IFJlbmRlcldlYkdMLmNyZWF0ZVRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5MSU5FQVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgIFJlbmRlcldlYkdMLnRleERlcHRoU3RlbmNpbCA9IFJlbmRlcldlYkdMLmNyZWF0ZVRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNULCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNMQU1QX1RPX0VER0UpO1xyXG5cclxuICAgICAgY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgUmVuZGVyV2ViR0wuZmJvU2NlbmUpO1xyXG4gICAgICBjcmMzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0wudGV4Q29sb3IsIDApO1xyXG4gICAgICBjcmMzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0wudGV4UG9zaXRpb24sIDApO1xyXG4gICAgICBjcmMzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQVRUQUNITUVOVDIsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgUmVuZGVyV2ViR0wudGV4Tm9ybWFsLCAwKTtcclxuICAgICAgY3JjMy5mcmFtZWJ1ZmZlclRleHR1cmUyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBSZW5kZXJXZWJHTC50ZXhEZXB0aFN0ZW5jaWwsIDApO1xyXG5cclxuICAgICAgY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudEFtYmllbnRPY2NsdXNpb24uaW5pdGlhbGl6ZShSZW5kZXJXZWJHTCk7XHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50Qmxvb20uaW5pdGlhbGl6ZShSZW5kZXJXZWJHTCk7XHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50T3V0bGluZS5pbml0aWFsaXplKFJlbmRlcldlYkdMKTtcclxuICAgICAgUmVuZGVyV2ViR0xQaWNraW5nLmluaXRpYWxpemUoUmVuZGVyV2ViR0wpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0cyB0aGUgc2l6ZSBvZiB0aGUgZGlmZmVyZW50IHRleHR1cmUgYXR0YWNobWVudHMgKHJlbmRlciB0YXJnZXRzKSB0byB0aGUgY2FudmFzIHNpemUuXHJcbiAgICAgKiBcclxuICAgICAqIOKaoO+4jyBDQVVUSU9OOiBFeHBlbnNpdmUgb3BlcmF0aW9uLCB1c2Ugb25seSB3aGVuIGNhbnZhcyBzaXplIGNoYW5nZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYWRqdXN0QXR0YWNobWVudHMoKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcbiAgICAgIGNvbnN0IGNhbnZhc1dpZHRoOiBudW1iZXIgPSBSZW5kZXJXZWJHTC5yZWN0Q2FudmFzLndpZHRoIHx8IDE7XHJcbiAgICAgIGNvbnN0IGNhbnZhc0hlaWdodDogbnVtYmVyID0gUmVuZGVyV2ViR0wucmVjdENhbnZhcy5oZWlnaHQgfHwgMTtcclxuXHJcbiAgICAgIGNyYzMuYWN0aXZlVGV4dHVyZShjcmMzLlRFWFRVUkUwKTtcclxuXHJcbiAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBSZW5kZXJXZWJHTC50ZXhDb2xvcik7XHJcbiAgICAgIGNyYzMudGV4SW1hZ2UyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQSwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0JZVEUsIG51bGwpO1xyXG5cclxuICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFJlbmRlcldlYkdMLnRleFBvc2l0aW9uKTtcclxuICAgICAgLy8gSW4gdmlldyBzcGFjZSAxNkYgd291bGQgYmUgcHJlY2lzZSBlbm91Z2guLi4gYnV0IHdlIHdhbnQgdG8gdXNlIHdvcmxkIHNwYWNlIGZvciBjYWxjdWxhdGlvbnNcclxuICAgICAgY3JjMy50ZXhJbWFnZTJEKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBMzJGLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0LCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJHQkEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRkxPQVQsIG51bGwpO1xyXG5cclxuICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFJlbmRlcldlYkdMLnRleE5vcm1hbCk7XHJcbiAgICAgIGNyYzMudGV4SW1hZ2UyRChXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQTE2RiwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCwgMCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZMT0FULCBudWxsKTtcclxuXHJcbiAgICAgIGNyYzMuYmluZFRleHR1cmUoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBSZW5kZXJXZWJHTC50ZXhEZXB0aFN0ZW5jaWwpO1xyXG4gICAgICBjcmMzLnRleEltYWdlMkQoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCAwLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRFUFRIMjRfU1RFTkNJTDgsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuREVQVEhfU1RFTkNJTCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9JTlRfMjRfOCwgbnVsbCk7XHJcblxyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKGNyYzMuVEVYVFVSRV8yRCwgbnVsbCk7XHJcblxyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudEFtYmllbnRPY2NsdXNpb24ucmVzaXplKFJlbmRlcldlYkdMLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcclxuICAgICAgUmVuZGVyV2ViR0xDb21wb25lbnRCbG9vbS5yZXNpemUoUmVuZGVyV2ViR0wsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xyXG4gICAgICBSZW5kZXJXZWJHTENvbXBvbmVudE91dGxpbmUucmVzaXplKFJlbmRlcldlYkdMLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZVRleHR1cmUoX2ZpbHRlcjogbnVtYmVyLCBfd3JhcDogbnVtYmVyKTogV2ViR0xUZXh0dXJlIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgY29uc3QgdGV4dHVyZTogV2ViR0xUZXh0dXJlID0gUmVuZGVyV2ViR0wuYXNzZXJ0PFdlYkdMVGV4dHVyZT4oY3JjMy5jcmVhdGVUZXh0dXJlKCkpO1xyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcbiAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NSU5fRklMVEVSLCBfZmlsdGVyKTtcclxuICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX01BR19GSUxURVIsIF9maWx0ZXIpO1xyXG4gICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfV1JBUF9TLCBfd3JhcCk7XHJcbiAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9XUkFQX1QsIF93cmFwKTtcclxuICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIG51bGwpO1xyXG4gICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGJpbmRUZXh0dXJlKF9zaGFkZXI6IFNoYWRlckludGVyZmFjZSwgX3RleHR1cmU6IFdlYkdMVGV4dHVyZSwgX3VuaXQ6IG51bWJlciwgX3VuaWZvcm06IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjcmMzLmFjdGl2ZVRleHR1cmUoX3VuaXQpO1xyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgX3RleHR1cmUpO1xyXG4gICAgICBjcmMzLnVuaWZvcm0xaShfc2hhZGVyLnVuaWZvcm1zW191bmlmb3JtXSwgX3VuaXQgLSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkUwKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHVzZU5vZGVVbmlmb3Jtcyhfc2hhZGVyOiBTaGFkZXJJbnRlcmZhY2UsIF9tdHhXb3JsZDogTWF0cml4NHg0LCBfbXR4UGl2b3Q6IE1hdHJpeDN4MywgX2NvbG9yOiBDb2xvciwgX2lkPzogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5jcmMzO1xyXG5cclxuICAgICAgbGV0IHVuaWZvcm06IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gX3NoYWRlci51bmlmb3Jtc1tcInVfbXR4TWVzaFRvV29ybGRcIl07XHJcbiAgICAgIGlmICh1bmlmb3JtICYmIF9tdHhXb3JsZClcclxuICAgICAgICBjcmMzLnVuaWZvcm1NYXRyaXg0ZnYodW5pZm9ybSwgZmFsc2UsIF9tdHhXb3JsZC5nZXRBcnJheSgpKTtcclxuXHJcbiAgICAgIHVuaWZvcm0gPSBfc2hhZGVyLnVuaWZvcm1zW1widV9tdHhQaXZvdFwiXTtcclxuICAgICAgaWYgKHVuaWZvcm0gJiYgX210eFBpdm90KVxyXG4gICAgICAgIGNyYzMudW5pZm9ybU1hdHJpeDNmdihfc2hhZGVyLnVuaWZvcm1zW1widV9tdHhQaXZvdFwiXSwgZmFsc2UsIF9tdHhQaXZvdC5nZXRBcnJheSgpKTtcclxuXHJcbiAgICAgIHVuaWZvcm0gPSBfc2hhZGVyLnVuaWZvcm1zW1widV92Y3RDb2xvclwiXTtcclxuICAgICAgaWYgKHVuaWZvcm0gJiYgX2NvbG9yKVxyXG4gICAgICAgIGNyYzMudW5pZm9ybTRmdih1bmlmb3JtLCBfY29sb3IuZ2V0KCkpO1xyXG5cclxuICAgICAgdW5pZm9ybSA9IF9zaGFkZXIudW5pZm9ybXNbXCJ1X2lkXCJdO1xyXG4gICAgICBpZiAodW5pZm9ybSlcclxuICAgICAgICBSZW5kZXJXZWJHTC5jcmMzLnVuaWZvcm0xaSh1bmlmb3JtLCBfaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIG1lc2ggYnVmZmVyIHVzaW5nIHRoZSBnaXZlbiBpbmZvcyBhbmQgdGhlIGNvbXBsZXRlIHByb2plY3Rpb24gbWF0cml4XHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3Tm9kZShfbm9kZTogTm9kZSwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogdm9pZCB7XHJcbiAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpO1xyXG4gICAgICBsZXQgY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1hdGVyaWFsKTtcclxuICAgICAgbGV0IGNtcFBhcnRpY2xlU3lzdGVtOiBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSk7XHJcbiAgICAgIGlmIChjbXBQYXJ0aWNsZVN5c3RlbT8uaXNBY3RpdmUpIHtcclxuICAgICAgICBSZW5kZXJXZWJHTC5kcmF3UGFydGljbGVzKF9ub2RlLCBjbXBQYXJ0aWNsZVN5c3RlbSwgY21wTWVzaCwgY21wTWF0ZXJpYWwpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGNtcFRleHQ6IENvbXBvbmVudFRleHQgPSBfbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50VGV4dCk7XHJcbiAgICAgIGxldCBjbXBGYWNlQ2FtZXJhOiBDb21wb25lbnRGYWNlQ2FtZXJhID0gX25vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudEZhY2VDYW1lcmEpO1xyXG5cclxuICAgICAgY29uc3QgbWF0ZXJpYWw6IE1hdGVyaWFsID0gY21wTWF0ZXJpYWwubWF0ZXJpYWw7XHJcbiAgICAgIG1hdGVyaWFsLmdldFNoYWRlcigpLnVzZVByb2dyYW0oKTtcclxuICAgICAgbWF0ZXJpYWwuY29hdC51c2VSZW5kZXJEYXRhKCk7XHJcblxyXG4gICAgICBpZiAoY21wTWVzaC5za2VsZXRvbj8uaXNBY3RpdmUpXHJcbiAgICAgICAgY21wTWVzaC5za2VsZXRvbi51c2VSZW5kZXJCdWZmZXIoKTtcclxuXHJcbiAgICAgIGxldCBtdHhXb3JsZE92ZXJyaWRlOiBNYXRyaXg0eDQ7XHJcblxyXG4gICAgICBpZiAoY21wVGV4dD8uaXNBY3RpdmUpXHJcbiAgICAgICAgbXR4V29ybGRPdmVycmlkZSA9IGNtcFRleHQudXNlUmVuZGVyRGF0YShjbXBNZXNoLm10eFdvcmxkLCBfY21wQ2FtZXJhKTtcclxuXHJcbiAgICAgIGlmIChjbXBGYWNlQ2FtZXJhPy5pc0FjdGl2ZSlcclxuICAgICAgICBtdHhXb3JsZE92ZXJyaWRlID0gUmVuZGVyV2ViR0wuZmFjZUNhbWVyYShfbm9kZSwgbXR4V29ybGRPdmVycmlkZSA/PyBjbXBNZXNoLm10eFdvcmxkLCBfY21wQ2FtZXJhLm10eFdvcmxkKTtcclxuXHJcbiAgICAgIF9ub2RlLnVzZVJlbmRlckRhdGEobXR4V29ybGRPdmVycmlkZSk7XHJcblxyXG4gICAgICBjb25zdCByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzID0gY21wTWVzaC5tZXNoLnVzZVJlbmRlckJ1ZmZlcnMoKTsgLy8gVE9ETzogZmluZCBvdXQgd2h5IHRoaXMgZ2V0cyBzbG93ZXIgdGhlIG1vcmUgZGlmZmVyZW50IG1lc2hlcyBhcmUgZHJhd24/Pz9cclxuICAgICAgUmVuZGVyV2ViR0wuY3JjMy5kcmF3RWxlbWVudHMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsIHJlbmRlckJ1ZmZlcnMubkluZGljZXMsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB3aXRoIGEge0BsaW5rIFBpY2tlcn0tY2FtZXJhLCB0aGlzIG1ldGhvZCByZW5kZXJzIG9uZSBwaXhlbCB3aXRoIHBpY2tpbmcgaW5mb3JtYXRpb24gXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlIGluIHRoZSBsaW5lIG9mIHNpZ2h0IGFuZCByZXR1cm4gdGhhdCBhcyBhbiB1bnNvcnRlZCB7QGxpbmsgUGlja30tYXJyYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBwaWNrKF9ub2RlczogcmVhZG9ubHkgTm9kZVtdLCBfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEpOiBQaWNrW10geyAvLyBUT0RPOiBzZWUgaWYgdGhpcmQgcGFyYW1ldGVyIF93b3JsZD86IE1hdHJpeDR4NCB3b3VsZCBiZSB1c2VmdWxsXHJcbiAgICAgIHJldHVybiBSZW5kZXJXZWJHTFBpY2tpbmcucGlja0Zyb20oX25vZGVzLCBfY21wQ2FtZXJhLCBSZW5kZXJXZWJHTC5waWNrTm9kZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlbmRlciBmdW5jdGlvbiBmb3IgcGlja2luZyBub2Rlcy4gXHJcbiAgICAgKiBBIGNhbWVyYXByb2plY3Rpb24gd2l0aCBleHRyZW1lbHkgbmFycm93IGZvY3VzIGlzIHVzZWQsIHNvIGVhY2ggcGl4ZWwgb2YgdGhlIGJ1ZmZlciB3b3VsZCBob2xkIHRoZSBzYW1lIGluZm9ybWF0aW9uIGZyb20gdGhlIG5vZGUsICBcclxuICAgICAqIGJ1dCB0aGUgZnJhZ21lbnQgc2hhZGVyIHJlbmRlcnMgb25seSAxIHBpeGVsIGZvciBlYWNoIG5vZGUgaW50byB0aGUgcmVuZGVyIGJ1ZmZlciwgMXN0IG5vZGUgdG8gMXN0IHBpeGVsLCAybmQgbm9kZSB0byBzZWNvbmQgcGl4ZWwgZXRjLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHBpY2tOb2Rlcyhfbm9kZXM6IHJlYWRvbmx5IE5vZGVbXSwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogUGlja1tdIHtcclxuICAgICAgbGV0IHBpY2tzOiBQaWNrW10gPSBbXTtcclxuXHJcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBfbm9kZXMpIHtcclxuICAgICAgICBsZXQgY21wTWVzaDogQ29tcG9uZW50TWVzaCA9IG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpO1xyXG4gICAgICAgIGxldCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwgPSBub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNYXRlcmlhbCk7XHJcbiAgICAgICAgaWYgKCEoY21wTWVzaCAmJiBjbXBNZXNoLmlzQWN0aXZlICYmIGNtcE1hdGVyaWFsICYmIGNtcE1hdGVyaWFsLmlzQWN0aXZlKSlcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBsZXQgY29hdDogQ29hdCA9IGNtcE1hdGVyaWFsLm1hdGVyaWFsLmNvYXQ7XHJcbiAgICAgICAgbGV0IHNoYWRlcjogU2hhZGVySW50ZXJmYWNlID0gY29hdCBpbnN0YW5jZW9mIENvYXRUZXh0dXJlZCA/IFNoYWRlclBpY2tUZXh0dXJlZCA6IFNoYWRlclBpY2s7XHJcblxyXG4gICAgICAgIHNoYWRlci51c2VQcm9ncmFtKCk7XHJcbiAgICAgICAgY29hdC51c2VSZW5kZXJEYXRhKCk7XHJcblxyXG4gICAgICAgIGxldCBtdHhNZXNoVG9Xb3JsZDogTWF0cml4NHg0ID0gUmVuZGVyV2ViR0wuZmFjZUNhbWVyYShub2RlLCBjbXBNZXNoLm10eFdvcmxkLCBfY21wQ2FtZXJhLm10eFdvcmxkKTtcclxuICAgICAgICBSZW5kZXJXZWJHTC51c2VOb2RlVW5pZm9ybXMoc2hhZGVyLCBtdHhNZXNoVG9Xb3JsZCwgY21wTWF0ZXJpYWwubXR4UGl2b3QsIGNtcE1hdGVyaWFsLmNsclByaW1hcnksIHBpY2tzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlbmRlckJ1ZmZlcnM6IFJlbmRlckJ1ZmZlcnMgPSBjbXBNZXNoLm1lc2gudXNlUmVuZGVyQnVmZmVycygpO1xyXG4gICAgICAgIFJlbmRlcldlYkdMLmNyYzMuZHJhd0VsZW1lbnRzKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLCByZW5kZXJCdWZmZXJzLm5JbmRpY2VzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX1NIT1JULCAwKTtcclxuXHJcbiAgICAgICAgcGlja3MucHVzaChuZXcgUGljayhub2RlKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBwaWNrcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBnaXZlbiBub2RlcyB1c2luZyB0aGUgZ2l2ZW4gY2FtZXJhIGFuZCB0aGUgcG9zdCBwcm9jZXNzIGNvbXBvbmVudHMgYXR0YWNoZWQgdG8gdGhlIHNhbWUgbm9kZSBhcyB0aGUgY2FtZXJhXHJcbiAgICAgKiBUaGUgb3BhcXVlIG5vZGVzIGFyZSBkcmF3biBmaXJzdCwgdGhlbiBzc2FvIGlzIGFwcGxpZWQsIHRoZW4gYmxvb20gaXMgYXBwbGllZCwgdGhlbiBub2RlcyBhbHBoYSAoc29ydEZvckFscGhhKSBhcmUgZHJhd24uXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZHJhd05vZGVzKF9ub2Rlc09wYXF1ZTogSXRlcmFibGU8Tm9kZT4sIF9ub2Rlc0FscGhhOiBJdGVyYWJsZTxOb2RlPiwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBjb25zdCBub2RlOiBOb2RlID0gX2NtcENhbWVyYS5ub2RlO1xyXG4gICAgICBjb25zdCBjbXBGb2c6IENvbXBvbmVudEZvZyA9IG5vZGU/LmdldENvbXBvbmVudChDb21wb25lbnRGb2cpO1xyXG4gICAgICBjb25zdCBjbXBBbWJpZW50T2NjbHVzaW9uOiBDb21wb25lbnRBbWJpZW50T2NjbHVzaW9uID0gbm9kZT8uZ2V0Q29tcG9uZW50KENvbXBvbmVudEFtYmllbnRPY2NsdXNpb24pO1xyXG4gICAgICBjb25zdCBjbXBCbG9vbTogQ29tcG9uZW50Qmxvb20gPSBub2RlPy5nZXRDb21wb25lbnQoQ29tcG9uZW50Qmxvb20pO1xyXG4gICAgICBjb25zdCBjbXBPdXRsaW5lOiBDb21wb25lbnRPdXRsaW5lID0gbm9kZT8uZ2V0Q29tcG9uZW50KENvbXBvbmVudE91dGxpbmUpO1xyXG5cclxuICAgICAgUmVuZGVyV2ViR0xDb21wb25lbnRGb2cudXNlUmVuZGVyYnVmZmVyKGNtcEZvZyk7XHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50Q2FtZXJhLnVzZVJlbmRlcmJ1ZmZlcihfY21wQ2FtZXJhKTtcclxuXHJcbiAgICAgIC8vIG9wYXF1ZSBwYXNzIFxyXG4gICAgICAvLyBUT0RPOiB0aGluayBhYm91dCBkaXNhYmxpbmcgYmxlbmRpbmcgZm9yIGFsbCBvcGFxdWUgb2JqZWN0cywgdGhpcyBtaWdodCBpbXByb3ZlIHBlcmZvcm1hbmNlIFxyXG4gICAgICAvLyBhcyBvdGhlcndpc2UgdGhlIDMgY29sb3IgYXR0YWNobWVudHMgKGNvbG9yLCBwb3NpdGlvbiBhbmQgbm9ybWFscykgYWxsIG5lZWQgdG8gYmUgYmxlbmRlZFxyXG4gICAgICBjcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBSZW5kZXJXZWJHTC5mYm9TY2VuZSk7XHJcbiAgICAgIGNyYzMuZHJhd0J1ZmZlcnMoY21wQW1iaWVudE9jY2x1c2lvbj8uaXNBY3RpdmUgPyBSZW5kZXJXZWJHTC5hdHRhY2htZW50c0NvbG9yUG9zaXRpb25Ob3JtYWwgOiBSZW5kZXJXZWJHTC5hdHRhY2htZW50c0NvbG9yKTtcclxuXHJcbiAgICAgIGNyYzMuZGlzYWJsZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkJMRU5EKTtcclxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBfbm9kZXNPcGFxdWUpXHJcbiAgICAgICAgUmVuZGVyV2ViR0wuZHJhd05vZGUobm9kZSwgX2NtcENhbWVyYSk7XHJcbiAgICAgIGNyYzMuZW5hYmxlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQkxFTkQpO1xyXG5cclxuICAgICAgLy8gYW1iaWVudCBvY2NsdXNpb24gcGFzc1xyXG4gICAgICBpZiAoY21wQW1iaWVudE9jY2x1c2lvbj8uaXNBY3RpdmUpXHJcbiAgICAgICAgUmVuZGVyV2ViR0xDb21wb25lbnRBbWJpZW50T2NjbHVzaW9uLmRyYXcoX2NtcENhbWVyYSwgY21wQW1iaWVudE9jY2x1c2lvbik7XHJcblxyXG4gICAgICAvLyB0cmFuc3BhcmVudCBwYXNzIFRPRE86IHRoaW5rIGFib3V0IGRpc2FibGluZyBkZXB0aCB3cml0ZSBmb3IgYWxsIHRyYW5zcGFyZW50IG9iamVjdHMgLT4gdGhpcyBtaWdodCBtYWtlIGRlcHRoIG1hc2sgb3B0aW9uIGluIGNvbXBvbmVudCBwYXJ0aWNsZSBzeXN0ZW0gb2Jzb2xldGVcclxuICAgICAgY3JjMy5iaW5kRnJhbWVidWZmZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgUmVuZGVyV2ViR0wuZmJvU2NlbmUpO1xyXG4gICAgICBjcmMzLmRyYXdCdWZmZXJzKFJlbmRlcldlYkdMLmF0dGFjaG1lbnRzQ29sb3IpO1xyXG5cclxuICAgICAgLy8gY3JjMy5kZXB0aE1hc2soZmFsc2UpO1xyXG4gICAgICBmb3IgKGxldCBub2RlIG9mIF9ub2Rlc0FscGhhKVxyXG4gICAgICAgIFJlbmRlcldlYkdMLmRyYXdOb2RlKG5vZGUsIF9jbXBDYW1lcmEpO1xyXG4gICAgICAvLyBjcmMzLmRlcHRoTWFzayh0cnVlKTtcclxuXHJcbiAgICAgIC8vIGJsb29tIHBhc3NcclxuICAgICAgaWYgKGNtcEJsb29tPy5pc0FjdGl2ZSlcclxuICAgICAgICBSZW5kZXJXZWJHTENvbXBvbmVudEJsb29tLmRyYXcoY21wQmxvb20pO1xyXG5cclxuICAgICAgaWYgKGNtcE91dGxpbmU/LmlzQWN0aXZlICYmIGNtcE91dGxpbmUuc2VsZWN0aW9uKVxyXG4gICAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50T3V0bGluZS5kcmF3KGNtcE91dGxpbmUuc2VsZWN0aW9uLCBfY21wQ2FtZXJhLCBjbXBPdXRsaW5lKTtcclxuXHJcbiAgICAgIC8vIGNvcHkgZnJhbWVidWZmZXIgdG8gY2FudmFzXHJcbiAgICAgIGNyYzMuYmluZEZyYW1lYnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkVBRF9GUkFNRUJVRkZFUiwgUmVuZGVyV2ViR0wuZmJvU2NlbmUpO1xyXG4gICAgICBjcmMzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkRSQVdfRlJBTUVCVUZGRVIsIFJlbmRlcldlYkdMLmZib091dCk7XHJcbiAgICAgIGNyYzMuYmxpdEZyYW1lYnVmZmVyKDAsIDAsIFJlbmRlcldlYkdMLnJlY3RDYW52YXMud2lkdGgsIFJlbmRlcldlYkdMLnJlY3RDYW52YXMuaGVpZ2h0LCAwLCAwLCBSZW5kZXJXZWJHTC5yZWN0Q2FudmFzLndpZHRoLCBSZW5kZXJXZWJHTC5yZWN0Q2FudmFzLmhlaWdodCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9CVUZGRVJfQklUIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ERVBUSF9CVUZGRVJfQklULCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGRyYXdQYXJ0aWNsZXMoX25vZGU6IE5vZGUsIF9jbXBQYXJ0aWNsZVN5c3RlbTogQ29tcG9uZW50UGFydGljbGVTeXN0ZW0sIF9jbXBNZXNoOiBDb21wb25lbnRNZXNoLCBfY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBjb25zdCByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzID0gX2NtcE1lc2gubWVzaC51c2VSZW5kZXJCdWZmZXJzKCk7XHJcbiAgICAgIGNvbnN0IG1hdGVyaWFsOiBNYXRlcmlhbCA9IF9jbXBNYXRlcmlhbC5tYXRlcmlhbDtcclxuICAgICAgbWF0ZXJpYWwuY29hdC51c2VSZW5kZXJEYXRhKCk7XHJcbiAgICAgIF9jbXBQYXJ0aWNsZVN5c3RlbS5wYXJ0aWNsZVN5c3RlbS5nZXRTaGFkZXJGcm9tKG1hdGVyaWFsLmdldFNoYWRlcigpKS51c2VQcm9ncmFtKCk7XHJcbiAgICAgIF9jbXBQYXJ0aWNsZVN5c3RlbS51c2VSZW5kZXJEYXRhKCk7XHJcbiAgICAgIF9ub2RlLnVzZVJlbmRlckRhdGEoKTtcclxuXHJcbiAgICAgIGNyYzMuZGVwdGhNYXNrKF9jbXBQYXJ0aWNsZVN5c3RlbS5kZXB0aE1hc2spO1xyXG4gICAgICBSZW5kZXJXZWJHTC5zZXRCbGVuZE1vZGUoX2NtcFBhcnRpY2xlU3lzdGVtLmJsZW5kTW9kZSk7XHJcbiAgICAgIGNyYzMuZHJhd0VsZW1lbnRzSW5zdGFuY2VkKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLCByZW5kZXJCdWZmZXJzLm5JbmRpY2VzLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX1NIT1JULCAwLCBfY21wUGFydGljbGVTeXN0ZW0uc2l6ZSk7XHJcbiAgICAgIGNyYzMuZGVwdGhNYXNrKHRydWUpO1xyXG4gICAgICBSZW5kZXJXZWJHTC5zZXRCbGVuZE1vZGUoQkxFTkQuVFJBTlNQQVJFTlQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGZhY2VDYW1lcmEoX25vZGU6IE5vZGUsIF9tdHhNZXNoVG9Xb3JsZDogTWF0cml4NHg0LCBfbXR4Q2FtZXJhOiBNYXRyaXg0eDQpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgY21wRmFjZUNhbWVyYTogQ29tcG9uZW50RmFjZUNhbWVyYSA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRGYWNlQ2FtZXJhKTtcclxuICAgICAgaWYgKGNtcEZhY2VDYW1lcmE/LmlzQWN0aXZlKVxyXG4gICAgICAgIHJldHVybiBfbXR4TWVzaFRvV29ybGQuY2xvbmUubG9va0F0KF9tdHhDYW1lcmEudHJhbnNsYXRpb24sIGNtcEZhY2VDYW1lcmEudXBMb2NhbCA/IG51bGwgOiBjbXBGYWNlQ2FtZXJhLnVwLCBjbXBGYWNlQ2FtZXJhLnJlc3RyaWN0KTtcclxuXHJcbiAgICAgIHJldHVybiBfbXR4TWVzaFRvV29ybGQ7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEdpdmVzIFdlYkdMIEJ1ZmZlciB0aGUgZGF0YSBmcm9tIHRoZSB7QGxpbmsgVGV4dHVyZX1cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUmVuZGVySW5qZWN0b3JUZXh0dXJlIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVjb3JhdGUoX2NvbnN0cnVjdG9yOiB0eXBlb2YgVGV4dHVyZSwgX2NvbnRleHQ6IENsYXNzRGVjb3JhdG9yQ29udGV4dCk6IHZvaWQge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgX2NvbnN0cnVjdG9yLnByb3RvdHlwZS51c2VSZW5kZXJEYXRhLm5hbWUsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JUZXh0dXJlLnVzZVJlbmRlckRhdGFcclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBfY29uc3RydWN0b3IucHJvdG90eXBlLmRlbGV0ZVJlbmRlckRhdGEubmFtZSwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvclRleHR1cmUuZGVsZXRlUmVuZGVyRGF0YVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVzZVJlbmRlckRhdGEodGhpczogVGV4dHVyZSwgX3RleHR1cmVVbml0OiBudW1iZXIgPSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkUwKTogdm9pZCB7XHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBpZiAoIXRoaXMucmVuZGVyRGF0YSlcclxuICAgICAgICB0aGlzLnJlbmRlckRhdGEgPSBSZW5kZXJXZWJHTC5hc3NlcnQ8V2ViR0xUZXh0dXJlPihjcmMzLmNyZWF0ZVRleHR1cmUoKSk7IC8vIFRPRE86IGNoZWNrIGlmIGFsbCBXZWJHTC1DcmVhdGlvbnMgYXJlIGFzc2VydGVkXHJcblxyXG4gICAgICBjcmMzLmFjdGl2ZVRleHR1cmUoX3RleHR1cmVVbml0KTtcclxuICAgICAgY3JjMy5iaW5kVGV4dHVyZShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIHRoaXMucmVuZGVyRGF0YSk7XHJcblxyXG4gICAgICBpZiAodGhpcy50ZXh0dXJlRGlydHkpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gQWx3YXlzIHByZW11bHRpcGx5IGFscGhhIHdoaWxlIGxvYWRpbmcgdGV4dHVyZXNcclxuICAgICAgICAgIGNyYzMucGl4ZWxTdG9yZWkoY3JjMy5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRydWUpO1xyXG4gICAgICAgICAgY3JjMy50ZXhJbWFnZTJEKFxyXG4gICAgICAgICAgICBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIDAsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkdCQSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SR0JBLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0JZVEUsXHJcbiAgICAgICAgICAgIHRoaXMudGV4SW1hZ2VTb3VyY2VcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBjcmMzLnBpeGVsU3RvcmVpKGNyYzMuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgdGhpcy5taXBtYXBEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICB0aGlzLnRleHR1cmVEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgICAgRGVidWcuZXJyb3IoX2Vycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLm1pcG1hcERpcnR5KSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLm1pcG1hcCkge1xyXG4gICAgICAgICAgY2FzZSBNSVBNQVAuQ1JJU1A6XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NQUdfRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QpO1xyXG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUlOX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIE1JUE1BUC5NRURJVU06XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NQUdfRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk5FQVJFU1QpO1xyXG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUlOX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUX01JUE1BUF9MSU5FQVIpO1xyXG4gICAgICAgICAgICBjcmMzLmdlbmVyYXRlTWlwbWFwKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBNSVBNQVAuQkxVUlJZOlxyXG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUFHX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5MSU5FQVIpO1xyXG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfTUlOX0ZJTFRFUiwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5MSU5FQVJfTUlQTUFQX0xJTkVBUik7XHJcbiAgICAgICAgICAgIGNyYzMuZ2VuZXJhdGVNaXBtYXAoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJEKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIE1JUE1BUC5TTU9PVEg6XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NQUdfRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkxJTkVBUik7XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9NSU5fRklMVEVSLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkxJTkVBUik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm1pcG1hcERpcnR5ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLndyYXBEaXJ0eSkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy53cmFwKSB7XHJcbiAgICAgICAgICBjYXNlIFdSQVAuUkVQRUFUOlxyXG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfV1JBUF9TLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJFUEVBVCk7XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9XUkFQX1QsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkVQRUFUKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFdSQVAuQ0xBTVA6XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9XUkFQX1MsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgICAgIGNyYzMudGV4UGFyYW1ldGVyaShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfMkQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV9XUkFQX1QsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBXUkFQLk1JUlJPUjpcclxuICAgICAgICAgICAgY3JjMy50ZXhQYXJhbWV0ZXJpKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFX1dSQVBfUywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5NSVJST1JFRF9SRVBFQVQpO1xyXG4gICAgICAgICAgICBjcmMzLnRleFBhcmFtZXRlcmkoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5URVhUVVJFXzJELCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlRFWFRVUkVfV1JBUF9ULCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1JUlJPUkVEX1JFUEVBVCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy53cmFwRGlydHkgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgZGVsZXRlUmVuZGVyRGF0YSh0aGlzOiBUZXh0dXJlKTogdm9pZCB7XHJcbiAgICAgIGlmICghdGhpcy5yZW5kZXJEYXRhKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjcmMzLmJpbmRUZXh0dXJlKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRV8yRCwgbnVsbCk7XHJcbiAgICAgIGNyYzMuZGVsZXRlVGV4dHVyZSh0aGlzLnJlbmRlckRhdGEpO1xyXG4gICAgICB0aGlzLnJlbmRlckRhdGEgPSBudWxsO1xyXG4gICAgICB0aGlzLnRleHR1cmVEaXJ0eSA9IHRydWU7XHJcbiAgICAgIHRoaXMubWlwbWFwRGlydHkgPSB0cnVlO1xyXG4gICAgICB0aGlzLndyYXBEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBNYXBDbGFzc1RvQ29tcG9uZW50cyB7XHJcbiAgICBbY2xhc3NOYW1lOiBzdHJpbmddOiBDb21wb25lbnRbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgYSBub2RlIGluIHRoZSBzY2VuZXRyZWUuXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ocy1mdXJ0d2FuZ2VuL0ZVREdFL3dpa2kvR3JhcGhcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTm9kZSBleHRlbmRzIEV2ZW50VGFyZ2V0VW5pZmllZCBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nOyAvLyBUaGUgbmFtZSB0byBjYWxsIHRoaXMgbm9kZSBieS5cclxuICAgIHB1YmxpYyByZWFkb25seSBtdHhXb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICBwdWJsaWMgdGltZXN0YW1wVXBkYXRlOiBudW1iZXIgPSAwO1xyXG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygbm9kZXMgb2YgdGhlIHdob2xlIGJyYW5jaCBpbmNsdWRpbmcgdGhpcyBub2RlIGFuZCBhbGwgc3VjY2Vzc29ycyAqL1xyXG4gICAgcHVibGljIG5Ob2Rlc0luQnJhbmNoOiBudW1iZXIgPSAwO1xyXG4gICAgLyoqIFRoZSByYWRpdXMgb2YgdGhlIGJvdW5kaW5nIHNwaGVyZSBpbiB3b3JsZCBkaW1lbnNpb25zIGVuY2xvc2luZyB0aGUgZ2VvbWV0cnkgb2YgdGhpcyBub2RlIGFuZCBhbGwgc3VjY2Vzc29ycyBpbiB0aGUgYnJhbmNoICovXHJcbiAgICBwdWJsaWMgcmFkaXVzOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHByaXZhdGUgcGFyZW50OiBOb2RlIHwgbnVsbCA9IG51bGw7IC8vIFRoZSBwYXJlbnQgb2YgdGhpcyBub2RlLlxyXG4gICAgcHJpdmF0ZSBjaGlsZHJlbjogTm9kZVtdID0gW107IC8vIGFycmF5IG9mIGNoaWxkIG5vZGVzIGFwcGVuZGVkIHRvIHRoaXMgbm9kZS5cclxuICAgIHByaXZhdGUgY29tcG9uZW50czogTWFwQ2xhc3NUb0NvbXBvbmVudHMgPSB7fTtcclxuICAgIC8vIHByaXZhdGUgdGFnczogc3RyaW5nW10gPSBbXTsgLy8gTmFtZXMgb2YgdGFncyB0aGF0IGFyZSBhdHRhY2hlZCB0byB0aGlzIG5vZGUuIChUT0RPOiBBcyBvZiB5ZXQgbm8gZnVuY3Rpb25hbGl0eSlcclxuICAgIC8vIHByaXZhdGUgbGF5ZXJzOiBzdHJpbmdbXSA9IFtdOyAvLyBOYW1lcyBvZiB0aGUgbGF5ZXJzIHRoaXMgbm9kZSBpcyBvbi4gKFRPRE86IEFzIG9mIHlldCBubyBmdW5jdGlvbmFsaXR5KVxyXG4gICAgcHJpdmF0ZSBhY3RpdmU6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgI2xpc3RlbmVyczogTWFwRXZlbnRUeXBlVG9MaXN0ZW5lcnMgPSB7fTtcclxuICAgICNjYXB0dXJlczogTWFwRXZlbnRUeXBlVG9MaXN0ZW5lcnMgPSB7fTtcclxuXHJcbiAgICAjbXR4V29ybGRJbnZlcnNlVXBkYXRlZDogbnVtYmVyO1xyXG4gICAgI210eFdvcmxkSW52ZXJzZTogTWF0cml4NHg0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggYSBuYW1lIGFuZCBpbml0aWFsaXplcyBhbGwgYXR0cmlidXRlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgbXV0YXRvci1saWtlIHBhdGggc3RyaW5nIHRvIGdldCBmcm9tIG9uZSBub2RlIHRvIGFub3RoZXIgb3IgbnVsbCBpZiBubyBwYXRoIGlzIGZvdW5kIGUuZy46XHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBcIm5vZGUvcGFyZW50L2NoaWxkcmVuLzEvY29tcG9uZW50cy9Db21wb25lbnRTa2VsZXRvbi8wXCJcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFBBVEhfRlJPTV9UTyhfZnJvbTogTm9kZSB8IENvbXBvbmVudCwgX3RvOiBOb2RlIHwgQ29tcG9uZW50KTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICAgIGNvbnN0IGZyb206IE5vZGUgPSBfZnJvbSBpbnN0YW5jZW9mIENvbXBvbmVudCA/IF9mcm9tLm5vZGUgOiBfZnJvbTtcclxuICAgICAgY29uc3QgdG86IE5vZGUgPSBfdG8gaW5zdGFuY2VvZiBDb21wb25lbnQgPyBfdG8ubm9kZSA6IF90bztcclxuICAgICAgaWYgKCFmcm9tIHx8ICF0bylcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIC8vIGZpbmQgcGF0aHMgdG8gbG93ZXN0IGNvbW1vbiBhbmNlc3RvclxyXG4gICAgICBsZXQgcGF0aEZyb206IE5vZGVbXSA9IGZyb20uZ2V0UGF0aCgpO1xyXG4gICAgICBsZXQgcGF0aFRvOiBOb2RlW10gPSB0by5nZXRQYXRoKCk7XHJcbiAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IG51bGw7XHJcbiAgICAgIHdoaWxlIChwYXRoRnJvbS5sZW5ndGggJiYgcGF0aFRvLmxlbmd0aCAmJiBwYXRoRnJvbVswXSA9PSBwYXRoVG9bMF0pIHtcclxuICAgICAgICBhbmNlc3RvciA9IHBhdGhGcm9tLnNoaWZ0KCk7XHJcbiAgICAgICAgcGF0aFRvLnNoaWZ0KCk7XHJcbiAgICAgIH1cclxuICAgICAgcGF0aFRvLnVuc2hpZnQoYW5jZXN0b3IpO1xyXG5cclxuICAgICAgaWYgKCFhbmNlc3RvcilcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIC8vIGNyZWF0ZSByZWxhdGl2ZSBwYXRoXHJcbiAgICAgIGxldCBwYXRoVG9BbmNlc3Rvcjogc3RyaW5nW10gPSBwYXRoRnJvbS5tYXAoX25vZGUgPT4gXCJwYXJlbnRcIik7IC8vIFRPRE86IHVzZSBcImtleW9mIE5vZGVcIiBhcyB0eXBlXHJcbiAgICAgIGxldCBwYXRoRnJvbUFuY2VzdG9yOiBzdHJpbmdbXSA9IHBhdGhUb1xyXG4gICAgICAgIC5mbGF0TWFwKChfbm9kZSwgX2luZGV4LCBfYXJyYXkpID0+IFtcImNoaWxkcmVuXCIsIF9ub2RlLmZpbmRDaGlsZChfYXJyYXlbX2luZGV4ICsgMV0pLnRvU3RyaW5nKCldKVxyXG4gICAgICAgIC5zbGljZSgwLCAtMik7XHJcblxyXG4gICAgICBpZiAoX2Zyb20gaW5zdGFuY2VvZiBDb21wb25lbnQpXHJcbiAgICAgICAgcGF0aFRvQW5jZXN0b3IudW5zaGlmdChcIm5vZGVcIik7XHJcbiAgICAgIGlmIChfdG8gaW5zdGFuY2VvZiBDb21wb25lbnQpXHJcbiAgICAgICAgcGF0aEZyb21BbmNlc3Rvci5wdXNoKFwiY29tcG9uZW50c1wiLCBfdG8udHlwZSwgdG8uY29tcG9uZW50c1tfdG8udHlwZV0uaW5kZXhPZihfdG8pLnRvU3RyaW5nKCkpO1xyXG5cclxuICAgICAgcmV0dXJuIHBhdGhUb0FuY2VzdG9yLmNvbmNhdChwYXRoRnJvbUFuY2VzdG9yKS5qb2luKFwiL1wiKTsgLy8gVE9ETzogb3IgbWF5YmUgdmFsaWRhdGUgdGhpcyBzdHJpbmcgd2l0aCBub2RlIGFuZCBjb21wb25lbnQgb2JqZWN0cz9cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUge0BsaW5rIE5vZGV9IG9yIHtAbGluayBDb21wb25lbnR9IGZvdW5kIGF0IHRoZSBnaXZlbiBwYXRoIHN0YXJ0aW5nIGZyb20gdGhlIGdpdmVuIG5vZGUgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEZJTkQ8VCA9IE5vZGUgfCBDb21wb25lbnQ+KF9mcm9tOiBOb2RlIHwgQ29tcG9uZW50LCBfcGF0aDogc3RyaW5nKTogVCB7XHJcbiAgICAgIGlmIChfcGF0aCA9PSBcIlwiKVxyXG4gICAgICAgIHJldHVybiA8VD5fZnJvbTtcclxuXHJcbiAgICAgIGxldCBwYXRoOiBzdHJpbmdbXSA9IF9wYXRoLnNwbGl0KFwiL1wiKTtcclxuICAgICAgbGV0IHRvOiBHZW5lcmFsID0gX2Zyb207XHJcblxyXG4gICAgICB3aGlsZSAocGF0aC5sZW5ndGggJiYgdG8pXHJcbiAgICAgICAgdG8gPSBSZWZsZWN0LmdldCh0bywgcGF0aC5zaGlmdCgpKTtcclxuXHJcbiAgICAgIHJldHVybiB0bztcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsIHJlcm91dGUgdG8ge0BsaW5rIFJlbmRlck1hbmFnZXJOb2RlLnJlc2V0UmVuZGVyRGF0YX0gKi9cclxuICAgIEBSZW5kZXJNYW5hZ2VyTm9kZS5kZWNvcmF0ZVxyXG4gICAgcHVibGljIHN0YXRpYyByZXNldFJlbmRlckRhdGEoKTogdm9pZCB7IC8qIGluamVjdGVkICovIH07XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCByZXJvdXRlIHRvIHtAbGluayBSZW5kZXJNYW5hZ2VyTm9kZS51cGRhdGVSZW5kZXJidWZmZXJ9ICovXHJcbiAgICBAUmVuZGVyTWFuYWdlck5vZGUuZGVjb3JhdGVcclxuICAgIHB1YmxpYyBzdGF0aWMgdXBkYXRlUmVuZGVyYnVmZmVyKCk6IHZvaWQgeyAvKiBpbmplY3RlZCAqLyB9O1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgcmVyb3V0ZSB0byB7QGxpbmsgUmVuZGVyTWFuYWdlck5vZGUudXBkYXRlUmVuZGVyRGF0YX0gKi9cclxuICAgIEBSZW5kZXJNYW5hZ2VyTm9kZS5kZWNvcmF0ZVxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyB1cGRhdGVSZW5kZXJEYXRhKF9ub2RlOiBOb2RlLCBfY21wTWVzaDogQ29tcG9uZW50TWVzaCwgX2NtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCwgX2NtcEZhY2VDYW1lcmE6IENvbXBvbmVudEZhY2VDYW1lcmEsIF9jbXBQYXJ0aWNsZVN5c3RlbTogQ29tcG9uZW50UGFydGljbGVTeXN0ZW0pOiB2b2lkIHsgLyogaW5qZWN0ZWQgKi8gfTtcclxuXHJcbiAgICAvKiogQGludGVybmFsIHJlcm91dGUgdG8ge0BsaW5rIFJlbmRlck1hbmFnZXJOb2RlLnVzZVJlbmRlckRhdGF9ICovXHJcbiAgICBAUmVuZGVyTWFuYWdlck5vZGUuZGVjb3JhdGVcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgdXNlUmVuZGVyRGF0YShfbm9kZTogTm9kZSwgX210eFdvcmxkT3ZlcnJpZGU/OiBNYXRyaXg0eDQpOiB2b2lkIHsgLyogaW5qZWN0ZWQgKi8gfTtcclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzQWN0aXZlKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG9ydGN1dCB0byByZXRyaWV2ZSB0aGlzIG5vZGVzIHtAbGluayBDb21wb25lbnRUcmFuc2Zvcm19XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY21wVHJhbnNmb3JtKCk6IENvbXBvbmVudFRyYW5zZm9ybSB7XHJcbiAgICAgIHJldHVybiA8Q29tcG9uZW50VHJhbnNmb3JtPnRoaXMuZ2V0Q29tcG9uZW50KENvbXBvbmVudFRyYW5zZm9ybSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG9ydGN1dCB0byByZXRyaWV2ZSB0aGUgbG9jYWwge0BsaW5rIE1hdHJpeDR4NH0gYXR0YWNoZWQgdG8gdGhpcyBub2RlcyB7QGxpbmsgQ29tcG9uZW50VHJhbnNmb3JtfSAgXHJcbiAgICAgKiBGYWlscyBpZiBubyB7QGxpbmsgQ29tcG9uZW50VHJhbnNmb3JtfSBpcyBhdHRhY2hlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG10eExvY2FsKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNtcFRyYW5zZm9ybT8ubXR4TG9jYWw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBtdHhXb3JsZEludmVyc2UoKTogTWF0cml4NHg0IHtcclxuICAgICAgaWYgKHRoaXMuI210eFdvcmxkSW52ZXJzZVVwZGF0ZWQgIT0gdGhpcy50aW1lc3RhbXBVcGRhdGUpXHJcbiAgICAgICAgdGhpcy4jbXR4V29ybGRJbnZlcnNlID0gTWF0cml4NHg0LklOVkVSU0UodGhpcy5tdHhXb3JsZCk7XHJcblxyXG4gICAgICB0aGlzLiNtdHhXb3JsZEludmVyc2VVcGRhdGVkID0gdGhpcy50aW1lc3RhbXBVcGRhdGU7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtdHhXb3JsZEludmVyc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gYXR0YWNoZWQgdG8gdGhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG5DaGlsZHJlbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0b3IgeWllbGRpbmcgdGhlIG5vZGUgYW5kIGFsbCBkZWNlbmRhbnRzIGluIHRoZSBncmFwaCBiZWxvdyBmb3IgaXRlcmF0aW9uXHJcbiAgICAgKiBJbmFjdGl2ZSBub2RlcyBhbmQgdGhlaXIgZGVzY2VuZGFudHMgY2FuIGJlIGZpbHRlcmVkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyAqIGdldEl0ZXJhdG9yKF9hY3RpdmU6IGJvb2xlYW4gPSBmYWxzZSk6IEl0ZXJhYmxlSXRlcmF0b3I8Tm9kZT4ge1xyXG4gICAgICBpZiAoIV9hY3RpdmUgfHwgdGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICAgIHlpZWxkIHRoaXM7XHJcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcclxuICAgICAgICAgIHlpZWxkKiBjaGlsZC5nZXRJdGVyYXRvcihfYWN0aXZlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoaXMgbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cyBpbiB0aGUgZ3JhcGggYmVsb3dcclxuICAgICAqL1xyXG4gICAgcHVibGljIFtTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhYmxlSXRlcmF0b3I8Tm9kZT4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRJdGVyYXRvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDYWxsZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0gZHVyaW5nIHtAbGluayBSZW5kZXIucHJlcGFyZX0uIE92ZXJyaWRlIHRoaXMgdG8gcHJvdmlkZSB0aGUgcmVuZGVyIHN5c3RlbSB3aXRoIGFkZGl0aW9uYWwgcmVuZGVyIGRhdGEuICovXHJcbiAgICBwdWJsaWMgdXBkYXRlUmVuZGVyRGF0YShfY21wTWVzaDogQ29tcG9uZW50TWVzaCwgX2NtcE1hdGVyaWFsOiBDb21wb25lbnRNYXRlcmlhbCwgX2NtcEZhY2VDYW1lcmE6IENvbXBvbmVudEZhY2VDYW1lcmEsIF9jbXBQYXJ0aWNsZVN5c3RlbTogQ29tcG9uZW50UGFydGljbGVTeXN0ZW0pOiB2b2lkIHtcclxuICAgICAgTm9kZS51cGRhdGVSZW5kZXJEYXRhKHRoaXMsIF9jbXBNZXNoLCBfY21wTWF0ZXJpYWwsIF9jbXBGYWNlQ2FtZXJhLCBfY21wUGFydGljbGVTeXN0ZW0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiogQ2FsbGVkIGJ5IHRoZSByZW5kZXIgc3lzdGVtIGR1cmluZyB7QGxpbmsgUmVuZGVyLmRyYXd9LiBPdmVycmlkZSB0aGlzIHRvIHByb3ZpZGUgdGhlIHJlbmRlciBzeXN0ZW0gd2l0aCBhZGRpdGlvbmFsIHJlbmRlciBkYXRhLiAqL1xyXG4gICAgcHVibGljIHVzZVJlbmRlckRhdGEoX210eFdvcmxkT3ZlcnJpZGU/OiBNYXRyaXg0eDQpOiB2b2lkIHtcclxuICAgICAgTm9kZS51c2VSZW5kZXJEYXRhKHRoaXMsIF9tdHhXb3JsZE92ZXJyaWRlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZS0gLyBBY3RpdmF0ZSB0aGlzIG5vZGUuIEluYWN0aXZlIG5vZGVzIHdpbGwgbm90IGJlIHByb2Nlc3NlZCBieSB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhY3RpdmF0ZShfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgdGhpcy5hY3RpdmUgPSBfb247XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoX29uID8gRVZFTlQuTk9ERV9BQ1RJVkFURSA6IEVWRU5ULk5PREVfREVBQ1RJVkFURSwgeyBidWJibGVzOiB0cnVlIH0pKTtcclxuICAgICAgdGhpcy5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoX29uID8gRVZFTlQuTk9ERV9BQ1RJVkFURSA6IEVWRU5ULk5PREVfREVBQ1RJVkFURSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICNyZWdpb24gU2NlbmV0cmVlXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhpcyBub2RlcyBwYXJlbnQgbm9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UGFyZW50KCk6IE5vZGUgfCBudWxsIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhY2VzIGJhY2sgdGhlIGFuY2VzdG9ycyBvZiB0aGlzIG5vZGUgYW5kIHJldHVybnMgdGhlIGZpcnN0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QW5jZXN0b3IoKTogTm9kZSB8IG51bGwge1xyXG4gICAgICBsZXQgYW5jZXN0b3I6IE5vZGUgPSB0aGlzO1xyXG4gICAgICB3aGlsZSAoYW5jZXN0b3IuZ2V0UGFyZW50KCkpXHJcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5nZXRQYXJlbnQoKTtcclxuICAgICAgcmV0dXJuIGFuY2VzdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhY2VzIHRoZSBoaWVyYXJjaHkgdXB3YXJkcyB0byB0aGUgcm9vdCBhbmQgcmV0dXJucyB0aGUgcGF0aCBmcm9tIHRoZSByb290IHRvIHRoaXMgbm9kZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFBhdGgoX291dDogTm9kZVtdID0gW10sIF9vZmZzZXQ6IG51bWJlciA9IDApOiBOb2RlW10ge1xyXG4gICAgICBsZXQgYW5jZXN0b3I6IE5vZGUgPSB0aGlzO1xyXG4gICAgICBfb3V0W19vZmZzZXRdID0gYW5jZXN0b3I7XHJcbiAgICAgIHdoaWxlICgoYW5jZXN0b3IgPSBhbmNlc3Rvci5nZXRQYXJlbnQoKSkpXHJcbiAgICAgICAgX291dFsrK19vZmZzZXRdID0gYW5jZXN0b3I7XHJcbiAgICAgIHJldHVybiBfb3V0LnJldmVyc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY2hpbGQgYXQgdGhlIGdpdmVuIGluZGV4IGluIHRoZSBsaXN0IG9mIGNoaWxkcmVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDaGlsZChfaW5kZXg6IG51bWJlcik6IE5vZGUge1xyXG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltfaW5kZXhdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVhZG9ubHkgbGlzdCBvZiBjaGlsZHJlbi4gQ3JlYXRlIGEgY29weSB0byBtb2RpZnkgaXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDaGlsZHJlbigpOiByZWFkb25seSBOb2RlW10ge1xyXG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2hpbGRCeU5hbWUoX25hbWU6IHN0cmluZyk6IE5vZGUge1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykgeyAvLyBubyBnYXJiYWdlIGNyZWF0aW9uXHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0ubmFtZSA9PSBfbmFtZSlcclxuICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiByZWZlcmVuY2VzIHRvIGNoaWxkbm9kZXMgd2l0aCB0aGUgc3VwcGxpZWQgbmFtZS4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDaGlsZHJlbkJ5TmFtZShfbmFtZTogc3RyaW5nKTogTm9kZVtdIHtcclxuICAgICAgbGV0IGZvdW5kOiBOb2RlW10gPSBbXTtcclxuICAgICAgZm91bmQgPSB0aGlzLmNoaWxkcmVuLmZpbHRlcigoX25vZGU6IE5vZGUpID0+IF9ub2RlLm5hbWUgPT0gX25hbWUpO1xyXG4gICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW1wbHkgY2FsbHMge0BsaW5rIGFkZENoaWxkfS4gVGhpcyByZWZlcmVuY2UgaXMgaGVyZSBzb2xlbHkgYmVjYXVzZSBhcHBlbmRDaGlsZCBpcyB0aGUgZXF1aXZhbGVudCBtZXRob2QgaW4gRE9NLlxyXG4gICAgICogU2VlIGFuZCBwcmVmZXJhYmx5IHVzZSB7QGxpbmsgYWRkQ2hpbGR9XHJcbiAgICAgKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgYXBwZW5kQ2hpbGQ6IChfY2hpbGQ6IE5vZGUpID0+IHZvaWQgPSB0aGlzLmFkZENoaWxkO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHJlZmVyZW5jZSB0byBhIG5vZGUgdG8gdGhlIGxpc3Qgb2YgY2hpbGRyZW4sIGlmIG5vdCBhbHJlYWR5IGluXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yIHdoZW4gdHJ5aW5nIHRvIGFkZCBhbiBhbmNlc3RvciBvZiB0aGlzIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkQ2hpbGQoX2NoaWxkOiBOb2RlKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gcmVmZXJlbmNlIHRvIGEgbm9kZSB0byB0aGUgbGlzdCBvZiBjaGlsZHJlbiBhdCB0aGUgZ2l2ZW4gaW5kZXguIElmIGl0IGlzIGFscmVhZHkgYSBjaGlsZCwgaXQgaXMgbW92ZWQgdG8gdGhlIG5ldyBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZENoaWxkKF9jaGlsZDogTm9kZSwgX2luZGV4OiBudW1iZXIpOiB2b2lkO1xyXG4gICAgcHVibGljIGFkZENoaWxkKF9jaGlsZDogTm9kZSwgX2luZGV4PzogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmluY2x1ZGVzKF9jaGlsZCkgJiYgX2luZGV4ID09IHVuZGVmaW5lZClcclxuICAgICAgICAvLyBfbm9kZSBpcyBhbHJlYWR5IGEgY2hpbGQgb2YgdGhpc1xyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBpbkF1ZGlvR3JhcGg6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgbGV0IGdyYXBoTGlzdGVuZWQ6IE5vZGUgPSBBdWRpb01hbmFnZXIuZGVmYXVsdC5nZXRHcmFwaExpc3RlbmluZ1RvKCk7XHJcbiAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IHRoaXM7XHJcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xyXG4gICAgICAgIGFuY2VzdG9yLnRpbWVzdGFtcFVwZGF0ZSA9IDA7XHJcbiAgICAgICAgaW5BdWRpb0dyYXBoID0gaW5BdWRpb0dyYXBoIHx8IChhbmNlc3RvciA9PSBncmFwaExpc3RlbmVkKTtcclxuICAgICAgICBpZiAoYW5jZXN0b3IgPT0gX2NoaWxkKVxyXG4gICAgICAgICAgdGhyb3cgKG5ldyBFcnJvcihcIkN5Y2xpYyByZWZlcmVuY2UgcHJvaGliaXRlZCBpbiBub2RlIGhpZXJhcmNoeSwgYW5jZXN0b3JzIG11c3Qgbm90IGJlIGFkZGVkIGFzIGNoaWxkcmVuXCIpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHByZXZpb3VzUGFyZW50OiBOb2RlID0gX2NoaWxkLnBhcmVudDtcclxuICAgICAgaWYgKHByZXZpb3VzUGFyZW50ID09IHRoaXMgJiYgX2luZGV4ID4gcHJldmlvdXNQYXJlbnQuZmluZENoaWxkKF9jaGlsZCkpXHJcbiAgICAgICAgX2luZGV4LS07XHJcblxyXG4gICAgICBpZiAocHJldmlvdXNQYXJlbnQpXHJcbiAgICAgICAgcHJldmlvdXNQYXJlbnQucmVtb3ZlQ2hpbGQoX2NoaWxkKTtcclxuXHJcbiAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKF9pbmRleCA/PyB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgX2NoaWxkKTtcclxuICAgICAgX2NoaWxkLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgIF9jaGlsZC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5DSElMRF9BUFBFTkQsIHsgYnViYmxlczogdHJ1ZSB9KSk7XHJcbiAgICAgIGlmIChpbkF1ZGlvR3JhcGgpXHJcbiAgICAgICAgX2NoaWxkLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVF9BVURJTy5DSElMRF9BUFBFTkQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHJlZmVyZW5jZSB0byB0aGUgZ2l2ZSBub2RlIGZyb20gdGhlIGxpc3Qgb2YgY2hpbGRyZW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUNoaWxkKF9jaGlsZDogTm9kZSk6IHZvaWQge1xyXG4gICAgICBsZXQgZm91bmQ6IG51bWJlciA9IHRoaXMuZmluZENoaWxkKF9jaGlsZCk7XHJcbiAgICAgIGlmIChmb3VuZCA8IDApXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgX2NoaWxkLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkNISUxEX1JFTU9WRSwgeyBidWJibGVzOiB0cnVlIH0pKTtcclxuICAgICAgX2NoaWxkLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVC5OT0RFX0RFQUNUSVZBVEUpKTtcclxuICAgICAgaWYgKHRoaXMuaXNEZXNjZW5kYW50T2YoQXVkaW9NYW5hZ2VyLmRlZmF1bHQuZ2V0R3JhcGhMaXN0ZW5pbmdUbygpKSlcclxuICAgICAgICBfY2hpbGQuYnJvYWRjYXN0RXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLkNISUxEX1JFTU9WRSkpO1xyXG4gICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShmb3VuZCwgMSk7XHJcbiAgICAgIF9jaGlsZC5wYXJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgcmVmZXJlbmNlcyBpbiB0aGUgbGlzdCBvZiBjaGlsZHJlblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlQWxsQ2hpbGRyZW4oKTogdm9pZCB7XHJcbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkcmVuLmxlbmd0aClcclxuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuY2hpbGRyZW5bMF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgaW4gdGhlIGxpc3Qgb2YgY2hpbGRyZW4gb3IgLTEgaWYgbm90IGZvdW5kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBmaW5kQ2hpbGQoX3NlYXJjaDogTm9kZSk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmluZGV4T2YoX3NlYXJjaCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlcyBhIGNoaWxkIG5vZGUgd2l0aCBhbm90aGVyLCBwcmVzZXJ2aW5nIHRoZSBwb3NpdGlvbiBpbiB0aGUgbGlzdCBvZiBjaGlsZHJlblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVwbGFjZUNoaWxkKF9yZXBsYWNlOiBOb2RlLCBfd2l0aDogTm9kZSk6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQgZm91bmQ6IG51bWJlciA9IHRoaXMuZmluZENoaWxkKF9yZXBsYWNlKTtcclxuICAgICAgaWYgKGZvdW5kIDwgMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICBfd2l0aC5nZXRQYXJlbnQoKT8ucmVtb3ZlQ2hpbGQoX3dpdGgpO1xyXG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKF9yZXBsYWNlKTtcclxuXHJcbiAgICAgIHRoaXMuYWRkQ2hpbGQoX3dpdGgsIGZvdW5kKTtcclxuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB0aW1lc3RhbXAgbWF0Y2hlcyB0aGUgbGFzdCB1cGRhdGUgdGltZXN0YW1wIHRoaXMgbm9kZSB1bmRlcndlbnQsIGVsc2UgZmFsc2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzVXBkYXRlZChfdGltZXN0YW1wVXBkYXRlOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuICh0aGlzLnRpbWVzdGFtcFVwZGF0ZSA9PSBfdGltZXN0YW1wVXBkYXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGlzIGEgZGVzY2VuZGFudCBvZiB0aGUgZ2l2ZW4gbm9kZSwgZGlyZWN0bHkgb3IgaW5kaXJlY3RseSwgZWxzZSBmYWxzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNEZXNjZW5kYW50T2YoX2FuY2VzdG9yOiBOb2RlKTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBub2RlOiBOb2RlID0gdGhpcztcclxuICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPSBfYW5jZXN0b3IpXHJcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xyXG4gICAgICByZXR1cm4gKG5vZGUgIT0gbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGEgTXV0YXRvciBmcm9tIHtAbGluayBBbmltYXRpb259IHRvIGFsbCBpdHMgY29tcG9uZW50cyBhbmQgdHJhbnNmZXJzIGl0IHRvIGl0cyBjaGlsZHJlbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5QW5pbWF0aW9uKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGlmIChfbXV0YXRvci5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb21wb25lbnRUeXBlIGluIF9tdXRhdG9yLmNvbXBvbmVudHMpIHtcclxuICAgICAgICAgIGxldCBjb21wb25lbnRzT2ZUeXBlOiBDb21wb25lbnRbXSA9IHRoaXMuY29tcG9uZW50c1tjb21wb25lbnRUeXBlXTtcclxuICAgICAgICAgIGxldCBtdXRhdG9yc0ZvclR5cGU6IE11dGF0b3JbXSA9IF9tdXRhdG9yLmNvbXBvbmVudHNbY29tcG9uZW50VHlwZV07XHJcbiAgICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgY29tcG9uZW50c09mVHlwZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgY29tcG9uZW50c09mVHlwZVtpXS5tdXRhdGUobXV0YXRvcnNGb3JUeXBlW2ldLCBudWxsLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoX211dGF0b3IuY2hpbGRyZW4pXHJcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZE5hbWUgaW4gX211dGF0b3IuY2hpbGRyZW4pXHJcbiAgICAgICAgICB0aGlzLmdldENoaWxkQnlOYW1lKGNoaWxkTmFtZSkuYXBwbHlBbmltYXRpb24oX211dGF0b3IuY2hpbGRyZW5bY2hpbGROYW1lXSk7XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gICAgLy8gI3JlZ2lvbiBDb21wb25lbnRzXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBjb21wb25lbnRzIGF0dGFjaGVkIHRvIHRoaXMgbm9kZSwgaW5kZXBlbmRlbnQgb2YgdHlwZS4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRBbGxDb21wb25lbnRzKCk6IENvbXBvbmVudFtdIHsgLy8gVE9ETzogcmV3b3JrIHRoaXNcclxuICAgICAgbGV0IGFsbDogQ29tcG9uZW50W10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgdHlwZSBpbiB0aGlzLmNvbXBvbmVudHMpIHtcclxuICAgICAgICBhbGwgPSBhbGwuY29uY2F0KHRoaXMuY29tcG9uZW50c1t0eXBlXSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgY29tcG9uZW50cyBvZiB0aGUgZ2l2ZW4gY2xhc3MgYXR0YWNoZWQgdG8gdGhpcyBub2RlLiBJZiBubyBjb21wb25lbnRzIG9mIHRoaXMgdHlwZSBhcmUgYXR0YWNoZWQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxyXG4gICAgICogQHJldHVybnMgQSAqKnJlYWRvbmx5KiogYXJyYXkgb2YgY29tcG9uZW50cy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbXBvbmVudHM8VCBleHRlbmRzIENvbXBvbmVudD4oX2NsYXNzOiBuZXcgKCkgPT4gVCk6IHJlYWRvbmx5IFRbXSB7XHJcbiAgICAgIHJldHVybiA8VFtdPih0aGlzLmNvbXBvbmVudHNbX2NsYXNzLm5hbWVdID8/PSBbXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjb21wb250ZW50IGZvdW5kIG9mIHRoZSBnaXZlbiBjbGFzcyBhdHRhY2hlZCB0aGlzIG5vZGUgb3IgbnVsbCwgaWYgbGlzdCBpcyBlbXB0eSBvciBkb2Vzbid0IGV4aXN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4oX2NsYXNzOiBuZXcgKCkgPT4gVCk6IFQge1xyXG4gICAgICByZXR1cm4gPFQ+dGhpcy5jb21wb25lbnRzW19jbGFzcy5uYW1lXT8uWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNoIHRoZSBnaXZlbiBjb21wb25lbnQgdG8gdGhpcyBub2RlLiBJZGVudGljYWwgdG8ge0BsaW5rIGFkZENvbXBvbmVudH1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGF0dGFjaChfY29tcG9uZW50OiBDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5hZGRDb21wb25lbnQoX2NvbXBvbmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2ggdGhlIGdpdmVuIGNvbXBvbmVudCB0byB0aGlzIG5vZGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZENvbXBvbmVudChfY29tcG9uZW50OiBDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgaWYgKF9jb21wb25lbnQubm9kZSA9PSB0aGlzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgbGV0IGNtcExpc3Q6IENvbXBvbmVudFtdID0gdGhpcy5jb21wb25lbnRzW19jb21wb25lbnQudHlwZV07XHJcbiAgICAgIGlmIChjbXBMaXN0ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRzW19jb21wb25lbnQudHlwZV0gPSBbX2NvbXBvbmVudF07XHJcbiAgICAgIGVsc2UgaWYgKGNtcExpc3QubGVuZ3RoICYmIF9jb21wb25lbnQuaXNTaW5nbGV0b24pXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgJHtfY29tcG9uZW50LnR5cGV9IGlzIG1hcmtlZCBzaW5nbGV0b24gYW5kIGNhbid0IGJlIGF0dGFjaGVkLCBubyBtb3JlIHRoYW4gb25lIGFsbG93ZWRgKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGNtcExpc3QucHVzaChfY29tcG9uZW50KTtcclxuXHJcbiAgICAgIF9jb21wb25lbnQuYXR0YWNoVG9Ob2RlKHRoaXMpO1xyXG4gICAgICBfY29tcG9uZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULkNPTVBPTkVOVF9BREQpKTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50VG9UYXJnZXRPbmx5KG5ldyBDdXN0b21FdmVudChFVkVOVC5DT01QT05FTlRfQURELCB7IGRldGFpbDogX2NvbXBvbmVudCB9KSk7IC8vIFRPRE86IHNlZSBpZiB0aGlzIGlzIGJlIGZlYXNhYmxlXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRhY2ggdGhlIGdpdmVuIGNvbXBvbmVudCBmcm9tIHRoaXMgbm9kZS4gSWRlbnRpY2FsIHRvIHtAbGluayByZW1vdmVDb21wb25lbnR9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZXRhY2goX2NvbXBvbmVudDogQ29tcG9uZW50KTogdm9pZCB7XHJcbiAgICAgIHRoaXMucmVtb3ZlQ29tcG9uZW50KF9jb21wb25lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgY29tcG9uZW50cyBvZiB0aGUgZ2l2ZW4gY2xhc3MgYXR0YWNoZWQgdG8gdGhpcyBub2RlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlQ29tcG9uZW50cyhfY2xhc3M6IG5ldyAoKSA9PiBDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgdGhpcy5nZXRDb21wb25lbnRzKF9jbGFzcykpXHJcbiAgICAgICAgdGhpcy5yZW1vdmVDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjb21wb25lbnQgZnJvbSB0aGUgbm9kZSwgaWYgaXQgd2FzIGF0dGFjaGVkLCBhbmQgc2V0cyBpdHMgcGFyZW50IHRvIG51bGwuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlQ29tcG9uZW50KF9jb21wb25lbnQ6IENvbXBvbmVudCk6IHZvaWQge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGxldCBjb21wb25lbnRzT2ZUeXBlOiBDb21wb25lbnRbXSA9IHRoaXMuY29tcG9uZW50c1tfY29tcG9uZW50LnR5cGVdO1xyXG4gICAgICAgIGxldCBmb3VuZEF0OiBudW1iZXIgPSBjb21wb25lbnRzT2ZUeXBlLmluZGV4T2YoX2NvbXBvbmVudCk7XHJcbiAgICAgICAgaWYgKGZvdW5kQXQgPCAwKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIF9jb21wb25lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSkpO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudFRvVGFyZ2V0T25seShuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgeyBkZXRhaWw6IF9jb21wb25lbnQgfSkpOyAvLyBUT0RPOiBzZWUgaWYgdGhpcyB3b3VsZCBiZSBmZWFzYWJsZVxyXG4gICAgICAgIGNvbXBvbmVudHNPZlR5cGUuc3BsaWNlKGZvdW5kQXQsIDEpO1xyXG4gICAgICAgIF9jb21wb25lbnQuYXR0YWNoVG9Ob2RlKG51bGwpO1xyXG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZW1vdmUgY29tcG9uZW50ICcke19jb21wb25lbnR9J2luIG5vZGUgbmFtZWQgJyR7dGhpcy5uYW1lfSdgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vICNyZWdpb24gU2VyaWFsaXphdGlvblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIGFjdGl2ZTogdGhpcy5hY3RpdmVcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGxldCBjb21wb25lbnRzOiBTZXJpYWxpemF0aW9uID0ge307XHJcbiAgICAgIGZvciAobGV0IHR5cGUgaW4gdGhpcy5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50c1t0eXBlXS5sZW5ndGggPT0gMClcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBjb21wb25lbnRzW3R5cGVdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgY29tcG9uZW50IG9mIHRoaXMuY29tcG9uZW50c1t0eXBlXSkge1xyXG4gICAgICAgICAgLy8gY29tcG9uZW50c1t0eXBlXS5wdXNoKGNvbXBvbmVudC5zZXJpYWxpemUoKSk7XHJcbiAgICAgICAgICBjb21wb25lbnRzW3R5cGVdLnB1c2goU2VyaWFsaXplci5zZXJpYWxpemUoY29tcG9uZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bXCJjb21wb25lbnRzXCJdID0gY29tcG9uZW50cztcclxuXHJcbiAgICAgIGxldCBjaGlsZHJlbjogU2VyaWFsaXphdGlvbltdID0gW107XHJcbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICBjaGlsZHJlbi5wdXNoKFNlcmlhbGl6ZXIuc2VyaWFsaXplKGNoaWxkKSk7XHJcbiAgICAgIH1cclxuICAgICAgc2VyaWFsaXphdGlvbltcImNoaWxkcmVuXCJdID0gY2hpbGRyZW47XHJcblxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk5PREVfU0VSSUFMSVpFRCkpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xyXG4gICAgICAvLyB0aGlzLnBhcmVudCA9IGlzIHNldCB3aGVuIHRoZSBub2RlcyBhcmUgYWRkZWRcclxuXHJcbiAgICAgIC8vIGRlc2VyaWFsaXplIGNvbXBvbmVudHMgZmlyc3Qgc28gc2NyaXB0cyBjYW4gcmVhY3QgdG8gY2hpbGRyZW4gYmVpbmcgYXBwZW5kZWRcclxuICAgICAgZm9yIChsZXQgdHlwZSBpbiBfc2VyaWFsaXphdGlvbi5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgc2VyaWFsaXplZENvbXBvbmVudCBvZiBfc2VyaWFsaXphdGlvbi5jb21wb25lbnRzW3R5cGVdKSB7XHJcbiAgICAgICAgICBsZXQgZGVzZXJpYWxpemVkQ29tcG9uZW50OiBDb21wb25lbnQgPSA8Q29tcG9uZW50PmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoc2VyaWFsaXplZENvbXBvbmVudCk7XHJcbiAgICAgICAgICB0aGlzLmFkZENvbXBvbmVudChkZXNlcmlhbGl6ZWRDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmNoaWxkcmVuKVxyXG4gICAgICAgIGZvciAobGV0IHNlcmlhbGl6ZWRDaGlsZCBvZiBfc2VyaWFsaXphdGlvbi5jaGlsZHJlbikge1xyXG4gICAgICAgICAgbGV0IGRlc2VyaWFsaXplZENoaWxkOiBOb2RlID0gPE5vZGU+YXdhaXQgU2VyaWFsaXplci5kZXNlcmlhbGl6ZShzZXJpYWxpemVkQ2hpbGQpO1xyXG4gICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChkZXNlcmlhbGl6ZWRDaGlsZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5OT0RFX0RFU0VSSUFMSVpFRCkpO1xyXG4gICAgICBmb3IgKGxldCBjb21wb25lbnQgb2YgdGhpcy5nZXRBbGxDb21wb25lbnRzKCkpXHJcbiAgICAgICAgY29tcG9uZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk5PREVfREVTRVJJQUxJWkVEKSk7XHJcblxyXG4gICAgICAvLyBUT0RPOiBjb25zaWRlciBpZiB0aGlzIGlzIGEgZ29vZCBpZGVhXHJcbiAgICAgIC8vIGNvbnN0IGhuZEdyYXBoRGVzZXJpYWxpemVkOiBFdmVudExpc3RlbmVyVW5pZmllZCA9ICgpID0+IHtcclxuICAgICAgLy8gICBmb3IgKGxldCBjb21wb25lbnQgb2YgdGhpcy5nZXRBbGxDb21wb25lbnRzKCkpXHJcbiAgICAgIC8vICAgICBjb21wb25lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuR1JBUEhfREVTRVJJQUxJWkVELCB7IGJ1YmJsZXM6IGZhbHNlIH0pKTtcclxuICAgICAgLy8gICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuR1JBUEhfREVTRVJJQUxJWkVELCBobmRHcmFwaERlc2VyaWFsaXplZCwgdHJ1ZSk7XHJcbiAgICAgIC8vICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULkdSQVBIX0lOU1RBTlRJQVRFRCwgaG5kR3JhcGhEZXNlcmlhbGl6ZWQsIHRydWUpO1xyXG4gICAgICAvLyB9O1xyXG4gICAgICAvLyB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuR1JBUEhfREVTRVJJQUxJWkVELCBobmRHcmFwaERlc2VyaWFsaXplZCwgdHJ1ZSk7XHJcbiAgICAgIC8vIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5HUkFQSF9JTlNUQU5USUFURUQsIGhuZEdyYXBoRGVzZXJpYWxpemVkLCB0cnVlKTtcclxuXHJcbiAgICAgIHRoaXMuYWN0aXZhdGUoX3NlcmlhbGl6YXRpb24uYWN0aXZlKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc3RyaW5nIGFzIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZSBhbmQgaXRzIGRlc2NlbmRhbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b0hpZXJhcmNoeVN0cmluZyhfbm9kZTogTm9kZSA9IG51bGwsIF9sZXZlbDogbnVtYmVyID0gMCk6IHN0cmluZyB7XHJcbiAgICAgIC8vIFRPRE86IHJlZmFjdG9yIGZvciBiZXR0ZXIgcmVhZGFiaWxpdHlcclxuICAgICAgaWYgKCFfbm9kZSlcclxuICAgICAgICBfbm9kZSA9IHRoaXM7XHJcblxyXG4gICAgICBsZXQgcHJlZml4OiBzdHJpbmcgPSBcIitcIi5yZXBlYXQoX2xldmVsKTtcclxuXHJcbiAgICAgIGxldCBvdXRwdXQ6IHN0cmluZyA9IHByZWZpeCArIFwiIFwiICsgX25vZGUubmFtZSArIFwiIHwgXCI7XHJcbiAgICAgIGZvciAobGV0IHR5cGUgaW4gX25vZGUuY29tcG9uZW50cylcclxuICAgICAgICBvdXRwdXQgKz0gX25vZGUuY29tcG9uZW50c1t0eXBlXS5sZW5ndGggKyBcIiBcIiArIHR5cGUuc3BsaXQoXCJDb21wb25lbnRcIikucG9wKCkgKyBcIiwgXCI7XHJcbiAgICAgIG91dHB1dCA9IG91dHB1dC5zbGljZSgwLCAtMikgKyBcIjwvYnI+XCI7XHJcbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIF9ub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgb3V0cHV0ICs9IHRoaXMudG9IaWVyYXJjaHlTdHJpbmcoY2hpbGQsIF9sZXZlbCArIDEpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gI3JlZ2lvbiBFdmVudHNcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgbm9kZS4gVGhlIGdpdmVuIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIG1hdGNoaW5nIGV2ZW50IGlzIHBhc3NlZCB0byB0aGUgbm9kZS5cclxuICAgICAqIERldmlhdGluZyBmcm9tIHRoZSBzdGFuZGFyZCBFdmVudFRhcmdldCwgaGVyZSB0aGUgX2hhbmRsZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIGFuZCBfY2FwdHVyZSBpcyB0aGUgb25seSBvcHRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRFdmVudExpc3RlbmVyKF90eXBlOiBFVkVOVCB8IHN0cmluZywgX2hhbmRsZXI6IEV2ZW50TGlzdGVuZXJVbmlmaWVkLCBfY2FwdHVyZTogYm9vbGVhbiAvKnwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMqLyA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGxpc3RMaXN0ZW5lcnM6IE1hcEV2ZW50VHlwZVRvTGlzdGVuZXJzID0gX2NhcHR1cmUgPyB0aGlzLiNjYXB0dXJlcyA6IHRoaXMuI2xpc3RlbmVycztcclxuICAgICAgY29uc3QgbGlzdGVuZXJzRm9yVHlwZTogU2V0PEV2ZW50TGlzdGVuZXJVbmlmaWVkPiA9IGxpc3RMaXN0ZW5lcnNbX3R5cGVdID8/PSBuZXcgU2V0KCk7XHJcbiAgICAgIGxpc3RlbmVyc0ZvclR5cGUuYWRkKF9oYW5kbGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGUgbm9kZS4gVGhlIHNpZ25hdHVyZSBtdXN0IG1hdGNoIHRoZSBvbmUgdXNlZCB3aXRoIGFkZEV2ZW50TGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUV2ZW50TGlzdGVuZXIoX3R5cGU6IEVWRU5UIHwgc3RyaW5nLCBfaGFuZGxlcjogRXZlbnRMaXN0ZW5lclVuaWZpZWQsIF9jYXB0dXJlOiBib29sZWFuIC8qfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyovID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgY29uc3QgbGlzdGVuZXJzRm9yVHlwZTogU2V0PEV2ZW50TGlzdGVuZXJVbmlmaWVkPiA9IF9jYXB0dXJlID8gdGhpcy4jY2FwdHVyZXNbX3R5cGVdIDogdGhpcy4jbGlzdGVuZXJzW190eXBlXTtcclxuICAgICAgaWYgKCFsaXN0ZW5lcnNGb3JUeXBlKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxpc3RlbmVyc0ZvclR5cGUuZGVsZXRlKF9oYW5kbGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc3BhdGNoZXMgYSBzeW50aGV0aWMgZXZlbnQgdG8gdGFyZ2V0LiBUaGlzIGltcGxlbWVudGF0aW9uIGFsd2F5cyByZXR1cm5zIHRydWUgKHN0YW5kYXJkOiByZXR1cm4gdHJ1ZSBvbmx5IGlmIGVpdGhlciBldmVudCdzIGNhbmNlbGFibGUgYXR0cmlidXRlIHZhbHVlIGlzIGZhbHNlIG9yIGl0cyBwcmV2ZW50RGVmYXVsdCgpIG1ldGhvZCB3YXMgbm90IGludm9rZWQpXHJcbiAgICAgKiBUaGUgZXZlbnQgdHJhdmVscyBpbnRvIHRoZSBoaWVyYXJjaHkgdG8gdGhpcyBub2RlIGRpc3BhdGNoaW5nIHRoZSBldmVudCwgaW52b2tpbmcgbWF0Y2hpbmcgaGFuZGxlcnMgb2YgdGhlIG5vZGVzIGFuY2VzdG9ycyBsaXN0ZW5pbmcgdG8gdGhlIGNhcHR1cmUgcGhhc2UsIFxyXG4gICAgICogdGhhbiB0aGUgbWF0Y2hpbmcgaGFuZGxlciBvZiB0aGUgdGFyZ2V0IG5vZGUgaW4gdGhlIHRhcmdldCBwaGFzZSwgYW5kIGJhY2sgb3V0IG9mIHRoZSBoaWVyYXJjaHkgaW4gdGhlIGJ1YmJsaW5nIHBoYXNlLCBpbnZva2luZyBhcHByb3ByaWF0ZSBoYW5kbGVycyBvZiB0aGUgYW52ZXN0b3JzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkaXNwYXRjaEV2ZW50KF9ldmVudDogRXZlbnQpOiBib29sZWFuIHtcclxuICAgICAgaWYgKF9ldmVudCBpbnN0YW5jZW9mIFJlY3ljbGFibGVFdmVudCkge1xyXG4gICAgICAgIF9ldmVudC5zZXRUYXJnZXQodGhpcyk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBwYXRoXHJcbiAgICAgICAgY29uc3QgcGF0aDogTm9kZVtdID0gPE5vZGVbXT5fZXZlbnQucGF0aDtcclxuICAgICAgICBwYXRoLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5nZXRQYXRoKHBhdGgpLnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gY2FwdHVyZSBwaGFzZVxyXG4gICAgICAgIF9ldmVudC5zZXRFdmVudFBoYXNlKEV2ZW50LkNBUFRVUklOR19QSEFTRSk7XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDE7IGktLSkge1xyXG4gICAgICAgICAgbGV0IGFuY2VzdG9yOiBOb2RlID0gcGF0aFtpXTtcclxuICAgICAgICAgIF9ldmVudC5zZXRDdXJyZW50VGFyZ2V0KGFuY2VzdG9yKTtcclxuICAgICAgICAgIHRoaXMuY2FsbExpc3RlbmVycyhhbmNlc3Rvci4jY2FwdHVyZXNbX2V2ZW50LnR5cGVdLCBfZXZlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdGFyZ2V0IHBoYXNlXHJcbiAgICAgICAgX2V2ZW50LnNldEV2ZW50UGhhc2UoRXZlbnQuQVRfVEFSR0VUKTtcclxuICAgICAgICBfZXZlbnQuc2V0Q3VycmVudFRhcmdldCh0aGlzKTtcclxuICAgICAgICB0aGlzLmNhbGxMaXN0ZW5lcnModGhpcy4jY2FwdHVyZXNbX2V2ZW50LnR5cGVdLCBfZXZlbnQpO1xyXG4gICAgICAgIHRoaXMuY2FsbExpc3RlbmVycyh0aGlzLiNsaXN0ZW5lcnNbX2V2ZW50LnR5cGVdLCBfZXZlbnQpO1xyXG5cclxuICAgICAgICAvLyBidWJibGUgcGhhc2VcclxuICAgICAgICBpZiAoIV9ldmVudC5idWJibGVzKVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIF9ldmVudC5zZXRFdmVudFBoYXNlKEV2ZW50LkJVQkJMSU5HX1BIQVNFKTtcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAxOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbGV0IGFuY2VzdG9yOiBOb2RlID0gcGF0aFtpXTtcclxuICAgICAgICAgIF9ldmVudC5zZXRDdXJyZW50VGFyZ2V0KGFuY2VzdG9yKTtcclxuICAgICAgICAgIHRoaXMuY2FsbExpc3RlbmVycyhhbmNlc3Rvci4jbGlzdGVuZXJzW19ldmVudC50eXBlXSwgX2V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGFuY2VzdG9yczogTm9kZVtdID0gW107XHJcbiAgICAgICAgbGV0IHVwY29taW5nOiBOb2RlID0gdGhpcztcclxuICAgICAgICAvLyBvdmVyd3JpdGUgZXZlbnQgdGFyZ2V0XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJ0YXJnZXRcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRoaXMgfSk7XHJcbiAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgdXNpbmcgUmVmbGVjdCBpbnN0ZWFkIG9mIE9iamVjdCB0aHJvdWdob3V0LiBTZWUgYWxzbyBSZW5kZXIgYW5kIE11dGFibGUuLi5cclxuICAgICAgICB3aGlsZSAodXBjb21pbmcucGFyZW50KVxyXG4gICAgICAgICAgYW5jZXN0b3JzLnB1c2godXBjb21pbmcgPSB1cGNvbWluZy5wYXJlbnQpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwicGF0aFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogbmV3IEFycmF5PE5vZGU+KHRoaXMsIC4uLmFuY2VzdG9ycykgfSk7XHJcblxyXG4gICAgICAgIC8vIGNhcHR1cmUgcGhhc2VcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2V2ZW50LCBcImV2ZW50UGhhc2VcIiwgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IEV2ZW50LkNBUFRVUklOR19QSEFTRSB9KTtcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSBhbmNlc3RvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgIGxldCBhbmNlc3RvcjogTm9kZSA9IGFuY2VzdG9yc1tpXTtcclxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogYW5jZXN0b3IgfSk7XHJcbiAgICAgICAgICB0aGlzLmNhbGxMaXN0ZW5lcnMoYW5jZXN0b3IuI2NhcHR1cmVzW19ldmVudC50eXBlXSwgX2V2ZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRhcmdldCBwaGFzZVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiZXZlbnRQaGFzZVwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogRXZlbnQuQVRfVEFSR0VUIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcyB9KTtcclxuICAgICAgICB0aGlzLmNhbGxMaXN0ZW5lcnModGhpcy4jY2FwdHVyZXNbX2V2ZW50LnR5cGVdLCBfZXZlbnQpO1xyXG4gICAgICAgIHRoaXMuY2FsbExpc3RlbmVycyh0aGlzLiNsaXN0ZW5lcnNbX2V2ZW50LnR5cGVdLCBfZXZlbnQpO1xyXG5cclxuICAgICAgICBpZiAoIV9ldmVudC5idWJibGVzKVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIC8vIGJ1YmJsZSBwaGFzZVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiZXZlbnRQaGFzZVwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogRXZlbnQuQlVCQkxJTkdfUEhBU0UgfSk7XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbGV0IGFuY2VzdG9yOiBOb2RlID0gYW5jZXN0b3JzW2ldO1xyXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJjdXJyZW50VGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBhbmNlc3RvciB9KTtcclxuICAgICAgICAgIHRoaXMuY2FsbExpc3RlbmVycyhhbmNlc3Rvci4jbGlzdGVuZXJzW19ldmVudC50eXBlXSwgX2V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0cnVlOyAvL1RPRE86IHJldHVybiBhIG1lYW5pbmdmdWwgdmFsdWUsIHNlZSBkb2N1bWVudGF0aW9uIG9mIGRpc3BhdGNoIGV2ZW50XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYXRjaGVzIGEgc3ludGhldGljIGV2ZW50IHRvIHRhcmdldCB3aXRob3V0IHRyYXZlbGxpbmcgdGhyb3VnaCB0aGUgZ3JhcGggaGllcmFyY2h5IG5laXRoZXIgZHVyaW5nIGNhcHR1cmUgbm9yIGJ1YmJsaW5nIHBoYXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkaXNwYXRjaEV2ZW50VG9UYXJnZXRPbmx5KF9ldmVudDogRXZlbnQpOiBib29sZWFuIHtcclxuICAgICAgaWYgKF9ldmVudCBpbnN0YW5jZW9mIFJlY3ljbGFibGVFdmVudCkge1xyXG4gICAgICAgIF9ldmVudC5zZXRDdXJyZW50VGFyZ2V0KHRoaXMpO1xyXG4gICAgICAgIF9ldmVudC5zZXRFdmVudFBoYXNlKEV2ZW50LkFUX1RBUkdFVCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJldmVudFBoYXNlXCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBFdmVudC5BVF9UQVJHRVQgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9ldmVudCwgXCJjdXJyZW50VGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0aGlzIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmNhbGxMaXN0ZW5lcnModGhpcy4jbGlzdGVuZXJzW19ldmVudC50eXBlXSwgX2V2ZW50KTsgLy8gVE9ETzogZXhhbWluZSBpZiB0aGlzIHNob3VsZCBnbyB0byB0aGUgY2FwdHVyZXMgaW5zdGVhZCBvZiB0aGUgbGlzdGVuZXJzXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnJvYWRjYXN0cyBhIHN5bnRoZXRpYyBldmVudCB0byB0aGlzIG5vZGUgYW5kIGZyb20gdGhlcmUgdG8gYWxsIG5vZGVzIGRlZXBlciBpbiB0aGUgaGllcmFyY2h5LFxyXG4gICAgICogaW52b2tpbmcgbWF0Y2hpbmcgaGFuZGxlcnMgb2YgdGhlIG5vZGVzIGxpc3RlbmluZyB0byB0aGUgY2FwdHVyZSBwaGFzZS4gV2F0Y2ggcGVyZm9ybWFuY2Ugd2hlbiB0aGVyZSBhcmUgbWFueSBub2RlcyBpbnZvbHZlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYnJvYWRjYXN0RXZlbnQoX2V2ZW50OiBFdmVudCk6IHZvaWQge1xyXG4gICAgICBpZiAoX2V2ZW50IGluc3RhbmNlb2YgUmVjeWNsYWJsZUV2ZW50KSB7XHJcbiAgICAgICAgX2V2ZW50LnNldEN1cnJlbnRUYXJnZXQodGhpcyk7XHJcbiAgICAgICAgX2V2ZW50LnNldEV2ZW50UGhhc2UoRXZlbnQuQ0FQVFVSSU5HX1BIQVNFKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBvdmVyd3JpdGUgZXZlbnQgdGFyZ2V0IGFuZCBwaGFzZVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiZXZlbnRQaGFzZVwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogRXZlbnQuQ0FQVFVSSU5HX1BIQVNFIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwidGFyZ2V0XCIsIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0aGlzIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmJyb2FkY2FzdEV2ZW50UmVjdXJzaXZlKF9ldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBicm9hZGNhc3RFdmVudFJlY3Vyc2l2ZShfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICAgIGlmIChfZXZlbnQgaW5zdGFuY2VvZiBSZWN5Y2xhYmxlRXZlbnQpXHJcbiAgICAgICAgX2V2ZW50LnNldEV2ZW50UGhhc2UoRXZlbnQuQ0FQVFVSSU5HX1BIQVNFKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXZlbnQsIFwiY3VycmVudFRhcmdldFwiLCB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcyB9KTtcclxuXHJcbiAgICAgIHRoaXMuY2FsbExpc3RlbmVycyh0aGlzLiNjYXB0dXJlc1tfZXZlbnQudHlwZV0sIF9ldmVudCk7XHJcblxyXG4gICAgICAvLyBzYW1lIGZvciBjaGlsZHJlblxyXG4gICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgY2hpbGQuYnJvYWRjYXN0RXZlbnRSZWN1cnNpdmUoX2V2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbHMgdGhlIGxpc3RlbmVycyB3aXRoIHRoZSBnaXZlbiBldmVudC4gVGhlIGxpc3RlbmVycyBhcmUgY2FsbGVkIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgYWRkZWQuIEhhbmRsZXMgbGlzdGVuZXJzIHJlbW92aW5nIHRoZW1zZWx2ZXMgb3Igb3RoZXIgbGlzdGVuZXJzIGZyb20gdGhlIGxpc3QgZHVyaW5nIGV4ZWN1dGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjYWxsTGlzdGVuZXJzKF9saXN0ZW5lcnM6IFNldDxFdmVudExpc3RlbmVyVW5pZmllZD4sIF9ldmVudDogRXZlbnQpOiB2b2lkIHtcclxuICAgICAgaWYgKCFfbGlzdGVuZXJzIHx8IF9saXN0ZW5lcnMuc2l6ZSA9PSAwKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBfbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGhhbmRsZXIoX2V2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vVHJhbnNmZXIvU2VyaWFsaXplci50c1wiLz5cclxuLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UcmFuc2Zlci9NdXRhYmxlLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKiogXHJcbiAgICogU3VwZXJjbGFzcyBmb3IgYWxsIHtAbGluayBDb21wb25lbnR9cyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byB7QGxpbmsgTm9kZX1zLlxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwIHwgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgIFxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ocy1mdXJ0d2FuZ2VuL0ZVREdFL3dpa2kvQ29tcG9uZW50XHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIENvbXBvbmVudCBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUsIEdpem1vIHtcclxuICAgIC8qKiBzdWJjbGFzc2VzIGdldCBhIGlTdWJjbGFzcyBudW1iZXIgZm9yIGlkZW50aWZpY2F0aW9uICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyO1xyXG4gICAgLyoqIHJlZmVycyBiYWNrIHRvIHRoaXMgY2xhc3MgZnJvbSBhbnkgc3ViY2xhc3MgZS5nLiBpbiBvcmRlciB0byBmaW5kIGNvbXBhdGlibGUgb3RoZXIgcmVzb3VyY2VzKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgYmFzZUNsYXNzOiB0eXBlb2YgQ29tcG9uZW50ID0gQ29tcG9uZW50O1xyXG4gICAgLyoqIGxpc3Qgb2YgYWxsIHRoZSBzdWJjbGFzc2VzIGRlcml2ZWQgZnJvbSB0aGlzIGNsYXNzLCBpZiB0aGV5IHJlZ2lzdGVyZWQgcHJvcGVybHkqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBzdWJjbGFzc2VzOiB0eXBlb2YgQ29tcG9uZW50W10gPSBbXTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc2luZ2xldG9uOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHByb3RlY3RlZCBhY3RpdmU6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgI25vZGU6IE5vZGUgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5NVVRBVEUsIChfZXZlbnQ6IEN1c3RvbUV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuI25vZGUpIHtcclxuICAgICAgICAgIC8vIFRPRE86IGZpbmQgdGhlIG51bWJlciBvZiB0aGUgY29tcG9uZW50IGluIHRoZSBhcnJheSBpZiBub3Qgc2luZ2xldG9uXHJcbiAgICAgICAgICBfZXZlbnQuZGV0YWlsLmNvbXBvbmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgIF9ldmVudC5kZXRhaWwuY29tcG9uZW50SW5kZXggPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50cyh0aGlzLmNvbnN0cnVjdG9yKS5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgICAgdGhpcy4jbm9kZS5kaXNwYXRjaEV2ZW50KF9ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlZ2lzdGVyU3ViY2xhc3MoX3N1YmNsYXNzOiB0eXBlb2YgQ29tcG9uZW50KTogbnVtYmVyIHsgcmV0dXJuIENvbXBvbmVudC5zdWJjbGFzc2VzLnB1c2goX3N1YmNsYXNzKSAtIDE7IH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzQWN0aXZlKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0cnVlLCB3aGVuIG9ubHkgb25lIGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQgY2xhc3MgY2FuIGJlIGF0dGFjaGVkIHRvIGEgbm9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGlzU2luZ2xldG9uKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5zaW5nbGV0b247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG5vZGUsIHRoaXMgY29tcG9uZW50IGlzIGN1cnJlbnRseSBhdHRhY2hlZCB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG5vZGUoKTogTm9kZSB8IG51bGwge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbm9kZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlLSAvIEFjdGl2YXRlIHRoaXMgY29tcG9uZW50LiBJbmFjdGl2ZSBjb21wb25lbnRzIHdpbGwgbm90IGJlIHByb2Nlc3NlZCBieSB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhY3RpdmF0ZShfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgdGhpcy5hY3RpdmUgPSBfb247XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoX29uID8gRVZFTlQuQ09NUE9ORU5UX0FDVElWQVRFIDogRVZFTlQuQ09NUE9ORU5UX0RFQUNUSVZBVEUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyaWVzIHRvIGF0dGFjaCB0aGUgY29tcG9uZW50IHRvIHRoZSBnaXZlbiBub2RlLCByZW1vdmluZyBpdCBmcm9tIHRoZSBub2RlIGl0IHdhcyBhdHRhY2hlZCB0byBpZiBhcHBsaWNhYmxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhdHRhY2hUb05vZGUoX2NvbnRhaW5lcjogTm9kZSB8IG51bGwpOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuI25vZGUgPT0gX2NvbnRhaW5lcilcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGxldCBwcmV2aW91c0NvbnRhaW5lcjogTm9kZSA9IHRoaXMuI25vZGU7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHByZXZpb3VzQ29udGFpbmVyKVxyXG4gICAgICAgICAgcHJldmlvdXNDb250YWluZXIucmVtb3ZlQ29tcG9uZW50KHRoaXMpO1xyXG4gICAgICAgIHRoaXMuI25vZGUgPSBfY29udGFpbmVyO1xyXG4gICAgICAgIGlmICh0aGlzLiNub2RlKVxyXG4gICAgICAgICAgdGhpcy4jbm9kZS5hZGRDb21wb25lbnQodGhpcyk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIHRoaXMuI25vZGUgPSBwcmV2aW91c0NvbnRhaW5lcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGUgdGhpcyB0byBkcmF3IHZpc3VhbCBhaWRzIGZvciB0aGlzIGNvbXBvbmVudCBpbnNpZGUgdGhlIGVkaXRvcnMgcmVuZGVyIHZpZXcuIFVzZSB7QGxpbmsgR2l6bW9zfSBpbnNpZGUgdGhlIG92ZXJyaWRlIHRvIGRyYXcgc3R1ZmYuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkcmF3R2l6bW9zPyhfY21wQ2FtZXJhPzogQ29tcG9uZW50Q2FtZXJhKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlZSB7QGxpbmsgZHJhd0dpem1vc30uIE9ubHkgZGlzcGxheWVkIHdoaWxlIHRoZSBjb3JyZXNwb25kaW5nIG5vZGUgaXMgc2VsZWN0ZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkcmF3R2l6bW9zU2VsZWN0ZWQ/KF9jbXBDYW1lcmE/OiBDb21wb25lbnRDYW1lcmEpOiB2b2lkO1xyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgYWN0aXZlOiB0aGlzLmFjdGl2ZVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlKF9zZXJpYWxpemF0aW9uLmFjdGl2ZSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb24/OiBzdHJpbmdbXSwgX2Rpc3BhdGNoTXV0YXRlPzogYm9vbGVhbik6IHZvaWQgfCBQcm9taXNlPHZvaWQ+OyAvLyBhbGxvdyBzeW5jIG9yIGFzeW5jIG92ZXJyaWRlc1xyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgICAgaWYgKF9tdXRhdG9yLmFjdGl2ZSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZShfbXV0YXRvci5hY3RpdmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBtdXRhdGVTeW5jKF9tdXRhdG9yOiBNdXRhdG9yLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLm11dGF0ZVN5bmMoX211dGF0b3IsIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICAgIGlmIChfbXV0YXRvci5hY3RpdmUgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUoX211dGF0b3IuYWN0aXZlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iuc2luZ2xldG9uO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IubXR4V29ybGQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogV3JhcHMgYSByZWd1bGFyIEphdmFzY3JpcHQgQXJyYXkgYW5kIG9mZmVycyB2ZXJ5IGxpbWl0ZWQgZnVuY3Rpb25hbGl0eSBnZWFyZWQgc29sZWx5IHRvd2FyZHMgYXZvaWRpbmcgZ2FyYmFnZSBjb2xsZXRpb24uXHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ocy1mdXJ0d2FuZ2VuL0ZVREdFL3dpa2kvUmVjeWNsZXJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUmVjeWNhYmxlQXJyYXk8VD4geyAvLyBUT0RPOiBmaXggc3BlbGxpbmcgUmVjeWNhYmxlIC0+IFJlY3ljbGFibGVcclxuICAgICNsZW5ndGg6IG51bWJlciA9IDA7XHJcbiAgICAjYXJyYXk6IEFycmF5PFQ+ID0gbmV3IEFycmF5PFQ+KCk7XHJcbiAgICAvLyAjdHlwZTogbmV3ICgpID0+IFQ7XHJcblxyXG4gICAgLy8gLy90c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAvLyBjb25zdHJ1Y3RvcihfdHlwZTogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gVCkge1xyXG4gICAgLy8gICB0aGlzLiN0eXBlID0gX3R5cGU7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcHVibGljIGdldCBsZW5ndGgoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2xlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZpcnR1YWwgbGVuZ3RoIG9mIHRoZSBhcnJheSB0byB6ZXJvIGJ1dCBrZWVwcyB0aGUgZW50cmllcyBiZXlvbmQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jbGVuZ3RoID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3ljbGUgdGhpcyBhcnJheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBhIG5ldyBlbnRyeSB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSwgYW5kIHJldHVybnMgdGhlIG5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcHVzaChfZW50cnk6IFQpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLiNhcnJheVt0aGlzLiNsZW5ndGhdID0gX2VudHJ5O1xyXG4gICAgICB0aGlzLiNsZW5ndGgrKztcclxuICAgICAgcmV0dXJuIHRoaXMuI2xlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGxhc3QgZW50cnkgZnJvbSB0aGUgYXJyYXkgYW5kIHJldHVybnMgaXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb3AoKTogVCB7XHJcbiAgICAgIGlmICh0aGlzLiNsZW5ndGggPT0gMClcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgdGhpcy4jbGVuZ3RoLS07XHJcbiAgICAgIHJldHVybiB0aGlzLiNhcnJheVt0aGlzLiNsZW5ndGhdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVjeWNsZXMgdGhlIG9iamVjdCBmb2xsb3dpbmcgdGhlIGxhc3QgaW4gdGhlIGFycmF5IGFuZCBpbmNyZWFzZXMgdGhlIGFycmF5IGxlbmd0aFxyXG4gICAgICogSXQgbXVzdCBiZSBhc3N1cmVkLCB0aGF0IG5vbmUgb2YgdGhlIG9iamVjdHMgaW4gdGhlIGFycmF5IGlzIHN0aWxsIGluIGFueSB1c2Ugb2YgYW55IGtpbmQhXHJcbiAgICAgKi9cclxuICAgIC8vIHB1YmxpYyByZWN5Y2xlKCk6IFQge1xyXG4gICAgLy8gICBpZiAodGhpcy4jbGVuZ3RoIDwgdGhpcy4jYXJyYXkubGVuZ3RoKSB7XHJcbiAgICAvLyAgICAgdGhpcy4jbGVuZ3RoKys7XHJcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMuI2FycmF5W3RoaXMuI2xlbmd0aCsrXTtcclxuICAgIC8vICAgfVxyXG4gICAgLy8gICB0aGlzLiNhcnJheS5wdXNoKFJlY3ljbGVyLmdldCh0aGlzLiN0eXBlKSk7XHJcbiAgICAvLyAgIHJldHVybiB0aGlzLiNhcnJheVt0aGlzLiNsZW5ndGgrK107XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcHVibGljICpbU3ltYm9sLml0ZXJhdG9yXSgpOiBJdGVyYWJsZUl0ZXJhdG9yPFQ+IHtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuI2xlbmd0aDsgaSsrKVxyXG4gICAgICAgIHlpZWxkIHRoaXMuI2FycmF5W2ldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGFycmF5IHNvcnRlZCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGNvbXBhcmUgZnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFNvcnRlZChfc29ydDogKGE6IFQsIGI6IFQpID0+IG51bWJlcik6IFRbXSB7XHJcbiAgICAgIGxldCBzb3J0ZWQ6IFRbXSA9IHRoaXMuI2FycmF5LnNsaWNlKDAsIHRoaXMuI2xlbmd0aCk7XHJcbiAgICAgIHNvcnRlZC5zb3J0KF9zb3J0KTtcclxuICAgICAgcmV0dXJuIHNvcnRlZDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfUEhZU0lDUyB7XHJcbiAgICBUUklHR0VSX0VOVEVSID0gXCJUcmlnZ2VyRW50ZXJlZENvbGxpc2lvblwiLFxyXG4gICAgVFJJR0dFUl9FWElUID0gXCJUcmlnZ2VyTGVmdENvbGxpc2lvblwiLFxyXG4gICAgQ09MTElTSU9OX0VOVEVSID0gXCJDb2xsaWRlckVudGVyZWRDb2xsaXNpb25cIixcclxuICAgIENPTExJU0lPTl9FWElUID0gXCJDb2xsaWRlckxlZnRDb2xsaXNpb25cIlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3BlY2lhbCB0eXBlIG9mIHtAbGluayBFdmVudH0gZm9yIHBoeXNpY3MuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEV2ZW50UGh5c2ljcyBleHRlbmRzIEV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcG9uZW50UmlnaWRib2R5IHRoYXQgY29sbGlkZWQgd2l0aCB0aGlzIENvbXBvbmVudFJpZ2lkYm9keVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY21wUmlnaWRib2R5OiBDb21wb25lbnRSaWdpZGJvZHk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBub3JtYWwgaW1wdWxzZSBiZXR3ZWVuIHRoZSB0d28gY29sbGlkaW5nIG9iamVjdHMuIE5vcm1hbCByZXByZXNlbnRzIHRoZSBkZWZhdWx0IGltcHVsc2UuXHJcbiAgICAgKiBJbXB1bHNlIGlzIG9ubHkgaGFwcGVuaW5nIG9uIENPTExJU0lPTl9FTlRFUiwgc28gdGhlcmUgaXMgbm8gaW1wdWxzZSBvbiBleGl0IG5vciBvbiB0cmlnZ2Vycy5cclxuICAgICAqIFVzZSB0aGUgdmVsb2NpdHkgb2YgdGhlIGNtcFJpZ2lkYm9keSB0byBkZXRlcm1pbmUgdGhlIGludGVuc2l0eSBvZiB0aGUgRVZFTlQgaW5zdGVhZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vcm1hbEltcHVsc2U6IG51bWJlcjtcclxuICAgIHB1YmxpYyB0YW5nZW50SW1wdWxzZTogbnVtYmVyO1xyXG4gICAgcHVibGljIGJpbm9tYWxJbXB1bHNlOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIHBvaW50IHdoZXJlIHRoZSBjb2xsaXNpb24vdHJpZ2dlcmluZyBpbml0aWFsbHkgaGFwcGVuZWQuIFRoZSBjb2xsaXNpb24gcG9pbnQgZXhpc3RzIG9ubHkgb24gQ09MTElTSU9OX0VOVEVSIC8gVFJJR0dFUl9FTlRFUi4gKi9cclxuICAgIHB1YmxpYyBjb2xsaXNpb25Qb2ludDogVmVjdG9yMztcclxuICAgIC8qKiBUaGUgbm9ybWFsIHZlY3RvciBvZiB0aGUgY29sbGlzaW9uLiBPbmx5IGV4aXN0aW5nIG9uIENPTExJU0lPTl9FTlRFUiAqL1xyXG4gICAgcHVibGljIGNvbGxpc2lvbk5vcm1hbDogVmVjdG9yMztcclxuXHJcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBldmVudCBjdXN0b21pemVkIGZvciBwaHlzaWNzLiBIb2xkaW5nIGluZm9ybWF0aW9ucyBhYm91dCBpbXB1bHNlcy4gQ29sbGlzaW9uIHBvaW50IGFuZCB0aGUgYm9keSB0aGF0IGlzIGNvbGxpZGluZyAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF90eXBlOiBFVkVOVF9QSFlTSUNTLCBfaGl0UmlnaWRib2R5OiBDb21wb25lbnRSaWdpZGJvZHksIF9ub3JtYWxJbXB1bHNlOiBudW1iZXIsIF90YW5nZW50SW1wdWxzZTogbnVtYmVyLCBfYmlub3JtYWxJbXB1bHNlOiBudW1iZXIsIF9jb2xsaXNpb25Qb2ludDogVmVjdG9yMyA9IG51bGwsIF9jb2xsaXNpb25Ob3JtYWw6IFZlY3RvcjMgPSBudWxsKSB7XHJcbiAgICAgIHN1cGVyKF90eXBlKTtcclxuICAgICAgdGhpcy5jbXBSaWdpZGJvZHkgPSBfaGl0UmlnaWRib2R5O1xyXG4gICAgICB0aGlzLm5vcm1hbEltcHVsc2UgPSBfbm9ybWFsSW1wdWxzZTtcclxuICAgICAgdGhpcy50YW5nZW50SW1wdWxzZSA9IF90YW5nZW50SW1wdWxzZTtcclxuICAgICAgdGhpcy5iaW5vbWFsSW1wdWxzZSA9IF9iaW5vcm1hbEltcHVsc2U7XHJcbiAgICAgIHRoaXMuY29sbGlzaW9uUG9pbnQgPSBfY29sbGlzaW9uUG9pbnQ7XHJcbiAgICAgIHRoaXMuY29sbGlzaW9uTm9ybWFsID0gX2NvbGxpc2lvbk5vcm1hbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogR3JvdXBzIHRvIHBsYWNlIGEgbm9kZSBpbiwgbm90IGV2ZXJ5IGdyb3VwIHNob3VsZCBjb2xsaWRlIHdpdGggZXZlcnkgZ3JvdXAuIFVzZSBhIE1hc2sgaW4gdG8gZXhjbHVkZSBjb2xsaXNpb25zXHJcbiAgKi9cclxuICBleHBvcnQgZW51bSBDT0xMSVNJT05fR1JPVVAgeyAvL1RPRE8gR2l2ZSBhIHBvc3NpYmxpdGh5IHRvIHNldCB3aGljaCBsYXllciBjb2xsaWRlcyB3aXRoIHdoaWNoLCBDb2xsaXNpb25NYXRyaXg/XHJcbiAgICBERUZBVUxUID0gMSxcclxuICAgIEdST1VQXzEgPSAyLFxyXG4gICAgR1JPVVBfMiA9IDQsXHJcbiAgICBHUk9VUF8zID0gOCxcclxuICAgIEdST1VQXzQgPSAxNixcclxuICAgIEdST1VQXzUgPSAzMlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgKiBEZWZpbmVzIHRoZSB0eXBlIG9mIHRoZSByaWdpZGJvZHkgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgd2F5IGl0IGludGVyYWN0cyB3aXRoIHRoZSBwaHlzaWNhbCBhbmQgdGhlIHZpc3VhbCB3b3JsZFxyXG4gICovXHJcbiAgZXhwb3J0IGVudW0gQk9EWV9UWVBFIHtcclxuICAgIC8qKiBUaGUgYm9keSBpZ25vcmVzIHRoZSBoaWVyYXJjaHkgb2YgdGhlIHJlbmRlciBncmFwaCwgaXMgY29tcGxldGVseSBjb250cm9sbGVkICBieSBwaHlzaWNzIGFuZCB0YWtlcyBpdHMgbm9kZSB3aXRoIGl0ICAqL1xyXG4gICAgRFlOQU1JQywgLy8gPSBPSU1PLlJpZ2lkQm9keVR5cGUuRFlOQU1JQyxcclxuICAgIC8qKiBUaGUgYm9keSBpZ25vcmVzIHRoZSBoaWVyYXJjaHkgb2YgdGhlIHJlbmRlciBncmFwaCwgaXMgY29tcGxldGVseSBpbW1vdmVibGUgYW5kIGtlZXBzIGl0cyBub2RlIGZyb20gbW92aW5nICAqL1xyXG4gICAgU1RBVElDLCAvLyA9IE9JTU8uUmlnaWRCb2R5VHlwZS5TVEFUSUMsXHJcbiAgICAvKiogVGhlIGJvZHkgaXMgY29udHJvbGxlZCBieSBpdHMgbm9kZSBhbmQgbW92ZXMgd2l0aCBpdCwgd2hpbGUgaXQgaW1wYWN0cyB0aGUgcGh5c2ljYWwgd29ybGQgZS5nLiBieSBjb2xsaXNpb25zICovXHJcbiAgICBLSU5FTUFUSUMgLy8gPSBPSU1PLlJpZ2lkQm9keVR5cGUuS0lORU1BVElDXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIERpZmZlcmVudCB0eXBlcyBvZiBjb2xsaWRlciBzaGFwZXMsIHdpdGggZGlmZmVyZW50IG9wdGlvbnMgaW4gc2NhbGluZyBCT1ggPSBWZWN0b3IzKGxlbmd0aCwgaGVpZ2h0LCBkZXB0aCksXHJcbiAgKiBTUEhFUkUgPSBWZWN0b3IzKGRpYW1ldGVyLCB4LCB4KSwgQ0FQU1VMRSA9IFZlY3RvcjMoZGlhbWV0ZXIsIGhlaWdodCwgeCksIENZTElOREVSID0gVmVjdG9yMyhkaWFtZXRlciwgaGVpZ2h0LCB4KSxcclxuICAqIENPTkUgPSBWZWN0b3IoZGlhbWV0ZXIsIGhlaWdodCwgeCksIFBZUkFNSUQgPSBWZWN0b3IzKGxlbmd0aCwgaGVpZ2h0LCBkZXB0aCk7IHggPT0gdW51c2VkLlxyXG4gICogQ09OVkVYID0gQ29tcG9uZW50TWVzaCBuZWVkcyB0byBiZSBhdmFpbGFibGUgaW4gdGhlIFJCIFByb3BlcnR5IGNvbnZleE1lc2gsIHRoZSBwb2ludHMgb2YgdGhhdCBjb21wb25lbnQgYXJlIHVzZWQgdG8gY3JlYXRlIGEgY29sbGlkZXIgdGhhdCBtYXRjaGVzLFxyXG4gICogdGhlIGNsb3Nlc3QgcG9zc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhhdCBmb3JtLCBpbiBmb3JtIG9mIGEgaHVsbC4gQ29udmV4IGlzIGV4cGVyaW1lbnRhbCBhbmQgY2FuIHByb2R1Y2UgdW5leHBlY3RlZCBiZWhhdmlvdXIgd2hlbiB2ZXJ0aWNlc1xyXG4gICogYXJlIHRvbyBjbG9zZSB0byBvbmUgYW5vdGhlciBhbmQgdGhlIGdpdmVuIHZlcnRpY2VzIGRvIG5vdCBmb3JtIGEgaW4gaXRzZWxmIGNsb3NlZCBzaGFwZSBhbmQgaGF2aW5nIGEgZ2VudXMgb2YgMCAobm8gaG9sZXMpLiBWZXJ0aWNlcyBpbiB0aGUgQ29tcG9uZW50TWVzaCBjYW4gYmUgc2NhbGVkIGRpZmZlcmVudGx5IFxyXG4gICogZm9yIHRleHR1cmluZy9ub3JtYWwgb3Igb3RoZXIgcmVhc29ucywgc28gdGhlIGNvbGxpZGVyIG1pZ2h0IGJlIG9mZiBjb21wYXJlZCB0byB0aGUgdmlzdWFsIHNoYXBlLCB0aGlzIGNhbiBiZSBjb3JyZWN0ZWQgYnkgY2hhbmdpbmcgdGhlIHBpdm90IHNjYWxlIG9mIHRoZSBDb21wb25lbnRSaWdpZGJvZHkuICBcclxuICAqL1xyXG4gIGV4cG9ydCBlbnVtIENPTExJREVSX1RZUEUge1xyXG4gICAgQ1VCRSxcclxuICAgIFNQSEVSRSxcclxuICAgIENBUFNVTEUsXHJcbiAgICBDWUxJTkRFUixcclxuICAgIENPTkUsXHJcbiAgICBQWVJBTUlELFxyXG4gICAgQ09OVkVYXHJcbiAgfVxyXG5cclxuICAvKiogRGlzcGxheWluZyBkaWZmZXJlbnQgdHlwZXMgb2YgZGVidWcgaW5mb3JtYXRpb24gYWJvdXQgZGlmZmVyZW50IHBoeXNpYyBmZWF0dXJlcy4gRGVmYXVsdCA9IEpPSU5UU19BTkRfQ09MTElERVIuICovXHJcbiAgZXhwb3J0IGVudW0gUEhZU0lDU19ERUJVR01PREUge1xyXG4gICAgTk9ORSxcclxuICAgIENPTExJREVSUyxcclxuICAgIEpPSU5UU19BTkRfQ09MTElERVIsXHJcbiAgICBCT1VORElOR19CT1hFUyxcclxuICAgIENPTlRBQ1RTLFxyXG4gICAgUEhZU0lDX09CSkVDVFNfT05MWVxyXG4gIH1cclxuXHJcbiAgLyoqIEluZm8gYWJvdXQgUmF5Y2FzdHMgc2hvdCBmcm9tIHRoZSBwaHlzaWNzIHN5c3RlbS4gKi9cclxuICBleHBvcnQgY2xhc3MgUmF5SGl0SW5mbyBpbXBsZW1lbnRzIFJlY3ljYWJsZSB7XHJcbiAgICBwdWJsaWMgaGl0OiBib29sZWFuO1xyXG4gICAgcHVibGljIGhpdERpc3RhbmNlOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgaGl0UG9pbnQ6IFZlY3RvcjMgPSBWZWN0b3IzLlpFUk8oKTtcclxuICAgIHB1YmxpYyByaWdpZGJvZHlDb21wb25lbnQ6IENvbXBvbmVudFJpZ2lkYm9keTtcclxuICAgIHB1YmxpYyBoaXROb3JtYWw6IFZlY3RvcjMgPSBWZWN0b3IzLlpFUk8oKTtcclxuICAgIHB1YmxpYyByYXlFbmQ6IFZlY3RvcjMgPSBWZWN0b3IzLlpFUk8oKTtcclxuICAgIHB1YmxpYyByYXlPcmlnaW46IFZlY3RvcjMgPSBWZWN0b3IzLlpFUk8oKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHRoaXMucmVjeWNsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmhpdCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmhpdERpc3RhbmNlID0gMDtcclxuICAgICAgdGhpcy5oaXRQb2ludC5yZWN5Y2xlKCk7XHJcbiAgICAgIHRoaXMucmlnaWRib2R5Q29tcG9uZW50ID0gbnVsbDtcclxuICAgICAgdGhpcy5oaXROb3JtYWwucmVjeWNsZSgpO1xyXG4gICAgICB0aGlzLnJheU9yaWdpbi5yZWN5Y2xlKCk7XHJcbiAgICAgIHRoaXMucmF5RW5kLnJlY3ljbGUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBHZW5lcmFsIHNldHRpbmdzIGZvciB0aGUgcGh5c2ljIHNpbXVsYXRpb24gYW5kIHRoZSBkZWJ1ZyBvZiBpdC4gKi9cclxuICBleHBvcnQgY2xhc3MgUGh5c2ljc1NldHRpbmdzIHtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2RlZmF1bHRDb2xsaXNpb25Hcm91cDogbnVtYmVyLCBfZGVmYXVsdENvbGxpc2lvbk1hc2s6IG51bWJlcikge1xyXG4gICAgICBpZiAodHlwZW9mIE9JTU8gPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIHRoaXMuZGVmYXVsdENvbGxpc2lvbkdyb3VwID0gX2RlZmF1bHRDb2xsaXNpb25Hcm91cDtcclxuICAgICAgdGhpcy5kZWZhdWx0Q29sbGlzaW9uTWFzayA9IF9kZWZhdWx0Q29sbGlzaW9uTWFzaztcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2hhbmdlIGlmIHJpZ2lkYm9kaWVzIGFyZSBhYmxlIHRvIHNsZWVwIChkb24ndCBiZSBjb25zaWRlcmVkIGluIHBoeXNpY2FsIGNhbGN1bGF0aW9ucykgd2hlbiB0aGVpciBtb3ZlbWVudCBpcyBiZWxvdyBhIHRocmVzaG9sZC4gRGVhY3RpdmF0aW9uIGlzIGRlY3JlYXNpbmcgcGVyZm9ybWFuY2UgZm9yIG1pbm9yIGFkdmFudGFnZSBpbiBwcmVjaXNpb24uICovXHJcbiAgICBwdWJsaWMgZ2V0IGRpc2FibGVTbGVlcGluZygpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIE9JTU8uU2V0dGluZy5kaXNhYmxlU2xlZXBpbmc7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGRpc2FibGVTbGVlcGluZyhfdmFsdWU6IGJvb2xlYW4pIHtcclxuICAgICAgT0lNTy5TZXR0aW5nLmRpc2FibGVTbGVlcGluZyA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKiBTbGVlcGluZyBUaHJlc2hvbGQgZm9yIE1vdmVtZW50IFZlbG9jdGl5LiAqL1xyXG4gICAgcHVibGljIGdldCBzbGVlcGluZ1ZlbG9jaXR5VGhyZXNob2xkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuc2xlZXBpbmdWZWxvY2l0eVRocmVzaG9sZDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc2xlZXBpbmdWZWxvY2l0eVRocmVzaG9sZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBPSU1PLlNldHRpbmcuc2xlZXBpbmdWZWxvY2l0eVRocmVzaG9sZCA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogU2xlZXBpbmcgVGhyZXNob2xkIGZvciBSb3RhdGlvbiBWZWxvY2l0eS4gKi9cclxuICAgIHB1YmxpYyBnZXQgc2xlZXBpbmdBbmd1bGFyVmVsb2NpdHlUaHJlc2hvbGQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIE9JTU8uU2V0dGluZy5zbGVlcGluZ0FuZ3VsYXJWZWxvY2l0eVRocmVzaG9sZDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc2xlZXBpbmdBbmd1bGFyVmVsb2NpdHlUaHJlc2hvbGQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgT0lNTy5TZXR0aW5nLnNsZWVwaW5nQW5ndWxhclZlbG9jaXR5VGhyZXNob2xkID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaHJlc2hvbGQgaG93IGxvbmcgdGhlIFJpZ2lkYm9keSBtdXN0IGJlIGJlbG93L2Fib3ZlIHRoZSB0aHJlc2hvbGQgdG8gY291bnQgYXMgc2xlZXBpbmcuICovXHJcbiAgICBwdWJsaWMgZ2V0IHNsZWVwaW5nVGltZVRocmVzaG9sZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLnNsZWVwaW5nVGltZVRocmVzaG9sZDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc2xlZXBpbmdUaW1lVGhyZXNob2xkKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIE9JTU8uU2V0dGluZy5zbGVlcGluZ1RpbWVUaHJlc2hvbGQgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEVycm9yIHRocmVzaG9sZC4gRGVmYXVsdCBpcyAwLjA1LiBUaGUgaGlnaGVyIHRoZSBtb3JlIGxpa2VseSBjb2xsaXNpb25zIGdldCBkZXRlY3RlZCBiZWZvcmUgYWN0dWFsIGltcGFjdCBhdCBoaWdoIHNwZWVkcyBidXQgaXQncyB2aXN1YWxseSBsZXNzIGFjY3VyYXRlLiAqL1xyXG4gICAgcHVibGljIGdldCBkZWZhdWx0Q29sbGlzaW9uTWFyZ2luKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuZGVmYXVsdEdKS01hcmdpbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgZGVmYXVsdENvbGxpc2lvbk1hcmdpbihfdGhpY2tuZXNzOiBudW1iZXIpIHtcclxuICAgICAgT0lNTy5TZXR0aW5nLmRlZmF1bHRHSktNYXJnaW4gPSBfdGhpY2tuZXNzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgZGVmYXVsdCBhcHBsaWVkIGZyaWN0aW9uIGJldHdlZW4gdHdvIHJpZ2lkYm9kaWVzIHdpdGggdGhlIGRlZmF1bHQgdmFsdWUuIEhvdyBtdWNoIHZlbG9jaXR5IGlzIHNsb3dlZCBkb3duIHdoZW4gbW92aW5nIGFjY3Jvc3MgdGhpcyBzdXJmYWNlLiAqL1xyXG4gICAgcHVibGljIGdldCBkZWZhdWx0RnJpY3Rpb24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIE9JTU8uU2V0dGluZy5kZWZhdWx0RnJpY3Rpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGRlZmF1bHRGcmljdGlvbihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBPSU1PLlNldHRpbmcuZGVmYXVsdEZyaWN0aW9uID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBCb3VuY2luZXNzIG9mIHJpZ2lkYm9kaWVzLiBIb3cgbXVjaCBvZiB0aGUgaW1wYWN0IGlzIHJlc3RpdHV0ZWQuICovXHJcbiAgICBwdWJsaWMgZ2V0IGRlZmF1bHRSZXN0aXR1dGlvbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLmRlZmF1bHRSZXN0aXR1dGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgZGVmYXVsdFJlc3RpdHV0aW9uKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIE9JTU8uU2V0dGluZy5kZWZhdWx0UmVzdGl0dXRpb24gPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdyb3VwcyB0aGUgZGVmYXVsdCByaWdpZGJvZHkgd2lsbCBjb2xsaWRlIHdpdGguIFNldCBpdCBsaWtlOiAoUEhZU0lDU19HUk9VUC5ERUZBVUxUIHwgUEhZU0lDU19HUk9VUC5HUk9VUF8xIHwgUEhZU0lDU19HUk9VUC5HUk9VUF8yIHwgUEhZU0lDU19HUk9VUC5HUk9VUF8zKSBcclxuICAgICAqIHRvIGNvbGxpZGUgd2l0aCBtdWx0aXBsZSBncm91cHMuIERlZmF1bHQgaXMgY29sbGlzaW9uIHdpdGggZXZlcnl0aGluZyBidXQgdHJpZ2dlcnMuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGdldCBkZWZhdWx0Q29sbGlzaW9uTWFzaygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLmRlZmF1bHRDb2xsaXNpb25NYXNrO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBkZWZhdWx0Q29sbGlzaW9uTWFzayhfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBPSU1PLlNldHRpbmcuZGVmYXVsdENvbGxpc2lvbk1hc2sgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBncm91cCB0aGF0IHRoaXMgcmlnaWRib2R5IGJlbG9uZ3MgdG8uIERlZmF1bHQgaXMgdGhlIERFRkFVTFQgR3JvdXAgd2hpY2ggbWVhbnMgaXRzIGp1c3QgYSBub3JtYWwgUmlnaWRib2R5IG5vdCBhIHRyaWdnZXIgbm9yIGFueXRoaW5nIHNwZWNpYWwuICovXHJcbiAgICBwdWJsaWMgZ2V0IGRlZmF1bHRDb2xsaXNpb25Hcm91cCgpOiBDT0xMSVNJT05fR1JPVVAge1xyXG4gICAgICByZXR1cm4gPENPTExJU0lPTl9HUk9VUD5PSU1PLlNldHRpbmcuZGVmYXVsdENvbGxpc2lvbkdyb3VwO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBkZWZhdWx0Q29sbGlzaW9uR3JvdXAoX3ZhbHVlOiBDT0xMSVNJT05fR1JPVVApIHtcclxuICAgICAgT0lNTy5TZXR0aW5nLmRlZmF1bHRDb2xsaXNpb25Hcm91cCA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2hhbmdlIHRoZSB0eXBlIG9mIGpvaW50IHNvbHZlciBhbGdvcml0aG0uIERlZmF1bHQgSXRlcmF0aXZlID09IDAsIGlzIGZhc3RlciBidXQgbGVzcyBzdGFibGUuIERpcmVjdCA9PSAxLCBzbG93IGJ1dCBtb3JlIHN0YWJsZSwgcmVjb21tZW5kZWQgZm9yIGNvbXBsZXggam9pbnQgd29yay4gQ2hhbmdlIHRoaXMgc2V0dGluZyBvbmx5IGF0IHRoZSBzdGFydCBvZiB5b3VyIGdhbWUuICovXHJcbiAgICBwdWJsaWMgZ2V0IGRlZmF1bHRDb25zdHJhaW50U29sdmVyVHlwZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gT0lNTy5TZXR0aW5nLmRlZmF1bHRKb2ludENvbnN0cmFpbnRTb2x2ZXJUeXBlO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBkZWZhdWx0Q29uc3RyYWludFNvbHZlclR5cGUoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgT0lNTy5TZXR0aW5nLmRlZmF1bHRKb2ludENvbnN0cmFpbnRTb2x2ZXJUeXBlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgY29ycmVjdGlvbiBhbGdvcml0aG0gdXNlZCB0byBjb3JyZWN0IHBoeXNpY3MgY2FsY3VsYXRpb25zLiBDaGFuZ2UgdGhpcyBvbmx5IGF0IHRoZSBiZWdpbm5pbmcgb2YgeW91ciBnYW1lLiBFYWNoIGhhcyBkaWZmZXJlbnQgYXBwcm9hY2hlcywgc28gaWYgeW91IGhhdmUgcHJvYmxlbXMgdGVzdCBhbm90aGVyXHJcbiAgICAgKiAgRGVmYXVsdCAwID0gQmF1bWdhcnRlIChmYXN0IGJ1dCBsZXNzIGNvcnJlY3QgaW5kdWNlcyBzb21lIGVuZXJneSBlcnJvcnMpLCAxID0gU3BsaXQtSW1wdWxzZSAoZmFzdCBhbmQgbm8gZW5nZXJ5IGVycm9ycywgYnV0IG1vcmUgaW5hY2N1cmF0ZSBmb3Igam9pbnRzKSwgMiA9IE5vbi1saW5lYXIgR2F1c3MgU2VpZGVsIChzbG93ZXN0IGJ1dCBtb3N0IGFjY3VyYXRlKSovXHJcbiAgICBwdWJsaWMgZ2V0IGRlZmF1bHRDb3JyZWN0aW9uQWxnb3JpdGhtKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBPSU1PLlNldHRpbmcuZGVmYXVsdEpvaW50UG9zaXRpb25Db3JyZWN0aW9uQWxnb3JpdGhtO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBkZWZhdWx0Q29ycmVjdGlvbkFsZ29yaXRobShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBPSU1PLlNldHRpbmcuZGVmYXVsdEpvaW50UG9zaXRpb25Db3JyZWN0aW9uQWxnb3JpdGhtID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgcHJlY2lzaW9uIG9mIHRoZSBzaW11bGF0aW9uIGluIGZvcm0gb2YgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdGhlIHNpbXVsYXRpb25zIHJ1bnMgdGhyb3VnaCB1bnRpbCBpdCBhY2NlcHRzIHRoZSByZXN1bHQuXHJcbiAgICAgKiAgMTAgRGVmYXVsdCAtIEhpZ2hlciBtZWFucyBtb3JlIHByZWNpc2lvbiBidXQgcmVzdWx0cyBpbiBhIHBlcmZvcm1hbmNlIGRlY3JlYXNlLiBUaGlzIGhlbHBzIGVzcGVjaWFsbHkgd2l0aCBqb2ludHMsXHJcbiAgICAgKiBidXQgYWxzbyB0aGUgZ2VuZXJhbCBzdGFiaWxpdHkgb2YgdGhlIHNpbXVsYXRpb24gZHVlIHRvIHNpbXVsYXRpb24gc3RlcHMgYmVpbmcgcmVjaGVja2VkIG11bHRpcGxlIHRpbWVzIGJlZm9yZSBiZWluZyBzZXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc29sdmVySXRlcmF0aW9ucygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gUGh5c2ljcy5hY3RpdmVJbnN0YW5jZS5nZXRPaW1vV29ybGQoKS5nZXROdW1Qb3NpdGlvbkl0ZXJhdGlvbnMoKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc29sdmVySXRlcmF0aW9ucyhfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBQaHlzaWNzLmFjdGl2ZUluc3RhbmNlLmdldE9pbW9Xb3JsZCgpLnNldE51bVBvc2l0aW9uSXRlcmF0aW9ucyhfdmFsdWUpO1xyXG4gICAgICBQaHlzaWNzLmFjdGl2ZUluc3RhbmNlLmdldE9pbW9Xb3JsZCgpLnNldE51bVZlbG9jaXR5SXRlcmF0aW9ucyhfdmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAgICogQWN0cyBhcyB0aGUgcGh5c2ljYWwgcmVwcmVzZW50YXRpb24gb2YgYSBjb25uZWN0aW9uIGJldHdlZW4gdHdvIHtAbGluayBOb2RlfSdzLlxyXG4gICAgICogVGhlIHR5cGUgb2YgY29ubmNldGlvbiBpcyBkZWZpbmVkIGJ5IHRoZSBzdWJjbGFzc2VzIGxpa2UgcHJpc21hdGljIGpvaW50LCBjeWxpbmRlciBqb2ludCBldGMuXHJcbiAgICAgKiBBIFJpZ2lkYm9keSBvbiB0aGUge0BsaW5rIE5vZGV9IHRoYXQgdGhpcyBjb21wb25lbnQgaXMgYWRkZWQgdG8gaXMgbmVlZGVkLiBTZXR0aW5nIHRoZSBjb25uZWN0ZWRSaWdpZGJvZHkgYW5kXHJcbiAgICAgKiBpbml0aWFsaXppbmcgdGhlIGNvbm5lY3Rpb24gY3JlYXRlcyBhIHBoeXNpY2FsIGNvbm5lY3Rpb24gYmV0d2VlbiB0aGVtLiBUaGlzIGRpZmZlcnMgZnJvbSBhIGNvbm5lY3Rpb24gdGhyb3VnaCBoaWVyYXJjaHlcclxuICAgICAqIGluIHRoZSBub2RlIHN0cnVjdHVyZSBvZiBmdWRnZS4gSm9pbnRzIGNhbiBoYXZlIGRpZmZlcmVudCBET0YncyAoRGVncmVlcyBPZiBGcmVlZG9tKSwgMSBBeGlzIHRoYXQgY2FuIGVpdGhlciB0d2lzdCBvciBzd2luZyBpcyBhIGRlZ3JlZSBvZiBmcmVlZG9tLlxyXG4gICAgICogQSBqb2ludCB0eXBpY2FsbHkgY29uc2lzdHMgb2YgYSBtb3RvciB0aGF0IGxpbWl0cyBtb3ZlbWVudC9yb3RhdGlvbiBvciBpcyBhY3Rpdmx5IHRyeWluZyB0byBtb3ZlIHRvIGEgbGltaXQuIEFuZCBhIHNwcmluZyB3aGljaCBkZWZpbmVzIHRoZSByaWdpZGl0eS5cclxuICAgICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVIDIwMjBcclxuICAgICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBKb2ludCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICAvKiogcmVmZXJzIGJhY2sgdG8gdGhpcyBjbGFzcyBmcm9tIGFueSBzdWJjbGFzcyBlLmcuIGluIG9yZGVyIHRvIGZpbmQgY29tcGF0aWJsZSBvdGhlciByZXNvdXJjZXMqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBiYXNlQ2xhc3M6IHR5cGVvZiBKb2ludCA9IEpvaW50O1xyXG4gICAgLyoqIGxpc3Qgb2YgYWxsIHRoZSBzdWJjbGFzc2VzIGRlcml2ZWQgZnJvbSB0aGlzIGNsYXNzLCBpZiB0aGV5IHJlZ2lzdGVyZWQgcHJvcGVybHkqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBzdWJjbGFzc2VzOiB0eXBlb2YgSm9pbnRbXSA9IFtdO1xyXG5cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRKb2ludCk7XHJcbiAgICBwcm90ZWN0ZWQgc2luZ2xldG9uOiBib29sZWFuID0gZmFsc2U7IC8vTXVsdGlwbGUgam9pbnRzIGNhbiBiZSBhdHRhY2hlZCB0byBvbmUgTm9kZVxyXG5cclxuICAgICNpZEJvZHlBbmNob3I6IG51bWJlciA9IDA7XHJcbiAgICAjaWRCb2R5VGllZDogbnVtYmVyID0gMDtcclxuICAgICNib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHk7XHJcbiAgICAjYm9keVRpZWQ6IENvbXBvbmVudFJpZ2lkYm9keTtcclxuXHJcbiAgICAjY29ubmVjdGVkOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAjYW5jaG9yOiBPSU1PLlZlYzM7XHJcbiAgICAjaW50ZXJuYWxDb2xsaXNpb246IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAjYnJlYWtGb3JjZTogbnVtYmVyID0gMDtcclxuICAgICNicmVha1RvcnF1ZTogbnVtYmVyID0gMDtcclxuXHJcbiAgICAjbmFtZUNoaWxkVG9Db25uZWN0OiBzdHJpbmc7XHJcblxyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGpvaW50OiBPSU1PLkpvaW50O1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGNvbmZpZzogT0lNTy5Kb2ludENvbmZpZztcclxuXHJcbiAgICAvKiogQ3JlYXRlIGEgam9pbnQgY29ubmVjdGlvbiBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gUmlnaWRib2R5Q29tcG9uZW50cy4gKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuYm9keUFuY2hvciA9IF9ib2R5QW5jaG9yO1xyXG4gICAgICB0aGlzLmJvZHlUaWVkID0gX2JvZHlUaWVkO1xyXG5cclxuICAgICAgLypcclxuICAgICAgICBUZWxsIHRoZSBwaHlzaWNzIHRoYXQgdGhlcmUgaXMgYSBuZXcgam9pbnQgYW5kIG9uIHRoZSBwaHlzaWNzIHN0YXJ0IHRoZSBhY3R1YWwgam9pbnQgaXMgZmlyc3QgY3JlYXRlZC4gVmFsdWVzIGNhbiBiZSBzZXQgYnV0IHRoZVxyXG4gICAgICAgIGFjdHVhbCBjb25zdHJhaW50IGFpbid0IGV4aXN0ZW50IHVudGlsIHRoZSBnYW1lIHN0YXJ0c1xyXG4gICAgICAqL1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy5obmRFdmVudCk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLmhuZEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlZ2lzdGVyU3ViY2xhc3MoX3N1YmNsYXNzOiB0eXBlb2YgSm9pbnQpOiBudW1iZXIgeyByZXR1cm4gSm9pbnQuc3ViY2xhc3Nlcy5wdXNoKF9zdWJjbGFzcykgLSAxOyB9XHJcblxyXG4gICAgLyoqIEdldC9TZXQgdGhlIGZpcnN0IENvbXBvbmVudFJpZ2lkYm9keSBvZiB0aGlzIGNvbm5lY3Rpb24uIEl0IHNob3VsZCBhbHdheXMgYmUgdGhlIG9uZSB0aGF0IHRoaXMgY29tcG9uZW50IGlzIGF0dGFjaGVkIHRvbyBpbiB0aGUgc2NlbmVUcmVlLiAqL1xyXG4gICAgcHVibGljIGdldCBib2R5QW5jaG9yKCk6IENvbXBvbmVudFJpZ2lkYm9keSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNib2R5QW5jaG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgYm9keUFuY2hvcihfY21wUkI6IENvbXBvbmVudFJpZ2lkYm9keSkge1xyXG4gICAgICB0aGlzLiNpZEJvZHlBbmNob3IgPSBfY21wUkIgIT0gbnVsbCA/IF9jbXBSQi5pZCA6IC0xO1xyXG4gICAgICB0aGlzLiNib2R5QW5jaG9yID0gX2NtcFJCO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQvU2V0IHRoZSBzZWNvbmQgQ29tcG9uZW50UmlnaWRib2R5IG9mIHRoaXMgY29ubmVjdGlvbi4gKi9cclxuICAgIHB1YmxpYyBnZXQgYm9keVRpZWQoKTogQ29tcG9uZW50UmlnaWRib2R5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2JvZHlUaWVkO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBib2R5VGllZChfY21wUkI6IENvbXBvbmVudFJpZ2lkYm9keSkge1xyXG4gICAgICB0aGlzLiNpZEJvZHlUaWVkID0gX2NtcFJCICE9IG51bGwgPyBfY21wUkIuaWQgOiAtMTtcclxuICAgICAgdGhpcy4jYm9keVRpZWQgPSBfY21wUkI7XHJcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZXhhY3QgcG9zaXRpb24gd2hlcmUgdGhlIHR3byB7QGxpbmsgTm9kZX1zIGFyZSBjb25uZWN0ZWQuIFdoZW4gY2hhbmdlZCBhZnRlciBpbml0aWFsaXphdGlvbiB0aGUgam9pbnQgbmVlZHMgdG8gYmUgcmVjb25uZWN0ZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgYW5jaG9yKCk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy4jYW5jaG9yLngsIHRoaXMuI2FuY2hvci55LCB0aGlzLiNhbmNob3Iueik7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGFuY2hvcihfdmFsdWU6IFZlY3RvcjMpIHtcclxuICAgICAgdGhpcy4jYW5jaG9yID0gbmV3IE9JTU8uVmVjMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KTtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbW91bnQgb2YgZm9yY2UgbmVlZGVkIHRvIGJyZWFrIHRoZSBKT0lOVCwgd2hpbGUgcm90YXRpbmcsIGluIE5ld3Rvbi4gMCBlcXVhbHMgdW5icmVha2FibGUgKGRlZmF1bHQpIFxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBnZXQgYnJlYWtUb3JxdWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2JyZWFrVG9ycXVlO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBicmVha1RvcnF1ZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNicmVha1RvcnF1ZSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5zZXRCcmVha1RvcnF1ZSh0aGlzLiNicmVha1RvcnF1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYW1vdW50IG9mIGZvcmNlIG5lZWRlZCB0byBicmVhayB0aGUgSk9JTlQsIGluIE5ld3Rvbi4gMCBlcXVhbHMgdW5icmVha2FibGUgKGRlZmF1bHQpIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGJyZWFrRm9yY2UoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2JyZWFrRm9yY2U7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGJyZWFrRm9yY2UoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jYnJlYWtGb3JjZSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5zZXRCcmVha0ZvcmNlKHRoaXMuI2JyZWFrRm9yY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIElmIHRoZSB0d28gY29ubmVjdGVkIFJpZ2lkQm9kaWVzIGNvbGxpZGUgd2l0aCBlYXRoIG90aGVyLiAoRGVmYXVsdCA9IGZhbHNlKVxyXG4gICAgICAqIE9uIGEgd2VsZGluZyBqb2ludCB0aGUgY29ubmVjdGVkIGJvZGllcyBzaG91bGQgbm90IGJlIGNvbGxpZGluZyB3aXRoIGVhY2ggb3RoZXIsXHJcbiAgICAgICogZm9yIGJlc3QgcmVzdWx0c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGludGVybmFsQ29sbGlzaW9uKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxDb2xsaXNpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGludGVybmFsQ29sbGlzaW9uKF92YWx1ZTogYm9vbGVhbikge1xyXG4gICAgICB0aGlzLiNpbnRlcm5hbENvbGxpc2lvbiA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5zZXRBbGxvd0NvbGxpc2lvbih0aGlzLiNpbnRlcm5hbENvbGxpc2lvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0IGEgY2hpbGQgbm9kZSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBqb2ludC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbm5lY3RDaGlsZChfbmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI25hbWVDaGlsZFRvQ29ubmVjdCA9IF9uYW1lO1xyXG4gICAgICBpZiAoIXRoaXMubm9kZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBsZXQgY2hpbGRyZW46IE5vZGVbXSA9IHRoaXMubm9kZS5nZXRDaGlsZHJlbkJ5TmFtZShfbmFtZSk7XHJcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT0gMSlcclxuICAgICAgICB0aGlzLmNvbm5lY3ROb2RlKGNoaWxkcmVuLnBvcCgpKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIERlYnVnLndhcm4oYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBhdCAke3RoaXMubm9kZS5uYW1lfSBmYWlscyB0byBjb25uZWN0IGNoaWxkIHdpdGggbm9uIGV4aXN0ZW50IG9yIGFtYmlnb3VzIG5hbWUgJHtfbmFtZX1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbm5lY3QgdGhlIGdpdmVuIG5vZGUgdG8gdGhlIGpvaW50LiBUaWVpbmcgaXRzIHJpZ2lkYm9keSB0byB0aGUgbm9kZXMgcmlnaWRib2R5IHRoaXMgY29tcG9uZW50IGlzIGF0dGFjaGVkIHRvLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29ubmVjdE5vZGUoX25vZGU6IE5vZGUpOiB2b2lkIHtcclxuICAgICAgaWYgKCFfbm9kZSB8fCAhdGhpcy5ub2RlKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIERlYnVnLmZ1ZGdlKGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gY29ubmVjdGVkICR7dGhpcy5ub2RlLm5hbWV9IGFuZCAke19ub2RlLm5hbWV9YCk7XHJcblxyXG4gICAgICBsZXQgY29ubmVjdEJvZHk6IENvbXBvbmVudFJpZ2lkYm9keSA9IF9ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRSaWdpZGJvZHkpO1xyXG4gICAgICBsZXQgdGhpc0JvZHk6IENvbXBvbmVudFJpZ2lkYm9keSA9IHRoaXMubm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50UmlnaWRib2R5KTtcclxuXHJcbiAgICAgIGlmICghY29ubmVjdEJvZHkgfHwgIXRoaXNCb2R5KSB7XHJcbiAgICAgICAgRGVidWcud2FybihgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGF0ICR7dGhpcy5ub2RlLm5hbWV9IGZhaWxzIGR1ZSB0byBtaXNzaW5nIHJpZ2lkYm9kaWVzIG9uICR7dGhpcy5ub2RlLm5hbWV9IG9yICR7X25vZGUubmFtZX1gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuYm9keUFuY2hvciA9IHRoaXNCb2R5O1xyXG4gICAgICB0aGlzLmJvZHlUaWVkID0gY29ubmVjdEJvZHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENoZWNrIGlmIGNvbm5lY3Rpb24gaXMgZGlydHksIHNvIHdoZW4gZWl0aGVyIHJiIGlzIGNoYW5nZWQgZGlzY29ubmVjdCBhbmQgcmVjb25uZWN0LiBJbnRlcm5hbGx5IHVzZWQgbm8gdXNlciBpbnRlcmFjdGlvbiBuZWVkZWQuICovXHJcbiAgICBwdWJsaWMgaXNDb25uZWN0ZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNjb25uZWN0ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXppbmcgYW5kIGNvbm5lY3RpbmcgdGhlIHR3byByaWdpZGJvZGllcyB3aXRoIHRoZSBjb25maWd1cmVkIGpvaW50IHByb3BlcnRpZXNcclxuICAgICAqIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IHRoZSBwaHlzaWNzIHN5c3RlbS4gTm8gdXNlciBpbnRlcmFjdGlvbiBuZWVkZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25uZWN0KCk6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy4jY29ubmVjdGVkID09IGZhbHNlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuI2lkQm9keUFuY2hvciA9PSAtMSB8fCB0aGlzLiNpZEJvZHlUaWVkID09IC0xKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy4jbmFtZUNoaWxkVG9Db25uZWN0KVxyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RDaGlsZCh0aGlzLiNuYW1lQ2hpbGRUb0Nvbm5lY3QpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RKb2ludCgpO1xyXG4gICAgICAgIHRoaXMuI2Nvbm5lY3RlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hZGRKb2ludCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNjb25uZWN0aW5nIHRoZSB0d28gcmlnaWRib2RpZXMgYW5kIHJlbW92aW5nIHRoZW0gZnJvbSB0aGUgcGh5c2ljcyBzeXN0ZW0sXHJcbiAgICAgKiBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSB0aGUgcGh5c2ljcyBzeXN0ZW0uIE5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGlzY29ubmVjdCgpOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuI2Nvbm5lY3RlZCA9PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVKb2ludCgpO1xyXG4gICAgICAgIHRoaXMuI2Nvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBKb2ludCB1c2VkIGJ5IHRoZSBwaHlzaWNzIGVuZ2luZS4gVXNlZCBpbnRlcm5hbGx5IG5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkLlxyXG4gICAgICogT25seSB0byBiZSB1c2VkIHdoZW4gZnVuY3Rpb25hbGl0eSB0aGF0IGlzIG5vdCBhZGRlZCB3aXRoaW4gRlVER0UgaXMgbmVlZGVkLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBnZXRPaW1vSm9pbnQoKTogT0lNTy5Kb2ludCB7XHJcbiAgICAgIHJldHVybiB0aGlzLmpvaW50O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy4jZ2V0TXV0YXRvcigpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmFuY2hvciA9IHRoaXMuYW5jaG9yLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuYW5jaG9yID0gYXdhaXQgbmV3IFZlY3RvcjMoKS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5hbmNob3IpO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHRoaXMuY29ubmVjdENoaWxkKF9zZXJpYWxpemF0aW9uLm5hbWVDaGlsZFRvQ29ubmVjdCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IodHJ1ZSk7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24obXV0YXRvciwgdGhpcy4jZ2V0TXV0YXRvcigpKTtcclxuICAgICAgbXV0YXRvci5hbmNob3IgPSB0aGlzLmFuY2hvci5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHN1cGVyLmdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcik7XHJcbiAgICAgIHR5cGVzLm5hbWVDaGlsZFRvQ29ubmVjdCA9IFwiU3RyaW5nXCI7XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH0gXHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9tdXRhdG9yLmFuY2hvcikgIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgdGhpcy5hbmNob3IgPSBuZXcgVmVjdG9yMyguLi48bnVtYmVyW10+KE9iamVjdC52YWx1ZXMoX211dGF0b3IuYW5jaG9yKSkpO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuYW5jaG9yO1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5uYW1lQ2hpbGRUb0Nvbm5lY3QpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMuY29ubmVjdENoaWxkKF9tdXRhdG9yLm5hbWVDaGlsZFRvQ29ubmVjdCk7XHJcbiAgICAgIHRoaXMuI211dGF0ZShfbXV0YXRvcik7XHJcbiAgICAgIHRoaXMuZGVsZXRlRnJvbU11dGF0b3IoX211dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zcHJpbmdEYW1wZXI7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5qb2ludDtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLm1vdG9yO1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGVsbCB0aGUgRnVkZ2VQaHlzaWNzIHN5c3RlbSB0aGF0IHRoaXMgam9pbnQgbmVlZHMgdG8gYmUgaGFuZGxlZCBpbiB0aGUgbmV4dCBmcmFtZS4gKi9cclxuICAgIHByb3RlY3RlZCBkaXJ0eVN0YXR1cygpOiB2b2lkIHtcclxuICAgICAgUGh5c2ljcy5jaGFuZ2VKb2ludFN0YXR1cyh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYWRkSm9pbnQoKTogdm9pZCB7XHJcbiAgICAgIFBoeXNpY3MuYWRkSm9pbnQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlbW92ZUpvaW50KCk6IHZvaWQge1xyXG4gICAgICBQaHlzaWNzLnJlbW92ZUpvaW50KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCguLi5fY29uZmlnUGFyYW1zOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICBsZXQgcG9zQm9keUFuY2hvcjogVmVjdG9yMyA9IHRoaXMuYm9keUFuY2hvci5ub2RlLm10eFdvcmxkLnRyYW5zbGF0aW9uOyAvL1NldHRpbmcgdGhlIGFuY2hvciBwb3NpdGlvbiBsb2NhbGx5IGZyb20gdGhlIGZpcnN0IHJpZ2lkYm9keVxyXG4gICAgICBsZXQgd29ybGRBbmNob3I6IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzMocG9zQm9keUFuY2hvci54ICsgdGhpcy4jYW5jaG9yLngsIHBvc0JvZHlBbmNob3IueSArIHRoaXMuI2FuY2hvci55LCBwb3NCb2R5QW5jaG9yLnogKyB0aGlzLiNhbmNob3Iueik7XHJcblxyXG4gICAgICAvLyBAdHMtaWdub3JlICAgIC8vIHVuZm9ydHVuYXRlbHksIG1ldGhvZCBpbml0IGlzIG5vdCBhIG1lbWJlciBvZiB0aGUgYmFzZSBjbGFzcyBPSU1PLkpvaW50Q29uZmlnXHJcbiAgICAgIHRoaXMuY29uZmlnLmluaXQodGhpcy4jYm9keUFuY2hvci5nZXRPaW1vUmlnaWRib2R5KCksIHRoaXMuI2JvZHlUaWVkLmdldE9pbW9SaWdpZGJvZHkoKSwgd29ybGRBbmNob3IsIC4uLl9jb25maWdQYXJhbXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBjb25maWd1cmVKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5qb2ludC5zZXRCcmVha0ZvcmNlKHRoaXMuYnJlYWtGb3JjZSk7XHJcbiAgICAgIHRoaXMuam9pbnQuc2V0QnJlYWtUb3JxdWUodGhpcy5icmVha1RvcnF1ZSk7XHJcbiAgICAgIHRoaXMuam9pbnQuc2V0QWxsb3dDb2xsaXNpb24odGhpcy4jaW50ZXJuYWxDb2xsaXNpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBkZWxldGVGcm9tTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvciwgX2RlbGV0ZTogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBrZXkgaW4gX2RlbGV0ZSlcclxuICAgICAgICBkZWxldGUgX211dGF0b3Jba2V5XTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhuZEV2ZW50ID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgc3dpdGNoIChfZXZlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgRVZFTlQuQ09NUE9ORU5UX0FERDpcclxuICAgICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkRJU0NPTk5FQ1RfSk9JTlQsICgpID0+IHsgdGhpcy5kaXNjb25uZWN0KCk7IHRoaXMuZGlydHlTdGF0dXMoKTsgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEVWRU5ULkNPTVBPTkVOVF9SRU1PVkU6XHJcbiAgICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5ESVNDT05ORUNUX0pPSU5ULCAoKSA9PiB7IHRoaXMuZGlzY29ubmVjdCgpOyB0aGlzLmRpcnR5U3RhdHVzKCk7IH0sIHRydWUpO1xyXG4gICAgICAgICAgdGhpcy5yZW1vdmVKb2ludCgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgI2dldE11dGF0b3IgPSAoKTogTXV0YXRvciA9PiB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIG5hbWVDaGlsZFRvQ29ubmVjdDogdGhpcy4jbmFtZUNoaWxkVG9Db25uZWN0LFxyXG4gICAgICAgIGludGVybmFsQ29sbGlzaW9uOiB0aGlzLiNpbnRlcm5hbENvbGxpc2lvbixcclxuICAgICAgICBicmVha0ZvcmNlOiB0aGlzLiNicmVha0ZvcmNlLFxyXG4gICAgICAgIGJyZWFrVG9ycXVlOiB0aGlzLiNicmVha1RvcnF1ZVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH07XHJcblxyXG4gICAgI211dGF0ZSA9IChfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgPT4ge1xyXG4gICAgICB0aGlzLm11dGF0ZUJhc2UoX211dGF0b3IsIFtcImludGVybmFsQ29sbGlzaW9uXCIsIFwiYnJlYWtGb3JjZVwiLCBcImJyZWFrVG9ycXVlXCJdKTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAgKiBCYXNlIGNsYXNzIGZvciBqb2ludHMgb3BlcmF0aW5nIHdpdGggZXhhY3RseSBvbmUgYXhpc1xyXG4gICAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBKb2ludEF4aWFsIGV4dGVuZHMgSm9pbnQge1xyXG4gICAgcHJvdGVjdGVkIHNwcmluZ0RhbXBlcjogT0lNTy5TcHJpbmdEYW1wZXI7XHJcbiAgICBcclxuICAgIC8vSW50ZXJuYWwgVmFyaWFibGVzXHJcbiAgICAjbWF4TW90b3I6IG51bWJlciA9IDEwO1xyXG4gICAgI21pbk1vdG9yOiBudW1iZXIgPSAtMTA7XHJcbiAgICAjbW90b3JTcGVlZDogbnVtYmVyID0gMDtcclxuICAgICNheGlzOiBPSU1PLlZlYzM7XHJcbiAgICAjc3ByaW5nRnJlcXVlbmN5OiBudW1iZXIgPSAwO1xyXG4gICAgI3NwcmluZ0RhbXBpbmc6IG51bWJlciA9IDA7XHJcblxyXG4gICAgLyoqIENyZWF0aW5nIGEgY3lsaW5kcmljYWwgam9pbnQgYmV0d2VlbiB0d28gQ29tcG9uZW50UmlnaWRib2RpZXMgbW92aW5nIG9uIG9uZSBheGlzIGFuZCByb3RhdGluZyBhcm91bmQgYW5vdGhlciBib3VuZCBvbiBhIGxvY2FsIGFuY2hvcnBvaW50LiAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9ib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYm9keVRpZWQ6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9heGlzOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCksIF9sb2NhbEFuY2hvcjogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDAsIDApKSB7XHJcbiAgICAgIHN1cGVyKF9ib2R5QW5jaG9yLCBfYm9keVRpZWQpO1xyXG4gICAgICB0aGlzLmF4aXMgPSBfYXhpcztcclxuICAgICAgdGhpcy5hbmNob3IgPSBfbG9jYWxBbmNob3I7XHJcbiAgICAgIHRoaXMubWluTW90b3IgPSAtMTA7XHJcbiAgICAgIHRoaXMubWF4TW90b3IgPSAxMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXhpcyBjb25uZWN0aW5nIHRoZSB0aGUgdHdvIHtAbGluayBOb2RlfXMgZS5nLiBWZWN0b3IzKDAsMSwwKSB0byBoYXZlIGEgdXB3YXJkIGNvbm5lY3Rpb24uXHJcbiAgICAgKiAgV2hlbiBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIHRoZSBqb2ludCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBheGlzKCk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy4jYXhpcy54LCB0aGlzLiNheGlzLnksIHRoaXMuI2F4aXMueik7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGF4aXMoX3ZhbHVlOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuI2F4aXMgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBVcHBlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtYXhNb3RvcigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWF4TW90b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBtYXhNb3RvcihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtYXhNb3RvciA9IF92YWx1ZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAoPE9JTU8uUHJpc21hdGljSm9pbnQ+PHVua25vd24+dGhpcy5qb2ludCkuZ2V0TGltaXRNb3RvcigpLnVwcGVyTGltaXQgPSBfdmFsdWU7XHJcbiAgICAgIH0gY2F0Y2ggKF9lOiB1bmtub3duKSB7IC8qICovIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgTG93ZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtaW5Nb3RvcigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWluTW90b3I7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1pbk1vdG9yKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21pbk1vdG9yID0gX3ZhbHVlO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgICg8T0lNTy5QcmlzbWF0aWNKb2ludD48dW5rbm93bj50aGlzLmpvaW50KS5nZXRMaW1pdE1vdG9yKCkubG93ZXJMaW1pdCA9IF92YWx1ZTtcclxuICAgICAgfSBjYXRjaCAoX2U6IHVua25vd24pIHsgLyogKi8gfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBzcHJpbmdEYW1waW5nKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdEYW1waW5nO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzcHJpbmdEYW1waW5nKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0RhbXBpbmcgPSBfdmFsdWU7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgKDxPSU1PLlByaXNtYXRpY0pvaW50Pjx1bmtub3duPnRoaXMuam9pbnQpLmdldFNwcmluZ0RhbXBlcigpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcclxuICAgICAgfSBjYXRjaCAoX2U6IHVua25vd24pIHsgLyogKi8gfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSB0YXJnZXQgc3BlZWQgb2YgdGhlIG1vdG9yIGluIG0vcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtb3RvclNwZWVkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtb3RvclNwZWVkO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgbW90b3JTcGVlZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtb3RvclNwZWVkID0gX3ZhbHVlO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgICg8T0lNTy5QcmlzbWF0aWNKb2ludD50aGlzLmpvaW50KS5nZXRMaW1pdE1vdG9yKCkubW90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgICAgfSBjYXRjaCAoX2U6IHVua25vd24pIHsgLyogKi8gfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyZXF1ZW5jeSBvZiB0aGUgc3ByaW5nIGluIEh6LiBBdCAwIHRoZSBzcHJpbmcgaXMgcmlnaWQsIGVxdWFscyBubyBzcHJpbmcuIFRoZSBzbWFsbGVyIHRoZSB2YWx1ZSB0aGUgbGVzcyByZXN0cmljdGl2ZSBpcyB0aGUgc3ByaW5nLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc3ByaW5nRnJlcXVlbmN5KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3k7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0ZyZXF1ZW5jeShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdGcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgKDxPSU1PLlByaXNtYXRpY0pvaW50PnRoaXMuam9pbnQpLmdldFNwcmluZ0RhbXBlcigpLmZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgICAgfSBjYXRjaCAoX2U6IHVua25vd24pIHsgLyogKi8gfVxyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNhdmluZy9Mb2FkaW5nXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuI2dldE11dGF0b3IoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5heGlzID0gdGhpcy5heGlzLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuYXhpcyA9IGF3YWl0IG5ldyBWZWN0b3IzKCkuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYXhpcyk7XHJcbiAgICAgIHRoaXMuI211dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9tdXRhdG9yLmF4aXMpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMuYXhpcyA9IG5ldyBWZWN0b3IzKC4uLjxudW1iZXJbXT4oT2JqZWN0LnZhbHVlcyhfbXV0YXRvci5heGlzKSkpO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuYXhpcztcclxuICAgICAgdGhpcy4jbXV0YXRlKF9tdXRhdG9yKTtcclxuICAgICAgdGhpcy5kZWxldGVGcm9tTXV0YXRvcihfbXV0YXRvciwgdGhpcy4jZ2V0TXV0YXRvcigpKTtcclxuICAgICAgYXdhaXQgc3VwZXIubXV0YXRlKF9tdXRhdG9yLCBfc2VsZWN0aW9uLCBfZGlzcGF0Y2hNdXRhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IoKTtcclxuICAgICAgbXV0YXRvci5heGlzID0gdGhpcy5heGlzLmdldE11dGF0b3IoKTtcclxuICAgICAgT2JqZWN0LmFzc2lnbihtdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuICAgIFxyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdEpvaW50KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNwcmluZ0RhbXBlciA9IG5ldyBPSU1PLlNwcmluZ0RhbXBlcigpLnNldFNwcmluZyh0aGlzLiNzcHJpbmdGcmVxdWVuY3ksIHRoaXMuI3NwcmluZ0RhbXBpbmcpO1xyXG4gICAgICBzdXBlci5jb25zdHJ1Y3RKb2ludCh0aGlzLiNheGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAjZ2V0TXV0YXRvciA9ICgpOiBNdXRhdG9yID0+IHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XHJcbiAgICAgICAgc3ByaW5nRGFtcGluZzogdGhpcy4jc3ByaW5nRGFtcGluZyxcclxuICAgICAgICBzcHJpbmdGcmVxdWVuY3k6IHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeSxcclxuICAgICAgICBtYXhNb3RvcjogdGhpcy4jbWF4TW90b3IsXHJcbiAgICAgICAgbWluTW90b3I6IHRoaXMuI21pbk1vdG9yLFxyXG4gICAgICAgIG1vdG9yU3BlZWQ6IHRoaXMuI21vdG9yU3BlZWRcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9O1xyXG5cclxuICAgICNtdXRhdGUgPSAoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkID0+IHtcclxuICAgICAgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBbXCJzcHJpbmdEYW1waW5nXCIsIFwic3ByaW5nRnJlcXVlbmN5XCIsIFwibWF4TW90b3JcIiwgXCJtaW5Nb3RvclwiLCBcIm1vdG9yU3BlZWRcIl0pO1xyXG4gICAgfTtcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgZW51bSBNT0RFIHtcclxuICAgIEVESVRPUiwgUlVOVElNRVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gUkVTT1VSQ0VfU1RBVFVTIHtcclxuICAgIFBFTkRJTkcsIFJFQURZLCBFUlJPUlxyXG4gIH1cclxuXHJcbiAgLyoqIEEgc2VyaWFsaXphYmxlIHJlc291cmNlIGltcGxlbWVudGluZyBhbiBpZCBhbmQgYSBuYW1lIHNvIGl0IGNhbiBiZSBtYW5hZ2VkIGJ5IHRoZSB7QGxpbmsgUHJvamVjdH0gKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2VyaWFsaXphYmxlUmVzb3VyY2UgZXh0ZW5kcyBJbXBsZW1lbnRhYmxlIHt9IC8vIGFsbG93IGNoZWNrIHdpdGggaW5zdGFuY2VvZiBcclxuICBleHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YWJsZVJlc291cmNlIGV4dGVuZHMgU2VyaWFsaXphYmxlIHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIGlkUmVzb3VyY2U6IHN0cmluZztcclxuICAgIHJlYWRvbmx5IHR5cGU6IHN0cmluZztcclxuICB9XHJcblxyXG4gIC8qKiBBIHNlcmlhbGl6YWJsZSByZXNvdXJjZSB0aGF0IGlzIGxvYWRlZCBmcm9tIGFuIGV4dGVybmFsIHNvdXJjZSAoZS5nLiBmcm9tIGEgZ2xURi1maWxlKSAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbCBleHRlbmRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcclxuICAgIHVybDogUmVxdWVzdEluZm87XHJcbiAgICBzdGF0dXM6IFJFU09VUkNFX1NUQVRVUztcclxuICAgIGxvYWQoKTogUHJvbWlzZTxTZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsPjtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VzIHtcclxuICAgIFtpZFJlc291cmNlOiBzdHJpbmddOiBTZXJpYWxpemFibGVSZXNvdXJjZTtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2VyaWFsaXphdGlvbk9mUmVzb3VyY2VzIHtcclxuICAgIFtpZFJlc291cmNlOiBzdHJpbmddOiBTZXJpYWxpemF0aW9uO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBTY3JpcHROYW1lc3BhY2VzIHtcclxuICAgIFtuYW1lOiBzdHJpbmddOiBPYmplY3Q7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIENvbXBvbmVudFNjcmlwdHMge1xyXG4gICAgW25hbWVzcGFjZTogc3RyaW5nXTogQ29tcG9uZW50U2NyaXB0W107XHJcbiAgfVxyXG5cclxuICBpbnRlcmZhY2UgR3JhcGhJbnN0YW5jZXNUb1Jlc3luYyB7XHJcbiAgICBbaWRSZXNvdXJjZTogc3RyaW5nXTogR3JhcGhJbnN0YW5jZVtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhdGljIGNsYXNzIGhhbmRsaW5nIHRoZSByZXNvdXJjZXMgdXNlZCB3aXRoIHRoZSBjdXJyZW50IEZVREdFLWluc3RhbmNlLiAgXHJcbiAgICogS2VlcHMgYSBsaXN0IG9mIHRoZSByZXNvdXJjZXMgYW5kIGdlbmVyYXRlcyBpZHMgdG8gcmV0cmlldmUgdGhlbS4gIFxyXG4gICAqIFJlc291cmNlcyBhcmUgb2JqZWN0cyByZWZlcmVuY2VkIG11bHRpcGxlIHRpbWVzIGJ1dCBzdXBwb3NlZCB0byBiZSBzdG9yZWQgb25seSBvbmNlXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFByb2plY3QgZXh0ZW5kcyBFdmVudFRhcmdldFN0YXRpYyB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlc291cmNlczogUmVzb3VyY2VzID0ge307XHJcbiAgICBwdWJsaWMgc3RhdGljIHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyA9IHt9O1xyXG4gICAgcHVibGljIHN0YXRpYyBzY3JpcHROYW1lc3BhY2VzOiBTY3JpcHROYW1lc3BhY2VzID0ge307XHJcbiAgICBwdWJsaWMgc3RhdGljIGJhc2VVUkw6IFVSTCA9IG5ldyBVUkwobG9jYXRpb24udG9TdHJpbmcoKSk7XHJcbiAgICBwdWJsaWMgc3RhdGljIG1vZGU6IE1PREUgPSBNT0RFLlJVTlRJTUU7XHJcbiAgICBwdWJsaWMgc3RhdGljIGdyYXBoSW5zdGFuY2VzVG9SZXN5bmM6IEdyYXBoSW5zdGFuY2VzVG9SZXN5bmMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyB0aGUgcmVzb3VyY2UgYW5kIGdlbmVyYXRlcyBhbiBpZCBmb3IgaXQgYnkgZGVmYXVsdC4gIFxyXG4gICAgICogSWYgdGhlIHJlc291cmNlIGFscmVhZHkgaGFzIGFuIGlkLCB0aHVzIGhhdmluZyBiZWVuIHJlZ2lzdGVyZWQsIGl0cyBkZWxldGVkIGZyb20gdGhlIGxpc3QgYW5kIHJlZ2lzdGVyZWQgYW5ldy5cclxuICAgICAqIEl0J3MgcG9zc2libGUgdG8gcGFzcyBhbiBpZCwgYnV0IHNob3VsZCBub3QgYmUgZG9uZSBleGNlcHQgYnkgdGhlIFNlcmlhbGl6ZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXIoX3Jlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSwgX2lkUmVzb3VyY2U/OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgaWYgKF9yZXNvdXJjZS5pZFJlc291cmNlICYmIF9yZXNvdXJjZS5pZFJlc291cmNlID09IF9pZFJlc291cmNlKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGlmIChfcmVzb3VyY2UuaWRSZXNvdXJjZSkgLy8gZGVyZWdpc3RlciB0aGUgb2xkIGlkXHJcbiAgICAgICAgdGhpcy5kZXJlZ2lzdGVyKF9yZXNvdXJjZSk7XHJcblxyXG4gICAgICBpZiAoX2lkUmVzb3VyY2UpIHtcclxuICAgICAgICBfcmVzb3VyY2UuaWRSZXNvdXJjZSA9IF9pZFJlc291cmNlO1xyXG4gICAgICAgIHRoaXMuZGVyZWdpc3RlcihfcmVzb3VyY2UpOyAvLyBkZXJlZ2lzdGVyIHRoZSBuZXcgaWRcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFfcmVzb3VyY2UuaWRSZXNvdXJjZSlcclxuICAgICAgICBfcmVzb3VyY2UuaWRSZXNvdXJjZSA9IFByb2plY3QuZ2VuZXJhdGVJZChfcmVzb3VyY2UpO1xyXG5cclxuICAgICAgUHJvamVjdC5yZXNvdXJjZXNbX3Jlc291cmNlLmlkUmVzb3VyY2VdID0gX3Jlc291cmNlO1xyXG5cclxuICAgICAgaWYgKF9yZXNvdXJjZSBpbnN0YW5jZW9mIEdyYXBoKVxyXG4gICAgICAgIF9yZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkdSQVBIX01VVEFURUQsIChfZXZlbnQ6IEV2ZW50KSA9PiB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KEVWRU5ULkdSQVBIX01VVEFURUQsIHsgZGV0YWlsOiBfcmVzb3VyY2UgfSkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHJlc291cmNlIGZyb20gdGhlIGxpc3Qgb2YgcmVzb3VyY2VzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlcmVnaXN0ZXIoX3Jlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSk6IHZvaWQge1xyXG4gICAgICBkZWxldGUgKFByb2plY3QucmVzb3VyY2VzW19yZXNvdXJjZS5pZFJlc291cmNlXSk7XHJcbiAgICAgIGRlbGV0ZSAoUHJvamVjdC5zZXJpYWxpemF0aW9uW19yZXNvdXJjZS5pZFJlc291cmNlXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGxpc3Qgb2YgcmVzb3VyY2VzIGFuZCB0aGVpciBzZXJpYWxpemF0aW9uLCB0aHVzIHJlbW92aW5nIGFsbCByZXNvdXJjZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgIFByb2plY3QucmVzb3VyY2VzID0ge307XHJcbiAgICAgIFByb2plY3Quc2VyaWFsaXphdGlvbiA9IHt9O1xyXG4gICAgICBQcm9qZWN0LmNsZWFyU2NyaXB0TmFtZXNwYWNlcygpO1xyXG4gICAgICAvLyBQcm9qZWN0LnNjcmlwdE5hbWVzcGFjZXMgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA8VCBleHRlbmRzIENvbXBvbmVudD4oX2NsYXNzOiBuZXcgKCkgPT4gVCk6IFRbXSB7XHJcbiAgICAvLyAgIHJldHVybiA8VFtdPih0aGlzLmNvbXBvbmVudHNbX2NsYXNzLm5hbWVdIHx8IFtdKS5zbGljZSgwKTtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHJlc291cmNlcyBvZiB0aGUgcmVxdWVzdGVkIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0UmVzb3VyY2VzQnlUeXBlPFQ+KF90eXBlOiBuZXcgKF9hcmdzOiBHZW5lcmFsKSA9PiBUKTogU2VyaWFsaXphYmxlUmVzb3VyY2VbXSB7XHJcbiAgICAgIGxldCBmb3VuZDogU2VyaWFsaXphYmxlUmVzb3VyY2VbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCByZXNvdXJjZUlkIGluIFByb2plY3QucmVzb3VyY2VzKSB7XHJcbiAgICAgICAgbGV0IHJlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSA9IFByb2plY3QucmVzb3VyY2VzW3Jlc291cmNlSWRdO1xyXG4gICAgICAgIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIF90eXBlKVxyXG4gICAgICAgICAgZm91bmQucHVzaChyZXNvdXJjZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvdW5kO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgcmVzb3VyY2VzIHdpdGggdGhlIHJlcXVlc3RlZCBuYW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFJlc291cmNlc0J5TmFtZShfbmFtZTogc3RyaW5nKTogU2VyaWFsaXphYmxlUmVzb3VyY2VbXSB7XHJcbiAgICAgIGxldCBmb3VuZDogU2VyaWFsaXphYmxlUmVzb3VyY2VbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCByZXNvdXJjZUlkIGluIFByb2plY3QucmVzb3VyY2VzKSB7XHJcbiAgICAgICAgbGV0IHJlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSA9IFByb2plY3QucmVzb3VyY2VzW3Jlc291cmNlSWRdO1xyXG4gICAgICAgIGlmIChyZXNvdXJjZS5uYW1lID09IF9uYW1lKVxyXG4gICAgICAgICAgZm91bmQucHVzaChyZXNvdXJjZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvdW5kO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIGEgdXNlciByZWFkYWJsZSBhbmQgdW5pcXVlIGlkIHVzaW5nIHRoZSB0eXBlIG9mIHRoZSByZXNvdXJjZSwgdGhlIGRhdGUgYW5kIHJhbmRvbSBudW1iZXJzXHJcbiAgICAgKiBAcGFyYW0gX3Jlc291cmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2VuZXJhdGVJZChfcmVzb3VyY2U6IFNlcmlhbGl6YWJsZVJlc291cmNlKTogc3RyaW5nIHtcclxuICAgICAgLy8gVE9ETzogYnVpbGQgaWQgYW5kIGludGVncmF0ZSBpbmZvIGZyb20gcmVzb3VyY2UsIG5vdCBqdXN0IGRhdGVcclxuICAgICAgbGV0IGlkUmVzb3VyY2U6IHN0cmluZztcclxuICAgICAgZG9cclxuICAgICAgICBpZFJlc291cmNlID0gX3Jlc291cmNlLmNvbnN0cnVjdG9yLm5hbWUgKyBcInxcIiArIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSArIFwifFwiICsgTWF0aC5yYW5kb20oKS50b1ByZWNpc2lvbig1KS5zdWJzdHIoMiwgNSk7XHJcbiAgICAgIHdoaWxlIChQcm9qZWN0LnJlc291cmNlc1tpZFJlc291cmNlXSk7XHJcbiAgICAgIHJldHVybiBpZFJlc291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMsIGlmIGFuIG9iamVjdCBpcyBhIHtAbGluayBTZXJpYWxpemFibGVSZXNvdXJjZX1cclxuICAgICAqIEBwYXJhbSBfb2JqZWN0IFRoZSBvYmplY3QgdG8gZXhhbWluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGlzUmVzb3VyY2UoX29iamVjdDogU2VyaWFsaXphYmxlKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAoUmVmbGVjdC5oYXMoX29iamVjdCwgXCJpZFJlc291cmNlXCIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgcmVzb3VyY2Ugc3RvcmVkIHdpdGggdGhlIGdpdmVuIGlkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZ2V0UmVzb3VyY2UoX2lkUmVzb3VyY2U6IHN0cmluZyk6IFByb21pc2U8U2VyaWFsaXphYmxlUmVzb3VyY2U+IHtcclxuICAgICAgbGV0IHJlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSA9IFByb2plY3QucmVzb3VyY2VzW19pZFJlc291cmNlXTtcclxuICAgICAgaWYgKCFyZXNvdXJjZSkge1xyXG4gICAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gUHJvamVjdC5zZXJpYWxpemF0aW9uW19pZFJlc291cmNlXTtcclxuICAgICAgICBpZiAoIXNlcmlhbGl6YXRpb24pIHtcclxuICAgICAgICAgIERlYnVnLmVycm9yKFwiUmVzb3VyY2Ugbm90IGZvdW5kXCIsIF9pZFJlc291cmNlKTtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXNvdXJjZSA9IGF3YWl0IFByb2plY3QuZGVzZXJpYWxpemVSZXNvdXJjZShzZXJpYWxpemF0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzb3VyY2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBjbG9uZVJlc291cmNlKF9yZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UpOiBQcm9taXNlPFNlcmlhbGl6YWJsZVJlc291cmNlPiB7XHJcbiAgICAgIGlmICghX3Jlc291cmNlKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBTZXJpYWxpemVyLnNlcmlhbGl6ZShfcmVzb3VyY2UpO1xyXG4gICAgICBsZXQgdHlwZTogc3RyaW5nID0gPHN0cmluZz5SZWZsZWN0Lm93bktleXMoc2VyaWFsaXphdGlvbilbMF07XHJcbiAgICAgIGRlbGV0ZSAoc2VyaWFsaXphdGlvblt0eXBlXS5pZFJlc291cmNlKTtcclxuICAgICAgbGV0IGNsb25lOiB0eXBlb2YgX3Jlc291cmNlID0gYXdhaXQgUHJvamVjdC5kZXNlcmlhbGl6ZVJlc291cmNlKHNlcmlhbGl6YXRpb24pO1xyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKGNsb25lKTtcclxuICAgICAgY2xvbmUubmFtZSArPSBcIl9jbG9uZVwiO1xyXG4gICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZWdpc3RlcnMgYSByZXNvdXJjZSBmcm9tIGEge0BsaW5rIE5vZGV9LCBjb3B5aW5nIHRoZSBjb21wbGV0ZSBncmFwaCBzdGFydGluZyB3aXRoIGl0XHJcbiAgICAgKiBAcGFyYW0gX25vZGUgQSBub2RlIHRvIGNyZWF0ZSB0aGUgcmVzb3VyY2UgZnJvbVxyXG4gICAgICogQHBhcmFtIF9yZXBsYWNlV2l0aEluc3RhbmNlIGlmIHRydWUgKGRlZmF1bHQpLCB0aGUgbm9kZSB1c2VkIGFzIG9yaWdpbiBpcyByZXBsYWNlZCBieSBhIHtAbGluayBHcmFwaEluc3RhbmNlfSBvZiB0aGUge0BsaW5rIEdyYXBofSBjcmVhdGVkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgcmVnaXN0ZXJBc0dyYXBoKF9ub2RlOiBOb2RlLCBfcmVwbGFjZVdpdGhJbnN0YW5jZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPEdyYXBoPiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gX25vZGUuc2VyaWFsaXplKCk7XHJcbiAgICAgIGxldCBncmFwaDogR3JhcGggPSBuZXcgR3JhcGgoX25vZGUubmFtZSk7XHJcbiAgICAgIGF3YWl0IGdyYXBoLmRlc2VyaWFsaXplKHNlcmlhbGl6YXRpb24pO1xyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKGdyYXBoKTtcclxuXHJcbiAgICAgIGlmIChfcmVwbGFjZVdpdGhJbnN0YW5jZSAmJiBfbm9kZS5nZXRQYXJlbnQoKSkge1xyXG4gICAgICAgIGxldCBpbnN0YW5jZTogR3JhcGhJbnN0YW5jZSA9IGF3YWl0IFByb2plY3QuY3JlYXRlR3JhcGhJbnN0YW5jZShncmFwaCk7XHJcbiAgICAgICAgX25vZGUuZ2V0UGFyZW50KCkucmVwbGFjZUNoaWxkKF9ub2RlLCBpbnN0YW5jZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBncmFwaDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB7QGxpbmsgR3JhcGhJbnN0YW5jZX0gb2YgdGhlIGdpdmVuIHtAbGluayBHcmFwaH0gXHJcbiAgICAgKiBhbmQgY29ubmVjdHMgaXQgdG8gdGhlIGdyYXBoIGZvciBzeW5jaHJvbmlzYXRpb24gb2YgbXV0YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgY3JlYXRlR3JhcGhJbnN0YW5jZShfZ3JhcGg6IEdyYXBoKTogUHJvbWlzZTxHcmFwaEluc3RhbmNlPiB7XHJcbiAgICAgIGxldCBpbnN0YW5jZTogR3JhcGhJbnN0YW5jZSA9IG5ldyBHcmFwaEluc3RhbmNlKF9ncmFwaCk7IC8vIFRPRE86IGNsZWFudXAgc2luY2UgY3JlYXRpb24gbW92ZWQgaGVyZVxyXG4gICAgICBhd2FpdCBpbnN0YW5jZS5jb25uZWN0VG9HcmFwaCgpO1xyXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4ge0BsaW5rIEdyYXBoSW5zdGFuY2V9IHRvIGJlIHJlc3luY2VkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXJHcmFwaEluc3RhbmNlRm9yUmVzeW5jKF9pbnN0YW5jZTogR3JhcGhJbnN0YW5jZSk6IHZvaWQge1xyXG4gICAgICBsZXQgaW5zdGFuY2VzOiBHcmFwaEluc3RhbmNlW10gPSBQcm9qZWN0LmdyYXBoSW5zdGFuY2VzVG9SZXN5bmNbX2luc3RhbmNlLmlkU291cmNlXSB8fCBbXTtcclxuICAgICAgaW5zdGFuY2VzLnB1c2goX2luc3RhbmNlKTtcclxuICAgICAgUHJvamVjdC5ncmFwaEluc3RhbmNlc1RvUmVzeW5jW19pbnN0YW5jZS5pZFNvdXJjZV0gPSBpbnN0YW5jZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXN5bmMgYWxsIHtAbGluayBHcmFwaEluc3RhbmNlfSByZWdpc3RlcmVkIHRvIHRoZSBnaXZlbiB7QGxpbmsgR3JhcGh9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgcmVzeW5jR3JhcGhJbnN0YW5jZXMoX2dyYXBoOiBHcmFwaCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBsZXQgaW5zdGFuY2VzOiBHcmFwaEluc3RhbmNlW10gPSBQcm9qZWN0LmdyYXBoSW5zdGFuY2VzVG9SZXN5bmNbX2dyYXBoLmlkUmVzb3VyY2VdO1xyXG4gICAgICBpZiAoIWluc3RhbmNlcylcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGZvciAobGV0IGluc3RhbmNlIG9mIGluc3RhbmNlcylcclxuICAgICAgICBhd2FpdCBpbnN0YW5jZS5jb25uZWN0VG9HcmFwaCgpO1xyXG4gICAgICBkZWxldGUgKFByb2plY3QuZ3JhcGhJbnN0YW5jZXNUb1Jlc3luY1tfZ3JhcGguaWRSZXNvdXJjZV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIG5hbWVzcGFjZSB0byB0aGUgbGlzdCBvZiBzY3JpcHQtbmFtZXNwYWNlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWdpc3RlclNjcmlwdE5hbWVzcGFjZShfbmFtZXNwYWNlOiBPYmplY3QpOiB2b2lkIHtcclxuICAgICAgbGV0IG5hbWU6IHN0cmluZyA9IFNlcmlhbGl6ZXIucmVnaXN0ZXJOYW1lc3BhY2UoX25hbWVzcGFjZSk7XHJcbiAgICAgIGlmICghUHJvamVjdC5zY3JpcHROYW1lc3BhY2VzW25hbWVdKVxyXG4gICAgICAgIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlc1tuYW1lXSA9IF9uYW1lc3BhY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciB0aGUgbGlzdCBvZiBzY3JpcHQtbmFtZXNwYWNlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGVhclNjcmlwdE5hbWVzcGFjZXMoKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gUHJvamVjdC5zY3JpcHROYW1lc3BhY2VzKSB7XHJcbiAgICAgICAgUmVmbGVjdC5zZXQod2luZG93LCBuYW1lLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlc1tuYW1lXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBkZWxldGUgUHJvamVjdC5zY3JpcHROYW1lc3BhY2VzW25hbWVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0cyBhbGwge0BsaW5rIENvbXBvbmVudFNjcmlwdH1zIHJlZ2lzdGVyZWQgaW4ge0BsaW5rIFByb2plY3Quc2NyaXB0TmFtZXNwYWNlc30gYW5kIHJldHVybnMgdGhlbS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb21wb25lbnRTY3JpcHRzKCk6IENvbXBvbmVudFNjcmlwdHMge1xyXG4gICAgICBsZXQgY29tcG9tZW50czogQ29tcG9uZW50U2NyaXB0cyA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBuYW1lc3BhY2UgaW4gUHJvamVjdC5zY3JpcHROYW1lc3BhY2VzKSB7XHJcbiAgICAgICAgY29tcG9tZW50c1tuYW1lc3BhY2VdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBQcm9qZWN0LnNjcmlwdE5hbWVzcGFjZXNbbmFtZXNwYWNlXSkge1xyXG4gICAgICAgICAgbGV0IHNjcmlwdDogQ29tcG9uZW50U2NyaXB0ID0gUmVmbGVjdC5nZXQoUHJvamVjdC5zY3JpcHROYW1lc3BhY2VzW25hbWVzcGFjZV0sIG5hbWUpO1xyXG4gICAgICAgICAgLy8gVXNpbmcgT2JqZWN0LmNyZWF0ZSBkb2Vzbid0IGNhbGwgdGhlIGNvbnN0cnVjdG9yLCBidXQgaW5zdGFuY2VvZiBjYW4gYmUgdXNlZC4gTW9yZSBlbGVnYW50IHRoYW4gdGhlIGxvb3AgYWJvdmUsIHRob3VnaCBtYXliZSBub3QgYXMgcGVyZm9ybWFudC4gXHJcblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IG86IEdlbmVyYWwgPSBPYmplY3QuY3JlYXRlKHNjcmlwdCk7XHJcbiAgICAgICAgICAgIGlmIChvLnByb3RvdHlwZSBpbnN0YW5jZW9mIENvbXBvbmVudFNjcmlwdClcclxuICAgICAgICAgICAgICBjb21wb21lbnRzW25hbWVzcGFjZV0ucHVzaChzY3JpcHQpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoX2UpIHsgLyogKi8gfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY29tcG9tZW50cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgc2NyaXB0IGZyb20gdGhlIGdpdmVuIFVSTCBhbmQgaW50ZWdyYXRlcyBpdCBpbnRvIGEge0BsaW5rIEhUTUxTY3JpcHRFbGVtZW50fSBpbiB0aGUge0BsaW5rIGRvY3VtZW50LmhlYWR9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZFNjcmlwdChfdXJsOiBSZXF1ZXN0SW5mbyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBsZXQgc2NyaXB0OiBIVE1MU2NyaXB0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XHJcbiAgICAgIHNjcmlwdC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcclxuICAgICAgLy8gc2NyaXB0LnR5cGUgPSBcIm1vZHVsZVwiO1xyXG4gICAgICBzY3JpcHQuYXN5bmMgPSBmYWxzZTtcclxuICAgICAgLy8gc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGhhbmRsZUxvYWRlZFNjcmlwdClcclxuICAgICAgbGV0IGhlYWQ6IEhUTUxIZWFkRWxlbWVudCA9IGRvY3VtZW50LmhlYWQ7XHJcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuICAgICAgRGVidWcubG9nKFwiTG9hZGluZzogXCIsIF91cmwpO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xyXG4gICAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiBfcmVzb2x2ZSgpKTtcclxuICAgICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpID0+IHtcclxuICAgICAgICAgIERlYnVnLmVycm9yKFwiTG9hZGluZyBzY3JpcHRcIiwgX3VybCk7XHJcbiAgICAgICAgICBfcmVqZWN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2NyaXB0LnNyYyA9IF91cmwudG9TdHJpbmcoKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIHtAbGluayBSZXNvdXJjZXN9IGZyb20gdGhlIGdpdmVuIHVybFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWRSZXNvdXJjZXMoX3VybDogUmVxdWVzdEluZm8pOiBQcm9taXNlPFJlc291cmNlcz4ge1xyXG4gICAgICBjb25zdCByZXNwb25zZTogUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChfdXJsKTtcclxuICAgICAgY29uc3QgcmVzb3VyY2VGaWxlQ29udGVudDogc3RyaW5nID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG5cclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBTZXJpYWxpemVyLnBhcnNlKHJlc291cmNlRmlsZUNvbnRlbnQpO1xyXG4gICAgICBsZXQgcmVjb25zdHJ1Y3Rpb246IFJlc291cmNlcyA9IGF3YWl0IFByb2plY3QuZGVzZXJpYWxpemUoc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIFByb2plY3QuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuUkVTT1VSQ0VTX0xPQURFRCwgeyBkZXRhaWw6IHsgdXJsOiBfdXJsLCByZXNvdXJjZXM6IHJlY29uc3RydWN0aW9uIH0gfSkpO1xyXG4gICAgICByZXR1cm4gcmVjb25zdHJ1Y3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIGFsbCByZXNvdXJjZXMgZnJvbSB0aGUge0BsaW5rIGRvY3VtZW50LmhlYWR9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZFJlc291cmNlc0Zyb21IVE1MKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBjb25zdCBoZWFkOiBIVE1MSGVhZEVsZW1lbnQgPSBkb2N1bWVudC5oZWFkO1xyXG4gICAgICBsZXQgbGlua3M6IE5vZGVMaXN0T2Y8SFRNTExpbmtFbGVtZW50PiA9IGhlYWQucXVlcnlTZWxlY3RvckFsbChcImxpbmtbdHlwZT1yZXNvdXJjZXNdXCIpO1xyXG4gICAgICBmb3IgKGxldCBsaW5rIG9mIGxpbmtzKSB7XHJcbiAgICAgICAgbGV0IHVybDogUmVxdWVzdEluZm8gPSBsaW5rLmdldEF0dHJpYnV0ZShcInNyY1wiKTtcclxuICAgICAgICBhd2FpdCBQcm9qZWN0LmxvYWRSZXNvdXJjZXModXJsKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VyaWFsaXplIGFsbCByZXNvdXJjZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbk9mUmVzb3VyY2VzIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb25PZlJlc291cmNlcyA9IHt9O1xyXG4gICAgICBmb3IgKGxldCBpZFJlc291cmNlIGluIFByb2plY3QucmVzb3VyY2VzKSB7XHJcbiAgICAgICAgbGV0IHJlc291cmNlOiBTZXJpYWxpemFibGVSZXNvdXJjZSA9IFByb2plY3QucmVzb3VyY2VzW2lkUmVzb3VyY2VdO1xyXG4gICAgICAgIGlmIChpZFJlc291cmNlICE9IHJlc291cmNlLmlkUmVzb3VyY2UpXHJcbiAgICAgICAgICBEZWJ1Zy5lcnJvcihcIlJlc291cmNlLWlkIG1pc21hdGNoXCIsIHJlc291cmNlKTtcclxuICAgICAgICBzZXJpYWxpemF0aW9uW2lkUmVzb3VyY2VdID0gU2VyaWFsaXplci5zZXJpYWxpemUocmVzb3VyY2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHJlc291cmNlcyBmcm9tIGEgc2VyaWFsaXphdGlvbiwgZGVsZXRpbmcgYWxsIHJlc291cmNlcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWRcclxuICAgICAqIEBwYXJhbSBfc2VyaWFsaXphdGlvbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbk9mUmVzb3VyY2VzKTogUHJvbWlzZTxSZXNvdXJjZXM+IHtcclxuICAgICAgUHJvamVjdC5zZXJpYWxpemF0aW9uID0gX3NlcmlhbGl6YXRpb247XHJcbiAgICAgIFByb2plY3QucmVzb3VyY2VzID0ge307XHJcbiAgICAgIGZvciAobGV0IGlkUmVzb3VyY2UgaW4gX3NlcmlhbGl6YXRpb24pIHtcclxuICAgICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IF9zZXJpYWxpemF0aW9uW2lkUmVzb3VyY2VdO1xyXG4gICAgICAgIGxldCByZXNvdXJjZTogU2VyaWFsaXphYmxlUmVzb3VyY2UgPSBhd2FpdCBQcm9qZWN0LmRlc2VyaWFsaXplUmVzb3VyY2Uoc2VyaWFsaXphdGlvbik7XHJcbiAgICAgICAgaWYgKHJlc291cmNlKVxyXG4gICAgICAgICAgUHJvamVjdC5yZXNvdXJjZXNbaWRSZXNvdXJjZV0gPSByZXNvdXJjZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gUHJvamVjdC5yZXNvdXJjZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemVSZXNvdXJjZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlUmVzb3VyY2U+IHtcclxuICAgICAgcmV0dXJuIDxQcm9taXNlPFNlcmlhbGl6YWJsZVJlc291cmNlPj5TZXJpYWxpemVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKioge0BsaW5rIFRleEltYWdlU291cmNlfSBpcyBhIHVuaW9uIHR5cGUgd2hpY2ggYXMgb2Ygbm93IGluY2x1ZGVzIHtAbGluayBWaWRlb0ZyYW1lfS4gQWxsIG90aGVyIHBhcnRzIG9mIHRoaXMgdW5pb24gaGF2ZSBhIC53aWR0aCBhbmQgLmhlaWdodCBwcm9wZXJ0eSBidXQgVmlkZW9GcmFtZSBkb2VzIG5vdC4gQW5kIHNpbmNlIHdlIG9ubHkgZXZlciB1c2Uge0BsaW5rIEhUTUxJbWFnZUVsZW1lbnR9IGFuZCB7QGxpbmsgT2Zmc2NyZWVuQ2FudmFzfSBjdXJyZW50bHkgVmlkZW9GcmFtZSBjYW4gYmUgZXhjbHVkZWQgZm9yIGNvbnZlbmllbmNlIG9mIGFjY2Vzc2luZyAud2lkdGggYW5kIC5oZWlnaHQgKi9cclxuICB0eXBlIEltYWdlU291cmNlID0gRXhjbHVkZTxUZXhJbWFnZVNvdXJjZSwgVmlkZW9GcmFtZT47XHJcblxyXG4gIC8qKlxyXG4gICAqIC0gQ1JJU1A6IG5vIG1pcG1hcHBpbmcsIG1hZyBmaWx0ZXIgbmVhcmVzdCwgbWluIGZpbHRlciBuZWFyZXN0XHJcbiAgICogLSBNRURJVU06IG1pcG1hcHBpbmcsIG1hZyBmaWx0ZXIgbmVhcmVzdCwgbWluIGZpbHRlciBuZWFyZXN0X21pcG1hcF9saW5lYXJcclxuICAgKiAtIEJMVVJSWTogbWlwbWFwcGluZywgbWFnIGZpbHRlciBsaW5lYXIsIG1pbiBmaWx0ZXIgbGluZWFyX21pcG1hcF9saW5lYXJcclxuICAgKiAtIFNNT09USDogbm8gbWlwbWFwcGluZywgbWFnIGZpbHRlciBsaW5lYXIsIG1pbiBmaWx0ZXIgbGluZWFyXHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gTUlQTUFQIHtcclxuICAgIENSSVNQLCBNRURJVU0sIEJMVVJSWSwgU01PT1RIXHJcbiAgfVxyXG5cclxuICBleHBvcnQgZW51bSBXUkFQIHtcclxuICAgIFJFUEVBVCwgQ0xBTVAsIE1JUlJPUlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmFzZWNsYXNzIGZvciBkaWZmZXJlbnQga2luZHMgb2YgdGV4dHVyZXMuIFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgQFJlbmRlckluamVjdG9yVGV4dHVyZS5kZWNvcmF0ZVxyXG4gIEBTZXJpYWxpemFibGVSZXNvdXJjZS5yZWdpc3RlclxyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUZXh0dXJlIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZVJlc291cmNlIHtcclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgaWRSZXNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHByb3RlY3RlZCByZW5kZXJEYXRhOiB1bmtub3duO1xyXG5cclxuICAgIHByb3RlY3RlZCB0ZXh0dXJlRGlydHk6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgcHJvdGVjdGVkIG1pcG1hcERpcnR5OiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHByb3RlY3RlZCB3cmFwRGlydHk6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgICNtaXBtYXA6IE1JUE1BUCA9IE1JUE1BUC5DUklTUDtcclxuICAgICN3cmFwOiBXUkFQID0gV1JBUC5SRVBFQVQ7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIlRleHR1cmVcIikge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IG1pcG1hcChfbWlwbWFwOiBNSVBNQVApIHtcclxuICAgICAgdGhpcy4jbWlwbWFwID0gX21pcG1hcDtcclxuICAgICAgdGhpcy5taXBtYXBEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBtaXBtYXAoKTogTUlQTUFQIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21pcG1hcDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHdyYXAoX3dyYXA6IFdSQVApIHtcclxuICAgICAgdGhpcy4jd3JhcCA9IF93cmFwO1xyXG4gICAgICB0aGlzLndyYXBEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB3cmFwKCk6IFdSQVAge1xyXG4gICAgICByZXR1cm4gdGhpcy4jd3JhcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGltYWdlIHNvdXJjZSBvZiB0aGlzIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgdGV4SW1hZ2VTb3VyY2UoKTogSW1hZ2VTb3VyY2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYW5kIGJpbmRzIHRoZSB0ZXh0dXJlIGluIFdlYkdMIGZyb20gdGhlIHtAbGluayB0ZXhJbWFnZVNvdXJjZX0uIFxyXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yVGV4dHVyZX0uIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVzZVJlbmRlckRhdGEoX3RleHR1cmVVbml0OiBudW1iZXIgPSAwKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSB0ZXh0dXJlIGluIFdlYkdMIGZyZWVpbmcgdGhlIGFsbG9jYXRlZCBncHUgbWVtb3J5LlxyXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yVGV4dHVyZX0uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGRlbGV0ZVJlbmRlckRhdGEoKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGltYWdlIGRhdGEgaW4gdGhlIHJlbmRlciBlbmdpbmUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWZyZXNoKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnRleHR1cmVEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2UsXHJcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIG1pcG1hcDogTUlQTUFQW3RoaXMuI21pcG1hcF0sXHJcbiAgICAgICAgd3JhcDogV1JBUFt0aGlzLiN3cmFwXVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcywgX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XHJcbiAgICAgIHRoaXMuI21pcG1hcCA9IDxudW1iZXI+PHVua25vd24+TUlQTUFQW19zZXJpYWxpemF0aW9uLm1pcG1hcF07XHJcbiAgICAgIHRoaXMuI3dyYXAgPSA8bnVtYmVyPjx1bmtub3duPldSQVBbX3NlcmlhbGl6YXRpb24ud3JhcF07XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKF9leHRlbmRhYmxlPzogYm9vbGVhbik6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IodHJ1ZSk7XHJcbiAgICAgIG11dGF0b3IubWlwbWFwID0gdGhpcy4jbWlwbWFwO1xyXG4gICAgICBtdXRhdG9yLndyYXAgPSB0aGlzLiN3cmFwO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSBzdXBlci5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xyXG4gICAgICBpZiAodHlwZXMubWlwbWFwKVxyXG4gICAgICAgIHR5cGVzLm1pcG1hcCA9IE1JUE1BUDtcclxuICAgICAgaWYgKHR5cGVzLndyYXApXHJcbiAgICAgICAgdHlwZXMud3JhcCA9IFdSQVA7XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuaWRSZXNvdXJjZTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnJlbmRlckRhdGE7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci50ZXh0dXJlRGlydHk7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5taXBtYXBEaXJ0eTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLm1pcG1hcEdlbmVyYXRlZDtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLndyYXBEaXJ0eTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGFuIGV4aXN0aW5nIGltYWdlXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFRleHR1cmVJbWFnZSBleHRlbmRzIFRleHR1cmUge1xyXG4gICAgcHVibGljIGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50ID0gbnVsbDtcclxuICAgIHB1YmxpYyB1cmw6IFJlcXVlc3RJbmZvO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfdXJsPzogUmVxdWVzdEluZm8pIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgaWYgKF91cmwpIHtcclxuICAgICAgICB0aGlzLmxvYWQoX3VybCk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gX3VybC50b1N0cmluZygpLnNwbGl0KFwiL1wiKS5wb3AoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHRleEltYWdlU291cmNlKCk6IEltYWdlU291cmNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBc3luY2hyb25vdXNseSBsb2FkcyB0aGUgaW1hZ2UgZnJvbSB0aGUgZ2l2ZW4gdXJsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkKF91cmw6IFJlcXVlc3RJbmZvKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIHRoaXMudXJsID0gX3VybDtcclxuICAgICAgdGhpcy5pbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG5cclxuXHJcbiAgICAgIC8vIGNvbnN0IHJlc3BvbnNlOiBSZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5mZXRjaCh0aGlzLnVybCk7XHJcbiAgICAgIC8vIGNvbnN0IGJsb2I6IEJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XHJcbiAgICAgIC8vIGxldCBvYmplY3RVUkw6IHN0cmluZyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICAgIC8vIHRoaXMuaW1hZ2Uuc3JjID0gb2JqZWN0VVJMO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xyXG4gICAgICAgIHRoaXMuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5yZW5kZXJEYXRhID0gbnVsbDsgLy8gcmVmcmVzaCByZW5kZXIgZGF0YSBvbiBuZXh0IGRyYXcgY2FsbFxyXG4gICAgICAgICAgX3Jlc29sdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiBfcmVqZWN0KCkpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2Uuc3JjID0gbmV3IFVSTCh0aGlzLnVybC50b1N0cmluZygpLCBQcm9qZWN0LmJhc2VVUkwpLnRvU3RyaW5nKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB1cmw6IHRoaXMudXJsLFxyXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSwgLy8gc2VyaWFsaXplIGZvciBlZGl0b3Igdmlld3NcclxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIGF3YWl0IHRoaXMubG9hZChfc2VyaWFsaXphdGlvbi51cmwpO1xyXG4gICAgICAvLyB0aGlzLnR5cGUgaXMgYW4gYWNjZXNzb3Igb2YgTXV0YWJsZSBkb2Vzbid0IG5lZWQgdG8gYmUgZGVzZXJpYWxpemVkXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAoX211dGF0b3IudXJsICYmIF9tdXRhdG9yLnVybCAhPSB0aGlzLnVybC50b1N0cmluZygpKVxyXG4gICAgICAgIGF3YWl0IHRoaXMubG9hZChfbXV0YXRvci51cmwpO1xyXG4gICAgICAvLyBleGNlcHQgdXJsIGZyb20gbXV0YXRvciBmb3IgZnVydGhlciBwcm9jZXNzaW5nXHJcbiAgICAgIGRlbGV0ZSAoX211dGF0b3IudXJsKTtcclxuICAgICAgYXdhaXQgc3VwZXIubXV0YXRlKF9tdXRhdG9yLCBfc2VsZWN0aW9uLCBfZGlzcGF0Y2hNdXRhdGUpO1xyXG4gICAgICAvLyBUT0RPOiBleGFtaW5lIG5lY2Vzc2l0eSB0byByZWNvbnN0cnVjdCwgaWYgbXV0YXRvciBpcyBrZXB0IGJ5IGNhbGxlclxyXG4gICAgICAvLyBfbXV0YXRvci51cmwgPSB0aGlzLnVybDsgXHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGEgY2FudmFzXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFRleHR1cmVCYXNlNjQgZXh0ZW5kcyBUZXh0dXJlIHtcclxuICAgIHB1YmxpYyBpbWFnZTogSFRNTEltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfYmFzZTY0OiBzdHJpbmcsIF9taXBtYXA6IE1JUE1BUCA9IE1JUE1BUC5DUklTUCwgX3dyYXA6IFdSQVAgPSBXUkFQLlJFUEVBVCwgX3dpZHRoPzogbnVtYmVyLCBfaGVpZ2h0PzogbnVtYmVyKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgdGhpcy5pbWFnZS5zcmMgPSBfYmFzZTY0O1xyXG4gICAgICB0aGlzLm1pcG1hcCA9IF9taXBtYXA7XHJcbiAgICAgIHRoaXMud3JhcCA9IF93cmFwO1xyXG4gICAgICBpZiAoX3dpZHRoKVxyXG4gICAgICAgIHRoaXMuaW1hZ2Uud2lkdGggPSBfd2lkdGg7XHJcbiAgICAgIGlmIChfaGVpZ2h0KVxyXG4gICAgICAgIHRoaXMuaW1hZ2UuaGVpZ2h0ID0gX2hlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHRleEltYWdlU291cmNlKCk6IEltYWdlU291cmNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGEgY2FudmFzXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFRleHR1cmVDYW52YXMgZXh0ZW5kcyBUZXh0dXJlIHtcclxuICAgIHB1YmxpYyBjcmMyOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcsIF9jcmMyOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgc3VwZXIoX25hbWUpO1xyXG4gICAgICB0aGlzLmNyYzIgPSBfY3JjMjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXQgdGV4SW1hZ2VTb3VyY2UoKTogSW1hZ2VTb3VyY2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5jcmMyLmNhbnZhcztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRleHR1cmUgY3JlYXRlZCBmcm9tIGEgdGV4dC4gVGV4dHVyZSB1cGF0ZXMgd2hlbiB0aGUgdGV4dCBvciBmb250IGNoYW5nZXMuIFRoZSB0ZXh0dXJlIGlzIHJlc2l6ZWQgdG8gZml0IHRoZSB0ZXh0LlxyXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlVGV4dCBleHRlbmRzIFRleHR1cmUge1xyXG4gICAgcHJvdGVjdGVkIGNyYzI6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuICAgICN0ZXh0OiBzdHJpbmc7XHJcbiAgICAjZm9udDogc3RyaW5nO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfdGV4dDogc3RyaW5nID0gXCJUZXh0XCIsIF9mb250OiBzdHJpbmcgPSBcIjIwcHggbW9ub3NwYWNlXCIpIHtcclxuICAgICAgc3VwZXIoX25hbWUpO1xyXG4gICAgICB0aGlzLmNyYzIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgdGhpcy50ZXh0ID0gX3RleHQ7XHJcbiAgICAgIHRoaXMuZm9udCA9IF9mb250O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgdGV4dChfdGV4dDogc3RyaW5nKSB7XHJcbiAgICAgIHRoaXMuI3RleHQgPSBfdGV4dDtcclxuICAgICAgdGhpcy50ZXh0dXJlRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdGV4dCgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy4jdGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGZvbnQoX2ZvbnQ6IHN0cmluZykge1xyXG4gICAgICB0aGlzLiNmb250ID0gX2ZvbnQ7XHJcbiAgICAgIGRvY3VtZW50LmZvbnRzLmxvYWQodGhpcy4jZm9udClcclxuICAgICAgICAuY2F0Y2goKF9lcnJvcikgPT4gRGVidWcuZXJyb3IoYCR7VGV4dHVyZVRleHQubmFtZX06ICR7X2Vycm9yfWApKVxyXG4gICAgICAgIC5maW5hbGx5KCgpID0+IHRoaXMudGV4dHVyZURpcnR5ID0gdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBmb250KCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNmb250O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdGV4SW1hZ2VTb3VyY2UoKTogSW1hZ2VTb3VyY2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5jYW52YXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB3aWR0aCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5jYW52YXMud2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBoZWlnaHQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGhhc1RyYW5zcGFyZW5jeSgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXQgY2FudmFzKCk6IEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY3JjMi5jYW52YXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVzZVJlbmRlckRhdGEoX3RleHR1cmVVbml0PzogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLnRleHR1cmVEaXJ0eSkge1xyXG4gICAgICAgIHRoaXMuY3JjMi5mb250ID0gdGhpcy5mb250O1xyXG5cclxuICAgICAgICBsZXQgbWV0cmljczogVGV4dE1ldHJpY3MgPSB0aGlzLmNyYzIubWVhc3VyZVRleHQodGhpcy50ZXh0KTtcclxuICAgICAgICBsZXQgd2lkdGg6IG51bWJlciA9IG1ldHJpY3Mud2lkdGg7XHJcbiAgICAgICAgbGV0IGhlaWdodDogbnVtYmVyID0gbWV0cmljcy5mb250Qm91bmRpbmdCb3hBc2NlbnQgKyBtZXRyaWNzLmZvbnRCb3VuZGluZ0JveERlc2NlbnQ7XHJcblxyXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGggKyB0aGlzLmNyYzIubWVhc3VyZVRleHQoXCIgIFwiKS53aWR0aDtcclxuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiAxLjE7IC8vIHBhZGRpbmcsIG90aGVyd2lzZSBvbiBzb21lIGdseXBocyBtaWdodCBnZXQgY3V0IG9mZlxyXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcy53aWR0aCA9PSAwKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLmNyYzIuZm9udCA9IHRoaXMuZm9udDsgLy8gVE9ETzogd2FpdCBmb3IgZm9udCB0byBiZSBsb2FkZWQgdXNpbmcgZG9jdW1lbnQuZm9udHNcclxuICAgICAgICB0aGlzLmNyYzIudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgICB0aGlzLmNyYzIudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuICAgICAgICB0aGlzLmNyYzIuZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xyXG4gICAgICAgIHRoaXMuY3JjMi5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5jcmMyLmZpbGxUZXh0KHRoaXMuI3RleHQsIHRoaXMuY2FudmFzLndpZHRoIC8gMiwgdGhpcy5jYW52YXMuaGVpZ2h0IC8gMik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN1cGVyLnVzZVJlbmRlckRhdGEoX3RleHR1cmVVbml0KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKCksXHJcbiAgICAgICAgdGV4dDogdGhpcy50ZXh0LFxyXG4gICAgICAgIGZvbnQ6IHRoaXMuZm9udFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgdGhpcy50ZXh0ID0gX3NlcmlhbGl6YXRpb24udGV4dDtcclxuICAgICAgdGhpcy5mb250ID0gX3NlcmlhbGl6YXRpb24uZm9udDtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoX2V4dGVuZGFibGU/OiBib29sZWFuKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcih0cnVlKTtcclxuICAgICAgbXV0YXRvci50ZXh0ID0gdGhpcy50ZXh0O1xyXG4gICAgICBtdXRhdG9yLmZvbnQgPSB0aGlzLmZvbnQ7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGV4dHVyZSBjcmVhdGVkIGZyb20gYSBGVURHRS1Ta2V0Y2hcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVGV4dHVyZVNrZXRjaCBleHRlbmRzIFRleHR1cmVDYW52YXMge1xyXG4gICAgcHVibGljIGdldCB0ZXhJbWFnZVNvdXJjZSgpOiBJbWFnZVNvdXJjZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBUZXh0dXJlIGNyZWF0ZWQgZnJvbSBhbiBIVE1MLXBhZ2VcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVGV4dHVyZUhUTUwgZXh0ZW5kcyBUZXh0dXJlQ2FudmFzIHtcclxuICAgIHB1YmxpYyBnZXQgdGV4SW1hZ2VTb3VyY2UoKTogSW1hZ2VTb3VyY2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhbGwgbWVzaGVzLiBcclxuICAgKiBNZXNoZXMgcHJvdmlkZSBpbmRleGVkIHZlcnRpY2VzLCB0aGUgb3JkZXIgb2YgaW5kaWNlcyB0byBjcmVhdGUgdHJpZ29ucyBhbmQgbm9ybWFscywgYW5kIHRleHR1cmUgY29vcmRpbmF0ZXNcclxuICAgKiBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOS8yMlxyXG4gICAqL1xyXG4gIEBSZW5kZXJJbmplY3Rvck1lc2guZGVjb3JhdGVcclxuICBAU2VyaWFsaXphYmxlUmVzb3VyY2UucmVnaXN0ZXJcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgTWVzaCBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICAvKiogcmVmZXJzIGJhY2sgdG8gdGhpcyBjbGFzcyBmcm9tIGFueSBzdWJjbGFzcyBlLmcuIGluIG9yZGVyIHRvIGZpbmQgY29tcGF0aWJsZSBvdGhlciByZXNvdXJjZXMqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBiYXNlQ2xhc3M6IHR5cGVvZiBNZXNoID0gTWVzaDtcclxuICAgIC8qKiBsaXN0IG9mIGFsbCB0aGUgc3ViY2xhc3NlcyBkZXJpdmVkIGZyb20gdGhpcyBjbGFzcywgaWYgdGhleSByZWdpc3RlcmVkIHByb3Blcmx5Ki9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgc3ViY2xhc3NlczogdHlwZW9mIE1lc2hbXSA9IFtdO1xyXG5cclxuICAgIC8vIFRPRE86IHJlbmFtZSB2ZXJ0aWNlcyB0byB2ZXJ0aWNlc1Ntb290aCBvciBqdXN0IGNsb3VkLCBhbmQgY2xvdWQgdG8gdmVydGljZXNcclxuXHJcbiAgICBwdWJsaWMgaWRSZXNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZyA9IFwiTWVzaFwiO1xyXG4gICAgLy8gYmFzZSBzdHJ1Y3R1cmUgZm9yIG1lc2hlcyBpbiBGVURHRVxyXG4gICAgcHVibGljIHZlcnRpY2VzOiBWZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgcHVibGljIGZhY2VzOiBGYWNlW10gPSBbXTtcclxuXHJcbiAgICAvKiogYm91bmRpbmcgYm94IEFBQkIgKi9cclxuICAgIHByb3RlY3RlZCDGkmJveDogQm94O1xyXG4gICAgLy8gVE9ETzogZXhwbG9yZSBtYXRoZW1hdGljcyBmb3IgZWFzeSB0cmFuc2Zvcm1hdGlvbnMgb2YgcmFkaXVzIFxyXG4gICAgLyoqIGJvdW5kaW5nIHJhZGl1cyAqL1xyXG4gICAgcHJvdGVjdGVkIMaScmFkaXVzOiBudW1iZXI7XHJcblxyXG4gICAgI3JlbmRlck1lc2g6IFJlbmRlck1lc2g7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hcIikge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0ZXJTdWJjbGFzcyhfc3ViQ2xhc3M6IHR5cGVvZiBNZXNoKTogbnVtYmVyIHsgcmV0dXJuIE1lc2guc3ViY2xhc3Nlcy5wdXNoKF9zdWJDbGFzcykgLSAxOyB9XHJcblxyXG4gICAgcHVibGljIGdldCByZW5kZXJNZXNoKCk6IFJlbmRlck1lc2gge1xyXG4gICAgICBpZiAodGhpcy4jcmVuZGVyTWVzaCA9PSBudWxsKVxyXG4gICAgICAgIHRoaXMuI3JlbmRlck1lc2ggPSBuZXcgUmVuZGVyTWVzaCh0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLiNyZW5kZXJNZXNoO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgYm91bmRpbmdCb3goKTogQm94IHtcclxuICAgICAgaWYgKHRoaXMuxpJib3ggPT0gbnVsbClcclxuICAgICAgICB0aGlzLsaSYm94ID0gdGhpcy5jcmVhdGVCb3VuZGluZ0JveCgpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuxpJib3g7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IHJhZGl1cygpOiBudW1iZXIge1xyXG4gICAgICBpZiAodGhpcy7GknJhZGl1cyA9PSBudWxsKVxyXG4gICAgICAgIHRoaXMuxpJyYWRpdXMgPSB0aGlzLmNyZWF0ZVJhZGl1cygpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuxpJyYWRpdXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JNZXNofS5cclxuICAgICAqIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqLyAvLyBUT0RPOiByZW5hbWUgdGhpc1xyXG4gICAgcHVibGljIHVzZVJlbmRlckJ1ZmZlcnMoKTogUmVuZGVyQnVmZmVycyB7IHJldHVybiBudWxsOyAvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yTWVzaH0uXHJcbiAgICAgKiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRSZW5kZXJCdWZmZXJzKCk6IFJlbmRlckJ1ZmZlcnMgeyByZXR1cm4gbnVsbDsgLyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XHJcbiAgICAvKipcclxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3Rvck1lc2h9LlxyXG4gICAgICogVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVsZXRlUmVuZGVyQnVmZmVycyhfcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVycyk6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBib3VuZHMgb2YgdGhpcyBtZXNoIGFzd2VsbCBhcyB0aGUgYnVmZmVycyBvZiB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgUmVuZGVyTWVzaH0uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcclxuICAgICAgdGhpcy7GkmJveCA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy7GknJhZGl1cyA9IHVuZGVmaW5lZDtcclxuICAgICAgXHJcbiAgICAgIHRoaXMuZGVsZXRlUmVuZGVyQnVmZmVycyh0aGlzLnJlbmRlck1lc2guYnVmZmVycyk7XHJcbiAgICAgIHRoaXMucmVuZGVyTWVzaC5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgLy8gU2VyaWFsaXplL0Rlc2VyaWFsaXplIGZvciBhbGwgbWVzaGVzIHRoYXQgY2FsY3VsYXRlIHdpdGhvdXQgcGFyYW1ldGVyc1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgaWRSZXNvdXJjZTogdGhpcy5pZFJlc291cmNlLFxyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUgLy8gc3RvcmUgZm9yIGVkaXRvciB2aWV3XHJcbiAgICAgIH07IC8vIG5vIGRhdGEgbmVlZGVkIC4uLlxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcywgX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9zZXJpYWxpemF0aW9uLm5hbWU7XHJcbiAgICAgIC8vIHR5cGUgaXMgYW4gYWNjZXNzb3IgYW5kIG11c3Qgbm90IGJlIGRlc2VyaWFsaXplZFxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAvLyBUT0RPOiBzbyBtdWNoIHRvIGRlbGV0ZS4uLiByYXRoZXIganVzdCBnYXRoZXIgd2hhdCB0byBtdXRhdGVcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLsaSYm94O1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuxpJyYWRpdXM7XHJcblxyXG4gICAgICBkZWxldGUgX211dGF0b3IucmVuZGVyQnVmZmVycztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlUmFkaXVzKCk6IG51bWJlciB7XHJcbiAgICAgIC8vVE9ETzogcmFkaXVzIGFuZCBib3VuZGluZyBib3ggY291bGQgYmUgY3JlYXRlZCBvbiBjb25zdHJ1Y3Rpb24gb2YgdmVydGV4LWFycmF5XHJcbiAgICAgIGxldCByYWRpdXM6IG51bWJlciA9IDA7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcmFkaXVzID0gTWF0aC5tYXgocmFkaXVzLCB0aGlzLnZlcnRpY2VzLnBvc2l0aW9uKGkpLm1hZ25pdHVkZVNxdWFyZWQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBNYXRoLnNxcnQocmFkaXVzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlQm91bmRpbmdCb3goKTogQm94IHtcclxuICAgICAgbGV0IGJveDogQm94ID0gUmVjeWNsZXIuZ2V0KEJveCk7XHJcbiAgICAgIGJveC5zZXQoKTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgcG9pbnQ6IFZlY3RvcjMgPSB0aGlzLnZlcnRpY2VzLnBvc2l0aW9uKGkpO1xyXG4gICAgICAgIGJveC5leHBhbmQocG9pbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBib3g7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEJhc2VjbGFzcyBmb3IgbWF0ZXJpYWxzLiBDb21iaW5lcyBhIHtAbGluayBTaGFkZXJ9IHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBDb2F0fVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgQGVudW1lcmF0ZVxyXG4gIEBTZXJpYWxpemFibGVSZXNvdXJjZS5yZWdpc3RlclxyXG4gIGV4cG9ydCBjbGFzcyBNYXRlcmlhbCBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICAvKiogVGhlIG5hbWUgdG8gY2FsbCB0aGUgTWF0ZXJpYWwgYnkuICovXHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG4gICAgcHVibGljIGlkUmVzb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBwdWJsaWMgdGltZXN0YW1wVXBkYXRlOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHByaXZhdGUgc2hhZGVyVHlwZTogdHlwZW9mIFNoYWRlcjsgLy8gVGhlIHNoYWRlciBwcm9ncmFtIHVzZWQgYnkgdGhpcyBCYXNlTWF0ZXJpYWxcclxuICAgICNjb2F0OiBDb2F0O1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfc2hhZGVyPzogdHlwZW9mIFNoYWRlciwgX2NvYXQ/OiBDb2F0KSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICB0aGlzLnNoYWRlclR5cGUgPSBfc2hhZGVyO1xyXG4gICAgICBpZiAoX3NoYWRlcikge1xyXG4gICAgICAgIGlmIChfY29hdClcclxuICAgICAgICAgIHRoaXMuY29hdCA9IF9jb2F0O1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMuY29hdCA9IHRoaXMuY3JlYXRlQ29hdE1hdGNoaW5nU2hhZGVyKCk7XHJcbiAgICAgIH1cclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSByZWZlcmVuY2VkIHtAbGluayBDb2F0fSBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBAdHlwZShDb2F0KVxyXG4gICAgQGVudW1lcmF0ZVxyXG4gICAgcHVibGljIGdldCBjb2F0KCk6IENvYXQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY29hdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgdGhpcyBtYXRlcmlhbCByZWZlcmVuY2UgdGhlIGdpdmVuIHtAbGluayBDb2F0fSBpZiBpdCBpcyBjb21wYXRpYmxlIHdpdGggdGhlIHJlZmVyZW5jZWQge0BsaW5rIFNoYWRlcn1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBjb2F0KF9jb2F0OiBDb2F0KSB7XHJcbiAgICAgIGlmICh0aGlzLnNoYWRlclR5cGUpXHJcbiAgICAgICAgaWYgKF9jb2F0LmNvbnN0cnVjdG9yICE9IHRoaXMuc2hhZGVyVHlwZS5nZXRDb2F0KCkpXHJcbiAgICAgICAgICBpZiAoX2NvYXQgaW5zdGFuY2VvZiB0aGlzLnNoYWRlclR5cGUuZ2V0Q29hdCgpKVxyXG4gICAgICAgICAgICBEZWJ1Zy5mdWRnZShcIkNvYXQgaXMgZXh0ZW5zaW9uIG9mIENvYXQgcmVxdWlyZWQgYnkgc2hhZGVyXCIpO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aHJvdyAobmV3IEVycm9yKFwiU2hhZGVyIGFuZCBjb2F0IGRvbid0IG1hdGNoXCIpKTtcclxuICAgICAgdGhpcy4jY29hdCA9IF9jb2F0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgQ29hdH0gaW5zdGFuY2UgdGhhdCBpcyB2YWxpZCBmb3IgdGhlIHtAbGluayBTaGFkZXJ9IHJlZmVyZW5jZWQgYnkgdGhpcyBtYXRlcmlhbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlQ29hdE1hdGNoaW5nU2hhZGVyKCk6IENvYXQge1xyXG4gICAgICBsZXQgY29hdDogQ29hdCA9IG5ldyAodGhpcy5zaGFkZXJUeXBlLmdldENvYXQoKSkoKTtcclxuICAgICAgcmV0dXJuIGNvYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBtYXRlcmlhbHMgcmVmZXJlbmNlIHRvIHRoZSBnaXZlbiB7QGxpbmsgU2hhZGVyfSwgY3JlYXRlcyBhbmQgcmVmZXJlbmNlcyBhIG5ldyB7QGxpbmsgQ29hdH0gaW5zdGFuY2UgIFxyXG4gICAgICogYW5kIG11dGF0ZXMgdGhlIG5ldyBjb2F0IHRvIHByZXNlcnZlIG1hdGNoaW5nIHByb3BlcnRpZXMuXHJcbiAgICAgKiBAcGFyYW0gX3NoYWRlclR5cGUgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRTaGFkZXIoX3NoYWRlclR5cGU6IHR5cGVvZiBTaGFkZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zaGFkZXJUeXBlID0gX3NoYWRlclR5cGU7XHJcbiAgICAgIGxldCBjb2F0OiBDb2F0ID0gdGhpcy5jcmVhdGVDb2F0TWF0Y2hpbmdTaGFkZXIoKTtcclxuICAgICAgY29hdC5tdXRhdGUodGhpcy4jY29hdD8uZ2V0TXV0YXRvcigpKTtcclxuICAgICAgdGhpcy5jb2F0ID0gY29hdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBTaGFkZXJ9IHJlZmVyZW5jZWQgYnkgdGhpcyBtYXRlcmlhbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U2hhZGVyKCk6IHR5cGVvZiBTaGFkZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zaGFkZXJUeXBlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgLy8gVE9ETzogdGhpcyB0eXBlIG9mIHNlcmlhbGl6YXRpb24gd2FzIGltcGxlbWVudGVkIGZvciBpbXBsaWNpdCBNYXRlcmlhbCBjcmVhdGUuIENoZWNrIGlmIG9ic29sZXRlIHdoZW4gb25seSBvbmUgbWF0ZXJpYWwgY2xhc3MgZXhpc3RzIGFuZC9vciBtYXRlcmlhbHMgYXJlIHN0b3JlZCBzZXBhcmF0ZWx5XHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgaWRSZXNvdXJjZTogdGhpcy5pZFJlc291cmNlLFxyXG4gICAgICAgIHNoYWRlcjogdGhpcy5zaGFkZXJUeXBlLm5hbWUsXHJcbiAgICAgICAgY29hdDogU2VyaWFsaXplci5zZXJpYWxpemUodGhpcy4jY29hdCksXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5uYW1lID0gX3NlcmlhbGl6YXRpb24ubmFtZTtcclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzLCBfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlKTtcclxuICAgICAgdGhpcy5zaGFkZXJUeXBlID0gKDxHZW5lcmFsPkZ1ZGdlQ29yZSlbX3NlcmlhbGl6YXRpb24uc2hhZGVyXTtcclxuICAgICAgbGV0IGNvYXQ6IENvYXQgPSA8Q29hdD5hd2FpdCBTZXJpYWxpemVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmNvYXQpO1xyXG4gICAgICB0aGlzLmNvYXQgPSBjb2F0O1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3IudGltZXN0YW1wVXBkYXRlO1xyXG4gICAgICAvLyBkZWxldGUgX211dGF0b3IuaWRSZXNvdXJjZTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgbmFtZXNhcGNlIGZvciBoYW5kbGluZyB0aGUgcGFydGljbGUgZGF0YVxyXG4gICAqL1xyXG4gIGV4cG9ydCBuYW1lc3BhY2UgUGFydGljbGVEYXRhIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgYSBwYXJ0aWNsZSBzeXN0ZW0uIERlc2NyaWJlcyB0aGUgcGFydGljbGUgYmVoYXZpb3IgYW5kIGFwcGVhcmFuY2UuXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgU3lzdGVtIHtcclxuICAgICAgdmFyaWFibGVOYW1lcz86IHN0cmluZ1tdO1xyXG4gICAgICB2YXJpYWJsZXM/OiBFeHByZXNzaW9uW107IC8veyBbbmFtZTogc3RyaW5nXTogRXhwcmVzc2lvbiB9O1xyXG4gICAgICBjb2xvcj86IEV4cHJlc3Npb25bXTtcclxuICAgICAgbXR4TG9jYWw/OiBUcmFuc2Zvcm1hdGlvbltdO1xyXG4gICAgICBtdHhXb3JsZD86IFRyYW5zZm9ybWF0aW9uW107XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IHR5cGUgUmVjdXJzaXZlID0gU3lzdGVtIHwgRXhwcmVzc2lvbltdIHwgVHJhbnNmb3JtYXRpb25bXSB8IFRyYW5zZm9ybWF0aW9uIHwgRXhwcmVzc2lvbjtcclxuXHJcbiAgICBleHBvcnQgdHlwZSBFeHByZXNzaW9uID0gRnVuY3Rpb24gfCBWYXJpYWJsZSB8IENvbnN0YW50IHwgQ29kZTtcclxuXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uIHtcclxuICAgICAgZnVuY3Rpb246IEZVTkNUSU9OO1xyXG4gICAgICBwYXJhbWV0ZXJzOiBFeHByZXNzaW9uW107XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBWYXJpYWJsZSB7XHJcbiAgICAgIHZhbHVlOiBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBDb25zdGFudCB7XHJcbiAgICAgIHZhbHVlOiBudW1iZXI7XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBDb2RlIHtcclxuICAgICAgY29kZTogc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmb3JtYXRpb24ge1xyXG4gICAgICB0cmFuc2Zvcm1hdGlvbjogXCJ0cmFuc2xhdGVcIiB8IFwicm90YXRlXCIgfCBcInNjYWxlXCI7XHJcbiAgICAgIHBhcmFtZXRlcnM6IEV4cHJlc3Npb25bXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZGF0YSBpcyBhIHtAbGluayBFeHByZXNzaW9ufVxyXG4gICAgICovXHJcbiAgICBleHBvcnQgZnVuY3Rpb24gaXNFeHByZXNzaW9uKF9kYXRhOiBSZWN1cnNpdmUpOiBfZGF0YSBpcyBFeHByZXNzaW9uIHtcclxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oX2RhdGEpIHx8IGlzVmFyaWFibGUoX2RhdGEpIHx8IGlzQ29uc3RhbnQoX2RhdGEpIHx8IGlzQ29kZShfZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGRhdGEgaXMgYSB7QGxpbmsgRnVuY3Rpb259XHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKF9kYXRhOiBSZWN1cnNpdmUpOiBfZGF0YSBpcyBGdW5jdGlvbiB7XHJcbiAgICAgIHJldHVybiB0eXBlb2YgX2RhdGEgPT0gXCJvYmplY3RcIiAmJiBcImZ1bmN0aW9uXCIgaW4gX2RhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGRhdGEgaXMgYSB7QGxpbmsgVmFyaWFibGV9XHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc1ZhcmlhYmxlKF9kYXRhOiBSZWN1cnNpdmUpOiBfZGF0YSBpcyBWYXJpYWJsZSB7XHJcbiAgICAgIHJldHVybiB0eXBlb2YgX2RhdGEgPT0gXCJvYmplY3RcIiAmJiBcInZhbHVlXCIgaW4gX2RhdGEgJiYgdHlwZW9mIF9kYXRhLnZhbHVlID09IFwic3RyaW5nXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGRhdGEgaXMgYSB7QGxpbmsgQ29uc3RhbnR9XHJcbiAgICAgKi9cclxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0NvbnN0YW50KF9kYXRhOiBSZWN1cnNpdmUpOiBfZGF0YSBpcyBDb25zdGFudCB7XHJcbiAgICAgIHJldHVybiB0eXBlb2YgX2RhdGEgPT0gXCJvYmplY3RcIiAmJiBcInZhbHVlXCIgaW4gX2RhdGEgJiYgdHlwZW9mIF9kYXRhLnZhbHVlID09IFwibnVtYmVyXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGRhdGEgaXMgYSB7QGxpbmsgQ29kZX1cclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzQ29kZShfZGF0YTogUmVjdXJzaXZlKTogX2RhdGEgaXMgQ29kZSB7XHJcbiAgICAgIHJldHVybiB0eXBlb2YgX2RhdGEgPT0gXCJvYmplY3RcIiAmJiBcImNvZGVcIiBpbiBfZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZGF0YSBpcyBhIHtAbGluayBUcmFuc2Zvcm1hdGlvbn1cclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzVHJhbnNmb3JtYXRpb24oX2RhdGE6IFJlY3Vyc2l2ZSk6IF9kYXRhIGlzIFRyYW5zZm9ybWF0aW9uIHtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBfZGF0YSA9PSBcIm9iamVjdFwiICYmIFwidHJhbnNmb3JtYXRpb25cIiBpbiBfZGF0YTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhvbGRzIGluZm9ybWF0aW9uIG9uIGhvdyB0byBtdXRhdGUgdGhlIHBhcnRpY2xlcyBvZiBhIHBhcnRpY2xlIHN5c3RlbS5cclxuICAgKiBBIGZ1bGwgcGFydGljbGUgc3lzdGVtIGlzIGNvbXBvc2VkIGJ5IGF0dGFjaGluZyBhIHtAbGluayBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbX0sIHtAbGluayBDb21wb25lbnRNZXNofSBhbmQge0BsaW5rIENvbXBvbmVudE1hdGVyaWFsfSB0byB0aGUgc2FtZSB7QGxpbmsgTm9kZX0uIFxyXG4gICAqIEFkZGl0aW9uYWxseSBhIHtAbGluayBDb21wb25lbnRGYWNlQ2FtZXJhfSBjYW4gYmUgYXR0YWNoZWQgdG8gbWFrZSB0aGUgcGFydGljbGVzIGZhY2UgdGhlIGNhbWVyYS5cclxuICAgKiBAYXV0aG9ycyBKb25hcyBQbG90emt5LCBIRlUsIDIwMjJcclxuICAgKi9cclxuICBAU2VyaWFsaXphYmxlUmVzb3VyY2UucmVnaXN0ZXJcclxuICBleHBvcnQgY2xhc3MgUGFydGljbGVTeXN0ZW0gZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcclxuICAgIHB1YmxpYyBpZFJlc291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgI2RhdGE6IFBhcnRpY2xlRGF0YS5TeXN0ZW07XHJcbiAgICAvKiogTWFwIG9mIHNoYWRlciB1bml2ZXJzYWwgZGVyaXZhdGVzIHRvIGNvcnJlc3BvbmRpbmcgY29tcHV0ZWQge0BsaW5rIFNoYWRlclBhcnRpY2xlU3lzdGVtfS4gXHJcbiAgICAgKiBUaGlzIHdheSBlYWNoIHBhcnRpY2xlIHN5c3RlbSByZXNvdXJjZSBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIG11bHRpcGxlIHNoYWRlciB1bml2ZXJzYWwgZGVyaXZhdGVzICovXHJcbiAgICAjbWFwU2hhZGVyVG9TaGFkZXJQYXJ0aWNsZVN5c3RlbTogTWFwPFNoYWRlckludGVyZmFjZSwgU2hhZGVyUGFydGljbGVTeXN0ZW0+ID0gbmV3IE1hcCgpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gUGFydGljbGVTeXN0ZW0ubmFtZSwgX2RhdGE6IFBhcnRpY2xlRGF0YS5TeXN0ZW0gPSB7fSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgICAgdGhpcy5kYXRhID0gX2RhdGE7XHJcblxyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgZGF0YSgpOiBQYXJ0aWNsZURhdGEuU3lzdGVtIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2RhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBkYXRhKF9kYXRhOiBQYXJ0aWNsZURhdGEuU3lzdGVtKSB7XHJcbiAgICAgIHRoaXMuI2RhdGEgPSBfZGF0YTtcclxuICAgICAgdGhpcy4jbWFwU2hhZGVyVG9TaGFkZXJQYXJ0aWNsZVN5c3RlbS5mb3JFYWNoKF9zaGFkZXIgPT4gX3NoYWRlci5kZWxldGVQcm9ncmFtKCkpO1xyXG4gICAgICB0aGlzLiNtYXBTaGFkZXJUb1NoYWRlclBhcnRpY2xlU3lzdGVtLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29ycmVzcG9uZGluZyB7QGxpbmsgU2hhZGVyUGFydGljbGVTeXN0ZW19IGZvciB0aGUgZ2l2ZW4gc2hhZGVyIHVuaXZlcnNhbCBkZXJpdmF0ZS5cclxuICAgICAqIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0gdG8gcmVuZGVyIHRoZSBwYXJ0aWNsZSBzeXN0ZW0uXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyB7QGxpbmsgU2hhZGVyUGFydGljbGVTeXN0ZW19XHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFNoYWRlckZyb20oX3NvdXJjZTogU2hhZGVySW50ZXJmYWNlKTogU2hhZGVyUGFydGljbGVTeXN0ZW0ge1xyXG4gICAgICBpZiAoIXRoaXMuI21hcFNoYWRlclRvU2hhZGVyUGFydGljbGVTeXN0ZW0uaGFzKF9zb3VyY2UpKSB7XHJcbiAgICAgICAgbGV0IHBhcnRpY2xlU2hhZGVyOiBTaGFkZXJQYXJ0aWNsZVN5c3RlbSA9IG5ldyBTaGFkZXJQYXJ0aWNsZVN5c3RlbSgpO1xyXG4gICAgICAgIHBhcnRpY2xlU2hhZGVyLmRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICAgICAgcGFydGljbGVTaGFkZXIuZGVmaW5lID0gWy4uLnBhcnRpY2xlU2hhZGVyLmRlZmluZSwgLi4uX3NvdXJjZS5kZWZpbmVdO1xyXG4gICAgICAgIHBhcnRpY2xlU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IF9zb3VyY2UuZ2V0VmVydGV4U2hhZGVyU291cmNlKCk7XHJcbiAgICAgICAgcGFydGljbGVTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBfc291cmNlLmdldEZyYWdtZW50U2hhZGVyU291cmNlKCk7XHJcbiAgICAgICAgdGhpcy4jbWFwU2hhZGVyVG9TaGFkZXJQYXJ0aWNsZVN5c3RlbS5zZXQoX3NvdXJjZSwgcGFydGljbGVTaGFkZXIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy4jbWFwU2hhZGVyVG9TaGFkZXJQYXJ0aWNsZVN5c3RlbS5nZXQoX3NvdXJjZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2UsXHJcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIGRhdGE6IHRoaXMuZGF0YVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMsIF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xyXG4gICAgICB0aGlzLmRhdGEgPSBfc2VyaWFsaXphdGlvbi5kYXRhO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuY2FjaGVkTXV0YXRvcnM7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zaGFkZXJNYXA7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQnVmZmVycyB0aGUgYm9uZSBkYXRhIGZyb20gdGhlIHtAbGluayBDb21wb25lbnRTa2VsZXRvbn0gaW50byBhIFdlYkdMIEJ1ZmZlclxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZW5kZXJJbmplY3RvckNvbXBvbmVudFNrZWxldG9uIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVjb3JhdGUoX2NvbnN0cnVjdG9yOiB0eXBlb2YgQ29tcG9uZW50U2tlbGV0b24sIF9jb250ZXh0OiBDbGFzc0RlY29yYXRvckNvbnRleHQpOiB2b2lkIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIF9jb25zdHJ1Y3Rvci5wcm90b3R5cGUudXNlUmVuZGVyQnVmZmVyLm5hbWUsIHtcclxuICAgICAgICB2YWx1ZTogUmVuZGVySW5qZWN0b3JDb21wb25lbnRTa2VsZXRvbi51c2VSZW5kZXJCdWZmZXJcclxuICAgICAgfSk7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfY29uc3RydWN0b3IucHJvdG90eXBlLCBfY29uc3RydWN0b3IucHJvdG90eXBlLnVwZGF0ZVJlbmRlckJ1ZmZlci5uYW1lLCB7XHJcbiAgICAgICAgdmFsdWU6IFJlbmRlckluamVjdG9yQ29tcG9uZW50U2tlbGV0b24udXBkYXRlUmVuZGVyQnVmZmVyXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2NvbnN0cnVjdG9yLnByb3RvdHlwZSwgX2NvbnN0cnVjdG9yLnByb3RvdHlwZS5kZWxldGVSZW5kZXJCdWZmZXIubmFtZSwge1xyXG4gICAgICAgIHZhbHVlOiBSZW5kZXJJbmplY3RvckNvbXBvbmVudFNrZWxldG9uLmRlbGV0ZVJlbmRlckJ1ZmZlclxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVzZVJlbmRlckJ1ZmZlcih0aGlzOiBDb21wb25lbnRTa2VsZXRvbik6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG5cclxuICAgICAgaWYgKHRoaXMucmVuZGVyQnVmZmVyKVxyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlckJhc2UoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTklGT1JNX0JVRkZFUiwgVU5JRk9STV9CTE9DSy5TS0lOLkJJTkRJTkcsIHRoaXMucmVuZGVyQnVmZmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVwZGF0ZVJlbmRlckJ1ZmZlcih0aGlzOiBDb21wb25lbnRTa2VsZXRvbik6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLnJlbmRlckJ1ZmZlcikge1xyXG4gICAgICAgIGNvbnN0IGJvbmVzQnl0ZVNpemU6IG51bWJlciA9IDI1NiAqIDE2ICogNDsgLy8gQ0FVVElPTjogdGhpcyBpcyBkZXBlbmRlbnQgb24gdGhlIHNoYWRlciBzb3VyY2UgY29kZSB3aGVyZSAyNTYgaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGJvbmVzXHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyQnVmZmVyID0gUmVuZGVyV2ViR0wuYXNzZXJ0KGNyYzMuY3JlYXRlQnVmZmVyKCkpO1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcik7XHJcbiAgICAgICAgY3JjMy5idWZmZXJEYXRhKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5JRk9STV9CVUZGRVIsIGJvbmVzQnl0ZVNpemUsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFlOQU1JQ19EUkFXKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF0aGlzLm10eEJvbmVzRGF0YSkge1xyXG4gICAgICAgIHRoaXMubXR4Qm9uZXMgPSBuZXcgQXJyYXkodGhpcy5ib25lcy5sZW5ndGgpO1xyXG4gICAgICAgIHRoaXMubXR4Qm9uZXNEYXRhID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmJvbmVzLmxlbmd0aCAqIDE2KTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICB0aGlzLm10eEJvbmVzW2ldID0gbmV3IE1hdHJpeDR4NCh0aGlzLm10eEJvbmVzRGF0YS5zdWJhcnJheShpICogMTYsIGkgKiAxNiArIDE2KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmJvbmVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIE1hdHJpeDR4NC5QUk9EVUNUKHRoaXMuYm9uZXNbaV0ubXR4V29ybGQsIHRoaXMubXR4QmluZEludmVyc2VzW2ldLCB0aGlzLm10eEJvbmVzW2ldKTtcclxuXHJcbiAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlcik7XHJcbiAgICAgIGNyYzMuYnVmZmVyU3ViRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOSUZPUk1fQlVGRkVSLCAwLCB0aGlzLm10eEJvbmVzRGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkZWxldGVSZW5kZXJCdWZmZXIodGhpczogQ29tcG9uZW50U2tlbGV0b24pOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnJlbmRlckJ1ZmZlcilcclxuICAgICAgICBjcmMzLmRlbGV0ZUJ1ZmZlcih0aGlzLnJlbmRlckJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi8uLi9SZW5kZXIvUmVuZGVySW5qZWN0b3JDb21wb25lbnRTa2VsZXRvbi50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEhvbGRzIGFuIGFycmF5IG9mIGJvbmVzICh7QGxpbmsgTm9kZX1zIHdpdGhpbiBhIHtAbGluayBHcmFwaH0pLiBSZWZlcmVuY2VkIGZyb20gYSB7QGxpbmsgQ29tcG9uZW50TWVzaH0gaXQgY2FuIGJlIGFzc29jaWF0ZWQgd2l0aCBhIHtAbGluayBNZXNofSBhbmQgZW5hYmxlIHNraW5uaW5nIGZvciB0aGUgbWVzaC5cclxuICAgKiBAYXV0aG9ycyBNYXR0aGlhcyBSb21pbmcsIEhGVSwgMjAyMi0yMDIzIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXHJcbiAgICovXHJcbiAgQFJlbmRlckluamVjdG9yQ29tcG9uZW50U2tlbGV0b24uZGVjb3JhdGVcclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50U2tlbGV0b24gZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgLyoqIFRoZSBib25lcyB1c2VkIGZvciBza2lubmluZyAqL1xyXG4gICAgcHVibGljIGJvbmVzOiBOb2RlW107XHJcbiAgICAvKiogV2hlbiBhcHBsaWVkIHRvIHZlcnRpY2VzLCBpdCBtb3ZlcyB0aGVtIGZyb20gb2JqZWN0L21vZGVsIHNwYWNlIHRvIGJvbmUtbG9jYWwgc3BhY2UgYXMgaWYgdGhlIGJvbmUgd2VyZSBhdCBpdHMgaW5pdGlhbCBwb3NlICovXHJcbiAgICBwdWJsaWMgbXR4QmluZEludmVyc2VzOiBNYXRyaXg0eDRbXTsgLy8gVE9ETzogdGhpbmsgYWJvdXQgc2VyaWFsaXppbmcgdGhpcyBzZXBhcmF0ZWx5IHRvIG1ha2UgaXQgc2hhcmVhYmxlIGJldHdlZW4gc2tlbGV0b24gc2VyaWFsaXphdGlvbnNcclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyQnVmZmVyOiB1bmtub3duO1xyXG4gICAgcHJvdGVjdGVkIHNpbmdsZXRvbjogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgLyoqIENvbnRhaW5zIHRoZSBib25lIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWNhYmxlIHRvIHRoZSB2ZXJ0aWNlcyBvZiBhIHtAbGluayBNZXNofSAqL1xyXG4gICAgcHJvdGVjdGVkIG10eEJvbmVzOiBNYXRyaXg0eDRbXTtcclxuICAgIHByb3RlY3RlZCBtdHhCb25lc0RhdGE6IEZsb2F0MzJBcnJheTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2JvbmVzOiBOb2RlW10gPSBbXSwgX210eEJvbmVJbnZlcnNlczogTWF0cml4NHg0W10gPSBbXSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmJvbmVzID0gX2JvbmVzO1xyXG4gICAgICB0aGlzLm10eEJpbmRJbnZlcnNlcyA9IF9tdHhCb25lSW52ZXJzZXM7XHJcblxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICh0aGlzLm10eEJpbmRJbnZlcnNlc1tpXSA9PSBudWxsKVxyXG4gICAgICAgICAgdGhpcy5tdHhCaW5kSW52ZXJzZXNbaV0gPSB0aGlzLmJvbmVzW2ldLm10eFdvcmxkSW52ZXJzZS5jbG9uZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yQ29tcG9uZW50U2tlbGV0b259LlxyXG4gICAgICogVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXNlUmVuZGVyQnVmZmVyKCk6IHZvaWQgeyAvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH07XHJcbiAgICAvKipcclxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvckNvbXBvbmVudFNrZWxldG9ufS5cclxuICAgICAqIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZVJlbmRlckJ1ZmZlcigpOiB2b2lkIHsgLyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XHJcbiAgICAvKipcclxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvckNvbXBvbmVudFNrZWxldG9ufS5cclxuICAgICAqIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGRlbGV0ZVJlbmRlckJ1ZmZlcigpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBSZW5kZXJJbmplY3RvciovIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBub2RlIGFzIGEgYm9uZSB3aXRoIGl0cyBiaW5kIGludmVyc2UgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRCb25lKF9ib25lOiBOb2RlLCBfbXR4QmluZEludmVyc2U6IE1hdHJpeDR4NCA9IF9ib25lLm10eFdvcmxkSW52ZXJzZS5jbG9uZSk6IHZvaWQge1xyXG4gICAgICB0aGlzLmJvbmVzLnB1c2goX2JvbmUpO1xyXG4gICAgICB0aGlzLm10eEJpbmRJbnZlcnNlcy5wdXNoKF9tdHhCaW5kSW52ZXJzZSk7XHJcblxyXG4gICAgICB0aGlzLm10eEJvbmVzRGF0YSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBib25lIGluIHRoZSBib25lcyBhcnJheSB3aGljaCBoYXMgdGhlIGdpdmVuIG5hbWUsIGFuZCAtMSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbmRleE9mKF9uYW1lOiBzdHJpbmcpOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIGdpdmVuIGJvbmUgbm9kZSBpbiB0aGUgYm9uZSBhcnJheSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbmRleE9mKF9ub2RlOiBOb2RlKTogbnVtYmVyO1xyXG4gICAgcHVibGljIGluZGV4T2YoX25hbWU6IHN0cmluZyB8IE5vZGUpOiBudW1iZXIge1xyXG4gICAgICBpZiAodHlwZW9mIChfbmFtZSkgPT0gXCJzdHJpbmdcIilcclxuICAgICAgICByZXR1cm4gdGhpcy5ib25lcy5maW5kSW5kZXgoKF9ib25lOiBOb2RlKSA9PiBfYm9uZS5uYW1lID09IF9uYW1lKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHJldHVybiB0aGlzLmJvbmVzLmluZGV4T2YoX25hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBwb3NlIG9mIHRoaXMgc2tlbGV0b24gdG8gdGhlIGRlZmF1bHQgcG9zZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzZXRQb3NlKCk6IHZvaWQgeyAvLyBUT0RPOiB0ZXN0IHRoaXNcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgdGhpcy5ib25lc1tpXS5tdHhMb2NhbC5jb3B5KE1hdHJpeDR4NC5JTlZFUlNFKHRoaXMubXR4QmluZEludmVyc2VzW2ldKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgY29uc3Qgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHt9O1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uYm9uZXMgPSB0aGlzLmJvbmVzLm1hcChfYm9uZSA9PiBOb2RlLlBBVEhfRlJPTV9UTyh0aGlzLCBfYm9uZSkpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLm10eEJpbmRJbnZlcnNlcyA9IFNlcmlhbGl6ZXIuc2VyaWFsaXplQXJyYXkoTWF0cml4NHg0LCB0aGlzLm10eEJpbmRJbnZlcnNlcyk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8Q29tcG9uZW50U2tlbGV0b24+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG5cclxuICAgICAgY29uc3QgaG5kTm9kZURlc2VyaWFsaXplZDogRXZlbnRMaXN0ZW5lclVuaWZpZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5ib25lcyA9IF9zZXJpYWxpemF0aW9uLmJvbmVzLm1hcCgoX3BhdGg6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgbGV0IGJvbmU6IE5vZGUgPSBOb2RlLkZJTkQodGhpcywgX3BhdGgpO1xyXG4gICAgICAgICAgaWYgKCFib25lKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Tm9kZS5uYW1lfSBcIiR7dGhpcy5ub2RlLm5hbWV9XCIgJHtDb21wb25lbnRTa2VsZXRvbi5uYW1lfTogQ291bGQgbm90IGZpbmQgYm9uZSAke19wYXRofWApO1xyXG4gICAgICAgICAgcmV0dXJuIGJvbmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVTRVJJQUxJWkVELCBobmROb2RlRGVzZXJpYWxpemVkKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVTRVJJQUxJWkVELCBobmROb2RlRGVzZXJpYWxpemVkKTtcclxuXHJcbiAgICAgIHRoaXMubXR4QmluZEludmVyc2VzID0gPE1hdHJpeDR4NFtdPmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemVBcnJheShfc2VyaWFsaXphdGlvbi5tdHhCaW5kSW52ZXJzZXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9XHJcblxyXG59IiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnL1BlcmZvcm1hbmNlLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWcvRGVidWdUYXJnZXQudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJEZWJ1Zy9EZWJ1Zy50c1wiLz5cclxuLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCJUaW1lL1RpbWUudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJFdmVudC9FdmVudC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlJlY3ljbGUvUmVjeWNsYWJsZUV2ZW50LnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU2VyaWFsaXphdGlvbi9NdXRhYmxlLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiU2VyaWFsaXphdGlvbi9TZXJpYWxpemVyLnRzXCIvPiBcclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlci9SZW5kZXJXZWJHTC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlJlbmRlci9SZW5kZXJJbmplY3RvclRleHR1cmUudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJHcmFwaC9Ob2RlLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiQ29tcG9uZW50L0NvbXBvbmVudC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlJlY3ljbGUvUmVjeWNhYmxlQXJyYXkudHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJQaHlzaWNzL0hlbHBlcnNQaHlzaWNzLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUGh5c2ljcy9Kb2ludC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlBoeXNpY3MvSm9pbnRBeGlhbC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlNlcmlhbGl6YXRpb24vUHJvamVjdC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIlRleHR1cmUvVGV4dHVyZS50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIk1lc2gvTWVzaC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIk1hdGVyaWFsL01hdGVyaWFsLnRzXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiUGFydGljbGVTeXN0ZW0vUGFydGljbGVTeXN0ZW0udHNcIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJDb21wb25lbnQvQ29tcG9uZW50U2tlbGV0b24udHNcIi8+XHJcblxyXG5cclxuLy9nbG9iYWwgZnVuY3Rpb25zXHJcbmZ1bmN0aW9uIGlmTnVtYmVyKF9jaGVjazogbnVtYmVyLCBfZGVmYXVsdDogbnVtYmVyKTogbnVtYmVyIHtcclxuICByZXR1cm4gdHlwZW9mIF9jaGVjayA9PSBcInVuZGVmaW5lZFwiID8gX2RlZmF1bHQgOiBfY2hlY2s7XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBIb2xkcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgQW5pbWF0aW9uU3RydWN0dXJlIHRoYXQgdGhlIEFuaW1hdGlvbiB1c2VzIHRvIG1hcCB0aGUgU2VxdWVuY2VzIHRvIHRoZSBBdHRyaWJ1dGVzLlxyXG4gICAqIEJ1aWx0IG91dCBvZiBhIHtAbGluayBOb2RlfSdzIHNlcmlhbHNhdGlvbiwgaXQgc3dhcHMgdGhlIHZhbHVlcyB3aXRoIHtAbGluayBBbmltYXRpb25TZXF1ZW5jZU51bWJlcn1zLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uU3RydWN0dXJlIHtcclxuICAgIFthdHRyaWJ1dGU6IHN0cmluZ106IEFuaW1hdGlvblN0cnVjdHVyZVtdIHwgQW5pbWF0aW9uU3RydWN0dXJlIHwgQW5pbWF0aW9uU2VxdWVuY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIEFuIGFzc29jaWF0aXZlIGFycmF5IG1hcHBpbmcgbmFtZXMgb2YgbGFibGVzIHRvIHRpbWVzdGFtcHMuXHJcbiAgKiBMYWJlbHMgbmVlZCB0byBiZSB1bmlxdWUgcGVyIEFuaW1hdGlvbi5cclxuICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uTGFiZWwge1xyXG4gICAgW25hbWU6IHN0cmluZ106IG51bWJlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgQW5pbWF0aW9uIEV2ZW50IFRyaWdnZXJzXHJcbiAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICBbbmFtZTogc3RyaW5nXTogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW50ZXJuYWxseSB1c2VkIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB0aGUgdmFyaW91cyBnZW5lcmF0ZWQgc3RydWN0dXJlcyBhbmQgZXZlbnRzLlxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBlbnVtIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSB7XHJcbiAgICAvKipEZWZhdWx0OiBmb3J3YXJkLCBjb250aW5vdXMgKi9cclxuICAgIE5PUk1BTCxcclxuICAgIC8qKmJhY2t3YXJkLCBjb250aW5vdXMgKi9cclxuICAgIFJFVkVSU0UsXHJcbiAgICAvKipmb3J3YXJkLCByYXN0ZXJlZCAqL1xyXG4gICAgUkFTVEVSRUQsXHJcbiAgICAvKipiYWNrd2FyZCwgcmFzdGVyZWQgKi9cclxuICAgIFJBU1RFUkVEUkVWRVJTRSxcclxuICAgIC8qKiBmb3J3YXJkLCBzYW1wbGVkIGF0IGRpc2NyZXRlIGZyYW1lIHRpbWVzICovXHJcbiAgICBTQU1QTEVEXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIb2xkcyBkaWZmZXJlbnQgcGxheW1vZGVzIHRoZSBhbmltYXRpb24gdXNlcyB0byBwbGF5IGJhY2sgaXRzIGFuaW1hdGlvbi5cclxuICAgKiBAYXV0aG9yIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gQU5JTUFUSU9OX1BMQVlNT0RFIHtcclxuICAgIC8qKlBsYXlzIGFuaW1hdGlvbiBpbiBhIGxvb3A6IGl0IHJlc3RhcnRzIG9uY2UgaXQgaGl0IHRoZSBlbmQuKi9cclxuICAgIExPT1AgPSBcImxvb3BcIixcclxuICAgIC8qKlBsYXlzIGFuaW1hdGlvbiBvbmNlIGFuZCBzdG9wcyBhdCB0aGUgbGFzdCBrZXkvZnJhbWUqL1xyXG4gICAgUExBWV9PTkNFID0gXCJwbGF5T25jZVwiLFxyXG4gICAgLyoqUGxheXMgYW5pbWF0aW9uIG9uY2UgYW5kIHN0b3BzIG9uIHRoZSBmaXJzdCBrZXkvZnJhbWUgKi9cclxuICAgIFBMQVlfT05DRV9SRVNFVCA9IFwicGxheU9uY2VSZXNldFwiLFxyXG4gICAgLyoqUGxheXMgYW5pbWF0aW9uIGxpa2UgTE9PUCwgYnV0IGJhY2t3YXJkcy4qL1xyXG4gICAgUkVWRVJTRV9MT09QID0gXCJyZXZlcnNlTG9vcFwiLFxyXG4gICAgLyoqQ2F1c2VzIHRoZSBhbmltYXRpb24gbm90IHRvIHBsYXkgYXQgYWxsLiBVc2VmdWwgZm9yIGp1bXBpbmcgdG8gdmFyaW91cyBwb3NpdGlvbnMgaW4gdGhlIGFuaW1hdGlvbiB3aXRob3V0IHByb2NlZWRpbmcgaW4gdGhlIGFuaW1hdGlvbi4qL1xyXG4gICAgU1RPUCA9IFwic3RvcFwiXHJcbiAgICAvL1RPRE86IGFkZCBhbiBJTkhFUklUIGFuZCBhIFBJTkdQT05HIG1vZGVcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIEFOSU1BVElPTl9RVUFOVElaQVRJT04ge1xyXG4gICAgLy9UT0RPOiBhZGQgYW4gaW4tZGVwdGggZGVzY3JpcHRpb24gb2Ygd2hhdCBoYXBwZW5zIHRvIHRoZSBhbmltYXRpb24gKGFuZCBldmVudHMpIGRlcGVuZGluZyBvbiB0aGUgcXVhbnRpemF0aW9uLiBVc2UgR3JhcGhzIHRvIGV4cGxhaW4uXHJcbiAgICAvKipDYWxjdWxhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgYW5pbWF0aW9uIGF0IHRoZSBleGFjdCBwb3NpdGlvbiBvZiB0aW1lLiBJZ25vcmVzIEZQUyB2YWx1ZSBvZiBhbmltYXRpb24uKi9cclxuICAgIENPTlRJTk9VUyA9IFwiY29udGlub3VzXCIsXHJcbiAgICAvKipMaW1pdHMgdGhlIGNhbGN1bGF0aW9uIG9mIHRoZSBzdGF0ZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHRoZSBGUFMgdmFsdWUgb2YgdGhlIGFuaW1hdGlvbi4gU2tpcHMgZnJhbWVzIGlmIG5lZWRlZC4qL1xyXG4gICAgRElTQ1JFVEUgPSBcImRpc2NyZXRlXCIsXHJcbiAgICAvKiogQWR2YW5jZXMgdGhlIHRpbWUgZWFjaCBmcmFtZSBhY2NvcmRpbmcgdG8gdGhlIEZQUyB2YWx1ZSBvZiB0aGUgYW5pbWF0aW9uLCBpZ25vcmluZyB0aGUgYWN0dWFsIGR1cmF0aW9uIG9mIHRoZSBmcmFtZXMuIERvZXNuJ3Qgc2tpcCBhbnkgZnJhbWVzLiovXHJcbiAgICBGUkFNRVMgPSBcImZyYW1lc1wiXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgYW5kIGNvbnRyb2xzIGFuZCBhbmltYXRpb24gYnkgeWllbGRpbmcgbXV0YXRvcnMgXHJcbiAgICogYWNjb3JkaW5nIHRvIHRoZSBzdG9yZWQge0BsaW5rIEFuaW1hdGlvblN0cnVjdHVyZX0gYW5kIHtAbGluayBBbmltYXRpb25TZXF1ZW5jZU51bWJlcn1zXHJcbiAgICogQXBwbGllZCB0byBhIHtAbGluayBOb2RlfSBkaXJlY3RseSB2aWEgc2NyaXB0IG9yIHtAbGluayBDb21wb25lbnRBbmltYXRpb259LlxyXG4gICAqIEBhdXRob3JzIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyMyB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNVxyXG4gICAqL1xyXG4gIEBTZXJpYWxpemFibGVSZXNvdXJjZS5yZWdpc3RlclxyXG4gIGV4cG9ydCBjbGFzcyBBbmltYXRpb24gZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgLy8gLyoqIHJlZmVycyBiYWNrIHRvIHRoaXMgY2xhc3MgZnJvbSBhbnkgc3ViY2xhc3MgZS5nLiBpbiBvcmRlciB0byBmaW5kIGNvbXBhdGlibGUgb3RoZXIgcmVzb3VyY2VzKi9cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgYmFzZUNsYXNzOiB0eXBlb2YgQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xyXG4gICAgLy8gLyoqIGxpc3Qgb2YgYWxsIHRoZSBzdWJjbGFzc2VzIGRlcml2ZWQgZnJvbSB0aGlzIGNsYXNzLCBpZiB0aGV5IHJlZ2lzdGVyZWQgcHJvcGVybHkqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBzdWJjbGFzc2VzOiB0eXBlb2YgQW5pbWF0aW9uW10gPSBbXTtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBBbmltYXRpb24ucmVnaXN0ZXJTdWJjbGFzcyhBbmltYXRpb24pO1xyXG4gICAgcHVibGljIGlkUmVzb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmc7XHJcbiAgICBwdWJsaWMgdG90YWxUaW1lOiBudW1iZXIgPSAwOyAvLyBXaHkgaXNuJ3QgdGhpcyBjYWxsZWQgZHVyYXRpb24gb3IgbGVuZ3RoP1xyXG4gICAgcHVibGljIGxhYmVsczogQW5pbWF0aW9uTGFiZWwgPSB7fTsgLy8gYSBsYWJlbCBtYXJrcyBhIHNwZWNpZmljIHRpbWUgdG8gY29udmVuaWVudGx5IGp1bXAgdG8gdXNpbmcgYSB0ZXh0IGlkZW50aWZpZXJcclxuICAgIHB1YmxpYyBzYW1wbGVkOiBib29sZWFuID0gZmFsc2U7IC8vIFRPRE86IGlmIHNldCB0aGUgY2FjaGUgbmVlZHMgdG8gYmUgYWRqdXN0ZWQgKGFuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQpXHJcbiAgICBwdWJsaWMgYW5pbWF0aW9uU3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmU7IC8vIFRPRE86IGlmIHNldCB0aGUgY2FjaGUgbmVlZHMgdG8gYmUgYWRqdXN0ZWQgKGFuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQpXHJcbiAgICBwdWJsaWMgZXZlbnRzOiBBbmltYXRpb25FdmVudFRyaWdnZXIgPSB7fTtcclxuICAgIHByb3RlY3RlZCBmcmFtZXNQZXJTZWNvbmQ6IG51bWJlciA9IDYwOyAvLyBUT0RPOiBjaGFuZ2UgdGhpcyBhbmQgaXRzIGFjY2Vzc29ycyB0byAjZnJhbWVzUGVyU2Vjb25kP1xyXG5cclxuICAgIC8vIHByb2Nlc3NlZCBldmVudGxpc3QgYW5kIGFuaW1hdGlvbiBzdHJ1Y3V0cmVzIGZvciBwbGF5YmFjay5cclxuICAgIHByaXZhdGUgZXZlbnRzUHJvY2Vzc2VkOiBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25FdmVudFRyaWdnZXI+ID0gbmV3IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcj4oKTtcclxuICAgICNhbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkOiBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25TdHJ1Y3R1cmU+ID0gbmV3IE1hcDxBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUsIEFuaW1hdGlvblN0cnVjdHVyZT4oKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IEFuaW1hdGlvbi5uYW1lLCBfYW5pbVN0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlID0ge30sIF9mcHM6IG51bWJlciA9IDYwKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSA9IF9hbmltU3RydWN0dXJlO1xyXG4gICAgICB0aGlzLiNhbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkLnNldChBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuTk9STUFMLCBfYW5pbVN0cnVjdHVyZSk7XHJcbiAgICAgIHRoaXMuZnJhbWVzUGVyU2Vjb25kID0gX2ZwcztcclxuICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBPdmVycmlkZSB0aGUgZ2l2ZW4gYmFzZSBtdXRhdG9yIHdpdGggdGhlIGdpdmVuIG92ZXJyaWRlIG11dGF0b3IgdXNpbmcgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0aGUgdmFsdWVzIHdpdGggdGhlIGdpdmVuIHdlaWdodC5cclxuICAgICAqIFNldCB0aGUgaW50ZXJzZWN0IGZsYWcgdG8gb25seSBpbmNsdWRlIHByb3BlcnRpZXMgaW4gdGhlIHJlc3VsdCB0aGF0IGV4aXN0IGluIGJvdGggb2YgdGhlIGdpdmVuIG11dGF0b3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGJsZW5kT3ZlcnJpZGUoX2Jhc2U6IE11dGF0b3IsIF9vdmVycmlkZTogTXV0YXRvciwgX3dlaWdodDogbnVtYmVyLCBfaW50ZXJzZWN0OiBib29sZWFuID0gZmFsc2UpOiBNdXRhdG9yIHtcclxuICAgICAgcmV0dXJuIEFuaW1hdGlvbi5ibGVuZFJlY3Vyc2l2ZShfYmFzZSwgX292ZXJyaWRlLCAxIC0gX3dlaWdodCwgX3dlaWdodCwgX2ludGVyc2VjdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdGhlIGdpdmVuIGFkZGl0aXZlIG11dGF0b3IgdG8gdGhlIGdpdmVuIGJhc2UgbXV0YXRvci4gVGhlIHZhbHVlcyBvZiB0aGUgYWRkaXRpdmUgbXV0YXRvciB3aWxsIGJlIG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIHdlaWdodC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBibGVuZEFkZGl0aXZlKF9iYXNlOiBNdXRhdG9yLCBfYWRkOiBNdXRhdG9yLCBfd2VpZ2h0OiBudW1iZXIpOiBNdXRhdG9yIHtcclxuICAgICAgcmV0dXJuIEFuaW1hdGlvbi5ibGVuZFJlY3Vyc2l2ZShfYmFzZSwgX2FkZCwgMSwgX3dlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCbGVuZCB0aGUgdHdvIGdpdmVuIG11dGF0b3JzIHRvZ2V0aGVyLCB1c2luZyB0aGUgZ2l2ZW4gd2VpZ2h0cyB0byBkZXRlcm1pbmUgdGhlIGluZmx1ZW5jZSBvZiBlYWNoLiBcclxuICAgICAqIFRoZSByZXN1bHRpbmcgbXV0YXRvciB3aWxsIGNvbnRhaW4gYWxsIHByb3BlcnRpZXMgb2YgdGhlIGJhc2UgbXV0YXRvciwgd2l0aCB0aGUgcHJvcGVydGllcyBvZiB0aGUgYmxlbmQgbXV0YXRvciBibGVuZGVkIGluLlxyXG4gICAgICogQmxlbmQgbXV0YXRvciBwcm9wZXJ0aWVzIHRoYXQgZG9uJ3QgZXhpc3QgaW4gdGhlIGJhc2UgbXV0YXRvciB3aWxsIGJlIGFkZGVkIHRvIHRoZSByZXN1bHQgbXV0YXRvci5cclxuICAgICAqIFNldCB0aGUgaW50ZXJzZWN0IGZsYWcgdG8gb25seSBpbmNsdWRlIHByb3BlcnRpZXMgaW4gdGhlIHJlc3VsdCB0aGF0IGV4aXN0IGluIGJvdGggb2YgdGhlIGdpdmVuIG11dGF0b3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGJsZW5kUmVjdXJzaXZlKF9iYXNlOiBNdXRhdG9yLCBfYmxlbmQ6IE11dGF0b3IsIF93ZWlnaHRCYXNlOiBudW1iZXIsIF93ZWlnaHRCbGVuZDogbnVtYmVyLCBfaW50ZXJzZWN0OiBib29sZWFuID0gZmFsc2UpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBfaW50ZXJzZWN0ID8ge30gOiB7IC4uLl9iYXNlIH07XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBfYmxlbmQpIHtcclxuICAgICAgICBpZiAoX2ludGVyc2VjdCAmJiBfYmFzZVtrZXldID09IHVuZGVmaW5lZClcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIF9ibGVuZFtrZXldID09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgIG11dGF0b3Jba2V5XSA9IChfYmFzZVtrZXldID8/IDApICogX3dlaWdodEJhc2UgKyBfYmxlbmRba2V5XSAqIF93ZWlnaHRCbGVuZDtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBfYmFzZVtrZXldID09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgIGxldCBiYXNlOiBNdXRhdG9yID0gX2Jhc2Vba2V5XTtcclxuICAgICAgICAgIGxldCBibGVuZDogTXV0YXRvciA9IF9ibGVuZFtrZXldO1xyXG4gICAgICAgICAgaWYgKGJhc2UueCAhPSB1bmRlZmluZWQgJiYgYmFzZS55ICE9IHVuZGVmaW5lZCAmJiBiYXNlLnogIT0gdW5kZWZpbmVkICYmIGJhc2UudyAhPSB1bmRlZmluZWQgJiYgUXVhdGVybmlvbi5ET1QoPFF1YXRlcm5pb24+YmFzZSwgPFF1YXRlcm5pb24+YmxlbmQpIDwgMClcclxuICAgICAgICAgICAgUXVhdGVybmlvbi5uZWdhdGUoPFF1YXRlcm5pb24+YmFzZSk7IC8vIFRPRE86IGVsaW1pbmF0ZSB0aGlzIHNpZGUgZWZmZWN0XHJcbiAgICAgICAgICBtdXRhdG9yW2tleV0gPSB0aGlzLmJsZW5kUmVjdXJzaXZlKGJhc2UsIGJsZW5kLCBfd2VpZ2h0QmFzZSwgX3dlaWdodEJsZW5kLCBfaW50ZXJzZWN0KTtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBfYmxlbmRba2V5XSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgbXV0YXRvcltrZXldID0gdGhpcy5ibGVuZFJlY3Vyc2l2ZSh7fSwgX2JsZW5kW2tleV0sIF93ZWlnaHRCYXNlLCBfd2VpZ2h0QmxlbmQsIF9pbnRlcnNlY3QpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHJlZ2lzdGVyU3ViY2xhc3MoX3N1YkNsYXNzOiB0eXBlb2YgQW5pbWF0aW9uKTogbnVtYmVyIHsgcmV0dXJuIEFuaW1hdGlvbi5zdWJjbGFzc2VzLnB1c2goX3N1YkNsYXNzKSAtIDE7IH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGdldExhYmVscygpOiBFbnVtZXJhdG9yIHtcclxuICAgICAgLy9UT0RPOiB0aGlzIGFjdHVhbGx5IG5lZWRzIHRlc3RpbmdcclxuICAgICAgbGV0IGVuOiBFbnVtZXJhdG9yID0gbmV3IEVudW1lcmF0b3IodGhpcy5sYWJlbHMpO1xyXG4gICAgICByZXR1cm4gZW47XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBmcHMoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzUGVyU2Vjb25kO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgZnBzKF9mcHM6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmZyYW1lc1BlclNlY29uZCA9IF9mcHM7XHJcbiAgICAgIHRoaXMuZXZlbnRzUHJvY2Vzc2VkLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgdGhpcyBhbmltYXRpb25zIGNhY2hlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2xlYXJDYWNoZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jYW5pbWF0aW9uU3RydWN0dXJlc1Byb2Nlc3NlZC5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGFuZCByZXR1cm5zIGEge0BsaW5rIE11dGF0b3J9IHdpdGggdGhlIGluZm9ybWF0aW9uIHRvIGFwcGx5IHRvIHRoZSB7QGxpbmsgTm9kZX0gdG8gYW5pbWF0ZVxyXG4gICAgICogaW4gdGhlIHN0YXRlIHRoZSBhbmltYXRpb24gaXMgaW4gYXQgdGhlIGdpdmVuIHRpbWUsIGRpcmVjdGlvbiBhbmQgcXVhbnRpemF0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTdGF0ZShfdGltZTogbnVtYmVyLCBfZGlyZWN0aW9uOiBudW1iZXIsIF9xdWFudGl6YXRpb246IEFOSU1BVElPTl9RVUFOVElaQVRJT04sIF9tdXRhdG9yT3V0OiBNdXRhdG9yID0ge30pOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IGZyYW1lOiBudW1iZXIgPSB0aGlzLnNhbXBsZWQgPyBNYXRoLmZsb29yKF90aW1lICogdGhpcy5mcmFtZXNQZXJTZWNvbmQgLyAxMDAwKSA6IHVuZGVmaW5lZDtcclxuICAgICAgcmV0dXJuIHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JNdXRhdG9yKHRoaXMuZ2V0QW5pbWF0aW9uU3RydWN0dXJlKF9kaXJlY3Rpb24sIF9xdWFudGl6YXRpb24pLCBfdGltZSwgZnJhbWUsIF9tdXRhdG9yT3V0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBuYW1lcyBvZiB0aGUgZXZlbnRzIHRoZSB7QGxpbmsgQ29tcG9uZW50QW5pbWF0aW9ufSBuZWVkcyB0byBmaXJlIGJldHdlZW4gX21pbiBhbmQgX21heCBpbnB1dCB2YWx1ZXMuXHJcbiAgICAgKiBAcGFyYW0gX2RpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRoZSBhbmltYXRpb24gaXMgc3VwcG9zZWQgdG8gcnVuIGluLiA+MCA9PSBmb3J3YXJkLCAwID09IHN0b3AsIDwwID09IGJhY2t3YXJkc1xyXG4gICAgICogQHJldHVybnMgYSBsaXN0IG9mIHN0cmluZ3Mgd2l0aCB0aGUgbmFtZXMgb2YgdGhlIGN1c3RvbSBldmVudHMgdG8gZmlyZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEV2ZW50c1RvRmlyZShfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlciwgX3F1YW50aXphdGlvbjogQU5JTUFUSU9OX1FVQU5USVpBVElPTiwgX2RpcmVjdGlvbjogbnVtYmVyKTogc3RyaW5nW10gfCBudWxsIHtcclxuICAgICAgbGV0IGV2ZW50czogc3RyaW5nW10gPSBbXTtcclxuICAgICAgbGV0IG1pblNlY3Rpb246IG51bWJlciA9IE1hdGguZmxvb3IoX21pbiAvIHRoaXMudG90YWxUaW1lKTtcclxuICAgICAgbGV0IG1heFNlY3Rpb246IG51bWJlciA9IE1hdGguZmxvb3IoX21heCAvIHRoaXMudG90YWxUaW1lKTtcclxuICAgICAgX21pbiA9IF9taW4gJSB0aGlzLnRvdGFsVGltZTtcclxuICAgICAgX21heCA9IF9tYXggJSB0aGlzLnRvdGFsVGltZTtcclxuXHJcbiAgICAgIHdoaWxlIChtaW5TZWN0aW9uIDw9IG1heFNlY3Rpb24pIHtcclxuICAgICAgICBsZXQgZXZlbnRUcmlnZ2VyczogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0gdGhpcy5nZXRDb3JyZWN0RXZlbnRMaXN0KF9kaXJlY3Rpb24sIF9xdWFudGl6YXRpb24pO1xyXG4gICAgICAgIGlmIChtaW5TZWN0aW9uID09IG1heFNlY3Rpb24pIHtcclxuICAgICAgICAgIHRoaXMuYWRkRXZlbnRzQmV0d2VlbihldmVudFRyaWdnZXJzLCBfbWluLCBfbWF4LCBldmVudHMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50c0JldHdlZW4oZXZlbnRUcmlnZ2VycywgX21pbiwgX21heCwgZXZlbnRzKTtcclxuICAgICAgICAgIF9taW4gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtaW5TZWN0aW9uKys7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBldmVudHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIEV2ZW50IHRvIHRoZSBMaXN0IG9mIGV2ZW50cy5cclxuICAgICAqIEBwYXJhbSBfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG5lZWRzIHRvIGJlIHVuaXF1ZSBwZXIgQW5pbWF0aW9uKS5cclxuICAgICAqIEBwYXJhbSBfdGltZSBUaGUgdGltZXN0YW1wIG9mIHRoZSBldmVudCAoaW4gbWlsbGlzZWNvbmRzKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEV2ZW50KF9uYW1lOiBzdHJpbmcsIF90aW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5ldmVudHNbX25hbWVdID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuZXZlbnRzUHJvY2Vzc2VkLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBldmVudCB3aXRoIHRoZSBnaXZlbiBuYW1lIGZyb20gdGhlIGxpc3Qgb2YgZXZlbnRzLlxyXG4gICAgICogQHBhcmFtIF9uYW1lIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlbW92ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUV2ZW50KF9uYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzW19uYW1lXTtcclxuICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIChSZS0pQ2FsY3VsYXRlIHRoZSB0b3RhbCB0aW1lIG9mIHRoZSBBbmltYXRpb24uIENhbGN1bGF0aW9uLWhlYXZ5LCB1c2Ugb25seSBpZiBhY3R1YWxseSBuZWVkZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjYWxjdWxhdGVUb3RhbFRpbWUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudG90YWxUaW1lID0gMDtcclxuICAgICAgdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvclRpbWUodGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUpO1xyXG4gICAgICAvLyBpZiAodGhpcy50b3RhbFRpbWUgPT0gMCkgLy8gYW5pbWF0aW9ucyB3aXRoIG9uZSBrZXlmcmFtZSBuZWVkIGEgdG90YWwgdGltZSAhPSAwIHRvIHdvcmtcclxuICAgICAgLy8gICB0aGlzLnRvdGFsVGltZSA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0aW1lIHRvIHVzZSBmb3IgYW5pbWF0aW9uIHNhbXBsaW5nIHdoZW4gYXBwbHlpbmcgYSBwbGF5bW9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TW9kYWxUaW1lKF90aW1lOiBudW1iZXIsIF9wbGF5bW9kZTogQU5JTUFUSU9OX1BMQVlNT0RFLCBfdGltZVN0b3A6IG51bWJlciA9IF90aW1lKTogbnVtYmVyIHtcclxuICAgICAgc3dpdGNoIChfcGxheW1vZGUpIHtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5TVE9QOlxyXG4gICAgICAgICAgLy8gcmV0dXJuIHRoaXMubG9jYWxUaW1lLmdldE9mZnNldCgpO1xyXG4gICAgICAgICAgcmV0dXJuIF90aW1lU3RvcDtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5QTEFZX09OQ0U6XHJcbiAgICAgICAgICBpZiAoX3RpbWUgPj0gdGhpcy50b3RhbFRpbWUpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZSAtIDAuMDE7ICAgICAvL1RPRE86IHRoaXMgbWlnaHQgY2F1c2Ugc29tZSBpc3N1ZXNcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5QTEFZX09OQ0VfUkVTRVQ6XHJcbiAgICAgICAgICBpZiAoX3RpbWUgPj0gdGhpcy50b3RhbFRpbWUpXHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJldHVybiBfdGltZVN0b3AgaW5zdGVhZD9cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxUaW1lICsgMC4wMTsgICAgIC8vVE9ETzogdGhpcyBtaWdodCBjYXVzZSBzb21lIGlzc3Vlc1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBfdGltZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIGRpcmVjdGlvbiB0aGUgYW5pbWF0aW9uIHNob3VsZCBjdXJyZW50bHkgYmUgcGxheWluZyBpbi5cclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgdGltZSBhdCB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGRpcmVjdGlvblxyXG4gICAgICogQHJldHVybnMgMSBpZiBmb3J3YXJkLCAwIGlmIHN0b3AsIC0xIGlmIGJhY2t3YXJkc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2FsY3VsYXRlRGlyZWN0aW9uKF90aW1lOiBudW1iZXIsIF9wbGF5bW9kZTogQU5JTUFUSU9OX1BMQVlNT0RFKTogbnVtYmVyIHtcclxuICAgICAgc3dpdGNoIChfcGxheW1vZGUpIHtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5TVE9QOlxyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgLy8gY2FzZSBBTklNQVRJT05fUExBWU1PREUuUElOR1BPTkc6XHJcbiAgICAgICAgLy8gICBpZiAoTWF0aC5mbG9vcihfdGltZSAvIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZSkgJSAyID09IDApXHJcbiAgICAgICAgLy8gICAgIHJldHVybiAxO1xyXG4gICAgICAgIC8vICAgZWxzZVxyXG4gICAgICAgIC8vICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fUExBWU1PREUuUkVWRVJTRV9MT09QOlxyXG4gICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1BMQVlNT0RFLlBMQVlfT05DRTpcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9QTEFZTU9ERS5QTEFZX09OQ0VfUkVTRVQ6XHJcbiAgICAgICAgICBpZiAoX3RpbWUgPj0gdGhpcy50b3RhbFRpbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIHRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgczogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBpZFJlc291cmNlOiB0aGlzLmlkUmVzb3VyY2UsXHJcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIGxhYmVsczoge30sXHJcbiAgICAgICAgZXZlbnRzOiB7fSxcclxuICAgICAgICBzYW1wbGVkOiB0aGlzLnNhbXBsZWQsXHJcbiAgICAgICAgZnJhbWVzUGVyU2Vjb25kOiB0aGlzLmZyYW1lc1BlclNlY29uZFxyXG4gICAgICAgIC8vIHNwczogdGhpcy5zdGVwc1BlclNlY29uZFxyXG4gICAgICB9O1xyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMubGFiZWxzKSB7XHJcbiAgICAgICAgcy5sYWJlbHNbbmFtZV0gPSB0aGlzLmxhYmVsc1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuZXZlbnRzKSB7XHJcbiAgICAgICAgcy5ldmVudHNbbmFtZV0gPSB0aGlzLmV2ZW50c1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICBzLmFuaW1hdGlvblN0cnVjdHVyZSA9IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JTZXJpYWxpemF0aW9uKHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlKTtcclxuICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgUHJvamVjdC5yZWdpc3Rlcih0aGlzLCBfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlKTtcclxuICAgICAgdGhpcy5uYW1lID0gX3NlcmlhbGl6YXRpb24ubmFtZTtcclxuICAgICAgdGhpcy5zYW1wbGVkID0gX3NlcmlhbGl6YXRpb24uc2FtcGxlZDtcclxuICAgICAgdGhpcy5mcmFtZXNQZXJTZWNvbmQgPSBfc2VyaWFsaXphdGlvbi5mcmFtZXNQZXJTZWNvbmQ7XHJcbiAgICAgIC8vIHRoaXMuc3RlcHNQZXJTZWNvbmQgPSBfc2VyaWFsaXphdGlvbi5zcHM7XHJcbiAgICAgIHRoaXMubGFiZWxzID0ge307XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX3NlcmlhbGl6YXRpb24ubGFiZWxzKSB7XHJcbiAgICAgICAgdGhpcy5sYWJlbHNbbmFtZV0gPSBfc2VyaWFsaXphdGlvbi5sYWJlbHNbbmFtZV07XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5ldmVudHMgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfc2VyaWFsaXphdGlvbi5ldmVudHMpIHtcclxuICAgICAgICB0aGlzLmV2ZW50c1tuYW1lXSA9IF9zZXJpYWxpemF0aW9uLmV2ZW50c1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmV2ZW50c1Byb2Nlc3NlZCA9IG5ldyBNYXA8QU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLCBBbmltYXRpb25FdmVudFRyaWdnZXI+KCk7XHJcblxyXG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSA9IGF3YWl0IHRoaXMudHJhdmVyc2VTdHJ1Y3R1cmVGb3JEZXNlcmlhbGl6YXRpb24oX3NlcmlhbGl6YXRpb24uYW5pbWF0aW9uU3RydWN0dXJlKTtcclxuXHJcbiAgICAgIHRoaXMuI2FuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQgPSBuZXcgTWFwPEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSwgQW5pbWF0aW9uU3RydWN0dXJlPigpO1xyXG5cclxuICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAvLyAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci50b3RhbFRpbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyBhbiBBbmltYXRpb25TdHJ1Y3R1cmUgYW5kIHJldHVybnMgdGhlIFNlcmlhbGl6YXRpb24gb2Ygc2FpZCBTdHJ1Y3R1cmUuXHJcbiAgICAgKiBAcGFyYW0gX3N0cnVjdHVyZSBUaGUgQW5pbWF0aW9uIFN0cnVjdHVyZSBhdCB0aGUgY3VycmVudCBsZXZlbCB0byB0cmFuc2Zvcm0gaW50byB0aGUgU2VyaWFsaXphdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHRoZSBmaWxsZWQgU2VyaWFsaXphdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB0cmF2ZXJzZVN0cnVjdHVyZUZvclNlcmlhbGl6YXRpb24oX3N0cnVjdHVyZTogT2JqZWN0KTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge307XHJcbiAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gX3N0cnVjdHVyZSkge1xyXG4gICAgICAgIGxldCBzdHJ1Y3R1cmVPclNlcXVlbmNlOiBPYmplY3QgPSAoPEdlbmVyYWw+X3N0cnVjdHVyZSlbcHJvcGVydHldO1xyXG4gICAgICAgIGlmIChzdHJ1Y3R1cmVPclNlcXVlbmNlIGluc3RhbmNlb2YgQW5pbWF0aW9uU2VxdWVuY2UpXHJcbiAgICAgICAgICBzZXJpYWxpemF0aW9uW3Byb3BlcnR5XSA9IHN0cnVjdHVyZU9yU2VxdWVuY2Uuc2VyaWFsaXplKCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgc2VyaWFsaXphdGlvbltwcm9wZXJ0eV0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yU2VyaWFsaXphdGlvbihzdHJ1Y3R1cmVPclNlcXVlbmNlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIGEgU2VyaWFsaXphdGlvbiB0byBjcmVhdGUgYSBuZXcgQW5pbWF0aW9uU3RydWN0dXJlLlxyXG4gICAgICogQHBhcmFtIF9zZXJpYWxpemF0aW9uIFRoZSBzZXJpYWxpemF0aW9uIHRvIHRyYW5zZmVyIGludG8gYW4gQW5pbWF0aW9uU3RydWN0dXJlXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3bHkgY3JlYXRlZCBBbmltYXRpb25TdHJ1Y3R1cmUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JEZXNlcmlhbGl6YXRpb24oX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPEFuaW1hdGlvblN0cnVjdHVyZT4ge1xyXG4gICAgICBsZXQgc3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSB7fTtcclxuICAgICAgZm9yIChsZXQgbiBpbiBfc2VyaWFsaXphdGlvbikge1xyXG4gICAgICAgIGlmIChfc2VyaWFsaXphdGlvbltuXS5hbmltYXRpb25TZXF1ZW5jZSkge1xyXG4gICAgICAgICAgbGV0IGFuaW1TZXE6IEFuaW1hdGlvblNlcXVlbmNlID0gbmV3IEFuaW1hdGlvblNlcXVlbmNlKFtdLCBudWxsKTtcclxuICAgICAgICAgIHN0cnVjdHVyZVtuXSA9IDxBbmltYXRpb25TZXF1ZW5jZT4oYXdhaXQgYW5pbVNlcS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltuXSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHJ1Y3R1cmVbbl0gPSBhd2FpdCB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yRGVzZXJpYWxpemF0aW9uKF9zZXJpYWxpemF0aW9uW25dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHN0cnVjdHVyZTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgYW5kIHJldHVybnMgdGhlIGxpc3Qgb2YgZXZlbnRzIHRvIGJlIHVzZWQgd2l0aCB0aGVzZSBzZXR0aW5ncy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRDb3JyZWN0RXZlbnRMaXN0KF9kaXJlY3Rpb246IG51bWJlciwgX3F1YW50aXphdGlvbjogQU5JTUFUSU9OX1FVQU5USVpBVElPTik6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICAgIGlmIChfcXVhbnRpemF0aW9uICE9IEFOSU1BVElPTl9RVUFOVElaQVRJT04uRlJBTUVTKSB7XHJcbiAgICAgICAgaWYgKF9kaXJlY3Rpb24gPj0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoX2RpcmVjdGlvbiA+PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRFJFVkVSU0UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIGFuIHtAbGluayBBbmltYXRpb25TdHJ1Y3R1cmV9IGFuZCByZXR1cm5zIGEge0BsaW5rIE11dGF0b3J9IGRlc2NyaWJpbmcgdGhlIHN0YXRlIGF0IHRoZSBnaXZlbiB0aW1lLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRyYXZlcnNlU3RydWN0dXJlRm9yTXV0YXRvcihfc3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUsIF90aW1lOiBudW1iZXIsIF9mcmFtZT86IG51bWJlciwgX211dGF0b3JPdXQ6IE11dGF0b3IgPSB7fSk6IE11dGF0b3Ige1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShfc3RydWN0dXJlKSlcclxuICAgICAgICBmb3IgKGxldCBuOiBudW1iZXIgPSAwOyBuIDwgX3N0cnVjdHVyZS5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgICAgaWYgKF9zdHJ1Y3R1cmVbbl0gaW5zdGFuY2VvZiBBbmltYXRpb25TZXF1ZW5jZSlcclxuICAgICAgICAgICAgX211dGF0b3JPdXRbbl0gPSAoPEFuaW1hdGlvblNlcXVlbmNlPl9zdHJ1Y3R1cmVbbl0pLmV2YWx1YXRlKF90aW1lLCBfZnJhbWUsIF9tdXRhdG9yT3V0W25dKTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgX211dGF0b3JPdXRbbl0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTXV0YXRvcig8QW5pbWF0aW9uU3RydWN0dXJlPl9zdHJ1Y3R1cmVbbl0sIF90aW1lLCBfZnJhbWUsIF9tdXRhdG9yT3V0W25dKTtcclxuICAgICAgICB9XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBmb3IgKGxldCBuIGluIF9zdHJ1Y3R1cmUpIHtcclxuICAgICAgICAgIGlmIChfc3RydWN0dXJlW25dIGluc3RhbmNlb2YgQW5pbWF0aW9uU2VxdWVuY2UpXHJcbiAgICAgICAgICAgIF9tdXRhdG9yT3V0W25dID0gKDxBbmltYXRpb25TZXF1ZW5jZT5fc3RydWN0dXJlW25dKS5ldmFsdWF0ZShfdGltZSwgX2ZyYW1lLCBfbXV0YXRvck91dFtuXSk7XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIF9tdXRhdG9yT3V0W25dID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck11dGF0b3IoPEFuaW1hdGlvblN0cnVjdHVyZT5fc3RydWN0dXJlW25dLCBfdGltZSwgX2ZyYW1lLCBfbXV0YXRvck91dFtuXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIF9tdXRhdG9yT3V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSBjdXJyZW50IEFuaW1hdGlvblN0cmN1dHVyZSB0byBmaW5kIHRoZSB0b3RhbFRpbWUgb2YgdGhpcyBhbmltYXRpb24uXHJcbiAgICAgKiBAcGFyYW0gX3N0cnVjdHVyZSBUaGUgc3RydWN0dXJlIHRvIHRyYXZlcnNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdHJhdmVyc2VTdHJ1Y3R1cmVGb3JUaW1lKF9zdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBuIGluIF9zdHJ1Y3R1cmUpIHtcclxuICAgICAgICBpZiAoX3N0cnVjdHVyZVtuXSBpbnN0YW5jZW9mIEFuaW1hdGlvblNlcXVlbmNlKSB7XHJcbiAgICAgICAgICBsZXQgc2VxdWVuY2U6IEFuaW1hdGlvblNlcXVlbmNlID0gPEFuaW1hdGlvblNlcXVlbmNlPl9zdHJ1Y3R1cmVbbl07XHJcbiAgICAgICAgICBpZiAoc2VxdWVuY2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgc2VxdWVuY2VUaW1lOiBudW1iZXIgPSBzZXF1ZW5jZS5nZXRLZXkoc2VxdWVuY2UubGVuZ3RoIC0gMSkudGltZTtcclxuICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgPSBNYXRoLm1heChzZXF1ZW5jZVRpbWUsIHRoaXMudG90YWxUaW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvclRpbWUoPEFuaW1hdGlvblN0cnVjdHVyZT5fc3RydWN0dXJlW25dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldEFuaW1hdGlvblN0cnVjdHVyZShfZGlyZWN0aW9uOiBudW1iZXIsIF9xdWFudGl6YXRpb246IEFOSU1BVElPTl9RVUFOVElaQVRJT04pOiBBbmltYXRpb25TdHJ1Y3R1cmUge1xyXG4gICAgICBsZXQgYW5pbWF0aW9uU3RydWN0dXJlOiBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEU7XHJcblxyXG4gICAgICBpZiAoX3F1YW50aXphdGlvbiA9PSBBTklNQVRJT05fUVVBTlRJWkFUSU9OLkNPTlRJTk9VUylcclxuICAgICAgICBpZiAodGhpcy5zYW1wbGVkKVxyXG4gICAgICAgICAgYW5pbWF0aW9uU3RydWN0dXJlID0gQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlNBTVBMRUQ7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgYW5pbWF0aW9uU3RydWN0dXJlID0gX2RpcmVjdGlvbiA8IDAgPyBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRSA6IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUw7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBhbmltYXRpb25TdHJ1Y3R1cmUgPSBfZGlyZWN0aW9uIDwgMCA/IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRFJFVkVSU0UgOiBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRUQ7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5nZXRQcm9jZXNzZWRBbmltYXRpb25TdHJ1Y3R1cmUoYW5pbWF0aW9uU3RydWN0dXJlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGV4aXN0YW5jZSBvZiB0aGUgcmVxdWVzdGVkIHtAbGluayBBbmltYXRpb25TdHJ1Y3R1cmV9IGFuZCByZXR1cm5zIGl0LlxyXG4gICAgICogQHBhcmFtIF90eXBlIHRoZSB0eXBlIG9mIHRoZSBzdHJ1Y3R1cmUgdG8gZ2V0XHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVxdWVzdGVkIFtbQGxpbmsgQW5pbWF0aW9uU3RydWN0dXJlXV1cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRQcm9jZXNzZWRBbmltYXRpb25TdHJ1Y3R1cmUoX3R5cGU6IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSk6IEFuaW1hdGlvblN0cnVjdHVyZSB7XHJcbiAgICAgIGxldCBwcm9jZXNzZWQ6IEFuaW1hdGlvblN0cnVjdHVyZSA9IHRoaXMuI2FuaW1hdGlvblN0cnVjdHVyZXNQcm9jZXNzZWQuZ2V0KF90eXBlKTtcclxuICAgICAgaWYgKHByb2Nlc3NlZClcclxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkO1xyXG5cclxuICAgICAgdGhpcy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuICAgICAgcHJvY2Vzc2VkID0ge307XHJcbiAgICAgIHN3aXRjaCAoX3R5cGUpIHtcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5OT1JNQUw6XHJcbiAgICAgICAgICBwcm9jZXNzZWQgPSB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJFVkVSU0U6XHJcbiAgICAgICAgICBwcm9jZXNzZWQgPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTmV3U3RydWN0dXJlKHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlLCB0aGlzLmNhbGN1bGF0ZVJldmVyc2VTZXF1ZW5jZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEOlxyXG4gICAgICAgICAgcHJvY2Vzc2VkID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck5ld1N0cnVjdHVyZSh0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSwgdGhpcy5jYWxjdWxhdGVSYXN0ZXJlZFNlcXVlbmNlLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkFTVEVSRURSRVZFUlNFOlxyXG4gICAgICAgICAgcHJvY2Vzc2VkID0gdGhpcy50cmF2ZXJzZVN0cnVjdHVyZUZvck5ld1N0cnVjdHVyZSh0aGlzLmdldFByb2Nlc3NlZEFuaW1hdGlvblN0cnVjdHVyZShBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuUkVWRVJTRSksIHRoaXMuY2FsY3VsYXRlUmFzdGVyZWRTZXF1ZW5jZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlNBTVBMRUQ6XHJcbiAgICAgICAgICBwcm9jZXNzZWQgPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTmV3U3RydWN0dXJlKHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlLCB0aGlzLmNhbGN1bGF0ZVNhbXBsZWRTZXF1ZW5jZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLiNhbmltYXRpb25TdHJ1Y3R1cmVzUHJvY2Vzc2VkLnNldChfdHlwZSwgcHJvY2Vzc2VkKTtcclxuICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGV4aXN0YW5jZSBvZiB0aGUgcmVxdWVzdGVkIHtAbGluayBBbmltYXRpb25FdmVudFRyaWdnZXJ9IGFuZCByZXR1cm5zIGl0LlxyXG4gICAgICogQHBhcmFtIF90eXBlIFRoZSB0eXBlIG9mIEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB0byBnZXRcclxuICAgICAqIEByZXR1cm5zIHRoZSByZXF1ZXN0ZWQge0BsaW5rIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcn1cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRQcm9jZXNzZWRFdmVudFRyaWdnZXIoX3R5cGU6IEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRSk6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICAgIGxldCBwcm9jZXNzZWQ6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciA9IHRoaXMuZXZlbnRzUHJvY2Vzc2VkLmdldChfdHlwZSk7XHJcbiAgICAgIGlmIChwcm9jZXNzZWQpXHJcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcclxuXHJcbiAgICAgIHRoaXMuY2FsY3VsYXRlVG90YWxUaW1lKCk7XHJcbiAgICAgIHByb2Nlc3NlZCA9IHt9O1xyXG4gICAgICBzd2l0Y2ggKF90eXBlKSB7XHJcbiAgICAgICAgY2FzZSBBTklNQVRJT05fU1RSVUNUVVJFX1RZUEUuTk9STUFMOlxyXG4gICAgICAgICAgcHJvY2Vzc2VkID0gdGhpcy5ldmVudHM7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFOlxyXG4gICAgICAgICAgcHJvY2Vzc2VkID0gdGhpcy5jYWxjdWxhdGVSZXZlcnNlRXZlbnRUcmlnZ2Vycyh0aGlzLmV2ZW50cyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SQVNURVJFRDpcclxuICAgICAgICAgIHByb2Nlc3NlZCA9IHRoaXMuY2FsY3VsYXRlUmFzdGVyZWRFdmVudFRyaWdnZXJzKHRoaXMuZXZlbnRzKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUUlVDVFVSRV9UWVBFLlJBU1RFUkVEUkVWRVJTRTpcclxuICAgICAgICAgIHByb2Nlc3NlZCA9IHRoaXMuY2FsY3VsYXRlUmFzdGVyZWRFdmVudFRyaWdnZXJzKHRoaXMuZ2V0UHJvY2Vzc2VkRXZlbnRUcmlnZ2VyKEFOSU1BVElPTl9TVFJVQ1RVUkVfVFlQRS5SRVZFUlNFKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5ldmVudHNQcm9jZXNzZWQuc2V0KF90eXBlLCBwcm9jZXNzZWQpO1xyXG5cclxuICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyBhbiBleGlzdGluZyBzdHJ1Y3R1cmUgdG8gYXBwbHkgYSByZWNhbGN1bGF0aW9uIGZ1bmN0aW9uIHRvIHRoZSBBbmltYXRpb25TdHJ1Y3R1cmUgdG8gc3RvcmUgaW4gYSBuZXcgU3RydWN0dXJlLlxyXG4gICAgICogQHBhcmFtIF9vbGRTdHJ1Y3R1cmUgVGhlIG9sZCBzdHJ1Y3R1cmUgdG8gdHJhdmVyc2VcclxuICAgICAqIEBwYXJhbSBfZnVuY3Rpb25Ub1VzZSBUaGUgZnVuY3Rpb24gdG8gdXNlIHRvIHJlY2FsY3VsYXRlZCB0aGUgc3RydWN0dXJlLlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgQW5pbWF0aW9uIFN0cnVjdHVyZSB3aXRoIHRoZSByZWNhbHVsYXRlZCBBbmltYXRpb24gU2VxdWVuY2VzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRyYXZlcnNlU3RydWN0dXJlRm9yTmV3U3RydWN0dXJlKF9vbGRTdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSwgX2Z1bmN0aW9uVG9Vc2U6IEZ1bmN0aW9uKTogQW5pbWF0aW9uU3RydWN0dXJlIHtcclxuICAgICAgbGV0IG5ld1N0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlID0ge307XHJcbiAgICAgIGZvciAobGV0IG4gaW4gX29sZFN0cnVjdHVyZSkge1xyXG4gICAgICAgIGlmIChfb2xkU3RydWN0dXJlW25dIGluc3RhbmNlb2YgQW5pbWF0aW9uU2VxdWVuY2UpIHtcclxuICAgICAgICAgIG5ld1N0cnVjdHVyZVtuXSA9IF9mdW5jdGlvblRvVXNlKF9vbGRTdHJ1Y3R1cmVbbl0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdTdHJ1Y3R1cmVbbl0gPSB0aGlzLnRyYXZlcnNlU3RydWN0dXJlRm9yTmV3U3RydWN0dXJlKDxBbmltYXRpb25TdHJ1Y3R1cmU+X29sZFN0cnVjdHVyZVtuXSwgX2Z1bmN0aW9uVG9Vc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3U3RydWN0dXJlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHJldmVyc2VkIEFuaW1hdGlvbiBTZXF1ZW5jZSBvdXQgb2YgYSBnaXZlbiBTZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSBfc2VxdWVuY2UgVGhlIHNlcXVlbmNlIHRvIGNhbGN1bGF0ZSB0aGUgbmV3IHNlcXVlbmNlIG91dCBvZlxyXG4gICAgICogQHJldHVybnMgVGhlIHJldmVyc2VkIFNlcXVlbmNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlUmV2ZXJzZVNlcXVlbmNlKF9zZXF1ZW5jZTogQW5pbWF0aW9uU2VxdWVuY2UpOiBBbmltYXRpb25TZXF1ZW5jZSB7XHJcbiAgICAgIGxldCBrZXlzOiBBbmltYXRpb25LZXlbXSA9IG5ldyBBcnJheShfc2VxdWVuY2UubGVuZ3RoKTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF9zZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBvbGRLZXk6IEFuaW1hdGlvbktleSA9IF9zZXF1ZW5jZS5nZXRLZXkoaSk7XHJcbiAgICAgICAga2V5c1tpXSA9IG5ldyBBbmltYXRpb25LZXkodGhpcy50b3RhbFRpbWUgLSBvbGRLZXkudGltZSwgb2xkS2V5LnZhbHVlLCBvbGRLZXkuaW50ZXJwb2xhdGlvbiwgb2xkS2V5LnNsb3BlT3V0LCBvbGRLZXkuc2xvcGVJbik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25TZXF1ZW5jZShrZXlzLCBfc2VxdWVuY2UuY2xhc3NUeXBlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSByYXN0ZXJlZCB7QGxpbmsgQW5pbWF0aW9uU2VxdWVuY2VOdW1iZXJ9IG91dCBvZiBhIGdpdmVuIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIF9zZXF1ZW5jZSBUaGUgc2VxdWVuY2UgdG8gY2FsY3VsYXRlIHRoZSBuZXcgc2VxdWVuY2Ugb3V0IG9mXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmFzdGVyZWQgc2VxdWVuY2UuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlUmFzdGVyZWRTZXF1ZW5jZShfc2VxdWVuY2U6IEFuaW1hdGlvblNlcXVlbmNlKTogQW5pbWF0aW9uU2VxdWVuY2Uge1xyXG4gICAgICBsZXQga2V5czogQW5pbWF0aW9uS2V5W10gPSBbXTtcclxuICAgICAgbGV0IGZyYW1lVGltZTogbnVtYmVyID0gMTAwMCAvIHRoaXMuZnJhbWVzUGVyU2Vjb25kO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy50b3RhbFRpbWU7IGkgKz0gZnJhbWVUaW1lKVxyXG4gICAgICAgIGtleXMucHVzaChuZXcgQW5pbWF0aW9uS2V5KGksIF9zZXF1ZW5jZS5ldmFsdWF0ZShpKSwgQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04uQ09OU1RBTlQpKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uU2VxdWVuY2Uoa2V5cywgX3NlcXVlbmNlLmNsYXNzVHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEge0BsaW5rIEFuaW1hdGlvblNlcXVlbmNlU2FtcGxlZH0gb3V0IG9mIGEgZ2l2ZW4gc2VxdWVuY2UuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlU2FtcGxlZFNlcXVlbmNlKF9zZXF1ZW5jZTogQW5pbWF0aW9uU2VxdWVuY2UpOiBBbmltYXRpb25TZXF1ZW5jZVNhbXBsZWQge1xyXG4gICAgICBjb25zdCBmcmFtZVRpbWU6IG51bWJlciA9IDEwMDAgLyB0aGlzLmZyYW1lc1BlclNlY29uZDtcclxuICAgICAgY29uc3QgbkZyYW1lczogbnVtYmVyID0gTWF0aC5jZWlsKHRoaXMudG90YWxUaW1lIC8gZnJhbWVUaW1lKTtcclxuXHJcbiAgICAgIGxldCBrZXlzT3JpZ2luYWw6IEFuaW1hdGlvbktleVtdID0gX3NlcXVlbmNlLmdldEtleXMoKTtcclxuICAgICAgbGV0IGtleXNTYW1wbGVkOiBBbmltYXRpb25LZXlbXSA9IG5ldyBBcnJheShuRnJhbWVzICsgMSk7XHJcblxyXG4gICAgICBmb3IgKGxldCBpU2FtcGxlZDogbnVtYmVyID0gMCwgaU9yaWdpbmFsOiBudW1iZXIgPSAwLCB0aW1lOiBudW1iZXIgPSAwOyBpU2FtcGxlZCA8PSBuRnJhbWVzOyBpU2FtcGxlZCsrLCB0aW1lICs9IGZyYW1lVGltZSkge1xyXG4gICAgICAgIHdoaWxlIChpT3JpZ2luYWwgPCBrZXlzT3JpZ2luYWwubGVuZ3RoIC0gMSAmJiBrZXlzT3JpZ2luYWxbaU9yaWdpbmFsICsgMV0udGltZSA8PSB0aW1lICsgMWUtMylcclxuICAgICAgICAgIGlPcmlnaW5hbCsrO1xyXG5cclxuICAgICAgICBrZXlzU2FtcGxlZFtpU2FtcGxlZF0gPSBrZXlzT3JpZ2luYWxbaU9yaWdpbmFsXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25TZXF1ZW5jZVNhbXBsZWQoa2V5c1NhbXBsZWQsIF9zZXF1ZW5jZS5jbGFzc1R5cGUpOztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmV2ZXJzZWQge0BsaW5rIEFuaW1hdGlvbkV2ZW50VHJpZ2dlcn0gb2JqZWN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvbmUuICBcclxuICAgICAqIEBwYXJhbSBfZXZlbnRzIHRoZSBldmVudCBvYmplY3QgdG8gY2FsY3VsYXRlIHRoZSBuZXcgb25lIG91dCBvZlxyXG4gICAgICogQHJldHVybnMgdGhlIHJldmVyc2VkIGV2ZW50IG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNhbGN1bGF0ZVJldmVyc2VFdmVudFRyaWdnZXJzKF9ldmVudHM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlcik6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICAgIGxldCBhZTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0ge307XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX2V2ZW50cykge1xyXG4gICAgICAgIGFlW25hbWVdID0gdGhpcy50b3RhbFRpbWUgLSBfZXZlbnRzW25hbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSByYXN0ZXJlZCB7QGxpbmsgQW5pbWF0aW9uRXZlbnRUcmlnZ2VyfSBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIG9uZS4gIFxyXG4gICAgICogQHBhcmFtIF9ldmVudHMgdGhlIGV2ZW50IG9iamVjdCB0byBjYWxjdWxhdGUgdGhlIG5ldyBvbmUgb3V0IG9mXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmFzdGVyZWQgZXZlbnQgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlUmFzdGVyZWRFdmVudFRyaWdnZXJzKF9ldmVudHM6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlcik6IEFuaW1hdGlvbkV2ZW50VHJpZ2dlciB7XHJcbiAgICAgIGxldCBhZTogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyID0ge307XHJcbiAgICAgIGxldCBmcmFtZVRpbWU6IG51bWJlciA9IDEwMDAgLyB0aGlzLmZyYW1lc1BlclNlY29uZDtcclxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBfZXZlbnRzKSB7XHJcbiAgICAgICAgYWVbbmFtZV0gPSBfZXZlbnRzW25hbWVdIC0gKF9ldmVudHNbbmFtZV0gJSBmcmFtZVRpbWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGljaCBldmVudHMgbGF5IGJldHdlZW4gdHdvIGdpdmVuIHRpbWVzIGFuZCByZXR1cm5zIHRoZSBuYW1lcyBvZiB0aGUgb25lcyB0aGF0IGRvLlxyXG4gICAgICogQHBhcmFtIF9ldmVudFRyaWdnZXJzIFRoZSBldmVudCBvYmplY3QgdG8gY2hlY2sgdGhlIGV2ZW50cyBpbnNpZGUgb2YuXHJcbiAgICAgKiBAcGFyYW0gX21pbiB0aGUgbWluaW11bSBvZiB0aGUgcmFuZ2UgdG8gY2hlY2sgYmV0d2VlbiAoaW5jbHVzaXZlKS5cclxuICAgICAqIEBwYXJhbSBfbWF4IHRoZSBtYXhpbXVtIG9mIHRoZSByYW5nZSB0byBjaGVjayBiZXR3ZWVuIChleGNsdXNpdmUpLlxyXG4gICAgICogQHBhcmFtIF9ldmVudHMgdGhlIGFycmF5IHRvIGFkZCB0aGUgbmFtZXMgb2YgdGhlIGV2ZW50cyB0by5cclxuICAgICAqIEByZXR1cm5zIGFuIGdpdmVuIGFycmF5IG9mIHRoZSBldmVudHMgYXBwZW5kZWQgd2l0aCB0aGUgZXZlbnRzIGluIHRoZSBnaXZlbiByYW5nZS4gXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYWRkRXZlbnRzQmV0d2VlbihfZXZlbnRUcmlnZ2VyczogQW5pbWF0aW9uRXZlbnRUcmlnZ2VyLCBfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlciwgX2V2ZW50czogc3RyaW5nW10pOiBzdHJpbmdbXSB7XHJcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gX2V2ZW50VHJpZ2dlcnMpIHtcclxuICAgICAgICBpZiAoX21pbiA8PSBfZXZlbnRUcmlnZ2Vyc1tuYW1lXSAmJiBfZXZlbnRUcmlnZ2Vyc1tuYW1lXSA8IF9tYXgpIHtcclxuICAgICAgICAgIF9ldmVudHMucHVzaChuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIF9ldmVudHM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIHZhbHVlcyBiZXR3ZWVuIHtAbGluayBBbmltYXRpb25LZXlOdW1iZXJ9cy5cclxuICAgKiBSZXByZXNlbnRlZCBpbnRlcm5hbGx5IGJ5IGEgY3ViaWMgZnVuY3Rpb24gKGBmKHgpID0gYXjCsyArIGJ4wrIgKyBjeCArIGRgKS4gXHJcbiAgICogT25seSBuZWVkcyB0byBiZSByZWNhbGN1bGF0ZWQgd2hlbiB0aGUga2V5cyBjaGFuZ2UsIHNvIGF0IHJ1bnRpbWUgaXQgc2hvdWxkIG9ubHkgYmUgY2FsY3VsYXRlZCBvbmNlLlxyXG4gICAqIEBhdXRob3JzIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5IHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDI1XHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFuaW1hdGlvbkZ1bmN0aW9uPFQgZXh0ZW5kcyBBbmltYXRpb25SZXR1cm5UeXBlID0gQW5pbWF0aW9uUmV0dXJuVHlwZT4ge1xyXG4gICAgcHJvdGVjdGVkIGE6IFQ7XHJcbiAgICBwcm90ZWN0ZWQgYjogVDtcclxuICAgIHByb3RlY3RlZCBjOiBUO1xyXG4gICAgcHJvdGVjdGVkIGQ6IFQ7XHJcblxyXG4gICAgLy8gVE9ETzogdGhpbmsgYWJvdXQgcmVtb3ZpbmcgdGhlc2UgYXMgaW4gbW9zdCBjYXNlcyBjaGFuZ2VzIHRvIGFueSBrZXkgZW50YWlsIGEgcmVjYWxjdWxhdGlvbiBvZiB0aGUgd2hvbGUgc2VxdWVuY2UgaS5lLiBhbGwgZnVuY3Rpb25zIGhhdmUgdG8gYmUgcmVjcmVhdGVkXHJcbiAgICAvLyBvciBtYXliZSBtZXJnZSBmdW5jdGlvbiBhbmQga2V5IGludG8gb25lIGNsYXNzP1xyXG4gICAgcHJvdGVjdGVkIGtleUluOiBBbmltYXRpb25LZXk8VD47XHJcbiAgICBwcm90ZWN0ZWQga2V5T3V0OiBBbmltYXRpb25LZXk8VD47XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9rZXlJbjogQW5pbWF0aW9uS2V5PFQ+LCBfa2V5T3V0OiBBbmltYXRpb25LZXk8VD4gPSBudWxsKSB7XHJcbiAgICAgIHRoaXMua2V5SW4gPSBfa2V5SW47XHJcbiAgICAgIHRoaXMua2V5T3V0ID0gX2tleU91dDtcclxuICAgICAgdGhpcy5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBhcmFtZXRlciB2YWx1ZXMgb2YgdGhpcyBjdWJpYyBmdW5jdGlvbi4gYGYoeCkgPSBheMKzICsgYnjCsiArIGN4ICsgZGBcclxuICAgICAqIFVzZWQgYnkgZWRpdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UGFyYW1ldGVycygpOiB7IGE6IFQ7IGI6IFQ7IGM6IFQ7IGQ6IFQgfSB7XHJcbiAgICAgIHJldHVybiB7IGE6IHRoaXMuYSwgYjogdGhpcy5iLCBjOiB0aGlzLmMsIGQ6IHRoaXMuZCB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIGF0IHRoZSBnaXZlbiB0aW1lLlxyXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSBwb2ludCBpbiB0aW1lIGF0IHdoaWNoIHRvIGV2YWx1YXRlIHRoZSBmdW5jdGlvbiBpbiBtaWxsaXNlY29uZHMuIFdpbGwgYmUgY29ycmVjdGVkIGZvciBvZmZzZXQgaW50ZXJuYWxseS5cclxuICAgICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZXZhbHVhdGUoX3RpbWU6IG51bWJlciwgX211dGF0b3JPdXQ6IEFuaW1hdGlvblJldHVyblR5cGUpOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogKFJlLSlDYWxjdWxhdGVzIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBjdWJpYyBmdW5jdGlvbi5cclxuICAgICAqIFNlZSBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzMxNzM0NjkvY2FsY3VsYXRlLWN1YmljLWVxdWF0aW9uLWZyb20tdHdvLXBvaW50cy1hbmQtdHdvLXNsb3Blcy12YXJpYWJseVxyXG4gICAgICogYW5kIGh0dHBzOi8vamlya2FkZWxsb3JvLmdpdGh1Yi5pby9GVURHRS9Eb2N1bWVudGF0aW9uL0xvZ3MvMTkwNDEwX05vdGl6ZW5fTFNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGNhbGN1bGF0ZSgpOiB2b2lkO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvbkZ1bmN0aW9uTnVtYmVyIGV4dGVuZHMgQW5pbWF0aW9uRnVuY3Rpb248bnVtYmVyPiB7XHJcbiAgICBwdWJsaWMgZXZhbHVhdGUoX3RpbWU6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIF90aW1lIC09IHRoaXMua2V5SW4udGltZTtcclxuICAgICAgbGV0IHRpbWUyOiBudW1iZXIgPSBfdGltZSAqIF90aW1lO1xyXG4gICAgICBsZXQgdGltZTM6IG51bWJlciA9IHRpbWUyICogX3RpbWU7XHJcbiAgICAgIHJldHVybiB0aGlzLmEgKiB0aW1lMyArIHRoaXMuYiAqIHRpbWUyICsgdGhpcy5jICogX3RpbWUgKyB0aGlzLmQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNhbGN1bGF0ZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5kID0gdGhpcy5jID0gdGhpcy5iID0gdGhpcy5hID0gMDtcclxuXHJcbiAgICAgIGlmICghdGhpcy5rZXlJbilcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICB0aGlzLmQgPSB0aGlzLmtleUluLnZhbHVlO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLmtleU91dCB8fCB0aGlzLmtleUluLmludGVycG9sYXRpb24gPT0gQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04uQ09OU1RBTlQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IHgxOiBudW1iZXIgPSB0aGlzLmtleU91dC50aW1lIC0gdGhpcy5rZXlJbi50aW1lO1xyXG5cclxuICAgICAgaWYgKHRoaXMua2V5SW4uaW50ZXJwb2xhdGlvbiA9PSBBTklNQVRJT05fSU5URVJQT0xBVElPTi5MSU5FQVIpIHtcclxuICAgICAgICB0aGlzLmMgPSAodGhpcy5rZXlPdXQudmFsdWUgLSB0aGlzLmtleUluLnZhbHVlKSAvIHgxO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5jID0gdGhpcy5rZXlJbi5zbG9wZU91dDtcclxuICAgICAgdGhpcy5hID0gKC14MSAqICh0aGlzLmtleUluLnNsb3BlT3V0ICsgdGhpcy5rZXlPdXQuc2xvcGVJbikgLSAyICogdGhpcy5rZXlJbi52YWx1ZSArIDIgKiB0aGlzLmtleU91dC52YWx1ZSkgLyAtTWF0aC5wb3coeDEsIDMpO1xyXG4gICAgICB0aGlzLmIgPSAodGhpcy5rZXlPdXQuc2xvcGVJbiAtIHRoaXMua2V5SW4uc2xvcGVPdXQgLSAzICogdGhpcy5hICogTWF0aC5wb3coeDEsIDIpKSAvICgyICogeDEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvbkZ1bmN0aW9uVmVjdG9yMyBleHRlbmRzIEFuaW1hdGlvbkZ1bmN0aW9uPE11dGF0b3JWZWN0b3IzPiB7XHJcbiAgICBwdWJsaWMgb3ZlcnJpZGUgZXZhbHVhdGUoX3RpbWU6IG51bWJlciwgX291dDogTXV0YXRvclZlY3RvcjMgPSB7fSk6IE11dGF0b3JWZWN0b3IzIHtcclxuICAgICAgX3RpbWUgLT0gdGhpcy5rZXlJbi50aW1lO1xyXG4gICAgICBsZXQgdGltZTI6IG51bWJlciA9IF90aW1lICogX3RpbWU7XHJcbiAgICAgIGxldCB0aW1lMzogbnVtYmVyID0gdGltZTIgKiBfdGltZTtcclxuXHJcbiAgICAgIF9vdXQueCA9IHRoaXMuYS54ICogdGltZTMgKyB0aGlzLmIueCAqIHRpbWUyICsgdGhpcy5jLnggKiBfdGltZSArIHRoaXMuZC54O1xyXG4gICAgICBfb3V0LnkgPSB0aGlzLmEueSAqIHRpbWUzICsgdGhpcy5iLnkgKiB0aW1lMiArIHRoaXMuYy55ICogX3RpbWUgKyB0aGlzLmQueTtcclxuICAgICAgX291dC56ID0gdGhpcy5hLnogKiB0aW1lMyArIHRoaXMuYi56ICogdGltZTIgKyB0aGlzLmMueiAqIF90aW1lICsgdGhpcy5kLno7XHJcbiAgICAgIHJldHVybiBfb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjYWxjdWxhdGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuYSA9IHsgeDogMCwgeTogMCwgejogMCB9O1xyXG4gICAgICB0aGlzLmIgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcclxuICAgICAgdGhpcy5jID0geyB4OiAwLCB5OiAwLCB6OiAwIH07XHJcbiAgICAgIHRoaXMuZCA9IHsgeDogMCwgeTogMCwgejogMCB9O1xyXG5cclxuICAgICAgaWYgKCF0aGlzLmtleUluKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5kLCB0aGlzLmtleUluLnZhbHVlKTtcclxuXHJcbiAgICAgIGlmICghdGhpcy5rZXlPdXQgfHwgdGhpcy5rZXlJbi5pbnRlcnBvbGF0aW9uID09IEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkNPTlNUQU5UKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCB4MTogbnVtYmVyID0gdGhpcy5rZXlPdXQudGltZSAtIHRoaXMua2V5SW4udGltZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmtleUluLmludGVycG9sYXRpb24gPT0gQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04uTElORUFSKSB7XHJcbiAgICAgICAgdGhpcy5jLnggPSAodGhpcy5rZXlPdXQudmFsdWUueCAtIHRoaXMua2V5SW4udmFsdWUueCkgLyB4MTtcclxuICAgICAgICB0aGlzLmMueSA9ICh0aGlzLmtleU91dC52YWx1ZS55IC0gdGhpcy5rZXlJbi52YWx1ZS55KSAvIHgxO1xyXG4gICAgICAgIHRoaXMuYy56ID0gKHRoaXMua2V5T3V0LnZhbHVlLnogLSB0aGlzLmtleUluLnZhbHVlLnopIC8geDE7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmMsIHRoaXMua2V5SW4uc2xvcGVPdXQpO1xyXG5cclxuICAgICAgdGhpcy5hLnggPSAoLXgxICogKHRoaXMua2V5SW4uc2xvcGVPdXQueCArIHRoaXMua2V5T3V0LnNsb3BlSW4ueCkgLSAyICogdGhpcy5rZXlJbi52YWx1ZS54ICsgMiAqIHRoaXMua2V5T3V0LnZhbHVlLngpIC8gLU1hdGgucG93KHgxLCAzKTtcclxuICAgICAgdGhpcy5hLnkgPSAoLXgxICogKHRoaXMua2V5SW4uc2xvcGVPdXQueSArIHRoaXMua2V5T3V0LnNsb3BlSW4ueSkgLSAyICogdGhpcy5rZXlJbi52YWx1ZS55ICsgMiAqIHRoaXMua2V5T3V0LnZhbHVlLnkpIC8gLU1hdGgucG93KHgxLCAzKTtcclxuICAgICAgdGhpcy5hLnogPSAoLXgxICogKHRoaXMua2V5SW4uc2xvcGVPdXQueiArIHRoaXMua2V5T3V0LnNsb3BlSW4ueikgLSAyICogdGhpcy5rZXlJbi52YWx1ZS56ICsgMiAqIHRoaXMua2V5T3V0LnZhbHVlLnopIC8gLU1hdGgucG93KHgxLCAzKTtcclxuXHJcbiAgICAgIHRoaXMuYi54ID0gKHRoaXMua2V5T3V0LnNsb3BlSW4ueCAtIHRoaXMua2V5SW4uc2xvcGVPdXQueCAtIDMgKiB0aGlzLmEueCAqIE1hdGgucG93KHgxLCAyKSkgLyAoMiAqIHgxKTtcclxuICAgICAgdGhpcy5iLnkgPSAodGhpcy5rZXlPdXQuc2xvcGVJbi55IC0gdGhpcy5rZXlJbi5zbG9wZU91dC55IC0gMyAqIHRoaXMuYS55ICogTWF0aC5wb3coeDEsIDIpKSAvICgyICogeDEpO1xyXG4gICAgICB0aGlzLmIueiA9ICh0aGlzLmtleU91dC5zbG9wZUluLnogLSB0aGlzLmtleUluLnNsb3BlT3V0LnogLSAzICogdGhpcy5hLnogKiBNYXRoLnBvdyh4MSwgMikpIC8gKDIgKiB4MSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uRnVuY3Rpb25RdWF0ZXJuaW9uIGV4dGVuZHMgQW5pbWF0aW9uRnVuY3Rpb248TXV0YXRvclF1YXRlcm5pb24+IHtcclxuICAgIHB1YmxpYyBldmFsdWF0ZShfdGltZTogbnVtYmVyLCBfb3V0OiBNdXRhdG9yUXVhdGVybmlvbiA9IDxNdXRhdG9yUXVhdGVybmlvbj57fSk6IE11dGF0b3JRdWF0ZXJuaW9uIHtcclxuICAgICAgX3RpbWUgLT0gdGhpcy5rZXlJbi50aW1lO1xyXG4gICAgICBsZXQgdGltZTI6IG51bWJlciA9IF90aW1lICogX3RpbWU7XHJcbiAgICAgIGxldCB0aW1lMzogbnVtYmVyID0gdGltZTIgKiBfdGltZTtcclxuXHJcbiAgICAgIF9vdXQueCA9IHRoaXMuYS54ICogdGltZTMgKyB0aGlzLmIueCAqIHRpbWUyICsgdGhpcy5jLnggKiBfdGltZSArIHRoaXMuZC54O1xyXG4gICAgICBfb3V0LnkgPSB0aGlzLmEueSAqIHRpbWUzICsgdGhpcy5iLnkgKiB0aW1lMiArIHRoaXMuYy55ICogX3RpbWUgKyB0aGlzLmQueTtcclxuICAgICAgX291dC56ID0gdGhpcy5hLnogKiB0aW1lMyArIHRoaXMuYi56ICogdGltZTIgKyB0aGlzLmMueiAqIF90aW1lICsgdGhpcy5kLno7XHJcbiAgICAgIF9vdXQudyA9IHRoaXMuYS53ICogdGltZTMgKyB0aGlzLmIudyAqIHRpbWUyICsgdGhpcy5jLncgKiBfdGltZSArIHRoaXMuZC53O1xyXG4gICAgICByZXR1cm4gX291dDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2FsY3VsYXRlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmEgPSB7IHg6IDAsIHk6IDAsIHo6IDAsIHc6IDAgfTtcclxuICAgICAgdGhpcy5iID0geyB4OiAwLCB5OiAwLCB6OiAwLCB3OiAwIH07XHJcbiAgICAgIHRoaXMuYyA9IHsgeDogMCwgeTogMCwgejogMCwgdzogMCB9O1xyXG4gICAgICB0aGlzLmQgPSB7IHg6IDAsIHk6IDAsIHo6IDAsIHc6IDAgfTtcclxuXHJcbiAgICAgIGlmICghdGhpcy5rZXlJbilcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMuZCwgdGhpcy5rZXlJbi52YWx1ZSk7XHJcblxyXG4gICAgICBpZiAoIXRoaXMua2V5T3V0IHx8IHRoaXMua2V5SW4uaW50ZXJwb2xhdGlvbiA9PSBBTklNQVRJT05fSU5URVJQT0xBVElPTi5DT05TVEFOVClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBsZXQgeDE6IG51bWJlciA9IHRoaXMua2V5T3V0LnRpbWUgLSB0aGlzLmtleUluLnRpbWU7XHJcblxyXG4gICAgICBpZiAodGhpcy5rZXlJbi5pbnRlcnBvbGF0aW9uID09IEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkxJTkVBUikge1xyXG4gICAgICAgIHRoaXMuYy54ID0gKHRoaXMua2V5T3V0LnZhbHVlLnggLSB0aGlzLmtleUluLnZhbHVlLngpIC8geDE7XHJcbiAgICAgICAgdGhpcy5jLnkgPSAodGhpcy5rZXlPdXQudmFsdWUueSAtIHRoaXMua2V5SW4udmFsdWUueSkgLyB4MTtcclxuICAgICAgICB0aGlzLmMueiA9ICh0aGlzLmtleU91dC52YWx1ZS56IC0gdGhpcy5rZXlJbi52YWx1ZS56KSAvIHgxO1xyXG4gICAgICAgIHRoaXMuYy53ID0gKHRoaXMua2V5T3V0LnZhbHVlLncgLSB0aGlzLmtleUluLnZhbHVlLncpIC8geDE7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmMsIHRoaXMua2V5SW4uc2xvcGVPdXQpO1xyXG5cclxuICAgICAgdGhpcy5hLnggPSAoLXgxICogKHRoaXMua2V5SW4uc2xvcGVPdXQueCArIHRoaXMua2V5T3V0LnNsb3BlSW4ueCkgLSAyICogdGhpcy5rZXlJbi52YWx1ZS54ICsgMiAqIHRoaXMua2V5T3V0LnZhbHVlLngpIC8gLU1hdGgucG93KHgxLCAzKTtcclxuICAgICAgdGhpcy5hLnkgPSAoLXgxICogKHRoaXMua2V5SW4uc2xvcGVPdXQueSArIHRoaXMua2V5T3V0LnNsb3BlSW4ueSkgLSAyICogdGhpcy5rZXlJbi52YWx1ZS55ICsgMiAqIHRoaXMua2V5T3V0LnZhbHVlLnkpIC8gLU1hdGgucG93KHgxLCAzKTtcclxuICAgICAgdGhpcy5hLnogPSAoLXgxICogKHRoaXMua2V5SW4uc2xvcGVPdXQueiArIHRoaXMua2V5T3V0LnNsb3BlSW4ueikgLSAyICogdGhpcy5rZXlJbi52YWx1ZS56ICsgMiAqIHRoaXMua2V5T3V0LnZhbHVlLnopIC8gLU1hdGgucG93KHgxLCAzKTtcclxuICAgICAgdGhpcy5hLncgPSAoLXgxICogKHRoaXMua2V5SW4uc2xvcGVPdXQudyArIHRoaXMua2V5T3V0LnNsb3BlSW4udykgLSAyICogdGhpcy5rZXlJbi52YWx1ZS53ICsgMiAqIHRoaXMua2V5T3V0LnZhbHVlLncpIC8gLU1hdGgucG93KHgxLCAzKTtcclxuXHJcbiAgICAgIHRoaXMuYi54ID0gKHRoaXMua2V5T3V0LnNsb3BlSW4ueCAtIHRoaXMua2V5SW4uc2xvcGVPdXQueCAtIDMgKiB0aGlzLmEueCAqIE1hdGgucG93KHgxLCAyKSkgLyAoMiAqIHgxKTtcclxuICAgICAgdGhpcy5iLnkgPSAodGhpcy5rZXlPdXQuc2xvcGVJbi55IC0gdGhpcy5rZXlJbi5zbG9wZU91dC55IC0gMyAqIHRoaXMuYS55ICogTWF0aC5wb3coeDEsIDIpKSAvICgyICogeDEpO1xyXG4gICAgICB0aGlzLmIueiA9ICh0aGlzLmtleU91dC5zbG9wZUluLnogLSB0aGlzLmtleUluLnNsb3BlT3V0LnogLSAzICogdGhpcy5hLnogKiBNYXRoLnBvdyh4MSwgMikpIC8gKDIgKiB4MSk7XHJcbiAgICAgIHRoaXMuYi53ID0gKHRoaXMua2V5T3V0LnNsb3BlSW4udyAtIHRoaXMua2V5SW4uc2xvcGVPdXQudyAtIDMgKiB0aGlzLmEudyAqIE1hdGgucG93KHgxLCAyKSkgLyAoMiAqIHgxKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBbiB7QGxpbmsgQW5pbWF0aW9ufSBsb2FkZWQgZnJvbSBhIGdsVEYtRmlsZS5cclxuICAgKiBAYXV0aG9ycyBKb25hcyBQbG90emt5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvbkdMVEYgZXh0ZW5kcyBtaXhpblNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWwoQW5pbWF0aW9uKSB7XHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZChfdXJsOiBSZXF1ZXN0SW5mbyA9IHRoaXMudXJsLCBfbmFtZTogc3RyaW5nID0gdGhpcy5uYW1lKTogUHJvbWlzZTxBbmltYXRpb25HTFRGPiB7XHJcbiAgICAgIHRoaXMudXJsID0gX3VybDtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHJldHVybiBHTFRGTG9hZGVyLmxvYWRSZXNvdXJjZSh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBjb25zdCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uZXZlbnRzID0geyAuLi50aGlzLmV2ZW50cyB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHRoaXMuZXZlbnRzID0geyAuLi5fc2VyaWFsaXphdGlvbi5ldmVudHMgfTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGVudW0gQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04ge1xyXG4gICAgQ09OU1RBTlQsXHJcbiAgICBMSU5FQVIsXHJcbiAgICBDVUJJQ1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgY29udGlub3VzIHBvaW50cyBpbiB0aW1lIHRoZWlyIGFjY29tcGFueWluZyB2YWx1ZXMgYXMgd2VsbCBhcyB0aGVpciBzbG9wZXMuIFxyXG4gICAqIEFsc28gaG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlIHtAbGluayBBbmltYXRpb25GdW5jdGlvbn1zIHRoYXQgY29tZSBpbiBhbmQgb3V0IG9mIHRoZSBzaWRlcy4gXHJcbiAgICogVGhlIHtAbGluayBBbmltYXRpb25GdW5jdGlvbn1zIGFyZSBoYW5kbGVkIGJ5IHRoZSB7QGxpbmsgQW5pbWF0aW9uU2VxdWVuY2V9cy5cclxuICAgKiBJZiB0aGUgcHJvcGVydHkgY29uc3RhbnQgaXMgdHJ1ZSwgdGhlIHZhbHVlIGRvZXMgbm90IGNoYW5nZSBhbmQgd2lsIG5vdCBiZSBpbnRlcnBvbGF0ZWQgYmV0d2VlbiB0aGlzIGFuZCB0aGUgbmV4dCBrZXkgaW4gYSBzZXF1ZW5jZVxyXG4gICAqIEBhdXRob3JzIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5IHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDI1XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvbktleTxUIGV4dGVuZHMgQW5pbWF0aW9uUmV0dXJuVHlwZSA9IEFuaW1hdGlvblJldHVyblR5cGU+IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7XHJcbiAgICAvKipEb24ndCBtb2RpZnkgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuKi9cclxuICAgIHB1YmxpYyBmdW5jdGlvbk91dDogQW5pbWF0aW9uRnVuY3Rpb248VD47XHJcblxyXG4gICAgI2ludGVycG9sYXRpb246IEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OO1xyXG4gICAgI3RpbWU6IG51bWJlcjtcclxuICAgICN2YWx1ZTogVDtcclxuICAgICNzbG9wZUluOiBUO1xyXG4gICAgI3Nsb3BlT3V0OiBUO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfdGltZTogbnVtYmVyID0gMCwgX3ZhbHVlPzogVCwgX2ludGVycG9sYXRpb246IEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OID0gQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04uQ1VCSUMsIF9zbG9wZUluPzogVCwgX3Nsb3BlT3V0PzogVCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLiN0aW1lID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuI3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICB0aGlzLiNpbnRlcnBvbGF0aW9uID0gX2ludGVycG9sYXRpb247XHJcbiAgICAgIHRoaXMuI3Nsb3BlSW4gPSBfc2xvcGVJbjtcclxuICAgICAgdGhpcy4jc2xvcGVPdXQgPSBfc2xvcGVPdXQ7XHJcbiAgICAgIGlmICh0eXBlb2YgdGhpcy4jdmFsdWUgPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHRoaXMuI3Nsb3BlSW4gPz89IDxUPnt9O1xyXG4gICAgICAgIHRoaXMuI3Nsb3BlT3V0ID8/PSA8VD57fTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLiN2YWx1ZSkpIHtcclxuICAgICAgICAgIFJlZmxlY3Quc2V0KDxvYmplY3Q+dGhpcy4jc2xvcGVJbiwga2V5LCAwKTtcclxuICAgICAgICAgIFJlZmxlY3Quc2V0KDxvYmplY3Q+dGhpcy4jc2xvcGVPdXQsIGtleSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLiN2YWx1ZSA9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgdGhpcy4jc2xvcGVJbiA/Pz0gPFQ+MDtcclxuICAgICAgICB0aGlzLiNzbG9wZU91dCA/Pz0gPFQ+MDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhdGljIGNvbXBhcmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSBpbiBhbiBhcnJheSBzb3J0IGZ1bmN0aW9uIHRvIHNvcnQgdGhlIGtleXMgYnkgdGhlaXIgdGltZS5cclxuICAgICAqIEBwYXJhbSBfYSB0aGUgYW5pbWF0aW9uIGtleSB0byBjaGVja1xyXG4gICAgICogQHBhcmFtIF9iIHRoZSBhbmltYXRpb24ga2V5IHRvIGNoZWNrIGFnYWluc3RcclxuICAgICAqIEByZXR1cm5zID4wIGlmIGE+YiwgMCBpZiBhPWIsIDwwIGlmIGE8YlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBhcmU8VCBleHRlbmRzIEFuaW1hdGlvblJldHVyblR5cGUsIEsgZXh0ZW5kcyBBbmltYXRpb25LZXk8VD4+KF9hOiBLLCBfYjogSyk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBfYS50aW1lIC0gX2IudGltZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHRpbWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3RpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCB0aW1lKF90aW1lOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jdGltZSA9IF90aW1lO1xyXG4gICAgICB0aGlzLmZ1bmN0aW9uT3V0LmNhbGN1bGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdmFsdWUoKTogVCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiN2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHZhbHVlKF92YWx1ZTogVCkge1xyXG4gICAgICB0aGlzLiN2YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgdGhpcy5mdW5jdGlvbk91dC5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGludGVycG9sYXRpb24oKTogQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jaW50ZXJwb2xhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGludGVycG9sYXRpb24oX2ludGVycG9sYXRpb246IEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OKSB7XHJcbiAgICAgIHRoaXMuI2ludGVycG9sYXRpb24gPSBfaW50ZXJwb2xhdGlvbjtcclxuICAgICAgdGhpcy5mdW5jdGlvbk91dC5jYWxjdWxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHNsb3BlSW4oKTogVCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzbG9wZUluO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgc2xvcGVJbihfc2xvcGU6IFQpIHtcclxuICAgICAgdGhpcy4jc2xvcGVJbiA9IF9zbG9wZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHNsb3BlT3V0KCk6IFQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc2xvcGVPdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBzbG9wZU91dChfc2xvcGU6IFQpIHtcclxuICAgICAgdGhpcy4jc2xvcGVPdXQgPSBfc2xvcGU7XHJcbiAgICAgIHRoaXMuZnVuY3Rpb25PdXQuY2FsY3VsYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIHRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHt9O1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnRpbWUgPSB0aGlzLiN0aW1lO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnZhbHVlID0gdGhpcy4jdmFsdWU7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaW50ZXJwb2xhdGlvbiA9IHRoaXMuI2ludGVycG9sYXRpb247XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc2xvcGVJbiA9IHRoaXMuI3Nsb3BlSW47XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc2xvcGVPdXQgPSB0aGlzLiNzbG9wZU91dDtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy4jdGltZSA9IF9zZXJpYWxpemF0aW9uLnRpbWU7XHJcbiAgICAgIHRoaXMuI3ZhbHVlID0gX3NlcmlhbGl6YXRpb24udmFsdWU7XHJcbiAgICAgIHRoaXMuI2ludGVycG9sYXRpb24gPSBfc2VyaWFsaXphdGlvbi5pbnRlcnBvbGF0aW9uO1xyXG4gICAgICB0aGlzLiNzbG9wZUluID0gX3NlcmlhbGl6YXRpb24uc2xvcGVJbjtcclxuICAgICAgdGhpcy4jc2xvcGVPdXQgPSBfc2VyaWFsaXphdGlvbi5zbG9wZU91dDtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAvL1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKiBCbGVuZGluZyBtb2RlcyB1c2VkIGluIHtAbGluayBBbmltYXRpb25Ob2RlQmxlbmR9LiAqL1xyXG4gIGV4cG9ydCBlbnVtIEFOSU1BVElPTl9CTEVORElORyB7XHJcbiAgICAvKiogQWRkcyB0aGlzIGFuaW1hdGlvbiB0byB0aGUgcHJldmlvdXMgYW5pbWF0aW9ucy4gKi9cclxuICAgIEFERElUSVZFID0gXCJBZGRpdGl2ZVwiLFxyXG4gICAgLyoqIE92ZXJyaWRlcyB0aGUgcHJldmlvdXMgYW5pbWF0aW9ucyB1c2luZyBsaW5lYXIgaW50ZXJwb2xhdGlvbi4gKi9cclxuICAgIE9WRVJSSURFID0gXCJPdmVycmlkZVwiXHJcbiAgfVxyXG5cclxuICAvKiogXHJcbiAgICogQmFzZSBjbGFzcyBmb3IgYWxsIGFuaW1hdGlvbiBub2Rlcy4gQW5pbWF0aW9uIG5vZGVzIGZvcm0gYW4gYW5pbWF0aW9uIGdyYXBoIGVuYWJsaW5nIGhpZXJhY2hpY2FsIGFuaW1hdGlvbiBibGVuZGluZyBhbmQgYW5pbWF0aW9uIHRyYW5zaXRpb25zLiBcclxuICAgKiBDYW4gYmUgYXR0YWNoZWQgdG8gYSB7QGxpbmsgTm9kZX0gdmlhIHtAbGluayBDb21wb25lbnRBbmltYXRpb25HcmFwaH0uIFxyXG4gICAqIEBhdXRob3IgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDI0LTIwMjVcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgQW5pbWF0aW9uTm9kZSB7XHJcbiAgICAvKiogVGhlIChibGVuZGVkKSB7QGxpbmsgQW5pbWF0aW9uLmdldFN0YXRlIGFuaW1hdGlvbiBtdXRhdG9yfSBhdCB0aGUgc3RhdGUgb2YgdGhlIGxhc3QgY2FsbCB0byB7QGxpbmsgdXBkYXRlfS4gKi9cclxuICAgIHB1YmxpYyBtdXRhdG9yOiBNdXRhdG9yO1xyXG4gICAgLyoqIFRoZSB7QGxpbmsgQW5pbWF0aW9uLmV2ZW50cyBldmVudHN9IHRoYXQgb2NjdXJlZCBiZXR3ZWVuIHRoZSBub2RlcyBsYXN0IHR3byB7QGxpbmsgdXBkYXRlfXMuICovXHJcbiAgICBwdWJsaWMgZXZlbnRzOiBzdHJpbmdbXTtcclxuXHJcbiAgICAvKiogVGhlIHBsYXliYWNrIHNwZWVkICovXHJcbiAgICBwdWJsaWMgc3BlZWQ6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIHdlaWdodCB1c2VkIGZvciBibGVuZGluZyB0aGlzIG5vZGUgd2l0aCBvdGhlcnMgaW4gYW4ge0BsaW5rIEFuaW1hdGlvbk5vZGVCbGVuZH0uIERlZmF1bHQ6IDEuKi9cclxuICAgIHB1YmxpYyB3ZWlnaHQ6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgbW9kZSB1c2VkIGZvciBibGVuZGluZyB0aGlzIG5vZGUgd2l0aCBvdGhlcnMgaW4gYW4ge0BsaW5rIEFuaW1hdGlvbk5vZGVCbGVuZH0uIERlZmF1bHQ6IHtAbGluayBBTklNQVRJT05fQkxFTkRJTkcuT1ZFUlJJREV9LiAqL1xyXG4gICAgcHVibGljIGJsZW5kaW5nOiBBTklNQVRJT05fQkxFTkRJTkc7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9vcHRpb25zPzogeyBzcGVlZD86IG51bWJlcjsgd2VpZ2h0PzogbnVtYmVyOyBibGVuZGluZz86IEFOSU1BVElPTl9CTEVORElORyB9KSB7XHJcbiAgICAgIHRoaXMuc3BlZWQgPSBfb3B0aW9ucz8uc3BlZWQgPz8gMTtcclxuICAgICAgdGhpcy53ZWlnaHQgPSBfb3B0aW9ucz8ud2VpZ2h0ID8/IDE7XHJcbiAgICAgIHRoaXMuYmxlbmRpbmcgPSBfb3B0aW9ucz8uYmxlbmRpbmcgPz8gQU5JTUFUSU9OX0JMRU5ESU5HLk9WRVJSSURFO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXNldHMgdGhlIHRpbWUuICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgcmVzZXQoKTogdm9pZDtcclxuXHJcbiAgICAvKiogVXBkYXRlcyB0aGUge0BsaW5rIG11dGF0b3J9IGFuZCB7QGxpbmsgZXZlbnRzfSBhY2NvcmRpbmcgdGhlIGdpdmVuIGRlbHRhIHRpbWUgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCB1cGRhdGUoX2RlbHRhVGltZTogbnVtYmVyLCBfcG9zZT86IE11dGF0b3IpOiB2b2lkO1xyXG4gIH1cclxuXHJcbiAgLyoqIFxyXG4gICAqIEV2YWx1YXRlcyBhIHNpbmdsZSB7QGxpbmsgQW5pbWF0aW9ufSBwcm92aWRpbmcgYSB7QGxpbmsgbXV0YXRvcn0gYW5kIHtAbGluayBldmVudHN9LiBcclxuICAgKiBVc2VkIGFzIGFuIGlucHV0IGZvciBvdGhlciB7QGxpbmsgQW5pbWF0aW9uTm9kZX1zLiBcclxuICAgKiBAYXV0aG9yIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNC0yMDI1XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvbk5vZGVBbmltYXRpb24gZXh0ZW5kcyBBbmltYXRpb25Ob2RlIHtcclxuICAgIHB1YmxpYyBhbmltYXRpb246IEFuaW1hdGlvbjtcclxuICAgIHB1YmxpYyBwbGF5bW9kZTogQU5JTUFUSU9OX1BMQVlNT0RFO1xyXG5cclxuICAgIC8qKiBUaGUgdGltZSBhZnRlciB0aGUgbGFzdCBjYWxsIHRvIHtAbGluayB1cGRhdGV9LiAqL1xyXG4gICAgcHVibGljIHRpbWU6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIHRpbWUgb2Zmc2V0IGZyb20gd2hpY2ggdGhlIGFuaW1hdGlvbiBzdGFydHMgd2hlbiByZXNldC4gKi9cclxuICAgIHB1YmxpYyBvZmZzZXQ/OiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9hbmltYXRpb246IEFuaW1hdGlvbiwgX29wdGlvbnM/OiB7IHNwZWVkPzogbnVtYmVyOyBvZmZzZXQ/OiBudW1iZXI7IHBsYXltb2RlPzogQU5JTUFUSU9OX1BMQVlNT0RFOyB3ZWlnaHQ/OiBudW1iZXI7IGJsZW5kaW5nPzogQU5JTUFUSU9OX0JMRU5ESU5HIH0pO1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCk7XHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX211dGF0b3I6IE11dGF0b3IpO1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9hbmltYXRpb24/OiBBbmltYXRpb24gfCBNdXRhdG9yLCBfb3B0aW9ucz86IHsgc3BlZWQ/OiBudW1iZXI7IG9mZnNldD86IG51bWJlcjsgcGxheW1vZGU/OiBBTklNQVRJT05fUExBWU1PREU7IHdlaWdodD86IG51bWJlcjsgYmxlbmRpbmc/OiBBTklNQVRJT05fQkxFTkRJTkcgfSkge1xyXG4gICAgICBzdXBlcihfb3B0aW9ucyk7XHJcblxyXG4gICAgICBpZiAoIV9hbmltYXRpb24pXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgaWYgKCEoX2FuaW1hdGlvbiBpbnN0YW5jZW9mIEFuaW1hdGlvbikpIHtcclxuICAgICAgICB0aGlzLm11dGF0b3IgPSBfYW5pbWF0aW9uO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5hbmltYXRpb24gPSBfYW5pbWF0aW9uO1xyXG4gICAgICB0aGlzLm9mZnNldCA9IF9vcHRpb25zPy5vZmZzZXQgPz8gMDtcclxuICAgICAgdGhpcy5wbGF5bW9kZSA9IF9vcHRpb25zPy5wbGF5bW9kZTtcclxuICAgICAgdGhpcy50aW1lID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVzZXRzIHRoaXMgbm9kZSB0byBpdHMge0BsaW5rIG9mZnNldH0gdGltZS4gKi9cclxuICAgIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy50aW1lID0gdGhpcy5vZmZzZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZShfZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLmFuaW1hdGlvbilcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBfZGVsdGFUaW1lICo9IHRoaXMuc3BlZWQ7XHJcblxyXG4gICAgICBsZXQgdXBkYXRlZFRpbWU6IG51bWJlciA9IHRoaXMudGltZSArIF9kZWx0YVRpbWU7XHJcblxyXG4gICAgICBpZiAodGhpcy5hbmltYXRpb24udG90YWxUaW1lID09IDApXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgdXBkYXRlZFRpbWUgPSB0aGlzLmFuaW1hdGlvbi5nZXRNb2RhbFRpbWUodXBkYXRlZFRpbWUsIHRoaXMucGxheW1vZGUpO1xyXG5cclxuICAgICAgbGV0IGRpcmVjdGlvbjogbnVtYmVyID0gdGhpcy5hbmltYXRpb24uY2FsY3VsYXRlRGlyZWN0aW9uKHVwZGF0ZWRUaW1lLCB0aGlzLnBsYXltb2RlKTtcclxuXHJcbiAgICAgIHRoaXMuZXZlbnRzID0gdGhpcy5hbmltYXRpb24uZ2V0RXZlbnRzVG9GaXJlKHRoaXMudGltZSwgdXBkYXRlZFRpbWUsIEFOSU1BVElPTl9RVUFOVElaQVRJT04uQ09OVElOT1VTLCBkaXJlY3Rpb24pO1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSB0aGlzLmFuaW1hdGlvbi5nZXRTdGF0ZSh1cGRhdGVkVGltZSAlIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZSwgZGlyZWN0aW9uLCBBTklNQVRJT05fUVVBTlRJWkFUSU9OLkNPTlRJTk9VUyk7XHJcbiAgICAgIHRoaXMudGltZSA9IHVwZGF0ZWRUaW1lO1xyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIFxyXG4gICAqIEJsZW5kcyBtdWx0aXBsZSBpbnB1dCB7QGxpbmsgQW5pbWF0aW9uTm9kZX1zIHByb3ZpZGluZyBhIGJsZW5kZWQge0BsaW5rIG11dGF0b3J9IGFuZCB0aGUge0BsaW5rIGV2ZW50c30gZnJvbSBhbGwgbm9kZXMuIFxyXG4gICAqIEVhY2ggY2hpbGQgbm9kZSBtdXN0IHNwZWNpZnkgaXRzIG93biBibGVuZCB7QGxpbmsgd2VpZ2h0fSBhbmQge0BsaW5rIGJsZW5kaW5nfS4gUHJvY2Vzc2VzIG5vZGVzIHNlcXVlbnRpYWxseSwgZWFjaCBub2RlIGJsZW5kcyB3aXRoIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQuXHJcbiAgICogV2hlbiBjb21iaW5lZCB3aXRoIHtAbGluayBBbmltYXRpb25Ob2RlVHJhbnNpdGlvbn1zIGFzIGNoaWxkcmVuLCB0cmFuc2l0aW9ucyBmcm9tL2ludG8gYW4gZW1wdHkgc3RhdGUgd2lsbCBibGVuZCBmcm9tL2ludG8gdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiB0aGlzIG5vZGUuXHJcbiAgICogQGF1dGhvciBKb25hcyBQbG90emt5LCBIRlUsIDIwMjQtMjAyNVxyXG4gICAqIFxyXG4gICAqICoqRXhhbXBsZSB3YWxrLXJ1bi1ibGVuZDoqKlxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiBpbXBvcnQgxpIgPSBGdWRnZUNvcmU7XHJcbiAgICogLy8gaW5pdGlhbGl6YXRpb25cclxuICAgKiBjb25zdCB3YWxrOiDGki5BbmltYXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uKCk7XHJcbiAgICogY29uc3QgcnVuOiDGki5BbmltYXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uKCk7XHJcbiAgICogY29uc3Qgbm9kZVdhbGs6IMaSLkFuaW1hdGlvbk5vZGVBbmltYXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uTm9kZUFuaW1hdGlvbih3YWxrKTtcclxuICAgKiBjb25zdCBub2RlUnVuOiDGki5BbmltYXRpb25Ob2RlQW5pbWF0aW9uID0gbmV3IMaSLkFuaW1hdGlvbk5vZGVBbmltYXRpb24ocnVuLCB7IHNwZWVkOiBydW4udG90YWxUaW1lIC8gd2Fsay50b3RhbFRpbWUgfSkgLy8gc2xvdyBkb3duIHRoZSBwbGF5YmFjayBzcGVlZCBvZiBydW4gdG8gc3luY2hyb25pemUgdGhlIG1vdGlvbiB3aXRoIHdhbGsuXHJcbiAgICogY29uc3Qgbm9kZU1vdmU6IMaSLkFuaW1hdGlvbk5vZGVCbGVuZCA9IG5ldyDGki5BbmltYXRpb25Ob2RlQmxlbmQoW25vZGVXYWxrLCBub2RlUnVuXSk7XHJcbiAgICogY29uc3QgY21wQW5pbWF0aW9uR3JhcGg6IMaSLkNvbXBvbmVudEFuaW1hdGlvbkdyYXBoID0gbmV3IMaSLkNvbXBvbmVudEFuaW1hdGlvbkdyYXBoKCk7IC8vIGdldCB0aGUgYW5pbWF0aW9uIGNvbXBvbmVudFxyXG4gICAqIGNtcEFuaW1hdGlvbkdyYXBoLnJvb3QgPSBub2RlTW92ZTtcclxuICAgKiBcclxuICAgKiAvLyBkdXJpbmcgdGhlIGdhbWVcclxuICAgKiBub2RlUnVuLndlaWdodCA9IDAuNTsgLy8gYWRqdXN0IHRoZSB3ZWlnaHQ6IDAgaXMgd2Fsa2luZywgMSBpcyBydW5uaW5nLlxyXG4gICAqIG5vZGVNb3ZlLnNwZWVkID0gMSArIG5vZGVSdW4ud2VpZ2h0ICogbm9kZVJ1bi5zcGVlZDsgLy8gYWRqdXN0IHRoZSBwbGF5YmFjayBzcGVlZCBvZiB0aGUgYmxlbmQgdG8gYWNjb3VudCBmb3IgdGhlIHNsb3dlZCBkb3duIHJ1biBhbmltYXRpb24uXHJcbiAgICogYGBgXHJcbiAgICogKipFeGFtcGxlIHRyYW5zaXRpb24tZW1wdHktc3RhdGU6KipcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogaW1wb3J0IMaSID0gRnVkZ2VDb3JlO1xyXG4gICAqIC8vIGluaXRpYWxpemF0aW9uXHJcbiAgICogY29uc3QgaWRsZTogxpIuQW5pbWF0aW9uID0gbmV3IMaSLkFuaW1hdGlvbigpO1xyXG4gICAqIGNvbnN0IHdhbGs6IMaSLkFuaW1hdGlvbiA9IG5ldyDGki5BbmltYXRpb24oKTtcclxuICAgKiBjb25zdCBkcmF3OiDGki5BbmltYXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uKCk7XHJcbiAgICogY29uc3Qgc2hlYXRoZTogxpIuQW5pbWF0aW9uID0gbmV3IMaSLkFuaW1hdGlvbigpO1xyXG4gICAqIFxyXG4gICAqIGNvbnN0IG5vZGVFbXB0eTogxpIuQW5pbWF0aW9uTm9kZUFuaW1hdGlvbiA9IG5ldyDGki5BbmltYXRpb25Ob2RlQW5pbWF0aW9uKCk7XHJcbiAgICogY29uc3Qgbm9kZUlkbGU6IMaSLkFuaW1hdGlvbk5vZGVBbmltYXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uTm9kZUFuaW1hdGlvbihpZGxlKTtcclxuICAgKiBjb25zdCBub2RlV2FsazogxpIuQW5pbWF0aW9uTm9kZUFuaW1hdGlvbiA9IG5ldyDGki5BbmltYXRpb25Ob2RlQW5pbWF0aW9uKHdhbGspO1xyXG4gICAqIGNvbnN0IG5vZGVEcmF3OiDGki5BbmltYXRpb25Ob2RlQW5pbWF0aW9uID0gbmV3IMaSLkFuaW1hdGlvbk5vZGVBbmltYXRpb24oZHJhdywgeyBwbGF5bW9kZTogxpIuQU5JTUFUSU9OX1BMQVlNT0RFLlBMQVlfT05DRSB9KTtcclxuICAgKiBjb25zdCBub2RlU2hlYXRoZTogxpIuQW5pbWF0aW9uTm9kZUFuaW1hdGlvbiA9IG5ldyDGki5BbmltYXRpb25Ob2RlQW5pbWF0aW9uKHNoZWF0aGUsIHsgcGxheW1vZGU6IMaSLkFOSU1BVElPTl9QTEFZTU9ERS5QTEFZX09OQ0UgfSk7XHJcbiAgICogXHJcbiAgICogY29uc3Qgbm9kZVdob2xlQm9keTogxpIuQW5pbWF0aW9uTm9kZVRyYW5zaXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uTm9kZVRyYW5zaXRpb24obm9kZUlkbGUpO1xyXG4gICAqIGNvbnN0IG5vZGVVcHBlckJvZHk6IMaSLkFuaW1hdGlvbk5vZGVUcmFuc2l0aW9uID0gbmV3IMaSLkFuaW1hdGlvbk5vZGVUcmFuc2l0aW9uKG5vZGVFbXB0eSk7XHJcbiAgICogY29uc3Qgbm9kZVJvb3Q6IMaSLkFuaW1hdGlvbk5vZGVCbGVuZCA9IG5ldyDGki5BbmltYXRpb25Ob2RlQmxlbmQoW25vZGVXaG9sZUJvZHksIG5vZGVVcHBlckJvZHldKTtcclxuICAgKiBjb25zdCBjbXBBbmltYXRpb25HcmFwaDogxpIuQ29tcG9uZW50QW5pbWF0aW9uR3JhcGggPSBuZXcgxpIuQ29tcG9uZW50QW5pbWF0aW9uR3JhcGgoKTsgLy8gZ2V0IHRoZSBhbmltYXRpb24gY29tcG9uZW50XHJcbiAgICogY21wQW5pbWF0aW9uR3JhcGgucm9vdCA9IG5vZGVSb290O1xyXG4gICAqIFxyXG4gICAqIC8vIGR1cmluZyB0aGUgZ2FtZVxyXG4gICAqIG5vZGVXaG9sZUJvZHkudHJhbnNpdChub2RlV2FsaywgMzAwKTsgLy8gdHJhbnNpdCB3aG9sZSBib2R5IGludG8gd2Fsay5cclxuICAgKiAvLyBpbiBwYXJhbGxlbCB0byB0aGUgd2hvbGUgYm9keSwgdGhlIHVwcGVyIGJvZHkgY2FuIHRyYW5zaXQgZnJvbSBlbXB0eSB0byBkcmF3L3NoZWF0aCBhbmQgYmFjayB0byBlbXB0eS5cclxuICAgKiBub2RlVXBwZXJCb2R5LnRyYW5zaXQobm9kZURyYXcsIDMwMCk7IC8vIHRyYW5zaXQgdXBwZXIgYm9keSBmcm9tIGVtcHR5IGludG8gZHJhdy5cclxuICAgKiBub2RlVXBwZXJCb2R5LnRyYW5zaXQobm9kZVNoZWF0aGUsIDMwMCk7IC8vIHRyYW5zaXQgdXBwZXIgYm9keSBmcm9tIGRyYXcgaW50byBzaGVhdGhlLlxyXG4gICAqIG5vZGVVcHBlckJvZHkudHJhbnNpdChub2RlRW1wdHksIDMwMCk7IC8vIHRyYW5zaXQgdXBwZXIgYm9keSBmcm9tIHNoZWF0aGUgaW50byBlbXB0eS5cclxuICAgKiBgYGBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uTm9kZUJsZW5kIGV4dGVuZHMgQW5pbWF0aW9uTm9kZSB7XHJcbiAgICBwdWJsaWMgbm9kZXM6IEFuaW1hdGlvbk5vZGVbXTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25vZGVzOiBBbmltYXRpb25Ob2RlW10sIF9vcHRpb25zPzogeyBzcGVlZD86IG51bWJlcjsgd2VpZ2h0PzogbnVtYmVyOyBibGVuZGluZz86IEFOSU1BVElPTl9CTEVORElORyB9KSB7XHJcbiAgICAgIHN1cGVyKF9vcHRpb25zKTtcclxuICAgICAgdGhpcy5ub2RlcyA9IF9ub2RlcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XHJcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLm5vZGVzKVxyXG4gICAgICAgIG5vZGUucmVzZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlKF9kZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy5ub2Rlcy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9kZWx0YVRpbWUgKj0gdGhpcy5zcGVlZDtcclxuXHJcbiAgICAgIHRoaXMubm9kZXNbMF0udXBkYXRlKF9kZWx0YVRpbWUsIHt9KTsgLy8gVE9ETzogYWRkIGJhc2UgcG9zZSBzbmFwc2hvdCB0byBibGVuZCBmcm9tXHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gdGhpcy5ub2Rlc1swXS5tdXRhdG9yID8/IHt9O1xyXG4gICAgICBsZXQgZXZlbnRzOiBzdHJpbmdbXSA9IHRoaXMubm9kZXNbMF0uZXZlbnRzID8/IFtdO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAxOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG5vZGU6IEFuaW1hdGlvbk5vZGUgPSB0aGlzLm5vZGVzW2ldO1xyXG4gICAgICAgIG5vZGUudXBkYXRlKF9kZWx0YVRpbWUsIG11dGF0b3IpO1xyXG5cclxuICAgICAgICBpZiAoIW5vZGUubXV0YXRvcilcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKG5vZGUuYmxlbmRpbmcpIHtcclxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX0JMRU5ESU5HLkFERElUSVZFOlxyXG4gICAgICAgICAgICBtdXRhdG9yID0gQW5pbWF0aW9uLmJsZW5kQWRkaXRpdmUobXV0YXRvciwgbm9kZS5tdXRhdG9yLCBub2RlLndlaWdodCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fQkxFTkRJTkcuT1ZFUlJJREU6XHJcbiAgICAgICAgICAgIG11dGF0b3IgPSBBbmltYXRpb24uYmxlbmRPdmVycmlkZShtdXRhdG9yLCBub2RlLm11dGF0b3IsIG5vZGUud2VpZ2h0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KG5vZGUuZXZlbnRzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5tdXRhdG9yID0gbXV0YXRvcjtcclxuICAgICAgdGhpcy5ldmVudHMgPSBldmVudHM7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogXHJcbiAgICogQWxsb3dzIHRvIHRyYW5zaXRpb24gZnJvbSBvbmUge0BsaW5rIEFuaW1hdGlvbk5vZGV9IHRvIGFub3RoZXIgb3ZlciBhIHNwZWNpZmllZCB0aW1lLiBcclxuICAgKiBJZiBuZXN0ZWQgaW5zaWRlIGFuIHtAbGluayBBbmltYXRpb25Ob2RlQmxlbmR9LCB0cmFuc2l0IGZyb20vaW50byBhbiBlbXB0eSBzdGF0ZSB0byBibGVuZCBmcm9tL2ludG8gdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiB0aGUgY29udGFpbmVyIGJsZW5kIG5vZGUuXHJcbiAgICogQGF1dGhvciBKb25hcyBQbG90emt5LCBIRlUsIDIwMjQtMjAyNVxyXG4gICAqIFxyXG4gICAqICoqRXhhbXBsZToqKlxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiBpbXBvcnQgxpIgPSBGdWRnZUNvcmU7XHJcbiAgICogLy8gaW5pdGlhbGl6YXRpb25cclxuICAgKiBjb25zdCBpZGxlOiDGki5BbmltYXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uKCk7XHJcbiAgICogY29uc3Qgd2FsazogxpIuQW5pbWF0aW9uID0gbmV3IMaSLkFuaW1hdGlvbigpO1xyXG4gICAqIGNvbnN0IG5vZGVJZGxlOiDGki5BbmltYXRpb25Ob2RlQW5pbWF0aW9uID0gbmV3IMaSLkFuaW1hdGlvbk5vZGVBbmltYXRpb24oaWRsZSk7XHJcbiAgICogY29uc3Qgbm9kZVdhbGs6IMaSLkFuaW1hdGlvbk5vZGVBbmltYXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uTm9kZUFuaW1hdGlvbih3YWxrKTtcclxuICAgKiBjb25zdCBub2RlVHJhbnNpdGlvbjogxpIuQW5pbWF0aW9uTm9kZVRyYW5zaXRpb24gPSBuZXcgxpIuQW5pbWF0aW9uTm9kZVRyYW5zaXRpb24obm9kZUlkbGUpO1xyXG4gICAqIGNvbnN0IGNtcEFuaW1hdGlvbkdyYXBoOiDGki5Db21wb25lbnRBbmltYXRpb25HcmFwaCA9IG5ldyDGki5Db21wb25lbnRBbmltYXRpb25HcmFwaCgpOyAvLyBnZXQgdGhlIGFuaW1hdGlvbiBjb21wb25lbnRcclxuICAgKiBjbXBBbmltYXRpb25HcmFwaC5yb290ID0gbm9kZVRyYW5zaXRpb247XHJcbiAgICogXHJcbiAgICogLy8gZHVyaW5nIHRoZSBnYW1lXHJcbiAgICogbm9kZVRyYW5zaXRpb24udHJhbnNpdChub2RlV2FsaywgMzAwKTsgLy8gdHJhbnNpdCB0byB0aGUgd2FsayBhbmltYXRpb24gaW4gMzAwbXMuXHJcbiAgICogbm9kZVRyYW5zaXRpb24udHJhbnNpdChub2RlSWRsZSwgMzAwKTsgLy8gdHJhbnNpdCBiYWNrIHRvIHRoZSBpZGxlIGFuaW1hdGlvbi5cclxuICAgKiBgYGBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uTm9kZVRyYW5zaXRpb24gZXh0ZW5kcyBBbmltYXRpb25Ob2RlIHtcclxuICAgIHB1YmxpYyBmcm9tOiBBbmltYXRpb25Ob2RlO1xyXG4gICAgcHVibGljIHRvOiBBbmltYXRpb25Ob2RlO1xyXG5cclxuICAgIHB1YmxpYyBkdXJhdGlvbjogbnVtYmVyO1xyXG4gICAgcHVibGljIHRpbWU6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2FuaW1hdGlvbjogQW5pbWF0aW9uTm9kZSwgX29wdGlvbnM/OiB7IHNwZWVkPzogbnVtYmVyOyB3ZWlnaHQ/OiBudW1iZXI7IGJsZW5kaW5nPzogQU5JTUFUSU9OX0JMRU5ESU5HIH0pIHtcclxuICAgICAgc3VwZXIoX29wdGlvbnMpO1xyXG4gICAgICB0aGlzLmZyb20gPSBfYW5pbWF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5mcm9tLnJlc2V0KCk7XHJcbiAgICAgIHRoaXMudG8/LnJlc2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRyYW5zaXQgdG8gdGhlIGdpdmVuIHtAbGluayBBbmltYXRpb25Ob2RlfSBvdmVyIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uIFRoZSBnaXZlbiBub2RlIHdpbGwgYmUge0BsaW5rIHJlc2V0fS4gKi9cclxuICAgIHB1YmxpYyB0cmFuc2l0KF90bzogQW5pbWF0aW9uTm9kZSwgX2R1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgX3RvLnJlc2V0KCk7XHJcbiAgICAgIGlmICh0aGlzLnRvKVxyXG4gICAgICAgIHRoaXMuZnJvbSA9IG5ldyBBbmltYXRpb25Ob2RlQW5pbWF0aW9uKHRoaXMubXV0YXRvcik7XHJcbiAgICAgIHRoaXMudG8gPSBfdG87XHJcbiAgICAgIHRoaXMuZHVyYXRpb24gPSBfZHVyYXRpb247XHJcbiAgICAgIHRoaXMudGltZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZShfZGVsdGFUaW1lOiBudW1iZXIsIF9wb3NlOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIF9kZWx0YVRpbWUgKj0gdGhpcy5zcGVlZDtcclxuXHJcbiAgICAgIHRoaXMudGltZSArPSBfZGVsdGFUaW1lO1xyXG5cclxuICAgICAgdGhpcy5mcm9tLnVwZGF0ZShfZGVsdGFUaW1lKTtcclxuXHJcbiAgICAgIGlmICghdGhpcy50bykge1xyXG4gICAgICAgIHRoaXMubXV0YXRvciA9IHRoaXMuZnJvbS5tdXRhdG9yO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gdGhpcy5mcm9tLmV2ZW50cztcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMudG8udXBkYXRlKF9kZWx0YVRpbWUpO1xyXG5cclxuICAgICAgbGV0IHByb2dyZXNzOiBudW1iZXIgPSBNYXRoLm1pbih0aGlzLnRpbWUgLyB0aGlzLmR1cmF0aW9uLCAxKTtcclxuXHJcbiAgICAgIGxldCBmcm9tOiBNdXRhdG9yID0gdGhpcy5mcm9tLm11dGF0b3IgPz8gX3Bvc2U7XHJcbiAgICAgIGxldCB0bzogTXV0YXRvciA9IHRoaXMudG8ubXV0YXRvciA/PyBfcG9zZTtcclxuXHJcbiAgICAgIGlmIChmcm9tID09IHRvKSB7XHJcbiAgICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubXV0YXRvciA9IEFuaW1hdGlvbi5ibGVuZE92ZXJyaWRlKGZyb20sIHRvLCBwcm9ncmVzcywgZnJvbSA9PSBfcG9zZSB8fCB0byA9PSBfcG9zZSk7XHJcbiAgICAgIHRoaXMuZXZlbnRzID0gdGhpcy50by5ldmVudHM7XHJcblxyXG4gICAgICBpZiAocHJvZ3Jlc3MgPj0gMSkge1xyXG4gICAgICAgIHRoaXMuZnJvbSA9IHRoaXMudG87XHJcbiAgICAgICAgdGhpcy50byA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50aW1lID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIE11dGF0b3JWZWN0b3IzIHtcclxuICAgIHg/OiBudW1iZXI7XHJcbiAgICB5PzogbnVtYmVyO1xyXG4gICAgej86IG51bWJlcjtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTXV0YXRvclF1YXRlcm5pb24ge1xyXG4gICAgeDogbnVtYmVyO1xyXG4gICAgeTogbnVtYmVyO1xyXG4gICAgejogbnVtYmVyO1xyXG4gICAgdzogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IHR5cGUgQW5pbWF0aW9uUmV0dXJuVHlwZSA9IG51bWJlciB8IE11dGF0b3JWZWN0b3IzIHwgTXV0YXRvclF1YXRlcm5pb247XHJcblxyXG4gIGV4cG9ydCB0eXBlIEFuaW1hdGlvbkNsYXNzVHlwZTxUIGV4dGVuZHMgQW5pbWF0aW9uUmV0dXJuVHlwZSA9IEFuaW1hdGlvblJldHVyblR5cGU+ID1cclxuICAgIFQgZXh0ZW5kcyBudW1iZXIgPyBOdW1iZXJDb25zdHJ1Y3RvciA6XHJcbiAgICBUIGV4dGVuZHMgTXV0YXRvclF1YXRlcm5pb24gPyB0eXBlb2YgUXVhdGVybmlvbiA6XHJcbiAgICBUIGV4dGVuZHMgTXV0YXRvclZlY3RvcjMgPyB0eXBlb2YgVmVjdG9yMyA6XHJcbiAgICBuZXZlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBzZXF1ZW5jZSBvZiB7QGxpbmsgQW5pbWF0aW9uS2V5fXMgdGhhdCBpcyBtYXBwZWQgdG8gYW4gYXR0cmlidXRlIG9mIGEge0BsaW5rIE5vZGV9IG9yIGl0cyB7QGxpbmsgQ29tcG9uZW50fXMgaW5zaWRlIHRoZSB7QGxpbmsgQW5pbWF0aW9ufS5cclxuICAgKiBQcm92aWRlcyBmdW5jdGlvbnMgdG8gbW9kaWZ5IHNhaWQga2V5c1xyXG4gICAqIEBhdXRob3JzIEx1a2FzIFNjaGV1ZXJsZSwgSEZVLCAyMDE5IHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIyLTIwMjVcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uU2VxdWVuY2U8VCBleHRlbmRzIEFuaW1hdGlvblJldHVyblR5cGUgPSBBbmltYXRpb25SZXR1cm5UeXBlLCBDIGV4dGVuZHMgQW5pbWF0aW9uQ2xhc3NUeXBlPFQ+ID0gQW5pbWF0aW9uQ2xhc3NUeXBlPFQ+PiBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUge1xyXG4gICAgcHJvdGVjdGVkIGtleXM6IEFuaW1hdGlvbktleTxUPltdO1xyXG5cclxuICAgICNjbGFzc1R5cGU6IEM7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9rZXlzOiBBbmltYXRpb25LZXk8VD5bXSA9IFtdLCBfdmFsdWVUeXBlOiBDKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMua2V5cyA9IF9rZXlzO1xyXG4gICAgICB0aGlzLmtleXMuc29ydChBbmltYXRpb25LZXkuY29tcGFyZSk7XHJcbiAgICAgIHRoaXMuY2xhc3NUeXBlID0gX3ZhbHVlVHlwZTtcclxuICAgICAgdGhpcy5yZWdlbmVyYXRlRnVuY3Rpb25zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBsZW5ndGgoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMua2V5cy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBjbGFzc1R5cGUoKTogQyB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNjbGFzc1R5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzZXQgY2xhc3NUeXBlKF90eXBlOiBDKSB7XHJcbiAgICAgIHRoaXMuI2NsYXNzVHlwZSA9IF90eXBlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXZhbHVhdGVzIHRoZSBzZXF1ZW5jZSBhdCB0aGUgZ2l2ZW4gcG9pbnQgaW4gdGltZS5cclxuICAgICAqIEBwYXJhbSBfdGltZSB0aGUgcG9pbnQgaW4gdGltZSBhdCB3aGljaCB0byBldmFsdWF0ZSB0aGUgc2VxdWVuY2UgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICogQHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzZXF1ZW5jZSBhdCB0aGUgZ2l2ZW4gdGltZS4gdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBubyBrZXlzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZXZhbHVhdGUoX3RpbWU6IG51bWJlciwgX2ZyYW1lPzogbnVtYmVyLCBfb3V0PzogQW5pbWF0aW9uUmV0dXJuVHlwZSk6IFQge1xyXG4gICAgICBsZXQgaUxlZnQ6IG51bWJlciA9IDAsIGlSaWdodDogbnVtYmVyID0gdGhpcy5rZXlzLmxlbmd0aCAtIDEsIGlNaWQ6IG51bWJlcjtcclxuICAgICAgd2hpbGUgKGlMZWZ0IDw9IGlSaWdodCkge1xyXG4gICAgICAgIGlNaWQgPSBNYXRoLmZsb29yKChpTGVmdCArIGlSaWdodCkgLyAyKTtcclxuICAgICAgICBpZiAodGhpcy5rZXlzW2lNaWRdLnRpbWUgPCBfdGltZSlcclxuICAgICAgICAgIGlMZWZ0ID0gaU1pZCArIDE7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgaVJpZ2h0ID0gaU1pZCAtIDE7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qga2V5OiBBbmltYXRpb25LZXk8VD4gPSB0aGlzLmtleXNbaVJpZ2h0XSA/PyB0aGlzLmtleXNbaUxlZnRdO1xyXG4gICAgICByZXR1cm4ga2V5Py5mdW5jdGlvbk91dC5ldmFsdWF0ZShfdGltZSwgX291dCk7XHJcblxyXG5cclxuICAgICAgLy8gaWYgKHRoaXMua2V5cy5sZW5ndGggPT0gMClcclxuICAgICAgLy8gICByZXR1cm4gdW5kZWZpbmVkOyAvL1RPRE86IHNob3VsZG4ndCByZXR1cm4gMCBidXQgc29tZXRoaW5nIGluZGljYXRpbmcgbm8gY2hhbmdlLCBsaWtlIG51bGwuIHByb2JhYmx5IG5lZWRzIHRvIGJlIGNoYW5nZWQgaW4gTm9kZSBhcyB3ZWxsIHRvIGlnbm9yZSBub24tbnVtZXJpYyB2YWx1ZXMgaW4gdGhlIGFwcGx5QW5pbWF0aW9uIGZ1bmN0aW9uXHJcbiAgICAgIC8vIGlmICh0aGlzLmtleXMubGVuZ3RoID09IDEgfHwgdGhpcy5rZXlzWzBdLnRpbWUgPj0gX3RpbWUpXHJcbiAgICAgIC8vICAgcmV0dXJuIHRoaXMua2V5c1swXS52YWx1ZTtcclxuXHJcblxyXG4gICAgICAvLyBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAvLyAgIGlmICh0aGlzLmtleXNbaV0udGltZSA8PSBfdGltZSAmJiBfdGltZSA8IHRoaXMua2V5c1tpICsgMV0udGltZSkge1xyXG4gICAgICAvLyAgICAgcmV0dXJuIHRoaXMua2V5c1tpXS5mdW5jdGlvbk91dC5ldmFsdWF0ZShfdGltZSk7XHJcbiAgICAgIC8vICAgfVxyXG4gICAgICAvLyAgIC8vIGlmICh0aGlzLmtleXNbaV0udGltZSA9PSBfdGltZSlcclxuICAgICAgLy8gICAvLyAgIHJldHVybiB0aGlzLmtleXNbaV0udmFsdWU7XHJcbiAgICAgIC8vIH1cclxuICAgICAgLy8gcmV0dXJuIHRoaXMua2V5c1t0aGlzLmtleXMubGVuZ3RoIC0gMV0udmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IGtleSB0byB0aGUgc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gX2tleSB0aGUga2V5IHRvIGFkZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkS2V5KF9rZXk6IEFuaW1hdGlvbktleTxUPik6IHZvaWQge1xyXG4gICAgICB0aGlzLmtleXMucHVzaChfa2V5KTtcclxuICAgICAgdGhpcy5rZXlzLnNvcnQoQW5pbWF0aW9uS2V5LmNvbXBhcmUpO1xyXG4gICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmeXMgYSBnaXZlbiBrZXkgaW4gdGhlIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIF9rZXkgdGhlIGtleSB0byBhZGRcclxuICAgICAqL1xyXG4gICAgcHVibGljIG1vZGlmeUtleShfa2V5OiBBbmltYXRpb25LZXk8VD4sIF90aW1lPzogbnVtYmVyLCBfdmFsdWU/OiBUKTogdm9pZCB7XHJcbiAgICAgIGlmIChfdGltZSAhPSBudWxsKVxyXG4gICAgICAgIF9rZXkudGltZSA9IF90aW1lO1xyXG4gICAgICBpZiAoX3ZhbHVlICE9IG51bGwpXHJcbiAgICAgICAgX2tleS52YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgdGhpcy5rZXlzLnNvcnQoQW5pbWF0aW9uS2V5LmNvbXBhcmUpO1xyXG4gICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBnaXZlbiBrZXkgZnJvbSB0aGUgc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gX2tleSB0aGUga2V5IHRvIHJlbW92ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlS2V5KF9rZXk6IEFuaW1hdGlvbktleTxUPik6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMua2V5c1tpXSA9PSBfa2V5KSB7XHJcbiAgICAgICAgICB0aGlzLmtleXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgdGhpcy5yZWdlbmVyYXRlRnVuY3Rpb25zKCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIGEga2V5IGluIHRoZSBzZXF1ZW5jZSBleGFjdGx5IG1hdGNoaW5nIHRoZSBnaXZlbiB0aW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZmluZEtleShfdGltZTogbnVtYmVyKTogQW5pbWF0aW9uS2V5PFQ+IHtcclxuICAgICAgZm9yIChsZXQga2V5IG9mIHRoaXMua2V5cylcclxuICAgICAgICBpZiAoa2V5LnRpbWUgPT0gX3RpbWUpXHJcbiAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIEFuaW1hdGlvbiBLZXkgYXQgdGhlIGdpdmVuIGluZGV4IGZyb20gdGhlIGtleXMuXHJcbiAgICAgKiBAcGFyYW0gX2luZGV4IHRoZSB6ZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIHJlbW92ZSB0aGUga2V5XHJcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVtb3ZlZCBBbmltYXRpb25LZXkgaWYgc3VjY2Vzc2Z1bCwgbnVsbCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZW1vdmVLZXlBdEluZGV4KF9pbmRleDogbnVtYmVyKTogQW5pbWF0aW9uS2V5PFQ+IHtcclxuICAgICAgaWYgKF9pbmRleCA8IDAgfHwgX2luZGV4ID49IHRoaXMua2V5cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBsZXQgYWs6IEFuaW1hdGlvbktleTxUPiA9IHRoaXMua2V5c1tfaW5kZXhdO1xyXG4gICAgICB0aGlzLmtleXMuc3BsaWNlKF9pbmRleCwgMSk7XHJcbiAgICAgIHRoaXMucmVnZW5lcmF0ZUZ1bmN0aW9ucygpO1xyXG4gICAgICByZXR1cm4gYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEga2V5IGZyb20gdGhlIHNlcXVlbmNlIGF0IHRoZSBkZXNpcmVkIGluZGV4LlxyXG4gICAgICogQHBhcmFtIF9pbmRleCB0aGUgemVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byBnZXQgdGhlIGtleVxyXG4gICAgICogQHJldHVybnMgdGhlIEFuaW1hdGlvbktleSBhdCB0aGUgaW5kZXggaWYgaXQgZXhpc3RzLCBudWxsIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEtleShfaW5kZXg6IG51bWJlcik6IEFuaW1hdGlvbktleTxUPiB7XHJcbiAgICAgIGlmIChfaW5kZXggPCAwIHx8IF9pbmRleCA+PSB0aGlzLmtleXMubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICByZXR1cm4gdGhpcy5rZXlzW19pbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgc2VxdWVuY2UncyBrZXlzLiBUaGlzIGlzIG5vdCBhIGNvcHksIGJ1dCB0aGUgYWN0dWFsIGFycmF5IHVzZWQgaW50ZXJuYWxseS4gSGFuZGxlIHdpdGggY2FyZSFcclxuICAgICAqIFVzZWQgYnkgRWRpdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0S2V5cygpOiBBbmltYXRpb25LZXk8VD5bXSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmtleXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHM6IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAga2V5czogW10sXHJcbiAgICAgICAgY2xhc3NUeXBlOiB0aGlzLmNsYXNzVHlwZS5uYW1lLFxyXG4gICAgICAgIGFuaW1hdGlvblNlcXVlbmNlOiB0cnVlXHJcbiAgICAgIH07XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzLmtleXNbaV0gPSB0aGlzLmtleXNbaV0uc2VyaWFsaXplKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmNsYXNzVHlwZSAhPSBudWxsKVxyXG4gICAgICAgIHRoaXMuY2xhc3NUeXBlID0gPEM+UmVmbGVjdC5nZXQoRnVkZ2VDb3JlLCBfc2VyaWFsaXphdGlvbi5jbGFzc1R5cGUpO1xyXG5cclxuICAgICAgdGhpcy5jbGFzc1R5cGUgPz89IDxDPjx1bmtub3duPk51bWJlcjtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF9zZXJpYWxpemF0aW9uLmtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyB0aGlzLmtleXMucHVzaCg8QW5pbWF0aW9uS2V5PlNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ua2V5c1tpXSkpO1xyXG4gICAgICAgIGxldCBrOiBBbmltYXRpb25LZXk8R2VuZXJhbD4gPSBuZXcgQW5pbWF0aW9uS2V5KCk7XHJcbiAgICAgICAgYXdhaXQgay5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5rZXlzW2ldKTtcclxuICAgICAgICB0aGlzLmtleXNbaV0gPSBrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnJlZ2VuZXJhdGVGdW5jdGlvbnMoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRoYXQgKHJlLSlnZW5lcmF0ZXMgYWxsIGZ1bmN0aW9ucyBpbiB0aGUgc2VxdWVuY2UuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCByZWdlbmVyYXRlRnVuY3Rpb25zKF9rZXlzOiBBbmltYXRpb25LZXk8VD5bXSA9IHRoaXMua2V5cyk6IHZvaWQge1xyXG4gICAgICBpZiAoX2tleXMubGVuZ3RoID09IDApXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLmNsYXNzVHlwZSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfTogTm8ga2V5IHR5cGUgc3BlY2lmaWVkLiBDYW5ub3QgZ2VuZXJhdGUgYW5pbWF0aW9uIGZ1bmN0aW9ucy5gKTtcclxuXHJcbiAgICAgIGNvbnN0IGZ1bmN0aW9uVHlwZTogbmV3ICguLi5fYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPHR5cGVvZiBBbmltYXRpb25GdW5jdGlvbj4pID0+IEFuaW1hdGlvbkZ1bmN0aW9uPFQ+ID0gUmVmbGVjdC5nZXQoRnVkZ2VDb3JlLCBBbmltYXRpb25GdW5jdGlvbi5uYW1lICsgdGhpcy5jbGFzc1R5cGUubmFtZSk7XHJcblxyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgX2tleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBrZXk6IEFuaW1hdGlvbktleTxUPiA9IF9rZXlzW2ldO1xyXG4gICAgICAgIGNvbnN0IGtleU5leHQ6IEFuaW1hdGlvbktleTxUPiA9IF9rZXlzW2kgKyAxXTtcclxuICAgICAgICBrZXkuZnVuY3Rpb25PdXQgPSBuZXcgZnVuY3Rpb25UeXBlKGtleSwga2V5TmV4dCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgeyAvKiAqLyB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHNlcXVlbmNlIG9mIHtAbGluayBBbmltYXRpb25LZXlOdW1iZXJ9cyBzYW1wbGVkIGZyb20gYW4gb3JpZ2luYWwgc2VxdWVuY2UuIEluIGEgc2FtcGxlZCBzZXF1ZW5jZSwgdGhlIGtleXMgYXJlIHN0b3JlZCBhdCBpbmRpY2VzIGNvcnJlc3BvbmRpbmcgdG8gZGlzY3JldGUgZnJhbWVzIGluIGFjY29yZGFuY2Ugd2l0aCB0aGUge0BsaW5rIEFuaW1hdGlvbn0ncyBmcmFtZXMgcGVyIHNlY29uZC5cclxuICAgKiBLZXlzIGZyb20gdGhlIG9yaWdpbmFsIHNlcXVlbmNlIG1heSBiZSByZWZlcmVuY2VkIHJlcGVhdGVkIHRpbWVzIGluIGEgc2FtcGxlZCBzZXF1ZW5jZS4gU2FtcGxlZCBzZXF1ZW5jZXMgYWxsb3cgTygxKSBhY2Nlc3MgdG8ga2V5cyBiYXNlZCBvbiB0aGUgZGVzaXJlZCBmcmFtZS4gXHJcbiAgICogQGF1dGhvcnMgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDI1XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvblNlcXVlbmNlU2FtcGxlZCBleHRlbmRzIEFuaW1hdGlvblNlcXVlbmNlIHtcclxuXHJcbiAgICAvKiogRXZhbHVhdGVzIHRoZSBzZXF1ZW5jZSBhdCB0aGUgZ2l2ZW4gZnJhbWUgYW5kIHRpbWUuICovXHJcbiAgICBwdWJsaWMgb3ZlcnJpZGUgZXZhbHVhdGUoX3RpbWU6IG51bWJlciwgX2ZyYW1lPzogbnVtYmVyLCBfb3V0PzogQW5pbWF0aW9uUmV0dXJuVHlwZSk6IEFuaW1hdGlvblJldHVyblR5cGUge1xyXG4gICAgICByZXR1cm4gdGhpcy5rZXlzW19mcmFtZV0/LmZ1bmN0aW9uT3V0LmV2YWx1YXRlKF90aW1lLCBfb3V0KTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgcmVnZW5lcmF0ZUZ1bmN0aW9ucyhfa2V5czogQW5pbWF0aW9uS2V5W10gPSB0aGlzLmtleXMpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVnZW5lcmF0ZUZ1bmN0aW9ucyhbLi4ubmV3IFNldChfa2V5cyldKTsgLy8gcmVtb3ZlIGR1cGxpY2F0ZXMsIGFzIHNhbXBsZWQgc2VxdWVuY2VzIG1heSBjb250YWluIHRoZSBzYW1lIGtleSByZXBlYXRlZCB0aW1lc1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIEBlbnVtZXJhdGVcclxuICBleHBvcnQgY2xhc3MgQW5pbWF0aW9uU3ByaXRlIGV4dGVuZHMgQW5pbWF0aW9uIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBBbmltYXRpb24ucmVnaXN0ZXJTdWJjbGFzcyhBbmltYXRpb25TcHJpdGUpO1xyXG4gICAgcHJpdmF0ZSBmcmFtZXM6IG51bWJlciA9IDI1O1xyXG4gICAgcHJpdmF0ZSB3cmFwQWZ0ZXI6IG51bWJlciA9IDU7XHJcbiAgICBwcml2YXRlIHN0YXJ0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoMCwgMCk7XHJcbiAgICBwcml2YXRlIHNpemU6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMig4MCwgODApO1xyXG4gICAgcHJpdmF0ZSBuZXh0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoODAsIDApO1xyXG4gICAgcHJpdmF0ZSB3cmFwOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoMCwgODApO1xyXG5cclxuICAgICN0ZXh0dXJlOiBUZXh0dXJlID0gVGV4dHVyZURlZmF1bHQuY29sb3I7XHJcblxyXG4gICAgLy8gVE9ETzogZnBzIHNob3VsZCBiZSBhIHBhcmFtZXRlciB0b29cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJBbmltYXRpb25TcHJpdGVcIikgeyAvL30sIF9mcHM6IG51bWJlciA9IDE1KSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lLCB7fSwgMSk7XHJcbiAgICAgIHRoaXMuZnJhbWVzUGVyU2Vjb25kID0gdGhpcy5mcmFtZXM7XHJcbiAgICAgIHRoaXMuY3JlYXRlKHRoaXMudGV4dHVyZSwgdGhpcy5mcmFtZXMsIHRoaXMud3JhcEFmdGVyLCB0aGlzLnN0YXJ0LCB0aGlzLnNpemUsIHRoaXMubmV4dCwgdGhpcy53cmFwLCB0aGlzLmZyYW1lc1BlclNlY29uZCk7XHJcbiAgICB9XHJcblxyXG4gICAgQGVudW1lcmF0ZVxyXG4gICAgQHR5cGUoVGV4dHVyZSlcclxuICAgIHB1YmxpYyBnZXQgdGV4dHVyZSgpOiBUZXh0dXJlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3RleHR1cmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHRleHR1cmUgdG8gYmUgdXNlZCBhcyB0aGUgc3ByaXRlc2hlZXRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCB0ZXh0dXJlKF90ZXh0dXJlOiBUZXh0dXJlKSB7XHJcbiAgICAgIHRoaXMuI3RleHR1cmUgPSBfdGV4dHVyZTtcclxuICAgICAgdGhpcy5jcmVhdGUodGhpcy50ZXh0dXJlLCB0aGlzLmZyYW1lcywgdGhpcy53cmFwQWZ0ZXIsIHRoaXMuc3RhcnQsIHRoaXMuc2l6ZSwgdGhpcy5uZXh0LCB0aGlzLndyYXAsIHRoaXMuZnJhbWVzUGVyU2Vjb25kKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhpcyBhbmltYXRpb24gc3ByaXRlIGZyb20gdGhlIGdpdmVuIGFyZ3VtZW50c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlKF90ZXh0dXJlOiBUZXh0dXJlLCBfZnJhbWVzOiBudW1iZXIsIF93cmFwQWZ0ZXI6IG51bWJlciwgX3N0YXJ0OiBWZWN0b3IyLCBfc2l6ZTogVmVjdG9yMiwgX25leHQ6IFZlY3RvcjIsIF93cmFwOiBWZWN0b3IyLCBfZnJhbWVzUGVyU2Vjb25kOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jdGV4dHVyZSA9IF90ZXh0dXJlO1xyXG4gICAgICB0aGlzLmZyYW1lcyA9IF9mcmFtZXM7XHJcbiAgICAgIHRoaXMud3JhcEFmdGVyID0gX3dyYXBBZnRlcjtcclxuICAgICAgdGhpcy5zdGFydCA9IF9zdGFydDtcclxuICAgICAgdGhpcy5zaXplID0gX3NpemU7XHJcbiAgICAgIHRoaXMubmV4dCA9IF9uZXh0O1xyXG4gICAgICB0aGlzLndyYXAgPSBfd3JhcDtcclxuICAgICAgdGhpcy5mcmFtZXNQZXJTZWNvbmQgPSBfZnJhbWVzUGVyU2Vjb25kO1xyXG5cclxuICAgICAgbGV0IHNjYWxlOiBWZWN0b3IyID0gdGhpcy5nZXRTY2FsZSgpO1xyXG4gICAgICBsZXQgcG9zaXRpb25zOiBWZWN0b3IyW10gPSB0aGlzLmdldFBvc2l0aW9ucygpO1xyXG5cclxuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IGFuZCB1c2UgQW5pbWF0aW9uU2VxdWVuY2U8VmVjdG9yMj4/XHJcbiAgICAgIGxldCB4VHJhbnNsYXRpb25LZXlzOiBBbmltYXRpb25LZXk8bnVtYmVyPltdID0gbmV3IEFycmF5KHRoaXMuZnJhbWVzICsgMSk7XHJcbiAgICAgIGxldCB5VHJhbnNsYXRpb25LZXlzOiBBbmltYXRpb25LZXk8bnVtYmVyPltdID0gbmV3IEFycmF5KHRoaXMuZnJhbWVzICsgMSk7XHJcblxyXG4gICAgICBmb3IgKGxldCBmcmFtZTogbnVtYmVyID0gMDsgZnJhbWUgPD0gdGhpcy5mcmFtZXM7IGZyYW1lKyspIHtcclxuICAgICAgICBsZXQgdGltZTogbnVtYmVyID0gMTAwMCAqIGZyYW1lIC8gdGhpcy5mcmFtZXNQZXJTZWNvbmQ7XHJcbiAgICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IyID0gcG9zaXRpb25zW01hdGgubWluKGZyYW1lLCB0aGlzLmZyYW1lcyAtIDEpXTsgLy9yZXBlYXQgdGhlIGxhc3Qga2V5IHRvIGdpdmUgdGhlIGxhc3QgZnJhbWUgc29tZSB0aW1lXHJcbiAgICAgICAgeFRyYW5zbGF0aW9uS2V5c1tmcmFtZV0gPSBuZXcgQW5pbWF0aW9uS2V5KHRpbWUsIHBvc2l0aW9uLnggLyB0aGlzLiN0ZXh0dXJlLnRleEltYWdlU291cmNlLndpZHRoLCBBTklNQVRJT05fSU5URVJQT0xBVElPTi5DT05TVEFOVCk7XHJcbiAgICAgICAgeVRyYW5zbGF0aW9uS2V5c1tmcmFtZV0gPSBuZXcgQW5pbWF0aW9uS2V5KHRpbWUsIHBvc2l0aW9uLnkgLyB0aGlzLiN0ZXh0dXJlLnRleEltYWdlU291cmNlLmhlaWdodCwgQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04uQ09OU1RBTlQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgeFRyYW5zbGF0aW9uOiBBbmltYXRpb25TZXF1ZW5jZTxudW1iZXI+ID0gbmV3IEFuaW1hdGlvblNlcXVlbmNlKHhUcmFuc2xhdGlvbktleXMsIE51bWJlcik7XHJcbiAgICAgIGxldCB5VHJhbnNsYXRpb246IEFuaW1hdGlvblNlcXVlbmNlPG51bWJlcj4gPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2UoeVRyYW5zbGF0aW9uS2V5cywgTnVtYmVyKTtcclxuICAgICAgbGV0IHhTY2FsZTogQW5pbWF0aW9uU2VxdWVuY2U8bnVtYmVyPiA9IG5ldyBBbmltYXRpb25TZXF1ZW5jZShbbmV3IEFuaW1hdGlvbktleSgwLCBzY2FsZS54LCBBTklNQVRJT05fSU5URVJQT0xBVElPTi5DT05TVEFOVCldLCBOdW1iZXIpO1xyXG4gICAgICBsZXQgeVNjYWxlOiBBbmltYXRpb25TZXF1ZW5jZTxudW1iZXI+ID0gbmV3IEFuaW1hdGlvblNlcXVlbmNlKFtuZXcgQW5pbWF0aW9uS2V5KDAsIHNjYWxlLnksIEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkNPTlNUQU5UKV0sIE51bWJlcik7XHJcblxyXG4gICAgICB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZSA9IHtcclxuICAgICAgICBcImNvbXBvbmVudHNcIjoge1xyXG4gICAgICAgICAgXCJDb21wb25lbnRNYXRlcmlhbFwiOiBbe1xyXG4gICAgICAgICAgICBcIm10eFBpdm90XCI6IHtcclxuICAgICAgICAgICAgICBcInRyYW5zbGF0aW9uXCI6IHtcclxuICAgICAgICAgICAgICAgIHg6IHhUcmFuc2xhdGlvbixcclxuICAgICAgICAgICAgICAgIHk6IHlUcmFuc2xhdGlvblxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgXCJzY2FsaW5nXCI6IHtcclxuICAgICAgICAgICAgICAgIHg6IHhTY2FsZSxcclxuICAgICAgICAgICAgICAgIHk6IHlTY2FsZVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfV1cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmNhbGN1bGF0ZVRvdGFsVGltZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2NhbGUgb2YgdGhlIHNwcml0ZXNoZWV0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTY2FsZSgpOiBWZWN0b3IyIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIHRoaXMuc2l6ZS54IC8gdGhpcy4jdGV4dHVyZS50ZXhJbWFnZVNvdXJjZS53aWR0aCxcclxuICAgICAgICB0aGlzLnNpemUueSAvIHRoaXMuI3RleHR1cmUudGV4SW1hZ2VTb3VyY2UuaGVpZ2h0XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbnMgb2YgdGhlIHNwcml0ZXNoZWV0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQb3NpdGlvbnMoKTogVmVjdG9yMltdIHtcclxuICAgICAgbGV0IGlOZXh0OiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgaVdyYXA6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCBwb3NpdGlvbnM6IFZlY3RvcjJbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBmcmFtZTogbnVtYmVyID0gMDsgZnJhbWUgPCB0aGlzLmZyYW1lczsgZnJhbWUrKykge1xyXG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKG5ldyBWZWN0b3IyKFxyXG4gICAgICAgICAgdGhpcy5zdGFydC54ICsgaU5leHQgKiB0aGlzLm5leHQueCArIGlXcmFwICogdGhpcy53cmFwLngsXHJcbiAgICAgICAgICB0aGlzLnN0YXJ0LnkgKyBpTmV4dCAqIHRoaXMubmV4dC55ICsgaVdyYXAgKiB0aGlzLndyYXAueVxyXG4gICAgICAgICkpO1xyXG5cclxuICAgICAgICBpTmV4dCsrO1xyXG4gICAgICAgIGlmIChpTmV4dCA+PSB0aGlzLndyYXBBZnRlcikge1xyXG4gICAgICAgICAgaU5leHQgPSAwO1xyXG4gICAgICAgICAgaVdyYXArKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHBvc2l0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gdHJhbnNmZXJcclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb24/OiBzdHJpbmdbXSwgX2Rpc3BhdGNoTXV0YXRlPzogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBzdXBlci5tdXRhdGUoX211dGF0b3IsIF9zZWxlY3Rpb24sIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKHRoaXMudGV4dHVyZSwgdGhpcy5mcmFtZXMsIHRoaXMud3JhcEFmdGVyLCB0aGlzLnN0YXJ0LCB0aGlzLnNpemUsIHRoaXMubmV4dCwgdGhpcy53cmFwLCB0aGlzLmZyYW1lc1BlclNlY29uZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pZFJlc291cmNlID0gdGhpcy5pZFJlc291cmNlO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmlkVGV4dHVyZSA9IHRoaXMuI3RleHR1cmUuaWRSZXNvdXJjZTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5mcmFtZXMgPSB0aGlzLmZyYW1lcztcclxuICAgICAgc2VyaWFsaXphdGlvbi53cmFwQWZ0ZXIgPSB0aGlzLndyYXBBZnRlcjtcclxuICAgICAgZm9yIChsZXQgbmFtZSBvZiBbXCJzdGFydFwiLCBcInNpemVcIiwgXCJuZXh0XCIsIFwid3JhcFwiXSlcclxuICAgICAgICBzZXJpYWxpemF0aW9uW25hbWVdID0gKDxWZWN0b3IyPlJlZmxlY3QuZ2V0KHRoaXMsIG5hbWUpKS5zZXJpYWxpemUoKTtcclxuXHJcbiAgICAgIGxldCBhbmltYXRpb25zU3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSB0aGlzLmFuaW1hdGlvblN0cnVjdHVyZTtcclxuICAgICAgdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUgPSB7fTsgLy8gbm8gbmVlZCB0byBzZXJpYWxpemUgc3RydWN0dXJlXHJcbiAgICAgIC8vIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgdGhpcy5hbmltYXRpb25TdHJ1Y3R1cmUgPSBhbmltYXRpb25zU3RydWN0dXJlOyAvLyByZXN0b3JlIGV4aXN0ZW50IHN0cnVjdHVyZVxyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi5pZFRleHR1cmUpXHJcbiAgICAgICAgdGhpcy4jdGV4dHVyZSA9IDxUZXh0dXJlPmF3YWl0IFByb2plY3QuZ2V0UmVzb3VyY2UoX3NlcmlhbGl6YXRpb24uaWRUZXh0dXJlKTtcclxuXHJcbiAgICAgIGZvciAobGV0IG5hbWUgb2YgW1wic3RhcnRcIiwgXCJzaXplXCIsIFwibmV4dFwiLCBcIndyYXBcIl0pXHJcbiAgICAgICAgKDxWZWN0b3IyPlJlZmxlY3QuZ2V0KHRoaXMsIG5hbWUpKS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltuYW1lXSk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKHRoaXMudGV4dHVyZSwgX3NlcmlhbGl6YXRpb24uZnJhbWVzLCBfc2VyaWFsaXphdGlvbi53cmFwQWZ0ZXIsIHRoaXMuc3RhcnQsIHRoaXMuc2l6ZSwgdGhpcy5uZXh0LCB0aGlzLndyYXAsIHRoaXMuZnJhbWVzUGVyU2Vjb25kKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSB7QGxpbmsgQW5pbWF0aW9uU3ByaXRlfSBpbnRvIGFuIHtAbGluayBBbmltYXRpb259XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb252ZXJ0VG9BbmltYXRpb24oKTogQW5pbWF0aW9uIHtcclxuICAgICAgbGV0IGFuaW1hdGlvbjogQW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbih0aGlzLm5hbWUsIHRoaXMuYW5pbWF0aW9uU3RydWN0dXJlLCB0aGlzLmZyYW1lc1BlclNlY29uZCk7XHJcbiAgICAgIHJldHVybiBhbmltYXRpb247XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gbmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbi8vICAgZXhwb3J0IGNsYXNzIEFuaW1hdGlvblRhcmdldEJpbmRpbmcge1xyXG5cclxuLy8gICAgIHB1YmxpYyBwYXRoOiBzdHJpbmc7XHJcbi8vICAgICBwdWJsaWMgcGFyc2VkUGF0aDogc3RyaW5nW107XHJcblxyXG4vLyAgICAgcHVibGljIG5vZGU6IE5vZGU7XHJcbi8vICAgICBwdWJsaWMgY29tcG9uZW50OiBDb21wb25lbnQ7XHJcbiAgICBcclxuLy8gICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihfcm9vdE5vZGU6IE5vZGUsIF9wYXRoOiBzdHJpbmcpIHtcclxuLy8gICAgICAgdGhpcy5wYXRoID0gX3BhdGg7XHJcbi8vICAgICAgIHRoaXMucGFyc2VkUGF0aCA9IEFuaW1hdGlvblRhcmdldEJpbmRpbmcucGFyc2VQYXRoKF9wYXRoKTtcclxuLy8gICAgIH1cclxuXHJcbi8vICAgICBwdWJsaWMgc3RhdGljIHBhcnNlUGF0aChfcGF0aDogc3RyaW5nKTogc3RyaW5nW10ge1xyXG4vLyAgICAgICByZXR1cm4gX3BhdGguc3BsaXQoXCIvXCIpO1xyXG4vLyAgICAgfVxyXG5cclxuLy8gICAgIC8qKlxyXG4vLyAgICAgICogQGV4YW1wbGUgXCJub2RlL3BhcmVudC9jaGlsZHJlbi8xL2NvbXBvbmVudHMvQ29tcG9uZW50U2tlbGV0b24vMFwiXHJcbi8vICAgICAgKi9cclxuLy8gICAgIHB1YmxpYyBzdGF0aWMgZmluZFRhcmdldChfcm9vdE5vZGU6IE5vZGUsIF9wYXRoOiBzdHJpbmcpOiBOb2RlIHtcclxuLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xyXG4vLyAgICAgfVxyXG5cclxuLy8gICAgIHB1YmxpYyBiaW5kKCk6IHZvaWQge1xyXG4vLyAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XHJcbi8vICAgICB9XHJcblxyXG4vLyAgICAgcHVibGljIHVuYmluZCgpOiB2b2lkIHtcclxuLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xyXG4vLyAgICAgfVxyXG5cclxuLy8gICAgIHB1YmxpYyBnZXRWYWx1ZSgpOiB1bmtub3duIHtcclxuLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xyXG4vLyAgICAgfVxyXG5cclxuLy8gICAgIHB1YmxpYyBzZXRWYWx1ZShfdmFsdWU6IHVua25vd24pOiB2b2lkIHtcclxuLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH1cclxuLy8gfSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEV4dGVuc2lvbiBvZiBBdWRpb0J1ZmZlciB3aXRoIGEgbG9hZCBtZXRob2QgdGhhdCBjcmVhdGVzIGEgYnVmZmVyIGluIHRoZSB7QGxpbmsgQXVkaW9NYW5hZ2VyfS5kZWZhdWx0IHRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgQ29tcG9uZW50QXVkaW99XHJcbiAgICogQGF1dGhvcnMgVGhvbWFzIERvcm5lciwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjBcclxuICAgKi9cclxuICBAU2VyaWFsaXphYmxlUmVzb3VyY2UucmVnaXN0ZXJcclxuICBleHBvcnQgY2xhc3MgQXVkaW8gZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlUmVzb3VyY2Uge1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZyA9IFwiQXVkaW9cIjtcclxuICAgIHB1YmxpYyBpZFJlc291cmNlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICBwdWJsaWMgYnVmZmVyOiBBdWRpb0J1ZmZlciA9IHVuZGVmaW5lZDtcclxuICAgIHB1YmxpYyBwYXRoOiBVUkwgPSB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIHVybDogUmVxdWVzdEluZm8gPSB1bmRlZmluZWQ7XHJcbiAgICBwcml2YXRlIHJlYWR5OiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF91cmw/OiBSZXF1ZXN0SW5mbykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICBpZiAoX3VybCkge1xyXG4gICAgICAgIHRoaXMubG9hZChfdXJsKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBfdXJsLnRvU3RyaW5nKCkuc3BsaXQoXCIvXCIpLnBvcCgpO1xyXG4gICAgICB9XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpc1JlYWR5KCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5yZWFkeTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFzeW5jaHJvbm91c2x5IGxvYWRzIHRoZSBhdWRpbyAobXAzKSBmcm9tIHRoZSBnaXZlbiB1cmxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGxvYWQoX3VybDogUmVxdWVzdEluZm8pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgRGVidWcuZnVkZ2UoXCJBdWRpb0xvYWRcIiwgX3VybCk7XHJcbiAgICAgIHRoaXMudXJsID0gX3VybDtcclxuICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnBhdGggPSBuZXcgVVJMKHRoaXMudXJsLnRvU3RyaW5nKCksIFByb2plY3QuYmFzZVVSTCk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlOiBSZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5mZXRjaCh0aGlzLnBhdGgudG9TdHJpbmcoKSk7XHJcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyOiBBcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgIGxldCBidWZmZXI6IEF1ZGlvQnVmZmVyID0gYXdhaXQgQXVkaW9NYW5hZ2VyLmRlZmF1bHQuZGVjb2RlQXVkaW9EYXRhKGFycmF5QnVmZmVyKTtcclxuICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5UX0FVRElPLlJFQURZKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHVybDogdGhpcy51cmwsXHJcbiAgICAgICAgaWRSZXNvdXJjZTogdGhpcy5pZFJlc291cmNlLFxyXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB0eXBlOiB0aGlzLnR5cGVcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIFByb2plY3QucmVnaXN0ZXIodGhpcywgX3NlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMubG9hZChfc2VyaWFsaXphdGlvbi51cmwpO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfc2VyaWFsaXphdGlvbi5uYW1lO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uPzogc3RyaW5nW10sIF9kaXNwYXRjaE11dGF0ZT86IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgbGV0IHVybDogc3RyaW5nID0gX211dGF0b3IudXJsOyAvLyBzYXZlIHVybCBmb3IgcmVjb25zdHJ1Y3Rpb24gYWZ0ZXIgZXhjbHVzaW9uXHJcbiAgICAgIGlmIChfbXV0YXRvci51cmwgIT0gdGhpcy51cmwudG9TdHJpbmcoKSlcclxuICAgICAgICB0aGlzLmxvYWQoX211dGF0b3IudXJsKTtcclxuICAgICAgLy8gZXhjZXB0IHVybCBmcm9tIG11dGF0b3IgZm9yIGZ1cnRoZXIgcHJvY2Vzc2luZ1xyXG4gICAgICBkZWxldGUgKF9tdXRhdG9yLnVybCk7XHJcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgICAgLy8gcmVjb25zdHJ1Y3QsIGZvciBtdXRhdG9yIG1heSBiZSBrZXB0IGJ5IGNhbGxlclxyXG4gICAgICBSZWZsZWN0LnNldChfbXV0YXRvciwgXCJ1cmxcIiwgdXJsKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICAvLyBkZWxldGUgX211dGF0b3IuaWRSZXNvdXJjZTsgXHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5yZWFkeTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX0FVRElPIHtcclxuICAgIC8qKiBicm9hZGNhc3QgdG8gYSB7QGxpbmsgTm9kZX0gYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMgaW4gdGhlIGdyYXBoIGFmdGVyIGl0IHdhcyBhcHBlbmRlZCB0byBhIHBhcmVudCAqL1xyXG4gICAgQ0hJTERfQVBQRU5EID0gXCJjaGlsZEFwcGVuZFRvQXVkaW9HcmFwaFwiLFxyXG4gICAgLyoqIGJyb2FkY2FzdCB0byBhIHtAbGluayBOb2RlfSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cyBpbiB0aGUgZ3JhcGgganVzdCBiZWZvcmUgaXRzIGJlaW5nIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50ICovXHJcbiAgICBDSElMRF9SRU1PVkUgPSBcImNoaWxkUmVtb3ZlRnJvbUF1ZGlvR3JhcGhcIixcclxuICAgIC8qKiBicm9hZGNhc3QgdG8gYSB7QGxpbmsgTm9kZX0gYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMgaW4gdGhlIGdyYXBoIHRvIHVwZGF0ZSB0aGUgcGFubmVycyBpbiBBdWRpb0NvbXBvbmVudHMgKi9cclxuICAgIFVQREFURSA9IFwidXBkYXRlQXVkaW9HcmFwaFwiLFxyXG4gICAgLyoqIGZpcmVkIHdoZW4gdGhlIGF1ZGlvIGZpbGUgd2FzIGxvYWRlZCBhbmQgaXMgcmVhZHkgZm9yIHBsYXlpbmcgKi9cclxuICAgIFJFQURZID0gXCJyZWFkeVwiLFxyXG4gICAgLyoqIGZpcmVkIHdoZW4gdGhlIGVuZCBvZiB0aGUgYXVkaW8gaXMgcmVhY2hlZCB3aGlsZSBwbGF5aW5nICovXHJcbiAgICBFTkRFRCA9IFwiZW5kZWRcIlxyXG4gIH1cclxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIi4uL0V2ZW50L0V2ZW50QXVkaW8udHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEV4dGVuZHMgdGhlIHN0YW5kYXJkIEF1ZGlvQ29udGV4dCBmb3IgaW50ZWdyYXRpb24gd2l0aCBGVURHRS1ncmFwaHMuXHJcbiAgICogQ3JlYXRlcyBhIGRlZmF1bHQgb2JqZWN0IGF0IHN0YXJ0dXAgdG8gYmUgYWRkcmVzc2VkIGFzIEF1ZGlvTWFuYWdlciBkZWZhdWx0LlxyXG4gICAqIE90aGVyIG9iamVjdHMgb2YgdGhpcyBjbGFzcyBtYXkgYmUgY3JlYXRlIGZvciBzcGVjaWFsIHB1cnBvc2VzLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBBdWRpb01hbmFnZXIgZXh0ZW5kcyBBdWRpb0NvbnRleHQge1xyXG4gICAgLyoqIFRoZSBkZWZhdWx0IGNvbnRleHQgdGhhdCBtYXkgYmUgdXNlZCB0aHJvdWdob3V0IHRoZSBwcm9qZWN0IHdpdGhvdXQgdGhlIG5lZWQgdG8gY3JlYXRlIG90aGVycyAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBkZWZhdWx0OiBBdWRpb01hbmFnZXIgPSBuZXcgQXVkaW9NYW5hZ2VyKHsgbGF0ZW5jeUhpbnQ6IFwiaW50ZXJhY3RpdmVcIiwgc2FtcGxlUmF0ZTogNDQxMDAgfSk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBldmVudFVwZGF0ZTogRXZlbnQgPSBuZXcgRXZlbnQoRVZFTlRfQVVESU8uVVBEQVRFKTtcclxuICAgIC8qKiBUaGUgbWFzdGVyIHZvbHVtZSBhbGwgQXVkaW9Ob2RlcyBpbiB0aGUgY29udGV4dCBzaG91bGQgYXR0YWNoIHRvICovXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgZ2FpbjogR2Fpbk5vZGU7XHJcbiAgICBwcml2YXRlIGdyYXBoOiBOb2RlID0gbnVsbDtcclxuICAgIHByaXZhdGUgY21wTGlzdGVuZXI6IENvbXBvbmVudEF1ZGlvTGlzdGVuZXIgPSBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfY29udGV4dE9wdGlvbnM/OiBBdWRpb0NvbnRleHRPcHRpb25zKSB7XHJcbiAgICAgIHN1cGVyKF9jb250ZXh0T3B0aW9ucyk7XHJcbiAgICAgIHRoaXMuZ2FpbiA9IHRoaXMuY3JlYXRlR2FpbigpO1xyXG4gICAgICB0aGlzLmdhaW4uY29ubmVjdCh0aGlzLmRlc3RpbmF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbWFzdGVyIHZvbHVtZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IHZvbHVtZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbWFzdGVyIHZvbHVtZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHZvbHVtZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIEZVREdFLWdyYXBoIHRvIGxpc3RlbiB0by4gRWFjaCB7QGxpbmsgQ29tcG9uZW50QXVkaW99IGluIHRoZSBncmFwaCB3aWxsIGNvbm5lY3QgdG8gdGhpcyBjb250ZXh0cyBtYXN0ZXIgZ2FpbiwgYWxsIG90aGVycyBkaXNjb25uZWN0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbGlzdGVuVG8gPSAoX2dyYXBoOiBOb2RlIHwgbnVsbCk6IHZvaWQgPT4ge1xyXG4gICAgICBpZiAodGhpcy5ncmFwaClcclxuICAgICAgICB0aGlzLmdyYXBoLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVF9BVURJTy5DSElMRF9SRU1PVkUpKTtcclxuICAgICAgaWYgKCFfZ3JhcGgpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB0aGlzLmdyYXBoID0gX2dyYXBoO1xyXG4gICAgICB0aGlzLmdyYXBoLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVF9BVURJTy5DSElMRF9BUFBFTkQpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgRlVER0UtZ3JhcGggY3VycmVudGx5IGxpc3RlbmluZyB0b1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0R3JhcGhMaXN0ZW5pbmdUbyA9ICgpOiBOb2RlID0+IHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ3JhcGg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB7QGxpbmsgQ29tcG9uZW50QXVkaW9MaXN0ZW5lcn0gdGhhdCBzZXJ2ZXMgdGhlIHNwYXRpYWwgbG9jYXRpb24gYW5kIG9yaWVudGF0aW9uIGZvciB0aGlzIGNvbnRleHRzIGxpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBsaXN0ZW5XaXRoID0gKF9jbXBMaXN0ZW5lcjogQ29tcG9uZW50QXVkaW9MaXN0ZW5lciB8IG51bGwpOiB2b2lkID0+IHtcclxuICAgICAgdGhpcy5jbXBMaXN0ZW5lciA9IF9jbXBMaXN0ZW5lcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBzcGF0aWFsIHNldHRpbmdzIG9mIHRoZSBBdWRpb05vZGVzIGVmZmVjdGVkIGluIHRoZSBjdXJyZW50IEZVREdFLWdyYXBoXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1cGRhdGUgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9IFwicnVubmluZ1wiKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgLy8gdGhpcy5ncmFwaC5icm9hZGNhc3RFdmVudChuZXcgRXZlbnQoRVZFTlRfQVVESU8uVVBEQVRFKSk7XHJcbiAgICAgIHRoaXMuZ3JhcGguYnJvYWRjYXN0RXZlbnQoQXVkaW9NYW5hZ2VyLmV2ZW50VXBkYXRlKTtcclxuICAgICAgaWYgKHRoaXMuY21wTGlzdGVuZXIpXHJcbiAgICAgICAgdGhpcy5jbXBMaXN0ZW5lci51cGRhdGUodGhpcy5saXN0ZW5lcik7XHJcbiAgICB9O1xyXG4gIH1cclxufSIsIi8vIG5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gICAgXHJcbi8vICAgICAvKipcclxuLy8gICAgICAqIEVudW1lcmF0b3IgZm9yIGFsbCBwb3NzaWJsZSBPc2NpbGxhdG9yIFR5cGVzXHJcbi8vICAgICAgKi9cclxuLy8gICAgIHR5cGUgT1NDSUxMQVRPUl9UWVBFID0gXCJzaW5lXCIgfCBcInNxdWFyZVwiIHwgXCJzYXd0b290aFwiIHwgXCJ0cmlhbmdsZVwiIHwgXCJjdXN0b21cIjtcclxuXHJcbi8vICAgICAvKipcclxuLy8gICAgICAqIEludGVyZmFjZSB0byBjcmVhdGUgQ3VzdG9tIE9zY2lsbGF0b3IgVHlwZXMuXHJcbi8vICAgICAgKiBTdGFydC0vRW5kcG9pbnQgb2YgYSBjdXN0dW0gY3VydmUgZS5nLiBzaW5lIGN1cnZlLlxyXG4vLyAgICAgICogQm90aCBwYXJhbWV0ZXJzIG5lZWQgdG8gYmUgaW5iZXR3ZWVuIC0xIGFuZCAxLlxyXG4vLyAgICAgICogQHBhcmFtIHN0YXJ0cG9pbnQgc3RhcnRwb2ludCBvZiBhIGN1cnZlIFxyXG4vLyAgICAgICogQHBhcmFtIGVuZHBvaW50IEVuZHBvaW50IG9mIGEgY3VydmUgXHJcbi8vICAgICAgKi9cclxuLy8gICAgIGludGVyZmFjZSBPc2NpbGxhdG9yV2F2ZSB7XHJcbi8vICAgICAgICAgc3RhcnRwb2ludDogbnVtYmVyO1xyXG4vLyAgICAgICAgIGVuZHBvaW50OiBudW1iZXI7XHJcbi8vICAgICB9XHJcbi8vICAgICAvKipcclxuLy8gICAgICAqIEFkZCBhbiB7QGxpbmsgQXVkaW9GaWx0ZXJ9IHRvIGFuIHtAbGluayBBdWRpb11dXHJcbi8vICAgICAgKiBAYXV0aG9ycyBUaG9tYXMgRG9ybmVyLCBIRlUsIDIwMTlcclxuLy8gICAgICAqL1xyXG4vLyAgICAgZXhwb3J0IGNsYXNzIEF1ZGlvT3NjaWxsYXRvciB7XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBhdWRpb09zY2lsbGF0b3I6IE9zY2lsbGF0b3JOb2RlOyBcclxuXHJcbi8vICAgICAgICAgcHJpdmF0ZSBmcmVxdWVuY3k6IG51bWJlcjtcclxuLy8gICAgICAgICBwcml2YXRlIG9zY2lsbGF0b3JUeXBlOiBPU0NJTExBVE9SX1RZUEU7XHJcbi8vICAgICAgICAgcHJpdmF0ZSBvc2NpbGxhdG9yV2F2ZTogUGVyaW9kaWNXYXZlO1xyXG5cclxuLy8gICAgICAgICBwcml2YXRlIGxvY2FsR2FpbjogR2Fpbk5vZGU7XHJcbi8vICAgICAgICAgcHJpdmF0ZSBsb2NhbEdhaW5WYWx1ZTogbnVtYmVyO1xyXG5cclxuLy8gICAgICAgICBjb25zdHJ1Y3RvcihfYXVkaW9TZXR0aW5nczogQXVkaW9TZXR0aW5ncywgX29zY2lsbGF0b3JUeXBlPzogT1NDSUxMQVRPUl9UWVBFKSB7XHJcbi8vICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yID0gX2F1ZGlvU2V0dGluZ3MuZ2V0QXVkaW9Db250ZXh0KCkuY3JlYXRlT3NjaWxsYXRvcigpO1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2FpbiA9IF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZUdhaW4oKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5vc2NpbGxhdG9yVHlwZSA9IF9vc2NpbGxhdG9yVHlwZTtcclxuLy8gICAgICAgICAgICAgaWYgKHRoaXMub3NjaWxsYXRvclR5cGUgIT0gXCJjdXN0b21cIikge1xyXG4vLyAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3IudHlwZSA9IHRoaXMub3NjaWxsYXRvclR5cGU7XHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgZWxzZSB7XHJcbi8vICAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3NjaWxsYXRvcldhdmUpIHtcclxuLy8gICAgICAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvT3NjaWxsYXRvci5zZXRQZXJpb2RpY1dhdmUodGhpcy5vc2NpbGxhdG9yV2F2ZSk7XHJcbi8vICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgICAgICBlbHNlIHtcclxuLy8gICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWF0ZSBhIEN1c3RvbSBQZXJpb2RpYyBXYXZlIGZpcnN0IHRvIHVzZSBDdXN0b20gVHlwZVwiKTtcclxuLy8gICAgICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIHNldE9zY2lsbGF0b3JUeXBlKF9vc2NpbGxhdG9yVHlwZTogT1NDSUxMQVRPUl9UWVBFKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIGlmICh0aGlzLm9zY2lsbGF0b3JUeXBlICE9IFwiY3VzdG9tXCIpIHtcclxuLy8gICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Pc2NpbGxhdG9yLnR5cGUgPSB0aGlzLm9zY2lsbGF0b3JUeXBlO1xyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgIGVsc2Uge1xyXG4vLyAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9zY2lsbGF0b3JXYXZlKSB7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3Iuc2V0UGVyaW9kaWNXYXZlKHRoaXMub3NjaWxsYXRvcldhdmUpO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgZ2V0T3NjaWxsYXRvclR5cGUoKTogT1NDSUxMQVRPUl9UWVBFIHtcclxuLy8gICAgICAgICAgICAgcmV0dXJuIHRoaXMub3NjaWxsYXRvclR5cGU7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgY3JlYXRlUGVyaW9kaWNXYXZlKF9hdWRpb1NldHRpbmdzOiBBdWRpb1NldHRpbmdzLCBfcmVhbDogT3NjaWxsYXRvcldhdmUsIF9pbWFnOiBPc2NpbGxhdG9yV2F2ZSk6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICBsZXQgd2F2ZVJlYWw6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbi8vICAgICAgICAgICAgIHdhdmVSZWFsWzBdID0gX3JlYWwuc3RhcnRwb2ludDtcclxuLy8gICAgICAgICAgICAgd2F2ZVJlYWxbMV0gPSBfcmVhbC5lbmRwb2ludDtcclxuXHJcbi8vICAgICAgICAgICAgIGxldCB3YXZlSW1hZzogRmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuLy8gICAgICAgICAgICAgd2F2ZUltYWdbMF0gPSBfaW1hZy5zdGFydHBvaW50O1xyXG4vLyAgICAgICAgICAgICB3YXZlSW1hZ1sxXSA9IF9pbWFnLmVuZHBvaW50O1xyXG5cclxuLy8gICAgICAgICAgICAgdGhpcy5vc2NpbGxhdG9yV2F2ZSA9IF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmNyZWF0ZVBlcmlvZGljV2F2ZSh3YXZlUmVhbCwgd2F2ZUltYWcpO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIHNldExvY2FsR2FpbihfbG9jYWxHYWluOiBHYWluTm9kZSk6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2FpbiA9IF9sb2NhbEdhaW47XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgZ2V0TG9jYWxHYWluKCk6IEdhaW5Ob2RlIHtcclxuLy8gICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxHYWluO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIHNldExvY2FsR2FpblZhbHVlKF9sb2NhbEdhaW5WYWx1ZTogbnVtYmVyKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluVmFsdWUgPSBfbG9jYWxHYWluVmFsdWU7XHJcbi8vICAgICAgICAgICAgIHRoaXMubG9jYWxHYWluLmdhaW4udmFsdWUgPSB0aGlzLmxvY2FsR2FpblZhbHVlO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIGdldExvY2FsR2FpblZhbHVlKCk6IG51bWJlciB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsR2FpblZhbHVlO1xyXG4vLyAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgcHVibGljIHNldEZyZXF1ZW5jeShfYXVkaW9TZXR0aW5nczogQXVkaW9TZXR0aW5ncywgX2ZyZXF1ZW5jeTogbnVtYmVyKTogdm9pZCB7XHJcbi8vICAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gX2ZyZXF1ZW5jeTtcclxuLy8gICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3IuZnJlcXVlbmN5LnNldFZhbHVlQXRUaW1lKHRoaXMuZnJlcXVlbmN5LCBfYXVkaW9TZXR0aW5ncy5nZXRBdWRpb0NvbnRleHQoKS5jdXJyZW50VGltZSk7XHJcbi8vICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICBwdWJsaWMgZ2V0RnJlcXVlbmN5KCk6IG51bWJlciB7XHJcbi8vICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyZXF1ZW5jeTtcclxuLy8gICAgICAgICB9XHJcblxyXG4vLyAgICAgICAgIHB1YmxpYyBjcmVhdGVTbmFyZShfYXVkaW9TZXR0aW5nczogQXVkaW9TZXR0aW5ncyk6IHZvaWQge1xyXG4vLyAgICAgICAgICAgICB0aGlzLnNldE9zY2lsbGF0b3JUeXBlKFwidHJpYW5nbGVcIik7XHJcbi8vICAgICAgICAgICAgIHRoaXMuc2V0RnJlcXVlbmN5KF9hdWRpb1NldHRpbmdzLCAxMDApO1xyXG4vLyAgICAgICAgICAgICB0aGlzLnNldExvY2FsR2FpblZhbHVlKDApO1xyXG4vLyAgICAgICAgICAgICB0aGlzLmxvY2FsR2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmN1cnJlbnRUaW1lKTtcclxuLy8gICAgICAgICAgICAgdGhpcy5sb2NhbEdhaW4uZ2Fpbi5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKDAuMDEsIF9hdWRpb1NldHRpbmdzLmdldEF1ZGlvQ29udGV4dCgpLmN1cnJlbnRUaW1lICsgLjEpO1xyXG5cclxuLy8gICAgICAgICAgICAgdGhpcy5hdWRpb09zY2lsbGF0b3IuY29ubmVjdCh0aGlzLmxvY2FsR2Fpbik7XHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgfVxyXG4vLyB9IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZWQgdG8gYSB7QGxpbmsgTm9kZX0gd2l0aCBhbiBhdHRhY2hlZCB7QGxpbmsgQ29tcG9uZW50Q2FtZXJhfSB0aGlzIGNhdXNlcyB0aGUgcmVuZGVyZWQgaW1hZ2UgdG8gcmVjZWl2ZSBhbiBhbWJpZW50IG9jY2x1c2lvbiBlZmZlY3QuXHJcbiAgICogQGF1dGhvcnMgUm9sYW5kIEhlZXIsIEhGVSwgMjAyMyB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRBbWJpZW50T2NjbHVzaW9uIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRBbWJpZW50T2NjbHVzaW9uKTtcclxuXHJcbiAgICBwdWJsaWMgc2FtcGxlUmFkaXVzOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYmlhczogbnVtYmVyO1xyXG4gICAgcHVibGljIGF0dGVudWF0aW9uQ29uc3RhbnQ6IG51bWJlcjtcclxuICAgIHB1YmxpYyBhdHRlbnVhdGlvbkxpbmVhcjogbnVtYmVyO1xyXG4gICAgcHVibGljIGF0dGVudWF0aW9uUXVhZHJhdGljOiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9zYW1wbGVSYWRpdXM6IG51bWJlciA9IDE2LCBfYmlhczogbnVtYmVyID0gMC4wNywgX2F0dGVudWF0aW9uQ29uc3RhbnQ6IG51bWJlciA9IDIuNSwgX2F0dGVudWF0aW9uTGluZWFyOiBudW1iZXIgPSAxLCBfYXR0ZW51YXRpb25RdWFkcmF0aWM6IG51bWJlciA9IDEpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zYW1wbGVSYWRpdXMgPSBfc2FtcGxlUmFkaXVzO1xyXG4gICAgICB0aGlzLmJpYXMgPSBfYmlhcztcclxuICAgICAgdGhpcy5hdHRlbnVhdGlvbkNvbnN0YW50ID0gX2F0dGVudWF0aW9uQ29uc3RhbnQ7XHJcbiAgICAgIHRoaXMuYXR0ZW51YXRpb25MaW5lYXIgPSBfYXR0ZW51YXRpb25MaW5lYXI7XHJcbiAgICAgIHRoaXMuYXR0ZW51YXRpb25RdWFkcmF0aWMgPSBfYXR0ZW51YXRpb25RdWFkcmF0aWM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBzYW1wbGVSYWRpdXM6IHRoaXMuc2FtcGxlUmFkaXVzLFxyXG4gICAgICAgIGJpYXM6IHRoaXMuYmlhcyxcclxuICAgICAgICBhdHRlbnVhdGlvbkNvbnN0YW50OiB0aGlzLmF0dGVudWF0aW9uQ29uc3RhbnQsXHJcbiAgICAgICAgYXR0ZW51YXRpb25MaW5lYXI6IHRoaXMuYXR0ZW51YXRpb25MaW5lYXIsXHJcbiAgICAgICAgYXR0ZW51YXRpb25RdWFkcmF0aWM6IHRoaXMuYXR0ZW51YXRpb25RdWFkcmF0aWNcclxuICAgICAgfTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLnNhbXBsZVJhZGl1cyA9IF9zZXJpYWxpemF0aW9uLnNhbXBsZVJhZGl1cztcclxuICAgICAgdGhpcy5iaWFzID0gX3NlcmlhbGl6YXRpb24uYmlhcztcclxuICAgICAgdGhpcy5hdHRlbnVhdGlvbkNvbnN0YW50ID0gX3NlcmlhbGl6YXRpb24uYXR0ZW51YXRpb25Db25zdGFudDtcclxuICAgICAgdGhpcy5hdHRlbnVhdGlvbkxpbmVhciA9IF9zZXJpYWxpemF0aW9uLmF0dGVudWF0aW9uTGluZWFyO1xyXG4gICAgICB0aGlzLmF0dGVudWF0aW9uUXVhZHJhdGljID0gX3NlcmlhbGl6YXRpb24uYXR0ZW51YXRpb25RdWFkcmF0aWM7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8gLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9UaW1lL0xvb3AudHNcIi8+XHJcbi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vQW5pbWF0aW9uL0FuaW1hdGlvbi50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBIb2xkcyBhIHJlZmVyZW5jZSB0byBhbiB7QGxpbmsgQW5pbWF0aW9ufSBhbmQgY29udHJvbHMgaXQuIENvbnRyb2xzIHF1YW50aXphdGlvbiBhbmQgcGxheW1vZGUgYXMgd2VsbCBhcyBzcGVlZC5cclxuICAgKiBAYXV0aG9ycyBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIyLTIwMjVcclxuICAgKi9cclxuICBAZW51bWVyYXRlXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudEFuaW1hdGlvbiBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50QW5pbWF0aW9uKTtcclxuXHJcbiAgICBwdWJsaWMgcGxheW1vZGU6IEFOSU1BVElPTl9QTEFZTU9ERTtcclxuICAgIHB1YmxpYyBxdWFudGl6YXRpb246IEFOSU1BVElPTl9RVUFOVElaQVRJT047XHJcbiAgICBwdWJsaWMgc2NhbGVXaXRoR2FtZVRpbWU6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgcHVibGljIGFuaW1hdGVJbkVkaXRvcjogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgICNhbmltYXRpb246IEFuaW1hdGlvbjtcclxuICAgICNtdXRhdG9yOiBNdXRhdG9yIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICNzY2FsZTogbnVtYmVyID0gMTtcclxuICAgICN0aW1lTG9jYWw6IFRpbWU7XHJcbiAgICAjcHJldmlvdXM6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9hbmltYXRpb24/OiBBbmltYXRpb24sIF9wbGF5bW9kZTogQU5JTUFUSU9OX1BMQVlNT0RFID0gQU5JTUFUSU9OX1BMQVlNT0RFLkxPT1AsIF9xdWFudGl6YXRpb246IEFOSU1BVElPTl9RVUFOVElaQVRJT04gPSBBTklNQVRJT05fUVVBTlRJWkFUSU9OLkNPTlRJTk9VUykge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnBsYXltb2RlID0gX3BsYXltb2RlO1xyXG4gICAgICB0aGlzLnF1YW50aXphdGlvbiA9IF9xdWFudGl6YXRpb247XHJcblxyXG4gICAgICB0aGlzLiNhbmltYXRpb24gPSBfYW5pbWF0aW9uO1xyXG4gICAgICB0aGlzLiN0aW1lTG9jYWwgPSBuZXcgVGltZSgpO1xyXG5cclxuICAgICAgLy9UT0RPOiB1cGRhdGUgYW5pbWF0aW9uIHRvdGFsIHRpbWUgd2hlbiBsb2FkaW5nIGEgZGlmZmVyZW50IGFuaW1hdGlvbj9cclxuICAgICAgdGhpcy4jYW5pbWF0aW9uPy5jYWxjdWxhdGVUb3RhbFRpbWUoKTtcclxuXHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCAoKSA9PiB0aGlzLmFjdGl2YXRlKGZhbHNlKSk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ0hJTERfUkVNT1ZFLCAoKSA9PiB0aGlzLmFjdGl2YXRlKGZhbHNlKSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSh0cnVlKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgQGVudW1lcmF0ZSBAdHlwZShBbmltYXRpb24pXHJcbiAgICBwdWJsaWMgZ2V0IGFuaW1hdGlvbigpOiBBbmltYXRpb24ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jYW5pbWF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgYW5pbWF0aW9uKF9hbmltYXRpb246IEFuaW1hdGlvbikge1xyXG4gICAgICB0aGlzLiNhbmltYXRpb24gPSBfYW5pbWF0aW9uO1xyXG4gICAgICB0aGlzLiNtdXRhdG9yID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgc2NhbGUoX3NjYWxlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc2NhbGUgPSBfc2NhbGU7XHJcbiAgICAgIHRoaXMudXBkYXRlU2NhbGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHNjYWxlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiAtIGdldDogcmV0dXJuIHRoZSBjdXJyZW50IHNhbXBsZSB0aW1lIG9mIHRoZSBhbmltYXRpb24gIFxyXG4gICAgICogLSBzZXQ6IGp1bXAgdG8gYSBjZXJ0YWluIHNhbXBsZSB0aW1lIGluIHRoZSBhbmltYXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB0aW1lKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiN0aW1lTG9jYWwuZ2V0KCkgJSB0aGlzLmFuaW1hdGlvbi50b3RhbFRpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCB0aW1lKF90aW1lOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5qdW1wVG8oX3RpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhY3RpdmF0ZShfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgc3VwZXIuYWN0aXZhdGUoX29uKTtcclxuICAgICAgaWYgKCF0aGlzLm5vZGUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgdGhpcy5hY3RpdmF0ZUxpc3RlbmVycyhfb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSnVtcHMgdG8gYSBjZXJ0YWluIHRpbWUgaW4gdGhlIGFuaW1hdGlvbiB0byBwbGF5IGZyb20gdGhlcmUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBqdW1wVG8oX3RpbWU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLiN0aW1lTG9jYWwuc2V0KF90aW1lKTtcclxuICAgICAgdGhpcy4jcHJldmlvdXMgPSBfdGltZTtcclxuICAgICAgX3RpbWUgPSBfdGltZSAlIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZTtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB0aGlzLmFuaW1hdGlvbi5nZXRTdGF0ZShfdGltZSwgdGhpcy5hbmltYXRpb24uY2FsY3VsYXRlRGlyZWN0aW9uKF90aW1lLCB0aGlzLnBsYXltb2RlKSwgdGhpcy5xdWFudGl6YXRpb24pO1xyXG4gICAgICB0aGlzLm5vZGUuYXBwbHlBbmltYXRpb24obXV0YXRvcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBKdW1wcyB0byBhIGNlcnRhaW4gbGFiZWwgaW4gdGhlIGFuaW1hdGlvbiBpZiBkZWZpbmVkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBqdW1wVG9MYWJlbChfbGFiZWw6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBsZXQgdGltZTogbnVtYmVyID0gdGhpcy5hbmltYXRpb24ubGFiZWxzW19sYWJlbF07XHJcbiAgICAgIGlmICh0aW1lKVxyXG4gICAgICAgIHRoaXMuanVtcFRvKHRpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yY2VzIGFuIHVwZGF0ZSBvZiB0aGUgYW5pbWF0aW9uIGZyb20gb3V0c2lkZS4gVXNlZCBpbiB0aGUgVmlld0FuaW1hdGlvbi4gU2hvdWxkbid0IGJlIHVzZWQgZHVyaW5nIHRoZSBnYW1lLlxyXG4gICAgICogQHBhcmFtIF90aW1lIHRoZSAodW5zY2FsZWQpIHRpbWUgdG8gdXBkYXRlIHRoZSBhbmltYXRpb24gd2l0aC5cclxuICAgICAqIEByZXR1cm5zIHRoZSBNdXRhdG9yIGZvciBBbmltYXRpb24uIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlQW5pbWF0aW9uKF90aW1lOiBudW1iZXIpOiBNdXRhdG9yIHtcclxuICAgICAgdGhpcy4jcHJldmlvdXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUFuaW1hdGlvbkxvb3AobnVsbCwgX3RpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiB0cmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7fTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmlkQW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb24uaWRSZXNvdXJjZTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5wbGF5bW9kZSA9IHRoaXMucGxheW1vZGU7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24ucXVhbnRpemF0aW9uID0gdGhpcy5xdWFudGl6YXRpb247XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnNjYWxlV2l0aEdhbWVUaW1lID0gdGhpcy5zY2FsZVdpdGhHYW1lVGltZTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5hbmltYXRlSW5FZGl0b3IgPSB0aGlzLmFuaW1hdGVJbkVkaXRvcjtcclxuXHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgdGhpcy5hbmltYXRpb24gPSA8QW5pbWF0aW9uPmF3YWl0IFByb2plY3QuZ2V0UmVzb3VyY2UoX3NlcmlhbGl6YXRpb24uaWRBbmltYXRpb24pO1xyXG4gICAgICB0aGlzLnBsYXltb2RlID0gX3NlcmlhbGl6YXRpb24ucGxheW1vZGU7XHJcbiAgICAgIHRoaXMucXVhbnRpemF0aW9uID0gX3NlcmlhbGl6YXRpb24ucXVhbnRpemF0aW9uO1xyXG4gICAgICB0aGlzLnNjYWxlID0gX3NlcmlhbGl6YXRpb24uc2NhbGU7XHJcbiAgICAgIHRoaXMuc2NhbGVXaXRoR2FtZVRpbWUgPSBfc2VyaWFsaXphdGlvbi5zY2FsZVdpdGhHYW1lVGltZTtcclxuICAgICAgdGhpcy5hbmltYXRlSW5FZGl0b3IgPSBfc2VyaWFsaXphdGlvbi5hbmltYXRlSW5FZGl0b3I7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgYXdhaXQgc3VwZXIubXV0YXRlKF9tdXRhdG9yLCBfc2VsZWN0aW9uLCBfZGlzcGF0Y2hNdXRhdGUpO1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5hbmltYXRlSW5FZGl0b3IpICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVBbmltYXRpb24oMCk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZUxpc3RlbmVycyh0aGlzLmFjdGl2ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yOiBNdXRhdG9yKTogTXV0YXRvckF0dHJpYnV0ZVR5cGVzIHtcclxuICAgICAgbGV0IHR5cGVzOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMgPSBzdXBlci5nZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3IpO1xyXG4gICAgICBpZiAodHlwZXMucGxheW1vZGUpXHJcbiAgICAgICAgdHlwZXMucGxheW1vZGUgPSBBTklNQVRJT05fUExBWU1PREU7XHJcbiAgICAgIGlmICh0eXBlcy5xdWFudGl6YXRpb24pXHJcbiAgICAgICAgdHlwZXMucXVhbnRpemF0aW9uID0gQU5JTUFUSU9OX1FVQU5USVpBVElPTjtcclxuICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgcHJpdmF0ZSBhY3RpdmF0ZUxpc3RlbmVycyhfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKF9vbiAmJiAoUHJvamVjdC5tb2RlICE9IE1PREUuRURJVE9SIHx8IFByb2plY3QubW9kZSA9PSBNT0RFLkVESVRPUiAmJiB0aGlzLmFuaW1hdGVJbkVkaXRvcikpIHtcclxuICAgICAgICBUaW1lLmdhbWUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5USU1FX1NDQUxFRCwgdGhpcy51cGRhdGVTY2FsZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuUkVOREVSX1BSRVBBUkUsIHRoaXMudXBkYXRlQW5pbWF0aW9uTG9vcCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgVGltZS5nYW1lLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuVElNRV9TQ0FMRUQsIHRoaXMudXBkYXRlU2NhbGUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULlJFTkRFUl9QUkVQQVJFLCB0aGlzLnVwZGF0ZUFuaW1hdGlvbkxvb3ApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIHVwZGF0ZUFuaW1hdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBBbmltYXRpb24uXHJcbiAgICAgKiBVc2VzIHRoZSBidWlsdC1pbiB0aW1lIHVubGVzcyBhIGRpZmZlcmVudCB0aW1lIGlzIHNwZWNpZmllZC5cclxuICAgICAqIE1heSBhbHNvIGJlIGNhbGxlZCBmcm9tIHVwZGF0ZUFuaW1hdGlvbigpLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZUFuaW1hdGlvbkxvb3AgPSAoX2U6IEV2ZW50LCBfdGltZT86IG51bWJlcik6IE11dGF0b3IgPT4ge1xyXG5cclxuICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZSA9PSAwKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgbGV0IHRpbWU6IG51bWJlciA9IF90aW1lIHx8IF90aW1lID09PSAwID8gX3RpbWUgOiB0aGlzLiN0aW1lTG9jYWwuZ2V0KCk7XHJcbiAgICAgIGlmICh0aGlzLnF1YW50aXphdGlvbiA9PSBBTklNQVRJT05fUVVBTlRJWkFUSU9OLkZSQU1FUykge1xyXG4gICAgICAgIHRpbWUgPSB0aGlzLiNwcmV2aW91cyArICgxMDAwIC8gdGhpcy5hbmltYXRpb24uZnBzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGRpcmVjdGlvbjogbnVtYmVyID0gdGhpcy5hbmltYXRpb24uY2FsY3VsYXRlRGlyZWN0aW9uKHRpbWUsIHRoaXMucGxheW1vZGUpO1xyXG4gICAgICB0aW1lID0gdGhpcy5hbmltYXRpb24uZ2V0TW9kYWxUaW1lKHRpbWUsIHRoaXMucGxheW1vZGUsIHRoaXMuI3RpbWVMb2NhbC5nZXRPZmZzZXQoKSk7XHJcblxyXG4gICAgICB0aGlzLmV4ZWN1dGVFdmVudHModGhpcy5hbmltYXRpb24uZ2V0RXZlbnRzVG9GaXJlKHRoaXMuI3ByZXZpb3VzLCB0aW1lLCB0aGlzLnF1YW50aXphdGlvbiwgZGlyZWN0aW9uKSk7XHJcblxyXG4gICAgICBpZiAodGhpcy4jcHJldmlvdXMgIT0gdGltZSkge1xyXG4gICAgICAgIHRoaXMuI3ByZXZpb3VzID0gdGltZTtcclxuICAgICAgICB0aW1lID0gdGltZSAlIHRoaXMuYW5pbWF0aW9uLnRvdGFsVGltZTtcclxuXHJcbiAgICAgICAgdGhpcy4jbXV0YXRvciA9IHRoaXMuYW5pbWF0aW9uLmdldFN0YXRlKHRpbWUsIGRpcmVjdGlvbiwgdGhpcy5xdWFudGl6YXRpb24sIHRoaXMuI211dGF0b3IpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0aGlzLm5vZGUpIFxyXG4gICAgICAgICAgdGhpcy5ub2RlLmFwcGx5QW5pbWF0aW9uKHRoaXMuI211dGF0b3IpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB0aGlzLiNtdXRhdG9yO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVzIGFsbCBjdXN0b20gZXZlbnRzIHRoZSBBbmltYXRpb24gc2hvdWxkIGhhdmUgZmlyZWQgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgZnJhbWUuXHJcbiAgICAgKiBAcGFyYW0gX2V2ZW50cyBhIGxpc3Qgb2YgbmFtZXMgb2YgY3VzdG9tIGV2ZW50cyB0byBmaXJlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZXhlY3V0ZUV2ZW50cyhfZXZlbnRzOiBzdHJpbmdbXSk6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgX2V2ZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoX2V2ZW50c1tpXSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBzY2FsZSBvZiB0aGUgYW5pbWF0aW9uIGlmIHRoZSB1c2VyIGNoYW5nZXMgaXQgb3IgaWYgdGhlIGdsb2JhbCBnYW1lIHRpbWVyIGNoYW5nZWQgaXRzIHNjYWxlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZVNjYWxlID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICBsZXQgbmV3U2NhbGU6IG51bWJlciA9IHRoaXMuI3NjYWxlO1xyXG4gICAgICBpZiAodGhpcy5zY2FsZVdpdGhHYW1lVGltZSlcclxuICAgICAgICBuZXdTY2FsZSAqPSBUaW1lLmdhbWUuZ2V0U2NhbGUoKTtcclxuICAgICAgdGhpcy4jdGltZUxvY2FsLnNldFNjYWxlKG5ld1NjYWxlKTtcclxuICAgIH07XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBhbiB7QGxpbmsgQW5pbWF0aW9uTm9kZSBhbmltYXRpb24gZ3JhcGh9IHRvIGEge0BsaW5rIE5vZGV9IGFuZCBhbmltYXRlcyBpdC5cclxuICAgKiBAYXV0aG9yIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNC0yMDI1XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudEFuaW1hdGlvbkdyYXBoIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRBbmltYXRpb25HcmFwaCk7XHJcbiAgICBwdWJsaWMgcm9vdDogQW5pbWF0aW9uTm9kZTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3Jvb3Q/OiBBbmltYXRpb25Ob2RlKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMucm9vdCA9IF9yb290O1xyXG5cclxuICAgICAgaWYgKFByb2plY3QubW9kZSA9PSBNT0RFLkVESVRPUilcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgKCkgPT4gdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuUkVOREVSX1BSRVBBUkUsIHRoaXMudXBkYXRlKSk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCAoKSA9PiB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5SRU5ERVJfUFJFUEFSRSwgdGhpcy51cGRhdGUpKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGUgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgIFBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE1lYXN1cmUoXCJDb21wb25lbnRBbmltYXRpb25HcmFwaC51cGRhdGVcIik7XHJcbiAgICAgIGlmICghdGhpcy5yb290IHx8ICF0aGlzLm5vZGUgfHwgIXRoaXMuYWN0aXZlKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIFBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE1lYXN1cmUoXCJDb21wb25lbnRBbmltYXRpb25HcmFwaC51cGRhdGUgY29tcHV0ZVwiKTtcclxuICAgICAgdGhpcy5yb290LnVwZGF0ZShMb29wLnRpbWVGcmFtZUdhbWUpO1xyXG4gICAgICB0aGlzLnJvb3QuZXZlbnRzPy5mb3JFYWNoKF9ldmVudCA9PiB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KF9ldmVudCkpKTtcclxuICAgICAgUGVyZm9ybWFuY2VNb25pdG9yLmVuZE1lYXN1cmUoXCJDb21wb25lbnRBbmltYXRpb25HcmFwaC51cGRhdGUgY29tcHV0ZVwiKTtcclxuXHJcblxyXG4gICAgICBQZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNZWFzdXJlKFwiQ29tcG9uZW50QW5pbWF0aW9uR3JhcGgudXBkYXRlIGFwcGx5XCIpO1xyXG4gICAgICB0aGlzLm5vZGUuYXBwbHlBbmltYXRpb24odGhpcy5yb290Lm11dGF0b3IpO1xyXG4gICAgICBQZXJmb3JtYW5jZU1vbml0b3IuZW5kTWVhc3VyZShcIkNvbXBvbmVudEFuaW1hdGlvbkdyYXBoLnVwZGF0ZSBhcHBseVwiKTtcclxuXHJcbiAgICAgIFBlcmZvcm1hbmNlTW9uaXRvci5lbmRNZWFzdXJlKFwiQ29tcG9uZW50QW5pbWF0aW9uR3JhcGgudXBkYXRlXCIpO1xyXG4gICAgfTtcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgZXhwb3J0IGVudW0gQVVESU9fUEFOTkVSIHtcclxuICAgIENPTkVfSU5ORVJfQU5HTEUgPSBcImNvbmVJbm5lckFuZ2xlXCIsXHJcbiAgICBDT05FX09VVEVSX0FOR0xFID0gXCJjb25lT3V0ZXJBbmdsZVwiLFxyXG4gICAgQ09ORV9PVVRFUl9HQUlOID0gXCJjb25lT3V0ZXJHYWluXCIsXHJcbiAgICBESVNUQU5DRV9NT0RFTCA9IFwiZGlzdGFuY2VNb2RlbFwiLFxyXG4gICAgTUFYX0RJU1RBTkNFID0gXCJtYXhEaXN0YW5jZVwiLFxyXG4gICAgUEFOTklOR19NT0RFTCA9IFwicGFubmluZ01vZGVsXCIsXHJcbiAgICBSRUZfRElTVEFOQ0UgPSBcInJlZkRpc3RhbmNlXCIsXHJcbiAgICBST0xMT0ZGX0ZBQ1RPUiA9IFwicm9sbG9mZkZhY3RvclwiXHJcbiAgfVxyXG5cclxuICBleHBvcnQgZW51bSBBVURJT19OT0RFX1RZUEUge1xyXG4gICAgU09VUkNFLCBQQU5ORVIsIEdBSU5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1aWxkcyBhIG1pbmltYWwgYXVkaW8gZ3JhcGggKGJ5IGRlZmF1bHQgaW4ge0BsaW5rIEF1ZGlvTWFuYWdlcn0uZGVmYXVsdCkgYW5kIHN5bmNocm9uaXplcyBpdCB3aXRoIHRoZSBjb250YWluaW5nIHtAbGluayBOb2RlfVxyXG4gICAqIGBgYHRleHRcclxuICAgKiDilIwgQXVkaW9NYW5hZ2VyKC5kZWZhdWx0KSDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcclxuICAgKiDilIIg4pSMIENvbXBvbmVudEF1ZGlvIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICDilIJcclxuICAgKiDilIIg4pSCICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUkCDilIIg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQIOKUgiAgXHJcbiAgICog4pSCIOKUgiAgICDilIJzb3VyY2XilIIg4oaSIOKUgnBhbm5lcuKUgiDihpIg4pSCIGdhaW4g4pSCIOKGkiDilIIgZ2FpbiDilIIg4pSCXHJcbiAgICog4pSCIOKUgiAgICDilJTilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJgg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCDilIIgIFxyXG4gICAqIOKUgiDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggICAgICAgICAg4pSCXHJcbiAgICog4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgVGhvbWFzIERvcm5lciwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50QXVkaW8gZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudEF1ZGlvKTtcclxuICAgIC8qKiBwbGFjZXMgYW5kIGRpcmVjdHMgdGhlIHBhbm5lciByZWxhdGl2ZSB0byB0aGUgd29ybGQgdHJhbnNmb3JtIG9mIHRoZSB7QGxpbmsgTm9kZX0gICovXHJcbiAgICBwdWJsaWMgbXR4UGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG5cclxuICAgIHByb3RlY3RlZCBzaW5nbGV0b246IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBAdHlwZShBdWRpbylcclxuICAgIHByaXZhdGUgYXVkaW86IEF1ZGlvO1xyXG4gICAgcHJpdmF0ZSBnYWluOiBHYWluTm9kZTtcclxuICAgIHByaXZhdGUgcGFubmVyOiBQYW5uZXJOb2RlO1xyXG4gICAgcHJpdmF0ZSBzb3VyY2U6IEF1ZGlvQnVmZmVyU291cmNlTm9kZTtcclxuICAgIHByaXZhdGUgYXVkaW9NYW5hZ2VyOiBBdWRpb01hbmFnZXI7XHJcbiAgICBwcml2YXRlIHBsYXlpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgbGlzdGVuZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2F1ZGlvOiBBdWRpbyA9IG51bGwsIF9sb29wOiBib29sZWFuID0gZmFsc2UsIF9zdGFydDogYm9vbGVhbiA9IGZhbHNlLCBfYXVkaW9NYW5hZ2VyOiBBdWRpb01hbmFnZXIgPSBBdWRpb01hbmFnZXIuZGVmYXVsdCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmluc3RhbGwoX2F1ZGlvTWFuYWdlcik7XHJcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlKF9hdWRpbywgX2xvb3ApO1xyXG5cclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIHRoaXMuaGFuZGxlQXR0YWNoKTtcclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9SRU1PVkUsIHRoaXMuaGFuZGxlQXR0YWNoKTtcclxuXHJcbiAgICAgIGlmIChfc3RhcnQpXHJcbiAgICAgICAgdGhpcy5wbGF5KF9zdGFydCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCB2b2x1bWUoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5nYWluLmdhaW4udmFsdWUgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB2b2x1bWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgbG9vcChfb246IGJvb2xlYW4pIHtcclxuICAgICAgdGhpcy5zb3VyY2UubG9vcCA9IF9vbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGxvb3AoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5sb29wO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgcGxheWJhY2tSYXRlKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHBsYXliYWNrUmF0ZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzUGxheWluZygpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGxheWluZztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzQXR0YWNoZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5vZGUgIT0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzTGlzdGVuZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4ge0BsaW5rIEF1ZGlvfSBhcyB0aGUgYXVkaW8gc291cmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRBdWRpbyhfYXVkaW86IEF1ZGlvKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlKF9hdWRpbywgdGhpcy5zb3VyY2UubG9vcCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgQXVkaW99IGN1cnJlbnRseSB1c2VkIGFzIGF1ZGlvIHNvdXJjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QXVkaW8oKTogQXVkaW8ge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdWRpbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcHJvcGVydHkgb2YgdGhlIHBhbm5lciB0byB0aGUgZ2l2ZW4gdmFsdWUuIFVzZSB0byBtYW5pcHVsYXRlIHJhbmdlIGFuZCByb2xsb2ZmIGV0Yy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFBhbm5lcihfcHJvcGVydHk6IEFVRElPX1BBTk5FUiwgX3ZhbHVlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgUmVmbGVjdC5zZXQodGhpcy5wYW5uZXIsIF9wcm9wZXJ0eSwgX3ZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBtYXkgYmUgdXNlZCBmb3Igc2VyaWFsaXphdGlvbiBvZiBBdWRpb05vZGVzXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG11dGF0b3IgZm9yIHRoZSBzcGVjaWZpZWQgQXVkaW9Ob2RlIG9mIHRoZSBzdGFuZGFyZCBncmFwaFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvck9mTm9kZShfdHlwZTogQVVESU9fTk9ERV9UWVBFKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBub2RlOiBBdWRpb05vZGUgPSB0aGlzLmdldEF1ZGlvTm9kZShfdHlwZSk7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gZ2V0TXV0YXRvck9mQXJiaXRyYXJ5KG5vZGUpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNwZWNpZmllZCBBdWRpb05vZGUgb2YgdGhlIHN0YW5kYXJkIGdyYXBoIGZvciBmdXJ0aGVyIG1hbmlwdWxhdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QXVkaW9Ob2RlKF90eXBlOiBBVURJT19OT0RFX1RZUEUpOiBBdWRpb05vZGUge1xyXG4gICAgICBzd2l0Y2ggKF90eXBlKSB7XHJcbiAgICAgICAgY2FzZSBBVURJT19OT0RFX1RZUEUuU09VUkNFOiByZXR1cm4gdGhpcy5zb3VyY2U7XHJcbiAgICAgICAgY2FzZSBBVURJT19OT0RFX1RZUEUuUEFOTkVSOiByZXR1cm4gdGhpcy5wYW5uZXI7XHJcbiAgICAgICAgY2FzZSBBVURJT19OT0RFX1RZUEUuR0FJTjogcmV0dXJuIHRoaXMuZ2FpbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgb3Igc3RvcCBwbGF5aW5nIHRoZSBhdWRpb1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcGxheShfb246IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKF9vbikge1xyXG4gICAgICAgIGlmICh0aGlzLmF1ZGlvLmlzUmVhZHkpIHtcclxuICAgICAgICAgIHRoaXMuY3JlYXRlU291cmNlKHRoaXMuYXVkaW8sIHRoaXMuc291cmNlLmxvb3AsIHRoaXMucGxheWJhY2tSYXRlKTtcclxuICAgICAgICAgIHRoaXMuc291cmNlLnN0YXJ0KDAsIDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uUkVBRFksIHRoaXMuaG5kQXVkaW9SZWFkeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uRU5ERUQsIHRoaXMuaG5kQXVkaW9FbmRlZCk7XHJcbiAgICAgIH0gZWxzZVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zdG9wKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yOiB1bmtub3duKSB7IC8qIGNhdGNoIGV4Y2VwdGlvbiB3aGVuIHNvdXJjZSBoYXNuJ3QgYmVlbiBzdGFydGVkLi4uICovIH1cclxuICAgICAgdGhpcy5wbGF5aW5nID0gX29uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyBBdWRpb05vZGVzIGJldHdlZW4gdGhlIHBhbm5lciBhbmQgdGhlIGxvY2FsIGdhaW4gb2YgdGhpcyB7QGxpbmsgQ29tcG9uZW50QXVkaW99XHJcbiAgICAgKiBfaW5wdXQgYW5kIF9vdXRwdXQgbWF5IGJlIHRoZSBzYW1lIEF1ZGlvTm9kZSwgaWYgdGhlcmUgaXMgb25seSBvbmUgdG8gaW5zZXJ0LFxyXG4gICAgICogb3IgbWF5IGhhdmUgbXVsdGlwbGUgQXVkaW9Ob2RlIGJldHdlZW4gdGhlbSB0byBjcmVhdGUgYW4gZWZmZWN0LWdyYXBoLlxcXHJcbiAgICAgKiBOb3RlIHRoYXQge0BsaW5rIENvbXBvbmVudEF1ZGlvfSBkb2VzIG5vdCBrZWVwIHRyYWNrIG9mIGluc2VydGVkIEF1ZGlvTm9kZXMhXHJcbiAgICAgKiBgYGB0ZXh0XHJcbiAgICAgKiDilIwgQXVkaW9NYW5hZ2VyKC5kZWZhdWx0KSDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcclxuICAgICAqIOKUgiDilIwgQ29tcG9uZW50QXVkaW8g4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAgICAgICAgIOKUglxyXG4gICAgICog4pSCIOKUgiAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilIDilJAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSQIOKUgiDilIzilIDilIDilIDilIDilIDilIDilJAg4pSCICBcclxuICAgICAqIOKUgiDilIIgICAg4pSCc291cmNl4pSCIOKGkiDilIJwYW5uZXLilIIg4oaSIOKUgl9pbnB1dOKUgiDihpIgLi4uICDihpIg4pSCX291dHB1dOKUgiDihpIg4pSCIGdhaW4g4pSCIOKGkiDilIIgZ2FpbiDilIIg4pSCXHJcbiAgICAgKiDilIIg4pSCICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICDilJTilIDilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilIDilJgg4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCDilIIgIFxyXG4gICAgICog4pSCIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICDilIJcclxuICAgICAqIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnNlcnRBdWRpb05vZGVzKF9pbnB1dDogQXVkaW9Ob2RlLCBfb3V0cHV0OiBBdWRpb05vZGUpOiB2b2lkIHtcclxuICAgICAgdGhpcy5wYW5uZXIuZGlzY29ubmVjdCgwKTtcclxuICAgICAgaWYgKCFfaW5wdXQgJiYgIV9vdXRwdXQpIHtcclxuICAgICAgICB0aGlzLnBhbm5lci5jb25uZWN0KHRoaXMuZ2Fpbik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucGFubmVyLmNvbm5lY3QoX2lucHV0KTtcclxuICAgICAgX291dHB1dC5jb25uZWN0KHRoaXMuZ2Fpbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZSBvdmVycmlkZS4gQ29ubmVjdHMgb3IgZGlzY29ubmVjdHMgQXVkaW9Ob2Rlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWN0aXZhdGUoX29uOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLmFjdGl2YXRlKF9vbik7XHJcbiAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdHMgdGhpcyBjb21wb25lbnRzIGdhaW4tbm9kZSB0byB0aGUgZ2FpbiBub2RlIG9mIHRoZSBBdWRpb01hbmFnZXIgdGhpcyBjb21wb25lbnQgcnVucyBvbi5cclxuICAgICAqIE9ubHkgY2FsbCB0aGlzIG1ldGhvZCBpZiB0aGUgY29tcG9uZW50IGlzIG5vdCBhdHRhY2hlZCB0byBhIHtAbGluayBOb2RlfSBidXQgbmVlZHMgdG8gYmUgaGVhcmQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25uZWN0KF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAoX29uKVxyXG4gICAgICAgIHRoaXMuZ2Fpbi5jb25uZWN0KHRoaXMuYXVkaW9NYW5hZ2VyLmdhaW4pO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5nYWluLmRpc2Nvbm5lY3QodGhpcy5hdWRpb01hbmFnZXIuZ2Fpbik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRyYXdHaXptb3MoKTogdm9pZCB7XHJcbiAgICAgIGxldCBtdHhTaGFwZTogTWF0cml4NHg0ID0gTWF0cml4NHg0LlBST0RVQ1QodGhpcy5ub2RlLm10eFdvcmxkLCB0aGlzLm10eFBpdm90KTtcclxuICAgICAgbXR4U2hhcGUuc2NhbGluZyA9IG5ldyBWZWN0b3IzKDAuNSwgMC41LCAwLjUpO1xyXG4gICAgICBsZXQgY29sb3I6IENvbG9yID0gQ29sb3IuQ1NTKFwiY29ybmZsb3dlcmJsdWVcIik7XHJcbiAgICAgIEdpem1vcy5kcmF3SWNvbihUZXh0dXJlRGVmYXVsdC5pY29uQXVkaW8sIG10eFNoYXBlLCBjb2xvcik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFNoYXBlKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoY29sb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaWRSZXNvdXJjZSA9IHRoaXMuYXVkaW8/LmlkUmVzb3VyY2U7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24ucGxheWluZyA9IHRoaXMucGxheWluZztcclxuICAgICAgc2VyaWFsaXphdGlvbi5sb29wID0gdGhpcy5sb29wO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnZvbHVtZSA9IHRoaXMudm9sdW1lO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmdldE11dGF0b3JPZk5vZGUoQVVESU9fTk9ERV9UWVBFLlBBTk5FUikpO1xyXG4gICAgICAvLyBUT0RPOiBzZXJpYWxpemUgcGFubmVyIHBhcmFtZXRlcnNcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIGxldCBhdWRpbzogQXVkaW8gPSA8QXVkaW8+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlKTtcclxuICAgICAgdGhpcy5jcmVhdGVTb3VyY2UoYXVkaW8sIF9zZXJpYWxpemF0aW9uLmxvb3ApO1xyXG4gICAgICB0aGlzLnZvbHVtZSA9IF9zZXJpYWxpemF0aW9uLnZvbHVtZTtcclxuICAgICAgdGhpcy5wbGF5KF9zZXJpYWxpemF0aW9uLnBsYXlpbmcpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKHRydWUpO1xyXG4gICAgICBsZXQgYXVkaW86IE11dGF0b3IgPSBtdXRhdG9yLmF1ZGlvO1xyXG4gICAgICBkZWxldGUgbXV0YXRvci5hdWRpbzsgLy8ganVzdCB0byByZWFycmFuZ2UgaW4gaW50ZXJmYWNlcy4uLlxyXG4gICAgICBtdXRhdG9yLmxvb3AgPSB0aGlzLmxvb3A7XHJcbiAgICAgIG11dGF0b3Iudm9sdW1lID0gdGhpcy52b2x1bWU7XHJcbiAgICAgIG11dGF0b3IuYXVkaW8gPSBhdWRpbzsgLy8uLi4gc28gYXVkaW8gY29tZXMgbGFzdFxyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvcik7XHJcbiAgICAvLyAgIC8vIHRoaXMudm9sdW1lID0gX211dGF0b3Iudm9sdW1lO1xyXG4gICAgLy8gICAvLyB0aGlzLmxvb3AgPSBfbXV0YXRvci5sb29wO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IubGlzdGVuZWQ7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgcHJpdmF0ZSBobmRBdWRpb1JlYWR5OiBFdmVudExpc3RlbmVyID0gKF9ldmVudDogRXZlbnQpID0+IHtcclxuICAgICAgRGVidWcuZnVkZ2UoXCJBdWRpbyBzdGFydFwiLCBSZWZsZWN0LmdldChfZXZlbnQudGFyZ2V0LCBcInVybFwiKSk7XHJcbiAgICAgIGlmICh0aGlzLnBsYXlpbmcpXHJcbiAgICAgICAgdGhpcy5wbGF5KHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGhuZEF1ZGlvRW5kZWQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCkgPT4ge1xyXG4gICAgICAvLyBEZWJ1Zy5mdWRnZShcIkF1ZGlvIGVuZGVkXCIsIFJlZmxlY3QuZ2V0KF9ldmVudC50YXJnZXQsIFwidXJsXCIpKTtcclxuICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgaW5zdGFsbChfYXVkaW9NYW5hZ2VyOiBBdWRpb01hbmFnZXIgPSBBdWRpb01hbmFnZXIuZGVmYXVsdCk6IHZvaWQge1xyXG4gICAgICBsZXQgYWN0aXZlOiBib29sZWFuID0gdGhpcy5pc0FjdGl2ZTtcclxuICAgICAgdGhpcy5hY3RpdmF0ZShmYWxzZSk7XHJcbiAgICAgIHRoaXMuYXVkaW9NYW5hZ2VyID0gX2F1ZGlvTWFuYWdlcjtcclxuICAgICAgdGhpcy5wYW5uZXIgPSBfYXVkaW9NYW5hZ2VyLmNyZWF0ZVBhbm5lcigpO1xyXG4gICAgICB0aGlzLmdhaW4gPSBfYXVkaW9NYW5hZ2VyLmNyZWF0ZUdhaW4oKTtcclxuICAgICAgdGhpcy5wYW5uZXIuY29ubmVjdCh0aGlzLmdhaW4pO1xyXG4gICAgICB0aGlzLmdhaW4uY29ubmVjdChfYXVkaW9NYW5hZ2VyLmdhaW4pO1xyXG4gICAgICB0aGlzLmFjdGl2YXRlKGFjdGl2ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjcmVhdGVTb3VyY2UoX2F1ZGlvOiBBdWRpbywgX2xvb3A6IGJvb2xlYW4sIF9wbGF5YmFja1JhdGU6IG51bWJlciA9IDEuMCk6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy5zb3VyY2UpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UuYnVmZmVyID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNvdXJjZSA9IHRoaXMuYXVkaW9NYW5hZ2VyLmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG4gICAgICB0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMucGFubmVyKTtcclxuXHJcbiAgICAgIGlmIChfYXVkaW8pIHtcclxuICAgICAgICB0aGlzLmF1ZGlvID0gX2F1ZGlvO1xyXG4gICAgICAgIHRoaXMuc291cmNlLmJ1ZmZlciA9IF9hdWRpby5idWZmZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuc291cmNlLmxvb3AgPSBfbG9vcDtcclxuICAgICAgdGhpcy5wbGF5YmFja1JhdGUgPSBfcGxheWJhY2tSYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdXBkYXRlQ29ubmVjdGlvbigpOiB2b2lkIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5pc0FjdGl2ZSAmJiB0aGlzLmlzQXR0YWNoZWQgJiYgdGhpcy5saXN0ZW5lZCk7XHJcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xyXG4gICAgICAgIC8vIG5vcFxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQXV0b21hdGljYWxseSBjb25uZWN0cy9kaXNjb25uZWN0cyBBdWRpb05vZGVzIHdoZW4gYWRkaW5nL3JlbW92aW5nIHRoaXMgY29tcG9uZW50IHRvL2Zyb20gYSBub2RlLiBcclxuICAgICAqIFRoZXJlZm9yZSB1bnVzZWQgQXVkaW9Ob2RlcyBtYXkgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgd2hlbiBhbiB1bnVzZWQgY29tcG9uZW50IGlzIGNvbGxlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhhbmRsZUF0dGFjaCA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIC8vIERlYnVnLmxvZyhfZXZlbnQpO1xyXG4gICAgICBpZiAoX2V2ZW50LnR5cGUgPT0gRVZFTlQuQ09NUE9ORU5UX0FERCkge1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLkNISUxEX0FQUEVORCwgdGhpcy5oYW5kbGVHcmFwaCwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uQ0hJTERfUkVNT1ZFLCB0aGlzLmhhbmRsZUdyYXBoLCB0cnVlKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5VUERBVEUsIHRoaXMudXBkYXRlLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVkID0gdGhpcy5ub2RlLmlzRGVzY2VuZGFudE9mKEF1ZGlvTWFuYWdlci5kZWZhdWx0LmdldEdyYXBoTGlzdGVuaW5nVG8oKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRfQVVESU8uQ0hJTERfQVBQRU5ELCB0aGlzLmhhbmRsZUdyYXBoLCB0cnVlKTtcclxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9BVURJTy5DSElMRF9SRU1PVkUsIHRoaXMuaGFuZGxlR3JhcGgsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UX0FVRElPLlVQREFURSwgdGhpcy51cGRhdGUsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZWQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb24oKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQXV0b21hdGljYWxseSBjb25uZWN0cy9kaXNjb25uZWN0cyBBdWRpb05vZGVzIHdoZW4gYXBwZW5kaW5nL3JlbW92aW5nIHRoZSBGVURHRS1ncmFwaCB0aGUgY29tcG9uZW50IGlzIGluLiBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBoYW5kbGVHcmFwaCA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIC8vIERlYnVnLmxvZyhfZXZlbnQpO1xyXG4gICAgICB0aGlzLmxpc3RlbmVkID0gKF9ldmVudC50eXBlID09IEVWRU5UX0FVRElPLkNISUxEX0FQUEVORCk7XHJcbiAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvbigpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBwYW5uZXIgbm9kZSwgaXRzIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb24sIHVzaW5nIHRoZSB3b3JsZG1hdHJpeCBvZiB0aGUgY29udGFpbmVyIGFuZCB0aGUgcGl2b3Qgb2YgdGhpcyBjb21wb25lbnQuIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVwZGF0ZSA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIGxldCBtdHhSZXN1bHQ6IE1hdHJpeDR4NCA9IHRoaXMubXR4UGl2b3Q7XHJcbiAgICAgIGlmICh0aGlzLm5vZGUpXHJcbiAgICAgICAgbXR4UmVzdWx0ID0gTWF0cml4NHg0LlBST0RVQ1QodGhpcy5ub2RlLm10eFdvcmxkLCB0aGlzLm10eFBpdm90KTtcclxuXHJcbiAgICAgIC8vIERlYnVnLmxvZyhtdHhSZXN1bHQudG9TdHJpbmcoKSk7XHJcbiAgICAgIGxldCBwb3NpdGlvbjogVmVjdG9yMyA9IG10eFJlc3VsdC50cmFuc2xhdGlvbjtcclxuICAgICAgbGV0IGZvcndhcmQ6IFZlY3RvcjMgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKFZlY3RvcjMuWigxKSwgbXR4UmVzdWx0LCBmYWxzZSk7XHJcblxyXG4gICAgICB0aGlzLnBhbm5lci5wb3NpdGlvblgudmFsdWUgPSBwb3NpdGlvbi54O1xyXG4gICAgICB0aGlzLnBhbm5lci5wb3NpdGlvblkudmFsdWUgPSBwb3NpdGlvbi55O1xyXG4gICAgICB0aGlzLnBhbm5lci5wb3NpdGlvbloudmFsdWUgPSBwb3NpdGlvbi56O1xyXG5cclxuICAgICAgdGhpcy5wYW5uZXIub3JpZW50YXRpb25YLnZhbHVlID0gZm9yd2FyZC54O1xyXG4gICAgICB0aGlzLnBhbm5lci5vcmllbnRhdGlvblkudmFsdWUgPSBmb3J3YXJkLnk7XHJcbiAgICAgIHRoaXMucGFubmVyLm9yaWVudGF0aW9uWi52YWx1ZSA9IGZvcndhcmQuejtcclxuXHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKGZvcndhcmQpO1xyXG4gICAgICAvLyBUT0RPOiBleGFtaW5lIHdoeSB0aGUgZm9sbG93aW5nIHByb2R1Y2VzIGVycm9uZW91cyByZXN1bHRzLCBzZWUgdGVzdCBcIlNwYXRpYWwgQXVkaW9cIlxyXG4gICAgICBpZiAodGhpcy5ub2RlKVxyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJlc3VsdCk7XHJcbiAgICB9O1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFNlcnZlcyB0byBzZXQgdGhlIHNwYXRpYWwgbG9jYXRpb24gYW5kIG9yaWVudGF0aW9uIG9mIEF1ZGlvTGlzdGVuZXJzIHJlbGF0aXZlIHRvIHRoZVxyXG4gICAqIHdvcmxkIHRyYW5zZm9ybSBvZiB0aGUge0BsaW5rIE5vZGV9IGl0IGlzIGF0dGFjaGVkIHRvLlxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudEF1ZGlvTGlzdGVuZXIgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudEF1ZGlvTGlzdGVuZXIpO1xyXG4gICAgcHVibGljIG10eFBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gQXVkaW9MaXN0ZW5lclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlKF9saXN0ZW5lcjogQXVkaW9MaXN0ZW5lcik6IHZvaWQge1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSB0aGlzLm10eFBpdm90O1xyXG4gICAgICBpZiAodGhpcy5ub2RlKVxyXG4gICAgICAgIG10eFJlc3VsdCA9IE1hdHJpeDR4NC5QUk9EVUNUKHRoaXMubm9kZS5tdHhXb3JsZCwgdGhpcy5tdHhQaXZvdCk7XHJcblxyXG4gICAgICAvLyBEZWJ1Zy5sb2cobXR4UmVzdWx0LnRvU3RyaW5nKCkpO1xyXG4gICAgICBsZXQgcG9zaXRpb246IFZlY3RvcjMgPSBtdHhSZXN1bHQudHJhbnNsYXRpb247XHJcbiAgICAgIGxldCBmb3J3YXJkOiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihWZWN0b3IzLlooMSksIG10eFJlc3VsdCwgZmFsc2UpO1xyXG4gICAgICBsZXQgdXA6IFZlY3RvcjMgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKFZlY3RvcjMuWSgpLCBtdHhSZXN1bHQsIGZhbHNlKTtcclxuICAgICAgaWYgKF9saXN0ZW5lci5wb3NpdGlvblggIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgX2xpc3RlbmVyLnBvc2l0aW9uWC52YWx1ZSA9IHBvc2l0aW9uLng7XHJcbiAgICAgICAgX2xpc3RlbmVyLnBvc2l0aW9uWS52YWx1ZSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgICAgX2xpc3RlbmVyLnBvc2l0aW9uWi52YWx1ZSA9IHBvc2l0aW9uLno7XHJcblxyXG4gICAgICAgIF9saXN0ZW5lci5mb3J3YXJkWC52YWx1ZSA9IGZvcndhcmQueDtcclxuICAgICAgICBfbGlzdGVuZXIuZm9yd2FyZFkudmFsdWUgPSBmb3J3YXJkLnk7XHJcbiAgICAgICAgX2xpc3RlbmVyLmZvcndhcmRaLnZhbHVlID0gZm9yd2FyZC56O1xyXG5cclxuICAgICAgICBfbGlzdGVuZXIudXBYLnZhbHVlID0gdXAueDtcclxuICAgICAgICBfbGlzdGVuZXIudXBZLnZhbHVlID0gdXAueTtcclxuICAgICAgICBfbGlzdGVuZXIudXBaLnZhbHVlID0gdXAuejtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBGaXJlZm94IHN0aWxsIHVzZXMgZGVwcmVjYXRlZCBtZXRob2RzLiBUT0RPOiBkZWxldGUgYXMgc29vbiBhcyBwb3NzaWJsZSFcclxuICAgICAgICBfbGlzdGVuZXIuc2V0UG9zaXRpb24ocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueik7XHJcbiAgICAgICAgX2xpc3RlbmVyLnNldE9yaWVudGF0aW9uKGZvcndhcmQueCwgZm9yd2FyZC55LCBmb3J3YXJkLnosIHVwLngsIHVwLnksIHVwLnopO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBSZWN5Y2xlci5zdG9yZShmb3J3YXJkKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodXApO1xyXG4gICAgICBpZiAodGhpcy5ub2RlKVxyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJlc3VsdCk7XHJcblxyXG4gICAgICAvLyBEZWJ1Zy5sb2cobXR4UmVzdWx0LnRyYW5zbGF0aW9uLnRvU3RyaW5nKCksIGZvcndhcmQudG9TdHJpbmcoKSwgdXAudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVkIHRvIGEge0BsaW5rIE5vZGV9IHdpdGggYW4gYXR0YWNoZWQge0BsaW5rIENvbXBvbmVudENhbWVyYX0gdGhpcyBjYXVzZXMgdGhlIHJlbmRlcmVkIGltYWdlIHRvIHJlY2VpdmUgYSBibG9vbS1lZmZlY3QuXHJcbiAgICogQGF1dGhvcnMgUm9sYW5kIEhlZXIsIEhGVSwgMjAyM1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRCbG9vbSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50Qmxvb20pO1xyXG4gICAgXHJcbiAgICAjdGhyZXNob2xkOiBudW1iZXI7XHJcbiAgICAjaW50ZW5zaXR5OiBudW1iZXI7XHJcbiAgICAjaGlnaGxpZ2h0RGVzYXR1cmF0aW9uOiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF90aHJlc2hvbGQ6IG51bWJlciA9IDAuOTUsIF9pbnRlbnNpdHk6IG51bWJlciA9IDEuMCwgX2Rlc2F0dXJhdGVIaWdobGlnaHRzOiBudW1iZXIgPSAwLjUpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy4jdGhyZXNob2xkID0gX3RocmVzaG9sZDtcclxuICAgICAgdGhpcy4jaW50ZW5zaXR5ID0gX2ludGVuc2l0eTtcclxuICAgICAgdGhpcy4jaGlnaGxpZ2h0RGVzYXR1cmF0aW9uID0gX2Rlc2F0dXJhdGVIaWdobGlnaHRzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdGhyZXNob2xkKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiN0aHJlc2hvbGQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHRocmVzaG9sZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiN0aHJlc2hvbGQgPSBDYWxjLmNsYW1wKF92YWx1ZSwgMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpbnRlbnNpdHkoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2ludGVuc2l0eTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgaW50ZW5zaXR5KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI2ludGVuc2l0eSA9IE1hdGgubWF4KDAsIF92YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBoaWdobGlnaHREZXNhdHVyYXRpb24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2hpZ2hsaWdodERlc2F0dXJhdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgaGlnaGxpZ2h0RGVzYXR1cmF0aW9uKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI2hpZ2hsaWdodERlc2F0dXJhdGlvbiA9IENhbGMuY2xhbXAoX3ZhbHVlLCAwLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIHRocmVzaG9sZDogdGhpcy4jdGhyZXNob2xkLFxyXG4gICAgICAgIGludGVuc2l0eTogdGhpcy4jaW50ZW5zaXR5LFxyXG4gICAgICAgIGRlc2F0dXJhdGVIaWdobGlnaHRzOiB0aGlzLiNoaWdobGlnaHREZXNhdHVyYXRpb24sXHJcbiAgICAgIH07XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy4jdGhyZXNob2xkID0gX3NlcmlhbGl6YXRpb24udGhyZXNob2xkO1xyXG4gICAgICB0aGlzLiNpbnRlbnNpdHkgPSBfc2VyaWFsaXphdGlvbi5pbnRlbnNpdHk7XHJcbiAgICAgIHRoaXMuI2hpZ2hsaWdodERlc2F0dXJhdGlvbiA9IF9zZXJpYWxpemF0aW9uLmRlc2F0dXJhdGVIaWdobGlnaHRzO1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IodHJ1ZSk7XHJcbiAgICAgIG11dGF0b3IudGhyZXNob2xkID0gdGhpcy50aHJlc2hvbGQ7XHJcbiAgICAgIG11dGF0b3IuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XHJcbiAgICAgIG11dGF0b3IuaGlnaGxpZ2h0RGVzYXR1cmF0aW9uID0gdGhpcy5oaWdobGlnaHREZXNhdHVyYXRpb247XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiQ29tcG9uZW50LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgZW51bSBGSUVMRF9PRl9WSUVXIHtcclxuICAgIEhPUklaT05UQUwgPSBcImhvcml6b250YWxcIixcclxuICAgIFZFUlRJQ0FMID0gXCJ2ZXJ0aWNhbFwiLFxyXG4gICAgRElBR09OQUwgPSBcImRpYWdvbmFsXCJcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgaWRlbnRpZmllcnMgZm9yIHRoZSB2YXJpb3VzIHByb2plY3Rpb25zIGEgY2FtZXJhIGNhbiBwcm92aWRlLiAgXHJcbiAgICogVE9ETzogY2hhbmdlIGJhY2sgdG8gbnVtYmVyIGVudW0gaWYgc3RyaW5ncyBub3QgbmVlZGVkXHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gUFJPSkVDVElPTiB7XHJcbiAgICBDRU5UUkFMID0gXCJjZW50cmFsXCIsXHJcbiAgICBPUlRIT0dSQVBISUMgPSBcIm9ydGhvZ3JhcGhpY1wiLFxyXG4gICAgRElNRVRSSUMgPSBcImRpbWV0cmljXCIsXHJcbiAgICBTVEVSRU8gPSBcInN0ZXJlb1wiXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgY2FtZXJhIGNvbXBvbmVudCBob2xkcyB0aGUgcHJvamVjdGlvbi1tYXRyaXggYW5kIG90aGVyIGRhdGEgbmVlZGVkIHRvIHJlbmRlciBhIHNjZW5lIGZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIHRoZSBub2RlIGl0IGlzIGF0dGFjaGVkIHRvLlxyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTkgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjVcclxuICAgKi9cclxuICBAZW51bWVyYXRlXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudENhbWVyYSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50Q2FtZXJhKTtcclxuXHJcbiAgICBwdWJsaWMgbXR4UGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuXHJcbiAgICBwdWJsaWMgY2xyQmFja2dyb3VuZDogQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMSk7IC8vIFRoZSBjb2xvciBvZiB0aGUgYmFja2dyb3VuZCB0aGUgY2FtZXJhIHdpbGwgcmVuZGVyLlxyXG4gICAgLy9wcml2YXRlIG9ydGhvZ3JhcGhpYzogYm9vbGVhbiA9IGZhbHNlOyAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGltYWdlIHdpbGwgYmUgcmVuZGVyZWQgd2l0aCBwZXJzcGVjdGl2ZSBvciBvcnRob2dyYXBoaWMgcHJvamVjdGlvbi5cclxuICAgICNwcm9qZWN0aW9uOiBQUk9KRUNUSU9OID0gUFJPSkVDVElPTi5DRU5UUkFMO1xyXG4gICAgI2ZpZWxkT2ZWaWV3OiBudW1iZXIgPSA0NTsgLy8gVGhlIGNhbWVyYSdzIHNlbnNvcmFuZ2xlLlxyXG4gICAgI2FzcGVjdFJhdGlvOiBudW1iZXIgPSAxLjA7XHJcbiAgICAjZGlyZWN0aW9uOiBGSUVMRF9PRl9WSUVXID0gRklFTERfT0ZfVklFVy5ESUFHT05BTDtcclxuICAgICNuZWFyOiBudW1iZXIgPSAxO1xyXG4gICAgI2ZhcjogbnVtYmVyID0gMjAwMDtcclxuICAgICNiYWNrZ3JvdW5kRW5hYmxlZDogYm9vbGVhbiA9IHRydWU7IC8vIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIGJhY2tncm91bmQgb2YgdGhpcyBjYW1lcmEgd2lsbCBiZSByZW5kZXJlZC4gLy8gVE9ETzogc2VlbXMgdG8gYmUgdW51c2VkLCByZW1vdmU/XHJcbiAgICAvLyBUT0RPOiBleGFtaW5lLCBpZiBiYWNrZ3JvdW5kIHNob3VsZCBiZSBhbiBhdHRyaWJ1dGUgb2YgQ2FtZXJhIG9yIFZpZXdwb3J0XHJcblxyXG4gICAgcmVhZG9ubHkgI210eFdvcmxkVG9WaWV3OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgIHJlYWRvbmx5ICNtdHhDYW1lcmFJbnZlcnNlOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgIHJlYWRvbmx5ICNtdHhQcm9qZWN0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMge0BsaW5rIG10eFByb2plY3Rpb259ICoge0BsaW5rIG10eENhbWVyYUludmVyc2V9XHJcbiAgICAgKiB5aWVsZGluZyB0aGUgd29ybGRzcGFjZSB0byB2aWV3c3BhY2UgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbXR4V29ybGRUb1ZpZXcoKTogTWF0cml4NHg0IHtcclxuICAgICAgaWYgKHRoaXMuI210eFByb2plY3Rpb24ubW9kaWZpZWQgfHwgdGhpcy5tdHhDYW1lcmFJbnZlcnNlLm1vZGlmaWVkKSB7XHJcbiAgICAgICAgTWF0cml4NHg0LlBST0RVQ1QodGhpcy4jbXR4UHJvamVjdGlvbiwgdGhpcy5tdHhDYW1lcmFJbnZlcnNlLCB0aGlzLiNtdHhXb3JsZFRvVmlldyk7XHJcbiAgICAgICAgdGhpcy4jbXR4UHJvamVjdGlvbi5tb2RpZmllZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubXR4Q2FtZXJhSW52ZXJzZS5tb2RpZmllZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy4jbXR4V29ybGRUb1ZpZXc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnZlcnNpb24gb2YgdGhpcyBjYW1lcmFzIHdvcmxkdHJhbnNmb3JtYXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtdHhDYW1lcmFJbnZlcnNlKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGlmICh0aGlzLm10eFdvcmxkLm1vZGlmaWVkKSB7XHJcbiAgICAgICAgTWF0cml4NHg0LklOVkVSU0UodGhpcy5tdHhXb3JsZCwgdGhpcy4jbXR4Q2FtZXJhSW52ZXJzZSk7XHJcbiAgICAgICAgdGhpcy5tdHhXb3JsZC5tb2RpZmllZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy4jbXR4Q2FtZXJhSW52ZXJzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHByb2plY3Rpb25tYXRyaXggb2YgdGhpcyBjYW1lcmEuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbXR4UHJvamVjdGlvbigpOiBNYXRyaXg0eDQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbXR4UHJvamVjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYmFja2dyb3VuZCBvZiB0aGUgY2FtZXJhIHNob3VsZCBiZSByZW5kZXJlZCwgZmFsc2UgaWYgbm90LlxyXG4gICAgICovXHJcbiAgICBAZW51bWVyYXRlXHJcbiAgICBwdWJsaWMgZ2V0IGJhY2tncm91bmRFbmFibGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jYmFja2dyb3VuZEVuYWJsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjYW1lcmFzIHtAbGluayBQUk9KRUNUSU9OfSBtb2RlLlxyXG4gICAgICovXHJcbiAgICBAZW51bWVyYXRlXHJcbiAgICBAdHlwZShQUk9KRUNUSU9OKVxyXG4gICAgcHVibGljIGdldCBwcm9qZWN0aW9uKCk6IFBST0pFQ1RJT04ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcHJvamVjdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNhbWVyYXMgYXNwZWN0IHJhdGlvLlxyXG4gICAgICovXHJcbiAgICBAZW51bWVyYXRlXHJcbiAgICBwdWJsaWMgZ2V0IGFzcGVjdFJhdGlvKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNhc3BlY3RSYXRpbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNhbWVyYXMgZmllbGQgb2YgdmlldyBpbiBkZWdyZWVzLlxyXG4gICAgICovXHJcbiAgICBAZW51bWVyYXRlXHJcbiAgICBwdWJsaWMgZ2V0IGZpZWxkT2ZWaWV3KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNmaWVsZE9mVmlldztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNhbWVyYXMgZGlyZWN0aW9uIGkuZS4gdGhlIHBsYW5lIG9uIHdoaWNoIHRoZSBmaWVsZE9mVmlldy1BbmdsZSBpcyBnaXZlbi5cclxuICAgICAqL1xyXG4gICAgQGVudW1lcmF0ZVxyXG4gICAgQHR5cGUoRklFTERfT0ZfVklFVylcclxuICAgIHB1YmxpYyBnZXQgZGlyZWN0aW9uKCk6IEZJRUxEX09GX1ZJRVcge1xyXG4gICAgICByZXR1cm4gdGhpcy4jZGlyZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2FtZXJhcyBuZWFyIHZhbHVlIGkuZS4gdGhlIG1pbmltdW0gZGlzdGFuY2UgdG8gcmVuZGVyIG9iamVjdHMgYXQuXHJcbiAgICAgKi9cclxuICAgIEBlbnVtZXJhdGVcclxuICAgIHB1YmxpYyBnZXQgbmVhcigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbmVhcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNhbWVyYXMgZmFyIHZhbHVlIGkuZS4gdGhlIG1heGltdW0gZGlzdGFuY2UgdG8gcmVuZGVyIG9iamVjdHMgYXQuXHJcbiAgICAgKi9cclxuICAgIEBlbnVtZXJhdGVcclxuICAgIHB1YmxpYyBnZXQgZmFyKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNmYXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjYW1lcmFzIHtAbGluayBQUk9KRUNUSU9OfSBtb2RlLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBwcm9qZWN0aW9ufSBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UHJvamVjdGlvbigpOiBQUk9KRUNUSU9OIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3Byb2plY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGJhY2tncm91bmQgb2YgdGhlIGNhbWVyYSBzaG91bGQgYmUgcmVuZGVyZWQsIGZhbHNlIGlmIG5vdC5cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgYmFja2dyb3VuZEVuYWJsZWR9IGluc3RlYWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRCYWNrZ3JvdW5kRW5hYmxlZCgpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2JhY2tncm91bmRFbmFibGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2FtZXJhcyBhc3BlY3QgcmF0aW8uXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGFzcGVjdFJhdGlvfSBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QXNwZWN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNhc3BlY3RSYXRpbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNhbWVyYXMgZmllbGQgb2YgdmlldyBpbiBkZWdyZWVzLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBmaWVsZE9mVmlld30gaW5zdGVhZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEZpZWxkT2ZWaWV3KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNmaWVsZE9mVmlldztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNhbWVyYXMgZGlyZWN0aW9uIGkuZS4gdGhlIHBsYW5lIG9uIHdoaWNoIHRoZSBmaWVsZE9mVmlldy1BbmdsZSBpcyBnaXZlbi5cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgZGlyZWN0aW9ufSBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RGlyZWN0aW9uKCk6IEZJRUxEX09GX1ZJRVcge1xyXG4gICAgICByZXR1cm4gdGhpcy4jZGlyZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2FtZXJhcyBuZWFyIHZhbHVlIGkuZS4gdGhlIG1pbmltdW0gZGlzdGFuY2UgdG8gcmVuZGVyIG9iamVjdHMgYXQuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIG5lYXJ9IGluc3RlYWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXROZWFyKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNuZWFyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2FtZXJhcyBmYXIgdmFsdWUgaS5lLiB0aGUgbWF4aW11bSBkaXN0YW5jZSB0byByZW5kZXIgb2JqZWN0cyBhdC5cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgZmFyfSBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RmFyKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNmYXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGNhbWVyYSB0byBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uLiBUaGUgd29ybGQgb3JpZ2luIGlzIGluIHRoZSBjZW50ZXIgb2YgdGhlIGNhbnZhc2VsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gX2FzcGVjdCBUaGUgYXNwZWN0IHJhdGlvIGJldHdlZW4gd2lkdGggYW5kIGhlaWdodCBvZiBwcm9qZWN0aW9uc3BhY2UuKERlZmF1bHQgPSBjYW52YXMuY2xpZW50V2lkdGggLyBjYW52YXMuQ2xpZW50SGVpZ2h0KVxyXG4gICAgICogQHBhcmFtIF9maWVsZE9mVmlldyBUaGUgZmllbGQgb2YgdmlldyBpbiBEZWdyZWVzLiAoRGVmYXVsdCA9IDQ1KVxyXG4gICAgICogQHBhcmFtIF9kaXJlY3Rpb24gVGhlIHBsYW5lIG9uIHdoaWNoIHRoZSBmaWVsZE9mVmlldy1BbmdsZSBpcyBnaXZlbiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHByb2plY3RDZW50cmFsKF9hc3BlY3Q6IG51bWJlciA9IHRoaXMuI2FzcGVjdFJhdGlvLCBfZmllbGRPZlZpZXc6IG51bWJlciA9IHRoaXMuI2ZpZWxkT2ZWaWV3LCBfZGlyZWN0aW9uOiBGSUVMRF9PRl9WSUVXID0gdGhpcy4jZGlyZWN0aW9uLCBfbmVhcjogbnVtYmVyID0gdGhpcy4jbmVhciwgX2ZhcjogbnVtYmVyID0gdGhpcy4jZmFyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI2FzcGVjdFJhdGlvID0gX2FzcGVjdDtcclxuICAgICAgdGhpcy4jZmllbGRPZlZpZXcgPSBfZmllbGRPZlZpZXc7XHJcbiAgICAgIHRoaXMuI2RpcmVjdGlvbiA9IF9kaXJlY3Rpb247XHJcbiAgICAgIHRoaXMuI3Byb2plY3Rpb24gPSBQUk9KRUNUSU9OLkNFTlRSQUw7XHJcbiAgICAgIHRoaXMuI25lYXIgPSBfbmVhcjtcclxuICAgICAgdGhpcy4jZmFyID0gX2ZhcjtcclxuICAgICAgTWF0cml4NHg0LlBST0pFQ1RJT05fQ0VOVFJBTChfYXNwZWN0LCB0aGlzLiNmaWVsZE9mVmlldywgX25lYXIsIF9mYXIsIHRoaXMuI2RpcmVjdGlvbiwgdGhpcy4jbXR4UHJvamVjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGNhbWVyYSB0byBvcnRob2dyYXBoaWMgcHJvamVjdGlvbi4gRGVmYXVsdCB2YWx1ZXMgYXJlIGRlcml2ZWQgdGhlIGNhbnZhcyBjbGllbnQgZGltZW5zaW9uc1xyXG4gICAgICogQHBhcmFtIF9sZWZ0IFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyBsZWZ0IGJvcmRlci4gICAgXHJcbiAgICAgKiBAcGFyYW0gX3JpZ2h0IFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyByaWdodCBib3JkZXIuICBcclxuICAgICAqIEBwYXJhbSBfYm90dG9tIFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyBib3R0b20gYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF90b3AgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIHRvcCBib3JkZXIuICAgICAgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwcm9qZWN0T3J0aG9ncmFwaGljKF9sZWZ0PzogbnVtYmVyLCBfcmlnaHQ/OiBudW1iZXIsIF9ib3R0b20/OiBudW1iZXIsIF90b3A/OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgY29uc3QgcmVjdENhbnZhczogUmVjdGFuZ2xlID0gUmVuZGVyLmdldENhbnZhc1JlY3RhbmdsZSgpO1xyXG4gICAgICBjb25zdCB3aWR0aDogbnVtYmVyID0gcmVjdENhbnZhcy53aWR0aDtcclxuICAgICAgY29uc3QgaGVpZ2h0OiBudW1iZXIgPSByZWN0Q2FudmFzLmhlaWdodDtcclxuICAgICAgX2xlZnQgPSAtd2lkdGggLyAyO1xyXG4gICAgICBfcmlnaHQgPSB3aWR0aCAvIDI7XHJcbiAgICAgIF9ib3R0b20gPSBoZWlnaHQgLyAyO1xyXG4gICAgICBfdG9wID0gLWhlaWdodCAvIDI7XHJcblxyXG4gICAgICB0aGlzLiNwcm9qZWN0aW9uID0gUFJPSkVDVElPTi5PUlRIT0dSQVBISUM7XHJcbiAgICAgIE1hdHJpeDR4NC5QUk9KRUNUSU9OX09SVEhPR1JBUEhJQyhfbGVmdCwgX3JpZ2h0LCBfYm90dG9tLCBfdG9wLCA0MDAsIC00MDAsIHRoaXMuI210eFByb2plY3Rpb24pOyAvLyBUT0RPOiBleGFtaW5lIG1hZ2ljIG51bWJlcnMhXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgKHJlY3ljbGVkKSByZWN0YW5nbGUgb2YgdGhlIGNhbGN1bGF0ZWQgZGltZW5zaW9uIG9mIGEgcHJvamVjdGlvbiBzdXJmYWNlIGluIHRoZSBoeXBvdGhldGljYWwgZGlzdGFuY2Ugb2YgMSB0byB0aGUgY2FtZXJhLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgcmVjdGFuZ2xlIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQcm9qZWN0aW9uUmVjdGFuZ2xlKF9vdXQ6IFJlY3RhbmdsZSA9IFJlY3ljbGVyLnJldXNlKFJlY3RhbmdsZSkpOiBSZWN0YW5nbGUge1xyXG4gICAgICBsZXQgdGFuRm92OiBudW1iZXIgPSBNYXRoLnRhbihNYXRoLlBJICogdGhpcy4jZmllbGRPZlZpZXcgLyAzNjApOyAvLyBIYWxmIG9mIHRoZSBhbmdsZSwgdG8gY2FsY3VsYXRlIGRpbWVuc2lvbiBmcm9tIHRoZSBjZW50ZXIgLT4gcmlnaHQgYW5nbGVcclxuICAgICAgbGV0IHRhbkhvcml6b250YWw6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCB0YW5WZXJ0aWNhbDogbnVtYmVyID0gMDtcclxuXHJcbiAgICAgIGlmICh0aGlzLiNkaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5ESUFHT05BTCkge1xyXG4gICAgICAgIGxldCBhc3BlY3Q6IG51bWJlciA9IE1hdGguc3FydCh0aGlzLiNhc3BlY3RSYXRpbyk7XHJcbiAgICAgICAgdGFuSG9yaXpvbnRhbCA9IHRhbkZvdiAqIGFzcGVjdDtcclxuICAgICAgICB0YW5WZXJ0aWNhbCA9IHRhbkZvdiAvIGFzcGVjdDtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLiNkaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5WRVJUSUNBTCkge1xyXG4gICAgICAgIHRhblZlcnRpY2FsID0gdGFuRm92O1xyXG4gICAgICAgIHRhbkhvcml6b250YWwgPSB0YW5WZXJ0aWNhbCAqIHRoaXMuI2FzcGVjdFJhdGlvO1xyXG4gICAgICB9IGVsc2Ugey8vRk9WX0RJUkVDVElPTi5IT1JJWk9OVEFMXHJcbiAgICAgICAgdGFuSG9yaXpvbnRhbCA9IHRhbkZvdjtcclxuICAgICAgICB0YW5WZXJ0aWNhbCA9IHRhbkhvcml6b250YWwgLyB0aGlzLiNhc3BlY3RSYXRpbztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIF9vdXQuc2V0KDAsIDAsIHRhbkhvcml6b250YWwgKiAyLCB0YW5WZXJ0aWNhbCAqIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gcG9pbnQgZnJvbSB3b3JsZCBzcGFjZSB0byBjbGlwIHNwYWNlLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludFdvcmxkVG9DbGlwKF9wb2ludEluV29ybGRTcGFjZTogVmVjdG9yMywgX291dDogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpKTogVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IG06IEFycmF5TGlrZTxudW1iZXI+ID0gdGhpcy5tdHhXb3JsZFRvVmlldy5nZXRBcnJheSgpO1xyXG4gICAgICBjb25zdCB3OiBudW1iZXIgPSBtWzNdICogX3BvaW50SW5Xb3JsZFNwYWNlLnggKyBtWzddICogX3BvaW50SW5Xb3JsZFNwYWNlLnkgKyBtWzExXSAqIF9wb2ludEluV29ybGRTcGFjZS56ICsgbVsxNV07XHJcblxyXG4gICAgICByZXR1cm4gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfcG9pbnRJbldvcmxkU3BhY2UsIHRoaXMubXR4V29ybGRUb1ZpZXcsIHRydWUsIF9vdXQpLnNjYWxlKDEgLyB3KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGdpdmVuIHBvaW50IGZyb20gY2xpcCBzcGFjZSB0byB3b3JsZCBzcGFjZS5cclxuICAgICAqIEBwYXJhbSBfb3V0IE9wdGlvbmFsIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGlwVG9Xb3JsZChfcG9pbnRJbkNsaXBTcGFjZTogVmVjdG9yMywgX291dDogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpKTogVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IG10eFZpZXdUb1dvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSU5WRVJTRSh0aGlzLm10eFdvcmxkVG9WaWV3KTtcclxuICAgICAgY29uc3QgbTogQXJyYXlMaWtlPG51bWJlcj4gPSBtdHhWaWV3VG9Xb3JsZC5nZXRBcnJheSgpO1xyXG4gICAgICBjb25zdCB3OiBudW1iZXIgPSBtWzNdICogX3BvaW50SW5DbGlwU3BhY2UueCArIG1bN10gKiBfcG9pbnRJbkNsaXBTcGFjZS55ICsgbVsxMV0gKiBfcG9pbnRJbkNsaXBTcGFjZS56ICsgbVsxNV07XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFZpZXdUb1dvcmxkKTtcclxuICAgICAgcmV0dXJuIFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3BvaW50SW5DbGlwU3BhY2UsIG10eFZpZXdUb1dvcmxkLCB0cnVlLCBfb3V0KS5zY2FsZSgxIC8gdyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgc2NhbGluZyBmYWN0b3IgdGhhdCwgZ2l2ZW4gYSBwb3NpdGlvbiBpbiB3b3JsZCBzcGFjZSwgXHJcbiAgICAgKiBzY2FsZXMgYW4gb2JqZWN0IGF0IHRoYXQgcG9zaXRpb24gc28gdGhhdCBvbmUgdW5pdCBlcXVhbHMgb25lIChsb2dpY2FsKSBwaXhlbCBvbiB0aGUgc2NyZWVuIFxyXG4gICAgICogd2hlbiBzZWVuIHRocm91Z2ggdGhpcyBjYW1lcmEuXHJcbiAgICAgKiBlLmcuLCBhZnRlciBzZXR0aW5nIHRoZSBzY2FsaW5nLCAxIHVuaXQgaW4gdGhlIHdvcmxkIGVxdWFscyBvbmUgKGxvZ2ljYWwpIHBpeGVsIG9uIHRoZSBzY3JlZW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRXb3JsZFRvUGl4ZWxTY2FsZShfcG9zV29ybGQ6IFZlY3RvcjMpOiBudW1iZXIge1xyXG4gICAgICBsZXQgZGlzdGFuY2U6IG51bWJlciA9IHRoaXMubXR4V29ybGQudHJhbnNsYXRpb24uZ2V0RGlzdGFuY2UoX3Bvc1dvcmxkKTtcclxuICAgICAgbGV0IHNjYWxlOiBudW1iZXI7XHJcbiAgICAgIGxldCByZWN0OiBSZWN0YW5nbGUgPSBSZW5kZXIuZ2V0UmVuZGVyUmVjdGFuZ2xlKCk7XHJcbiAgICAgIHN3aXRjaCAodGhpcy4jZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBGSUVMRF9PRl9WSUVXLlZFUlRJQ0FMOlxyXG4gICAgICAgICAgc2NhbGUgPSAxIC8gcmVjdC5oZWlnaHQgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRklFTERfT0ZfVklFVy5IT1JJWk9OVEFMOlxyXG4gICAgICAgICAgc2NhbGUgPSAxIC8gcmVjdC53aWR0aCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBGSUVMRF9PRl9WSUVXLkRJQUdPTkFMOlxyXG4gICAgICAgICAgc2NhbGUgPSAxIC8gTWF0aC5zcXJ0KChyZWN0LndpZHRoICogcmVjdC5oZWlnaHQpICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzY2FsZSAqIGRpc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmNsckJhY2tncm91bmQsXHJcbiAgICAgICAgYmFja2dyb3VuZEVuYWJsZWQ6IHRoaXMuI2JhY2tncm91bmRFbmFibGVkLFxyXG4gICAgICAgIHByb2plY3Rpb246IHRoaXMuI3Byb2plY3Rpb24sXHJcbiAgICAgICAgZmllbGRPZlZpZXc6IHRoaXMuI2ZpZWxkT2ZWaWV3LFxyXG4gICAgICAgIGRpcmVjdGlvbjogdGhpcy4jZGlyZWN0aW9uLFxyXG4gICAgICAgIG5lYXI6IHRoaXMuI25lYXIsXHJcbiAgICAgICAgZmFyOiB0aGlzLiNmYXIsXHJcbiAgICAgICAgYXNwZWN0OiB0aGlzLiNhc3BlY3RSYXRpbyxcclxuICAgICAgICBwaXZvdDogdGhpcy5tdHhQaXZvdC5zZXJpYWxpemUoKSxcclxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHRoaXMuY2xyQmFja2dyb3VuZC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5iYWNrZ3JvdW5kQ29sb3IpO1xyXG4gICAgICB0aGlzLiNiYWNrZ3JvdW5kRW5hYmxlZCA9IF9zZXJpYWxpemF0aW9uLmJhY2tncm91bmRFbmFibGVkO1xyXG4gICAgICB0aGlzLiNwcm9qZWN0aW9uID0gX3NlcmlhbGl6YXRpb24ucHJvamVjdGlvbjtcclxuICAgICAgdGhpcy4jZmllbGRPZlZpZXcgPSBfc2VyaWFsaXphdGlvbi5maWVsZE9mVmlldztcclxuICAgICAgdGhpcy4jYXNwZWN0UmF0aW8gPSBfc2VyaWFsaXphdGlvbi5hc3BlY3Q7XHJcbiAgICAgIHRoaXMuI2RpcmVjdGlvbiA9IF9zZXJpYWxpemF0aW9uLmRpcmVjdGlvbjtcclxuICAgICAgdGhpcy4jbmVhciA9IF9zZXJpYWxpemF0aW9uLm5lYXIgPz8gdGhpcy4jbmVhcjtcclxuICAgICAgdGhpcy4jZmFyID0gX3NlcmlhbGl6YXRpb24uZmFyID8/IHRoaXMuI2ZhcjtcclxuICAgICAgYXdhaXQgdGhpcy5tdHhQaXZvdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5waXZvdCk7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgc3dpdGNoICh0aGlzLiNwcm9qZWN0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBQUk9KRUNUSU9OLk9SVEhPR1JBUEhJQzpcclxuICAgICAgICAgIHRoaXMucHJvamVjdE9ydGhvZ3JhcGhpYygpOyAvLyBUT0RPOiBzZXJpYWxpemUgYW5kIGRlc2VyaWFsaXplIHBhcmFtZXRlcnNcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgUFJPSkVDVElPTi5DRU5UUkFMOlxyXG4gICAgICAgICAgdGhpcy5wcm9qZWN0Q2VudHJhbCgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuXHJcbiAgICAgIHN3aXRjaCAodGhpcy4jcHJvamVjdGlvbikge1xyXG4gICAgICAgIGNhc2UgUFJPSkVDVElPTi5DRU5UUkFMOlxyXG4gICAgICAgICAgdGhpcy5wcm9qZWN0Q2VudHJhbCh0aGlzLiNhc3BlY3RSYXRpbywgdGhpcy4jZmllbGRPZlZpZXcsIHRoaXMuI2RpcmVjdGlvbiwgdGhpcy4jbmVhciwgdGhpcy4jZmFyKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRyYXdHaXptb3MoKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IG10eFdvcmxkOiBNYXRyaXg0eDQgPSB0aGlzLm10eFdvcmxkLmNsb25lO1xyXG4gICAgICBtdHhXb3JsZC5zY2FsaW5nID0gbXR4V29ybGQuc2NhbGluZy5zZXQoMC41LCAwLjUsIDAuNSk7XHJcbiAgICAgIGNvbnN0IGNvbG9yOiBDb2xvciA9IENvbG9yLkNTUyhcImxpZ2h0Z3JleVwiKTtcclxuICAgICAgR2l6bW9zLmRyYXdJY29uKFRleHR1cmVEZWZhdWx0Lmljb25DYW1lcmEsIG10eFdvcmxkLCBjb2xvcik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFdvcmxkKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoY29sb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkcmF3R2l6bW9zU2VsZWN0ZWQoKTogdm9pZCB7XHJcbiAgICAgIEdpem1vcy5kcmF3V2lyZUZydXN0dW0odGhpcy4jYXNwZWN0UmF0aW8sIHRoaXMuI2ZpZWxkT2ZWaWV3LCB0aGlzLiNuZWFyLCB0aGlzLiNmYXIsIHRoaXMuI2RpcmVjdGlvbiwgdGhpcy5tdHhXb3JsZCwgQ29sb3IuQ1NTKFwibGlnaHRncmV5XCIpKTtcclxuICAgIH07XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnRyYW5zZm9ybTtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBNYWtlcyB0aGUgbm9kZSBmYWNlIHRoZSBjYW1lcmEgd2hlbiByZW5kZXJpbmcsIHJlc3BlY3RpbmcgcmVzdHJpY3Rpb25zIGZvciByb3RhdGlvbiBhcm91bmQgc3BlY2lmaWMgYXhpc1xyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIyXHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2hzLWZ1cnR3YW5nZW4vRlVER0Uvd2lraS9Db21wb25lbnRcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50RmFjZUNhbWVyYSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50RmFjZUNhbWVyYSk7XHJcblxyXG4gICAgcHVibGljIHVwTG9jYWw6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgcHVibGljIHVwOiBWZWN0b3IzID0gVmVjdG9yMy5ZKDEpO1xyXG4gICAgcHVibGljIHJlc3RyaWN0OiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNpbmdsZXRvbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZWQgdG8gYSB7QGxpbmsgTm9kZX0gd2l0aCBhbiBhdHRhY2hlZCB7QGxpbmsgQ29tcG9uZW50Q2FtZXJhfSB0aGlzIGNhdXNlcyB0aGUgcmVuZGVyZWQgaW1hZ2UgdG8gcmVjZWl2ZSBhIGZvZy1lZmZlY3QuXHJcbiAgICogQGF1dGhvcnMgUm9sYW5kIEhlZXIsIEhGVSwgMjAyM1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRGb2cgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudEZvZyk7XHJcbiAgICBwdWJsaWMgY29sb3I6IENvbG9yO1xyXG4gICAgcHVibGljIG5lYXI6IG51bWJlcjtcclxuICAgIHB1YmxpYyBmYXI6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKSwgX25lYXI6IG51bWJlciA9IDEsIF9mYXI6IG51bWJlciA9IDUwKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuY29sb3IgPSBfY29sb3I7XHJcbiAgICAgIHRoaXMubmVhciA9IF9uZWFyO1xyXG4gICAgICB0aGlzLmZhciA9IF9mYXI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBjb2xvcjogdGhpcy5jb2xvci5zZXJpYWxpemUoKSxcclxuICAgICAgICBuZWFyOiB0aGlzLm5lYXIsXHJcbiAgICAgICAgZmFyOiB0aGlzLmZhclxyXG4gICAgICB9O1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHRoaXMuY29sb3IuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uY29sb3IpO1xyXG4gICAgICB0aGlzLm5lYXIgPSBfc2VyaWFsaXphdGlvbi5uZWFyID8/IHRoaXMubmVhcjtcclxuICAgICAgdGhpcy5mYXIgPSBfc2VyaWFsaXphdGlvbi5mYXIgPz8gdGhpcy5mYXI7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRmlsdGVycyBzeW5jaHJvbml6YXRpb24gYmV0d2VlbiBhIGdyYXBoIGluc3RhbmNlIGFuZCB0aGUgZ3JhcGggaXQgaXMgY29ubmVjdGVkIHRvLiBJZiBhY3RpdmUsIG5vIHN5bmNocm9uaXphdGlvbiBvY2N1cnMuXHJcbiAgICogTWF5YmUgbW9yZSBmaW5lZ3JhaW5lZCBpbiB0aGUgZnV0dXJlLi4uXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjJcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vaHMtZnVydHdhbmdlbi9GVURHRS93aWtpL0NvbXBvbmVudFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRHcmFwaEZpbHRlciBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50R3JhcGhGaWx0ZXIpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zaW5nbGV0b24gPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldE11dGF0b3IoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBEZWZpbmVzIGlkZW50aWZpZXJzIGZvciB0aGUgdmFyaW91cyB0eXBlcyBvZiBsaWdodCB0aGlzIGNvbXBvbmVudCBjYW4gcHJvdmlkZS4gIFxyXG4gICAqL1xyXG4gIC8vIGV4cG9ydCBsZXQgTElHSFRfVFlQRTogeyBbdHlwZTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XHJcbiAgZXhwb3J0IGVudW0gTElHSFRfVFlQRSB7XHJcbiAgICBBTUJJRU5UID0gXCJMaWdodEFtYmllbnRcIixcclxuICAgIERJUkVDVElPTkFMID0gXCJMaWdodERpcmVjdGlvbmFsXCIsXHJcbiAgICBQT0lOVCA9IFwiTGlnaHRQb2ludFwiLFxyXG4gICAgU1BPVCA9IFwiTGlnaHRTcG90XCJcclxuICB9XHJcbiAgLyoqXHJcbiAgICAqIEF0dGFjaGVzIGEge0BsaW5rIExpZ2h0fSB0byB0aGUgbm9kZVxyXG4gICAgKiBUaGUgcGl2b3QgbWF0cml4IGhhcyBkaWZmZXJlbnQgZWZmZWN0cyBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgdGhlIHtAbGluayBMaWdodH0uIFNlZSB0aGVyZSBmb3IgZGV0YWlscy5cclxuICAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudExpZ2h0IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRMaWdodCk7XHJcblxyXG4gICAgQHR5cGUoTElHSFRfVFlQRSlcclxuICAgIHB1YmxpYyBsaWdodFR5cGU6IExJR0hUX1RZUEU7XHJcbiAgICBwdWJsaWMgbXR4UGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgcHVibGljIGNvbG9yOiBDb2xvcjtcclxuICAgIHB1YmxpYyBpbnRlbnNpdHk6IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2xpZ2h0VHlwZTogTElHSFRfVFlQRSA9IExJR0hUX1RZUEUuQU1CSUVOVCwgX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKSwgX2ludGVuc2l0eTogbnVtYmVyID0gMSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNpbmdsZXRvbiA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmxpZ2h0VHlwZSA9IF9saWdodFR5cGU7XHJcbiAgICAgIHRoaXMuY29sb3IgPSBfY29sb3I7XHJcbiAgICAgIHRoaXMuaW50ZW5zaXR5ID0gX2ludGVuc2l0eTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGludGVybmFsIHJlcm91dGUgdG8ge0BsaW5rIFJlbmRlcldlYkdMQ29tcG9uZW50TGlnaHQudXBkYXRlUmVuZGVyYnVmZmVyfSAqL1xyXG4gICAgQFJlbmRlcldlYkdMQ29tcG9uZW50TGlnaHQuZGVjb3JhdGVcclxuICAgIHB1YmxpYyBzdGF0aWMgdXBkYXRlUmVuZGVyYnVmZmVyKF9saWdodHM6IE1hcExpZ2h0VHlwZVRvTGlnaHRMaXN0KTogdm9pZCB7IC8qIGluamVjdGVkICovIH07XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgbGlnaHRUeXBlOiB0aGlzLmxpZ2h0VHlwZSxcclxuICAgICAgICBwaXZvdDogdGhpcy5tdHhQaXZvdC5zZXJpYWxpemUoKSxcclxuICAgICAgICBjb2xvcjogdGhpcy5jb2xvci5zZXJpYWxpemUoKSxcclxuICAgICAgICBpbnRlbnNpdHk6IHRoaXMuaW50ZW5zaXR5XHJcbiAgICAgIH07XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICBpZiAoX3NlcmlhbGl6YXRpb24ubGlnaHRUeXBlICE9IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLmxpZ2h0VHlwZSA9IF9zZXJpYWxpemF0aW9uLmxpZ2h0VHlwZTtcclxuICAgICAgYXdhaXQgdGhpcy5tdHhQaXZvdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5waXZvdCk7XHJcbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi5jb2xvciAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgYXdhaXQgdGhpcy5jb2xvci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5jb2xvcik7XHJcbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi5pbnRlbnNpdHkgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuaW50ZW5zaXR5ID0gX3NlcmlhbGl6YXRpb24uaW50ZW5zaXR5O1xyXG5cclxuICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHJlbW92ZSBpbiBmdXR1cmUgdmVyc2lvbnNcclxuICAgICAgbGV0IGxpZ2h0OiBTZXJpYWxpemF0aW9uID0gX3NlcmlhbGl6YXRpb24ubGlnaHQ7XHJcbiAgICAgIGlmIChsaWdodCAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHBhdGggaW4gbGlnaHQpIHtcclxuICAgICAgICAgIHRoaXMubGlnaHRUeXBlID0gPExJR0hUX1RZUEU+U2VyaWFsaXplci5nZXRDb25zdHJ1Y3RvcihwYXRoKS5uYW1lO1xyXG4gICAgICAgICAgbGlnaHQgPSBsaWdodFtwYXRoXTtcclxuICAgICAgICAgIGlmIChsaWdodC5jb2xvciAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY29sb3IuZGVzZXJpYWxpemUobGlnaHQuY29sb3IpO1xyXG4gICAgICAgICAgaWYgKGxpZ2h0LmludGVuc2l0eSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuaW50ZW5zaXR5ID0gbGlnaHQuaW50ZW5zaXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRyYXdHaXptb3MoKTogdm9pZCB7XHJcbiAgICAgIGxldCBtdHhTaGFwZTogTWF0cml4NHg0ID0gTWF0cml4NHg0LlBST0RVQ1QodGhpcy5ub2RlLm10eFdvcmxkLCB0aGlzLm10eFBpdm90KTtcclxuICAgICAgbXR4U2hhcGUuc2NhbGluZyA9IG5ldyBWZWN0b3IzKDAuNSwgMC41LCAwLjUpO1xyXG4gICAgICBHaXptb3MuZHJhd0ljb24oVGV4dHVyZURlZmF1bHQuaWNvbkxpZ2h0LCBtdHhTaGFwZSwgdGhpcy5jb2xvcik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFNoYXBlKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGRyYXdHaXptb3NTZWxlY3RlZCgpOiB2b2lkIHtcclxuICAgICAgbGV0IG10eFNoYXBlOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUFJPRFVDVCh0aGlzLm5vZGUubXR4V29ybGQsIHRoaXMubXR4UGl2b3QpO1xyXG4gICAgICBsZXQgY29sb3I6IENvbG9yID0gQ29sb3IuQ1NTKFwieWVsbG93XCIpO1xyXG5cclxuICAgICAgc3dpdGNoICh0aGlzLmxpZ2h0VHlwZSkge1xyXG4gICAgICAgIGNhc2UgTElHSFRfVFlQRS5ESVJFQ1RJT05BTDpcclxuICAgICAgICAgIGNvbnN0IHJhZGl1czogbnVtYmVyID0gMC41O1xyXG4gICAgICAgICAgR2l6bW9zLmRyYXdXaXJlQ2lyY2xlKG10eFNoYXBlLCBjb2xvcik7XHJcbiAgICAgICAgICBjb25zdCBsaW5lczogVmVjdG9yM1tdID0gbmV3IEFycmF5KDEwKS5maWxsKG51bGwpLm1hcCgoKSA9PiBSZWN5Y2xlci5nZXQoVmVjdG9yMykpO1xyXG4gICAgICAgICAgbGluZXNbMF0uc2V0KDAsIDAsIDApOyBsaW5lc1sxXS5zZXQoMCwgMCwgMSk7XHJcbiAgICAgICAgICBsaW5lc1syXS5zZXQoMCwgcmFkaXVzLCAwKTsgbGluZXNbM10uc2V0KDAsIHJhZGl1cywgMSk7XHJcbiAgICAgICAgICBsaW5lc1s2XS5zZXQoMCwgLXJhZGl1cywgMCk7IGxpbmVzWzddLnNldCgwLCAtcmFkaXVzLCAxKTtcclxuICAgICAgICAgIGxpbmVzWzRdLnNldChyYWRpdXMsIDAsIDApOyBsaW5lc1s1XS5zZXQocmFkaXVzLCAwLCAxKTtcclxuICAgICAgICAgIGxpbmVzWzhdLnNldCgtcmFkaXVzLCAwLCAwKTsgbGluZXNbOV0uc2V0KC1yYWRpdXMsIDAsIDEpO1xyXG4gICAgICAgICAgR2l6bW9zLmRyYXdMaW5lcyhsaW5lcywgbXR4U2hhcGUsIGNvbG9yKTtcclxuICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKGxpbmVzKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTElHSFRfVFlQRS5QT0lOVDpcclxuICAgICAgICAgIG10eFNoYXBlLnNjYWxlKG5ldyBWZWN0b3IzKDIsIDIsIDIpKTtcclxuICAgICAgICAgIEdpem1vcy5kcmF3V2lyZVNwaGVyZShtdHhTaGFwZSwgY29sb3IpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBMSUdIVF9UWVBFLlNQT1Q6XHJcbiAgICAgICAgICBHaXptb3MuZHJhd1dpcmVDb25lKG10eFNoYXBlLCBjb2xvcik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4U2hhcGUpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShjb2xvcik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgYSB7QGxpbmsgTWF0ZXJpYWx9IHRvIHRoZSBub2RlXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTkgLSAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudE1hdGVyaWFsIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRNYXRlcmlhbCk7XHJcbiAgICBwdWJsaWMgY2xyUHJpbWFyeTogQ29sb3IgPSBDb2xvci5DU1MoXCJ3aGl0ZVwiKTtcclxuICAgIHB1YmxpYyBjbHJTZWNvbmRhcnk6IENvbG9yID0gQ29sb3IuQ1NTKFwid2hpdGVcIik7XHJcbiAgICBwdWJsaWMgbXR4UGl2b3Q6IE1hdHJpeDN4MyA9IE1hdHJpeDN4My5JREVOVElUWSgpO1xyXG4gICAgQHR5cGUoTWF0ZXJpYWwpXHJcbiAgICBwdWJsaWMgbWF0ZXJpYWw6IE1hdGVyaWFsO1xyXG4gICAgLyoqIFN1cHBvcnQgc29ydGluZyBvZiBvYmplY3RzIHdpdGggdHJhbnNwYXJlbmN5IHdoZW4gcmVuZGVyaW5nLCByZW5kZXIgb2JqZWN0cyBpbiB0aGUgYmFjayBmaXJzdC4gV2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1c2VkIGFzIGEgcGFydCBvZiBhIHtAbGluayBQYXJ0aWNsZVN5c3RlbX0sIHRyeSBlbmFibGluZyB0aGlzIHdoZW4gZGlzYWJsaW5nIHtAbGluayBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbS5kZXB0aE1hc2t9ICovXHJcbiAgICBwdWJsaWMgc29ydEZvckFscGhhOiBib29sZWFuID0gZmFsc2U7IC8vIFRPRE86IG1heWJlIG1ha2UgdGhpcyBhIHByb3BlcnR5IG9mIHRoZSBtYXRlcmlhbD9cclxuICAgIC8vIHB1YmxpYyBtdXRhdG9yQ29hdDogTXV0YXRvckZvckNvbXBvbmVudDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX21hdGVyaWFsOiBNYXRlcmlhbCA9IG51bGwpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5tYXRlcmlhbCA9IF9tYXRlcmlhbDtcclxuICAgICAgLy8gdGhpcy5tdXRhdG9yQ29hdCA9IF9tYXRlcmlhbC5nZXRDb2F0KCkuZ2V0TXV0YXRvckZvckNvbXBvbmVudCgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIHNvcnRGb3JBbHBoYTogdGhpcy5zb3J0Rm9yQWxwaGEsXHJcbiAgICAgICAgY2xyUHJpbWFyeTogdGhpcy5jbHJQcmltYXJ5LnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIGNsclNlY29uZGFyeTogdGhpcy5jbHJTZWNvbmRhcnkuc2VyaWFsaXplKCksXHJcbiAgICAgICAgcGl2b3Q6IHRoaXMubXR4UGl2b3Quc2VyaWFsaXplKCksXHJcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKSxcclxuICAgICAgICBpZE1hdGVyaWFsOiB0aGlzLm1hdGVyaWFsLmlkUmVzb3VyY2VcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMubWF0ZXJpYWwgPSA8TWF0ZXJpYWw+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZE1hdGVyaWFsKTtcclxuICAgICAgYXdhaXQgdGhpcy5jbHJQcmltYXJ5LmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmNsclByaW1hcnkpO1xyXG4gICAgICBhd2FpdCB0aGlzLmNsclNlY29uZGFyeS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5jbHJTZWNvbmRhcnkpO1xyXG4gICAgICB0aGlzLnNvcnRGb3JBbHBoYSA9IF9zZXJpYWxpemF0aW9uLnNvcnRGb3JBbHBoYTtcclxuICAgICAgYXdhaXQgdGhpcy5tdHhQaXZvdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5waXZvdCk7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBhIHtAbGluayBNZXNofSB0byB0aGUgbm9kZVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgQGVudW1lcmF0ZVxyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRNZXNoIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRNZXNoKTtcclxuICAgIHB1YmxpYyByZWFkb25seSBtdHhXb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcblxyXG4gICAgQHR5cGUoTWVzaClcclxuICAgIHB1YmxpYyBtZXNoOiBNZXNoO1xyXG4gICAgcHVibGljIHNrZWxldG9uOiBDb21wb25lbnRTa2VsZXRvbjtcclxuXHJcbiAgICAjbXR4UGl2b3Q6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbWVzaD86IE1lc2gsIF9za2VsZXRvbj86IENvbXBvbmVudFNrZWxldG9uKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubWVzaCA9IF9tZXNoO1xyXG4gICAgICB0aGlzLnNrZWxldG9uID0gX3NrZWxldG9uO1xyXG4gICAgfVxyXG5cclxuICAgIEBlbnVtZXJhdGVcclxuICAgIHB1YmxpYyBnZXQgbXR4UGl2b3QoKTogTWF0cml4NHg0IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI210eFBpdm90O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgbXR4UGl2b3QoX210eDogTWF0cml4NHg0KSB7XHJcbiAgICAgIHRoaXMuI210eFBpdm90ID0gX210eDtcclxuICAgICAgdGhpcy4jbXR4UGl2b3QubW9kaWZpZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgcmFkaXVzKCk6IG51bWJlciB7XHJcbiAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gdGhpcy5tdHhXb3JsZC5zY2FsaW5nO1xyXG4gICAgICBsZXQgc2NhbGU6IG51bWJlciA9IE1hdGgubWF4KE1hdGguYWJzKHNjYWxpbmcueCksIE1hdGguYWJzKHNjYWxpbmcueSksIE1hdGguYWJzKHNjYWxpbmcueikpO1xyXG4gICAgICByZXR1cm4gdGhpcy5tZXNoLnJhZGl1cyAqIHNjYWxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIC8qKlxyXG4gICAgLy8gICogQ2FsY3VsYXRlcyB0aGUgcG9zaXRpb24gb2YgYSB2ZXJ0ZXggdHJhbnNmb3JtZWQgYnkgdGhlIHNrZWxldG9uXHJcbiAgICAvLyAgKiBAcGFyYW0gX2luZGV4IGluZGV4IG9mIHRoZSB2ZXJ0ZXhcclxuICAgIC8vICAqL1xyXG4gICAgLy8gcHVibGljIGdldFZlcnRleFBvc2l0aW9uKF9pbmRleDogbnVtYmVyKTogVmVjdG9yMyB7XHJcbiAgICAvLyAgIC8vIGV4dHJhY3QgdGhlIHZlcnRleCBkYXRhICh2ZXJ0aWNlczogM0QgdmVjdG9ycywgYm9uZSBpbmRpY2VzICYgd2VpZ2h0czogNEQgdmVjdG9ycylcclxuICAgIC8vICAgY29uc3QgaVZlcnRleDogbnVtYmVyID0gX2luZGV4ICogMztcclxuICAgIC8vICAgY29uc3QgaUJvbmVJbmZsdWVuY2U6IG51bWJlciA9IF9pbmRleCAqIDQ7XHJcblxyXG4gICAgLy8gICBjb25zdCB2ZXJ0ZXg6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMyguLi5SZWZsZWN0LmdldCh0aGlzLm1lc2gsIFwicmVuZGVyTWVzaFwiKS52ZXJ0aWNlcy5zbGljZShpVmVydGV4LCBpVmVydGV4ICsgMykpO1xyXG4gICAgLy8gICBpZiAoISh0aGlzLm1lc2ggaW5zdGFuY2VvZiBNZXNoU2tpbikpIHJldHVybiB2ZXJ0ZXg7XHJcblxyXG4gICAgLy8gICBjb25zdCBpQm9uZXM6IFVpbnQ4QXJyYXkgPSB0aGlzLm1lc2guaUJvbmVzLnNsaWNlKGlCb25lSW5mbHVlbmNlLCBpQm9uZUluZmx1ZW5jZSArIDQpO1xyXG4gICAgLy8gICBjb25zdCB3ZWlnaHRzOiBGbG9hdDMyQXJyYXkgPSB0aGlzLm1lc2gud2VpZ2h0cy5zbGljZShpQm9uZUluZmx1ZW5jZSwgaUJvbmVJbmZsdWVuY2UgKyA0KTtcclxuXHJcbiAgICAvLyAgIC8vIGdldCBib25lIG1hdHJpY2VzXHJcbiAgICAvLyAgIGNvbnN0IG10eEJvbmVzOiBBcnJheTxNYXRyaXg0eDQ+ID0gdGhpcy5za2VsZXRvbi5tdHhCb25lcztcclxuXHJcbiAgICAvLyAgIC8vIHNraW4gbWF0cml4IFMgPSBzdW1faT0xXm17d19pICogQl9pfVxyXG4gICAgLy8gICBjb25zdCBza2luTWF0cml4OiBNYXRyaXg0eDQgPSBuZXcgTWF0cml4NHg0KCk7XHJcbiAgICAvLyAgIHNraW5NYXRyaXguc2V0KEFycmF5XHJcbiAgICAvLyAgICAgLmZyb20oaUJvbmVzKVxyXG4gICAgLy8gICAgIC5tYXAoKGlCb25lLCBpV2VpZ2h0KSA9PiBtdHhCb25lc1tpQm9uZV0uZ2V0KCkubWFwKHZhbHVlID0+IHZhbHVlICogd2VpZ2h0c1tpV2VpZ2h0XSkpIC8vIGFwcGx5IHdlaWdodCBvbiBlYWNoIG1hdHJpeFxyXG4gICAgLy8gICAgIC5yZWR1Y2UoKG10eFN1bSwgbXR4Qm9uZSkgPT4gbXR4U3VtLm1hcCgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZSArIG10eEJvbmVbaW5kZXhdKSkgLy8gc3VtIHVwIHRoZSBtYXRyaWNlc1xyXG4gICAgLy8gICApO1xyXG5cclxuICAgIC8vICAgLy8gdHJhbnNmb3JtIHZlcnRleFxyXG4gICAgLy8gICB2ZXJ0ZXgudHJhbnNmb3JtKHNraW5NYXRyaXgpO1xyXG5cclxuICAgIC8vICAgcmV0dXJuIHZlcnRleDtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyBUT0RPOiByZW1vdmUgb3IgdGhpbmsgaWYgdGhlIHRyYW5zZm9ybWVkIGJvdW5kaW5nIGJveCBpcyBvZiB2YWx1ZSBvciBjYW4gYmUgbWFkZSB0byBiZVxyXG4gICAgLy8gcHVibGljIGdldCBib3VuZGluZ0JveCgpOiBCb3gge1xyXG4gICAgLy8gICBsZXQgYm94OiBCb3ggPSBSZWN5Y2xlci5nZXQoQm94KTtcclxuICAgIC8vICAgYm94LnNldChcclxuICAgIC8vICAgICBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKHRoaXMubWVzaC5ib3VuZGluZ0JveC5taW4sIHRoaXMubXR4V29ybGQsIHRydWUpLFxyXG4gICAgLy8gICAgIFZlY3RvcjMuVFJBTlNGT1JNQVRJT04odGhpcy5tZXNoLmJvdW5kaW5nQm94Lm1heCwgdGhpcy5tdHhXb3JsZCwgdHJ1ZSlcclxuICAgIC8vICAgKTtcclxuICAgIC8vICAgcmV0dXJuIGJveDtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uO1xyXG4gICAgICAvKiBhdCB0aGlzIHBvaW50IG9mIHRpbWUsIHNlcmlhbGl6YXRpb24gYXMgcmVzb3VyY2UgYW5kIGFzIGlubGluZSBvYmplY3QgaXMgcG9zc2libGUuIFRPRE86IGNoZWNrIGlmIGlubGluZSBiZWNvbWVzIG9ic29sZXRlICovXHJcbiAgICAgIGxldCBpZE1lc2g6IHN0cmluZyA9IHRoaXMubWVzaC5pZFJlc291cmNlO1xyXG4gICAgICBpZiAoaWRNZXNoKVxyXG4gICAgICAgIHNlcmlhbGl6YXRpb24gPSB7IGlkTWVzaDogaWRNZXNoIH07XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBzZXJpYWxpemF0aW9uID0geyBtZXNoOiBTZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLm1lc2gpIH07XHJcblxyXG4gICAgICBpZiAodGhpcy5za2VsZXRvbilcclxuICAgICAgICBzZXJpYWxpemF0aW9uLnNrZWxldG9uID0gTm9kZS5QQVRIX0ZST01fVE8odGhpcywgdGhpcy5za2VsZXRvbik7XHJcblxyXG4gICAgICBzZXJpYWxpemF0aW9uLnBpdm90ID0gdGhpcy5tdHhQaXZvdC5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBsZXQgbWVzaDogTWVzaDtcclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkTWVzaClcclxuICAgICAgICBtZXNoID0gPE1lc2g+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZE1lc2gpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgbWVzaCA9IDxNZXNoPmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ubWVzaCk7XHJcbiAgICAgIHRoaXMubWVzaCA9IG1lc2g7XHJcblxyXG4gICAgICBpZiAoX3NlcmlhbGl6YXRpb24uc2tlbGV0b24pIHtcclxuICAgICAgICBjb25zdCBobmROb2RlRGVzZXJpYWxpemVkOiBFdmVudExpc3RlbmVyVW5pZmllZCA9ICgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGhuZEdyYXBoRGVzZXJpYWxpemVkOiBFdmVudExpc3RlbmVyVW5pZmllZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5za2VsZXRvbiA9IE5vZGUuRklORCh0aGlzLCBfc2VyaWFsaXphdGlvbi5za2VsZXRvbik7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULkdSQVBIX0RFU0VSSUFMSVpFRCwgaG5kR3JhcGhEZXNlcmlhbGl6ZWQsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERVNFUklBTElaRUQsIGhuZE5vZGVEZXNlcmlhbGl6ZWQpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkdSQVBIX0RFU0VSSUFMSVpFRCwgaG5kR3JhcGhEZXNlcmlhbGl6ZWQsIHRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVTRVJJQUxJWkVELCBobmROb2RlRGVzZXJpYWxpemVkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYXdhaXQgdGhpcy5tdHhQaXZvdC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5waXZvdCk7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgcHVibGljIGRyYXdHaXptb3NTZWxlY3RlZCgpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLm1lc2gpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBsZXQgY29sb3I6IENvbG9yID0gQ29sb3IuQ1NTKFwic2FsbW9uXCIpO1xyXG4gICAgICBHaXptb3MuZHJhd1dpcmVNZXNoKHRoaXMubWVzaCwgdGhpcy5tdHhXb3JsZCwgY29sb3IsIDAuMSk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKGNvbG9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVkIHRvIGEge0BsaW5rIE5vZGV9IHdpdGggYW4gYXR0YWNoZWQge0BsaW5rIENvbXBvbmVudENhbWVyYX0gdGhpcyBjYXVzZXMgYWxsIG5vZGVzIGluIHtAbGluayBzZWxlY3Rpb259IHRvIGJlIGRyYXduIHdpdGggYSAxcHggb3V0bGluZS5cclxuICAgKiBAYXV0aG9ycyBKb25hcyBQbG90emt5LCBIRlUsIDIwMjVcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50T3V0bGluZSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgY29sb3I6IENvbG9yO1xyXG4gICAgcHVibGljIGNvbG9yT2NjbHVkZWQ6IENvbG9yO1xyXG4gICAgcHVibGljIHNlbGVjdGlvbjogSXRlcmFibGU8Tm9kZT47XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9zZWxlY3Rpb246IE5vZGVbXSA9IFtdLCBfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDEpLCBfY29sb3JPY2NsdWRlZDogQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zZWxlY3Rpb24gPSBfc2VsZWN0aW9uO1xyXG4gICAgICB0aGlzLmNvbG9yID0gX2NvbG9yO1xyXG4gICAgICB0aGlzLmNvbG9yT2NjbHVkZWQgPSBfY29sb3JPY2NsdWRlZDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgZXhwb3J0IGVudW0gUEFSVElDTEVfU1lTVEVNX1BMQVlNT0RFIHtcclxuICAgIC8qKlBsYXlzIHBhcnRpY2xlIHN5c3RlbSBpbiBhIGxvb3A6IGl0IHJlc3RhcnRzIG9uY2UgaXQgaGl0IHRoZSBlbmQuKi9cclxuICAgIExPT1AsXHJcbiAgICAvKipQbGF5cyBwYXJ0aWNsZSBzeXN0ZW0gb25jZSBhbmQgc3RvcHMgYXQgdGhlIGxhc3QgcG9pbnQgaW4gdGltZS4qL1xyXG4gICAgUExBWV9PTkNFXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBhIHtAbGluayBQYXJ0aWNsZVN5c3RlbX0gdG8gdGhlIG5vZGUuIFxyXG4gICAqIFdvcmtzIGluIGNvbmp1bmN0aW9uIHdpdGgge0BsaW5rIENvbXBvbmVudE1lc2h9IGFuZCB7QGxpbmsgQ29tcG9uZW50TWF0ZXJpYWx9IHRvIGNyZWF0ZSBhIHNoYWRlciBwYXJ0aWNsZSBzeXN0ZW0uXHJcbiAgICogQWRkaXRpb25hbGx5IGEge0BsaW5rIENvbXBvbmVudEZhY2VDYW1lcmF9IGNhbiBiZSBhdHRhY2hlZCB0byBtYWtlIHRoZSBwYXJ0aWNsZXMgZmFjZSB0aGUgY2FtZXJhLlxyXG4gICAqIEBhdXRob3IgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIyXHJcbiAgICovXHJcbiAgQGVudW1lcmF0ZVxyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50UGFydGljbGVTeXN0ZW0pO1xyXG4gICAgQHR5cGUoUGFydGljbGVTeXN0ZW0pXHJcbiAgICBwdWJsaWMgcGFydGljbGVTeXN0ZW06IFBhcnRpY2xlU3lzdGVtO1xyXG4gICAgLyoqIFdoZW4gZGlzYWJsZWQgdHJ5IGVuYWJsaW5nIHtAbGluayBDb21wb25lbnRNYXRlcmlhbC5zb3J0Rm9yQWxwaGF9ICovXHJcbiAgICBwdWJsaWMgZGVwdGhNYXNrOiBib29sZWFuO1xyXG4gICAgcHVibGljIGJsZW5kTW9kZTogQkxFTkQ7XHJcbiAgICBwdWJsaWMgcGxheU1vZGU6IFBBUlRJQ0xFX1NZU1RFTV9QTEFZTU9ERTtcclxuICAgIHB1YmxpYyBkdXJhdGlvbjogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgQSB0ZXh0dXJlIGZpbGVkIHdpdGggcmFuZG9tIG51bWJlcnMuIFVzZWQgYnkgdGhlIHJlbmRlciBlbmdpbmUgKi9cclxuICAgIHByb3RlY3RlZCByZW5kZXJEYXRhOiB1bmtub3duO1xyXG5cclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHBhcnRpY2xlcyAqL1xyXG4gICAgI3NpemU6IG51bWJlcjtcclxuICAgICN0aW1lU2NhbGU6IG51bWJlciA9IDE7XHJcbiAgICByZWFkb25seSAjdGltZTogVGltZTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3BhcnRpY2xlU3lzdGVtOiBQYXJ0aWNsZVN5c3RlbSA9IG51bGwpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5wYXJ0aWNsZVN5c3RlbSA9IF9wYXJ0aWNsZVN5c3RlbTtcclxuICAgICAgdGhpcy5kZXB0aE1hc2sgPSB0cnVlO1xyXG4gICAgICB0aGlzLmJsZW5kTW9kZSA9IEJMRU5ELkFERElUSVZFO1xyXG4gICAgICB0aGlzLnBsYXlNb2RlID0gUEFSVElDTEVfU1lTVEVNX1BMQVlNT0RFLkxPT1A7XHJcbiAgICAgIHRoaXMuZHVyYXRpb24gPSAxMDAwO1xyXG4gICAgICB0aGlzLnNpemUgPSAxMDtcclxuICAgICAgdGhpcy4jdGltZSA9IG5ldyBUaW1lKCk7XHJcblxyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy5obmRFdmVudCk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLmhuZEV2ZW50KTtcclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVTRVJJQUxJWkVELCB0aGlzLmhuZEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIHBhcnRpY2xlc1xyXG4gICAgICovXHJcbiAgICBAZW51bWVyYXRlXHJcbiAgICBwdWJsaWMgZ2V0IHNpemUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG51bWJlciBvZiBwYXJ0aWNsZXMuIENhdXRpb246IFNldHRpbmcgdGhpcyB3aWxsIHJlaW5pdGlhbGl6ZSB0aGUgcmFuZG9tIG51bWJlcnMgYXJyYXkodGV4dHVyZSkgdXNlZCBpbiB0aGUgc2hhZGVyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IHNpemUoX3NpemU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzaXplID0gX3NpemU7XHJcbiAgICAgIHRoaXMuZGVsZXRlUmVuZGVyRGF0YSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdGltZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jdGltZS5nZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHRpbWUoX3RpbWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiN0aW1lLnNldChfdGltZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB0aW1lU2NhbGUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3RpbWVTY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHRpbWVTY2FsZShfc2NhbGU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiN0aW1lU2NhbGUgPSBfc2NhbGU7XHJcbiAgICAgIHRoaXMudXBkYXRlVGltZVNjYWxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogR2VuZXJhdGVzIGFuZCBiaW5kcyB0aGUgcmFuZG9tIG51bWJlcnMgdGV4dHVyZSBpbiBXZWJHTFxyXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yQ29tcG9uZW50UGFydGljbGVTeXN0ZW19LiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLlxyXG4gICAgICogQGludGVybmFsIFxyXG4gICAgICovXHJcbiAgICBAUmVuZGVySW5qZWN0b3JDb21wb25lbnRQYXJ0aWNsZVN5c3RlbS5kZWNvcmF0ZVxyXG4gICAgcHVibGljIHVzZVJlbmRlckRhdGEoKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgUmVuZGVySW5qZWN0b3IqLyB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogRGVsZXRlcyB0aGUgcmFuZG9tIG51bWJlcnMgdGV4dHVyZSBpbiBXZWJHTCBmcmVlaW5nIHRoZSBhbGxvY2F0ZWQgZ3B1IG1lbW9yeS5cclxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvckNvbXBvbmVudFBhcnRpY2xlU3lzdGVtfS4gXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgQFJlbmRlckluamVjdG9yQ29tcG9uZW50UGFydGljbGVTeXN0ZW0uZGVjb3JhdGVcclxuICAgIHB1YmxpYyBkZWxldGVSZW5kZXJEYXRhKCk6IHZvaWQgey8qIGluamVjdGVkIGJ5IFJlbmRlckluamVjdG9yKi8gfVxyXG5cclxuICAgIC8vI3JlZ2lvbiB0cmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKSxcclxuICAgICAgICBpZFBhcnRpY2xlU3lzdGVtOiB0aGlzLnBhcnRpY2xlU3lzdGVtPy5pZFJlc291cmNlLFxyXG4gICAgICAgIGRlcHRoTWFzazogdGhpcy5kZXB0aE1hc2ssXHJcbiAgICAgICAgYmxlbmRNb2RlOiB0aGlzLmJsZW5kTW9kZSxcclxuICAgICAgICBwbGF5TW9kZTogdGhpcy5wbGF5TW9kZSxcclxuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcclxuICAgICAgICBzaXplOiB0aGlzLnNpemVcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgaWYgKF9zZXJpYWxpemF0aW9uLmlkUGFydGljbGVTeXN0ZW0pIHRoaXMucGFydGljbGVTeXN0ZW0gPSA8UGFydGljbGVTeXN0ZW0+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZFBhcnRpY2xlU3lzdGVtKTtcclxuICAgICAgdGhpcy5kZXB0aE1hc2sgPSBfc2VyaWFsaXphdGlvbi5kZXB0aE1hc2s7XHJcbiAgICAgIHRoaXMuYmxlbmRNb2RlID0gX3NlcmlhbGl6YXRpb24uYmxlbmRNb2RlO1xyXG4gICAgICB0aGlzLnBsYXlNb2RlID0gX3NlcmlhbGl6YXRpb24ucGxheU1vZGU7XHJcbiAgICAgIHRoaXMuZHVyYXRpb24gPSBfc2VyaWFsaXphdGlvbi5kdXJhdGlvbjtcclxuICAgICAgdGhpcy5zaXplID0gX3NlcmlhbGl6YXRpb24uc2l6ZTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yRm9yQW5pbWF0aW9uKCk6IE11dGF0b3JGb3JBbmltYXRpb24ge1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvckZvckFuaW1hdGlvbiA9IDxNdXRhdG9yRm9yQW5pbWF0aW9uPnRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBkZWxldGUgbXV0YXRvci5wYXJ0aWNsZVN5c3RlbTtcclxuICAgICAgZGVsZXRlIG11dGF0b3Iuc2l6ZTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gc3VwZXIuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKHR5cGVzLmJsZW5kTW9kZSlcclxuICAgICAgICB0eXBlcy5ibGVuZE1vZGUgPSBCTEVORDtcclxuICAgICAgaWYgKHR5cGVzLnBsYXlNb2RlKVxyXG4gICAgICAgIHR5cGVzLnBsYXlNb2RlID0gUEFSVElDTEVfU1lTVEVNX1BMQVlNT0RFO1xyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBwcml2YXRlIGhuZEV2ZW50ID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgc3dpdGNoIChfZXZlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgRVZFTlQuTk9ERV9ERVNFUklBTElaRUQ6XHJcbiAgICAgICAgY2FzZSBFVkVOVC5DT01QT05FTlRfQUREOlxyXG4gICAgICAgICAgVGltZS5nYW1lLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuVElNRV9TQ0FMRUQsIHRoaXMudXBkYXRlVGltZVNjYWxlKTtcclxuICAgICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULlJFTkRFUl9QUkVQQVJFLCB0aGlzLnVwZGF0ZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEVWRU5ULkNPTVBPTkVOVF9SRU1PVkU6XHJcbiAgICAgICAgICBUaW1lLmdhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5USU1FX1NDQUxFRCwgdGhpcy51cGRhdGVUaW1lU2NhbGUpO1xyXG4gICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuUkVOREVSX1BSRVBBUkUsIHRoaXMudXBkYXRlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgaWYgKHRoaXMudGltZSA+IHRoaXMuZHVyYXRpb24pXHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnBsYXlNb2RlKSB7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY2FzZSBQQVJUSUNMRV9TWVNURU1fUExBWU1PREUuTE9PUDpcclxuICAgICAgICAgICAgdGhpcy50aW1lID0gMDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFBBUlRJQ0xFX1NZU1RFTV9QTEFZTU9ERS5QTEFZX09OQ0U6XHJcbiAgICAgICAgICAgIHRoaXMudGltZSA9IHRoaXMuZHVyYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMudGltZVNjYWxlID0gMDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZVRpbWVTY2FsZSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgbGV0IHRpbWVTY2FsZTogbnVtYmVyID0gdGhpcy4jdGltZVNjYWxlICogVGltZS5nYW1lLmdldFNjYWxlKCk7XHJcbiAgICAgIHRoaXMuI3RpbWUuc2V0U2NhbGUodGltZVNjYWxlKTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGVudW0gUElDSyB7XHJcbiAgICBSQURJVVMgPSBcInJhZGl1c1wiLFxyXG4gICAgQ0FNRVJBID0gXCJjYW1lcmFcIixcclxuICAgIFBIWVNJQ1MgPSBcInBoeXNpY3NcIlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGlja2luZyBmdW5jdGlvbmFsaXR5IHRvIHRoZSBub2RlXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50UGljayBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50UGljayk7XHJcbiAgICBwdWJsaWMgcGljazogUElDSyA9IFBJQ0suUkFESVVTO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGlja3MgdGhlIG5vZGUgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB7QGxpbmsgUmF5fSBhbmQgaW52b2tlcyBldmVudHMgYWNjb3JkaW5nbHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBpY2tBbmREaXNwYXRjaChfcmF5OiBSYXksIF9ldmVudDogUG9pbnRlckV2ZW50KTogdm9pZCB7XHJcbiAgICAgIGxldCBjbXBNZXNoOiBDb21wb25lbnRNZXNoID0gdGhpcy5ub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IzID0gY21wTWVzaCA/IGNtcE1lc2gubXR4V29ybGQudHJhbnNsYXRpb24gOiB0aGlzLm5vZGUubXR4V29ybGQudHJhbnNsYXRpb247XHJcblxyXG4gICAgICBzd2l0Y2ggKHRoaXMucGljaykge1xyXG4gICAgICAgIGNhc2UgUElDSy5SQURJVVM6XHJcbiAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgb25seSBiZSBub2RlLnJhZGl1cy4gQWRqdXN0bWVudCBuZWVkZWQsIGlmIG1lc2ggd2FzIHRyYW5zZm9ybWVkLi4uXHJcbiAgICAgICAgICBpZiAoX3JheS5nZXREaXN0YW5jZShwb3NpdGlvbikubWFnbml0dWRlIDwgdGhpcy5ub2RlLnJhZGl1cykge1xyXG4gICAgICAgICAgICB0aGlzLm5vZGUuZGlzcGF0Y2hFdmVudChfZXZlbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBQSUNLLlBIWVNJQ1M6XHJcbiAgICAgICAgICBsZXQgaGl0SW5mbzogUmF5SGl0SW5mbyA9IFBoeXNpY3MucmF5Y2FzdChfcmF5Lm9yaWdpbiwgX3JheS5kaXJlY3Rpb24sIFZlY3RvcjMuRElGRkVSRU5DRShwb3NpdGlvbiwgX3JheS5vcmlnaW4pLm1hZ25pdHVkZVNxdWFyZWQpO1xyXG4gICAgICAgICAgaWYgKGhpdEluZm8uaGl0KVxyXG4gICAgICAgICAgICB0aGlzLm5vZGUuZGlzcGF0Y2hFdmVudChfZXZlbnQpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy9UT0RPOiBQSUNLLkNBTUVSQVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gc3VwZXIuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKHR5cGVzLnBpY2spXHJcbiAgICAgICAgdHlwZXMucGljayA9IFBJQ0s7XHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZHJhd0dpem1vc1NlbGVjdGVkKF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSk6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy5waWNrICE9IFBJQ0suUkFESVVTKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCB0cmFuc2xhdGlvbjogVmVjdG9yMyA9ICh0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpPy5tdHhXb3JsZCA/PyB0aGlzLm5vZGUubXR4V29ybGQpLnRyYW5zbGF0aW9uO1xyXG5cclxuICAgICAgbGV0IGNvbG9yOiBDb2xvciA9IENvbG9yLkNTUyhcIndoaXRlXCIsIDAuNSk7XHJcbiAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpLnNldCh0aGlzLm5vZGUucmFkaXVzICogMiwgdGhpcy5ub2RlLnJhZGl1cyAqIDIsIHRoaXMubm9kZS5yYWRpdXMgKiAyKTtcclxuICAgICAgbGV0IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuQ09NUE9TSVRJT04odHJhbnNsYXRpb24sIHVuZGVmaW5lZCwgc2NhbGluZyk7XHJcbiAgICAgIEdpem1vcy5kcmF3U3BoZXJlKG10eFdvcmxkLCBjb2xvcik7XHJcblxyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhXb3JsZCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHNjYWxpbmcpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShjb2xvcik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQmFzZSBjbGFzcyBmb3Igc2NyaXB0cyB0aGUgdXNlciB3cml0ZXNcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ocy1mdXJ0d2FuZ2VuL0ZVREdFL3dpa2kvQ29tcG9uZW50XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudFNjcmlwdCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICAvLyByZWdpc3RlcmluZyB0aGlzIGRvZXNuJ3QgbWFrZSBzZW5zZSwgb25seSBpdHMgc3ViY2xhc3Nlcy4gT3IgdGhpcyBjb21wb25lbnQgbXVzdCByZWZlciB0byBzY3JpcHRzIHRvIGJlIGF0dGFjaGVkIHRvIHRoaXMgY29tcG9uZW50XHJcbiAgICAvLyBUT0RPOiByZXRoaW5rICYgcmVmYWN0b3JcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRTY3JpcHQpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zaW5nbGV0b24gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRNdXRhdG9yKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMubXV0YXRlKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgYSB7QGxpbmsgVGV4dHVyZVRleHR9IHRvIHRoZSBub2RlLiBcclxuICAgKiBXb3JrcyBpbiBjb25qdW5jdGlvbiB3aXRoIHtAbGluayBDb21wb25lbnRNZXNofSBhbmQge0BsaW5rIENvbXBvbmVudE1hdGVyaWFsfSB0byBjcmVhdGUgYSB0ZXh0IG5vZGUuXHJcbiAgICogQSAndGV4dHVyZWQnIHtAbGluayBNYXRlcmlhbH0gKGUuZy4ge0BsaW5rIFNoYWRlckxpdFRleHR1cmVkfSkgbXVzdCBiZSB1c2VkIHRvIGRpc3BsYXkgdGhlIHRleHQgcHJvcGVybHkuIElkZWFsbHkgYSB7QGxpbmsgTWVzaFF1YWR9IHNob3VsZCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgdGV4dCBvbnRvLlxyXG4gICAqIEFkZGl0aW9uYWxseSBhIHtAbGluayBDb21wb25lbnRGYWNlQ2FtZXJhfSBjYW4gYmUgYXR0YWNoZWQgdG8gbWFrZSB0aGUgdGV4dCBmYWNlIHRoZSBjYW1lcmEuXHJcbiAgICogQGF1dGhvcnMgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDI0XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvbXBvbmVudFRleHQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudFRleHQpO1xyXG5cclxuICAgIHB1YmxpYyByZWFkb25seSB0ZXh0dXJlOiBUZXh0dXJlVGV4dDtcclxuICAgIHB1YmxpYyByZWFkb25seSBtdHhXb3JsZDogTWF0cml4NHg0O1xyXG5cclxuICAgIC8qKiAtIG9uOiBUaGUgdGV4dHMgc2l6ZSBpcyBmaXhlZCB0byBtYXRjaCB0aGUgc2V0IGZvbnQgc2l6ZVxyXG4gICAgICogIC0gb2ZmOiBUaGUgZm9udCBzaXplIGlzIHN0cmV0Y2hlZCB0byBtYXRjaCB0aGUgYXR0YWNoZWQgbWVzaGVzIHNpemVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGZpeGVkU2l6ZTogYm9vbGVhbjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3RleHQ/OiBzdHJpbmcsIF9mb250Pzogc3RyaW5nKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMudGV4dHVyZSA9IG5ldyBUZXh0dXJlVGV4dChDb21wb25lbnRUZXh0Lm5hbWUsIF90ZXh0LCBfZm9udCk7XHJcbiAgICAgIHRoaXMubXR4V29ybGQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuICAgICAgdGhpcy5maXhlZFNpemUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXNlUmVuZGVyRGF0YShfbXR4TWVzaFRvV29ybGQ6IE1hdHJpeDR4NCwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogTWF0cml4NHg0IHtcclxuICAgICAgdGhpcy50ZXh0dXJlLnVzZVJlbmRlckRhdGEoVEVYVFVSRV9MT0NBVElPTi5DT0xPUi5VTklUKTtcclxuICAgICAgdGhpcy5tdHhXb3JsZC5jb3B5KF9tdHhNZXNoVG9Xb3JsZCk7XHJcblxyXG4gICAgICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmZpeGVkU2l6ZSkge1xyXG4gICAgICAgIGxldCBzY2FsZTogbnVtYmVyID0gX2NtcENhbWVyYS5nZXRXb3JsZFRvUGl4ZWxTY2FsZShfbXR4TWVzaFRvV29ybGQudHJhbnNsYXRpb24pO1xyXG4gICAgICAgIHRoaXMubXR4V29ybGQuc2NhbGluZyA9IHNjYWxpbmcuc2V0KHRoaXMudGV4dHVyZS53aWR0aCAqIHNjYWxlLCB0aGlzLnRleHR1cmUuaGVpZ2h0ICogc2NhbGUsIDEpOztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgcGl4ZWxzVG9Vbml0czogbnVtYmVyID0gMSAvIHRoaXMudGV4dHVyZS5oZWlnaHQ7XHJcbiAgICAgICAgc2NhbGluZy5zZXQodGhpcy50ZXh0dXJlLndpZHRoICogcGl4ZWxzVG9Vbml0cywgdGhpcy50ZXh0dXJlLmhlaWdodCAqIHBpeGVsc1RvVW5pdHMsIDEpO1xyXG4gICAgICAgIHRoaXMubXR4V29ybGQuc2NhbGUoc2NhbGluZyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHNjYWxpbmcpO1xyXG4gICAgICByZXR1cm4gdGhpcy5tdHhXb3JsZDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZHJhd0dpem1vc1NlbGVjdGVkKCk6IHZvaWQge1xyXG4gICAgICBsZXQgbWVzaDogTWVzaCA9IHRoaXMubm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCk/Lm1lc2g7XHJcbiAgICAgIGxldCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWwgPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1hdGVyaWFsKTtcclxuICAgICAgaWYgKG1lc2ggPT0gbnVsbCB8fCBjbXBNYXRlcmlhbCA9PSBudWxsKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIEdpem1vcy5kcmF3V2lyZU1lc2gobWVzaCwgdGhpcy5tdHhXb3JsZCwgY21wTWF0ZXJpYWwuY2xyUHJpbWFyeSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci50ZXh0dXJlLm5hbWU7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIGV4cG9ydCBlbnVtIEJBU0Uge1xyXG4gICAgU0VMRiwgUEFSRU5ULCBXT1JMRCwgTk9ERVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgYSB0cmFuc2Zvcm0te0BsaW5rIE1hdHJpeDR4NH0gdG8gdGhlIG5vZGUsIG1vdmluZywgc2NhbGluZyBhbmQgcm90YXRpbmcgaXQgaW4gc3BhY2UgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC5cclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRUcmFuc2Zvcm0gZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudFRyYW5zZm9ybSk7XHJcbiAgICBwdWJsaWMgbXR4TG9jYWw6IE1hdHJpeDR4NDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX210eEluaXQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMubXR4TG9jYWwgPSBfbXR4SW5pdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmb3JtYXRpb25zIHJlc3BlY3RpbmcgdGhlIGhpZXJhcmNoeVxyXG4gICAgLyoqXHJcbiAgICAgKiByZWNhbGN1bGF0ZXMgdGhpcyBsb2NhbCBtYXRyaXggdG8geWllbGQgdGhlIGlkZW50aWNhbCB3b3JsZCBtYXRyaXggYmFzZWQgb24gdGhlIGdpdmVuIG5vZGUuXHJcbiAgICAgKiBVc2UgcmViYXNlIGJlZm9yZSBhcHBlbmRpbmcgdGhlIGNvbnRhaW5lciBvZiB0aGlzIGNvbXBvbmVudCB0byBhbm90aGVyIG5vZGUgd2hpbGUgcHJlc2VydmluZyBpdHMgdHJhbnNmb3JtYXRpb24gaW4gdGhlIHdvcmxkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmViYXNlKF9ub2RlOiBOb2RlID0gbnVsbCk6IHZvaWQge1xyXG4gICAgICBsZXQgbXR4UmVzdWx0OiBNYXRyaXg0eDQgPSB0aGlzLm10eExvY2FsO1xyXG4gICAgICBsZXQgY29udGFpbmVyOiBOb2RlID0gdGhpcy5ub2RlO1xyXG4gICAgICBpZiAoY29udGFpbmVyKVxyXG4gICAgICAgIG10eFJlc3VsdCA9IGNvbnRhaW5lci5tdHhXb3JsZDtcclxuXHJcbiAgICAgIGlmIChfbm9kZSlcclxuICAgICAgICBtdHhSZXN1bHQgPSBNYXRyaXg0eDQuUkVMQVRJVkUobXR4UmVzdWx0LCBudWxsLCBfbm9kZS5tdHhXb3JsZEludmVyc2UpO1xyXG5cclxuICAgICAgdGhpcy5tdHhMb2NhbCA9IG10eFJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIHRyYW5zZm9ybWF0aW9uIHJlbGF0aXZlIHRvIHRoZSBzZWxlY3RlZCBiYXNlIChTRUxGLCBQQVJFTlQsIFdPUkxEKSBvciBhIHBhcnRpY3VsYXIgb3RoZXIgbm9kZSAoTk9ERSlcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zZm9ybShfbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQsIF9iYXNlOiBCQVNFID0gQkFTRS5TRUxGLCBfbm9kZTogTm9kZSA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgc3dpdGNoIChfYmFzZSkge1xyXG4gICAgICAgIGNhc2UgQkFTRS5TRUxGOlxyXG4gICAgICAgICAgdGhpcy5tdHhMb2NhbC5tdWx0aXBseShfbXR4VHJhbnNmb3JtKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQkFTRS5QQVJFTlQ6XHJcbiAgICAgICAgICB0aGlzLm10eExvY2FsLm11bHRpcGx5KF9tdHhUcmFuc2Zvcm0sIHRydWUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCQVNFLk5PREU6XHJcbiAgICAgICAgICBpZiAoIV9ub2RlKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCQVNFLk5PREUgcmVxdWlyZXMgYSBub2RlIGdpdmVuIGFzIGJhc2VcIik7XHJcbiAgICAgICAgY2FzZSBCQVNFLldPUkxEOlxyXG4gICAgICAgICAgdGhpcy5yZWJhc2UoX25vZGUpO1xyXG4gICAgICAgICAgdGhpcy5tdHhMb2NhbC5tdWx0aXBseShfbXR4VHJhbnNmb3JtLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICBsZXQgbm9kZTogTm9kZSA9IHRoaXMubm9kZTtcclxuICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgIGxldCBtdHhUZW1wOiBNYXRyaXg0eDQ7XHJcbiAgICAgICAgICAgIGlmIChfYmFzZSA9PSBCQVNFLk5PREUpIHtcclxuICAgICAgICAgICAgICAvLyBmaXggbXR4V29ybGQgb2YgY29udGFpbmVyIGZvciBzdWJzZXF1ZW50IHJlYmFzaW5nIFxyXG4gICAgICAgICAgICAgIG10eFRlbXAgPSBNYXRyaXg0eDQuUFJPRFVDVChfbm9kZS5tdHhXb3JsZCwgbm9kZS5tdHhMb2NhbCk7XHJcbiAgICAgICAgICAgICAgbm9kZS5tdHhXb3JsZC5jb3B5KG10eFRlbXApO1xyXG4gICAgICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFRlbXApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgcGFyZW50OiBOb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgIC8vIGZpeCBtdHhMb2NhbCBmb3IgY3VycmVudCBwYXJlbnRcclxuICAgICAgICAgICAgICB0aGlzLnJlYmFzZShub2RlLmdldFBhcmVudCgpKTtcclxuICAgICAgICAgICAgICBtdHhUZW1wID0gTWF0cml4NHg0LlBST0RVQ1Qobm9kZS5nZXRQYXJlbnQoKS5tdHhXb3JsZCwgbm9kZS5tdHhMb2NhbCk7XHJcbiAgICAgICAgICAgICAgbm9kZS5tdHhXb3JsZC5jb3B5KG10eFRlbXApO1xyXG4gICAgICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFRlbXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBsb2NhbDogdGhpcy5tdHhMb2NhbC5zZXJpYWxpemUoKSxcclxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdKTtcclxuICAgICAgYXdhaXQgdGhpcy5tdHhMb2NhbC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5sb2NhbCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvdmVycmlkZSBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb24/OiBzdHJpbmdbXSwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICAvLyBzdXBlci5tdXRhdGVTeW5jKF9tdXRhdG9yLCBfZGlzcGF0Y2hNdXRhdGUpO1xyXG4gICAgICAvLyBpbmxpbmUgbXV0YXRpb24gZm9yIGFuaW1hdGlvbiBwZXJmb3JtYW5jZSwgc2xpZ2h0bHkgZmFzdGVyIHRoYW4gY2FsbGluZyBzdXBlci5tdXRhdGVcclxuICAgICAgaWYgKF9tdXRhdG9yLmFjdGl2ZSAhPSB1bmRlZmluZWQpIFxyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUoX211dGF0b3IuYWN0aXZlKTtcclxuICAgICAgaWYgKF9tdXRhdG9yLm10eExvY2FsICE9IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLm10eExvY2FsLm11dGF0ZShfbXV0YXRvci5tdHhMb2NhbCk7XHJcbiAgICAgIGlmIChfZGlzcGF0Y2hNdXRhdGUpXHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChFVkVOVC5NVVRBVEUsIHsgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiB7IG11dGF0b3I6IF9tdXRhdG9yIH0gfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci53b3JsZDtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcblxyXG4gIC8vIGZ1bmN0aW9uIGRlY29yYXRlTXV0YWJsZTxNIGV4dGVuZHMgKHRoaXM6IEdlbmVyYWwsIC4uLmFyZ3M6IEdlbmVyYWwpID0+IEdlbmVyYWw+KF9tZXRob2Q6IE0sIF9jb250ZXh0OiBDbGFzc01ldGhvZERlY29yYXRvckNvbnRleHQ8dHlwZW9mIENvYXQsIE0+KTogTSB7XHJcbiAgLy8gICByZXR1cm4gXHJcbiAgLy8gfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgYSBWUiBDb250cm9sbGVyIGFuZCBpdHMgY2FwYWJpbGl0aWVzLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBWUkNvbnRyb2xsZXIge1xyXG4gICAgcHVibGljIGNtcFRyYW5zZm9ybTogQ29tcG9uZW50VHJhbnNmb3JtID0gbnVsbDtcclxuICAgIHB1YmxpYyBnYW1lUGFkOiBHYW1lcGFkID0gbnVsbDtcclxuICAgIHB1YmxpYyB0aHVtYnN0aWNrWDogbnVtYmVyID0gbnVsbDtcclxuICAgIHB1YmxpYyB0aHVtYnN0aWNrWTogbnVtYmVyID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFZSIENvbXBvbmVudCBDbGFzcywgZm9yIFNlc3Npb24gTWFuYWdlbWVudCwgQ29udHJvbGxlciBNYW5hZ2VtZW50IGFuZCBSZWZlcmVuY2UgU3BhY2UgTWFuYWdlbWVudC4gXHJcbiAgICogQGF1dGhvciBWYWxlbnRpbiBTY2htaWRiZXJnZXIsIEhGVSwgMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRWUkRldmljZSBleHRlbmRzIENvbXBvbmVudENhbWVyYSB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3MoQ29tcG9uZW50VlJEZXZpY2UpO1xyXG4gICAgcHVibGljIHJpZ2h0Q250cmw6IFZSQ29udHJvbGxlciA9IG5ldyBWUkNvbnRyb2xsZXIoKTtcclxuICAgIHB1YmxpYyBsZWZ0Q250cmw6IFZSQ29udHJvbGxlciA9IG5ldyBWUkNvbnRyb2xsZXIoKTtcclxuXHJcbiAgICAjbXR4TG9jYWw6IE1hdHJpeDR4NDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQURELCB0aGlzLmdldE10eExvY2FsRnJvbUNtcFRyYW5zZm9ybSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhY3R1YWwgbWF0cml4IG9mIHRoZSB2ciAtIGRldmljZS5cclxuICAgICAqIENyZWF0b3JzIHNob3VsZCB1c2UgdGhpcyBmb3IgcmVhZG9ubHkgcHVycG9zZXMuICBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtdHhMb2NhbCgpOiBNYXRyaXg0eDQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbXR4TG9jYWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgVmVjdG9yMyBhcyBQb3NpdGlvbiBvZiB0aGUgcmVmZXJlbmNlIHNwYWNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IHRyYW5zbGF0aW9uKF90cmFuc2xhdGlvbjogVmVjdG9yMykge1xyXG4gICAgICBsZXQgdHJhbnNsYXRpb246IFZlY3RvcjMgPSBfdHJhbnNsYXRpb24uY2xvbmU7XHJcbiAgICAgIHRyYW5zbGF0aW9uLnN1YnRyYWN0KHRoaXMuI210eExvY2FsLnRyYW5zbGF0aW9uKTtcclxuICAgICAgdHJhbnNsYXRpb24ubmVnYXRlKCk7XHJcbiAgICAgIFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZSA9IFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZS5nZXRPZmZzZXRSZWZlcmVuY2VTcGFjZShuZXcgWFJSaWdpZFRyYW5zZm9ybSh0cmFuc2xhdGlvbikpO1xyXG4gICAgICB0aGlzLiNtdHhMb2NhbC50cmFuc2xhdGlvbiA9IF90cmFuc2xhdGlvbjtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBWZWN0b3IzIFJvdGF0aW9uIG9mIHRoZSByZWZlcmVuY2Ugc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgcm90YXRpb24oX3JvdGF0aW9uOiBWZWN0b3IzKSB7XHJcbiAgICAgIGxldCByb3RhdGlvbjogVmVjdG9yMyA9IF9yb3RhdGlvbi5jbG9uZTsgXHJcbiAgICAgIHJvdGF0aW9uLnN1YnRyYWN0KHRoaXMuI210eExvY2FsLnJvdGF0aW9uKTtcclxuICAgICAgcm90YXRpb24ubmVnYXRlKCk7XHJcbiAgICAgIGxldCBvcmllbnRhdGlvbjogUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcbiAgICAgIG9yaWVudGF0aW9uLmV1bGVyQW5nbGVzID0gcm90YXRpb247XHJcbiAgICAgIC8vIFJvdGF0aW9uIG5lZWRzIHRvIGJlIHNldCBpbiB0aGUgT3JpZ2luICgwLDAsMCksIG90aGVyd2lzZSB0aGUgWFItUmlnIGdldHMgcm90YXRlZCBhcm91bmQgdGhlIG9yaWdpbi4gXHJcbiAgICAgIC8vIHNldCB4ciAtIHJpZyBiYWNrIHRvIG9yaWdpblxyXG4gICAgICBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UgPSBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UuZ2V0T2Zmc2V0UmVmZXJlbmNlU3BhY2UobmV3IFhSUmlnaWRUcmFuc2Zvcm0oVmVjdG9yMy5ESUZGRVJFTkNFKHRoaXMuI210eExvY2FsLnRyYW5zbGF0aW9uLCBWZWN0b3IzLlpFUk8oKSkpKTtcclxuICAgICAgLy8gcm90YXRlIHhyIHJpZyBpbiBvcmlnaW5cclxuICAgICAgWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlID0gWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlLmdldE9mZnNldFJlZmVyZW5jZVNwYWNlKG5ldyBYUlJpZ2lkVHJhbnNmb3JtKFZlY3RvcjMuWkVSTygpLCBvcmllbnRhdGlvbikpO1xyXG4gICAgICAvLyBzZXQgeHIgLSByaWcgYmFjayB0byBsYXN0IHBvc2l0aW9uIFxyXG4gICAgICBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UgPSBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UuZ2V0T2Zmc2V0UmVmZXJlbmNlU3BhY2UobmV3IFhSUmlnaWRUcmFuc2Zvcm0oVmVjdG9yMy5ESUZGRVJFTkNFKFZlY3RvcjMuWkVSTygpLCB0aGlzLiNtdHhMb2NhbC50cmFuc2xhdGlvbikpKTtcclxuICAgICAgdGhpcy4jbXR4TG9jYWwucm90YXRpb24gPSBfcm90YXRpb247XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJvdGF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBWZWN0b3IzIGluIFBvc2l0aW9uIG9mIHRoZSByZWZlcmVuY2Ugc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGUoX2J5OiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGxldCB0cmFuc2xhdGlvbjogVmVjdG9yMyA9IF9ieS5jbG9uZTtcclxuICAgICAgdHJhbnNsYXRpb24udHJhbnNmb3JtKHRoaXMuI210eExvY2FsLnF1YXRlcm5pb24pO1xyXG4gICAgICB0cmFuc2xhdGlvbi5uZWdhdGUoKTtcclxuICAgICAgWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlID0gWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlLmdldE9mZnNldFJlZmVyZW5jZVNwYWNlKG5ldyBYUlJpZ2lkVHJhbnNmb3JtKHRyYW5zbGF0aW9uKSk7XHJcbiAgICAgIHRoaXMuI210eExvY2FsLnRyYW5zbGF0ZShfYnkpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh0cmFuc2xhdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgVmVjdG9yMyBpbiBSb3RhdGlvbiBvZiB0aGUgcmVmZXJlbmNlIHNwYWNlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcm90YXRlKF9ieTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICBsZXQgcm90YXRpb246IFZlY3RvcjMgPSBfYnkuY2xvbmUubmVnYXRlKCk7IFxyXG4gICAgICBsZXQgb3JpZW50YXRpb246IFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xyXG4gICAgICBvcmllbnRhdGlvbi5ldWxlckFuZ2xlcyA9IHJvdGF0aW9uO1xyXG4gICAgICAvLyBSb3RhdGlvbiBuZWVkcyB0byBiZSBhZGRlZCBpbiB0aGUgT3JpZ2luICgwLDAsMCksIG90aGVyd2lzZSB0aGUgWFItUmlnIGdldHMgcm90YXRlZCBhcm91bmQgdGhlIG9yaWdpbi4gXHJcbiAgICAgIC8vIHNldCB4ciAtIHJpZyBiYWNrIHRvIG9yaWdpblxyXG4gICAgICBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UgPSBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UuZ2V0T2Zmc2V0UmVmZXJlbmNlU3BhY2UobmV3IFhSUmlnaWRUcmFuc2Zvcm0oVmVjdG9yMy5ESUZGRVJFTkNFKHRoaXMuI210eExvY2FsLnRyYW5zbGF0aW9uLCBWZWN0b3IzLlpFUk8oKSkpKTtcclxuICAgICAgLy8gcm90YXRlIHhyIHJpZyBpbiBvcmlnaW5cclxuICAgICAgWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlID0gWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlLmdldE9mZnNldFJlZmVyZW5jZVNwYWNlKG5ldyBYUlJpZ2lkVHJhbnNmb3JtKFZlY3RvcjMuWkVSTygpLCBvcmllbnRhdGlvbikpO1xyXG4gICAgICAvLyBzZXQgeHIgLSByaWcgYmFjayB0byBsYXN0IHBvc2l0aW9uIFxyXG4gICAgICBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UgPSBYUlZpZXdwb3J0LmRlZmF1bHQucmVmZXJlbmNlU3BhY2UuZ2V0T2Zmc2V0UmVmZXJlbmNlU3BhY2UobmV3IFhSUmlnaWRUcmFuc2Zvcm0oVmVjdG9yMy5ESUZGRVJFTkNFKFZlY3RvcjMuWkVSTygpLCB0aGlzLiNtdHhMb2NhbC50cmFuc2xhdGlvbikpKTtcclxuICAgICAgdGhpcy4jbXR4TG9jYWwucm90YXRlKF9ieSk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJvdGF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldE10eExvY2FsRnJvbUNtcFRyYW5zZm9ybSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jbXR4TG9jYWwgPSB0aGlzLm5vZGUubXR4TG9jYWw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgZXhwb3J0IGNvbnN0IGVudW0gRVZFTlRfQ09OVFJPTCB7XHJcbiAgICBJTlBVVCA9IFwiaW5wdXRcIixcclxuICAgIE9VVFBVVCA9IFwib3V0cHV0XCJcclxuICB9XHJcblxyXG4gIGV4cG9ydCBjb25zdCBlbnVtIENPTlRST0xfVFlQRSB7XHJcbiAgICAvKiogVGhlIG91dHB1dCBzaW1wbHkgZm9sbG93cyB0aGUgc2NhbGVkIGFuZCBkZWxheWVkIGlucHV0ICovXHJcbiAgICBQUk9QT1JUSU9OQUwsXHJcbiAgICAvKiogVGhlIG91dHB1dCB2YWx1ZSBjaGFuZ2VzIG92ZXIgdGltZSB3aXRoIGEgcmF0ZSBnaXZlbiBieSB0aGUgc2NhbGVkIGFuZCBkZWxheWVkIGlucHV0ICovXHJcbiAgICBJTlRFR1JBTCxcclxuICAgIC8qKiBUaGUgb3V0cHV0IHZhbHVlIHJlYWN0cyB0byBjaGFuZ2VzIG9mIHRoZSBzY2FsZWQgaW5wdXQgYW5kIGRyb3BzIHRvIDAgd2l0aCBnaXZlbiBkZWxheSwgaWYgaW5wdXQgcmVtYWlucyBjb25zdGFudCAqL1xyXG4gICAgRElGRkVSRU5USUFMXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcm9jZXNzZXMgaW5wdXQgc2lnbmFscyBvZiB0eXBlIG51bWJlciBhbmQgZ2VuZXJhdGVzIGFuIG91dHB1dCBzaWduYWwgb2YgdGhlIHNhbWUgdHlwZSB1c2luZyBcclxuICAgKiBwcm9wb3J0aW9uYWwsIGludGVncmFsIG9yIGRpZmZlcmVudGlhbCBtYXBwaW5nLCBhbiBhbXBsaWZpY2F0aW9uIGZhY3RvciBhbmQgYSBsaW5lYXIgZGFtcGVuaW5nL2RlbGF5XHJcbiAgICogYGBgdGV4dFxyXG4gICAqICAgICAgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXHJcbiAgICogICAgICAgICDilIIgICDilIzilIDilIDilIDilIDilIDilIDilIDilJAgICDilIzilIDilIDilIDilIDilIDilJAgICAgICBwYXNzIHRocm91Z2ggKFByb3BvcnRpb25hbCkgICAgICDilIJcclxuICAgKiBJbnB1dCDihpIg4pSCIOKGkiDilIJhbXBsaWZ54pSCIOKGkiDilIJkZWxheeKUgiDihpIg4pqfIHN1bSB1cCBvdmVyIHRpbWUgKEludGVncmFsKSDimp4g4oaSIOKUgiDihpIgT3V0cHV0XHJcbiAgICogICAgICAgICDilIIgICDilJTilIDilIDilIDilIDilIDilIDilIDilJggICDilJTilIDilIDilIDilIDilIDilJggICAgICBwYXNzIGNoYW5nZSAgKERpZmZlcmVudGlhbCkgICAgICDilIJcclxuICAgKiAgICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCBcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29udHJvbCBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcclxuICAgIHB1YmxpYyByZWFkb25seSB0eXBlOiBDT05UUk9MX1RZUEU7XHJcbiAgICBwdWJsaWMgYWN0aXZlOiBib29sZWFuO1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcclxuXHJcbiAgICBwcm90ZWN0ZWQgcmF0ZURpc3BhdGNoT3V0cHV0OiBudW1iZXIgPSAwO1xyXG4gICAgcHJvdGVjdGVkIHZhbHVlUHJldmlvdXM6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgb3V0cHV0QmFzZTogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBvdXRwdXRUYXJnZXQ6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgb3V0cHV0UHJldmlvdXM6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgb3V0cHV0VGFyZ2V0UHJldmlvdXM6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgZmFjdG9yOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHByb3RlY3RlZCB0aW1lOiBUaW1lID0gVGltZS5nYW1lO1xyXG4gICAgcHJvdGVjdGVkIHRpbWVWYWx1ZURlbGF5OiBudW1iZXIgPSAwO1xyXG4gICAgcHJvdGVjdGVkIHRpbWVPdXRwdXRUYXJnZXRTZXQ6IG51bWJlciA9IDA7XHJcbiAgICBwcm90ZWN0ZWQgaWRUaW1lcjogbnVtYmVyID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfZmFjdG9yOiBudW1iZXIgPSAxLCBfdHlwZTogQ09OVFJPTF9UWVBFID0gQ09OVFJPTF9UWVBFLlBST1BPUlRJT05BTCwgX2RlbGF5OiBudW1iZXIgPSAwKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuZmFjdG9yID0gX2ZhY3RvcjtcclxuICAgICAgdGhpcy50eXBlID0gX3R5cGU7XHJcbiAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMuc2V0RGVsYXkoX2RlbGF5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgdGltZS1vYmplY3QgdG8gYmUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBvdXRwdXQgaW4ge0BsaW5rIENPTlRST0xfVFlQRS5JTlRFR1JBTH1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFRpbWViYXNlKF90aW1lOiBUaW1lKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudGltZSA9IF90aW1lO1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZU91dHB1dCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmVlZCBhbiBpbnB1dCB2YWx1ZSBpbnRvIHRoaXMgY29udHJvbCBhbmQgZmlyZSB0aGUgZXZlbnRzIHtAbGluayBFVkVOVF9DT05UUk9MLklOUFVUfSBhbmQge0BsaW5rIEVWRU5UX0NPTlRST0wuT1VUUFVUfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0SW5wdXQoX2lucHV0OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICB0aGlzLm91dHB1dEJhc2UgPSB0aGlzLmNhbGN1bGF0ZU91dHB1dCgpO1xyXG4gICAgICB0aGlzLnZhbHVlUHJldmlvdXMgPSB0aGlzLmdldFZhbHVlRGVsYXllZCgpO1xyXG4gICAgICB0aGlzLm91dHB1dFRhcmdldCA9IHRoaXMuZmFjdG9yICogX2lucHV0O1xyXG4gICAgICB0aGlzLnRpbWVPdXRwdXRUYXJnZXRTZXQgPSB0aGlzLnRpbWUuZ2V0KCk7XHJcblxyXG4gICAgICBpZiAodGhpcy50eXBlID09IENPTlRST0xfVFlQRS5ESUZGRVJFTlRJQUwpIHtcclxuICAgICAgICB0aGlzLnZhbHVlUHJldmlvdXMgPSB0aGlzLm91dHB1dFRhcmdldCAtIHRoaXMub3V0cHV0VGFyZ2V0UHJldmlvdXM7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRUYXJnZXRQcmV2aW91cyA9IHRoaXMub3V0cHV0VGFyZ2V0O1xyXG4gICAgICAgIHRoaXMub3V0cHV0VGFyZ2V0ID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVF9DT05UUk9MLklOUFVUKSk7XHJcbiAgICAgIGlmICh0aGlzLnR5cGUgPT0gQ09OVFJPTF9UWVBFLkRJRkZFUkVOVElBTClcclxuICAgICAgICB0aGlzLmRpc3BhdGNoT3V0cHV0KHRoaXMudmFsdWVQcmV2aW91cyk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLmRpc3BhdGNoT3V0cHV0KG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVE9ETzogZGVzY3JpYmUhXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwdWxzZShfaW5wdXQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldElucHV0KF9pbnB1dCk7XHJcbiAgICAgIHRoaXMuc2V0SW5wdXQoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHRpbWUgdG8gdGFrZSBmb3IgdGhlIGludGVybmFsIGxpbmVhciBkYW1wZW5pbmcgdW50aWwgdGhlIGZpbmFsIG91cHV0IHZhbHVlIGlzIHJlYWNoZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldERlbGF5KF90aW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy50aW1lVmFsdWVEZWxheSA9IE1hdGgubWF4KDAsIF90aW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIG91dHB1dC1ldmVudHMgdG8gZGlzcGF0Y2ggcGVyIHNlY29uZC4gXHJcbiAgICAgKiBBdCB0aGUgZGVmYXVsdCBvZiAwLCB0aGUgY29udHJvbCBvdXRwdXQgbXVzdCBiZSBwb2xsZWQgYW5kIHdpbGwgb25seSBhY3RpdmVseSBkaXNwYXRjaGVkIG9uY2UgZWFjaCB0aW1lIGlucHV0IG9jY3VycyBhbmQgdGhlIG91dHB1dCBjaGFuZ2VzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UmF0ZURpc3BhdGNoT3V0cHV0KF9yYXRlRGlzcGF0Y2hPdXRwdXQ6IG51bWJlciA9IDApOiB2b2lkIHtcclxuICAgICAgdGhpcy5yYXRlRGlzcGF0Y2hPdXRwdXQgPSBfcmF0ZURpc3BhdGNoT3V0cHV0O1xyXG4gICAgICB0aGlzLnRpbWUuZGVsZXRlVGltZXIodGhpcy5pZFRpbWVyKTtcclxuICAgICAgdGhpcy5pZFRpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgICBpZiAodGhpcy5yYXRlRGlzcGF0Y2hPdXRwdXQpXHJcbiAgICAgICAgdGhpcy5pZFRpbWVyID0gdGhpcy50aW1lLnNldFRpbWVyKDEwMDAgLyB0aGlzLnJhdGVEaXNwYXRjaE91dHB1dCwgMCwgdGhpcy5kaXNwYXRjaE91dHB1dCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGZhY3RvciB0byBtdWx0aXBseSB0aGUgaW5wdXQgdmFsdWUgZ2l2ZW4gd2l0aCB7QGxpbmsgc2V0SW5wdXR9IHdpdGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEZhY3RvcihfZmFjdG9yOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5mYWN0b3IgPSBfZmFjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBvdXRwdXQgb2YgdGhpcyBjb250cm9sXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRPdXRwdXQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlT3V0cHV0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBvdXRwdXQgb2YgdGhpcyBjb250cm9sXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjYWxjdWxhdGVPdXRwdXQoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IG91dHB1dDogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHZhbHVlOiBudW1iZXIgPSB0aGlzLmdldFZhbHVlRGVsYXllZCgpO1xyXG5cclxuICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICBjYXNlIENPTlRST0xfVFlQRS5JTlRFR1JBTDpcclxuICAgICAgICAgIGxldCB0aW1lQ3VycmVudDogbnVtYmVyID0gdGhpcy50aW1lLmdldCgpO1xyXG4gICAgICAgICAgbGV0IHRpbWVFbGFwc2VkU2luY2VJbnB1dDogbnVtYmVyID0gdGltZUN1cnJlbnQgLSB0aGlzLnRpbWVPdXRwdXRUYXJnZXRTZXQ7XHJcbiAgICAgICAgICBvdXRwdXQgPSB0aGlzLm91dHB1dEJhc2U7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMudGltZVZhbHVlRGVsYXkgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lRWxhcHNlZFNpbmNlSW5wdXQgPCB0aGlzLnRpbWVWYWx1ZURlbGF5KSB7XHJcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IDAuNSAqICh0aGlzLnZhbHVlUHJldmlvdXMgKyB2YWx1ZSkgKiB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IDAuNSAqICh0aGlzLnZhbHVlUHJldmlvdXMgKyB2YWx1ZSkgKiB0aGlzLnRpbWVWYWx1ZURlbGF5O1xyXG4gICAgICAgICAgICAgIHRpbWVFbGFwc2VkU2luY2VJbnB1dCAtPSB0aGlzLnRpbWVWYWx1ZURlbGF5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBvdXRwdXQgKz0gdmFsdWUgKiB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ7XHJcbiAgICAgICAgICAvLyB2YWx1ZSArPSAwLjUgKiAodGhpcy5pbnB1dFByZXZpb3VzIC0gaW5wdXQpICogdGhpcy50aW1lSW5wdXREZWxheSArIGlucHV0ICogdGltZUVsYXBzZWRTaW5jZUlucHV0O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT05UUk9MX1RZUEUuRElGRkVSRU5USUFMOlxyXG4gICAgICAgIGNhc2UgQ09OVFJPTF9UWVBFLlBST1BPUlRJT05BTDpcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgb3V0cHV0ID0gdmFsdWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBjYWxjdWxhdGVzIHRoZSBvdXRwdXQgY29uc2lkZXJpbmcgdGhlIHRpbWUgb2YgdGhlIGRlbGF5XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0VmFsdWVEZWxheWVkKCk6IG51bWJlciB7XHJcbiAgICAgIGlmICh0aGlzLnRpbWVWYWx1ZURlbGF5ID4gMCkge1xyXG4gICAgICAgIGxldCB0aW1lRWxhcHNlZFNpbmNlSW5wdXQ6IG51bWJlciA9IHRoaXMudGltZS5nZXQoKSAtIHRoaXMudGltZU91dHB1dFRhcmdldFNldDtcclxuICAgICAgICBpZiAodGltZUVsYXBzZWRTaW5jZUlucHV0IDwgdGhpcy50aW1lVmFsdWVEZWxheSlcclxuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlUHJldmlvdXMgKyAodGhpcy5vdXRwdXRUYXJnZXQgLSB0aGlzLnZhbHVlUHJldmlvdXMpICogdGltZUVsYXBzZWRTaW5jZUlucHV0IC8gdGhpcy50aW1lVmFsdWVEZWxheTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5vdXRwdXRUYXJnZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBkaXNwYXRjaE91dHB1dCA9IChfZXZlbnRPclZhbHVlOiBFdmVudFRpbWVyIHwgbnVtYmVyKTogdm9pZCA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5hY3RpdmUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IHRpbWVyOiBUaW1lciA9IHRoaXMudGltZS5nZXRUaW1lcih0aGlzLmlkVGltZXIpO1xyXG4gICAgICBsZXQgb3V0cHV0OiBudW1iZXI7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9ldmVudE9yVmFsdWUpID09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgb3V0cHV0ID0gX2V2ZW50T3JWYWx1ZTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG91dHB1dCA9IHRoaXMuY2FsY3VsYXRlT3V0cHV0KCk7XHJcbiAgICAgIGxldCBvdXRwdXRDaGFuZ2VkOiBib29sZWFuID0gKG91dHB1dCAhPSB0aGlzLm91dHB1dFByZXZpb3VzKTtcclxuXHJcbiAgICAgIGlmICh0aW1lcikge1xyXG4gICAgICAgIHRpbWVyLmFjdGl2ZSA9IG91dHB1dENoYW5nZWQ7XHJcbiAgICAgICAgaWYgKCFvdXRwdXRDaGFuZ2VkKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLm91dHB1dFByZXZpb3VzID0gb3V0cHV0O1xyXG5cclxuICAgICAgbGV0IGV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChFVkVOVF9DT05UUk9MLk9VVFBVVCwge1xyXG4gICAgICAgIGRldGFpbDoge1xyXG4gICAgICAgICAgb3V0cHV0OiBvdXRwdXRcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiQ29udHJvbC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBtdWx0aXBsZSBjb250cm9scyBhcyBpbnB1dHMgYW5kIGNyZWF0ZXMgYW4gb3V0cHV0IGZyb20gdGhhdC5cclxuICAgKiBBcyBhIHN1YmNsYXNzIG9mIHtAbGluayBDb250cm9sfSwgYXhpcyBjYWxjdWxhdGVzIHRoZSBvdXB1dCBzdW1taW5nIHVwIHRoZSBpbnB1dHMgYW5kIHByb2Nlc3NpbmcgdGhlIHJlc3VsdCB1c2luZyBpdHMgb3duIHNldHRpbmdzLiAgXHJcbiAgICogRGlzcGF0Y2hlcyB7QGxpbmsgRVZFTlRfQ09OVFJPTC5PVVRQVVR9IGFuZCB7QGxpbmsgRVZFTlRfQ09OVFJPTC5JTlBVVH0gd2hlbiBvbmUgb2YgdGhlIGNvbnRyb2xzIGRpc3BhdGNoZXMgdGhlbS5cclxuICAgKiBgYGB0ZXh0XHJcbiAgICogICAgICAgICAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxyXG4gICAqICAgICAgICAgICDilIIg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXHJcbiAgICogICBJbnB1dCDihpIg4pSCIOKUgmNvbnRyb2zilIJcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXHJcbiAgICogICAgICAgICAgIOKUgiDilJTilIDilIDilIDilIDilIDilIDilIDilJggXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXHJcbiAgICogICAgICAgICAgIOKUgiDilIzilIDilIDilIDilIDilIDilIDilIDilJAgIFxc4pSM4pSA4pSA4pSA4pSQICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSCXHJcbiAgICogICBJbnB1dCDihpIg4pSCIOKUgmNvbnRyb2zilIItLS3ilIJzdW3ilIIg4oaSIOKUgmludGVybmFsIGNvbnRyb2wg4pSCIOKGkiDilIIg4oaSIE91dHB1dFxyXG4gICAqICAgICAgICAgICDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAv4pSU4pSA4pSA4pSA4pSYICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSCXHJcbiAgICogICAgICAgICAgIOKUgiDilIzilIDilIDilIDilIDilIDilIDilIDilJAgLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcclxuICAgKiAgIElucHV0IOKGkiDilIIg4pSCY29udHJvbOKUgi8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxyXG4gICAqICAgICAgICAgICDilIIg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXHJcbiAgICogICAgICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgXHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEF4aXMgZXh0ZW5kcyBDb250cm9sIHtcclxuICAgIHByaXZhdGUgY29udHJvbHM6IE1hcDxzdHJpbmcsIENvbnRyb2w+ID0gbmV3IE1hcCgpO1xyXG4gICAgcHJpdmF0ZSBzdW1QcmV2aW91czogbnVtYmVyID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCB0aGUgY29udHJvbCBnaXZlbiB0byB0aGUgbGlzdCBvZiBjb250cm9scyBmZWVkaW5nIGludG8gdGhpcyBheGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRDb250cm9sKF9jb250cm9sOiBDb250cm9sKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuY29udHJvbHMuc2V0KF9jb250cm9sLm5hbWUsIF9jb250cm9sKTtcclxuICAgICAgX2NvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVF9DT05UUk9MLklOUFVULCB0aGlzLmhuZElucHV0RXZlbnQpO1xyXG4gICAgICBfY29udHJvbC5hZGRFdmVudExpc3RlbmVyKEVWRU5UX0NPTlRST0wuT1VUUFVULCB0aGlzLmhuZE91dHB1dEV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29udHJvbChfbmFtZTogc3RyaW5nKTogQ29udHJvbCB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLmdldChfbmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG5hbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUNvbnRyb2woX25hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBsZXQgY29udHJvbDogQ29udHJvbCA9IHRoaXMuZ2V0Q29udHJvbChfbmFtZSk7XHJcbiAgICAgIGlmIChjb250cm9sKSB7XHJcbiAgICAgICAgY29udHJvbC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UX0NPTlRST0wuSU5QVVQsIHRoaXMuaG5kSW5wdXRFdmVudCk7XHJcbiAgICAgICAgY29udHJvbC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UX0NPTlRST0wuT1VUUFVULCB0aGlzLmhuZE91dHB1dEV2ZW50KTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xzLmRlbGV0ZShfbmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoaXMgYXhpcyBhZnRlciBzdW1taW5nIHVwIGFsbCBpbnB1dHMgYW5kIHByb2Nlc3NpbmcgdGhlIHN1bSBhY2NvcmRpbmcgdG8gdGhlIGF4aXMnIHNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRPdXRwdXQoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IHN1bUlucHV0OiBudW1iZXIgPSAwO1xyXG4gICAgICBmb3IgKGxldCBjb250cm9sIG9mIHRoaXMuY29udHJvbHMpIHtcclxuXHJcbiAgICAgICAgaWYgKGNvbnRyb2xbMV0uYWN0aXZlKVxyXG4gICAgICAgICAgc3VtSW5wdXQgKz0gY29udHJvbFsxXS5nZXRPdXRwdXQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHN1bUlucHV0ICE9IHRoaXMuc3VtUHJldmlvdXMpXHJcbiAgICAgICAgc3VwZXIuc2V0SW5wdXQoc3VtSW5wdXQpO1xyXG5cclxuICAgICAgdGhpcy5zdW1QcmV2aW91cyA9IHN1bUlucHV0O1xyXG5cclxuICAgICAgcmV0dXJuIHN1cGVyLmdldE91dHB1dCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaG5kT3V0cHV0RXZlbnQ6IEV2ZW50TGlzdGVuZXIgPSAoX2V2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuYWN0aXZlKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBjb250cm9sOiBDb250cm9sID0gKDxDb250cm9sPl9ldmVudC50YXJnZXQpO1xyXG4gICAgICBsZXQgZXZlbnQ6IEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEVWRU5UX0NPTlRST0wuT1VUUFVULCB7XHJcbiAgICAgICAgZGV0YWlsOiB7XHJcbiAgICAgICAgICBjb250cm9sOiBjb250cm9sLFxyXG4gICAgICAgICAgaW5wdXQ6ICg8Q3VzdG9tRXZlbnQ+X2V2ZW50KS5kZXRhaWwub3V0cHV0LFxyXG4gICAgICAgICAgb3V0cHV0OiB0aGlzLmdldE91dHB1dCgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBobmRJbnB1dEV2ZW50OiBFdmVudExpc3RlbmVyID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBsZXQgZXZlbnQ6IEV2ZW50ID0gbmV3IEV2ZW50KEVWRU5UX0NPTlRST0wuSU5QVVQsIF9ldmVudCk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9O1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGludGVyZmFjZSBLZXlQcmVzc2VkIHtcclxuICAgIFtjb2RlOiBzdHJpbmddOiBib29sZWFuO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29sbGVjdHMgdGhlIGtleXMgcHJlc3NlZCBvbiB0aGUga2V5Ym9hcmQgYW5kIHN0b3JlcyB0aGVpciBzdGF0dXMuIFxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBLZXlib2FyZCB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBrZXlzUHJlc3NlZDogS2V5UHJlc3NlZCA9IEtleWJvYXJkLmluaXRpYWxpemUoKTtcclxuICAgIC8vIHByaXZhdGUgc3RhdGljIGNvZGVfZW46IE9iamVjdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvbmUgb2YgdGhlIGdpdmVuIGtleXMgaXMgaXMgY3VycmVudGx5IGJlaW5nIHByZXNzZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaXNQcmVzc2VkT25lKF9rZXlzOiBLRVlCT0FSRF9DT0RFW10pOiBib29sZWFuIHtcclxuICAgICAgZm9yIChsZXQgY29kZSBvZiBfa2V5cykge1xyXG4gICAgICAgIGlmIChLZXlib2FyZC5rZXlzUHJlc3NlZFtjb2RlXSlcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbGwgb2YgdGhlIGdpdmVuIGtleXMgYXJlIGN1cnJlbnRseSBiZWluZyBwcmVzc2VkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgaXNQcmVzc2VkQ29tYm8oX2tleXM6IEtFWUJPQVJEX0NPREVbXSk6IGJvb2xlYW4ge1xyXG4gICAgICBmb3IgKGxldCBjb2RlIG9mIF9rZXlzKSB7XHJcbiAgICAgICAgaWYgKCFLZXlib2FyZC5rZXlzUHJlc3NlZFtjb2RlXSlcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGdpdmVuIGFzIF9hY3RpdmUgaWYgb25lIG9yLCB3aGVuIF9jb21ibyBpcyB0cnVlLCBhbGwgb2YgdGhlIGdpdmVuIGtleXMgYXJlIHByZXNzZWQuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBnaXZlbiBhcyBfaW5hY3RpdmUgaWYgbm90LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIG1hcFRvVmFsdWU8VD4oX2FjdGl2ZTogVCwgX2luYWN0aXZlOiBULCBfa2V5czogS0VZQk9BUkRfQ09ERVtdLCBfY29tYm86IGJvb2xlYW4gPSBmYWxzZSk6IFQge1xyXG4gICAgICBpZiAoIV9jb21ibyAmJiBLZXlib2FyZC5pc1ByZXNzZWRPbmUoX2tleXMpKVxyXG4gICAgICAgIHJldHVybiBfYWN0aXZlO1xyXG4gICAgICBpZiAoS2V5Ym9hcmQuaXNQcmVzc2VkQ29tYm8oX2tleXMpKVxyXG4gICAgICAgIHJldHVybiBfYWN0aXZlO1xyXG4gICAgICByZXR1cm4gX2luYWN0aXZlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGJhbGFuY2VkIHRlcm5hcnkgdmFsdWUgKGVpdGhlciAtMSwgMCBvciAxKSBcclxuICAgICAqIGFjY29yZGluZyB0byB0aGUgbWF0Y2ggb2YgdGhlIGtleXMgY3VycmVudGx5IGJlaW5nIHByZXNzZWQgYW5kIHRoZSBsaXN0cyBvZiBrZXlzIGdpdmVuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIG1hcFRvVHJpdChfcG9zaXRpdmU6IEtFWUJPQVJEX0NPREVbXSwgX25lZ2F0aXZlOiBLRVlCT0FSRF9DT0RFW10pOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gS2V5Ym9hcmQubWFwVG9WYWx1ZSgtMSwgMCwgX25lZ2F0aXZlKSArIEtleWJvYXJkLm1hcFRvVmFsdWUoMSwgMCwgX3Bvc2l0aXZlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBwdWJsaWMgc3RhdGljIGxvY2FsZShfa2V5Ym9hcmQ6IE9iamVjdCk6IHZvaWQge1xyXG4gICAgLy8gICBpZiAoIUtleWJvYXJkLmNvZGVfZW4pIHtcclxuICAgIC8vICAgICAvLyBzYXZlIG9yaWdpbmFsIGtleWJvYXJkIGNvZGVzIHRvIGJlIGFibGUgdG8gc3dpdGNoIGJhY2sgbGF0ZXJcclxuICAgIC8vICAgICBLZXlib2FyZC5jb2RlX2VuID0ge307XHJcbiAgICAvLyAgICAgT2JqZWN0LmFzc2lnbihLZXlib2FyZC5jb2RlX2VuLCBLRVlCT0FSRF9DT0RFKTtcclxuICAgIC8vICAgfVxyXG5cclxuICAgIC8vICAgZm9yIChsZXQga2V5IGluIF9rZXlib2FyZCkge1xyXG4gICAgLy8gICAgIGxldCB2YWx1ZTogc3RyaW5nID0gUmVmbGVjdC5nZXQoX2tleWJvYXJkLCBrZXkpO1xyXG4gICAgLy8gICAgIGZvciAobGV0IG9yaWdpbmFsIGluIEtFWUJPQVJEX0NPREUpXHJcbiAgICAvLyAgICAgICBpZiAoUmVmbGVjdC5nZXQoS0VZQk9BUkRfQ09ERSwgb3JpZ2luYWwpID09IHZhbHVlKVxyXG4gICAgLy8gICAgICAgICAvLyByZW1vdmUgb3JpZ2luYWwga2V5IHRoZSB5aWVsZHMgdGhlIHZhbHVlXHJcbiAgICAvLyAgICAgICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkoS0VZQk9BUkRfQ09ERSwgb3JpZ2luYWwpO1xyXG4gICAgLy8gICAgIC8vIGFkZCBuZXcga2V5IHRvIHlpZWxkIHRoYXQgdmFsdWVcclxuICAgIC8vICAgICBSZWZsZWN0LnNldChLRVlCT0FSRF9DT0RFLCBrZXksIHZhbHVlKTtcclxuICAgIC8vICAgfVxyXG4gICAgLy8gfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGluaXRpYWxpemUoKTogS2V5UHJlc3NlZCB7XHJcbiAgICAgIGxldCBzdG9yZTogS2V5UHJlc3NlZCA9IHt9O1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBLZXlib2FyZC5obmRLZXlJbnRlcmFjdGlvbik7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBLZXlib2FyZC5obmRLZXlJbnRlcmFjdGlvbik7XHJcbiAgICAgIHJldHVybiBzdG9yZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBobmRLZXlJbnRlcmFjdGlvbihfZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcclxuICAgICAgS2V5Ym9hcmQua2V5c1ByZXNzZWRbX2V2ZW50LmNvZGVdID0gKF9ldmVudC50eXBlID09IFwia2V5ZG93blwiKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnVGFyZ2V0LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBSb3V0aW5nIHRvIHRoZSBhbGVydCBib3hcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRGVidWdBbGVydCBleHRlbmRzIERlYnVnVGFyZ2V0IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVsZWdhdGVzOiBNYXBEZWJ1Z0ZpbHRlclRvRGVsZWdhdGUgPSB7XHJcbiAgICAgIFtERUJVR19GSUxURVIuSU5GT106IERlYnVnQWxlcnQuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5JTkZPXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuTE9HXTogRGVidWdBbGVydC5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkxPR10pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLldBUk5dOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuV0FSTl0pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkVSUk9SXTogRGVidWdBbGVydC5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkVSUk9SXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuRlVER0VdOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuRlVER0VdKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdOiBEZWJ1Z0FsZXJ0LmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuU09VUkNFXSlcclxuICAgIH07XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogUmV0dXJucyBhIGRlbGVnYXRlLWZ1bmN0aW9uIGV4cGVjdGluZyBhIG1lc3NhZ2UgdG8gbG9nLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZURlbGVnYXRlKF9oZWFkbGluZTogc3RyaW5nKTogRnVuY3Rpb24ge1xyXG4gICAgICBsZXQgZGVsZWdhdGU6IEZ1bmN0aW9uID0gZnVuY3Rpb24gKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICAgIGxldCBhcmdzOiBzdHJpbmdbXSA9IF9hcmdzLm1hcChfYXJnID0+IF9hcmcudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgbGV0IG91dDogc3RyaW5nID0gX2hlYWRsaW5lICsgXCIgXCIgKyBEZWJ1Z1RhcmdldC5tZXJnZUFyZ3VtZW50cyhfbWVzc2FnZSwgYXJncyk7XHJcbiAgICAgICAgYWxlcnQob3V0KTtcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIGRlbGVnYXRlO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIC8gPHJlZmVyZW5jZSBwYXRoPVwiRGVidWdUYXJnZXQudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFJvdXRpbmcgdG8gYSBIVE1MRGlhbG9nRWxlbWVudFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBEZWJ1Z0RpYWxvZyBleHRlbmRzIERlYnVnVGFyZ2V0IHtcclxuICAgIC8vIFRPRE86IGNoZWNrb3V0IEhUTUxEaWFsb2dFbGVtZW50OyAhISFcclxuICB9XHJcbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIkRlYnVnVGFyZ2V0LnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBSb3V0ZSB0byBhbiBIVE1MVGV4dEFyZWEsIG1heSBiZSBvYnNvbGV0ZSB3aGVuIHVzaW5nIEhUTUxEaWFsb2dFbGVtZW50XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIERlYnVnVGV4dEFyZWEgZXh0ZW5kcyBEZWJ1Z1RhcmdldCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHRleHRBcmVhOiBIVE1MVGV4dEFyZWFFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xyXG4gICAgcHVibGljIHN0YXRpYyBhdXRvU2Nyb2xsOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlbGVnYXRlczogTWFwRGVidWdGaWx0ZXJUb0RlbGVnYXRlID0ge1xyXG4gICAgICBbREVCVUdfRklMVEVSLklORk9dOiBEZWJ1Z1RleHRBcmVhLmNyZWF0ZURlbGVnYXRlKERFQlVHX1NZTUJPTFtERUJVR19GSUxURVIuSU5GT10pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkxPR106IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5MT0ddKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5XQVJOXTogRGVidWdUZXh0QXJlYS5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLldBUk5dKSxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5FUlJPUl06IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5FUlJPUl0pLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkZVREdFXTogRGVidWdUZXh0QXJlYS5jcmVhdGVEZWxlZ2F0ZShERUJVR19TWU1CT0xbREVCVUdfRklMVEVSLkZVREdFXSksXHJcbiAgICAgIFtERUJVR19GSUxURVIuQ0xFQVJdOiBEZWJ1Z1RleHRBcmVhLmNsZWFyLFxyXG4gICAgICBbREVCVUdfRklMVEVSLkdST1VQXTogRGVidWdUZXh0QXJlYS5ncm91cCxcclxuICAgICAgW0RFQlVHX0ZJTFRFUi5HUk9VUENPTExBUFNFRF06IERlYnVnVGV4dEFyZWEuZ3JvdXAsXHJcbiAgICAgIFtERUJVR19GSUxURVIuR1JPVVBFTkRdOiBEZWJ1Z1RleHRBcmVhLmdyb3VwRW5kLFxyXG4gICAgICBbREVCVUdfRklMVEVSLlNPVVJDRV06IERlYnVnVGV4dEFyZWEuY3JlYXRlRGVsZWdhdGUoREVCVUdfU1lNQk9MW0RFQlVHX0ZJTFRFUi5TT1VSQ0VdKVxyXG4gICAgfTtcclxuICAgIHByaXZhdGUgc3RhdGljIGdyb3Vwczogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgdGV4dCBhcmVhIGFuZCB0aGUgZ3JvdXBzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEudGV4dEFyZWEudGV4dENvbnRlbnQgPSBcIlwiO1xyXG4gICAgICBEZWJ1Z1RleHRBcmVhLmdyb3VwcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQmVnaW5zIGEgbmV3IGdyb3VwIHdpdGggdGhlIGdpdmVuIG5hbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBncm91cChfbmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEucHJpbnQoXCLilrwgXCIgKyBfbmFtZSk7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEuZ3JvdXBzLnB1c2goX25hbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmRzIHRoZSBsYXN0IGdyb3VwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXBFbmQoKTogdm9pZCB7XHJcbiAgICAgIERlYnVnVGV4dEFyZWEuZ3JvdXBzLnBvcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGRlbGVnYXRlLWZ1bmN0aW9uIGV4cGVjdGluZyBhIG1lc3NhZ2UgdG8gbG9nLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZURlbGVnYXRlKF9oZWFkbGluZTogc3RyaW5nKTogRnVuY3Rpb24ge1xyXG4gICAgICBsZXQgZGVsZWdhdGU6IEZ1bmN0aW9uID0gZnVuY3Rpb24gKF9tZXNzYWdlOiBPYmplY3QsIC4uLl9hcmdzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgICAgIERlYnVnVGV4dEFyZWEucHJpbnQoX2hlYWRsaW5lICsgXCIgXCIgKyBEZWJ1Z1RhcmdldC5tZXJnZUFyZ3VtZW50cyhfbWVzc2FnZSwgX2FyZ3MpKTtcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIGRlbGVnYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldEluZGVudGF0aW9uKF9sZXZlbDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgICAgbGV0IHJlc3VsdDogc3RyaW5nID0gXCJcIjtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF9sZXZlbDsgaSsrKVxyXG4gICAgICAgIHJlc3VsdCArPSBcInwgXCI7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJpbnQoX3RleHQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBEZWJ1Z1RleHRBcmVhLnRleHRBcmVhLnRleHRDb250ZW50ICs9IERlYnVnVGV4dEFyZWEuZ2V0SW5kZW50YXRpb24oRGVidWdUZXh0QXJlYS5ncm91cHMubGVuZ3RoKSArIF90ZXh0ICsgXCJcXG5cIjtcclxuICAgICAgaWYgKERlYnVnVGV4dEFyZWEuYXV0b1Njcm9sbClcclxuICAgICAgICBEZWJ1Z1RleHRBcmVhLnRleHRBcmVhLnNjcm9sbFRvcCA9IERlYnVnVGV4dEFyZWEudGV4dEFyZWEuc2Nyb2xsSGVpZ2h0O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFRoZSBjb2RlcyBzZW50IGZyb20gYSBzdGFuZGFyZCBlbmdsaXNoIGtleWJvYXJkIGxheW91dFxyXG4gICAqL1xyXG4gIGV4cG9ydCBlbnVtIEtFWUJPQVJEX0NPREUge1xyXG4gICAgQSA9IFwiS2V5QVwiLFxyXG4gICAgQiA9IFwiS2V5QlwiLFxyXG4gICAgQyA9IFwiS2V5Q1wiLFxyXG4gICAgRCA9IFwiS2V5RFwiLFxyXG4gICAgRSA9IFwiS2V5RVwiLFxyXG4gICAgRiA9IFwiS2V5RlwiLFxyXG4gICAgRyA9IFwiS2V5R1wiLFxyXG4gICAgSCA9IFwiS2V5SFwiLFxyXG4gICAgSSA9IFwiS2V5SVwiLFxyXG4gICAgSiA9IFwiS2V5SlwiLFxyXG4gICAgSyA9IFwiS2V5S1wiLFxyXG4gICAgTCA9IFwiS2V5TFwiLFxyXG4gICAgTSA9IFwiS2V5TVwiLFxyXG4gICAgTiA9IFwiS2V5TlwiLFxyXG4gICAgTyA9IFwiS2V5T1wiLFxyXG4gICAgUCA9IFwiS2V5UFwiLFxyXG4gICAgUSA9IFwiS2V5UVwiLFxyXG4gICAgUiA9IFwiS2V5UlwiLFxyXG4gICAgUyA9IFwiS2V5U1wiLFxyXG4gICAgVCA9IFwiS2V5VFwiLFxyXG4gICAgVSA9IFwiS2V5VVwiLFxyXG4gICAgViA9IFwiS2V5VlwiLFxyXG4gICAgVyA9IFwiS2V5V1wiLFxyXG4gICAgWCA9IFwiS2V5WFwiLFxyXG4gICAgWSA9IFwiS2V5WVwiLFxyXG4gICAgWiA9IFwiS2V5WlwiLFxyXG4gICAgRVNDID0gXCJFc2NhcGVcIixcclxuICAgIFpFUk8gPSBcIkRpZ2l0MFwiLFxyXG4gICAgT05FID0gXCJEaWdpdDFcIixcclxuICAgIFRXTyA9IFwiRGlnaXQyXCIsXHJcbiAgICBUSFJFRSA9IFwiRGlnaXQzXCIsXHJcbiAgICBGT1VSID0gXCJEaWdpdDRcIixcclxuICAgIEZJVkUgPSBcIkRpZ2l0NVwiLFxyXG4gICAgU0lYID0gXCJEaWdpdDZcIixcclxuICAgIFNFVkVOID0gXCJEaWdpdDdcIixcclxuICAgIEVJR0hUID0gXCJEaWdpdDhcIixcclxuICAgIE5JTkUgPSBcIkRpZ2l0OVwiLFxyXG4gICAgTUlOVVMgPSBcIk1pbnVzXCIsXHJcbiAgICBFUVVBTCA9IFwiRXF1YWxcIixcclxuICAgIEJBQ0tTUEFDRSA9IFwiQmFja3NwYWNlXCIsXHJcbiAgICBUQUJVTEFUT1IgPSBcIlRhYlwiLFxyXG4gICAgQlJBQ0tFVF9MRUZUID0gXCJCcmFja2V0TGVmdFwiLFxyXG4gICAgQlJBQ0tFVF9SSUdIVCA9IFwiQnJhY2tldFJpZ2h0XCIsXHJcbiAgICBFTlRFUiA9IFwiRW50ZXJcIixcclxuICAgIENUUkxfTEVGVCA9IFwiQ29udHJvbExlZnRcIixcclxuICAgIFNFTUlDT0xPTiA9IFwiU2VtaWNvbG9uXCIsXHJcbiAgICBRVU9URSA9IFwiUXVvdGVcIixcclxuICAgIEJBQ0tfUVVPVEUgPSBcIkJhY2txdW90ZVwiLFxyXG4gICAgU0hJRlRfTEVGVCA9IFwiU2hpZnRMZWZ0XCIsXHJcbiAgICBCQUNLU0xBU0ggPSBcIkJhY2tzbGFzaFwiLFxyXG4gICAgQ09NTUEgPSBcIkNvbW1hXCIsXHJcbiAgICBQRVJJT0QgPSBcIlBlcmlvZFwiLFxyXG4gICAgU0xBU0ggPSBcIlNsYXNoXCIsXHJcbiAgICBTSElGVF9SSUdIVCA9IFwiU2hpZnRSaWdodFwiLFxyXG4gICAgTlVNUEFEX01VTFRJUExZID0gXCJOdW1wYWRNdWx0aXBseVwiLFxyXG4gICAgQUxUX0xFRlQgPSBcIkFsdExlZnRcIixcclxuICAgIFNQQUNFID0gXCJTcGFjZVwiLFxyXG4gICAgQ0FQU19MT0NLID0gXCJDYXBzTG9ja1wiLFxyXG4gICAgRjEgPSBcIkYxXCIsXHJcbiAgICBGMiA9IFwiRjJcIixcclxuICAgIEYzID0gXCJGM1wiLFxyXG4gICAgRjQgPSBcIkY0XCIsXHJcbiAgICBGNSA9IFwiRjVcIixcclxuICAgIEY2ID0gXCJGNlwiLFxyXG4gICAgRjcgPSBcIkY3XCIsXHJcbiAgICBGOCA9IFwiRjhcIixcclxuICAgIEY5ID0gXCJGOVwiLFxyXG4gICAgRjEwID0gXCJGMTBcIixcclxuICAgIFBBVVNFID0gXCJQYXVzZVwiLFxyXG4gICAgU0NST0xMX0xPQ0sgPSBcIlNjcm9sbExvY2tcIixcclxuICAgIE5VTVBBRDcgPSBcIk51bXBhZDdcIixcclxuICAgIE5VTVBBRDggPSBcIk51bXBhZDhcIixcclxuICAgIE5VTVBBRDkgPSBcIk51bXBhZDlcIixcclxuICAgIE5VTVBBRF9TVUJUUkFDVCA9IFwiTnVtcGFkU3VidHJhY3RcIixcclxuICAgIE5VTVBBRDQgPSBcIk51bXBhZDRcIixcclxuICAgIE5VTVBBRDUgPSBcIk51bXBhZDVcIixcclxuICAgIE5VTVBBRDYgPSBcIk51bXBhZDZcIixcclxuICAgIE5VTVBBRF9BREQgPSBcIk51bXBhZEFkZFwiLFxyXG4gICAgTlVNUEFEMSA9IFwiTnVtcGFkMVwiLFxyXG4gICAgTlVNUEFEMiA9IFwiTnVtcGFkMlwiLFxyXG4gICAgTlVNUEFEMyA9IFwiTnVtcGFkM1wiLFxyXG4gICAgTlVNUEFEMCA9IFwiTnVtcGFkMFwiLFxyXG4gICAgTlVNUEFEX0RFQ0lNQUwgPSBcIk51bXBhZERlY2ltYWxcIixcclxuICAgIFBSSU5UX1NDUkVFTiA9IFwiUHJpbnRTY3JlZW5cIixcclxuICAgIElOVExfQkFDS19TTEFTSCA9IFwiSW50bEJhY2tTbGFzaFwiLFxyXG4gICAgRjExID0gXCJGMTFcIixcclxuICAgIEYxMiA9IFwiRjEyXCIsXHJcbiAgICBOVU1QQURfRVFVQUwgPSBcIk51bXBhZEVxdWFsXCIsXHJcbiAgICBGMTMgPSBcIkYxM1wiLFxyXG4gICAgRjE0ID0gXCJGMTRcIixcclxuICAgIEYxNSA9IFwiRjE1XCIsXHJcbiAgICBGMTYgPSBcIkYxNlwiLFxyXG4gICAgRjE3ID0gXCJGMTdcIixcclxuICAgIEYxOCA9IFwiRjE4XCIsXHJcbiAgICBGMTkgPSBcIkYxOVwiLFxyXG4gICAgRjIwID0gXCJGMjBcIixcclxuICAgIEYyMSA9IFwiRjIxXCIsXHJcbiAgICBGMjIgPSBcIkYyMlwiLFxyXG4gICAgRjIzID0gXCJGMjNcIixcclxuICAgIEYyNCA9IFwiRjI0XCIsXHJcbiAgICBLQU5BX01PREUgPSBcIkthbmFNb2RlXCIsXHJcbiAgICBMQU5HMiA9IFwiTGFuZzJcIixcclxuICAgIExBTkcxID0gXCJMYW5nMVwiLFxyXG4gICAgSU5UTF9STyA9IFwiSW50bFJvXCIsXHJcbiAgICBDT05WRVJUID0gXCJDb252ZXJ0XCIsXHJcbiAgICBOT05fQ09OVkVSVCA9IFwiTm9uQ29udmVydFwiLFxyXG4gICAgSU5UTF9ZRU4gPSBcIkludGxZZW5cIixcclxuICAgIE5VTVBBRF9DT01NQSA9IFwiTnVtcGFkQ29tbWFcIixcclxuICAgIFVORE8gPSBcIlVuZG9cIixcclxuICAgIFBBU1RFID0gXCJQYXN0ZVwiLFxyXG4gICAgTUVESUFfVFJBQ0tfUFJFVklPVVMgPSBcIk1lZGlhVHJhY2tQcmV2aW91c1wiLFxyXG4gICAgQ1VUID0gXCJDdXRcIixcclxuICAgIENPUFkgPSBcIkNvcHlcIixcclxuICAgIE1FRElBX1RSQUNLX05FWFQgPSBcIk1lZGlhVHJhY2tOZXh0XCIsXHJcbiAgICBOVU1QQURfRU5URVIgPSBcIk51bXBhZEVudGVyXCIsXHJcbiAgICBDVFJMX1JJR0hUID0gXCJDb250cm9sUmlnaHRcIixcclxuICAgIEFVRElPX1ZPTFVNRV9NVVRFID0gXCJBdWRpb1ZvbHVtZU11dGVcIixcclxuICAgIExBVU5DSF9BUFAyID0gXCJMYXVuY2hBcHAyXCIsXHJcbiAgICBNRURJQV9QTEFZX1BBVVNFID0gXCJNZWRpYVBsYXlQYXVzZVwiLFxyXG4gICAgTUVESUFfU1RPUCA9IFwiTWVkaWFTdG9wXCIsXHJcbiAgICBFSkVDVCA9IFwiRWplY3RcIixcclxuICAgIEFVRElPX1ZPTFVNRV9ET1dOID0gXCJBdWRpb1ZvbHVtZURvd25cIixcclxuICAgIFZPTFVNRV9ET1dOID0gXCJWb2x1bWVEb3duXCIsXHJcbiAgICBBVURJT19WT0xVTUVfVVAgPSBcIkF1ZGlvVm9sdW1lVXBcIixcclxuICAgIFZPTFVNRV9VUCA9IFwiVm9sdW1lVXBcIixcclxuICAgIEJST1dTRVJfSE9NRSA9IFwiQnJvd3NlckhvbWVcIixcclxuICAgIE5VTVBBRF9ESVZJREUgPSBcIk51bXBhZERpdmlkZVwiLFxyXG4gICAgQUxUX1JJR0hUID0gXCJBbHRSaWdodFwiLFxyXG4gICAgSEVMUCA9IFwiSGVscFwiLFxyXG4gICAgTlVNX0xPQ0sgPSBcIk51bUxvY2tcIixcclxuICAgIEhPTUUgPSBcIkhvbWVcIixcclxuICAgIEFSUk9XX1VQID0gXCJBcnJvd1VwXCIsXHJcbiAgICBBUlJPV19SSUdIVCA9IFwiQXJyb3dSaWdodFwiLFxyXG4gICAgQVJST1dfRE9XTiA9IFwiQXJyb3dEb3duXCIsXHJcbiAgICBBUlJPV19MRUZUID0gXCJBcnJvd0xlZnRcIixcclxuICAgIEVORCA9IFwiRW5kXCIsXHJcbiAgICBQQUdFX1VQID0gXCJQYWdlVXBcIixcclxuICAgIFBBR0VfRE9XTiA9IFwiUGFnZURvd25cIixcclxuICAgIElOU0VSVCA9IFwiSW5zZXJ0XCIsXHJcbiAgICBERUxFVEUgPSBcIkRlbGV0ZVwiLFxyXG4gICAgTUVUQV9MRUZUID0gXCJNZXRhX0xlZnRcIixcclxuICAgIE9TX0xFRlQgPSBcIk9TTGVmdFwiLFxyXG4gICAgTUVUQV9SSUdIVCA9IFwiTWV0YVJpZ2h0XCIsXHJcbiAgICBPU19SSUdIVCA9IFwiT1NSaWdodFwiLFxyXG4gICAgQ09OVEVYVF9NRU5VID0gXCJDb250ZXh0TWVudVwiLFxyXG4gICAgUE9XRVIgPSBcIlBvd2VyXCIsXHJcbiAgICBCUk9XU0VSX1NFQVJDSCA9IFwiQnJvd3NlclNlYXJjaFwiLFxyXG4gICAgQlJPV1NFUl9GQVZPUklURVMgPSBcIkJyb3dzZXJGYXZvcml0ZXNcIixcclxuICAgIEJST1dTRVJfUkVGUkVTSCA9IFwiQnJvd3NlclJlZnJlc2hcIixcclxuICAgIEJST1dTRVJfU1RPUCA9IFwiQnJvd3NlclN0b3BcIixcclxuICAgIEJST1dTRVJfRk9SV0FSRCA9IFwiQnJvd3NlckZvcndhcmRcIixcclxuICAgIEJST1dTRVJfQkFDSyA9IFwiQnJvd3NlckJhY2tcIixcclxuICAgIExBVU5DSF9BUFAxID0gXCJMYXVuY2hBcHAxXCIsXHJcbiAgICBMQVVOQ0hfTUFJTCA9IFwiTGF1bmNoTWFpbFwiLFxyXG4gICAgTEFVTkNIX01FRElBX1BMQVlFUiA9IFwiTGF1bmNoTWVkaWFQbGF5ZXJcIixcclxuXHJcbiAgICAvL21hYyBicmluZ3MgdGhpcyBidXR0dG9uXHJcbiAgICBGTiA9IFwiRm5cIiwgLy9ubyBldmVudCBmaXJlZCBhY3R1YWxseVxyXG5cclxuICAgIC8vTGludXggYnJpbmdzIHRoZXNlXHJcbiAgICBBR0FJTiA9IFwiQWdhaW5cIixcclxuICAgIFBST1BTID0gXCJQcm9wc1wiLFxyXG4gICAgU0VMRUNUID0gXCJTZWxlY3RcIixcclxuICAgIE9QRU4gPSBcIk9wZW5cIixcclxuICAgIEZJTkQgPSBcIkZpbmRcIixcclxuICAgIFdBS0VfVVAgPSBcIldha2VVcFwiLFxyXG4gICAgTlVNUEFEX1BBUkVOVF9MRUZUID0gXCJOdW1wYWRQYXJlbnRMZWZ0XCIsXHJcbiAgICBOVU1QQURfUEFSRU5UX1JJR0hUID0gXCJOdW1wYWRQYXJlbnRSaWdodFwiLFxyXG5cclxuICAgIC8vYW5kcm9pZFxyXG4gICAgU0xFRVAgPSBcIlNsZWVwXCJcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIEtFWUJPQVJEX0NPREVfREUge1xyXG4gICAgWiA9IEtFWUJPQVJEX0NPREUuWSxcclxuICAgIFkgPSBLRVlCT0FSRF9DT0RFLlosXHJcbiAgICDDliA9IEtFWUJPQVJEX0NPREUuU0VNSUNPTE9OLFxyXG4gICAgw4QgPSBLRVlCT0FSRF9DT0RFLlFVT1RFLFxyXG4gICAgw5wgPSBLRVlCT0FSRF9DT0RFLkJSQUNLRVRfTEVGVCxcclxuICAgIEhBU0ggPSBLRVlCT0FSRF9DT0RFLkJBQ0tTTEFTSCxcclxuICAgIFBMVVMgPSBLRVlCT0FSRF9DT0RFLkJSQUNLRVRfUklHSFQsXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgXHJcbiAgICDDnyA9IEtFWUJPQVJEX0NPREUuTUlOVVMsXHJcbiAgICBBQ1VURSA9IEtFWUJPQVJEX0NPREUuRVFVQUwsXHJcbiAgICBMRVNTX1RIQU4gPSBLRVlCT0FSRF9DT0RFLklOVExfQkFDS19TTEFTSCxcclxuICAgIE1JTlVTID0gS0VZQk9BUkRfQ09ERS5TTEFTSFxyXG4gIH1cclxuXHJcbiAgLyogXHJcbiAgRmlyZWZveCBjYW4ndCBtYWtlIHVzZSBvZiB0aG9zZSBidXR0b25zIGFuZCBDb21iaW5hdGlvbnM6XHJcbiAgU0lOR0VMRV9CVVRUT05TOlxyXG4gICBEcnVjayxcclxuICBDT01CSU5BVElPTlM6XHJcbiAgIFNoaWZ0ICsgRjEwLCBTaGlmdCArIE51bXBhZDUsXHJcbiAgIENUUkwgKyBxLCBDVFJMICsgRjQsXHJcbiAgIEFMVCArIEYxLCBBTFQgKyBGMiwgQUxUICsgRjMsIEFMVCArIEY3LCBBTFQgKyBGOCwgQUxUICsgRjEwXHJcbiAgT3BlcmEgd29uJ3QgZG8gZ29vZCB3aXRoIHRoZXNlIEJ1dHRvbnMgYW5kIGNvbWJpbmF0aW9uczpcclxuICBTSU5HTEVfQlVUVE9OUzpcclxuICAgRmxvYXQzMkFycmF5LCBGMTEsIEFMVCxcclxuICBDT01CSU5BVElPTlM6XHJcbiAgIENUUkwgKyBxLCBDVFJMICsgdCwgQ1RSTCArIGgsIENUUkwgKyBnLCBDVFJMICsgbiwgQ1RSTCArIGYgXHJcbiAgIEFMVCArIEYxLCBBTFQgKyBGMiwgQUxUICsgRjQsIEFMVCArIEY1LCBBTFQgKyBGNiwgQUxUICsgRjcsIEFMVCArIEY4LCBBTFQgKyBGMTBcclxuICAgKi9cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBjb25zdCBlbnVtIEVWRU5UX1RJTUVSIHtcclxuICAgIENBTEwgPSBcIsaSbGFwc2VcIlxyXG4gIH1cclxuICAvKipcclxuICAgKiBBbiBldmVudCB0aGF0IHJlcHJlc2VudHMgYSBjYWxsIGZyb20gYSB7QGxpbmsgVGltZXJ9XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEV2ZW50VGltZXIge1xyXG4gICAgcHVibGljIHR5cGU6IEVWRU5UX1RJTUVSID0gRVZFTlRfVElNRVIuQ0FMTDtcclxuICAgIHB1YmxpYyB0YXJnZXQ6IFRpbWVyO1xyXG4gICAgcHVibGljIGFyZ3VtZW50czogT2JqZWN0W107XHJcbiAgICBwdWJsaWMgZmlyc3RDYWxsOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHB1YmxpYyBsYXN0Q2FsbDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHVibGljIGNvdW50OiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF90aW1lcjogVGltZXIsIC4uLl9hcmd1bWVudHM6IE9iamVjdFtdKSB7XHJcbiAgICAgIHRoaXMudGFyZ2V0ID0gX3RpbWVyO1xyXG4gICAgICB0aGlzLmFyZ3VtZW50cyA9IF9hcmd1bWVudHM7XHJcbiAgICAgIHRoaXMuZmlyc3RDYWxsID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBDdXN0b20gdG91Y2ggZXZlbnRzXHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gRVZFTlRfVE9VQ0gge1xyXG4gICAgLyoqIGN1c3RvbSBldmVudCBmaXJlZCBpbiBhZGRpdGlvbiB0byB0aGUgc3RhbmRhcmQgdG91Y2htb3ZlLCBkZXRhaWxzIG9mZnNldCB0byBzdGFydGluZyB0b3VjaCAqL1xyXG4gICAgTU9WRSA9IFwidG91Y2hNb3ZlXCIsXHJcbiAgICAvKiogY3VzdG9tIGV2ZW50IGZpcmVkIHdoZW4gdGhlIHRvdWNoZXMgaGF2ZW4ndCBtb3ZlZCBvdXRzaWRlIG9mIHRoZSB0YXAgcmFkaXVzICovXHJcbiAgICBUQVAgPSBcInRvdWNoVGFwXCIsXHJcbiAgICAvKiogY3VzdG9tIGV2ZW50IGZpcmVkIHdoZW4gdGhlIHRvdWNoZXMgaGF2ZSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBub3RjaCByYWRpdXMsIGRldGFpbHMgb2Zmc2V0IGFuZCBjYXJkaW5hbCBkaXJlY3Rpb24gKi9cclxuICAgIE5PVENIID0gXCJ0b3VjaE5vdGNoXCIsXHJcbiAgICAvKiogY3VzdG9tIGV2ZW50IGZpcmVkIHdoZW4gdGhlIHRvdWNoZXMgaGF2ZW4ndCBtb3ZlZCBvdXRzaWRlIG9mIHRoZSB0YXAgcmFkaXVzIGZvciBzb21lIHRpbWUgKi9cclxuICAgIExPTkcgPSBcInRvdWNoTG9uZ1wiLFxyXG4gICAgLyoqIGN1c3RvbSBldmVudCBmaXJlZCB3aGVuIHR3byB0YXBzIHdlcmUgZGV0ZWN0ZWQgaW4gc2hvcnQgc3VjY2Vzc2lvbiAqL1xyXG4gICAgRE9VQkxFID0gXCJ0b3VjaERvdWJsZVwiLFxyXG4gICAgLyoqIGN1c3RvbSBldmVudCBmaXJlZCB3aGVuIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBvbmx5IHR3byB0b3VjaGVzIGNoYW5nZXMgYmV5b25kIGEgdG9sZXJhbmNlICovXHJcbiAgICBQSU5DSCA9IFwidG91Y2hQaW5jaFwiLFxyXG4gICAgLyoqIGN1c3RvbSBldmVudCBub3QgaW1wbGVtZW50ZWQgeWV0ICovXHJcbiAgICBST1RBVEUgPSBcInRvdWNoUm90YXRlXCJcclxuICB9XHJcblxyXG4gIC8qKiBEZXRhaWxzIGZvciBDdXN0b21Ub3VjaEV2ZW50cywgdXNlIGFzIGdlbmVyaWMgQ3VzdG9tRXZlbnQ8RXZlbnRUb3VjaERldGFpbD4gKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEV2ZW50VG91Y2hEZXRhaWwge1xyXG4gICAgcG9zaXRpb246IFZlY3RvcjI7XHJcbiAgICB0b3VjaGVzOiBUb3VjaExpc3Q7XHJcbiAgICBvZmZzZXQ/OiBWZWN0b3IyO1xyXG4gICAgbW92ZW1lbnQ/OiBWZWN0b3IyO1xyXG4gICAgY2FyZGluYWw/OiBWZWN0b3IyO1xyXG4gICAgcGluY2g/OiBWZWN0b3IyO1xyXG4gICAgcGluY2hEZWx0YT86IG51bWJlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoZXMgQ3VzdG9tVG91Y2hFdmVudHMgdG8gdGhlIEV2ZW50VGFyZ2V0IGdpdmVuIHdpdGggdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAqIFdoZW4gdXNpbmcgdG91Y2ggZXZlbnRzLCBtYWtlIHN1cmUgdG8gc2V0IGB0b3VjaC1hY3Rpb246IG5vbmVgIGluIENTUyBcclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIyXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFRvdWNoRXZlbnREaXNwYXRjaGVyIHtcclxuICAgIHB1YmxpYyBwb3NTdGFydDogVmVjdG9yMiA9IFZlY3RvcjIuWkVSTygpO1xyXG4gICAgcHVibGljIHBvc05vdGNoOiBWZWN0b3IyID0gVmVjdG9yMi5aRVJPKCk7XHJcbiAgICBwdWJsaWMgcmFkaXVzVGFwOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgcmFkaXVzTm90Y2g6IG51bWJlcjtcclxuICAgIHByaXZhdGUgdGFyZ2V0OiBFdmVudFRhcmdldDtcclxuICAgIHByaXZhdGUgcG9zUHJldjogVmVjdG9yMiA9IFZlY3RvcjIuWkVSTygpO1xyXG4gICAgcHJpdmF0ZSBtb3ZlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSB0aW1lckRvdWJsZTogVGltZXI7XHJcbiAgICBwcml2YXRlIHRpbWVyTG9uZzogVGltZXI7XHJcbiAgICBwcml2YXRlIHRpbWVEb3VibGU6IG51bWJlcjtcclxuICAgIHByaXZhdGUgdGltZUxvbmc6IG51bWJlcjtcclxuICAgIHByaXZhdGUgdGltZTogVGltZSA9IG5ldyBUaW1lKCk7XHJcbiAgICBwcml2YXRlIHBpbmNoRGlzdGFuY2U6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHBpbmNoVG9sZXJhbmNlOiBudW1iZXIgPSAxO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfdGFyZ2V0OiBFdmVudFRhcmdldCwgX3JhZGl1c1RhcDogbnVtYmVyID0gNSwgX3JhZGl1c05vdGNoOiBudW1iZXIgPSA1MCwgX3RpbWVEb3VibGU6IG51bWJlciA9IDIwMCwgX3RpbWVyTG9uZzogbnVtYmVyID0gMTAwMCkge1xyXG4gICAgICB0aGlzLnRhcmdldCA9IF90YXJnZXQ7XHJcbiAgICAgIHRoaXMucmFkaXVzVGFwID0gX3JhZGl1c1RhcDtcclxuICAgICAgdGhpcy5yYWRpdXNOb3RjaCA9IF9yYWRpdXNOb3RjaDtcclxuICAgICAgdGhpcy50aW1lRG91YmxlID0gX3RpbWVEb3VibGU7XHJcbiAgICAgIHRoaXMudGltZUxvbmcgPSBfdGltZXJMb25nO1xyXG4gICAgICB0aGlzLmFjdGl2YXRlKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGUtL0FjdGl2YXRlcyB0aGUgZGlzcGF0Y2ggb2YgQ3VzdG9tVG91Y2hFdmVudHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlKF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICBpZiAoX29uKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgPEV2ZW50TGlzdGVuZXI+dGhpcy5obmRFdmVudCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIDxFdmVudExpc3RlbmVyPnRoaXMuaG5kRXZlbnQpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgPEV2ZW50TGlzdGVuZXI+dGhpcy5obmRFdmVudCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCA8RXZlbnRMaXN0ZW5lcj50aGlzLmhuZEV2ZW50KTtcclxuICAgICAgdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIDxFdmVudExpc3RlbmVyPnRoaXMuaG5kRXZlbnQpO1xyXG4gICAgICB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIDxFdmVudExpc3RlbmVyPnRoaXMuaG5kRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaG5kRXZlbnQgPSAoX2V2ZW50OiBUb3VjaEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIF9ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBsZXQgdG91Y2hGaXJzdDogVG91Y2ggPSBfZXZlbnQudG91Y2hlc1swXTtcclxuICAgICAgbGV0IHBvc2l0aW9uOiBWZWN0b3IyID0gdGhpcy5jYWxjQXZlcmFnZVBvc2l0aW9uKF9ldmVudC50b3VjaGVzKTsgLy9uZXcgVmVjdG9yMih0b3VjaEZpcnN0Py5jbGllbnRYLCB0b3VjaEZpcnN0Py5jbGllbnRZKTtcclxuICAgICAgbGV0IG9mZnNldDogVmVjdG9yMjtcclxuXHJcbiAgICAgIHN3aXRjaCAoX2V2ZW50LnR5cGUpIHtcclxuICAgICAgICBjYXNlIFwidG91Y2hzdGFydFwiOlxyXG4gICAgICAgICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgdGhpcy5zdGFydEdlc3R1cmUocG9zaXRpb24pO1xyXG5cclxuICAgICAgICAgIGlmIChfZXZlbnQudG91Y2hlcy5sZW5ndGggPT0gMikge1xyXG4gICAgICAgICAgICAvLyByZXNldCBwaW5jaFxyXG4gICAgICAgICAgICBsZXQgcGluY2g6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihfZXZlbnQudG91Y2hlc1sxXS5jbGllbnRYIC0gdG91Y2hGaXJzdC5jbGllbnRYLCBfZXZlbnQudG91Y2hlc1sxXS5jbGllbnRZIC0gdG91Y2hGaXJzdC5jbGllbnRZKTtcclxuICAgICAgICAgICAgdGhpcy5waW5jaERpc3RhbmNlID0gcGluY2gubWFnbml0dWRlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGxldCBkaXNwYXRjaExvbmc6IFRpbWVySGFuZGxlciA9IChfZXZlbnRUaW1lcjogRXZlbnRUaW1lcik6IHZvaWQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQuZGlzcGF0Y2hFdmVudChcclxuICAgICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQ8RXZlbnRUb3VjaERldGFpbD4oRVZFTlRfVE9VQ0guTE9ORywge1xyXG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgdG91Y2hlczogX2V2ZW50LnRvdWNoZXMgfVxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHRoaXMudGltZXJMb25nPy5jbGVhcigpO1xyXG4gICAgICAgICAgdGhpcy50aW1lckxvbmcgPSBuZXcgVGltZXIodGhpcy50aW1lLCB0aGlzLnRpbWVMb25nLCAxLCBkaXNwYXRjaExvbmcpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInRvdWNoZW5kXCI6XHJcbiAgICAgICAgICB0aGlzLnRpbWVyTG9uZz8uY2xlYXIoKTtcclxuXHJcbiAgICAgICAgICBpZiAoX2V2ZW50LnRvdWNoZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBzdGlsbCB0b3VjaGVzIGFjdGl2ZVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0R2VzdHVyZShwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGxldCBkaXNwYXRjaFRhcDogVGltZXJIYW5kbGVyID0gKF9ldmVudFRpbWVyOiBFdmVudFRpbWVyKTogdm9pZCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmRpc3BhdGNoRXZlbnQoXHJcbiAgICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50PEV2ZW50VG91Y2hEZXRhaWw+KEVWRU5UX1RPVUNILlRBUCwge1xyXG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgdG91Y2hlczogX2V2ZW50LnRvdWNoZXMgfVxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIHdhcyBhIHRhcCBiZWZvcmUgYW5kIHRpbWVyIGlzIHN0aWxsIHJ1bm5pbmcgLT4gZG91YmxlIHRhcFxyXG4gICAgICAgICAgaWYgKHRoaXMudGltZXJEb3VibGU/LmFjdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVyRG91YmxlLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIC8vIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmRpc3BhdGNoRXZlbnQoXHJcbiAgICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50PEV2ZW50VG91Y2hEZXRhaWw+KEVWRU5UX1RPVUNILkRPVUJMRSwge1xyXG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgdG91Y2hlczogX2V2ZW50LnRvdWNoZXMgfVxyXG4gICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMubW92ZWQpXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIHdhcyBtb3ZlbWVudCwgb3RoZXJ3aXNlIHNldCB0aW1lciB0byBmaXJlIHRhcFxyXG4gICAgICAgICAgICB0aGlzLnRpbWVyRG91YmxlID0gbmV3IFRpbWVyKHRoaXMudGltZSwgdGhpcy50aW1lRG91YmxlLCAxLCBkaXNwYXRjaFRhcCk7XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInRvdWNobW92ZVwiOlxyXG4gICAgICAgICAgdGhpcy5kZXRlY3RQaW5jaChfZXZlbnQsIHBvc2l0aW9uKTtcclxuICAgICAgICAgIG9mZnNldCA9IFZlY3RvcjIuRElGRkVSRU5DRSh0aGlzLnBvc1ByZXYsIHRoaXMucG9zU3RhcnQpO1xyXG4gICAgICAgICAgdGhpcy5tb3ZlZCB8fD0gKG9mZnNldC5tYWduaXR1ZGUgPCB0aGlzLnJhZGl1c1RhcCk7IC8vIHJlbWVtYmVyIHRoYXQgdG91Y2ggbW92ZWQgb3ZlciB0YXAgcmFkaXVzXHJcbiAgICAgICAgICBsZXQgbW92ZW1lbnQ6IFZlY3RvcjIgPSBWZWN0b3IyLkRJRkZFUkVOQ0UocG9zaXRpb24sIHRoaXMucG9zUHJldik7XHJcbiAgICAgICAgICB0aGlzLnRhcmdldC5kaXNwYXRjaEV2ZW50KFxyXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQ8RXZlbnRUb3VjaERldGFpbD4oRVZFTlRfVE9VQ0guTU9WRSwge1xyXG4gICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsIGRldGFpbDogeyBwb3NpdGlvbjogcG9zaXRpb24sIHRvdWNoZXM6IF9ldmVudC50b3VjaGVzLCBvZmZzZXQ6IG9mZnNldCwgbW92ZW1lbnQ6IG1vdmVtZW50IH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgLy8gZmlyZSBub3RjaCB3aGVuIHRvdWNoZXMgbW92ZWQgb3V0IG9mIG5vdGNoIHJhZGl1cyBhbmQgcmVzZXQgbm90Y2hcclxuICAgICAgICAgIG9mZnNldCA9IFZlY3RvcjIuRElGRkVSRU5DRShwb3NpdGlvbiwgdGhpcy5wb3NOb3RjaCk7XHJcbiAgICAgICAgICBpZiAob2Zmc2V0Lm1hZ25pdHVkZSA+IHRoaXMucmFkaXVzTm90Y2gpIHtcclxuICAgICAgICAgICAgbGV0IGNhcmRpbmFsOiBWZWN0b3IyID0gTWF0aC5hYnMob2Zmc2V0LngpID4gTWF0aC5hYnMob2Zmc2V0LnkpID9cclxuICAgICAgICAgICAgICBWZWN0b3IyLlgob2Zmc2V0LnggPCAwID8gLTEgOiAxKSA6XHJcbiAgICAgICAgICAgICAgVmVjdG9yMi5ZKG9mZnNldC55IDwgMCA/IC0xIDogMSk7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmRpc3BhdGNoRXZlbnQoXHJcbiAgICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50PEV2ZW50VG91Y2hEZXRhaWw+KEVWRU5UX1RPVUNILk5PVENILCB7XHJcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHsgcG9zaXRpb246IHBvc2l0aW9uLCB0b3VjaGVzOiBfZXZlbnQudG91Y2hlcywgb2Zmc2V0OiBvZmZzZXQsIGNhcmRpbmFsOiBjYXJkaW5hbCwgbW92ZW1lbnQ6IG1vdmVtZW50IH1cclxuICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHRoaXMucG9zTm90Y2ggPSBwb3NpdGlvbjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vVE9ETzogcGluY2gsIHJvdGF0ZS4uLlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnBvc1ByZXYuc2V0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGRldGVjdFBpbmNoID0gKF9ldmVudDogVG91Y2hFdmVudCwgX3Bvc2l0aW9uOiBWZWN0b3IyKTogdm9pZCA9PiB7XHJcbiAgICAgIGlmIChfZXZlbnQudG91Y2hlcy5sZW5ndGggIT0gMilcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBsZXQgdDogVG91Y2hMaXN0ID0gX2V2ZW50LnRvdWNoZXM7XHJcbiAgICAgIGxldCBwaW5jaDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKHRbMV0uY2xpZW50WCAtIHRbMF0uY2xpZW50WCwgdFsxXS5jbGllbnRZIC0gdFswXS5jbGllbnRZKTtcclxuICAgICAgbGV0IHBpbmNoRGlzdGFuY2U6IG51bWJlciA9IHBpbmNoLm1hZ25pdHVkZTtcclxuICAgICAgbGV0IHBpbmNoRGVsdGE6IG51bWJlciA9IHBpbmNoRGlzdGFuY2UgLSB0aGlzLnBpbmNoRGlzdGFuY2U7XHJcbiAgICAgIGlmIChNYXRoLmFicyhwaW5jaERlbHRhKSA+IHRoaXMucGluY2hUb2xlcmFuY2UpXHJcbiAgICAgICAgdGhpcy50YXJnZXQuZGlzcGF0Y2hFdmVudChcclxuICAgICAgICAgIG5ldyBDdXN0b21FdmVudDxFdmVudFRvdWNoRGV0YWlsPihFVkVOVF9UT1VDSC5QSU5DSCwge1xyXG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHsgcG9zaXRpb246IF9wb3NpdGlvbiwgdG91Y2hlczogX2V2ZW50LnRvdWNoZXMsIHBpbmNoOiBwaW5jaCwgcGluY2hEZWx0YTogcGluY2hEZWx0YSB9XHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgIHRoaXMucGluY2hEaXN0YW5jZSA9IHBpbmNoRGlzdGFuY2U7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgc3RhcnRHZXN0dXJlKF9wb3NpdGlvbjogVmVjdG9yMik6IHZvaWQge1xyXG4gICAgICB0aGlzLnBvc05vdGNoLnNldChfcG9zaXRpb24ueCwgX3Bvc2l0aW9uLnkpO1xyXG4gICAgICB0aGlzLnBvc1N0YXJ0LnNldChfcG9zaXRpb24ueCwgX3Bvc2l0aW9uLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY2FsY0F2ZXJhZ2VQb3NpdGlvbihfdG91Y2hlczogVG91Y2hMaXN0KTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBhdmVyYWdlOiBWZWN0b3IyID0gVmVjdG9yMi5aRVJPKCk7XHJcbiAgICAgIGZvciAobGV0IHRvdWNoIG9mIF90b3VjaGVzKSB7XHJcbiAgICAgICAgYXZlcmFnZS54ICs9IHRvdWNoLmNsaWVudFg7XHJcbiAgICAgICAgYXZlcmFnZS55ICs9IHRvdWNoLmNsaWVudFk7XHJcbiAgICAgIH1cclxuICAgICAgYXZlcmFnZS5zY2FsZSgxIC8gX3RvdWNoZXMubGVuZ3RoKTtcclxuICAgICAgcmV0dXJuIGF2ZXJhZ2U7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIG5vZGUgbWFuYWdlZCBieSB7QGxpbmsgUHJvamVjdH0gdGhhdCBmdW5jdGlvbnMgYXMgYSB0ZW1wbGF0ZSBmb3Ige0BsaW5rIEdyYXBoSW5zdGFuY2V9cyBcclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2hzLWZ1cnR3YW5nZW4vRlVER0Uvd2lraS9SZXNvdXJjZVxyXG4gICAqL1xyXG4gIEBTZXJpYWxpemFibGVSZXNvdXJjZS5yZWdpc3RlclxyXG4gIGV4cG9ydCBjbGFzcyBHcmFwaCBleHRlbmRzIE5vZGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGVSZXNvdXJjZSB7XHJcbiAgICBwdWJsaWMgaWRSZXNvdXJjZTogc3RyaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgLy8gI3N5bmNpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiR3JhcGhcIikge1xyXG4gICAgICBzdXBlcihfbmFtZSk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5NVVRBVEUsIHRoaXMuaG5kTXV0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHR5cGUoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UgPSB0aGlzLmlkUmVzb3VyY2U7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24udHlwZSA9IHRoaXMudHlwZTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBQcm9qZWN0LnJlZ2lzdGVyKHRoaXMsIF9zZXJpYWxpemF0aW9uLmlkUmVzb3VyY2UpO1xyXG4gICAgICBhd2FpdCBQcm9qZWN0LnJlc3luY0dyYXBoSW5zdGFuY2VzKHRoaXMpO1xyXG4gICAgICB0aGlzLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVC5HUkFQSF9ERVNFUklBTElaRUQpKTtcclxuICAgICAgRGVidWcubG9nKFwiRGVzZXJpYWxpemVkXCIsIHRoaXMubmFtZSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaG5kTXV0YXRlID0gYXN5bmMgKF9ldmVudDogQ3VzdG9tRXZlbnQpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuXHJcbiAgICAgIC8vIFRPRE86IGlmIHBhdGggY29udGFpbnMgYSBncmFwaCBpbnN0YW5jZSBiZWxvdyB0aGlzLCBkb24ndCBkaXNwYXRjaCFcclxuICAgICAgLy8gbGV0IHBhdGg6IE5vZGVbXSA9IFJlZmxlY3QuZ2V0KF9ldmVudCwgXCJwYXRoXCIpO1xyXG4gICAgICAvLyBmb3IgKGxldCBub2RlIG9mIHBhdGgpXHJcbiAgICAgIC8vICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBHcmFwaEluc3RhbmNlICYmIG5vZGUuaWRTb3VyY2UgIT0gdGhpcy5pZFJlc291cmNlKVxyXG4gICAgICAvLyAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gY29uc29sZS5sb2coXCJHcmFwaCBtdXRhdGVzXCIsIHRoaXMubmFtZSk7XHJcbiAgICAgIC8vIHRoaXMuI3N5bmNpbmcgPSB0cnVlO1xyXG4gICAgICBfZXZlbnQuZGV0YWlsLnBhdGggPSBSZWZsZWN0LmdldChfZXZlbnQsIFwicGF0aFwiKTsgLy8gc2F2ZSBwYXRoIHRvIHRhcmdldCBpbiBkZXRhaWxcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChFVkVOVC5NVVRBVEVfR1JBUEgsIHsgZGV0YWlsOiBfZXZlbnQuZGV0YWlsIH0pKTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChFVkVOVC5HUkFQSF9NVVRBVEVELCB7IGRldGFpbDogX2V2ZW50LmRldGFpbCB9KSk7XHJcbiAgICAgIC8vIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTVVUQVRFX0lOU1RBTkNFKSk7XHJcbiAgICAgIC8vIHRoaXMuI3N5bmNpbmcgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEEge0BsaW5rIEdyYXBofSBsb2FkZWQgZnJvbSBhIGdsVEYtRmlsZS5cclxuICAgKiBAYXV0aG9ycyBKb25hcyBQbG90emt5LCBIRlUsIDIwMjRcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgR3JhcGhHTFRGIGV4dGVuZHMgbWl4aW5TZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsKEdyYXBoKSB7XHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZChfdXJsOiBSZXF1ZXN0SW5mbyA9IHRoaXMudXJsLCBfbmFtZTogc3RyaW5nID0gdGhpcy5uYW1lKTogUHJvbWlzZTxHcmFwaEdMVEY+IHtcclxuICAgICAgdGhpcy51cmwgPSBfdXJsO1xyXG4gICAgICB0aGlzLm5hbWUgPSBfbmFtZTtcclxuICAgICAgcmV0dXJuIEdMVEZMb2FkZXIubG9hZFJlc291cmNlKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGNvbnN0IHNlcmlhbGl6YXRpb25FeHRlcm5hbDogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBjb25zdCBzZXJpYWxpemF0aW9uTm9kZTogU2VyaWFsaXphdGlvbiA9IE5vZGUucHJvdG90eXBlLnNlcmlhbGl6ZS5jYWxsKHRoaXMpOyAvLyB0aGlzIGlzIHdhc3RlZnVsIGFzIHdlIG9ubHkgbmVlZCB0aGUgY29tcG9uZW50cyBkZXNlcmlhbGl6ZWRcclxuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb25Ob2RlLmNvbXBvbmVudHNbQ29tcG9uZW50U2tlbGV0b24ubmFtZV07XHJcbiAgICAgIGRlbGV0ZSBzZXJpYWxpemF0aW9uTm9kZS5jaGlsZHJlbjtcclxuICAgICAgcmV0dXJuIHsgLi4uc2VyaWFsaXphdGlvbk5vZGUsIC4uLnNlcmlhbGl6YXRpb25FeHRlcm5hbCB9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgYXdhaXQgR3JhcGgucHJvdG90eXBlLmRlc2VyaWFsaXplLmNhbGwodGhpcywgX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLy8gZW51bSBTWU5DIHtcclxuICAvLyAgIFJFQURZLCBHUkFQSF9TWU5DRUQsIEdSQVBIX0RPTkUsIElOU1RBTkNFXHJcbiAgLy8gfVxyXG5cclxuICAvKipcclxuICAgKiBBbiBpbnN0YW5jZSBvZiBhIHtAbGluayBHcmFwaH0uICBcclxuICAgKiBUaGlzIG5vZGUga2VlcHMgYSByZWZlcmVuY2UgdG8gaXRzIHJlc291cmNlIGFuIGNhbiB0aHVzIG9wdGltaXplIHNlcmlhbGl6YXRpb25cclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2hzLWZ1cnR3YW5nZW4vRlVER0Uvd2lraS9SZXNvdXJjZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBHcmFwaEluc3RhbmNlIGV4dGVuZHMgTm9kZSB7XHJcbiAgICAvKiogaWQgb2YgdGhlIHJlc291cmNlIHRoYXQgaW5zdGFuY2Ugd2FzIGNyZWF0ZWQgZnJvbSAqL1xyXG4gICAgLy8gVE9ETzogZXhhbWluZSwgaWYgdGhpcyBzaG91bGQgYmUgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBHcmFwaCwgaW5zdGVhZCBvZiB0aGUgaWRcclxuICAgIHB1YmxpYyBzdGF0aWMgY291bnQ6IG51bWJlciA9IDA7XHJcbiAgICAjaWRTb3VyY2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcclxuICAgIC8vICNzeW5jOiBTWU5DID0gU1lOQy5SRUFEWTtcclxuICAgICNkZXNlcmlhbGl6ZUZyb21Tb3VyY2U6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBjb25zdHJ1Y3RvciBhbG9uZSB3aWxsIG5vdCBjcmVhdGUgYSByZWNvbnN0cnVjdGlvbiwgYnV0IG9ubHkgc2F2ZSB0aGUgaWQuXHJcbiAgICAgKiBUbyBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIGdyYXBoLCBjYWxsIHJlc2V0IG9uIHRoaXMgb3Igc2V0IHdpdGggYSBncmFwaCBhcyBwYXJhbWV0ZXIuXHJcbiAgICAgKiBQcmVmZXIgUHJvamVjdC5jcmVhdGVHcmFwaEluc3RhbmNlKF9ncmFwaCkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfZ3JhcGg/OiBHcmFwaCkge1xyXG4gICAgICBzdXBlcihcIkdyYXBoSW5zdGFuY2VcIik7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5NVVRBVEUsIHRoaXMuaG5kTXV0YXRpb25JbnN0YW5jZSk7XHJcblxyXG4gICAgICBpZiAoIV9ncmFwaClcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIHRoaXMuI2lkU291cmNlID0gX2dyYXBoLmlkUmVzb3VyY2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpZFNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy4jaWRTb3VyY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNyZWF0ZSB0aGlzIG5vZGUgZnJvbSB0aGUge0BsaW5rIEdyYXBofSByZWZlcmVuY2VkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyByZXNldCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgbGV0IHJlc291cmNlOiBHcmFwaCA9IDxHcmFwaD5hd2FpdCBQcm9qZWN0LmdldFJlc291cmNlKHRoaXMuI2lkU291cmNlKTtcclxuICAgICAgYXdhaXQgdGhpcy5zZXQocmVzb3VyY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vVE9ETzogb3B0aW1pemUgdXNpbmcgdGhlIHJlZmVyZW5jZWQgR3JhcGgsIHNlcmlhbGl6ZS9kZXNlcmlhbGl6ZSBvbmx5IHRoZSBkaWZmZXJlbmNlc1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IGZpbHRlcjogQ29tcG9uZW50R3JhcGhGaWx0ZXIgPSB0aGlzLmdldENvbXBvbmVudChDb21wb25lbnRHcmFwaEZpbHRlcik7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge307XHJcblxyXG4gICAgICBpZiAoZmlsdGVyICYmIGZpbHRlci5pc0FjdGl2ZSkgeyAvLyBpZiBncmFwaCBzeW5jaHJvbmlzYXRpb24gaXMgdW5maWx0ZXJlZCwga25vd2luZyB0aGUgc291cmNlIGlzIHN1ZmZpY2llbnQgZm9yIHNlcmlhbGl6YXRpb25cclxuICAgICAgICBzZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgICAgbGV0IGdyYXBoOiBHcmFwaCA9IHRoaXMuZ2V0KCk7XHJcbiAgICAgICAgaWYgKGdyYXBoIGluc3RhbmNlb2YgR3JhcGhHTFRGKSB7IC8vIGxpa2UgZm9yIHRoZSBHcmFwaEdMVEY6IGNoaWxkcmVuIGFuZCBjb21wb25lbnRzIGxvYWRlZCBmcm9tIGdsdGYgbXVzdCBuZXZlciBiZSBzZXJpYWxpemVkXHJcbiAgICAgICAgICBkZWxldGUgc2VyaWFsaXphdGlvbi5jb21wb25lbnRzW0NvbXBvbmVudFNrZWxldG9uLm5hbWVdO1xyXG4gICAgICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb24uY2hpbGRyZW47XHJcbiAgICAgICAgICBzZXJpYWxpemF0aW9uLnVybCA9IGdyYXBoLnVybDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VyaWFsaXphdGlvbi5kZXNlcmlhbGl6ZUZyb21Tb3VyY2UgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaWRTb3VyY2UgPSB0aGlzLiNpZFNvdXJjZTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy4jaWRTb3VyY2UgPSBfc2VyaWFsaXphdGlvbi5pZFNvdXJjZSA/PyBfc2VyaWFsaXphdGlvbi5pZFJlc291cmNlO1xyXG4gICAgICBpZiAoIV9zZXJpYWxpemF0aW9uLmRlc2VyaWFsaXplRnJvbVNvdXJjZSkge1xyXG4gICAgICAgIGxldCBncmFwaDogR3JhcGggPSA8R3JhcGg+PHVua25vd24+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZSh0aGlzLiNpZFNvdXJjZSk7XHJcbiAgICAgICAgaWYgKGdyYXBoIGluc3RhbmNlb2YgR3JhcGhHTFRGKVxyXG4gICAgICAgICAgYXdhaXQgR0xURkxvYWRlci5sb2FkUmVzb3VyY2UodGhpcywgX3NlcmlhbGl6YXRpb24udXJsKTtcclxuXHJcbiAgICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pOyAvLyBpbnN0YW5jZSBpcyBkZXNlcmlhbGl6ZWQgZnJvbSBpbmRpdmlkdWFsIGRhdGFcclxuXHJcbiAgICAgICAgdGhpcy4jZGVzZXJpYWxpemVGcm9tU291cmNlID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBncmFwaDogR3JhcGggPSB0aGlzLmdldCgpO1xyXG4gICAgICBpZiAoZ3JhcGgpXHJcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0VG9HcmFwaCgpOyAvLyBvdGhlcndpc2UganVzdCBjb25uZWN0XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIERlYnVnLmxvZyhcIlJlZ2lzdGVyIGZvciByZXN5bmNcIiwgX3NlcmlhbGl6YXRpb24ubmFtZSwgdGhpcy5uYW1lKTtcclxuICAgICAgICBQcm9qZWN0LnJlZ2lzdGVyR3JhcGhJbnN0YW5jZUZvclJlc3luYyh0aGlzKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbm5lY3RzIHRoaXMgZ3JhcGggaW5zdGFuY2UgdG8gdGhlIGdyYXBoIHJlZmVyZW5jZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBjb25uZWN0VG9HcmFwaCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgbGV0IGdyYXBoOiBHcmFwaCA9IHRoaXMuZ2V0KCk7XHJcbiAgICAgIGlmICh0aGlzLiNkZXNlcmlhbGl6ZUZyb21Tb3VyY2UpXHJcbiAgICAgICAgYXdhaXQgdGhpcy5zZXQoZ3JhcGgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoaXMgbm9kZSB0byBiZSBhIHJlY3JlYXRpb24gb2YgdGhlIHtAbGluayBHcmFwaH0gZ2l2ZW5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIHNldChfZ3JhcGg6IEdyYXBoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIHRoaXMuI2lkU291cmNlID0gX2dyYXBoLmlkUmVzb3VyY2U7XHJcblxyXG4gICAgICBsZXQgY3VycmVudEdyYXBoOiBHcmFwaCA9IHRoaXMuZ2V0KCk7XHJcbiAgICAgIGlmIChjdXJyZW50R3JhcGgpIHtcclxuICAgICAgICBjdXJyZW50R3JhcGgucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5NVVRBVEVfR1JBUEgsIHRoaXMuaG5kTXV0YXRpb25HcmFwaCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRPRE86IGV4YW1pbmUsIGlmIHRoZSBzZXJpYWxpemF0aW9uIHNob3VsZCBiZSBzdG9yZWQgaW4gdGhlIEdyYXBoIGZvciBvcHRpbWl6YXRpb24gPC0gYWxzbyB1c2VmdWwgZm9yIHN5bmMgd2l0aCBpbnN0YW5jZXNcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBTZXJpYWxpemVyLnNlcmlhbGl6ZShfZ3JhcGgpO1xyXG4gICAgICBmb3IgKGxldCBwYXRoIGluIHNlcmlhbGl6YXRpb24pIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmRlc2VyaWFsaXplKHNlcmlhbGl6YXRpb25bcGF0aF0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBEZWJ1Zy5mdWRnZShcIkdyYXBoSW5zdGFuY2Ugc2V0IHRvIFwiICsgdGhpcy5uYW1lICsgXCIgfCBcIiArIFwiSW5zdGFuY2UgY291bnQ6IFwiICsgR3JhcGhJbnN0YW5jZS5jb3VudCsrKTtcclxuICAgICAgX2dyYXBoLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuTVVUQVRFX0dSQVBILCB0aGlzLmhuZE11dGF0aW9uR3JhcGgpO1xyXG4gICAgICB0aGlzLmJyb2FkY2FzdEV2ZW50KG5ldyBFdmVudChFVkVOVC5HUkFQSF9JTlNUQU5USUFURUQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBncmFwaCB0aGlzIGluc3RhbmNlcyByZWZlcnMgdG9cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBHcmFwaCB7XHJcbiAgICAgIHJldHVybiA8R3JhcGg+UHJvamVjdC5yZXNvdXJjZXNbdGhpcy4jaWRTb3VyY2VdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU291cmNlIGdyYXBoIG11dGF0ZWQsIHJlZmxlY3QgbXV0YXRpb24gaW4gdGhpcyBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhuZE11dGF0aW9uR3JhcGggPSBhc3luYyAoX2V2ZW50OiBDdXN0b21FdmVudCk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgICBpZiAodGhpcy5pc0ZpbHRlcmVkKCkpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgYXdhaXQgdGhpcy5yZWZsZWN0TXV0YXRpb24oX2V2ZW50LCA8R3JhcGg+X2V2ZW50LmN1cnJlbnRUYXJnZXQsIHRoaXMsIF9ldmVudC5kZXRhaWwucGF0aCk7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZFTlQuTVVUQVRFX0lOU1RBTkNFLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaW5zdGFuY2UgbXV0YXRlZCwgcmVmbGVjdCBtdXRhdGlvbiBpbiBzb3VyY2UgZ3JhcGhcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBobmRNdXRhdGlvbkluc3RhbmNlID0gYXN5bmMgKF9ldmVudDogQ3VzdG9tRXZlbnQpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgICAgaWYgKHRoaXMuaXNGaWx0ZXJlZCgpKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGF3YWl0IHRoaXMucmVmbGVjdE11dGF0aW9uKF9ldmVudCwgdGhpcywgdGhpcy5nZXQoKSwgUmVmbGVjdC5nZXQoX2V2ZW50LCBcInBhdGhcIikpO1xyXG4gICAgICB0aGlzLmdldCgpLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KEVWRU5ULk1VVEFURSwgeyBkZXRhaWw6IF9ldmVudC5kZXRhaWwgfSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyByZWZsZWN0IG11dGF0aW9uIGZyb20gYSBzb3VyY2UgZ3JhcGggb3IgaW5zdGFuY2UgdG8gYSBkZXN0aW5hdGlvbiBpbnN0YW5jZSBvciBncmFwaFxyXG4gICAgcHJpdmF0ZSBhc3luYyByZWZsZWN0TXV0YXRpb24oX2V2ZW50OiBDdXN0b21FdmVudCwgX3NvdXJjZTogTm9kZSwgX2Rlc3RpbmF0aW9uOiBOb2RlLCBfcGF0aDogTm9kZVtdKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGZvciAobGV0IG5vZGUgb2YgX3BhdGgpIC8vIGl0ZXJhdGUgdXAgdGhlIGV2ZW50IHBhdGgsIHdoaWNoIG1heSBjb250YWluIHJlZ3VsYXIgTm9kZXMgb3IgR3JhcGhJbnN0YW5jZXNcclxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEdyYXBoSW5zdGFuY2UpIC8vIHVudGlsIHRoaXMgR3JhcGhJbnN0YW5jZSBpcyBmb3VuZCAob3Igbm8gR3JhcGhJbnN0YW5jZS4uLilcclxuICAgICAgICAgIGlmIChub2RlID09IHRoaXMpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3luYyBhYm9ydGVkLCB0YXJnZXQgYWxyZWFkeSBzeW5jZWRcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgIC8vIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgbm9kZSBpbiB0aGUgZGVzdGluYXRpb24gaGllcmFyY2h5XHJcbiAgICAgIGxldCBpbmRleDogbnVtYmVyID0gX3BhdGguaW5kZXhPZihfc291cmNlKTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGxldCBjaGlsZEluZGV4OiBudW1iZXIgPSBfcGF0aFtpXS5nZXRQYXJlbnQoKS5maW5kQ2hpbGQoX3BhdGhbaV0pOyAvLyBnZXQgdGhlIGluZGV4IG9mIHRoZSBjaGlsZG5vZGUgaW4gdGhlIG9yaWdpbmFsIHBhdGhcclxuICAgICAgICBfZGVzdGluYXRpb24gPSBfZGVzdGluYXRpb24uZ2V0Q2hpbGQoY2hpbGRJbmRleCk7IC8vIGdldCB0aGUgY29ycmVzcG9uZGluZyBjaGlsZCBpbiB0aGlzIHBhdGhcclxuICAgICAgICAvLyBUT0RPOiByZXNwZWN0IGluZGV4IGZvciBub24tc2luZ2xldG9uIGNvbXBvbmVudHMuLi5cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gbXV0YXRlIHRoZSBjb3JyZXNwb25kaW5nIGNvbXBvbmVudCBpbiB0aGUgZGVzdGluYXRpb25cclxuICAgICAgbGV0IGNtcE11dGF0ZTogQ29tcG9uZW50ID0gX2Rlc3RpbmF0aW9uLmdldENvbXBvbmVudChfZXZlbnQuZGV0YWlsLmNvbXBvbmVudC5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgIGlmIChjbXBNdXRhdGUpXHJcbiAgICAgICAgYXdhaXQgY21wTXV0YXRlLm11dGF0ZShfZXZlbnQuZGV0YWlsLm11dGF0b3IsIG51bGwsIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGlzRmlsdGVyZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgIGxldCBjbXBGaWx0ZXI6IENvbXBvbmVudEdyYXBoRmlsdGVyID0gdGhpcy5nZXRDb21wb25lbnQoQ29tcG9uZW50R3JhcGhGaWx0ZXIpO1xyXG4gICAgICByZXR1cm4gKGNtcEZpbHRlciAmJiBjbXBGaWx0ZXIuaXNBY3RpdmUpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEhvbGRzIGRhdGEgdG8gZmVlZCBpbnRvIGEge0BsaW5rIFNoYWRlcn0gdG8gZGVzY3JpYmUgdGhlIHN1cmZhY2Ugb2Yge0BsaW5rIE1lc2h9LiAgXHJcbiAgICoge0BsaW5rIE1hdGVyaWFsfXMgcmVmZXJlbmNlIHtAbGluayBDb2F0fSBhbmQge0BsaW5rIFNoYWRlcn0uICAgXHJcbiAgICogVGhlIG1ldGhvZCB1c2VSZW5kZXJEYXRhIHdpbGwgYmUgaW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yfSBhdCBydW50aW1lLCBleHRlbmRpbmcgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhpcyBjbGFzcyB0byBkZWFsIHdpdGggdGhlIHJlbmRlcmVyLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb2F0IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSB7IC8vIFRPRE86IHJlZmFjdG9yIGludG8gY29tcG9zaXRpb24gYmFzZWQgc3RydWN0dXJlXHJcbiAgICAvLyBwdWJsaWMgbmFtZTogc3RyaW5nID0gXCJDb2F0XCI7XHJcbiAgICAvKipcclxuICAgICAqIENsaXBwaW5nIHRocmVzaG9sZCBmb3IgYWxwaGEgdmFsdWVzLCBldmVyeSBwaXhlbCB3aXRoIGFscGhhIDwgYWxwaGFDbGlwIHdpbGwgYmUgZGlzY2FyZGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWxwaGFDbGlwOiBudW1iZXIgPSAwLjAxO1xyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgcmVyb3V0ZSB0byB7QGxpbmsgUmVuZGVyTWFuYWdlckNvYXQucmVzZXRSZW5kZXJEYXRhfSAqL1xyXG4gICAgQFJlbmRlck1hbmFnZXJDb2F0LmRlY29yYXRlXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlc2V0UmVuZGVyRGF0YSgpOiB2b2lkIHsgLyogaW5qZWN0ZWQgKi8gfTtcclxuXHJcbiAgICAvKiogQGludGVybmFsIHJlcm91dGUgdG8ge0BsaW5rIFJlbmRlck1hbmFnZXJDb2F0LnVwZGF0ZVJlbmRlcmJ1ZmZlcn0gKi9cclxuICAgIEBSZW5kZXJNYW5hZ2VyQ29hdC5kZWNvcmF0ZVxyXG4gICAgcHVibGljIHN0YXRpYyB1cGRhdGVSZW5kZXJidWZmZXIoKTogdm9pZCB7IC8qIGluamVjdGVkICovIH07XHJcblxyXG4gICAgLyoqIEBpbnRlcm5hbCByZXJvdXRlIHRvIHtAbGluayBSZW5kZXJNYW5hZ2VyQ29hdC51cGRhdGVSZW5kZXJEYXRhfSAqL1xyXG4gICAgQFJlbmRlck1hbmFnZXJDb2F0LmRlY29yYXRlXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHVwZGF0ZVJlbmRlckRhdGEoX2NvYXQ6IENvYXQpOiB2b2lkIHsgLyogaW5qZWN0ZWQgKi8gfTtcclxuXHJcbiAgICAvKiogQGludGVybmFsIHJlcm91dGUgdG8ge0BsaW5rIFJlbmRlck1hbmFnZXJDb2F0LnVzZVJlbmRlckRhdGF9ICovXHJcbiAgICBAUmVuZGVyTWFuYWdlckNvYXQuZGVjb3JhdGVcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgdXNlUmVuZGVyRGF0YShfY29hdDogQ29hdCk6IHZvaWQgeyAvKiBpbmplY3RlZCAqLyB9O1xyXG5cclxuICAgIC8qKiBDYWxsZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0gZHVyaW5nIHtAbGluayBSZW5kZXIucHJlcGFyZX0uIE92ZXJyaWRlIHRoaXMgdG8gcHJvdmlkZSB0aGUgcmVuZGVyIHN5c3RlbSB3aXRoIGFkZGl0aW9uYWwgcmVuZGVyIGRhdGEuICovXHJcbiAgICBwdWJsaWMgdXBkYXRlUmVuZGVyRGF0YSgpOiB2b2lkIHtcclxuICAgICAgQ29hdC51cGRhdGVSZW5kZXJEYXRhKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiogQ2FsbGVkIGJ5IHRoZSByZW5kZXIgc3lzdGVtIGR1cmluZyB7QGxpbmsgUmVuZGVyLmRyYXd9LiBPdmVycmlkZSB0aGlzIHRvIHByb3ZpZGUgdGhlIHJlbmRlciBzeXN0ZW0gd2l0aCBhZGRpdGlvbmFsIHJlbmRlciBkYXRhLiAqL1xyXG4gICAgcHVibGljIHVzZVJlbmRlckRhdGEoKTogdm9pZCB7XHJcbiAgICAgIENvYXQudXNlUmVuZGVyRGF0YSh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGFscGhhQ2xpcDogdGhpcy5hbHBoYUNsaXBcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi5hbHBoYUNsaXAgIT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLmFscGhhQ2xpcCA9IF9zZXJpYWxpemF0aW9uLmFscGhhQ2xpcDtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnJlbmRlckRhdGE7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBUaGUgc2ltcGxlc3Qge0BsaW5rIENvYXR9IHByb3ZpZGluZyBqdXN0IGEgY29sb3JcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29hdENvbG9yZWQgZXh0ZW5kcyBDb2F0IHtcclxuICAgIHB1YmxpYyBjb2xvcjogQ29sb3I7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoKSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLmNvbG9yID0gX2NvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5jb2xvciA9IHRoaXMuY29sb3Iuc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBhd2FpdCB0aGlzLmNvbG9yLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmNvbG9yKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIHtAbGluayBDb2F0fSBwcm92aWRpbmcgYSBjb2xvciBhbmQgcGFyYW1ldGVycyBmb3IgdGhlIHBob25nIHNoYWRpbmcgbW9kZWwuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvYXRSZW1pc3NpdmUgZXh0ZW5kcyBDb2F0Q29sb3JlZCB7XHJcbiAgICBwdWJsaWMgZGlmZnVzZTogbnVtYmVyO1xyXG4gICAgcHVibGljIHNwZWN1bGFyOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgaW50ZW5zaXR5OiBudW1iZXI7XHJcblxyXG4gICAgI21ldGFsbGljOiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoKSwgX2RpZmZ1c2U6IG51bWJlciA9IDEsIF9zcGVjdWxhcjogbnVtYmVyID0gMC41LCBfaW50ZW5zaXR5OiBudW1iZXIgPSAwLjcsIF9tZXRhbGxpYzogbnVtYmVyID0gMC4wKSB7XHJcbiAgICAgIHN1cGVyKF9jb2xvcik7XHJcbiAgICAgIHRoaXMuZGlmZnVzZSA9IF9kaWZmdXNlO1xyXG4gICAgICB0aGlzLnNwZWN1bGFyID0gX3NwZWN1bGFyO1xyXG4gICAgICB0aGlzLmludGVuc2l0eSA9IF9pbnRlbnNpdHk7XHJcbiAgICAgIHRoaXMubWV0YWxsaWMgPSBfbWV0YWxsaWM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBtZXRhbGxpYygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWV0YWxsaWM7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1ldGFsbGljKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21ldGFsbGljID0gQ2FsYy5jbGFtcChfdmFsdWUsIDAsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5kaWZmdXNlID0gdGhpcy5kaWZmdXNlO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnNwZWN1bGFyID0gdGhpcy5zcGVjdWxhcjtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5tZXRhbGxpYyA9IHRoaXMubWV0YWxsaWM7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgdGhpcy5kaWZmdXNlID0gX3NlcmlhbGl6YXRpb24uZGlmZnVzZTtcclxuICAgICAgdGhpcy5zcGVjdWxhciA9IF9zZXJpYWxpemF0aW9uLnNwZWN1bGFyO1xyXG4gICAgICB0aGlzLmludGVuc2l0eSA9IF9zZXJpYWxpemF0aW9uLmludGVuc2l0eSA/PyB0aGlzLmludGVuc2l0eTtcclxuICAgICAgdGhpcy5tZXRhbGxpYyA9IF9zZXJpYWxpemF0aW9uLm1ldGFsbGljID8/IHRoaXMubWV0YWxsaWM7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IodHJ1ZSk7XHJcbiAgICAgIGRlbGV0ZSBtdXRhdG9yLmRpZmZ1c2U7XHJcbiAgICAgIGRlbGV0ZSBtdXRhdG9yLnNwZWN1bGFyO1xyXG4gICAgICBkZWxldGUgbXV0YXRvci5pbnRlbnNpdHk7XHJcbiAgICAgIG11dGF0b3IuZGlmZnVzZSA9IHRoaXMuZGlmZnVzZTtcclxuICAgICAgbXV0YXRvci5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXI7XHJcbiAgICAgIG11dGF0b3IuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XHJcbiAgICAgIG11dGF0b3IubWV0YWxsaWMgPSB0aGlzLm1ldGFsbGljO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEEge0BsaW5rIENvYXR9IHByb3ZpZGluZyBhIHRleHR1cmUgYW5kIGFkZGl0aW9uYWwgZGF0YSBmb3IgdGV4dHVyaW5nXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvYXRUZXh0dXJlZCBleHRlbmRzIENvYXRDb2xvcmVkIHtcclxuXHJcbiAgICBAdHlwZShUZXh0dXJlKVxyXG4gICAgcHVibGljIHRleHR1cmU6IFRleHR1cmU7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9jb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoKSwgX3RleHR1cmU6IFRleHR1cmUgPSBUZXh0dXJlRGVmYXVsdC5jb2xvcikge1xyXG4gICAgICBzdXBlcihfY29sb3IpO1xyXG4gICAgICB0aGlzLnRleHR1cmUgPSBfdGV4dHVyZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaWRUZXh0dXJlID0gdGhpcy50ZXh0dXJlLmlkUmVzb3VyY2U7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBpZiAoX3NlcmlhbGl6YXRpb24uaWRUZXh0dXJlKVxyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IDxUZXh0dXJlPmF3YWl0IFByb2plY3QuZ2V0UmVzb3VyY2UoX3NlcmlhbGl6YXRpb24uaWRUZXh0dXJlKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCJDb2F0VGV4dHVyZWQudHNcIi8+XHJcblxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIHtAbGluayBDb2F0fSBwcm92aWRpbmcgYSB0ZXh0dXJlIGFuZCBhZGRpdGlvbmFsIGRhdGEgZm9yIHRleHR1cmluZ1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb2F0UmVtaXNzaXZlVGV4dHVyZWQgZXh0ZW5kcyBDb2F0VGV4dHVyZWQge1xyXG4gICAgcHVibGljIGRpZmZ1c2U6IG51bWJlcjtcclxuICAgIHB1YmxpYyBzcGVjdWxhcjogbnVtYmVyO1xyXG4gICAgcHVibGljIGludGVuc2l0eTogbnVtYmVyO1xyXG5cclxuICAgICNtZXRhbGxpYzogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKCksIF90ZXh0dXJlOiBUZXh0dXJlID0gVGV4dHVyZURlZmF1bHQuY29sb3IsIF9kaWZmdXNlOiBudW1iZXIgPSAxLCBfc3BlY3VsYXI6IG51bWJlciA9IDAuNSwgX2ludGVuc2l0eTogbnVtYmVyID0gMC43LCBfbWV0YWxsaWM6IG51bWJlciA9IDAuMCkge1xyXG4gICAgICBzdXBlcihfY29sb3IsIF90ZXh0dXJlKTtcclxuICAgICAgdGhpcy5kaWZmdXNlID0gX2RpZmZ1c2U7XHJcbiAgICAgIHRoaXMuc3BlY3VsYXIgPSBfc3BlY3VsYXI7XHJcbiAgICAgIHRoaXMuaW50ZW5zaXR5ID0gX2ludGVuc2l0eTtcclxuICAgICAgdGhpcy5tZXRhbGxpYyA9IF9tZXRhbGxpYztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IG1ldGFsbGljKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtZXRhbGxpYztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbWV0YWxsaWMoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWV0YWxsaWMgPSBDYWxjLmNsYW1wKF92YWx1ZSwgMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmRpZmZ1c2UgPSB0aGlzLmRpZmZ1c2U7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xyXG4gICAgICBzZXJpYWxpemF0aW9uLm1ldGFsbGljID0gdGhpcy5tZXRhbGxpYztcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHRoaXMuZGlmZnVzZSA9IF9zZXJpYWxpemF0aW9uLmRpZmZ1c2U7XHJcbiAgICAgIHRoaXMuc3BlY3VsYXIgPSBfc2VyaWFsaXphdGlvbi5zcGVjdWxhcjtcclxuICAgICAgdGhpcy5pbnRlbnNpdHkgPSBfc2VyaWFsaXphdGlvbi5pbnRlbnNpdHkgPz8gdGhpcy5pbnRlbnNpdHk7XHJcbiAgICAgIHRoaXMubWV0YWxsaWMgPSBfc2VyaWFsaXphdGlvbi5tZXRhbGxpYyA/PyB0aGlzLm1ldGFsbGljO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKHRydWUpO1xyXG4gICAgICBkZWxldGUgbXV0YXRvci5kaWZmdXNlO1xyXG4gICAgICBkZWxldGUgbXV0YXRvci5zcGVjdWxhcjtcclxuICAgICAgZGVsZXRlIG11dGF0b3IuaW50ZW5zaXR5O1xyXG4gICAgICBtdXRhdG9yLmRpZmZ1c2UgPSB0aGlzLmRpZmZ1c2U7XHJcbiAgICAgIG11dGF0b3Iuc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyO1xyXG4gICAgICBtdXRhdG9yLmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xyXG4gICAgICBtdXRhdG9yLm1ldGFsbGljID0gdGhpcy5tZXRhbGxpYztcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCJDb2F0VGV4dHVyZWQudHNcIi8+XHJcblxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIHtAbGluayBDb2F0fSBwcm92aWRpbmcgYSB0ZXh0dXJlIGFuZCBhZGRpdGlvbmFsIGRhdGEgZm9yIHRleHR1cmluZ1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb2F0UmVtaXNzaXZlVGV4dHVyZWROb3JtYWxzIGV4dGVuZHMgQ29hdFJlbWlzc2l2ZVRleHR1cmVkIHtcclxuXHJcbiAgICBAdHlwZShUZXh0dXJlKVxyXG4gICAgcHVibGljIG5vcm1hbE1hcDogVGV4dHVyZTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigpLCBfdGV4dHVyZTogVGV4dHVyZSA9IFRleHR1cmVEZWZhdWx0LmNvbG9yLCBfbm9ybWFsTWFwOiBUZXh0dXJlID0gVGV4dHVyZURlZmF1bHQubm9ybWFsLCBfZGlmZnVzZT86IG51bWJlciwgX3NwZWN1bGFyOiBudW1iZXIgPSB1bmRlZmluZWQsIF9pbnRlbnNpdHk6IG51bWJlciA9IHVuZGVmaW5lZCwgX21ldGFsbGljOiBudW1iZXIgPSB1bmRlZmluZWQpIHtcclxuICAgICAgc3VwZXIoX2NvbG9yLCBfdGV4dHVyZSwgX2RpZmZ1c2UsIF9zcGVjdWxhciwgX2ludGVuc2l0eSwgX21ldGFsbGljKTtcclxuICAgICAgdGhpcy5ub3JtYWxNYXAgPSBfbm9ybWFsTWFwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5pZE5vcm1hbE1hcCA9IHRoaXMubm9ybWFsTWFwLmlkUmVzb3VyY2U7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBpZiAoX3NlcmlhbGl6YXRpb24uaWROb3JtYWxNYXApXHJcbiAgICAgICAgdGhpcy5ub3JtYWxNYXAgPSA8VGV4dHVyZT5hd2FpdCBQcm9qZWN0LmdldFJlc291cmNlKF9zZXJpYWxpemF0aW9uLmlkTm9ybWFsTWFwKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQSB7QGxpbmsgQ29hdH0gcHJvdmlkaW5nIGEgY29sb3IgYW5kIHBhcmFtZXRlcnMgZm9yIHRoZSB0b29uIHNoYWRpbmcgbW9kZWwuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIENvYXRUb29uIGV4dGVuZHMgbWl4aW5Db2F0VG9vbihDb2F0UmVtaXNzaXZlKSB7XHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2NvbG9yOiBDb2xvciA9IG5ldyBDb2xvcigpLCBfdGV4VG9vbjogVGV4dHVyZSA9IFRleHR1cmVEZWZhdWx0LnRvb24sIF9kaWZmdXNlPzogbnVtYmVyLCBfc3BlY3VsYXI6IG51bWJlciA9IDEuMiwgX2ludGVuc2l0eT86IG51bWJlciwgX21ldGFsbGljPzogbnVtYmVyKSB7XHJcbiAgICAgIHN1cGVyKF9jb2xvciwgX2RpZmZ1c2UsIF9zcGVjdWxhciwgX2ludGVuc2l0eSwgX21ldGFsbGljKTtcclxuICAgICAgdGhpcy50ZXhUb29uID0gX3RleFRvb247XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHtAbGluayBDb2F0fSBwcm92aWRpbmcgYSB0ZXh0dXJlLCBhIGNvbG9yIGFuZCBwYXJhbWV0ZXJzIGZvciB0aGUgdG9vbiBzaGFkaW5nIG1vZGVsLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb2F0VG9vblRleHR1cmVkIGV4dGVuZHMgbWl4aW5Db2F0VG9vbihDb2F0UmVtaXNzaXZlVGV4dHVyZWQpIHtcclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKCksIF90ZXh0dXJlOiBUZXh0dXJlID0gVGV4dHVyZURlZmF1bHQuY29sb3IsIF90ZXhUb29uOiBUZXh0dXJlID0gVGV4dHVyZURlZmF1bHQudG9vbiwgX2RpZmZ1c2U/OiBudW1iZXIsIF9zcGVjdWxhcjogbnVtYmVyID0gMS4yLCBfaW50ZW5zaXR5PzogbnVtYmVyLCBfbWV0YWxsaWM/OiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIoX2NvbG9yLCBfdGV4dHVyZSwgX2RpZmZ1c2UsIF9zcGVjdWxhciwgX2ludGVuc2l0eSwgX21ldGFsbGljKTtcclxuICAgICAgdGhpcy50ZXhUb29uID0gX3RleFRvb247XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtaXhpbkNvYXRUb29uPFRCYXNlIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBHZW5lcmFsW10pID0+IFNlcmlhbGl6YWJsZSAmIE11dGFibGU+KF9iYXNlOiBUQmFzZSk6IChhYnN0cmFjdCBuZXcgKC4uLmFyZ3M6IEdlbmVyYWxbXSkgPT4geyB0ZXhUb29uOiBUZXh0dXJlIH0pICYgVEJhc2Uge1xyXG4gICAgYWJzdHJhY3QgY2xhc3MgQ29hdFRvb24gZXh0ZW5kcyBfYmFzZSB7XHJcblxyXG4gICAgICBAdHlwZShUZXh0dXJlKVxyXG4gICAgICBwdWJsaWMgdGV4VG9vbjogVGV4dHVyZTtcclxuXHJcbiAgICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgICBzZXJpYWxpemF0aW9uLmlkVGV4VG9vbiA9IHRoaXMudGV4VG9vbi5pZFJlc291cmNlO1xyXG4gICAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgICBpZiAoX3NlcmlhbGl6YXRpb24uaWRUZXhUb29uKVxyXG4gICAgICAgICAgdGhpcy50ZXhUb29uID0gPFRleHR1cmU+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZFRleFRvb24pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIENvYXRUb29uO1xyXG4gIH1cclxufVxyXG5cclxuXHJcblxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBEZWZpbmVzIGEgY29sb3IgYXMgdmFsdWVzIGluIHRoZSByYW5nZSBvZiAwIHRvIDEgZm9yIHRoZSBmb3VyIGNoYW5uZWxzIHJlZCwgZ3JlZW4sIGJsdWUgYW5kIGFscGhhIChmb3Igb3BhY2l0eSlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29sb3IgZXh0ZW5kcyBNdXRhYmxlIGltcGxlbWVudHMgU2VyaWFsaXphYmxlLCBSZWN5Y2FibGUge1xyXG4gICAgLy8gY3JjMiBvbmx5IHVzZWQgZm9yIGNvbnZlcnRpbmcgY29sb3JzIGZyb20gc3RyaW5ncyBwcmVkZWZpbmVkIGJ5IENTU1xyXG4gICAgcHVibGljIHN0YXRpYyBjcmMyOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSAoKCkgPT4ge1xyXG4gICAgICBjb25zdCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgY2FudmFzLndpZHRoID0gMTtcclxuICAgICAgY2FudmFzLmhlaWdodCA9IDE7XHJcbiAgICAgIGNvbnN0IGNyYzI6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwgeyB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWUgfSk7XHJcbiAgICAgIGNyYzIuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJjb3B5XCI7XHJcbiAgICAgIHJldHVybiBjcmMyO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICBwdWJsaWMgcjogbnVtYmVyO1xyXG4gICAgcHVibGljIGc6IG51bWJlcjtcclxuICAgIHB1YmxpYyBiOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYTogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfcjogbnVtYmVyID0gMSwgX2c6IG51bWJlciA9IDEsIF9iOiBudW1iZXIgPSAxLCBfYTogbnVtYmVyID0gMSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnNldChfciwgX2csIF9iLCBfYSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gSFNMIHZhbHVlcyB0byBSR0IgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBpbiB0aGUgZ2l2ZW4gb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIF9odWUgSHVlIGFzIGFuIGFuZ2xlIGluIGRlZ3JlZXMgaW4gcmFuZ2UgWzAsIDM2MF0uXHJcbiAgICAgKiBAcGFyYW0gX3NhdHVyYXRpb24gU2F0dXJhdGlvbiBpbiByYW5nZSBbMCwgMV1cclxuICAgICAqIEBwYXJhbSBfbGlnaHRuZXNzIExpZ2h0bmVzcyBpbiByYW5nZSBbMCwgMV1cclxuICAgICAqIEBwYXJhbSBfb3V0IE9wdGlvbmFsIGNvbG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgUkdCIHZhbHVlcyBpbiByYW5nZSBbMCwgMV0uXHJcbiAgICAgKiBAc291cmNlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItNC8jaHNsLXRvLXJnYlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGhzbDJyZ2I8VCBleHRlbmRzIHsgcjogbnVtYmVyOyBnOiBudW1iZXI7IGI6IG51bWJlciB9ID0geyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyIH0+KF9odWU6IG51bWJlciwgX3NhdHVyYXRpb246IG51bWJlciwgX2xpZ2h0bmVzczogbnVtYmVyLCBfb3V0OiBUKTogVCB7XHJcbiAgICAgIF9odWUgPSBfaHVlICUgMzYwO1xyXG5cclxuICAgICAgaWYgKF9odWUgPCAwKVxyXG4gICAgICAgIF9odWUgKz0gMzYwO1xyXG5cclxuICAgICAgX291dC5yID0gQ29sb3IuI2YoMCwgX2h1ZSwgX3NhdHVyYXRpb24sIF9saWdodG5lc3MpO1xyXG4gICAgICBfb3V0LmcgPSBDb2xvci4jZig4LCBfaHVlLCBfc2F0dXJhdGlvbiwgX2xpZ2h0bmVzcyk7XHJcbiAgICAgIF9vdXQuYiA9IENvbG9yLiNmKDQsIF9odWUsIF9zYXR1cmF0aW9uLCBfbGlnaHRuZXNzKTtcclxuXHJcbiAgICAgIHJldHVybiBfb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIF9yZWQgUmVkIHZhbHVlICBbMCwgMV1cclxuICAgICAqIEBwYXJhbSBfZ3JlZW4gR3JlZW4gY29tcG9uZW50IFswLCAxXVxyXG4gICAgICogQHBhcmFtIF9ibHVlIEJsdWUgY29tcG9uZW50IFswLCAxXVxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgY29sb3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqIEByZXR1cm5zIFRoZSBIU0wgdmFsdWVzLiBIdWUgYXMgYW4gYW5nbGUgaW4gZGVncmVlcyBpbiByYW5nZSBbMCwgMzYwXS4gU2F0dXJhdGlvbiBhbmQgbGlnaHRuZXNzIGluIHJhbmdlIFswLCAxXS5cclxuICAgICAqIEBzb3VyY2UgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci00LyNyZ2ItdG8taHNsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmdiMmhzbDxUIGV4dGVuZHMgeyBoOiBudW1iZXI7IHM6IG51bWJlcjsgbDogbnVtYmVyIH0gPSB7IGg6IG51bWJlcjsgczogbnVtYmVyOyBsOiBudW1iZXIgfT4oX3JlZDogbnVtYmVyLCBfZ3JlZW46IG51bWJlciwgX2JsdWU6IG51bWJlciwgX291dDogVCk6IFQge1xyXG4gICAgICBsZXQgbWF4OiBudW1iZXIgPSBNYXRoLm1heChfcmVkLCBfZ3JlZW4sIF9ibHVlKTtcclxuICAgICAgbGV0IG1pbjogbnVtYmVyID0gTWF0aC5taW4oX3JlZCwgX2dyZWVuLCBfYmx1ZSk7XHJcbiAgICAgIGxldCBodWU6IG51bWJlciA9IE5hTjtcclxuICAgICAgbGV0IHNhdHVyYXRpb246IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCBsaWdodG5lc3M6IG51bWJlciA9IChtaW4gKyBtYXgpIC8gMjtcclxuXHJcbiAgICAgIGxldCBkOiBudW1iZXIgPSBtYXggLSBtaW47XHJcblxyXG4gICAgICBpZiAoZCAhPT0gMCkge1xyXG4gICAgICAgIHNhdHVyYXRpb24gPSAobGlnaHRuZXNzID09PSAwIHx8IGxpZ2h0bmVzcyA9PT0gMSlcclxuICAgICAgICAgID8gMFxyXG4gICAgICAgICAgOiAobWF4IC0gbGlnaHRuZXNzKSAvIE1hdGgubWluKGxpZ2h0bmVzcywgMSAtIGxpZ2h0bmVzcyk7XHJcblxyXG4gICAgICAgIHN3aXRjaCAobWF4KSB7XHJcbiAgICAgICAgICBjYXNlIF9yZWQ6IGh1ZSA9IChfZ3JlZW4gLSBfYmx1ZSkgLyBkICsgKF9ncmVlbiA8IF9ibHVlID8gNiA6IDApOyBicmVhaztcclxuICAgICAgICAgIGNhc2UgX2dyZWVuOiBodWUgPSAoX2JsdWUgLSBfcmVkKSAvIGQgKyAyOyBicmVhaztcclxuICAgICAgICAgIGNhc2UgX2JsdWU6IGh1ZSA9IChfcmVkIC0gX2dyZWVuKSAvIGQgKyA0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaHVlID0gaHVlICogNjA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzYXR1cmF0aW9uIDwgMCkge1xyXG4gICAgICAgIGh1ZSArPSAxODA7XHJcbiAgICAgICAgc2F0dXJhdGlvbiA9IE1hdGguYWJzKHNhdHVyYXRpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaHVlID49IDM2MClcclxuICAgICAgICBodWUgLT0gMzYwO1xyXG5cclxuICAgICAgX291dC5oID0gaHVlO1xyXG4gICAgICBfb3V0LnMgPSBzYXR1cmF0aW9uO1xyXG4gICAgICBfb3V0LmwgPSBsaWdodG5lc3M7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gX291dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcge0BsaW5rIENvbG9yfSBvYmplY3QgY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBjc3MgY29sb3Iga2V5d29yZC4gXHJcbiAgICAgKiBQYXNzaW5nIGFuIF9hbHBoYSB2YWx1ZSB3aWxsIG92ZXJyaWRlIHRoZSBhbHBoYSB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhlIGtleXdvcmQuXHJcbiAgICAgKiBTdXBwb3J0ZWQgY29sb3IgZm9ybWF0cyBhcmU6XHJcbiAgICAgKiAtIG5hbWVkIGNvbG9ycyAoZS5nLiBcInJlZFwiLCBcImJsdWVcIiwgXCJncmVlblwiKVxyXG4gICAgICogLSBoZXggY29sb3JzIChlLmcuIFwiI2YwMFwiIFwiI2ZmMDAwMFwiLCBcIiNmZjAwMDBmZlwiKVxyXG4gICAgICogLSBzcmdiIGNvbG9ycyAoZS5nLiBcInJnYigyNTUgMCAwIC8gMSlcIiwgXCJyZ2IoMjU1LCAwLCAwKVwiLCBcInJnYmEoMCwgMCwgMjU1LCAxKSlcclxuICAgICAqIC0gaHNsIGNvbG9ycyAoZS5nLiBcImhzbCg5MGRlZyAxMDAlIDUwJSAvIDEpXCIsIFwiaHNsKDkwLCAxMDAlLCA1MCUpXCIsIGhzbGEoOTAsIDEwMCUsIDUwJSwgMSkpXHJcbiAgICAgKiBcclxuICAgICAqICoqTm90ZToqKiBJZiBwb3NzaWJpbGUgdHJ5IHRvIGF2b2lkIGludm9raW5nIHRoaXMgbWV0aG9kIGZyZXF1ZW50bHksIGFzIGl0IG1pZ2h0IGNhdXNlIG1ham9yIGdhcmJhZ2UgY29sbGVjdGlvbiBkZXBlbmRpbmcgb24gdGhlIGtleXdvcmQgYW5kIGJyb3dzZXIuXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCBjb2xvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENTUyhfa2V5d29yZDogc3RyaW5nLCBfYWxwaGE/OiBudW1iZXIsIF9vdXQ6IENvbG9yID0gUmVjeWNsZXIucmV1c2UoQ29sb3IpKTogQ29sb3Ige1xyXG4gICAgICBDb2xvci5jcmMyLmZpbGxTdHlsZSA9IF9rZXl3b3JkOyAvLyBUSElTIHN0aWxsIGNhdXNlcyBtYWpvciBnYXJiYWdlIGNvbGxlY3Rpb24gZGVwZW5kaW5nIG9uIHRoZSBrZXl3b3JkICh0ZXN0ZWQgaW4gQ2hyb21lKVxyXG4gICAgICBjb25zdCB2YWx1ZTogc3RyaW5nID0gPHN0cmluZz5Db2xvci5jcmMyLmZpbGxTdHlsZTtcclxuXHJcbiAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKFwiI1wiKSkgeyAvLyB2YWx1ZSA9IFwiI3JyZ2diYlwiXHJcbiAgICAgICAgcmV0dXJuIF9vdXQuc2V0KFxyXG4gICAgICAgICAgcGFyc2VJbnQodmFsdWUuc2xpY2UoMSwgMyksIDE2KSAvIDI1NSxcclxuICAgICAgICAgIHBhcnNlSW50KHZhbHVlLnNsaWNlKDMsIDUpLCAxNikgLyAyNTUsXHJcbiAgICAgICAgICBwYXJzZUludCh2YWx1ZS5zbGljZSg1LCA3KSwgMTYpIC8gMjU1LFxyXG4gICAgICAgICAgX2FscGhhID8/IDFcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChcInJnYmFcIikpIHsgLy8gdmFsdWUgPSBcInJnYmEociwgZywgYiwgYSlcIlwiXHJcbiAgICAgICAgY29uc3QgaU9wZW5QYXJlbnRoZXNpczogbnVtYmVyID0gdmFsdWUuaW5kZXhPZihcIihcIik7XHJcbiAgICAgICAgY29uc3QgaUNvbW1hMDogbnVtYmVyID0gdmFsdWUuaW5kZXhPZihcIixcIiwgaU9wZW5QYXJlbnRoZXNpcyk7XHJcbiAgICAgICAgY29uc3QgaUNvbW1hMTogbnVtYmVyID0gdmFsdWUuaW5kZXhPZihcIixcIiwgaUNvbW1hMCArIDEpO1xyXG4gICAgICAgIGNvbnN0IGlDb21tYTI6IG51bWJlciA9IHZhbHVlLmluZGV4T2YoXCIsXCIsIGlDb21tYTEgKyAxKTtcclxuICAgICAgICBjb25zdCBpQ2xvc2VQYXJlbnRoZXNpczogbnVtYmVyID0gdmFsdWUuaW5kZXhPZihcIilcIiwgaU9wZW5QYXJlbnRoZXNpcyk7XHJcblxyXG4gICAgICAgIHJldHVybiBfb3V0LnNldChcclxuICAgICAgICAgIHBhcnNlRmxvYXQodmFsdWUuc2xpY2UoaU9wZW5QYXJlbnRoZXNpcyArIDEsIGlDb21tYTApKSAvIDI1NSxcclxuICAgICAgICAgIHBhcnNlRmxvYXQodmFsdWUuc2xpY2UoaUNvbW1hMCArIDIsIGlDb21tYTEpKSAvIDI1NSxcclxuICAgICAgICAgIHBhcnNlRmxvYXQodmFsdWUuc2xpY2UoaUNvbW1hMSArIDIsIGlDb21tYTIpKSAvIDI1NSxcclxuICAgICAgICAgIF9hbHBoYSA/PyBwYXJzZUZsb2F0KHZhbHVlLnNsaWNlKGlDb21tYTIgKyAyLCBpQ2xvc2VQYXJlbnRoZXNpcykpXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoXCJjb2xvcihzcmdiXCIpKSB7IC8vIHZhbHVlID0gXCJjb2xvcihzcmdiIHIgZyBiIC8gYSlcIlxyXG4gICAgICAgIGNvbnN0IGlPcGVuUGFyZW50aGVzaXM6IG51bWJlciA9IHZhbHVlLmluZGV4T2YoXCIoXCIpO1xyXG4gICAgICAgIGNvbnN0IGlTcGFjZTA6IG51bWJlciA9IHZhbHVlLmluZGV4T2YoXCIgXCIsIGlPcGVuUGFyZW50aGVzaXMpO1xyXG4gICAgICAgIGNvbnN0IGlTcGFjZTE6IG51bWJlciA9IHZhbHVlLmluZGV4T2YoXCIgXCIsIGlTcGFjZTAgKyAxKTtcclxuICAgICAgICBjb25zdCBpU3BhY2UyOiBudW1iZXIgPSB2YWx1ZS5pbmRleE9mKFwiIFwiLCBpU3BhY2UxICsgMSk7XHJcbiAgICAgICAgY29uc3QgaVNwYWNlMzogbnVtYmVyID0gdmFsdWUuaW5kZXhPZihcIiBcIiwgaVNwYWNlMiArIDEpO1xyXG4gICAgICAgIGNvbnN0IGlDbG9zZVBhcmVudGhlc2lzOiBudW1iZXIgPSB2YWx1ZS5pbmRleE9mKFwiKVwiLCBpT3BlblBhcmVudGhlc2lzKTtcclxuICAgICAgICBjb25zdCBoYXNBbHBoYTogYm9vbGVhbiA9IGlTcGFjZTMgIT0gLTE7XHJcblxyXG4gICAgICAgIHJldHVybiBfb3V0LnNldChcclxuICAgICAgICAgIHBhcnNlRmxvYXQodmFsdWUuc2xpY2UoaVNwYWNlMCArIDEsIGlTcGFjZTEpKSxcclxuICAgICAgICAgIHBhcnNlRmxvYXQodmFsdWUuc2xpY2UoaVNwYWNlMSArIDEsIGlTcGFjZTIpKSxcclxuICAgICAgICAgIHBhcnNlRmxvYXQodmFsdWUuc2xpY2UoaVNwYWNlMiArIDEsIGhhc0FscGhhID8gaVNwYWNlMyA6IGlDbG9zZVBhcmVudGhlc2lzKSksXHJcbiAgICAgICAgICBfYWxwaGEgPz8gKGhhc0FscGhhID8gcGFyc2VGbG9hdCh2YWx1ZS5zbGljZShpU3BhY2UzICsgMywgaUNsb3NlUGFyZW50aGVzaXMpKSA6IDEpXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0NvbG9yLm5hbWV9LiR7Q29sb3IuQ1NTLm5hbWV9OiBVbnJlY29nbml6ZWQgY29sb3IgZm9ybWF0OiBcIiR7X2tleXdvcmR9XCJgKTtcclxuICAgICAgLy8gQ29sb3IuY3JjMi5maWxsUmVjdCgwLCAwLCAxLCAxKTtcclxuICAgICAgLy8gbGV0IGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5ID0gQ29sb3IuY3JjMi5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YTtcclxuICAgICAgLy8gcmV0dXJuIF9vdXQuc2V0KFxyXG4gICAgICAvLyAgIGRhdGFbMF0gLyAyNTUsXHJcbiAgICAgIC8vICAgZGF0YVsxXSAvIDI1NSxcclxuICAgICAgLy8gICBkYXRhWzJdIC8gMjU1LFxyXG4gICAgICAvLyAgIF9hbHBoYSA/PyBkYXRhWzNdIC8gMjU1XHJcbiAgICAgIC8vICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgc3VtIG9mIHR3byBjb2xvcnMuXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCBjb2xvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNVTShfY2xyQTogQ29sb3IsIF9jbHJCOiBDb2xvciwgX291dDogQ29sb3IgPSBSZWN5Y2xlci5yZXVzZShDb2xvcikpOiBDb2xvciB7XHJcbiAgICAgIHJldHVybiBfb3V0LnNldChfY2xyQS5yICsgX2NsckIuciwgX2NsckEuZyArIF9jbHJCLmcsIF9jbHJBLmIgKyBfY2xyQi5iLCBfY2xyQS5hICsgX2NsckIuYSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgc3VtIG9mIHR3byBjb2xvcnMuXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCBjb2xvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERJRkZFUkVOQ0UoX2NsckE6IENvbG9yLCBfY2xyQjogQ29sb3IsIF9vdXQ6IENvbG9yID0gUmVjeWNsZXIucmV1c2UoQ29sb3IpKTogQ29sb3Ige1xyXG4gICAgICByZXR1cm4gX291dC5zZXQoTWF0aC5tYXgoMCwgX2NsckEuciAtIF9jbHJCLnIpLCBNYXRoLm1heCgwLCBfY2xyQS5nIC0gX2NsckIuZyksIE1hdGgubWF4KDAsIF9jbHJBLmIgLSBfY2xyQi5iKSwgTWF0aC5tYXgoMCwgX2NsckEuYSAtIF9jbHJCLmEpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHR3byBjb2xvcnMuXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCBjb2xvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFBST0RVQ1QoX2NsckE6IENvbG9yLCBfY2xyQjogQ29sb3IsIF9vdXQ6IENvbG9yID0gUmVjeWNsZXIucmV1c2UoQ29sb3IpKTogQ29sb3Ige1xyXG4gICAgICByZXR1cm4gX291dC5zZXQoX2NsckEuciAqIF9jbHJCLnIsIF9jbHJBLmcgKiBfY2xyQi5nLCBfY2xyQS5iICogX2NsckIuYiwgX2NsckEuYSAqIF9jbHJCLmEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBjb2xvciByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGNvbG9yIHNjYWxlZCBieSB0aGUgZ2l2ZW4gc2NhbGluZyBmYWN0b3IuXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCBjb2xvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNDQUxFKF92ZWN0b3I6IENvbG9yLCBfc2NhbGluZzogbnVtYmVyLCBfb3V0OiBDb2xvciA9IFJlY3ljbGVyLnJldXNlKENvbG9yKSk6IENvbG9yIHtcclxuICAgICAgcmV0dXJuIF9vdXQuc2V0KF92ZWN0b3IuciAqIF9zY2FsaW5nLCBfdmVjdG9yLmcgKiBfc2NhbGluZywgX3ZlY3Rvci5iICogX3NjYWxpbmcsIF92ZWN0b3IuYSAqIF9zY2FsaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgI2YoX246IG51bWJlciwgX2h1ZTogbnVtYmVyLCBfc2F0dXJhdGlvbjogbnVtYmVyLCBfbGlnaHQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIGxldCBrOiBudW1iZXIgPSAoX24gKyBfaHVlIC8gMzApICUgMTI7XHJcbiAgICAgIGxldCBhOiBudW1iZXIgPSBfc2F0dXJhdGlvbiAqIE1hdGgubWluKF9saWdodCwgMSAtIF9saWdodCk7XHJcbiAgICAgIHJldHVybiBfbGlnaHQgLSBhICogTWF0aC5tYXgoLTEsIE1hdGgubWluKGsgLSAzLCA5IC0gaywgMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGNsb25lIG9mIHRoaXMgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY2xvbmUoKTogQ29sb3Ige1xyXG4gICAgICByZXR1cm4gUmVjeWNsZXIucmV1c2UoQ29sb3IpLmNvcHkodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIHRoZSBnaXZlbiBjb2xvciBpbnRvIHRoaXMgY29sb3IgYW5kIHJldHVybnMgaXQuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29weShfY29sb3I6IENvbG9yKTogQ29sb3Ige1xyXG4gICAgICB0aGlzLnIgPSBfY29sb3IucjtcclxuICAgICAgdGhpcy5nID0gX2NvbG9yLmc7XHJcbiAgICAgIHRoaXMuYiA9IF9jb2xvci5iO1xyXG4gICAgICB0aGlzLmEgPSBfY29sb3IuYTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjb2xvciBjaGFubmVscyBvZiB0aGlzIGNvbG9yLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBjb2xvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldChfcjogbnVtYmVyLCBfZzogbnVtYmVyLCBfYjogbnVtYmVyLCBfYTogbnVtYmVyKTogQ29sb3Ige1xyXG4gICAgICB0aGlzLnIgPSBfcjsgdGhpcy5nID0gX2c7IHRoaXMuYiA9IF9iOyB0aGlzLmEgPSBfYTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnIgPSAxOyB0aGlzLmcgPSAxOyB0aGlzLmIgPSAxOyB0aGlzLmEgPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmVjdG9yIGlzIGVxdWFsIHRvIHRoZSBnaXZlbiB2ZWN0b3Igd2l0aGluIHRoZSBnaXZlbiB0b2xlcmFuY2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlcXVhbHMoX2NvbXBhcmU6IENvbG9yLCBfdG9sZXJhbmNlOiBudW1iZXIgPSBOdW1iZXIuRVBTSUxPTik6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5yIC0gX2NvbXBhcmUucikgPD0gX3RvbGVyYW5jZSAmJlxyXG4gICAgICAgIE1hdGguYWJzKHRoaXMuZyAtIF9jb21wYXJlLmcpIDw9IF90b2xlcmFuY2UgJiZcclxuICAgICAgICBNYXRoLmFicyh0aGlzLmIgLSBfY29tcGFyZS5iKSA8PSBfdG9sZXJhbmNlICYmXHJcbiAgICAgICAgTWF0aC5hYnModGhpcy5hIC0gX2NvbXBhcmUuYSkgPD0gX3RvbGVyYW5jZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhpcyBjb2xvciBmcm9tIHRoZSBnaXZlbiBjc3MgY29sb3Iga2V5d29yZC4gT3B0aW5hbGx5IHNldHMgdGhlIGFscGhhIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRDU1MoX2tleXdvcmQ6IHN0cmluZywgX2FscGhhPzogbnVtYmVyKTogQ29sb3Ige1xyXG4gICAgICByZXR1cm4gQ29sb3IuQ1NTKF9rZXl3b3JkLCBfYWxwaGEgPz8gdGhpcy5hLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIHRoaXMgY29sb3IgYW5kIGNsYW1wcyB0aGVtIGJldHdlZW4gMCBhbmQgMS5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRDbGFtcGVkKF9yOiBudW1iZXIsIF9nOiBudW1iZXIsIF9iOiBudW1iZXIsIF9hOiBudW1iZXIpOiBDb2xvciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNldChDYWxjLmNsYW1wKF9yLCAwLCAxKSwgQ2FsYy5jbGFtcChfZywgMCwgMSksIENhbGMuY2xhbXAoX2IsIDAsIDEpLCBDYWxjLmNsYW1wKF9hLCAwLCAxKSk7O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGlzIGNvbG9yIGZyb20gdGhlIGdpdmVuIGhzbCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRIU0woX2h1ZTogbnVtYmVyLCBfc2F0dXJhdGlvbjogbnVtYmVyLCBfbGlnaHRuZXNzOiBudW1iZXIsIF9hbHBoYT86IG51bWJlcik6IENvbG9yIHtcclxuICAgICAgaWYgKF9hbHBoYSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy5hID0gX2FscGhhO1xyXG5cclxuICAgICAgcmV0dXJuIENvbG9yLmhzbDJyZ2IoX2h1ZSwgX3NhdHVyYXRpb24sIF9saWdodG5lc3MsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGlzIGNvbG9yIGZyb20gdGhlIGdpdmVuIDgtYml0IHZhbHVlcyBmb3IgdGhlIGNvbG9yIGNoYW5uZWxzLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBjb2xvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldEJ5dGVzKF9yOiBudW1iZXIsIF9nOiBudW1iZXIsIF9iOiBudW1iZXIsIF9hOiBudW1iZXIpOiBDb2xvciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNldChfciAvIDI1NSwgX2cgLyAyNTUsIF9iIC8gMjU1LCBfYSAvIDI1NSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoaXMgY29sb3IgZnJvbSB0aGUgZ2l2ZW4gaGV4IHN0cmluZyBjb2xvci5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRIZXgoX2hleDogc3RyaW5nKTogQ29sb3Ige1xyXG4gICAgICBpZiAoX2hleC5zdGFydHNXaXRoKFwiI1wiKSlcclxuICAgICAgICBfaGV4ID0gX2hleC5zbGljZSgxKTtcclxuXHJcbiAgICAgIHRoaXMuciA9IHBhcnNlSW50KF9oZXguc2xpY2UoMCwgMiksIDE2KSAvIDI1NTtcclxuICAgICAgdGhpcy5nID0gcGFyc2VJbnQoX2hleC5zbGljZSgyLCA0KSwgMTYpIC8gMjU1O1xyXG4gICAgICB0aGlzLmIgPSBwYXJzZUludChfaGV4LnNsaWNlKDQsIDYpLCAxNikgLyAyNTU7XHJcblxyXG4gICAgICBpZiAoX2hleC5sZW5ndGggPj0gOClcclxuICAgICAgICB0aGlzLmEgPSBwYXJzZUludChfaGV4LnNsaWNlKDYsIDgpLCAxNikgLyAyNTU7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIHRoaXMgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQoKTogRmxvYXQzMkFycmF5IHsgLy8gVE9ETzogcmVtb3ZlIHRoaXNcclxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW3RoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3NzIGNvbG9yIGtleXdvcmQgcmVwcmVzZW50aW5nIHRoaXMgY29sb3IuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIHRvQ1NTfSBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q1NTKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRvQ1NTKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBoZXggc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29sb3IuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIHRvSGV4fSBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0SGV4KCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiBjb2xvciB0byB0aGlzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkKF9jb2xvcjogQ29sb3IpOiBDb2xvciB7XHJcbiAgICAgIHRoaXMuciArPSBfY29sb3IucjtcclxuICAgICAgdGhpcy5nICs9IF9jb2xvci5nO1xyXG4gICAgICB0aGlzLmIgKz0gX2NvbG9yLmI7XHJcbiAgICAgIHRoaXMuYSArPSBfY29sb3IuYTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiBjb2xvciB0byB0aGlzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VidHJhY3QoX2NvbG9yOiBDb2xvcik6IENvbG9yIHtcclxuICAgICAgdGhpcy5yID0gTWF0aC5tYXgoMCwgdGhpcy5yIC0gX2NvbG9yLnIpO1xyXG4gICAgICB0aGlzLmcgPSBNYXRoLm1heCgwLCB0aGlzLmcgLSBfY29sb3IuZyk7XHJcbiAgICAgIHRoaXMuYiA9IE1hdGgubWF4KDAsIHRoaXMuYiAtIF9jb2xvci5iKTtcclxuICAgICAgdGhpcy5hID0gTWF0aC5tYXgoMCwgdGhpcy5hIC0gX2NvbG9yLmEpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGxpZXMgdGhpcyB3aXRoIHRoZSBnaXZlbiBjb2xvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG11bHRpcGx5KF9jb2xvcjogQ29sb3IpOiBDb2xvciB7XHJcbiAgICAgIHRoaXMuciAqPSBfY29sb3IucjtcclxuICAgICAgdGhpcy5nICo9IF9jb2xvci5nO1xyXG4gICAgICB0aGlzLmIgKj0gX2NvbG9yLmI7XHJcbiAgICAgIHRoaXMuYSAqPSBfY29sb3IuYTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZXMgdGhpcyBjb2xvciBieSB0aGUgZ2l2ZW4gZmFjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGUoX3NjYWxpbmc6IG51bWJlcik6IENvbG9yIHtcclxuICAgICAgdGhpcy5yICo9IF9zY2FsaW5nO1xyXG4gICAgICB0aGlzLmcgKj0gX3NjYWxpbmc7XHJcbiAgICAgIHRoaXMuYiAqPSBfc2NhbGluZztcclxuICAgICAgdGhpcy5hICo9IF9zY2FsaW5nO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIGEgZGVmaW5lZCBjYWxsYmFjayBmdW5jdGlvbiBvbiBlYWNoIGNoYW5uZWwgb2YgdGhlIGNvbG9yLCBhbmQgcmV0dXJucyBhIG5ldyBjb2xvciB0aGF0IGNvbnRhaW5zIHRoZSByZXN1bHRzLiBTaW1pbGFyIHRvIHtAbGluayBBcnJheS5tYXB9LlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgY29sb3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG1hcChfZnVuY3Rpb246IChfdmFsdWU6IG51bWJlciwgX2luZGV4OiBudW1iZXIsIF9jaGFubmVsOiBcInJcIiB8IFwiZ1wiIHwgXCJiXCIgfCBcImFcIiwgX2NvbG9yOiBDb2xvcikgPT4gbnVtYmVyLCBfb3V0OiBDb2xvciA9IFJlY3ljbGVyLnJldXNlKENvbG9yKSk6IENvbG9yIHtcclxuICAgICAgX291dC5yID0gX2Z1bmN0aW9uKHRoaXMuciwgMCwgXCJyXCIsIHRoaXMpO1xyXG4gICAgICBfb3V0LmcgPSBfZnVuY3Rpb24odGhpcy5nLCAxLCBcImdcIiwgdGhpcyk7XHJcbiAgICAgIF9vdXQuYiA9IF9mdW5jdGlvbih0aGlzLmIsIDIsIFwiYlwiLCB0aGlzKTtcclxuICAgICAgX291dC5hID0gX2Z1bmN0aW9uKHRoaXMuYSwgMywgXCJhXCIsIHRoaXMpO1xyXG4gICAgICByZXR1cm4gX291dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIGEgZGVmaW5lZCBjYWxsYmFjayBmdW5jdGlvbiBvbiBlYWNoIGNoYW5uZWwgb2YgdGhlIGNvbG9yIGFuZCBhc3NpZ25zIHRoZSByZXN1bHQgdG8gdGhlIGNoYW5uZWwuIFNpbWlsYXIgdG8ge0BsaW5rIENvbG9yLm1hcH0gYnV0IG11dGF0ZXMgdGhpcyBjb2xvciBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9uZS5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhcHBseShfZnVuY3Rpb246IChfdmFsdWU6IG51bWJlciwgX2luZGV4OiBudW1iZXIsIF9jaGFubmVsOiBcInJcIiB8IFwiZ1wiIHwgXCJiXCIgfCBcImFcIiwgX2NvbG9yOiBDb2xvcikgPT4gbnVtYmVyKTogQ29sb3Ige1xyXG4gICAgICB0aGlzLnIgPSBfZnVuY3Rpb24odGhpcy5yLCAwLCBcInJcIiwgdGhpcyk7XHJcbiAgICAgIHRoaXMuZyA9IF9mdW5jdGlvbih0aGlzLmcsIDEsIFwiZ1wiLCB0aGlzKTtcclxuICAgICAgdGhpcy5iID0gX2Z1bmN0aW9uKHRoaXMuYiwgMiwgXCJiXCIsIHRoaXMpO1xyXG4gICAgICB0aGlzLmEgPSBfZnVuY3Rpb24odGhpcy5hLCAzLCBcImFcIiwgdGhpcyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29waWVzIHRoZSBjaGFubmVscyBvZiB0aGlzIGNvbG9yIGludG8gdGhlIGdpdmVuIGFycmF5IHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBvZmZzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGUgZ2l2ZW4gYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b0FycmF5PFQgZXh0ZW5kcyB7IFtuOiBudW1iZXJdOiBudW1iZXIgfT4oX291dDogVCwgX29mZnNldDogbnVtYmVyID0gMCk6IFQge1xyXG4gICAgICBfb3V0W19vZmZzZXRdID0gdGhpcy5yO1xyXG4gICAgICBfb3V0W19vZmZzZXQgKyAxXSA9IHRoaXMuZztcclxuICAgICAgX291dFtfb2Zmc2V0ICsgMl0gPSB0aGlzLmI7XHJcbiAgICAgIF9vdXRbX29mZnNldCArIDNdID0gdGhpcy5hO1xyXG5cclxuICAgICAgcmV0dXJuIF9vdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYChyOiAke3RoaXMuci50b0ZpeGVkKDMpfSwgZzogJHt0aGlzLmcudG9GaXhlZCgzKX0sIGI6ICR7dGhpcy5iLnRvRml4ZWQoMyl9LCBhOiAke3RoaXMuYS50b0ZpeGVkKDMpfSlgO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaGV4IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbG9yLiAvLyBUT0RPOiBtYXliZSB0aGlzIHNob3VsZCByZXR1cm4gYSBudW1iZXIgaW5zdGVhZCBvZiBhIHN0cmluZz9cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvSGV4KCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgJHsodGhpcy5yICogMjU1KS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpfSR7KHRoaXMuZyAqIDI1NSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKX0keyh0aGlzLmIgKiAyNTUpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIil9JHsodGhpcy5hICogMjU1KS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpfWA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjc3MgY29sb3Iga2V5d29yZCByZXByZXNlbnRpbmcgdGhpcyBjb2xvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvQ1NTKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgcmdiYSgke01hdGgucm91bmQodGhpcy5yICogMjU1KX0sICR7TWF0aC5yb3VuZCh0aGlzLmcgKiAyNTUpfSwgJHtNYXRoLnJvdW5kKHRoaXMuYiAqIDI1NSl9LCAke3RoaXMuYX0pYDtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKHRydWUpO1xyXG4gICAgICAvLyBzZXJpYWxpemF0aW9uLnRvSlNPTiA9ICgpID0+IHsgcmV0dXJuIGB7IFwiclwiOiAke3RoaXMucn0sIFwiZ1wiOiAke3RoaXMuZ30sIFwiYlwiOiAke3RoaXMuYn0sIFwiYVwiOiAke3RoaXMuYX19YDsgfTtcclxuICAgICAgc2VyaWFsaXphdGlvbi50b0pTT04gPSAoKSA9PiB7IHJldHVybiBgWyR7dGhpcy5yfSwgJHt0aGlzLmd9LCAke3RoaXMuYn0sICR7dGhpcy5hfV1gOyB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfc2VyaWFsaXphdGlvbikgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIFt0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmFdID0gSlNPTi5wYXJzZSg8c3RyaW5nPjx1bmtub3duPl9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgfSBlbHNlXHJcbiAgICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb3ZlcnJpZGUgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGlmIChfbXV0YXRvci5yICE9IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLnIgPSBfbXV0YXRvci5yO1xyXG4gICAgICBpZiAoX211dGF0b3IuZyAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy5nID0gX211dGF0b3IuZztcclxuICAgICAgaWYgKF9tdXRhdG9yLmIgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuYiA9IF9tdXRhdG9yLmI7XHJcbiAgICAgIGlmIChfbXV0YXRvci5hICE9IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLmEgPSBfbXV0YXRvci5hO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQSB7QGxpbmsgTWF0ZXJpYWx9IGxvYWRlZCBmcm9tIGEgZ2xURi1GaWxlLlxyXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNYXRlcmlhbEdMVEYgZXh0ZW5kcyBtaXhpblNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWwoTWF0ZXJpYWwpIHtcclxuICAgIHB1YmxpYyBhc3luYyBsb2FkKF91cmw6IFJlcXVlc3RJbmZvID0gdGhpcy51cmwsIF9uYW1lOiBzdHJpbmcgPSB0aGlzLm5hbWUpOiBQcm9taXNlPE1hdGVyaWFsR0xURj4ge1xyXG4gICAgICB0aGlzLnVybCA9IF91cmw7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICByZXR1cm4gR0xURkxvYWRlci5sb2FkUmVzb3VyY2UodGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQWJzdHJhY3QgY2xhc3Mgc3VwcG9ydGluZyB2YXJpb3VzIGFyaXRobWV0aWNhbCBoZWxwZXIgZnVuY3Rpb25zXHJcbiAgICovXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIENhbGMge1xyXG4gICAgLyoqIGZhY3RvciBtdWx0aXBsaWVkIHdpdGggYW5nbGUgaW4gZGVncmVlcyB5aWVsZHMgdGhlIGFuZ2xlIGluIHJhZGlhbiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBkZWcycmFkOiBudW1iZXIgPSBNYXRoLlBJIC8gMTgwO1xyXG4gICAgLyoqIGZhY3RvciBtdWx0aXBsaWVkIHdpdGggYW5nbGUgaW4gcmFkaWFuIHlpZWxkcyB0aGUgYW5nbGUgaW4gZGVncmVlcyAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSByYWQyZGVnOiBudW1iZXIgPSAxIC8gQ2FsYy5kZWcycmFkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBvbmUgb2YgdGhlIHZhbHVlcyBwYXNzZWQgaW4sIGVpdGhlciBfdmFsdWUgaWYgd2l0aGluIF9taW4gYW5kIF9tYXggb3IgdGhlIGJvdW5kYXJ5IGJlaW5nIGV4Y2VlZGVkIGJ5IF92YWx1ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGFtcDxUPihfdmFsdWU6IFQsIF9taW46IFQsIF9tYXg6IFQsIF9pc1NtYWxsZXI6IChfdmFsdWUxOiBULCBfdmFsdWUyOiBUKSA9PiBib29sZWFuID0gQ2FsYy5pc1NtYWxsZXI8VD4pOiBUIHtcclxuICAgICAgaWYgKF9pc1NtYWxsZXIoX3ZhbHVlLCBfbWluKSkgcmV0dXJuIF9taW47XHJcbiAgICAgIGlmIChfaXNTbWFsbGVyKF9tYXgsIF92YWx1ZSkpIHJldHVybiBfbWF4O1xyXG4gICAgICByZXR1cm4gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmFsdWVzLiBXaGVuIHQgaXMgMCB0aGUgcmVzdWx0IGlzIGEsIHdoZW4gdCBpcyAxIHRoZSByZXN1bHQgaXMgYi4gQ2xhbXBzIHQgYmV0d2VlbiAwIGFuZCAxLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGxlcnAoX2E6IG51bWJlciwgX2I6IG51bWJlciwgX3Q6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiBfYSArIENhbGMuY2xhbXAoX3QsIDAsIDEpICogKF9iIC0gX2EpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUm91bmRzIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgbmVhcmVzdCBtdWx0aXBsZSBvZiB0aGUgZ2l2ZW4gaW5jcmVtZW50IHVzaW5nIHRoZSBnaXZlbiByb3VuZGluZyBmdW5jdGlvbi4gXHJcbiAgICAgKiBEZWZhdWx0IHJvdW5kaW5nIGZ1bmN0aW9uIGlzIHtAbGluayBNYXRoLnJvdW5kfSwgdXNlIHtAbGluayBNYXRoLmZsb29yfSBvciB7QGxpbmsgTWF0aC5jZWlsfSB0byByb3VuZCBkb3duIG9yIHVwLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNuYXAoX3ZhbHVlOiBudW1iZXIsIF9pbmNyZW1lbnQ6IG51bWJlciwgX3JvdW5kOiAoX3ZhbHVlOiBudW1iZXIpID0+IG51bWJlciA9IE1hdGgucm91bmQpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gX3JvdW5kKF92YWx1ZSAvIF9pbmNyZW1lbnQpICogX2luY3JlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBpc1NtYWxsZXI8VD4oX3ZhbHVlMTogVCwgX3ZhbHVlMjogVCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gX3ZhbHVlMSA8IF92YWx1ZTI7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBCb3JkZXIge1xyXG4gICAgbGVmdDogbnVtYmVyO1xyXG4gICAgdG9wOiBudW1iZXI7XHJcbiAgICByaWdodDogbnVtYmVyO1xyXG4gICAgYm90dG9tOiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGcmFtaW5nIGRlc2NyaWJlcyBob3cgdG8gbWFwIGEgcmVjdGFuZ2xlIGludG8gYSBnaXZlbiBmcmFtZVxyXG4gICAqIGFuZCBob3cgcG9pbnRzIGluIHRoZSBmcmFtZSBjb3JyZXNwb25kIHRvIHBvaW50cyBpbiB0aGUgcmVzdWx0aW5nIHJlY3RhbmdsZSBhbmQgdmljZSB2ZXJzYVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5ICBcclxuICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vaHMtZnVydHdhbmdlbi9GVURHRS93aWtpL0ZyYW1pbmdcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgRnJhbWluZyBleHRlbmRzIE11dGFibGUge1xyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhIHBvaW50IGluIHRoZSBnaXZlbiBmcmFtZSBhY2NvcmRpbmcgdG8gdGhpcyBmcmFtaW5nXHJcbiAgICAgKiBAcGFyYW0gX3BvaW50SW5GcmFtZSBUaGUgcG9pbnQgaW4gdGhlIGZyYW1lIGdpdmVuXHJcbiAgICAgKiBAcGFyYW0gX3JlY3RGcmFtZSBUaGUgZnJhbWUgdGhlIHBvaW50IGlzIHJlbGF0aXZlIHRvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRQb2ludChfcG9pbnRJbkZyYW1lOiBWZWN0b3IyLCBfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBWZWN0b3IyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhIHBvaW50IGluIGEgZ2l2ZW4gcmVjdGFuZ2xlIGJhY2sgdG8gYSBjYWxjdWxhdGVkIGZyYW1lIG9mIG9yaWdpblxyXG4gICAgICogQHBhcmFtIF9wb2ludCBUaGUgcG9pbnQgaW4gdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIF9yZWN0IFRoZSByZWN0YW5nbGUgdGhlIHBvaW50IGlzIHJlbGF0aXZlIHRvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRQb2ludEludmVyc2UoX3BvaW50OiBWZWN0b3IyLCBfcmVjdDogUmVjdGFuZ2xlKTogVmVjdG9yMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGEgcmVjdGFuZ2xlIGFzIHRoZSBmcmFtZSBhbmQgY3JlYXRlcyBhIG5ldyByZWN0YW5nbGUgYWNjb3JkaW5nIHRvIHRoZSBmcmFtaW5nXHJcbiAgICAgKiBAcGFyYW0gX3JlY3RGcmFtZVxyXG4gICAgICogQHBhcmFtIF9yZWN0T3V0IE9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0UmVjdChfcmVjdEZyYW1lOiBSZWN0YW5nbGUsIF9yZWN0T3V0PzogUmVjdGFuZ2xlKTogUmVjdGFuZ2xlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHJlc3VsdGluZyByZWN0YW5nbGUgaGFzIGEgZml4ZWQgd2lkdGggYW5kIGhlaWdodCBhbmQgZGlzcGxheSBzaG91bGQgc2NhbGUgdG8gZml0IHRoZSBmcmFtZVxyXG4gICAqIFBvaW50cyBhcmUgc2NhbGVkIGluIHRoZSBzYW1lIHJhdGlvXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEZyYW1pbmdGaXhlZCBleHRlbmRzIEZyYW1pbmcge1xyXG4gICAgcHVibGljIHdpZHRoOiBudW1iZXIgPSAzMDA7XHJcbiAgICBwdWJsaWMgaGVpZ2h0OiBudW1iZXIgPSAxNTA7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF93aWR0aDogbnVtYmVyID0gMzAwLCBfaGVpZ2h0OiBudW1iZXIgPSAxNTApIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zZXRTaXplKF93aWR0aCwgX2hlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoaXMgZnJhbWluZyB0byB0aGUgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U2l6ZShfd2lkdGg6IG51bWJlciwgX2hlaWdodDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMud2lkdGggPSBfd2lkdGg7XHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gX2hlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UG9pbnQoX3BvaW50SW5GcmFtZTogVmVjdG9yMiwgX3JlY3RGcmFtZTogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICB0aGlzLndpZHRoICogKF9wb2ludEluRnJhbWUueCAtIF9yZWN0RnJhbWUueCkgLyBfcmVjdEZyYW1lLndpZHRoLFxyXG4gICAgICAgIHRoaXMuaGVpZ2h0ICogKF9wb2ludEluRnJhbWUueSAtIF9yZWN0RnJhbWUueSkgLyBfcmVjdEZyYW1lLmhlaWdodFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQb2ludEludmVyc2UoX3BvaW50OiBWZWN0b3IyLCBfcmVjdDogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICBfcG9pbnQueCAqIF9yZWN0LndpZHRoIC8gdGhpcy53aWR0aCArIF9yZWN0LngsXHJcbiAgICAgICAgX3BvaW50LnkgKiBfcmVjdC5oZWlnaHQgLyB0aGlzLmhlaWdodCArIF9yZWN0LnlcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UmVjdChfcmVjdEZyYW1lOiBSZWN0YW5nbGUsIF9yZWN0T3V0OiBSZWN0YW5nbGUgPSBSZWN5Y2xlci5yZXVzZShSZWN0YW5nbGUpKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHVuZGVmaW5lZCwgX3JlY3RPdXQpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSByZXN1bHRpbmcgcmVjdGFuZ2xlIGFyZSBmcmFjdGlvbnMgb2YgdGhvc2Ugb2YgdGhlIGZyYW1lLCBzY2FsZWQgYnkgbm9ybWVkIHZhbHVlcyBub3JtV2lkdGggYW5kIG5vcm1IZWlnaHQuXHJcbiAgICogRGlzcGxheSBzaG91bGQgc2NhbGUgdG8gZml0IHRoZSBmcmFtZSBhbmQgcG9pbnRzIGFyZSBzY2FsZWQgaW4gdGhlIHNhbWUgcmF0aW9cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRnJhbWluZ1NjYWxlZCBleHRlbmRzIEZyYW1pbmcge1xyXG4gICAgcHVibGljIG5vcm1XaWR0aDogbnVtYmVyID0gMS4wO1xyXG4gICAgcHVibGljIG5vcm1IZWlnaHQ6IG51bWJlciA9IDEuMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhpcyBmcmFtaW5nIHRvIHRoZSBnaXZlbiBub3JtZWQgd2lkdGggYW5kIGhlaWdodFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U2NhbGUoX25vcm1XaWR0aDogbnVtYmVyLCBfbm9ybUhlaWdodDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIHRoaXMubm9ybVdpZHRoID0gX25vcm1XaWR0aDtcclxuICAgICAgdGhpcy5ub3JtSGVpZ2h0ID0gX25vcm1IZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFBvaW50KF9wb2ludEluRnJhbWU6IFZlY3RvcjIsIF9yZWN0RnJhbWU6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgdGhpcy5ub3JtV2lkdGggKiAoX3BvaW50SW5GcmFtZS54IC0gX3JlY3RGcmFtZS54KSxcclxuICAgICAgICB0aGlzLm5vcm1IZWlnaHQgKiAoX3BvaW50SW5GcmFtZS55IC0gX3JlY3RGcmFtZS55KVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRQb2ludEludmVyc2UoX3BvaW50OiBWZWN0b3IyLCBfcmVjdDogUmVjdGFuZ2xlKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICBfcG9pbnQueCAvIHRoaXMubm9ybVdpZHRoICsgX3JlY3QueCxcclxuICAgICAgICBfcG9pbnQueSAvIHRoaXMubm9ybUhlaWdodCArIF9yZWN0LnlcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UmVjdChfcmVjdEZyYW1lOiBSZWN0YW5nbGUsIF9yZWN0T3V0OiBSZWN0YW5nbGUgPSBSZWN5Y2xlci5yZXVzZShSZWN0YW5nbGUpKTogUmVjdGFuZ2xlIHtcclxuICAgICAgcmV0dXJuIFJlY3RhbmdsZS5HRVQoMCwgMCwgdGhpcy5ub3JtV2lkdGggKiBfcmVjdEZyYW1lLndpZHRoLCB0aGlzLm5vcm1IZWlnaHQgKiBfcmVjdEZyYW1lLmhlaWdodCwgdW5kZWZpbmVkLCBfcmVjdE91dCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgcmVzdWx0aW5nIHJlY3RhbmdsZSBmaXRzIGludG8gYSBtYXJnaW4gZ2l2ZW4gYXMgZnJhY3Rpb25zIG9mIHRoZSBzaXplIG9mIHRoZSBmcmFtZSBnaXZlbiBieSBub3JtQW5jaG9yXHJcbiAgICogcGx1cyBhbiBhYnNvbHV0ZSBwYWRkaW5nIGdpdmVuIGJ5IHBpeGVsQm9yZGVyLiBEaXNwbGF5IHNob3VsZCBmaXQgaW50byB0aGlzLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBGcmFtaW5nQ29tcGxleCBleHRlbmRzIEZyYW1pbmcge1xyXG4gICAgcHVibGljIG1hcmdpbjogQm9yZGVyID0geyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAgfTtcclxuICAgIHB1YmxpYyBwYWRkaW5nOiBCb3JkZXIgPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXRQb2ludChfcG9pbnRJbkZyYW1lOiBWZWN0b3IyLCBfcmVjdEZyYW1lOiBSZWN0YW5nbGUpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHJlc3VsdDogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgIF9wb2ludEluRnJhbWUueCAtIHRoaXMucGFkZGluZy5sZWZ0IC0gdGhpcy5tYXJnaW4ubGVmdCAqIF9yZWN0RnJhbWUud2lkdGgsXHJcbiAgICAgICAgX3BvaW50SW5GcmFtZS55IC0gdGhpcy5wYWRkaW5nLnRvcCAtIHRoaXMubWFyZ2luLnRvcCAqIF9yZWN0RnJhbWUuaGVpZ2h0XHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0UG9pbnRJbnZlcnNlKF9wb2ludDogVmVjdG9yMiwgX3JlY3Q6IFJlY3RhbmdsZSk6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgX3BvaW50LnggKyB0aGlzLnBhZGRpbmcubGVmdCArIHRoaXMubWFyZ2luLmxlZnQgKiBfcmVjdC53aWR0aCxcclxuICAgICAgICBfcG9pbnQueSArIHRoaXMucGFkZGluZy50b3AgKyB0aGlzLm1hcmdpbi50b3AgKiBfcmVjdC5oZWlnaHRcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UmVjdChfcmVjdEZyYW1lOiBSZWN0YW5nbGUsIF9yZWN0T3V0OiBSZWN0YW5nbGUgPSBSZWN5Y2xlci5yZXVzZShSZWN0YW5nbGUpKTogUmVjdGFuZ2xlIHtcclxuICAgICAgaWYgKCFfcmVjdEZyYW1lKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgbGV0IG1pblg6IG51bWJlciA9IF9yZWN0RnJhbWUueCArIHRoaXMubWFyZ2luLmxlZnQgKiBfcmVjdEZyYW1lLndpZHRoICsgdGhpcy5wYWRkaW5nLmxlZnQ7XHJcbiAgICAgIGxldCBtaW5ZOiBudW1iZXIgPSBfcmVjdEZyYW1lLnkgKyB0aGlzLm1hcmdpbi50b3AgKiBfcmVjdEZyYW1lLmhlaWdodCArIHRoaXMucGFkZGluZy50b3A7XHJcbiAgICAgIGxldCBtYXhYOiBudW1iZXIgPSBfcmVjdEZyYW1lLnggKyAoMSAtIHRoaXMubWFyZ2luLnJpZ2h0KSAqIF9yZWN0RnJhbWUud2lkdGggLSB0aGlzLnBhZGRpbmcucmlnaHQ7XHJcbiAgICAgIGxldCBtYXhZOiBudW1iZXIgPSBfcmVjdEZyYW1lLnkgKyAoMSAtIHRoaXMubWFyZ2luLmJvdHRvbSkgKiBfcmVjdEZyYW1lLmhlaWdodCAtIHRoaXMucGFkZGluZy5ib3R0b207XHJcblxyXG4gICAgICByZXR1cm4gUmVjdGFuZ2xlLkdFVChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblksIHVuZGVmaW5lZCwgX3JlY3RPdXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICByZXR1cm4geyBtYXJnaW46IHRoaXMubWFyZ2luLCBwYWRkaW5nOiB0aGlzLnBhZGRpbmcgfTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBSZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvcjIgYXMgcG9sYXIgY29vcmRpbmF0ZXMgXHJcbiAgICogYGBgdGV4dFxyXG4gICAqICDihpUtIGFuZ2xlIChBbmdsZSB0byB0aGUgeC1heGlzKVxyXG4gICAqICAt4oaSIE1hZ25pdHVkZSAoRGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyKSAgXHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEdlbzIgaW1wbGVtZW50cyBSZWN5Y2FibGUge1xyXG4gICAgcHVibGljIG1hZ25pdHVkZTogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBhbmdsZTogbnVtYmVyID0gMDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2FuZ2xlOiBudW1iZXIgPSAwLCBfbWFnbml0dWRlOiBudW1iZXIgPSAxKSB7XHJcbiAgICAgIHRoaXMuc2V0KF9hbmdsZSwgX21hZ25pdHVkZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHByb3BlcnRpZXMgb2YgdGhpcyBpbnN0YW5jZSBhdCBvbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX2FuZ2xlOiBudW1iZXIgPSAwLCBfbWFnbml0dWRlOiBudW1iZXIgPSAxKTogR2VvMiB7XHJcbiAgICAgIHRoaXMubWFnbml0dWRlID0gX21hZ25pdHVkZTtcclxuICAgICAgdGhpcy5hbmdsZSA9IF9hbmdsZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcHJldHR5IHN0cmluZyByZXByZXNlbnRhdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGBhbmdsZTogJHt0aGlzLmFuZ2xlLnRvUHJlY2lzaW9uKDUpfSwgIG1hZ25pdHVkZTogJHt0aGlzLm1hZ25pdHVkZS50b1ByZWNpc2lvbig1KX1gO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yMyBhcyBnZW9ncmFwaGljIGNvb3JkaW5hdGVzIGFzIHNlZW4gb24gYSBnbG9iZVxyXG4gICAqIGBgYHRleHRcclxuICAgKiDihpB84oaSIExvbmdpdHVkZSAoQW5nbGUgdG8gdGhlIHotYXhpcykgXHJcbiAgICogIOKGlS0gTGF0aXR1ZGUgKEFuZ2xlIHRvIHRoZSBlcXVhdG9yKVxyXG4gICAqICAt4oaSIE1hZ25pdHVkZSAoRGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyKSAgXHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEdlbzMgaW1wbGVtZW50cyBSZWN5Y2FibGUge1xyXG4gICAgcHVibGljIG1hZ25pdHVkZTogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBsYXRpdHVkZTogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBsb25naXR1ZGU6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9sb25naXR1ZGU6IG51bWJlciA9IDAsIF9sYXRpdHVkZTogbnVtYmVyID0gMCwgX21hZ25pdHVkZTogbnVtYmVyID0gMSkge1xyXG4gICAgICB0aGlzLnNldChfbG9uZ2l0dWRlLCBfbGF0aXR1ZGUsIF9tYWduaXR1ZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgaW5zdGFuY2UgYXQgb25jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF9sb25naXR1ZGU6IG51bWJlciA9IDAsIF9sYXRpdHVkZTogbnVtYmVyID0gMCwgX21hZ25pdHVkZTogbnVtYmVyID0gMSk6IEdlbzMge1xyXG4gICAgICB0aGlzLm1hZ25pdHVkZSA9IF9tYWduaXR1ZGU7XHJcbiAgICAgIHRoaXMubGF0aXR1ZGUgPSBfbGF0aXR1ZGU7XHJcbiAgICAgIHRoaXMubG9uZ2l0dWRlID0gX2xvbmdpdHVkZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcHJldHR5IHN0cmluZyByZXByZXNlbnRhdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGBsb25naXR1ZGU6ICR7dGhpcy5sb25naXR1ZGUudG9QcmVjaXNpb24oNSl9LCBsYXRpdHVkZTogJHt0aGlzLmxhdGl0dWRlLnRvUHJlY2lzaW9uKDUpfSwgbWFnbml0dWRlOiAke3RoaXMubWFnbml0dWRlLnRvUHJlY2lzaW9uKDUpfWA7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLy8gRnJvbSBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXHJcbiAgLy8gSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5jb20+LCAyMDEwXHJcbiAgZXhwb3J0IGZ1bmN0aW9uIE1hc2goKTogRnVuY3Rpb24ge1xyXG4gICAgbGV0IG46IG51bWJlciA9IDB4ZWZjODI0OWQ7XHJcblxyXG4gICAgbGV0IG1hc2g6IEZ1bmN0aW9uID0gZnVuY3Rpb24gKF9kYXRhOiBzdHJpbmcgfCBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICBfZGF0YSA9IF9kYXRhLnRvU3RyaW5nKCk7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBfZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG4gKz0gX2RhdGEuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBsZXQgaDogbnVtYmVyID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XHJcbiAgICAgICAgbiA9IGggPj4+IDA7XHJcbiAgICAgICAgaCAtPSBuO1xyXG4gICAgICAgIGggKj0gbjtcclxuICAgICAgICBuID0gaCA+Pj4gMDtcclxuICAgICAgICBoIC09IG47XHJcbiAgICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7IC8vIDJeMzJcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcclxuICAgIH07XHJcblxyXG4gICAgLy8gbWFzaC52ZXJzaW9uID0gJ01hc2ggMC45JztcclxuICAgIHJldHVybiBtYXNoO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEZyb20gaHR0cDovL2JhYWdvZS5jb20vZW4vUmFuZG9tTXVzaW5ncy9qYXZhc2NyaXB0L1xyXG4gIGV4cG9ydCBmdW5jdGlvbiBMRklCNCgpOiBGdW5jdGlvbiB7XHJcbiAgICAvLyBHZW9yZ2UgTWFyc2FnbGlhJ3MgTEZJQjQsXHJcbiAgICAvL2h0dHA6Ly9ncm91cHMuZ29vZ2xlLmNvbS9ncm91cC9zY2kuY3J5cHQvbXNnL2ViNGRkZGU3ODJiMTcwNTFcclxuICAgIGxldCBhcmdzOiBudW1iZXJbXSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICBsZXQgazA6IG51bWJlciA9IDAsXHJcbiAgICAgIGsxOiBudW1iZXIgPSA1OCxcclxuICAgICAgazI6IG51bWJlciA9IDExOSxcclxuICAgICAgazM6IG51bWJlciA9IDE3ODtcclxuXHJcbiAgICBsZXQgczogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICBsZXQgbWFzaDogRnVuY3Rpb24gPSBNYXNoKCk7XHJcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgYXJncyA9IFsrbmV3IERhdGUoKV07XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgMjU2OyBqKyspIHtcclxuICAgICAgc1tqXSA9IG1hc2goXCIgXCIpO1xyXG4gICAgICBzW2pdIC09IG1hc2goXCIgXCIpICogNC43NjgzNzE1ODIwMzEyNWUtNzsgLy8gMl4tMjFcclxuICAgICAgaWYgKHNbal0gPCAwKSB7XHJcbiAgICAgICAgc1tqXSArPSAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgMjU2OyBqKyspIHtcclxuICAgICAgICBzW2pdIC09IG1hc2goYXJnc1tpXSk7XHJcbiAgICAgICAgc1tqXSAtPSBtYXNoKGFyZ3NbaV0pICogNC43NjgzNzE1ODIwMzEyNWUtNzsgLy8gMl4tMjFcclxuICAgICAgICBpZiAoc1tqXSA8IDApIHtcclxuICAgICAgICAgIHNbal0gKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG1hc2ggPSBudWxsO1xyXG5cclxuICAgIGxldCByYW5kb206IEZ1bmN0aW9uID0gZnVuY3Rpb24gKCk6IG51bWJlciB7XHJcbiAgICAgIGxldCB4OiBudW1iZXI7XHJcblxyXG4gICAgICBrMCA9IChrMCArIDEpICYgMjU1O1xyXG4gICAgICBrMSA9IChrMSArIDEpICYgMjU1O1xyXG4gICAgICBrMiA9IChrMiArIDEpICYgMjU1O1xyXG4gICAgICBrMyA9IChrMyArIDEpICYgMjU1O1xyXG5cclxuICAgICAgeCA9IHNbazBdIC0gc1trMV07XHJcbiAgICAgIGlmICh4IDwgMCkge1xyXG4gICAgICAgIHggKz0gMTtcclxuICAgICAgfVxyXG4gICAgICB4IC09IHNbazJdO1xyXG4gICAgICBpZiAoeCA8IDApIHtcclxuICAgICAgICB4ICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgeCAtPSBzW2szXTtcclxuICAgICAgaWYgKHggPCAwKSB7XHJcbiAgICAgICAgeCArPSAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc1trMF0gPSB4O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyByYW5kb20udWludDMyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gICByZXR1cm4gcmFuZG9tKCkgKiAweDEwMDAwMDAwMCA+Pj4gMDsgLy8gMl4zMlxyXG4gICAgLy8gfTtcclxuICAgIC8vIHJhbmRvbS5mcmFjdDUzID0gcmFuZG9tO1xyXG4gICAgLy8gcmFuZG9tLnZlcnNpb24gPSBcIkxGSUI0IDAuOVwiO1xyXG4gICAgLy8gcmFuZG9tLmFyZ3MgPSBhcmdzO1xyXG5cclxuICAgIHJldHVybiByYW5kb207XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogU2ltcGxlIGNsYXNzIGZvciAzeDMgbWF0cml4IG9wZXJhdGlvbnNcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIwIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDI1XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1hdHJpeDN4MyBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUsIFJlY3ljYWJsZSB7XHJcbiAgICBwcml2YXRlIGRhdGE6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7IC8vIFRoZSBkYXRhIG9mIHRoZSBtYXRyaXguXHJcbiAgICBwcml2YXRlIG11dGF0b3I6IE11dGF0b3IgPSBudWxsOyAvLyBwcmVwYXJlZCBmb3Igb3B0aW1pemF0aW9uLCBrZWVwIG11dGF0b3IgdG8gcmVkdWNlIHJlZHVuZGFudCBjYWxjdWxhdGlvbiBhbmQgZm9yIGNvbXBhcmlzb24uIFNldCB0byBudWxsIHdoZW4gZGF0YSBjaGFuZ2VzIVxyXG5cclxuICAgIHJlYWRvbmx5ICN0cmFuc2xhdGlvbjogVmVjdG9yMiA9IFZlY3RvcjIuWkVSTygpO1xyXG4gICAgcmVhZG9ubHkgI3NjYWxpbmc6IFZlY3RvcjIgPSBWZWN0b3IyLk9ORSgpO1xyXG4gICAgI3JvdGF0aW9uOiBudW1iZXIgPSAwO1xyXG5cclxuICAgICN0cmFuc2xhdGlvbkRpcnR5OiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAjcm90YXRpb25EaXJ0eTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgI3NjYWxpbmdEaXJ0eTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5yZWN5Y2xlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vVE9ETzogZmlndXJlIG91dCB3aGF0IHRoaXMgaXMgdXNlZCBmb3JcclxuICAgIC8qKiBUT0RPOiBkZXNjcmliZSEgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUFJPSkVDVElPTihfd2lkdGg6IG51bWJlciwgX2hlaWdodDogbnVtYmVyLCBfbXR4T3V0OiBNYXRyaXgzeDMgPSBSZWN5Y2xlci5yZXVzZShNYXRyaXgzeDMpKTogTWF0cml4M3gzIHtcclxuICAgICAgcmV0dXJuIF9tdHhPdXQuc2V0KFxyXG4gICAgICAgIDIgLyBfd2lkdGgsIDAsIDAsXHJcbiAgICAgICAgMCwgLTIgLyBfaGVpZ2h0LCAwLFxyXG4gICAgICAgIC0xLCAxLCAxXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBhIG5ldyBpZGVudGl0eSBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgSURFTlRJVFkoKTogTWF0cml4M3gzIHtcclxuICAgICAgcmV0dXJuIFJlY3ljbGVyLmdldChNYXRyaXgzeDMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcG9zZXMgYSBuZXcgbWF0cml4IGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gdHJhbnNsYXRpb24sIHJvdGF0aW9uIGFuZCBzY2FsaW5nLlxyXG4gICAgICogQHBhcmFtIF9tdHhPdXQgT3B0aW9uYWwgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQ09NUE9TSVRJT04oX3RyYW5zbGF0aW9uPzogVmVjdG9yMiwgX3JvdGF0aW9uPzogbnVtYmVyLCBfc2NhbGluZz86IFZlY3RvcjIsIF9tdHhPdXQ6IE1hdHJpeDN4MyA9IFJlY3ljbGVyLmdldChNYXRyaXgzeDMpKTogTWF0cml4M3gzIHtcclxuICAgICAgcmV0dXJuIF9tdHhPdXQuY29tcG9zZShfdHJhbnNsYXRpb24sIF9yb3RhdGlvbiwgX3NjYWxpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHRyYW5zbGF0ZXMgY29vcmRpbmF0ZXMgYWxvbmcgdGhlIHgtIGFuZCB5LWF4aXMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB7QGxpbmsgVmVjdG9yMn0uXHJcbiAgICAgKiBAcGFyYW0gX210eE91dCBPcHRpb25hbCBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUUkFOU0xBVElPTihfdHJhbnNsYXRlOiBWZWN0b3IyLCBfbXR4T3V0OiBNYXRyaXgzeDMgPSBSZWN5Y2xlci5yZXVzZShNYXRyaXgzeDMpKTogTWF0cml4M3gzIHtcclxuICAgICAgcmV0dXJuIF9tdHhPdXQuc2V0KFxyXG4gICAgICAgIDEsIDAsIDAsXHJcbiAgICAgICAgMCwgMSwgMCxcclxuICAgICAgICBfdHJhbnNsYXRlLngsIF90cmFuc2xhdGUueSwgMVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgb24gdGhlIHotYXhpcyB3aGVuIG11bHRpcGxpZWQgYnkuXHJcbiAgICAgKiBAcGFyYW0gX2FuZ2xlSW5EZWdyZWVzIFRoZSB2YWx1ZSBvZiB0aGUgcm90YXRpb24uXHJcbiAgICAgKiBAcGFyYW0gX210eE91dCBPcHRpb25hbCBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTihfYW5nbGVJbkRlZ3JlZXM6IG51bWJlciwgX210eE91dDogTWF0cml4M3gzID0gUmVjeWNsZXIucmV1c2UoTWF0cml4M3gzKSk6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGxldCBhbmdsZUluUmFkaWFuczogbnVtYmVyID0gX2FuZ2xlSW5EZWdyZWVzICogQ2FsYy5kZWcycmFkO1xyXG4gICAgICBsZXQgc2luOiBudW1iZXIgPSBNYXRoLnNpbihhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIGxldCBjb3M6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgcmV0dXJuIF9tdHhPdXQuc2V0KFxyXG4gICAgICAgIGNvcywgc2luLCAwLFxyXG4gICAgICAgIC1zaW4sIGNvcywgMCxcclxuICAgICAgICAwLCAwLCAxXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgc2NhbGVzIGNvb3JkaW5hdGVzIGFsb25nIHRoZSB4LSBhbmQgeS1heGlzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjJ9LlxyXG4gICAgICogQHBhcmFtIF9tdHhPdXQgT3B0aW9uYWwgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0NBTElORyhfc2NhbGFyOiBWZWN0b3IyLCBfbXR4T3V0OiBNYXRyaXgzeDMgPSBSZWN5Y2xlci5yZXVzZShNYXRyaXgzeDMpKTogTWF0cml4M3gzIHtcclxuICAgICAgcmV0dXJuIF9tdHhPdXQuc2V0KFxyXG4gICAgICAgIF9zY2FsYXIueCwgMCwgMCxcclxuICAgICAgICAwLCBfc2NhbGFyLnksIDAsXHJcbiAgICAgICAgMCwgMCwgMVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0d28gcGFzc2VkIG1hdHJpY2VzLlxyXG4gICAgICogQHBhcmFtIF9tdHhPdXQgT3B0aW9uYWwgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUFJPRFVDVChfbXR4TGVmdDogTWF0cml4M3gzLCBfbXR4UmlnaHQ6IE1hdHJpeDN4MywgX210eE91dDogTWF0cml4M3gzID0gUmVjeWNsZXIucmV1c2UoTWF0cml4M3gzKSk6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IGxlZnQ6IEZsb2F0MzJBcnJheSA9IF9tdHhMZWZ0LmRhdGE7XHJcbiAgICAgIGNvbnN0IHJpZ2h0OiBGbG9hdDMyQXJyYXkgPSBfbXR4UmlnaHQuZGF0YTtcclxuXHJcbiAgICAgIGNvbnN0IGEwMDogbnVtYmVyID0gbGVmdFswXSwgYTAxOiBudW1iZXIgPSBsZWZ0WzFdLCBhMDI6IG51bWJlciA9IGxlZnRbMl07XHJcbiAgICAgIGNvbnN0IGExMDogbnVtYmVyID0gbGVmdFszXSwgYTExOiBudW1iZXIgPSBsZWZ0WzRdLCBhMTI6IG51bWJlciA9IGxlZnRbNV07XHJcbiAgICAgIGNvbnN0IGEyMDogbnVtYmVyID0gbGVmdFs2XSwgYTIxOiBudW1iZXIgPSBsZWZ0WzddLCBhMjI6IG51bWJlciA9IGxlZnRbOF07XHJcblxyXG4gICAgICBjb25zdCBiMDA6IG51bWJlciA9IHJpZ2h0WzBdLCBiMDE6IG51bWJlciA9IHJpZ2h0WzFdLCBiMDI6IG51bWJlciA9IHJpZ2h0WzJdO1xyXG4gICAgICBjb25zdCBiMTA6IG51bWJlciA9IHJpZ2h0WzNdLCBiMTE6IG51bWJlciA9IHJpZ2h0WzRdLCBiMTI6IG51bWJlciA9IHJpZ2h0WzVdO1xyXG4gICAgICBjb25zdCBiMjA6IG51bWJlciA9IHJpZ2h0WzZdLCBiMjE6IG51bWJlciA9IHJpZ2h0WzddLCBiMjI6IG51bWJlciA9IHJpZ2h0WzhdO1xyXG5cclxuICAgICAgcmV0dXJuIF9tdHhPdXQuc2V0KFxyXG4gICAgICAgIGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMCxcclxuICAgICAgICBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjEsXHJcbiAgICAgICAgYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyLFxyXG4gICAgICAgIGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMCxcclxuICAgICAgICBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjEsXHJcbiAgICAgICAgYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyLFxyXG4gICAgICAgIGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMCxcclxuICAgICAgICBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjEsXHJcbiAgICAgICAgYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgaW52ZXJzZSBvZiBhIHBhc3NlZCBtYXRyaXguXHJcbiAgICAgKiBAcGFyYW0gX210eCBUaGUgbWF0cml4IHRvIGNvbXB1dGUgdGhlIGludmVyc2Ugb2YuXHJcbiAgICAgKiBAcGFyYW0gX210eE91dCBPcHRpb25hbCBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBJTlZFUlNFKF9tdHg6IE1hdHJpeDN4MywgX210eE91dDogTWF0cml4M3gzID0gUmVjeWNsZXIucmV1c2UoTWF0cml4M3gzKSk6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IG06IEZsb2F0MzJBcnJheSA9IF9tdHguZGF0YTtcclxuICAgICAgY29uc3QgbTAwOiBudW1iZXIgPSBtWzBdLCBtMDE6IG51bWJlciA9IG1bMV0sIG0wMjogbnVtYmVyID0gbVsyXTtcclxuICAgICAgY29uc3QgbTEwOiBudW1iZXIgPSBtWzNdLCBtMTE6IG51bWJlciA9IG1bNF0sIG0xMjogbnVtYmVyID0gbVs1XTtcclxuICAgICAgY29uc3QgbTIwOiBudW1iZXIgPSBtWzZdLCBtMjE6IG51bWJlciA9IG1bN10sIG0yMjogbnVtYmVyID0gbVs4XTtcclxuXHJcbiAgICAgIGxldCBkOiBudW1iZXIgPSAxIC9cclxuICAgICAgICAobTAwICogKG0xMSAqIG0yMiAtIG0yMSAqIG0xMikgLVxyXG4gICAgICAgICAgbTAxICogKG0xMCAqIG0yMiAtIG0xMiAqIG0yMCkgK1xyXG4gICAgICAgICAgbTAyICogKG0xMCAqIG0yMSAtIG0xMSAqIG0yMCkpO1xyXG5cclxuICAgICAgcmV0dXJuIF9tdHhPdXQuc2V0KFxyXG4gICAgICAgIGQgKiAobTExICogbTIyIC0gbTIxICogbTEyKSxcclxuICAgICAgICBkICogKG0wMiAqIG0yMSAtIG0wMSAqIG0yMiksXHJcbiAgICAgICAgZCAqIChtMDEgKiBtMTIgLSBtMDIgKiBtMTEpLFxyXG4gICAgICAgIGQgKiAobTEyICogbTIwIC0gbTEwICogbTIyKSxcclxuICAgICAgICBkICogKG0wMCAqIG0yMiAtIG0wMiAqIG0yMCksXHJcbiAgICAgICAgZCAqIChtMTAgKiBtMDIgLSBtMDAgKiBtMTIpLFxyXG4gICAgICAgIGQgKiAobTEwICogbTIxIC0gbTIwICogbTExKSxcclxuICAgICAgICBkICogKG0yMCAqIG0wMSAtIG0wMCAqIG0yMSksXHJcbiAgICAgICAgZCAqIChtMDAgKiBtMTEgLSBtMTAgKiBtMDEpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IHJldHVybiBhIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJhbnNsYXRpb24ge0BsaW5rIFZlY3RvcjJ9LiAgXHJcbiAgICAgKiAqKkNhdXRpb24hKiogVXNlIGltbWVkaWF0ZWx5IGFuZCByZWFkb25seSwgc2luY2UgdGhlIHZlY3RvciBpcyBnb2luZyB0byBiZSByZXVzZWQgaW50ZXJuYWxseS4gQ3JlYXRlIGEgY2xvbmUgdG8ga2VlcCBsb25nZXIgYW5kIG1hbmlwdWxhdGUuIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4IGlnbm9yaW5nIGl0cyByb3RhdGlvbiBhbmQgc2NhbGluZ1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHRyYW5zbGF0aW9uKCk6IFZlY3RvcjIge1xyXG4gICAgICBpZiAodGhpcy4jdHJhbnNsYXRpb25EaXJ0eSkge1xyXG4gICAgICAgIHRoaXMuI3RyYW5zbGF0aW9uRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLiN0cmFuc2xhdGlvbi5zZXQodGhpcy5kYXRhWzZdLCB0aGlzLmRhdGFbN10pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLiN0cmFuc2xhdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgdHJhbnNsYXRpb24oX3RyYW5zbGF0aW9uOiBWZWN0b3IyKSB7XHJcbiAgICAgIHRoaXMuY29tcG9zZShfdHJhbnNsYXRpb24sIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiAtIGdldDogYSBjb3B5IG9mIHRoZSBjYWxjdWxhdGVkIHJvdGF0aW9uIHtAbGluayBWZWN0b3IyfSAgIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcm90YXRpb24oKTogbnVtYmVyIHtcclxuICAgICAgaWYgKHRoaXMuI3JvdGF0aW9uRGlydHkpIHtcclxuICAgICAgICBsZXQgc2NhbGluZzogVmVjdG9yMiA9IHRoaXMuc2NhbGluZztcclxuXHJcbiAgICAgICAgbGV0IHMwOiBudW1iZXIgPSB0aGlzLmRhdGFbMF0gLyBzY2FsaW5nLng7XHJcbiAgICAgICAgbGV0IHMxOiBudW1iZXIgPSB0aGlzLmRhdGFbMV0gLyBzY2FsaW5nLng7XHJcbiAgICAgICAgbGV0IHMzOiBudW1iZXIgPSB0aGlzLmRhdGFbM10gLyBzY2FsaW5nLnk7XHJcbiAgICAgICAgbGV0IHM0OiBudW1iZXIgPSB0aGlzLmRhdGFbNF0gLyBzY2FsaW5nLnk7XHJcblxyXG4gICAgICAgIGxldCB4U2tldzogbnVtYmVyID0gTWF0aC5hdGFuMigtczMsIHM0KTtcclxuICAgICAgICBsZXQgeVNrZXc6IG51bWJlciA9IE1hdGguYXRhbjIoczAsIHMxKTtcclxuXHJcbiAgICAgICAgbGV0IHN5OiBudW1iZXIgPSBNYXRoLnNxcnQoczAgKiBzMCArIHMxICogczEpOyAvLyBwcm9iYWJseSAyLiBwYXJhbSBzaG91bGQgYmUgdGhpcy5kYXRhWzRdIC8gc2NhbGluZy55XHJcbiAgICAgICAgbGV0IHJvdGF0aW9uOiBudW1iZXI7XHJcblxyXG4gICAgICAgIGlmICghKHN5ID4gMWUtNikpXHJcbiAgICAgICAgICByb3RhdGlvbiA9IHlTa2V3O1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHJvdGF0aW9uID0geFNrZXc7XHJcblxyXG4gICAgICAgIHJvdGF0aW9uICo9IENhbGMucmFkMmRlZztcclxuXHJcbiAgICAgICAgdGhpcy4jcm90YXRpb24gPSByb3RhdGlvbjtcclxuICAgICAgICB0aGlzLiNyb3RhdGlvbkRpcnR5ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuI3JvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCByb3RhdGlvbihfcm90YXRpb246IG51bWJlcikge1xyXG4gICAgICB0aGlzLmNvbXBvc2UodW5kZWZpbmVkLCBfcm90YXRpb24sIHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogLSBnZXQ6IHJldHVybiBhIHZlY3RvciByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2NhbGUge0BsaW5rIFZlY3RvcjN9LiAgXHJcbiAgICAgKiAqKkNhdXRpb24hKiogRG8gbm90IG1hbmlwdWxhdGUgcmVzdWx0LCBpbnN0ZWFkIGNyZWF0ZSBhIGNsb25lISAgICBcclxuICAgICAqIC0gc2V0OiBlZmZlY3QgdGhlIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNjYWxpbmcoKTogVmVjdG9yMiB7XHJcbiAgICAgIGlmICh0aGlzLiNzY2FsaW5nRGlydHkpIHtcclxuICAgICAgICB0aGlzLiNzY2FsaW5nLnNldChcclxuICAgICAgICAgIE1hdGguc3FydCh0aGlzLmRhdGFbMF0gKiB0aGlzLmRhdGFbMF0gKyB0aGlzLmRhdGFbMV0gKiB0aGlzLmRhdGFbMV0pICogKHRoaXMuZGF0YVswXSA8IDAgPyAtMSA6IDEpLFxyXG4gICAgICAgICAgTWF0aC5zcXJ0KHRoaXMuZGF0YVszXSAqIHRoaXMuZGF0YVszXSArIHRoaXMuZGF0YVs0XSAqIHRoaXMuZGF0YVs0XSkgKiAodGhpcy5kYXRhWzRdIDwgMCA/IC0xIDogMSlcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuI3NjYWxpbmdEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLiNzY2FsaW5nO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzY2FsaW5nKF9zY2FsaW5nOiBWZWN0b3IyKSB7XHJcbiAgICAgIHRoaXMuY29tcG9zZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgX3NjYWxpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGNsb25lIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNsb25lKCk6IE1hdHJpeDN4MyB7XHJcbiAgICAgIHJldHVybiBSZWN5Y2xlci5yZXVzZShNYXRyaXgzeDMpLmNvcHkodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIG1hdHJpeCB0byB0aGUgaWRlbnRpdHktbWF0cml4IGFuZCBjbGVhcnMgY2FjaGUuIFVzZWQgYnkgdGhlIHJlY3ljbGVyIHRvIHJlc2V0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXQoXHJcbiAgICAgICAgMSwgMCwgMCxcclxuICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgIDAsIDAsIDFcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgbWF0cml4IHRvIHRoZSBpZGVudGl0eS1tYXRyaXggYW5kIGNsZWFycyBjYWNoZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnJlY3ljbGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNsYXRpb25cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHRyYW5zbGF0aW9uIGJ5IHRoZSBnaXZlbiB7QGxpbmsgVmVjdG9yMn0gdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZShfYnk6IFZlY3RvcjIpOiBNYXRyaXgzeDMge1xyXG4gICAgICBjb25zdCBtdHhUcmFuc2xhdGlvbjogTWF0cml4M3gzID0gTWF0cml4M3gzLlRSQU5TTEFUSU9OKF9ieSk7XHJcbiAgICAgIE1hdHJpeDN4My5QUk9EVUNUKHRoaXMsIG10eFRyYW5zbGF0aW9uLCB0aGlzKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4VHJhbnNsYXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeC1heGlzIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVYKF9ieTogbnVtYmVyKTogTWF0cml4M3gzIHtcclxuICAgICAgY29uc3QgdHJhbnNsYXRpb246IFZlY3RvcjIgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IyKS5zZXQoX2J5LCAwKTtcclxuICAgICAgdGhpcy50cmFuc2xhdGUodHJhbnNsYXRpb24pO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh0cmFuc2xhdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHRyYW5zbGF0aW9uIGFsb25nIHRoZSB5LWF4aXMgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRyYW5zbGF0ZVkoX2J5OiBudW1iZXIpOiBNYXRyaXgzeDMge1xyXG4gICAgICBjb25zdCB0cmFuc2xhdGlvbjogVmVjdG9yMiA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjIpLnNldCgwLCBfYnkpO1xyXG4gICAgICB0aGlzLnRyYW5zbGF0ZSh0cmFuc2xhdGlvbik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHRyYW5zbGF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gUm90YXRpb25cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgei1BeGlzIHRvIHRoaXMgbWF0cml4XHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJvdGF0ZShfYW5nbGVJbkRlZ3JlZXM6IG51bWJlcik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IG10eFJvdGF0aW9uOiBNYXRyaXgzeDMgPSBNYXRyaXgzeDMuUk9UQVRJT04oX2FuZ2xlSW5EZWdyZWVzKTtcclxuICAgICAgTWF0cml4M3gzLlBST0RVQ1QodGhpcywgbXR4Um90YXRpb24sIHRoaXMpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSb3RhdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNjYWxpbmdcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHNjYWxpbmcgYnkgdGhlIGdpdmVuIHtAbGluayBWZWN0b3IyfSB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGUoX2J5OiBWZWN0b3IyKTogTWF0cml4M3gzIHtcclxuICAgICAgY29uc3QgbXR4U2NhbGluZzogTWF0cml4M3gzID0gTWF0cml4M3gzLlNDQUxJTkcoX2J5KTtcclxuICAgICAgTWF0cml4M3gzLlBST0RVQ1QodGhpcywgbXR4U2NhbGluZywgdGhpcyk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFNjYWxpbmcpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzY2FsaW5nIGFsb25nIHRoZSB4LUF4aXMgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlWChfYnk6IG51bWJlcik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IHNjYWxpbmc6IFZlY3RvcjIgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IyKS5zZXQoX2J5LCAxKTtcclxuICAgICAgdGhpcy5zY2FsZShzY2FsaW5nKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoc2NhbGluZyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHNjYWxpbmcgYWxvbmcgdGhlIHktQXhpcyB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGVZKF9ieTogbnVtYmVyKTogTWF0cml4M3gzIHtcclxuICAgICAgY29uc3Qgc2NhbGluZzogVmVjdG9yMiA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjIpLnNldCgxLCBfYnkpO1xyXG4gICAgICB0aGlzLnNjYWxlKHNjYWxpbmcpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShzY2FsaW5nKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmb3JtYXRpb25cclxuICAgIC8qKlxyXG4gICAgICogTXVsdGlwbHkgdGhpcyBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gbWF0cml4LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtdWx0aXBseShfbXR4UmlnaHQ6IE1hdHJpeDN4Myk6IE1hdHJpeDN4MyB7XHJcbiAgICAgIHJldHVybiBNYXRyaXgzeDMuUFJPRFVDVCh0aGlzLCBfbXR4UmlnaHQsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJlbXVsdGlwbHkgdGhpcyBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gbWF0cml4LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwcmVtdWx0aXBseShfbXR4TGVmdDogTWF0cml4M3gzKTogTWF0cml4M3gzIHtcclxuICAgICAgcmV0dXJuIE1hdHJpeDN4My5QUk9EVUNUKF9tdHhMZWZ0LCB0aGlzLCB0aGlzKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgLyoqXHJcbiAgICAgKiAoUmUtKUNvbXBvc2UgdGhpcyBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gdHJhbnNsYXRpb24sIHJvdGF0aW9uIGFuZCBzY2FsaW5nLiBcclxuICAgICAqIE1pc3NpbmcgdmFsdWVzIHdpbGwgYmUgZGVjb21wc2VkIGZyb20gdGhlIGN1cnJlbnQgbWF0cml4IHN0YXRlIGlmIG5lY2Vzc2FyeS5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29tcG9zZShfdHJhbnNsYXRpb24/OiBQYXJ0aWFsPFZlY3RvcjI+LCBfcm90YXRpb24/OiBudW1iZXIsIF9zY2FsaW5nPzogUGFydGlhbDxWZWN0b3IyPik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IG06IEZsb2F0MzJBcnJheSA9IHRoaXMuZGF0YTtcclxuXHJcbiAgICAgIGlmIChfdHJhbnNsYXRpb24pIHtcclxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbjogVmVjdG9yMiA9IHRoaXMudHJhbnNsYXRpb247XHJcbiAgICAgICAgdHJhbnNsYXRpb24ubXV0YXRlKF90cmFuc2xhdGlvbik7XHJcbiAgICAgICAgbVs2XSA9IHRyYW5zbGF0aW9uLng7XHJcbiAgICAgICAgbVs3XSA9IHRyYW5zbGF0aW9uLnk7XHJcbiAgICAgICAgdGhpcy4jdHJhbnNsYXRpb25EaXJ0eSA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoX3JvdGF0aW9uIHx8IF9zY2FsaW5nKSB7XHJcbiAgICAgICAgY29uc3Qgcm90YXRpb246IG51bWJlciA9IF9yb3RhdGlvbiA/PyB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICAgIGlmIChfcm90YXRpb24gIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgdGhpcy4jcm90YXRpb24gPSByb3RhdGlvbjtcclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGluZzogVmVjdG9yMiA9IHRoaXMuc2NhbGluZztcclxuICAgICAgICBpZiAoX3NjYWxpbmcpXHJcbiAgICAgICAgICBzY2FsaW5nLm11dGF0ZShfc2NhbGluZyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGFuZ2xlSW5SYWRpYW5zOiBudW1iZXIgPSByb3RhdGlvbiAqIENhbGMuZGVnMnJhZDtcclxuICAgICAgICBjb25zdCBzaW46IG51bWJlciA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgICBjb25zdCBjb3M6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcclxuXHJcbiAgICAgICAgbVswXSA9IGNvcyAqIHNjYWxpbmcueDtcclxuICAgICAgICBtWzFdID0gc2luICogc2NhbGluZy54O1xyXG5cclxuICAgICAgICBtWzNdID0gLXNpbiAqIHNjYWxpbmcueTtcclxuICAgICAgICBtWzRdID0gY29zICogc2NhbGluZy55O1xyXG5cclxuICAgICAgICB0aGlzLiNyb3RhdGlvbkRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy4jc2NhbGluZ0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IHRvIHRoZSBnaXZlbiBhcnJheSBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRBcnJheShfYXJyYXk6IEFycmF5TGlrZTxudW1iZXI+LCBfb2Zmc2V0OiBudW1iZXIgPSAwKTogTWF0cml4M3gzIHtcclxuICAgICAgdGhpcy5kYXRhLnNldChfYXJyYXksIF9vZmZzZXQpO1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBlbGVtZW50cyBvZiB0aGlzIG1hdHJpeCB0byB0aGUgZ2l2ZW4gdmFsdWVzLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX20wMDogbnVtYmVyLCBfbTAxOiBudW1iZXIsIF9tMDI6IG51bWJlciwgX20xMDogbnVtYmVyLCBfbTExOiBudW1iZXIsIF9tMTI6IG51bWJlciwgX20yMDogbnVtYmVyLCBfbTIxOiBudW1iZXIsIF9tMjI6IG51bWJlcik6IE1hdHJpeDN4MyB7XHJcbiAgICAgIGNvbnN0IG06IEZsb2F0MzJBcnJheSA9IHRoaXMuZGF0YTtcclxuXHJcbiAgICAgIG1bMF0gPSBfbTAwOyBtWzFdID0gX20wMTsgbVsyXSA9IF9tMDI7XHJcbiAgICAgIG1bM10gPSBfbTEwOyBtWzRdID0gX20xMTsgbVs1XSA9IF9tMTI7XHJcbiAgICAgIG1bNl0gPSBfbTIwOyBtWzddID0gX20yMTsgbVs4XSA9IF9tMjI7XHJcblxyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBtYXRyaXggaW50byB0aGlzIG1hdHJpeC5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29weShfb3JpZ2luYWw6IE1hdHJpeDN4Myk6IE1hdHJpeDN4MyB7XHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoX29yaWdpbmFsLmRhdGEpO1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgICB0aGlzLiN0cmFuc2xhdGlvbkRpcnR5ID0gX29yaWdpbmFsLiN0cmFuc2xhdGlvbkRpcnR5O1xyXG4gICAgICB0aGlzLiNyb3RhdGlvbkRpcnR5ID0gX29yaWdpbmFsLiNyb3RhdGlvbkRpcnR5O1xyXG4gICAgICB0aGlzLiNzY2FsaW5nRGlydHkgPSBfb3JpZ2luYWwuI3NjYWxpbmdEaXJ0eTtcclxuICAgICAgaWYgKCF0aGlzLiN0cmFuc2xhdGlvbkRpcnR5KVxyXG4gICAgICAgIHRoaXMuI3RyYW5zbGF0aW9uLmNvcHkoX29yaWdpbmFsLiN0cmFuc2xhdGlvbik7XHJcbiAgICAgIGlmICghdGhpcy4jcm90YXRpb25EaXJ0eSlcclxuICAgICAgICB0aGlzLiNyb3RhdGlvbiA9IF9vcmlnaW5hbC4jcm90YXRpb247XHJcbiAgICAgIGlmICghdGhpcy4jc2NhbGluZ0RpcnR5KVxyXG4gICAgICAgIHRoaXMuI3NjYWxpbmcuY29weShfb3JpZ2luYWwuI3NjYWxpbmcpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBmb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYMaSLk1hdHJpeDN4Myh0cmFuc2xhdGlvbjogJHt0aGlzLnRyYW5zbGF0aW9uLnRvU3RyaW5nKCl9LCByb3RhdGlvbjogJHt0aGlzLnJvdGF0aW9uLnRvU3RyaW5nKCl9LCBzY2FsaW5nOiAke3RoaXMuc2NhbGluZy50b1N0cmluZygpfWA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5cyB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggaW50byB0aGUgZ2l2ZW4gYXJyYXkgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIG9mZnNldC5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoZSBnaXZlbiBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvQXJyYXk8VCBleHRlbmRzIHsgW246IG51bWJlcl06IG51bWJlciB9Pihfb3V0OiBULCBfb2Zmc2V0OiBudW1iZXIgPSAwKTogVCB7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCA5OyBpKyspXHJcbiAgICAgICAgX291dFtfb2Zmc2V0ICsgaV0gPSB0aGlzLmRhdGFbaV07XHJcblxyXG4gICAgICByZXR1cm4gX291dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGFycmF5IG9mIHRoZSBlbGVtZW50cyBvZiB0aGlzIG1hdHJpeC5cclxuICAgICAqIEByZXR1cm5zIEEgcmVhZG9ubHkgdmlldyBvZiB0aGUgaW50ZXJuYWwgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRBcnJheSgpOiBBcnJheUxpa2U8bnVtYmVyPiAmIEl0ZXJhYmxlPG51bWJlcj4gJiBBcnJheUJ1ZmZlclZpZXcge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIC8vIHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICB0cmFuc2xhdGlvbjogdGhpcy50cmFuc2xhdGlvbi5zZXJpYWxpemUoKSxcclxuICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcclxuICAgICAgICBzY2FsaW5nOiB0aGlzLnNjYWxpbmcuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICB0cmFuc2xhdGlvbjogYXdhaXQgdGhpcy50cmFuc2xhdGlvbi5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi50cmFuc2xhdGlvbiksXHJcbiAgICAgICAgcm90YXRpb246IF9zZXJpYWxpemF0aW9uLnJvdGF0aW9uLFxyXG4gICAgICAgIHNjYWxpbmc6IGF3YWl0IHRoaXMuc2NhbGluZy5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5zY2FsaW5nKVxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLm11dGF0ZShtdXRhdG9yKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGlmICh0aGlzLm11dGF0b3IpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0YXRvcjtcclxuXHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHRyYW5zbGF0aW9uOiB0aGlzLnRyYW5zbGF0aW9uLmdldE11dGF0b3IoKSxcclxuICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcclxuICAgICAgICBzY2FsaW5nOiB0aGlzLnNjYWxpbmcuZ2V0TXV0YXRvcigpXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBjYWNoZSBtdXRhdG9yXHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG11dGF0b3I7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9wdGltaXplZCBtdXRhdGUgbWV0aG9kIHRvIGRpcmVjdGx5IHVwZGF0ZSBtYXRyaXggdmFsdWVzXHJcbiAgICBwdWJsaWMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuY29tcG9zZShfbXV0YXRvci50cmFuc2xhdGlvbiwgX211dGF0b3Iucm90YXRpb24sIF9tdXRhdG9yLnNjYWxpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yQXR0cmlidXRlVHlwZXMoX211dGF0b3I6IE11dGF0b3IpOiBNdXRhdG9yQXR0cmlidXRlVHlwZXMge1xyXG4gICAgICBsZXQgdHlwZXM6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyA9IHt9O1xyXG4gICAgICBpZiAoX211dGF0b3IudHJhbnNsYXRpb24pIHR5cGVzLnRyYW5zbGF0aW9uID0gXCJWZWN0b3IyXCI7XHJcbiAgICAgIGlmIChfbXV0YXRvci5yb3RhdGlvbiAhPSB1bmRlZmluZWQpIHR5cGVzLnJvdGF0aW9uID0gXCJudW1iZXJcIjtcclxuICAgICAgaWYgKF9tdXRhdG9yLnNjYWxpbmcpIHR5cGVzLnNjYWxpbmcgPSBcIlZlY3RvcjJcIjtcclxuICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHsvKiogKi8gfVxyXG5cclxuICAgIHByaXZhdGUgcmVzZXRDYWNoZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jdHJhbnNsYXRpb25EaXJ0eSA9IHRydWU7XHJcbiAgICAgIHRoaXMuI3JvdGF0aW9uRGlydHkgPSB0cnVlO1xyXG4gICAgICB0aGlzLiNzY2FsaW5nRGlydHkgPSB0cnVlO1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyNlbmRyZWdpb25cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFN0b3JlcyBhIDR4NCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggYW5kIHByb3ZpZGVzIG9wZXJhdGlvbnMgZm9yIGl0LlxyXG4gICAqIGBgYHRleHRcclxuICAgKiBbIDAsIDEsIDIsIDMgXSDihpAgcm93IHZlY3RvciB4XHJcbiAgICogWyA0LCA1LCA2LCA3IF0g4oaQIHJvdyB2ZWN0b3IgeVxyXG4gICAqIFsgOCwgOSwxMCwxMSBdIOKGkCByb3cgdmVjdG9yIHpcclxuICAgKiBbMTIsMTMsMTQsMTUgXSDihpAgdHJhbnNsYXRpb25cclxuICAgKiAgICAgICAgICAgIOKGkSAgaG9tb2dlbmVvdXMgY29sdW1uXHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmFzY2hhIEthcmFnw7ZsLCBIRlUsIDIwMTkgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOSB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyMy0yMDI1XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1hdHJpeDR4NCBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUsIFJlY3ljYWJsZSB7XHJcbiAgICAvKiogQGludGVybmFsIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgbWF0cml4IHdhcyBtb2RpZmllZCBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHtAbGluayBSZW5kZXIucHJlcGFyZX0uICovXHJcbiAgICBwdWJsaWMgbW9kaWZpZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgcHJpdmF0ZSBkYXRhOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTsgLy8gVGhlIGRhdGEgb2YgdGhlIG1hdHJpeC5cclxuICAgIHByaXZhdGUgbXV0YXRvcjogTXV0YXRvciA9IG51bGw7IC8vIHByZXBhcmVkIGZvciBvcHRpbWl6YXRpb24sIGtlZXAgbXV0YXRvciB0byByZWR1Y2UgcmVkdW5kYW50IGNhbGN1bGF0aW9uIGFuZCBmb3IgY29tcGFyaXNvbi4gU2V0IHRvIG51bGwgd2hlbiBkYXRhIGNoYW5nZXMhXHJcblxyXG4gICAgcmVhZG9ubHkgI3RyYW5zbGF0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7XHJcbiAgICByZWFkb25seSAjc2NhbGluZzogVmVjdG9yMyA9IFZlY3RvcjMuWkVSTygpO1xyXG4gICAgcmVhZG9ubHkgI3JvdGF0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5PTkUoKTtcclxuICAgIHJlYWRvbmx5ICNxdWF0ZXJuaW9uOiBRdWF0ZXJuaW9uID0gUXVhdGVybmlvbi5JREVOVElUWSgpO1xyXG5cclxuICAgICN0cmFuc2xhdGlvbkRpcnR5OiBib29sZWFuO1xyXG4gICAgI3NjYWxpbmdEaXJ0eTogYm9vbGVhbjtcclxuICAgICNyb3RhdGlvbkRpcnR5OiBib29sZWFuO1xyXG4gICAgI3F1YXRlcm5pb25EaXJ0eTogYm9vbGVhbjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2RhdGE/OiBGbG9hdDMyQXJyYXkpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgaWYgKCFfZGF0YSkge1xyXG4gICAgICAgIHRoaXMucmVjeWNsZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5kYXRhID0gX2RhdGE7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBTVEFUSUNTXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIGEgbmV3IGlkZW50aXR5IG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIElERU5USVRZKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBvc2VzIGEgbmV3IG1hdHJpeCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHRyYW5zbGF0aW9uLCByb3RhdGlvbiBhbmQgc2NhbGluZy5cclxuICAgICAqIEBwYXJhbSBfbXR4T3V0IE9wdGlvbmFsIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENPTVBPU0lUSU9OKF90cmFuc2xhdGlvbj86IFZlY3RvcjMsIF9yb3RhdGlvbj86IFZlY3RvcjMgfCBRdWF0ZXJuaW9uLCBfc2NhbGluZz86IFZlY3RvcjMsIF9tdHhPdXQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLmdldChNYXRyaXg0eDQpKTogTWF0cml4NHg0IHtcclxuICAgICAgcmV0dXJuIF9tdHhPdXQuY29tcG9zZShfdHJhbnNsYXRpb24sIF9yb3RhdGlvbiwgX3NjYWxpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdHdvIHBhc3NlZCBtYXRyaWNlcy5cclxuICAgICAqIEBwYXJhbSBfbXR4T3V0IE9wdGlvbmFsIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFBST0RVQ1QoX210eExlZnQ6IE1hdHJpeDR4NCwgX210eFJpZ2h0OiBNYXRyaXg0eDQsIF9tdHhPdXQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDR4NCkpOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBsZWZ0OiBGbG9hdDMyQXJyYXkgPSBfbXR4TGVmdC5kYXRhO1xyXG4gICAgICBjb25zdCByaWdodDogRmxvYXQzMkFycmF5ID0gX210eFJpZ2h0LmRhdGE7XHJcbiAgICAgIGNvbnN0IG91dDogRmxvYXQzMkFycmF5ID0gX210eE91dC5kYXRhO1xyXG5cclxuICAgICAgY29uc3QgYTAwOiBudW1iZXIgPSBsZWZ0WzBdLCBhMDE6IG51bWJlciA9IGxlZnRbMV0sIGEwMjogbnVtYmVyID0gbGVmdFsyXSwgYTAzOiBudW1iZXIgPSBsZWZ0WzNdO1xyXG4gICAgICBjb25zdCBhMTA6IG51bWJlciA9IGxlZnRbNF0sIGExMTogbnVtYmVyID0gbGVmdFs1XSwgYTEyOiBudW1iZXIgPSBsZWZ0WzZdLCBhMTM6IG51bWJlciA9IGxlZnRbN107XHJcbiAgICAgIGNvbnN0IGEyMDogbnVtYmVyID0gbGVmdFs4XSwgYTIxOiBudW1iZXIgPSBsZWZ0WzldLCBhMjI6IG51bWJlciA9IGxlZnRbMTBdLCBhMjM6IG51bWJlciA9IGxlZnRbMTFdO1xyXG4gICAgICBjb25zdCBhMzA6IG51bWJlciA9IGxlZnRbMTJdLCBhMzE6IG51bWJlciA9IGxlZnRbMTNdLCBhMzI6IG51bWJlciA9IGxlZnRbMTRdLCBhMzM6IG51bWJlciA9IGxlZnRbMTVdO1xyXG5cclxuICAgICAgY29uc3QgYjAwOiBudW1iZXIgPSByaWdodFswXSwgYjAxOiBudW1iZXIgPSByaWdodFsxXSwgYjAyOiBudW1iZXIgPSByaWdodFsyXSwgYjAzOiBudW1iZXIgPSByaWdodFszXTtcclxuICAgICAgY29uc3QgYjEwOiBudW1iZXIgPSByaWdodFs0XSwgYjExOiBudW1iZXIgPSByaWdodFs1XSwgYjEyOiBudW1iZXIgPSByaWdodFs2XSwgYjEzOiBudW1iZXIgPSByaWdodFs3XTtcclxuICAgICAgY29uc3QgYjIwOiBudW1iZXIgPSByaWdodFs4XSwgYjIxOiBudW1iZXIgPSByaWdodFs5XSwgYjIyOiBudW1iZXIgPSByaWdodFsxMF0sIGIyMzogbnVtYmVyID0gcmlnaHRbMTFdO1xyXG4gICAgICBjb25zdCBiMzA6IG51bWJlciA9IHJpZ2h0WzEyXSwgYjMxOiBudW1iZXIgPSByaWdodFsxM10sIGIzMjogbnVtYmVyID0gcmlnaHRbMTRdLCBiMzM6IG51bWJlciA9IHJpZ2h0WzE1XTtcclxuXHJcbiAgICAgIG91dFswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMCArIGIwMyAqIGEzMDtcclxuICAgICAgb3V0WzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxICsgYjAzICogYTMxO1xyXG4gICAgICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjIgKyBiMDMgKiBhMzI7XHJcbiAgICAgIG91dFszXSA9IGIwMCAqIGEwMyArIGIwMSAqIGExMyArIGIwMiAqIGEyMyArIGIwMyAqIGEzMztcclxuICAgICAgb3V0WzRdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwICsgYjEzICogYTMwO1xyXG4gICAgICBvdXRbNV0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjEgKyBiMTMgKiBhMzE7XHJcbiAgICAgIG91dFs2XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMiArIGIxMyAqIGEzMjtcclxuICAgICAgb3V0WzddID0gYjEwICogYTAzICsgYjExICogYTEzICsgYjEyICogYTIzICsgYjEzICogYTMzO1xyXG4gICAgICBvdXRbOF0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjAgKyBiMjMgKiBhMzA7XHJcbiAgICAgIG91dFs5XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMSArIGIyMyAqIGEzMTtcclxuICAgICAgb3V0WzEwXSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMiArIGIyMyAqIGEzMjtcclxuICAgICAgb3V0WzExXSA9IGIyMCAqIGEwMyArIGIyMSAqIGExMyArIGIyMiAqIGEyMyArIGIyMyAqIGEzMztcclxuICAgICAgb3V0WzEyXSA9IGIzMCAqIGEwMCArIGIzMSAqIGExMCArIGIzMiAqIGEyMCArIGIzMyAqIGEzMDtcclxuICAgICAgb3V0WzEzXSA9IGIzMCAqIGEwMSArIGIzMSAqIGExMSArIGIzMiAqIGEyMSArIGIzMyAqIGEzMTtcclxuICAgICAgb3V0WzE0XSA9IGIzMCAqIGEwMiArIGIzMSAqIGExMiArIGIzMiAqIGEyMiArIGIzMyAqIGEzMjtcclxuICAgICAgb3V0WzE1XSA9IGIzMCAqIGEwMyArIGIzMSAqIGExMyArIGIzMiAqIGEyMyArIGIzMyAqIGEzMztcclxuXHJcbiAgICAgIF9tdHhPdXQucmVzZXRDYWNoZSgpO1xyXG5cclxuICAgICAgcmV0dXJuIF9tdHhPdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgdHJhbnNwb3NlIG9mIGEgcGFzc2VkIG1hdHJpeC5cclxuICAgICAqIEBwYXJhbSBfbXR4T3V0IE9wdGlvbmFsIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRSQU5TUE9TRShfbXR4OiBNYXRyaXg0eDQsIF9tdHhPdXQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDR4NCkpOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBtOiBGbG9hdDMyQXJyYXkgPSBfbXR4LmRhdGE7XHJcbiAgICAgIHJldHVybiBfbXR4T3V0LnNldChcclxuICAgICAgICBtWzBdLCBtWzRdLCBtWzhdLCBtWzEyXSxcclxuICAgICAgICBtWzFdLCBtWzVdLCBtWzldLCBtWzEzXSxcclxuICAgICAgICBtWzJdLCBtWzZdLCBtWzEwXSwgbVsxNF0sXHJcbiAgICAgICAgbVszXSwgbVs3XSwgbVsxMV0sIG1bMTVdXHJcbiAgICAgICk7O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIGludmVyc2Ugb2YgYSBwYXNzZWQgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIF9tdHhPdXQgT3B0aW9uYWwgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgSU5WRVJTRShfbXR4OiBNYXRyaXg0eDQsIF9tdHhPdXQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDR4NCkpOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBtOiBGbG9hdDMyQXJyYXkgPSBfbXR4LmRhdGE7XHJcbiAgICAgIGNvbnN0IG0wMDogbnVtYmVyID0gbVswXSwgbTAxOiBudW1iZXIgPSBtWzFdLCBtMDI6IG51bWJlciA9IG1bMl0sIG0wMzogbnVtYmVyID0gbVszXTtcclxuICAgICAgY29uc3QgbTEwOiBudW1iZXIgPSBtWzRdLCBtMTE6IG51bWJlciA9IG1bNV0sIG0xMjogbnVtYmVyID0gbVs2XSwgbTEzOiBudW1iZXIgPSBtWzddO1xyXG4gICAgICBjb25zdCBtMjA6IG51bWJlciA9IG1bOF0sIG0yMTogbnVtYmVyID0gbVs5XSwgbTIyOiBudW1iZXIgPSBtWzEwXSwgbTIzOiBudW1iZXIgPSBtWzExXTtcclxuICAgICAgY29uc3QgbTMwOiBudW1iZXIgPSBtWzEyXSwgbTMxOiBudW1iZXIgPSBtWzEzXSwgbTMyOiBudW1iZXIgPSBtWzE0XSwgbTMzOiBudW1iZXIgPSBtWzE1XTtcclxuICAgICAgY29uc3QgdG1wMDogbnVtYmVyID0gbTIyICogbTMzO1xyXG4gICAgICBjb25zdCB0bXAxOiBudW1iZXIgPSBtMzIgKiBtMjM7XHJcbiAgICAgIGNvbnN0IHRtcDI6IG51bWJlciA9IG0xMiAqIG0zMztcclxuICAgICAgY29uc3QgdG1wMzogbnVtYmVyID0gbTMyICogbTEzO1xyXG4gICAgICBjb25zdCB0bXA0OiBudW1iZXIgPSBtMTIgKiBtMjM7XHJcbiAgICAgIGNvbnN0IHRtcDU6IG51bWJlciA9IG0yMiAqIG0xMztcclxuICAgICAgY29uc3QgdG1wNjogbnVtYmVyID0gbTAyICogbTMzO1xyXG4gICAgICBjb25zdCB0bXA3OiBudW1iZXIgPSBtMzIgKiBtMDM7XHJcbiAgICAgIGNvbnN0IHRtcDg6IG51bWJlciA9IG0wMiAqIG0yMztcclxuICAgICAgY29uc3QgdG1wOTogbnVtYmVyID0gbTIyICogbTAzO1xyXG4gICAgICBjb25zdCB0bXAxMDogbnVtYmVyID0gbTAyICogbTEzO1xyXG4gICAgICBjb25zdCB0bXAxMTogbnVtYmVyID0gbTEyICogbTAzO1xyXG4gICAgICBjb25zdCB0bXAxMjogbnVtYmVyID0gbTIwICogbTMxO1xyXG4gICAgICBjb25zdCB0bXAxMzogbnVtYmVyID0gbTMwICogbTIxO1xyXG4gICAgICBjb25zdCB0bXAxNDogbnVtYmVyID0gbTEwICogbTMxO1xyXG4gICAgICBjb25zdCB0bXAxNTogbnVtYmVyID0gbTMwICogbTExO1xyXG4gICAgICBjb25zdCB0bXAxNjogbnVtYmVyID0gbTEwICogbTIxO1xyXG4gICAgICBjb25zdCB0bXAxNzogbnVtYmVyID0gbTIwICogbTExO1xyXG4gICAgICBjb25zdCB0bXAxODogbnVtYmVyID0gbTAwICogbTMxO1xyXG4gICAgICBjb25zdCB0bXAxOTogbnVtYmVyID0gbTMwICogbTAxO1xyXG4gICAgICBjb25zdCB0bXAyMDogbnVtYmVyID0gbTAwICogbTIxO1xyXG4gICAgICBjb25zdCB0bXAyMTogbnVtYmVyID0gbTIwICogbTAxO1xyXG4gICAgICBjb25zdCB0bXAyMjogbnVtYmVyID0gbTAwICogbTExO1xyXG4gICAgICBjb25zdCB0bXAyMzogbnVtYmVyID0gbTEwICogbTAxO1xyXG5cclxuICAgICAgY29uc3QgdDA6IG51bWJlciA9ICh0bXAwICogbTExICsgdG1wMyAqIG0yMSArIHRtcDQgKiBtMzEpIC1cclxuICAgICAgICAodG1wMSAqIG0xMSArIHRtcDIgKiBtMjEgKyB0bXA1ICogbTMxKTtcclxuXHJcbiAgICAgIGNvbnN0IHQxOiBudW1iZXIgPSAodG1wMSAqIG0wMSArIHRtcDYgKiBtMjEgKyB0bXA5ICogbTMxKSAtXHJcbiAgICAgICAgKHRtcDAgKiBtMDEgKyB0bXA3ICogbTIxICsgdG1wOCAqIG0zMSk7XHJcbiAgICAgIGNvbnN0IHQyOiBudW1iZXIgPSAodG1wMiAqIG0wMSArIHRtcDcgKiBtMTEgKyB0bXAxMCAqIG0zMSkgLVxyXG4gICAgICAgICh0bXAzICogbTAxICsgdG1wNiAqIG0xMSArIHRtcDExICogbTMxKTtcclxuICAgICAgY29uc3QgdDM6IG51bWJlciA9ICh0bXA1ICogbTAxICsgdG1wOCAqIG0xMSArIHRtcDExICogbTIxKSAtXHJcbiAgICAgICAgKHRtcDQgKiBtMDEgKyB0bXA5ICogbTExICsgdG1wMTAgKiBtMjEpO1xyXG5cclxuICAgICAgY29uc3QgZDogbnVtYmVyID0gMS4wIC8gKG0wMCAqIHQwICsgbTEwICogdDEgKyBtMjAgKiB0MiArIG0zMCAqIHQzKTtcclxuXHJcbiAgICAgIHJldHVybiBfbXR4T3V0LnNldChcclxuICAgICAgICBkICogdDAsXHJcbiAgICAgICAgZCAqIHQxLFxyXG4gICAgICAgIGQgKiB0MixcclxuICAgICAgICBkICogdDMsXHJcbiAgICAgICAgZCAqICgodG1wMSAqIG0xMCArIHRtcDIgKiBtMjAgKyB0bXA1ICogbTMwKSAtICh0bXAwICogbTEwICsgdG1wMyAqIG0yMCArIHRtcDQgKiBtMzApKSxcclxuICAgICAgICBkICogKCh0bXAwICogbTAwICsgdG1wNyAqIG0yMCArIHRtcDggKiBtMzApIC0gKHRtcDEgKiBtMDAgKyB0bXA2ICogbTIwICsgdG1wOSAqIG0zMCkpLFxyXG4gICAgICAgIGQgKiAoKHRtcDMgKiBtMDAgKyB0bXA2ICogbTEwICsgdG1wMTEgKiBtMzApIC0gKHRtcDIgKiBtMDAgKyB0bXA3ICogbTEwICsgdG1wMTAgKiBtMzApKSxcclxuICAgICAgICBkICogKCh0bXA0ICogbTAwICsgdG1wOSAqIG0xMCArIHRtcDEwICogbTIwKSAtICh0bXA1ICogbTAwICsgdG1wOCAqIG0xMCArIHRtcDExICogbTIwKSksXHJcbiAgICAgICAgZCAqICgodG1wMTIgKiBtMTMgKyB0bXAxNSAqIG0yMyArIHRtcDE2ICogbTMzKSAtICh0bXAxMyAqIG0xMyArIHRtcDE0ICogbTIzICsgdG1wMTcgKiBtMzMpKSxcclxuICAgICAgICBkICogKCh0bXAxMyAqIG0wMyArIHRtcDE4ICogbTIzICsgdG1wMjEgKiBtMzMpIC0gKHRtcDEyICogbTAzICsgdG1wMTkgKiBtMjMgKyB0bXAyMCAqIG0zMykpLFxyXG4gICAgICAgIGQgKiAoKHRtcDE0ICogbTAzICsgdG1wMTkgKiBtMTMgKyB0bXAyMiAqIG0zMykgLSAodG1wMTUgKiBtMDMgKyB0bXAxOCAqIG0xMyArIHRtcDIzICogbTMzKSksXHJcbiAgICAgICAgZCAqICgodG1wMTcgKiBtMDMgKyB0bXAyMCAqIG0xMyArIHRtcDIzICogbTIzKSAtICh0bXAxNiAqIG0wMyArIHRtcDIxICogbTEzICsgdG1wMjIgKiBtMjMpKSxcclxuICAgICAgICBkICogKCh0bXAxNCAqIG0yMiArIHRtcDE3ICogbTMyICsgdG1wMTMgKiBtMTIpIC0gKHRtcDE2ICogbTMyICsgdG1wMTIgKiBtMTIgKyB0bXAxNSAqIG0yMikpLFxyXG4gICAgICAgIGQgKiAoKHRtcDIwICogbTMyICsgdG1wMTIgKiBtMDIgKyB0bXAxOSAqIG0yMikgLSAodG1wMTggKiBtMjIgKyB0bXAyMSAqIG0zMiArIHRtcDEzICogbTAyKSksXHJcbiAgICAgICAgZCAqICgodG1wMTggKiBtMTIgKyB0bXAyMyAqIG0zMiArIHRtcDE1ICogbTAyKSAtICh0bXAyMiAqIG0zMiArIHRtcDE0ICogbTAyICsgdG1wMTkgKiBtMTIpKSxcclxuICAgICAgICBkICogKCh0bXAyMiAqIG0yMiArIHRtcDE2ICogbTAyICsgdG1wMjEgKiBtMTIpIC0gKHRtcDIwICogbTEyICsgdG1wMjMgKiBtMjIgKyB0bXAxNyAqIG0wMikpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyBhIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiB0cmFuc2xhdGlvbiwgaXRzIHotYXhpcyBwb2ludGluZyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gdGFyZ2V0LFxyXG4gICAgICogYW5kIGEgbWluaW1hbCBhbmdsZSBiZXR3ZWVuIGl0cyB5LWF4aXMgYW5kIHRoZSBnaXZlbiB1cC17QGxpbmsgVmVjdG9yM30sIHJlc3BldGl2ZWx5IGNhbGN1bGF0aW5nIHlhdyBhbmQgcGl0Y2guXHJcbiAgICAgKiBUaGUgcGl0Y2ggbWF5IGJlIHJlc3RyaWN0ZWQgdG8gdGhlIHVwLXZlY3RvciB0byBvbmx5IGNhbGN1bGF0ZSB5YXcuIE9wdGlvbmFsbHkgcGFzcyBhIGRlc2lyZWQgc2NhbGluZy5cclxuICAgICAqIEBwYXJhbSBfdXAgQSB1bml0IHZlY3RvciBpbmRpY2F0aW5nIHRoZSB1cC1kaXJlY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gX210eE91dCBPcHRpb25hbCBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBMT09LX0FUKF90cmFuc2xhdGlvbjogVmVjdG9yMywgX3RhcmdldDogVmVjdG9yMywgX3VwPzogVmVjdG9yMywgX3Jlc3RyaWN0OiBib29sZWFuID0gZmFsc2UsIF9zY2FsaW5nPzogVmVjdG9yMywgX210eE91dDogTWF0cml4NHg0ID0gUmVjeWNsZXIucmV1c2UoTWF0cml4NHg0KSk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGNvbnN0IGZvcndhcmQ6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3RhcmdldCwgX3RyYW5zbGF0aW9uKTtcclxuICAgICAgZm9yd2FyZC5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgIE1hdHJpeDR4NC5MT09LX0lOKGZvcndhcmQsIF91cCwgX3Jlc3RyaWN0LCBfdHJhbnNsYXRpb24sIF9zY2FsaW5nLCBfbXR4T3V0KTtcclxuXHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKGZvcndhcmQpO1xyXG5cclxuICAgICAgcmV0dXJuIF9tdHhPdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyBhIG1hdHJpeCB3aXRoIGl0cyB6LWF4aXMgcG9pbnRpbmcgZGlyZWN0bHkgaW4gdGhlIGdpdmVuIGZvcndhcmQgZGlyZWN0aW9uLFxyXG4gICAgICogYW5kIGEgbWluaW1hbCBhbmdsZSBiZXR3ZWVuIGl0cyB5LWF4aXMgYW5kIHRoZSBnaXZlbiB1cCBkaXJlY3Rpb24uIFRoZSBwaXRjaCBtYXkgYmUgcmVzdHJpY3RlZCB0byB0aGUgdXAtdmVjdG9yIHRvIG9ubHkgY2FsY3VsYXRlIHlhdy5cclxuICAgICAqIE9wdGlvbmFsbHkgcGFzcyBhIGRlc2lyZWQgdHJhbnNsYXRpb24gYW5kL29yIHNjYWxpbmcuXHJcbiAgICAgKiBAcGFyYW0gX2ZvcndhcmQgQSB1bml0IHZlY3RvciBpbmRpY2F0aW5nIHRoZSBkZXNpcmVkIGZvcndhcmQtZGlyZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIF91cCBBIHVuaXQgdmVjdG9yIGluZGljYXRpbmcgdGhlIHVwLWRpcmVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBfbXR4T3V0IE9wdGlvbmFsIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIExPT0tfSU4oX2ZvcndhcmQ6IFZlY3RvcjMsIF91cD86IFZlY3RvcjMsIF9yZXN0cmljdDogYm9vbGVhbiA9IGZhbHNlLCBfdHJhbnNsYXRpb24/OiBWZWN0b3IzLCBfc2NhbGluZz86IFZlY3RvcjMsIF9tdHhPdXQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDR4NCkpOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCB6QXhpczogVmVjdG9yMyA9IF9mb3J3YXJkLmNsb25lO1xyXG4gICAgICBjb25zdCB5QXhpczogVmVjdG9yMyA9IF91cCA/IF91cC5jbG9uZSA6IFZlY3RvcjMuWSgpO1xyXG4gICAgICBjb25zdCB4QXhpczogVmVjdG9yMyA9IFZlY3RvcjMuQ1JPU1MoeUF4aXMsIHpBeGlzKTtcclxuXHJcbiAgICAgIC8vIGlmIHogYW5kIHVwIGlzIHBhcmFsbGVsLCB0aGVyZSBpcyBubyB1cCB0byByZW1haW4uLi5cclxuICAgICAgaWYgKHhBeGlzLm1hZ25pdHVkZVNxdWFyZWQgPT0gMCkgeyAvLyBmcm9tIHRocmVlLmpzIFxyXG4gICAgICAgIGlmIChNYXRoLmFicyh5QXhpcy56KSA9PT0gMSlcclxuICAgICAgICAgIHpBeGlzLnggKz0gMC4wMDAxO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHpBeGlzLnogKz0gMC4wMDAxO1xyXG5cclxuICAgICAgICB6QXhpcy5ub3JtYWxpemUoKTtcclxuICAgICAgICBWZWN0b3IzLkNST1NTKHlBeGlzLCB6QXhpcywgeEF4aXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4QXhpcy5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgIGlmIChfcmVzdHJpY3QpXHJcbiAgICAgICAgVmVjdG9yMy5DUk9TUyh4QXhpcywgeUF4aXMsIHpBeGlzKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIFZlY3RvcjMuQ1JPU1MoekF4aXMsIHhBeGlzLCB5QXhpcyk7XHJcblxyXG4gICAgICBjb25zdCBzY2FsaW5nOiBWZWN0b3IzID0gX210eE91dC4jc2NhbGluZztcclxuICAgICAgaWYgKF9zY2FsaW5nKSB7XHJcbiAgICAgICAgc2NhbGluZy5jb3B5KF9zY2FsaW5nKTtcclxuICAgICAgICB4QXhpcy5zY2FsZShzY2FsaW5nLngpO1xyXG4gICAgICAgIHlBeGlzLnNjYWxlKHNjYWxpbmcueSk7XHJcbiAgICAgICAgekF4aXMuc2NhbGUoc2NhbGluZy56KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzY2FsaW5nLnNldCgxLCAxLCAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgdHJhbnNsYXRpb246IFZlY3RvcjMgPSBfbXR4T3V0LiN0cmFuc2xhdGlvbjtcclxuICAgICAgaWYgKF90cmFuc2xhdGlvbilcclxuICAgICAgICB0cmFuc2xhdGlvbi5jb3B5KF90cmFuc2xhdGlvbik7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0cmFuc2xhdGlvbi5zZXQoMCwgMCwgMCk7XHJcblxyXG4gICAgICBfbXR4T3V0LnNldChcclxuICAgICAgICB4QXhpcy54LCB4QXhpcy55LCB4QXhpcy56LCAwLFxyXG4gICAgICAgIHlBeGlzLngsIHlBeGlzLnksIHlBeGlzLnosIDAsXHJcbiAgICAgICAgekF4aXMueCwgekF4aXMueSwgekF4aXMueiwgMCxcclxuICAgICAgICB0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55LCB0cmFuc2xhdGlvbi56LCAxXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh4QXhpcyk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHlBeGlzKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoekF4aXMpO1xyXG5cclxuICAgICAgX210eE91dC4jdHJhbnNsYXRpb25EaXJ0eSA9IGZhbHNlO1xyXG4gICAgICBfbXR4T3V0LiNzY2FsaW5nRGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICAgIHJldHVybiBfbXR4T3V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHRyYW5zbGF0ZXMgY29vcmRpbmF0ZXMgYWxvbmcgdGhlIHgtLCB5LSBhbmQgei1heGlzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4ge0BsaW5rIFZlY3RvcjN9LlxyXG4gICAgICogQHBhcmFtIF9tdHhPdXQgT3B0aW9uYWwgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVFJBTlNMQVRJT04oX3RyYW5zbGF0ZTogVmVjdG9yMywgX210eE91dDogTWF0cml4NHg0ID0gUmVjeWNsZXIucmV1c2UoTWF0cml4NHg0KSk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiBfbXR4T3V0LnNldChcclxuICAgICAgICAxLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIDEsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMSwgMCxcclxuICAgICAgICBfdHJhbnNsYXRlLngsIF90cmFuc2xhdGUueSwgX3RyYW5zbGF0ZS56LCAxXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyBvbiB0aGUgeC1heGlzIHdoZW4gbXVsdGlwbGllZCBieS5cclxuICAgICAqIEBwYXJhbSBfbXR4T3V0IE9wdGlvbmFsIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OX1goX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIsIF9tdHhPdXQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDR4NCkpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIENhbGMuZGVnMnJhZDtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIHJldHVybiBfbXR4T3V0LnNldChcclxuICAgICAgICAxLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIGNvcywgc2luLCAwLFxyXG4gICAgICAgIDAsIC1zaW4sIGNvcywgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyBvbiB0aGUgeS1heGlzIHdoZW4gbXVsdGlwbGllZCBieS5cclxuICAgICAqIEBwYXJhbSBfbXR4T3V0IE9wdGlvbmFsIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OX1koX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIsIF9tdHhPdXQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDR4NCkpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIENhbGMuZGVnMnJhZDtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIHJldHVybiBfbXR4T3V0LnNldChcclxuICAgICAgICBjb3MsIDAsIC1zaW4sIDAsXHJcbiAgICAgICAgMCwgMSwgMCwgMCxcclxuICAgICAgICBzaW4sIDAsIGNvcywgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyBvbiB0aGUgei1heGlzIHdoZW4gbXVsdGlwbGllZCBieS5cclxuICAgICAqIEBwYXJhbSBfbXR4T3V0IE9wdGlvbmFsIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OX1ooX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIsIF9tdHhPdXQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDR4NCkpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgYW5nbGVJblJhZGlhbnM6IG51bWJlciA9IF9hbmdsZUluRGVncmVlcyAqIENhbGMuZGVnMnJhZDtcclxuICAgICAgbGV0IHNpbjogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICBsZXQgY29zOiBudW1iZXIgPSBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyk7XHJcbiAgICAgIHJldHVybiBfbXR4T3V0LnNldChcclxuICAgICAgICBjb3MsIHNpbiwgMCwgMCxcclxuICAgICAgICAtc2luLCBjb3MsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMSwgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyB3aGVuIG11bHRpcGxpZWQgYnksIHVzaW5nIHRoZSByb3RhdGlvbiBldWxlciBhbmdsZXMgb3IgdW5pdCBxdWF0ZXJuaW9uIGdpdmVuLlxyXG4gICAgICogUm90YXRpb24gb2NjdXJzIGFyb3VuZCB0aGUgYXhpcyBpbiB0aGUgb3JkZXIgWi1ZLVguIFxyXG4gICAgICogQHBhcmFtIF9tdHhPdXQgT3B0aW9uYWwgbWF0cml4IHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT04oX3JvdGF0aW9uOiBWZWN0b3IzIHwgUXVhdGVybmlvbiwgX210eE91dDogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCkpOiBNYXRyaXg0eDQge1xyXG4gICAgICAvLyBhdm9pZCBkZWNvbXBvc3Rpb24gb2Ygcm90YXRpb24gYW5kIHNjYWxpbmcgaW4gY29tcG9zZS4uLlxyXG4gICAgICBfbXR4T3V0LiNzY2FsaW5nLnNldCgxLCAxLCAxKTtcclxuICAgICAgX210eE91dC4jc2NhbGluZ0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgIGlmIChfcm90YXRpb24gaW5zdGFuY2VvZiBRdWF0ZXJuaW9uKSB7XHJcbiAgICAgICAgX210eE91dC4jcXVhdGVybmlvbi5jb3B5KF9yb3RhdGlvbik7XHJcbiAgICAgICAgX210eE91dC4jcXVhdGVybmlvbkRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgX210eE91dC4jcm90YXRpb25EaXJ0eSA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX210eE91dC4jcm90YXRpb24uY29weShfcm90YXRpb24pO1xyXG4gICAgICAgIF9tdHhPdXQuI3JvdGF0aW9uRGlydHkgPSBmYWxzZTtcclxuICAgICAgICBfbXR4T3V0LiNxdWF0ZXJuaW9uRGlydHkgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfbXR4T3V0LnJvdGF0aW9uID0gX3JvdGF0aW9uO1xyXG4gICAgICByZXR1cm4gX210eE91dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXRyaXggdGhhdCByb3RhdGVzIGNvb3JkaW5hdGVzIGFyb3VuZCBhbiBhcmJpdHJhcnkgYXhpcyB3aGVuIG11bHRpcGxpZWQgYnkuXHJcbiAgICAgKiBAcGFyYW0gX2F4aXMgVGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZCBhcyBhIHVuaXQgdmVjdG9yLlxyXG4gICAgICogQHBhcmFtIF9hbmdsZSBUaGUgYW5nbGUgaW4gZGVncmVlcy5cclxuICAgICAqIEBwYXJhbSBfbXR4T3V0IE9wdGlvbmFsIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OX0FYSVNfQU5HTEUoX2F4aXM6IFZlY3RvcjMsIF9hbmdsZTogbnVtYmVyLCBfbXR4T3V0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5nZXQoTWF0cml4NHg0KSk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIC8vIGZyb20gdGhyZWUuanMsIGFkanVzdGVkIGZvciBGVURHRSByb3cgdmVjdG9yICogcm93LW1ham9yIG1hdHJpeCB0cmFuc2Zvcm1hdGlvbiBjb252ZW50aW9uXHJcbiAgICAgIF9hbmdsZSAqPSBDYWxjLmRlZzJyYWQ7XHJcbiAgICAgIGNvbnN0IGM6IG51bWJlciA9IE1hdGguY29zKF9hbmdsZSk7XHJcbiAgICAgIGNvbnN0IHM6IG51bWJlciA9IE1hdGguc2luKF9hbmdsZSk7XHJcbiAgICAgIGNvbnN0IHQ6IG51bWJlciA9IDEgLSBjO1xyXG4gICAgICBjb25zdCB4OiBudW1iZXIgPSBfYXhpcy54LCB5OiBudW1iZXIgPSBfYXhpcy55LCB6OiBudW1iZXIgPSBfYXhpcy56O1xyXG4gICAgICBjb25zdCB0eDogbnVtYmVyID0gdCAqIHgsIHR5OiBudW1iZXIgPSB0ICogeTtcclxuXHJcbiAgICAgIF9tdHhPdXQuc2V0KFxyXG4gICAgICAgIHR4ICogeCArIGMsIHR4ICogeSArIHMgKiB6LCB0eCAqIHogLSBzICogeSwgMCxcclxuICAgICAgICB0eCAqIHkgLSBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6ICsgcyAqIHgsIDAsXHJcbiAgICAgICAgdHggKiB6ICsgcyAqIHksIHR5ICogeiAtIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxyXG4gICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiBfbXR4T3V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCB0aGF0IHNjYWxlcyBjb29yZGluYXRlcyBhbG9uZyB0aGUgeC0sIHktIGFuZCB6LWF4aXMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB7QGxpbmsgVmVjdG9yM30uXHJcbiAgICAgKiBAcGFyYW0gX210eE91dCBPcHRpb25hbCBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTQ0FMSU5HKF9zY2FsYXI6IFZlY3RvcjMsIF9tdHhPdXQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDR4NCkpOiBNYXRyaXg0eDQge1xyXG4gICAgICByZXR1cm4gX210eE91dC5zZXQoXHJcbiAgICAgICAgX3NjYWxhci54LCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIF9zY2FsYXIueSwgMCwgMCxcclxuICAgICAgICAwLCAwLCBfc2NhbGFyLnosIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBtYXRyaXggcmVsYXRpdmUgdG8gdGhlIGdpdmVuIGJhc2UuXHJcbiAgICAgKiBJZiBrbm93biwgcGFzcyB0aGUgaW52ZXJzZSBvZiB0aGUgYmFzZSB0byBhdm9pZCB1bm5lY2Nlc2FyeSBjYWxjdWxhdGlvbi5cclxuICAgICAqIEBwYXJhbSBfbXR4T3V0IE9wdGlvbmFsIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJFTEFUSVZFKF9tdHg6IE1hdHJpeDR4NCwgX210eEJhc2U6IE1hdHJpeDR4NCwgX210eEludmVyc2U/OiBNYXRyaXg0eDQsIF9tdHhPdXQ6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDR4NCkpOiBNYXRyaXg0eDQge1xyXG4gICAgICBpZiAoX210eEludmVyc2UpXHJcbiAgICAgICAgcmV0dXJuIE1hdHJpeDR4NC5QUk9EVUNUKF9tdHhJbnZlcnNlLCBfbXR4LCBfbXR4T3V0KTtcclxuXHJcbiAgICAgIGxldCBtdHhJbnZlcnNlOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSU5WRVJTRShfbXR4QmFzZSk7XHJcbiAgICAgIE1hdHJpeDR4NC5QUk9EVUNUKG10eEludmVyc2UsIF9tdHgsIF9tdHhPdXQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhJbnZlcnNlKTtcclxuICAgICAgcmV0dXJuIF9tdHhPdXQ7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gUFJPSkVDVElPTlNcclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSBtYXRyaXggdGhhdCBhcHBsaWVzIHBlcnNwZWN0aXZlIHRvIGFuIG9iamVjdCwgaWYgaXRzIHRyYW5zZm9ybSBpcyBtdWx0aXBsaWVkIGJ5IGl0LlxyXG4gICAgICogQHBhcmFtIF9hc3BlY3QgVGhlIGFzcGVjdCByYXRpbyBiZXR3ZWVuIHdpZHRoIGFuZCBoZWlnaHQgb2YgcHJvamVjdGlvbnNwYWNlLihEZWZhdWx0ID0gY2FudmFzLmNsaWVudFdpZHRoIC8gY2FudmFzLkNsaWVudEhlaWdodClcclxuICAgICAqIEBwYXJhbSBfZmllbGRPZlZpZXdJbkRlZ3JlZXMgVGhlIGZpZWxkIG9mIHZpZXcgaW4gRGVncmVlcy4gKERlZmF1bHQgPSA0NSlcclxuICAgICAqIEBwYXJhbSBfbmVhciBUaGUgbmVhciBjbGlwc3BhY2UgYm9yZGVyIG9uIHRoZSB6LWF4aXMuXHJcbiAgICAgKiBAcGFyYW0gX2ZhciBUaGUgZmFyIGNsaXBzcGFjZSBib3JkZXIgb24gdGhlIHotYXhpcy5cclxuICAgICAqIEBwYXJhbSBfZGlyZWN0aW9uIFRoZSBwbGFuZSBvbiB3aGljaCB0aGUgZmllbGRPZlZpZXctQW5nbGUgaXMgZ2l2ZW4gXHJcbiAgICAgKiBAcGFyYW0gX210eE91dCBPcHRpb25hbCBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBQUk9KRUNUSU9OX0NFTlRSQUwoX2FzcGVjdDogbnVtYmVyLCBfZmllbGRPZlZpZXdJbkRlZ3JlZXM6IG51bWJlciwgX25lYXI6IG51bWJlciwgX2ZhcjogbnVtYmVyLCBfZGlyZWN0aW9uOiBGSUVMRF9PRl9WSUVXLCBfbXR4T3V0OiBNYXRyaXg0eDQgPSBSZWN5Y2xlci5yZXVzZShNYXRyaXg0eDQpKTogTWF0cml4NHg0IHtcclxuICAgICAgLy9UT0RPOiBjYW1lcmEgbG9va3MgZG93biBuZWdhdGl2ZSB6LWRpcmVjdGlvbiwgc2hvdWxkIGJlIHBvc2l0aXZlXHJcbiAgICAgIGxldCBmaWVsZE9mVmlld0luUmFkaWFuczogbnVtYmVyID0gX2ZpZWxkT2ZWaWV3SW5EZWdyZWVzICogQ2FsYy5kZWcycmFkO1xyXG4gICAgICBsZXQgZjogbnVtYmVyID0gTWF0aC50YW4oMC41ICogKE1hdGguUEkgLSBmaWVsZE9mVmlld0luUmFkaWFucykpO1xyXG4gICAgICBsZXQgcmFuZ2VJbnY6IG51bWJlciA9IDEuMCAvIChfbmVhciAtIF9mYXIpO1xyXG5cclxuICAgICAgX210eE91dC5zZXQoXHJcbiAgICAgICAgZiwgMCwgMCwgMCxcclxuICAgICAgICAwLCBmLCAwLCAwLFxyXG4gICAgICAgIDAsIDAsIChfbmVhciArIF9mYXIpICogcmFuZ2VJbnYsIC0xLFxyXG4gICAgICAgIDAsIDAsIF9uZWFyICogX2ZhciAqIHJhbmdlSW52ICogMiwgMFxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKF9kaXJlY3Rpb24gPT0gRklFTERfT0ZfVklFVy5ESUFHT05BTCkge1xyXG4gICAgICAgIF9hc3BlY3QgPSBNYXRoLnNxcnQoX2FzcGVjdCk7XHJcbiAgICAgICAgX210eE91dC5kYXRhWzBdID0gZiAvIF9hc3BlY3Q7XHJcbiAgICAgICAgX210eE91dC5kYXRhWzVdID0gZiAqIF9hc3BlY3Q7XHJcbiAgICAgIH0gZWxzZSBpZiAoX2RpcmVjdGlvbiA9PSBGSUVMRF9PRl9WSUVXLlZFUlRJQ0FMKVxyXG4gICAgICAgIF9tdHhPdXQuZGF0YVswXSA9IGYgLyBfYXNwZWN0O1xyXG4gICAgICBlbHNlIC8vRk9WX0RJUkVDVElPTi5IT1JJWk9OVEFMXHJcbiAgICAgICAgX210eE91dC5kYXRhWzVdID0gZiAqIF9hc3BlY3Q7XHJcblxyXG4gICAgICAvLyBIQUNLOiBtYXRyaXggc2hvdWxkIGxvb2sgaW4gcG9zaXRpdmUgei1kaXJlY3Rpb24sIHByZWZlcmFibHkgdGhlIG1hdHJpeCBzaG91bGQgYmUgY2FsY3VsYXRlZCBsaWtlIHRoYXQgcmlnaHQgYXdheVxyXG4gICAgICBfbXR4T3V0LnJvdGF0ZVkoMTgwKTtcclxuXHJcbiAgICAgIHJldHVybiBfbXR4T3V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgYSBtYXRyaXggdGhhdCBhcHBsaWVzIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIHRvIGFuIG9iamVjdCwgaWYgaXRzIHRyYW5zZm9ybSBpcyBtdWx0aXBsaWVkIGJ5IGl0LlxyXG4gICAgICogQHBhcmFtIF9sZWZ0IFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyBsZWZ0IGJvcmRlci5cclxuICAgICAqIEBwYXJhbSBfcmlnaHQgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIHJpZ2h0IGJvcmRlci5cclxuICAgICAqIEBwYXJhbSBfYm90dG9tIFRoZSBwb3NpdGlvbnZhbHVlIG9mIHRoZSBwcm9qZWN0aW9uc3BhY2UncyBib3R0b20gYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF90b3AgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIHRvcCBib3JkZXIuXHJcbiAgICAgKiBAcGFyYW0gX25lYXIgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIG5lYXIgYm9yZGVyLlxyXG4gICAgICogQHBhcmFtIF9mYXIgVGhlIHBvc2l0aW9udmFsdWUgb2YgdGhlIHByb2plY3Rpb25zcGFjZSdzIGZhciBib3JkZXJcclxuICAgICAqIEBwYXJhbSBfbXR4T3V0IE9wdGlvbmFsIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFBST0pFQ1RJT05fT1JUSE9HUkFQSElDKF9sZWZ0OiBudW1iZXIsIF9yaWdodDogbnVtYmVyLCBfYm90dG9tOiBudW1iZXIsIF90b3A6IG51bWJlciwgX25lYXI6IG51bWJlciA9IC00MDAsIF9mYXI6IG51bWJlciA9IDQwMCwgX210eE91dDogTWF0cml4NHg0ID0gUmVjeWNsZXIucmV1c2UoTWF0cml4NHg0KSk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIF9tdHhPdXQuc2V0KFxyXG4gICAgICAgIDIgLyAoX3JpZ2h0IC0gX2xlZnQpLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIC0yIC8gKF90b3AgLSBfYm90dG9tKSwgMCwgMCxcclxuICAgICAgICAwLCAwLCAyIC8gKF9mYXIgLSBfbmVhciksIDAsXHJcbiAgICAgICAgKF9sZWZ0ICsgX3JpZ2h0KSAvIChfbGVmdCAtIF9yaWdodCksXHJcbiAgICAgICAgKF9ib3R0b20gKyBfdG9wKSAvIChfYm90dG9tIC0gX3RvcCksXHJcbiAgICAgICAgKF9uZWFyICsgX2ZhcikgLyAoX25lYXIgLSBfZmFyKSxcclxuICAgICAgICAxXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBfbXR4T3V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiAgQWNjZXNzb3JzXHJcbiAgICAvKiogXHJcbiAgICAgKiAtIGdldDogcmV0dXJuIGEgdmVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2xhdGlvbiB7QGxpbmsgVmVjdG9yM30uICBcclxuICAgICAqICoqQ2F1dGlvbiEqKiBVc2UgaW1tZWRpYXRlbHkgYW5kIHJlYWRvbmx5LCBzaW5jZSB0aGUgdmVjdG9yIGlzIGdvaW5nIHRvIGJlIHJldXNlZCBpbnRlcm5hbGx5LiBDcmVhdGUgYSBjbG9uZSB0byBrZWVwIGxvbmdlciBhbmQgbWFuaXB1bGF0ZS4gXHJcbiAgICAgKiAtIHNldDogZWZmZWN0IHRoZSBtYXRyaXggaWdub3JpbmcgaXRzIHJvdGF0aW9uIGFuZCBzY2FsaW5nXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgdHJhbnNsYXRpb24oKTogVmVjdG9yMyB7XHJcbiAgICAgIGlmICh0aGlzLiN0cmFuc2xhdGlvbkRpcnR5KSB7XHJcbiAgICAgICAgdGhpcy4jdHJhbnNsYXRpb24uc2V0KHRoaXMuZGF0YVsxMl0sIHRoaXMuZGF0YVsxM10sIHRoaXMuZGF0YVsxNF0pO1xyXG4gICAgICAgIHRoaXMuI3RyYW5zbGF0aW9uRGlydHkgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy4jdHJhbnNsYXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHRyYW5zbGF0aW9uKF90cmFuc2xhdGlvbjogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLmNvbXBvc2UoX3RyYW5zbGF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiAtIGdldDogcmV0dXJuIGEgdmVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByb3RhdGlvbiB7QGxpbmsgVmVjdG9yM30uICBcclxuICAgICAqICoqQ2F1dGlvbiEqKiBVc2UgaW1tZWRpYXRlbHkgYW5kIHJlYWRvbmx5LCBzaW5jZSB0aGUgdmVjdG9yIGlzIGdvaW5nIHRvIGJlIHJldXNlZCBpbnRlcm5hbGx5LiBDcmVhdGUgYSBjbG9uZSB0byBrZWVwIGxvbmdlciBhbmQgbWFuaXB1bGF0ZS4gXHJcbiAgICAgKiAtIHNldDogZWZmZWN0IHRoZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCByb3RhdGlvbigpOiBWZWN0b3IzIHtcclxuICAgICAgaWYgKHRoaXMuI3JvdGF0aW9uRGlydHkpIHtcclxuICAgICAgICBsZXQgc2NhbGluZzogVmVjdG9yMyA9IHRoaXMuc2NhbGluZztcclxuXHJcbiAgICAgICAgbGV0IHMwOiBudW1iZXIgPSB0aGlzLmRhdGFbMF0gLyBzY2FsaW5nLng7XHJcbiAgICAgICAgbGV0IHMxOiBudW1iZXIgPSB0aGlzLmRhdGFbMV0gLyBzY2FsaW5nLng7XHJcbiAgICAgICAgbGV0IHMyOiBudW1iZXIgPSB0aGlzLmRhdGFbMl0gLyBzY2FsaW5nLng7XHJcbiAgICAgICAgbGV0IHM2OiBudW1iZXIgPSB0aGlzLmRhdGFbNl0gLyBzY2FsaW5nLnk7XHJcbiAgICAgICAgbGV0IHMxMDogbnVtYmVyID0gdGhpcy5kYXRhWzEwXSAvIHNjYWxpbmcuejtcclxuXHJcbiAgICAgICAgbGV0IHN5OiBudW1iZXIgPSBNYXRoLnNxcnQoczAgKiBzMCArIHMxICogczEpOyAvLyBwcm9iYWJseSAyLiBwYXJhbSBzaG91bGQgYmUgdGhpcy5kYXRhWzRdIC8gc2NhbGluZy55XHJcblxyXG4gICAgICAgIGxldCBzaW5ndWxhcjogYm9vbGVhbiA9IHN5IDwgMWUtNjsgLy8gSWZcclxuXHJcbiAgICAgICAgbGV0IHgxOiBudW1iZXIsIHkxOiBudW1iZXIsIHoxOiBudW1iZXI7XHJcbiAgICAgICAgbGV0IHgyOiBudW1iZXIsIHkyOiBudW1iZXIsIHoyOiBudW1iZXI7XHJcblxyXG4gICAgICAgIGlmICghc2luZ3VsYXIpIHtcclxuICAgICAgICAgIHgxID0gTWF0aC5hdGFuMihzNiwgczEwKTtcclxuICAgICAgICAgIHkxID0gTWF0aC5hdGFuMigtczIsIHN5KTtcclxuICAgICAgICAgIHoxID0gTWF0aC5hdGFuMihzMSwgczApO1xyXG5cclxuICAgICAgICAgIHgyID0gTWF0aC5hdGFuMigtczYsIC1zMTApO1xyXG4gICAgICAgICAgeTIgPSBNYXRoLmF0YW4yKC1zMiwgLXN5KTtcclxuICAgICAgICAgIHoyID0gTWF0aC5hdGFuMigtczEsIC1zMCk7XHJcblxyXG4gICAgICAgICAgaWYgKE1hdGguYWJzKHgyKSArIE1hdGguYWJzKHkyKSArIE1hdGguYWJzKHoyKSA8IE1hdGguYWJzKHgxKSArIE1hdGguYWJzKHkxKSArIE1hdGguYWJzKHoxKSkge1xyXG4gICAgICAgICAgICB4MSA9IHgyO1xyXG4gICAgICAgICAgICB5MSA9IHkyO1xyXG4gICAgICAgICAgICB6MSA9IHoyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4MSA9IE1hdGguYXRhbjIoLXRoaXMuZGF0YVs5XSAvIHNjYWxpbmcueiwgdGhpcy5kYXRhWzVdIC8gc2NhbGluZy55KTtcclxuICAgICAgICAgIHkxID0gTWF0aC5hdGFuMigtdGhpcy5kYXRhWzJdIC8gc2NhbGluZy54LCBzeSk7XHJcbiAgICAgICAgICB6MSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLiNyb3RhdGlvbi5zZXQoeDEsIHkxLCB6MSk7XHJcbiAgICAgICAgdGhpcy4jcm90YXRpb24uc2NhbGUoQ2FsYy5yYWQyZGVnKTtcclxuICAgICAgICB0aGlzLiNyb3RhdGlvbkRpcnR5ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLiNyb3RhdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgcm90YXRpb24oX3JvdGF0aW9uOiBRdWF0ZXJuaW9uIHwgVmVjdG9yMykge1xyXG4gICAgICB0aGlzLmNvbXBvc2UodW5kZWZpbmVkLCBfcm90YXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIC0gZ2V0OiByZXR1cm4gYSB2ZWN0b3IgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNjYWxpbmcge0BsaW5rIFZlY3RvcjN9LiAgXHJcbiAgICAgKiAqKkNhdXRpb24hKiogVXNlIGltbWVkaWF0ZWx5IGFuZCByZWFkb25seSwgc2luY2UgdGhlIHZlY3RvciBpcyBnb2luZyB0byBiZSByZXVzZWQgaW50ZXJuYWxseS4gQ3JlYXRlIGEgY2xvbmUgdG8ga2VlcCBsb25nZXIgYW5kIG1hbmlwdWxhdGUuIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc2NhbGluZygpOiBWZWN0b3IzIHtcclxuICAgICAgaWYgKHRoaXMuI3NjYWxpbmdEaXJ0eSkge1xyXG4gICAgICAgIHRoaXMuI3NjYWxpbmcuc2V0KFxyXG4gICAgICAgICAgTWF0aC5zcXJ0KHRoaXMuZGF0YVswXSAqIHRoaXMuZGF0YVswXSArIHRoaXMuZGF0YVsxXSAqIHRoaXMuZGF0YVsxXSArIHRoaXMuZGF0YVsyXSAqIHRoaXMuZGF0YVsyXSksIC8vKiAodGhpcy5kYXRhWzBdIDwgMCA/IC0xIDogMSksXHJcbiAgICAgICAgICBNYXRoLnNxcnQodGhpcy5kYXRhWzRdICogdGhpcy5kYXRhWzRdICsgdGhpcy5kYXRhWzVdICogdGhpcy5kYXRhWzVdICsgdGhpcy5kYXRhWzZdICogdGhpcy5kYXRhWzZdKSwgLy8qICh0aGlzLmRhdGFbNV0gPCAwID8gLTEgOiAxKSxcclxuICAgICAgICAgIE1hdGguc3FydCh0aGlzLmRhdGFbOF0gKiB0aGlzLmRhdGFbOF0gKyB0aGlzLmRhdGFbOV0gKiB0aGlzLmRhdGFbOV0gKyB0aGlzLmRhdGFbMTBdICogdGhpcy5kYXRhWzEwXSkgLy8gKiAodGhpcy5kYXRhWzEwXSA8IDAgPyAtMSA6IDEpXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gaWYgKHRoaXMuZGV0ZXJtaW5hbnQgPCAwKSAvLyDimqDvuI9FWFBFUk1JTkVUQUwgZnJvbSB0aHJlZSBqczogaWYgZGV0ZXJtaW5hbnQgaXMgbmVnYXRpdmUsIGludmVydCBvbmUgc2NhbGVcclxuICAgICAgICAvLyAgIHRoaXMuI3NjYWxpbmcueCA9IC10aGlzLiNzY2FsaW5nLng7XHJcblxyXG4gICAgICAgIHRoaXMuI3NjYWxpbmdEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLiNzY2FsaW5nO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzY2FsaW5nKF9zY2FsaW5nOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuY29tcG9zZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgX3NjYWxpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIC0gZ2V0OiByZXR1cm4gYSB1bml0IHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSByb3RhdGlvbiBvZiB0aGlzIG1hdHJpeC5cclxuICAgICAqICoqQ2F1dGlvbiEqKiBVc2UgaW1tZWRpYXRlbHkgYW5kIHJlYWRvbmx5LCBzaW5jZSB0aGUgcXVhdGVybmlvbiBpcyBnb2luZyB0byBiZSByZXVzZWQgaW50ZXJuYWxseS4gQ3JlYXRlIGEgY2xvbmUgdG8ga2VlcCBsb25nZXIgYW5kIG1hbmlwdWxhdGUuIFxyXG4gICAgICogLSBzZXQ6IGVmZmVjdCB0aGUgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcXVhdGVybmlvbigpOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgaWYgKHRoaXMuI3F1YXRlcm5pb25EaXJ0eSkge1xyXG4gICAgICAgIHRoaXMuI3F1YXRlcm5pb24uZXVsZXJBbmdsZXMgPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICAgIHRoaXMuI3F1YXRlcm5pb25EaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBhbHRlcm5hdGl2ZSBxdWF0ZXJuaW9uIGNhbGN1bGF0aW9uLCBmYXN0ZXIgdGhhbiBldWxlciBhbmdsZXMsIGJ1dCBwcm9kdWNlcyBkaWZmZXJlbnQgcmVzdWx0cyBmb3IgbWF0cmljZXMgd2l0aCBkZXRlcm1pbmFudCA8IDAgdGhhbiBldWxlciBhbmdsZXMuLi5cclxuICAgICAgICAvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtLCBhZGp1c3RlZCBmb3IgRlVER0Ugcm93IHZlY3RvciAqIHJvdy1tYWpvciBtYXRyaXggdHJhbnNmb3JtYXRpb24gY29udmVudGlvblxyXG4gICAgICAgIC8vIHJlcXVpcmVzIGEgcHVyZSAodW5zY2FsZWQpIHJvdGF0aW9uIG1hdHJpeFxyXG4gICAgICAgIC8vIGNvbnN0IHNjYWxpbmc6IFZlY3RvcjMgPSB0aGlzLnNjYWxpbmc7XHJcbiAgICAgICAgLy8gY29uc3QgaW52U2NhbGluZ1g6IG51bWJlciA9ICAodGhpcy5nZXREZXRlcm1pbmFudCgpIDwgMCA/IC0xIDogMSkgLyBzY2FsaW5nLng7XHJcbiAgICAgICAgLy8gY29uc3QgaW52U2NhbGluZ1k6IG51bWJlciA9IDEgLyBzY2FsaW5nLnk7XHJcbiAgICAgICAgLy8gY29uc3QgaW52U2NhbGluZ1o6IG51bWJlciA9IDEgLyBzY2FsaW5nLno7XHJcblxyXG4gICAgICAgIC8vIGNvbnN0IG0wMDogbnVtYmVyID0gdGhpcy5kYXRhWzBdICogaW52U2NhbGluZ1g7XHJcbiAgICAgICAgLy8gY29uc3QgbTAxOiBudW1iZXIgPSB0aGlzLmRhdGFbMV0gKiBpbnZTY2FsaW5nWDtcclxuICAgICAgICAvLyBjb25zdCBtMDI6IG51bWJlciA9IHRoaXMuZGF0YVsyXSAqIGludlNjYWxpbmdYO1xyXG5cclxuICAgICAgICAvLyBjb25zdCBtMTA6IG51bWJlciA9IHRoaXMuZGF0YVs0XSAqIGludlNjYWxpbmdZO1xyXG4gICAgICAgIC8vIGNvbnN0IG0xMTogbnVtYmVyID0gdGhpcy5kYXRhWzVdICogaW52U2NhbGluZ1k7XHJcbiAgICAgICAgLy8gY29uc3QgbTEyOiBudW1iZXIgPSB0aGlzLmRhdGFbNl0gKiBpbnZTY2FsaW5nWTtcclxuXHJcbiAgICAgICAgLy8gY29uc3QgbTIwOiBudW1iZXIgPSB0aGlzLmRhdGFbOF0gKiBpbnZTY2FsaW5nWjtcclxuICAgICAgICAvLyBjb25zdCBtMjE6IG51bWJlciA9IHRoaXMuZGF0YVs5XSAqIGludlNjYWxpbmdaO1xyXG4gICAgICAgIC8vIGNvbnN0IG0yMjogbnVtYmVyID0gdGhpcy5kYXRhWzEwXSAqIGludlNjYWxpbmdaO1xyXG5cclxuICAgICAgICAvLyBjb25zdCB0cmFjZTogbnVtYmVyID0gbTAwICsgbTExICsgbTIyO1xyXG5cclxuICAgICAgICAvLyBpZiAodHJhY2UgPiAwKSB7XHJcbiAgICAgICAgLy8gICBjb25zdCBzOiBudW1iZXIgPSAwLjUgLyBNYXRoLnNxcnQodHJhY2UgKyAxKTtcclxuICAgICAgICAvLyAgIHRoaXMuI3F1YXRlcm5pb24uc2V0KFxyXG4gICAgICAgIC8vICAgICAobTEyIC0gbTIxKSAqIHMsIFxyXG4gICAgICAgIC8vICAgICAobTIwIC0gbTAyKSAqIHMsIFxyXG4gICAgICAgIC8vICAgICAobTAxIC0gbTEwKSAqIHMsIFxyXG4gICAgICAgIC8vICAgICAwLjI1IC8gcyk7XHJcbiAgICAgICAgLy8gfSBlbHNlIGlmIChtMDAgPiBtMTEgJiYgbTAwID4gbTIyKSB7XHJcbiAgICAgICAgLy8gICBjb25zdCBzOiBudW1iZXIgPSAyICogTWF0aC5zcXJ0KDEgKyBtMDAgLSBtMTEgLSBtMjIpO1xyXG4gICAgICAgIC8vICAgdGhpcy4jcXVhdGVybmlvbi5zZXQoXHJcbiAgICAgICAgLy8gICAgIDAuMjUgKiBzLFxyXG4gICAgICAgIC8vICAgICAobTEwICsgbTAxKSAvIHMsXHJcbiAgICAgICAgLy8gICAgIChtMjAgKyBtMDIpIC8gcyxcclxuICAgICAgICAvLyAgICAgKG0xMiAtIG0yMSkgLyBzXHJcbiAgICAgICAgLy8gICApO1xyXG4gICAgICAgIC8vIH0gZWxzZSBpZiAobTExID4gbTIyKSB7XHJcbiAgICAgICAgLy8gICBjb25zdCBzOiBudW1iZXIgPSAyICogTWF0aC5zcXJ0KDEgKyBtMTEgLSBtMDAgLSBtMjIpO1xyXG4gICAgICAgIC8vICAgdGhpcy4jcXVhdGVybmlvbi5zZXQoXHJcbiAgICAgICAgLy8gICAgIChtMTAgKyBtMDEpIC8gcyxcclxuICAgICAgICAvLyAgICAgMC4yNSAqIHMsXHJcbiAgICAgICAgLy8gICAgIChtMjEgKyBtMTIpIC8gcyxcclxuICAgICAgICAvLyAgICAgKG0yMCAtIG0wMikgLyBzXHJcbiAgICAgICAgLy8gICApO1xyXG4gICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICBjb25zdCBzOiBudW1iZXIgPSAyICogTWF0aC5zcXJ0KDEgKyBtMjIgLSBtMDAgLSBtMTEpO1xyXG4gICAgICAgIC8vICAgdGhpcy4jcXVhdGVybmlvbi5zZXQoXHJcbiAgICAgICAgLy8gICAgIChtMjAgKyBtMDIpIC8gcyxcclxuICAgICAgICAvLyAgICAgKG0yMSArIG0xMikgLyBzLFxyXG4gICAgICAgIC8vICAgICAwLjI1ICogcyxcclxuICAgICAgICAvLyAgICAgKG0wMSAtIG0xMCkgLyBzXHJcbiAgICAgICAgLy8gICApO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyB0aGlzLiNxdWF0ZXJuaW9uRGlydHkgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuI3F1YXRlcm5pb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHF1YXRlcm5pb24oX3F1YXRlcm5pb246IFF1YXRlcm5pb24pIHtcclxuICAgICAgdGhpcy5jb21wb3NlKHVuZGVmaW5lZCwgX3F1YXRlcm5pb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhpcyBtYXRyaXguIENvbXB1dGF0aW9uYWwgaGVhdnkgb3BlcmF0aW9uLCBub3QgY2FjaGVkIHNvIHVzZSB3aXRoIGNhcmUuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIE1hdHJpeDR4NC5nZXREZXRlcm1pbmFudH0gaW5zdGVhZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBkZXRlcm1pbmFudCgpOiBudW1iZXIge1xyXG4gICAgICBjb25zdCBtOiBGbG9hdDMyQXJyYXkgPSB0aGlzLmRhdGE7XHJcblxyXG4gICAgICBjb25zdCBkZXQwMDogbnVtYmVyID0gbVsxMF0gKiBtWzE1XSAtIG1bMTFdICogbVsxNF07XHJcbiAgICAgIGNvbnN0IGRldDAxOiBudW1iZXIgPSBtWzldICogbVsxNV0gLSBtWzExXSAqIG1bMTNdO1xyXG4gICAgICBjb25zdCBkZXQwMjogbnVtYmVyID0gbVs5XSAqIG1bMTRdIC0gbVsxMF0gKiBtWzEzXTtcclxuICAgICAgY29uc3QgZGV0MDM6IG51bWJlciA9IG1bOF0gKiBtWzE1XSAtIG1bMTFdICogbVsxMl07XHJcbiAgICAgIGNvbnN0IGRldDA0OiBudW1iZXIgPSBtWzhdICogbVsxNF0gLSBtWzEwXSAqIG1bMTJdO1xyXG4gICAgICBjb25zdCBkZXQwNTogbnVtYmVyID0gbVs4XSAqIG1bMTNdIC0gbVs5XSAqIG1bMTJdO1xyXG5cclxuICAgICAgY29uc3QgZGV0OiBudW1iZXIgPVxyXG4gICAgICAgIG1bMF0gKiAobVs1XSAqIGRldDAwIC0gbVs2XSAqIGRldDAxICsgbVs3XSAqIGRldDAyKSAtXHJcbiAgICAgICAgbVsxXSAqIChtWzRdICogZGV0MDAgLSBtWzZdICogZGV0MDMgKyBtWzddICogZGV0MDQpICtcclxuICAgICAgICBtWzJdICogKG1bNF0gKiBkZXQwMSAtIG1bNV0gKiBkZXQwMyArIG1bN10gKiBkZXQwNSkgLVxyXG4gICAgICAgIG1bM10gKiAobVs0XSAqIGRldDAyIC0gbVs1XSAqIGRldDA0ICsgbVs2XSAqIGRldDA1KTtcclxuXHJcbiAgICAgIHJldHVybiBkZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIGNhcmRpbmFsIHgtYXhpcy5cclxuICAgICAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgZ2V0UmlnaHR9IGluc3RlYWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcmlnaHQoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCByaWdodDogVmVjdG9yMyA9IHRoaXMuZ2V0WCgpO1xyXG4gICAgICByaWdodC5ub3JtYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHJpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbm9ybWFsaXplZCBjYXJkaW5hbCB5LWF4aXMuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIGdldFVwfSBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHVwKCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgdXA6IFZlY3RvcjMgPSB0aGlzLmdldFkoKTtcclxuICAgICAgdXAubm9ybWFsaXplKCk7XHJcbiAgICAgIHJldHVybiB1cDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgY2FyZGluYWwgei1heGlzLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayBnZXRGb3J3YXJkfSBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGZvcndhcmQoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBmb3J3YXJkOiBWZWN0b3IzID0gdGhpcy5nZXRaKCk7XHJcbiAgICAgIGZvcndhcmQubm9ybWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBmb3J3YXJkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGNsb25lIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNsb25lKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiBSZWN5Y2xlci5yZXVzZShNYXRyaXg0eDQpLmNvcHkodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgbWF0cml4IHRvIHRoZSBpZGVudGl0eS1tYXRyaXggYW5kIGNsZWFycyBjYWNoZS4gVXNlZCBieSB0aGUgcmVjeWNsZXIgdG8gcmVzZXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldChcclxuICAgICAgICAxLCAwLCAwLCAwLFxyXG4gICAgICAgIDAsIDEsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMSwgMCxcclxuICAgICAgICAwLCAwLCAwLCAxXHJcbiAgICAgICk7XHJcbiAgICAgIC8vIFRPRE86IHRoaW5rIGFib3V0IHRoaXM6IHNob3VsZCB0aGUgY2FjaGUgYmUgaW5pdGlhbGl6ZWQgYXMgd2VsbD8gVGhpcyB3b3VsZCBjb21lIGluIGhhbmR5IGZvciB3aGVuIHNldHRpbmcgb25seSByb3RhdGlvbiBvciBzY2FsaW5nLi4uXHJcbiAgICAgIC8vIHRoaXMuI3RyYW5zbGF0aW9uLnNldCgwLCAwLCAwKTtcclxuICAgICAgLy8gdGhpcy4jcm90YXRpb24uc2V0KDAsIDAsIDApO1xyXG4gICAgICAvLyB0aGlzLiNzY2FsaW5nLnNldCgxLCAxLCAxKTtcclxuICAgICAgLy8gdGhpcy4jcXVhdGVybmlvbi5zZXQoMCwgMCwgMCwgMSk7XHJcbiAgICAgIC8vIHRoaXMuI3RyYW5zbGF0aW9uRGlydHkgPSBmYWxzZTtcclxuICAgICAgLy8gdGhpcy4jcm90YXRpb25EaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAvLyB0aGlzLiNzY2FsaW5nRGlydHkgPSBmYWxzZTtcclxuICAgICAgLy8gdGhpcy4jcXVhdGVybmlvbkRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIG1hdHJpeCB0byB0aGUgaWRlbnRpdHktbWF0cml4IGFuZCBjbGVhcnMgY2FjaGUuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2V0KCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHRoaXMucmVjeWNsZSgpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zcG9zZSB0aGlzIG1hdHJpeC5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNwb3NlKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiBNYXRyaXg0eDQuVFJBTlNQT1NFKHRoaXMsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW52ZXJ0IHRoaXMgbWF0cml4LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnZlcnQoKTogTWF0cml4NHg0IHtcclxuICAgICAgcmV0dXJuIE1hdHJpeDR4NC5JTlZFUlNFKHRoaXMsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2xhdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgdHJhbnNsYXRpb24gYnkgdGhlIGdpdmVuIHtAbGluayBWZWN0b3IzfSB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqIElmIF9sb2NhbCBpcyB0cnVlLCB0aGUgdHJhbnNsYXRpb24gb2NjdXJzIGFjY29yZGluZyB0byB0aGUgY3VycmVudCByb3RhdGlvbiBhbmQgc2NhbGluZyBvZiB0aGlzIG1hdHJpeCxcclxuICAgICAqIG90aGVyd2lzZSwgaXQgb2NjdXJzIGFjY29yZGluZyB0byB0aGUgcGFyZW50LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGUoX2J5OiBWZWN0b3IzLCBfbG9jYWw6IGJvb2xlYW4gPSB0cnVlKTogTWF0cml4NHg0IHtcclxuICAgICAgaWYgKF9sb2NhbCkge1xyXG4gICAgICAgIGxldCBtdHhUcmFuc2xhdGlvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0LlRSQU5TTEFUSU9OKF9ieSk7XHJcbiAgICAgICAgdGhpcy5tdWx0aXBseShtdHhUcmFuc2xhdGlvbik7XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUobXR4VHJhbnNsYXRpb24pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZGF0YVsxMl0gKz0gX2J5Lng7XHJcbiAgICAgICAgdGhpcy5kYXRhWzEzXSArPSBfYnkueTtcclxuICAgICAgICB0aGlzLmRhdGFbMTRdICs9IF9ieS56O1xyXG4gICAgICAgIHRoaXMubXV0YXRvciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy4jdHJhbnNsYXRpb25EaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZCA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGNvbnN0IG1hdHJpeDogTWF0cml4NHg0ID0gTWF0cml4NHg0Lk1VTFRJUExJQ0FUSU9OKHRoaXMsIE1hdHJpeDR4NC5UUkFOU0xBVElPTihfYnkpKTtcclxuICAgICAgLy8gLy8gVE9ETzogcG9zc2libGUgb3B0aW1pemF0aW9uLCB0cmFuc2xhdGlvbiBtYXkgYWx0ZXIgbXV0YXRvciBpbnN0ZWFkIG9mIGRlbGV0aW5nIGl0LlxyXG4gICAgICAvLyB0aGlzLnNldChtYXRyaXgpO1xyXG4gICAgICAvLyBSZWN5Y2xlci5zdG9yZShtYXRyaXgpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeC1heGlzIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVYKF94OiBudW1iZXIsIF9sb2NhbDogYm9vbGVhbiA9IHRydWUpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgdHJhbnNsYXRpb246IFZlY3RvcjMgPSBWZWN0b3IzLlgoX3gpO1xyXG4gICAgICB0aGlzLnRyYW5zbGF0ZSh0cmFuc2xhdGlvbiwgX2xvY2FsKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgeS1heGlzIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVZKF95OiBudW1iZXIsIF9sb2NhbDogYm9vbGVhbiA9IHRydWUpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgdHJhbnNsYXRpb246IFZlY3RvcjMgPSBWZWN0b3IzLlkoX3kpO1xyXG4gICAgICB0aGlzLnRyYW5zbGF0ZSh0cmFuc2xhdGlvbiwgX2xvY2FsKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgei1heGlzIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGVaKF96OiBudW1iZXIsIF9sb2NhbDogYm9vbGVhbiA9IHRydWUpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgdHJhbnNsYXRpb246IFZlY3RvcjMgPSBWZWN0b3IzLlooX3opO1xyXG4gICAgICB0aGlzLnRyYW5zbGF0ZSh0cmFuc2xhdGlvbiwgX2xvY2FsKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodHJhbnNsYXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBSb3RhdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGVzIHRoaXMgbWF0cml4IGJ5IGdpdmVuIHtAbGluayBWZWN0b3IzfSBpbiB0aGUgb3JkZXIgWiwgWSwgWC4gUmlnaHQgaGFuZCByb3RhdGlvbiBpcyB1c2VkLCB0aHVtYiBwb2ludHMgaW4gYXhpcyBkaXJlY3Rpb24sIGZpbmdlcnMgY3VybGluZyBpbmRpY2F0ZSByb3RhdGlvblxyXG4gICAgICogVGhlIHJvdGF0aW9uIGlzIGFwcGVuZGVkIHRvIGFscmVhZHkgYXBwbGllZCB0cmFuc2Zvcm1zLCB0aHVzIG11bHRpcGxpZWQgZnJvbSB0aGUgcmlnaHQuIFNldCBfZnJvbUxlZnQgdG8gdHJ1ZSB0byBzd2l0Y2ggYW5kIHB1dCBpdCBpbiBmcm9udC5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcm90YXRlKF9ieTogVmVjdG9yMyB8IFF1YXRlcm5pb24sIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IG10eFJvdGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT04oX2J5KTtcclxuICAgICAgdGhpcy5tdWx0aXBseShtdHhSb3RhdGlvbiwgX2Zyb21MZWZ0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4Um90YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSByb3RhdGlvbiBhcm91bmQgdGhlIHgtYXhpcyB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcm90YXRlWChfYW5nbGVJbkRlZ3JlZXM6IG51bWJlciwgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgbXR4Um90YXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTl9YKF9hbmdsZUluRGVncmVlcyk7XHJcbiAgICAgIHRoaXMubXVsdGlwbHkobXR4Um90YXRpb24sIF9mcm9tTGVmdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJvdGF0aW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcm90YXRpb24gYXJvdW5kIHRoZSB5LWF4aXMgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJvdGF0ZVkoX2FuZ2xlSW5EZWdyZWVzOiBudW1iZXIsIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IG10eFJvdGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT05fWShfYW5nbGVJbkRlZ3JlZXMpO1xyXG4gICAgICB0aGlzLm11bHRpcGx5KG10eFJvdGF0aW9uLCBfZnJvbUxlZnQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhSb3RhdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgei1heGlzIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGVaKF9hbmdsZUluRGVncmVlczogbnVtYmVyLCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCBtdHhSb3RhdGlvbjogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJPVEFUSU9OX1ooX2FuZ2xlSW5EZWdyZWVzKTtcclxuICAgICAgdGhpcy5tdWx0aXBseShtdHhSb3RhdGlvbiwgX2Zyb21MZWZ0KTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4Um90YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdHMgdGhlIHJvdGF0aW9uIG9mIHRoaXMgbWF0cml4IHRvIHBvaW50IHRoZSB6LWF4aXMgZGlyZWN0bHkgYXQgdGhlIGdpdmVuIHRhcmdldCBhbmQgdGlsdHMgaXQgdG8gYWNjb3JkIHdpdGggdGhlIGdpdmVuIHVwLXtAbGluayBWZWN0b3IzfSxcclxuICAgICAqIHJlc3BlY3RpdmVseSBjYWxjdWxhdGluZyB5YXcgYW5kIHBpdGNoLiBJZiBubyB1cC17QGxpbmsgVmVjdG9yM30gaXMgZ2l2ZW4sIHRoZSBwcmV2aW91cyB1cC17QGxpbmsgVmVjdG9yM30gaXMgdXNlZC4gXHJcbiAgICAgKiBUaGUgcGl0Y2ggbWF5IGJlIHJlc3RyaWN0ZWQgdG8gdGhlIHVwLXZlY3RvciB0byBvbmx5IGNhbGN1bGF0ZSB5YXcuXHJcbiAgICAgKiBAcGFyYW0gX3VwIEEgdW5pdCB2ZWN0b3IgaW5kaWNhdGluZyB0aGUgdXAtZGlyZWN0aW9uLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi8gLy8gVE9ETzogbWF5YmUgcGFzc2luZyB1cCBzaG91bGQgYmUgbWFuZGF0b3J5LCBkZWZhdWx0IHVwIChsb2NhbCB1cCkgYW5kIGRlZmF1bHQgcmVzdHJpY3QgKGZhbHNlKSBmb3JtIGEgZmVlZGJhY2sgbG9vcCwgYXMgdGhlIGxvY2FsIHVwIGdldHMgbW9kaWZpZWQgZWFjaCBjYWxsLi4uXHJcbiAgICBwdWJsaWMgbG9va0F0KF90YXJnZXQ6IFZlY3RvcjMsIF91cD86IFZlY3RvcjMsIF9yZXN0cmljdDogYm9vbGVhbiA9IGZhbHNlKTogTWF0cml4NHg0IHtcclxuICAgICAgY29uc3QgdXA6IFZlY3RvcjMgPSBfdXAgPyBfdXAgOiB0aGlzLmdldFVwKCk7XHJcbiAgICAgIE1hdHJpeDR4NC5MT09LX0FUKHRoaXMudHJhbnNsYXRpb24sIF90YXJnZXQsIHVwLCBfcmVzdHJpY3QsIHRoaXMuc2NhbGluZywgdGhpcyk7XHJcbiAgICAgIGlmICghX3VwKVxyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKHVwKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3RzIHRoZSByb3RhdGlvbiBvZiB0aGlzIG1hdHJpeCB0byBhbGlnbiB0aGUgei1heGlzIHdpdGggdGhlIGdpdmVuIGZvcndhcmQtZGlyZWN0aW9uIGFuZCB0aWx0cyBpdCB0byBhY2NvcmQgd2l0aCB0aGUgZ2l2ZW4gdXAte0BsaW5rIFZlY3RvcjN9LlxyXG4gICAgICogSWYgbm8gdXAtdmVjdG9yIGlzIHByb3ZpZGVkLCB0aGUgbG9jYWwge0BsaW5rIE1hdHJpeDR4NC5nZXRVcH0gaXMgdXNlZC5cclxuICAgICAqIFRoZSBwaXRjaCBtYXkgYmUgcmVzdHJpY3RlZCB0byB0aGUgdXAtdmVjdG9yIHRvIG9ubHkgY2FsY3VsYXRlIHlhdy5cclxuICAgICAqIEBwYXJhbSBfZm9yd2FyZCBBIHVuaXQgdmVjdG9yIGluZGljYXRpbmcgdGhlIGRlc2lyZWQgZm9yd2FyZC1kaXJlY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gX3VwIEEgdW5pdCB2ZWN0b3IgaW5kaWNhdGluZyB0aGUgdXAtZGlyZWN0aW9uLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi8gLy8gVE9ETzogbWF5YmUgcGFzc2luZyB1cCBzaG91bGQgYmUgbWFuZGF0b3J5LCBkZWZhdWx0IHVwIChsb2NhbCB1cCkgYW5kIGRlZmF1bHQgcmVzdHJpY3QgKGZhbHNlKSBmb3JtIGEgZmVlZGJhY2sgbG9vcCwgYXMgdGhlIGxvY2FsIHVwIGdldHMgbW9kaWZpZWQgZWFjaCBjYWxsLi4uXHJcbiAgICBwdWJsaWMgbG9va0luKF9mb3J3YXJkOiBWZWN0b3IzLCBfdXA/OiBWZWN0b3IzLCBfcmVzdHJpY3Q6IGJvb2xlYW4gPSBmYWxzZSk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGNvbnN0IHVwOiBWZWN0b3IzID0gX3VwID8gX3VwIDogdGhpcy5nZXRVcCgpO1xyXG4gICAgICBNYXRyaXg0eDQuTE9PS19JTihfZm9yd2FyZCwgdXAsIF9yZXN0cmljdCwgdGhpcy50cmFuc2xhdGlvbiwgdGhpcy5zY2FsaW5nLCB0aGlzKTtcclxuICAgICAgaWYgKCFfdXApXHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUodXApO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNhbWUgYXMge0BsaW5rIE1hdHJpeDR4NC5sb29rQXR9LCBidXQgb3B0aW1pemVkIGFuZCBuZWVkcyB0ZXN0aW5nXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IHRlc3RpbmcgbG9va2F0IHRoYXQgcmVhbGx5IGp1c3Qgcm90YXRlcyB0aGUgbWF0cml4IHJhdGhlciB0aGFuIGNyZWF0aW5nIGEgbmV3IG9uZVxyXG4gICAgLy8gcHVibGljIGxvb2tBdFJvdGF0ZShfdGFyZ2V0OiBWZWN0b3IzLCBfdXA/OiBWZWN0b3IzLCBfcHJlc2VydmVTY2FsaW5nOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgLy8gICBpZiAoIV91cClcclxuICAgIC8vICAgICBfdXAgPSB0aGlzLmdldFkoKTtcclxuXHJcbiAgICAvLyAgIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gdGhpcy5zY2FsaW5nO1xyXG4gICAgLy8gICBsZXQgZGlmZmVyZW5jZTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfdGFyZ2V0LCB0aGlzLnRyYW5zbGF0aW9uKTtcclxuICAgIC8vICAgZGlmZmVyZW5jZS5ub3JtYWxpemUoKTtcclxuICAgIC8vICAgbGV0IGNvczogbnVtYmVyID0gVmVjdG9yMy5ET1QoVmVjdG9yMy5OT1JNQUxJWkFUSU9OKHRoaXMuZ2V0WigpKSwgZGlmZmVyZW5jZSk7XHJcbiAgICAvLyAgIGxldCBzaW46IG51bWJlciA9IFZlY3RvcjMuRE9UKFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLmdldFgoKSksIGRpZmZlcmVuY2UpO1xyXG4gICAgLy8gICAvLyBjb25zb2xlLmxvZyhzaW4sIGNvcyk7XHJcbiAgICAvLyAgIGxldCBtdHhSb3RhdGlvbjogTWF0cml4NHg0ID0gUmVjeWNsZXIuZ2V0KE1hdHJpeDR4NCk7XHJcbiAgICAvLyAgIG10eFJvdGF0aW9uLmRhdGEuc2V0KFtcclxuICAgIC8vICAgICBjb3MsIDAsIC1zaW4sIDAsXHJcbiAgICAvLyAgICAgMCwgMSwgMCwgMCxcclxuICAgIC8vICAgICBzaW4sIDAsIGNvcywgMCxcclxuICAgIC8vICAgICAwLCAwLCAwLCAxXHJcbiAgICAvLyAgIF0pO1xyXG4gICAgLy8gICB0aGlzLm11bHRpcGx5KG10eFJvdGF0aW9uLCBmYWxzZSk7XHJcblxyXG4gICAgLy8gICBjb3MgPSBWZWN0b3IzLkRPVChWZWN0b3IzLk5PUk1BTElaQVRJT04odGhpcy5nZXRaKCkpLCBkaWZmZXJlbmNlKTtcclxuICAgIC8vICAgc2luID0gLVZlY3RvcjMuRE9UKFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLmdldFkoKSksIGRpZmZlcmVuY2UpO1xyXG4gICAgLy8gICAvLyBjb25zb2xlLmxvZyhzaW4sIGNvcyk7XHJcbiAgICAvLyAgIG10eFJvdGF0aW9uLmRhdGEuc2V0KFtcclxuICAgIC8vICAgICAxLCAwLCAwLCAwLFxyXG4gICAgLy8gICAgIDAsIGNvcywgc2luLCAwLFxyXG4gICAgLy8gICAgIDAsIC1zaW4sIGNvcywgMCxcclxuICAgIC8vICAgICAwLCAwLCAwLCAxXHJcbiAgICAvLyAgIF0pO1xyXG4gICAgLy8gICB0aGlzLm11bHRpcGx5KG10eFJvdGF0aW9uLCBmYWxzZSk7XHJcbiAgICAvLyAgIHRoaXMuc2NhbGluZyA9IHNjYWxpbmc7XHJcbiAgICAvLyAgIFJlY3ljbGVyLnN0b3JlKG10eFJvdGF0aW9uKTtcclxuICAgIC8vIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTY2FsaW5nXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzY2FsaW5nIGJ5IHRoZSBnaXZlbiB7QGxpbmsgVmVjdG9yM30gdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlKF9ieTogVmVjdG9yMywgX2Zyb21MZWZ0OiBib29sZWFuID0gZmFsc2UpOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBtdHhTY2FsaW5nOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuU0NBTElORyhfYnkpO1xyXG4gICAgICB0aGlzLm11bHRpcGx5KG10eFNjYWxpbmcsIF9mcm9tTGVmdCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFNjYWxpbmcpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzY2FsaW5nIGFsb25nIHRoZSB4LWF4aXMgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlWChfYnk6IG51bWJlcik6IE1hdHJpeDR4NCB7XHJcbiAgICAgIGxldCB2ZWN0b3I6IFZlY3RvcjMgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKTtcclxuICAgICAgdmVjdG9yLnNldChfYnksIDEsIDEpO1xyXG4gICAgICB0aGlzLnNjYWxlKHZlY3Rvcik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHZlY3Rvcik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHNjYWxpbmcgYWxvbmcgdGhlIHktYXhpcyB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGVZKF9ieTogbnVtYmVyKTogTWF0cml4NHg0IHtcclxuICAgICAgbGV0IHZlY3RvcjogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpO1xyXG4gICAgICB2ZWN0b3Iuc2V0KDEsIF9ieSwgMSk7XHJcbiAgICAgIHRoaXMuc2NhbGUodmVjdG9yKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUodmVjdG9yKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgc2NhbGluZyBhbG9uZyB0aGUgei1heGlzIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVooX2J5OiBudW1iZXIpOiBNYXRyaXg0eDQge1xyXG4gICAgICBsZXQgdmVjdG9yOiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMyk7XHJcbiAgICAgIHZlY3Rvci5zZXQoMSwgMSwgX2J5KTtcclxuICAgICAgdGhpcy5zY2FsZSh2ZWN0b3IpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh2ZWN0b3IpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2Zvcm1hdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBseSB0aGlzIG1hdHJpeCBieSB0aGUgZ2l2ZW4gbWF0cml4LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtdWx0aXBseShfbWF0cml4OiBNYXRyaXg0eDQsIF9mcm9tTGVmdDogYm9vbGVhbiA9IGZhbHNlKTogTWF0cml4NHg0IHtcclxuICAgICAgaWYgKF9mcm9tTGVmdClcclxuICAgICAgICByZXR1cm4gTWF0cml4NHg0LlBST0RVQ1QoX21hdHJpeCwgdGhpcywgdGhpcyk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gTWF0cml4NHg0LlBST0RVQ1QodGhpcywgX21hdHJpeCwgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVtdWx0aXBseSB0aGlzIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBtYXRyaXguXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHByZW11bHRpcGx5KF9tdHhMZWZ0OiBNYXRyaXg0eDQpOiBNYXRyaXg0eDQge1xyXG4gICAgICByZXR1cm4gTWF0cml4NHg0LlBST0RVQ1QoX210eExlZnQsIHRoaXMsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICAvKipcclxuICAgICAqIChSZS0pQ29tcG9zZSB0aGlzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiB0cmFuc2xhdGlvbiwgcm90YXRpb24gYW5kIHNjYWxpbmcuIFxyXG4gICAgICogTWlzc2luZyB2YWx1ZXMgd2lsbCBiZSBkZWNvbXBzZWQgZnJvbSB0aGUgY3VycmVudCBtYXRyaXggc3RhdGUgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb21wb3NlKF90cmFuc2xhdGlvbj86IFBhcnRpYWw8VmVjdG9yMz4sIF9yb3RhdGlvbj86IFBhcnRpYWw8VmVjdG9yMz4gfCBQYXJ0aWFsPFF1YXRlcm5pb24+LCBfc2NhbGluZz86IFBhcnRpYWw8VmVjdG9yMz4pOiBNYXRyaXg0eDQge1xyXG4gICAgICBjb25zdCBtOiBGbG9hdDMyQXJyYXkgPSB0aGlzLmRhdGE7XHJcblxyXG4gICAgICBpZiAoX3RyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNsYXRpb246IFZlY3RvcjMgPSB0aGlzLnRyYW5zbGF0aW9uO1xyXG4gICAgICAgIHRyYW5zbGF0aW9uLm11dGF0ZShfdHJhbnNsYXRpb24pO1xyXG4gICAgICAgIG1bMTJdID0gdHJhbnNsYXRpb24ueDtcclxuICAgICAgICBtWzEzXSA9IHRyYW5zbGF0aW9uLnk7XHJcbiAgICAgICAgbVsxNF0gPSB0cmFuc2xhdGlvbi56O1xyXG4gICAgICAgIHRoaXMuI3RyYW5zbGF0aW9uRGlydHkgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKF9yb3RhdGlvbiB8fCBfc2NhbGluZykge1xyXG4gICAgICAgIGNvbnN0IGlzUXVhdGVybmlvbjogYm9vbGVhbiA9ICg8UXVhdGVybmlvbj5fcm90YXRpb24pPy53ICE9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgY29uc3Qgcm90YXRpb246IFZlY3RvcjMgfCBRdWF0ZXJuaW9uID0gaXNRdWF0ZXJuaW9uID8gdGhpcy5xdWF0ZXJuaW9uIDogdGhpcy5yb3RhdGlvbjtcclxuICAgICAgICBpZiAoX3JvdGF0aW9uKSB7XHJcbiAgICAgICAgICByb3RhdGlvbi5tdXRhdGUoX3JvdGF0aW9uKTtcclxuICAgICAgICAgIGlmIChpc1F1YXRlcm5pb24pXHJcbiAgICAgICAgICAgIHJvdGF0aW9uLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGluZzogVmVjdG9yMyA9IHRoaXMuc2NhbGluZztcclxuICAgICAgICBpZiAoX3NjYWxpbmcpXHJcbiAgICAgICAgICBzY2FsaW5nLm11dGF0ZShfc2NhbGluZyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHN4OiBudW1iZXIgPSBzY2FsaW5nLngsIHN5OiBudW1iZXIgPSBzY2FsaW5nLnksIHN6OiBudW1iZXIgPSBzY2FsaW5nLno7XHJcbiAgICAgICAgaWYgKGlzUXVhdGVybmlvbikge1xyXG4gICAgICAgICAgLy8gZmFzdCBhbGdvcml0aG0gZnJvbSB0aHJlZS5qc1xyXG4gICAgICAgICAgY29uc3QgeDogbnVtYmVyID0gKDxRdWF0ZXJuaW9uPnJvdGF0aW9uKS54LCB5OiBudW1iZXIgPSAoPFF1YXRlcm5pb24+cm90YXRpb24pLnksIHo6IG51bWJlciA9ICg8UXVhdGVybmlvbj5yb3RhdGlvbikueiwgdzogbnVtYmVyID0gKDxRdWF0ZXJuaW9uPnJvdGF0aW9uKS53O1xyXG4gICAgICAgICAgY29uc3QgeDI6IG51bWJlciA9IHggKyB4LCB5MjogbnVtYmVyID0geSArIHksIHoyOiBudW1iZXIgPSB6ICsgejtcclxuICAgICAgICAgIGNvbnN0IHh4OiBudW1iZXIgPSB4ICogeDIsIHh5OiBudW1iZXIgPSB4ICogeTIsIHh6OiBudW1iZXIgPSB4ICogejI7XHJcbiAgICAgICAgICBjb25zdCB5eTogbnVtYmVyID0geSAqIHkyLCB5ejogbnVtYmVyID0geSAqIHoyLCB6ejogbnVtYmVyID0geiAqIHoyO1xyXG4gICAgICAgICAgY29uc3Qgd3g6IG51bWJlciA9IHcgKiB4Miwgd3k6IG51bWJlciA9IHcgKiB5Miwgd3o6IG51bWJlciA9IHcgKiB6MjtcclxuXHJcbiAgICAgICAgICBtWzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XHJcbiAgICAgICAgICBtWzFdID0gKHh5ICsgd3opICogc3g7XHJcbiAgICAgICAgICBtWzJdID0gKHh6IC0gd3kpICogc3g7XHJcblxyXG4gICAgICAgICAgbVs0XSA9ICh4eSAtIHd6KSAqIHN5O1xyXG4gICAgICAgICAgbVs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xyXG4gICAgICAgICAgbVs2XSA9ICh5eiArIHd4KSAqIHN5O1xyXG5cclxuICAgICAgICAgIG1bOF0gPSAoeHogKyB3eSkgKiBzejtcclxuICAgICAgICAgIG1bOV0gPSAoeXogLSB3eCkgKiBzejtcclxuICAgICAgICAgIG1bMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnN0IHJhZFg6IG51bWJlciA9IHJvdGF0aW9uLnggKiBDYWxjLmRlZzJyYWQ7XHJcbiAgICAgICAgICBjb25zdCByYWRZOiBudW1iZXIgPSByb3RhdGlvbi55ICogQ2FsYy5kZWcycmFkO1xyXG4gICAgICAgICAgY29uc3QgcmFkWjogbnVtYmVyID0gcm90YXRpb24ueiAqIENhbGMuZGVnMnJhZDtcclxuXHJcbiAgICAgICAgICBjb25zdCBzaW5YOiBudW1iZXIgPSBNYXRoLnNpbihyYWRYKTtcclxuICAgICAgICAgIGNvbnN0IGNvc1g6IG51bWJlciA9IE1hdGguY29zKHJhZFgpO1xyXG4gICAgICAgICAgY29uc3Qgc2luWTogbnVtYmVyID0gTWF0aC5zaW4ocmFkWSk7XHJcbiAgICAgICAgICBjb25zdCBjb3NZOiBudW1iZXIgPSBNYXRoLmNvcyhyYWRZKTtcclxuICAgICAgICAgIGNvbnN0IHNpblo6IG51bWJlciA9IE1hdGguc2luKHJhZFopO1xyXG4gICAgICAgICAgY29uc3QgY29zWjogbnVtYmVyID0gTWF0aC5jb3MocmFkWik7XHJcblxyXG4gICAgICAgICAgbVswXSA9IChjb3NaICogY29zWSkgKiBzeDtcclxuICAgICAgICAgIG1bMV0gPSAoc2luWiAqIGNvc1kpICogc3g7XHJcbiAgICAgICAgICBtWzJdID0gLXNpblkgKiBzeDtcclxuXHJcbiAgICAgICAgICBtWzRdID0gKGNvc1ogKiBzaW5ZICogc2luWCAtIHNpblogKiBjb3NYKSAqIHN5O1xyXG4gICAgICAgICAgbVs1XSA9IChzaW5aICogc2luWSAqIHNpblggKyBjb3NaICogY29zWCkgKiBzeTtcclxuICAgICAgICAgIG1bNl0gPSAoY29zWSAqIHNpblgpICogc3k7XHJcblxyXG4gICAgICAgICAgbVs4XSA9IChjb3NaICogc2luWSAqIGNvc1ggKyBzaW5aICogc2luWCkgKiBzejtcclxuICAgICAgICAgIG1bOV0gPSAoc2luWiAqIHNpblkgKiBjb3NYIC0gY29zWiAqIHNpblgpICogc3o7XHJcbiAgICAgICAgICBtWzEwXSA9IChjb3NZICogY29zWCkgKiBzejtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuI3JvdGF0aW9uRGlydHkgPSBpc1F1YXRlcm5pb247XHJcbiAgICAgICAgdGhpcy4jcXVhdGVybmlvbkRpcnR5ID0gIWlzUXVhdGVybmlvbjtcclxuICAgICAgICB0aGlzLiNzY2FsaW5nRGlydHkgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5tdXRhdG9yID0gbnVsbDtcclxuICAgICAgdGhpcy5tb2RpZmllZCA9IHRydWU7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IHRvIHRoZSBnaXZlbiBhcnJheSBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRBcnJheShfYXJyYXk6IEFycmF5TGlrZTxudW1iZXI+LCBfb2Zmc2V0OiBudW1iZXIgPSAwKTogTWF0cml4NHg0IHtcclxuICAgICAgdGhpcy5kYXRhLnNldChfYXJyYXksIF9vZmZzZXQpO1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBlbGVtZW50cyBvZiB0aGlzIG1hdHJpeCB0byB0aGUgZ2l2ZW4gdmFsdWVzLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX20wMDogbnVtYmVyLCBfbTAxOiBudW1iZXIsIF9tMDI6IG51bWJlciwgX20wMzogbnVtYmVyLCBfbTEwOiBudW1iZXIsIF9tMTE6IG51bWJlciwgX20xMjogbnVtYmVyLCBfbTEzOiBudW1iZXIsIF9tMjA6IG51bWJlciwgX20yMTogbnVtYmVyLCBfbTIyOiBudW1iZXIsIF9tMjM6IG51bWJlciwgX20zMDogbnVtYmVyLCBfbTMxOiBudW1iZXIsIF9tMzI6IG51bWJlciwgX20zMzogbnVtYmVyKTogTWF0cml4NHg0IHtcclxuICAgICAgY29uc3QgbTogRmxvYXQzMkFycmF5ID0gdGhpcy5kYXRhO1xyXG5cclxuICAgICAgbVswXSA9IF9tMDA7IG1bMV0gPSBfbTAxOyBtWzJdID0gX20wMjsgbVszXSA9IF9tMDM7XHJcbiAgICAgIG1bNF0gPSBfbTEwOyBtWzVdID0gX20xMTsgbVs2XSA9IF9tMTI7IG1bN10gPSBfbTEzO1xyXG4gICAgICBtWzhdID0gX20yMDsgbVs5XSA9IF9tMjE7IG1bMTBdID0gX20yMjsgbVsxMV0gPSBfbTIzO1xyXG4gICAgICBtWzEyXSA9IF9tMzA7IG1bMTNdID0gX20zMTsgbVsxNF0gPSBfbTMyOyBtWzE1XSA9IF9tMzM7XHJcblxyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgdGhlIHN0YXRlIG9mIHRoZSBnaXZlbiBtYXRyaXggaW50byB0aGlzIG1hdHJpeC5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29weShfb3JpZ2luYWw6IE1hdHJpeDR4NCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHRoaXMuZGF0YS5zZXQoX29yaWdpbmFsLmRhdGEpO1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgICB0aGlzLm1vZGlmaWVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy4jdHJhbnNsYXRpb25EaXJ0eSA9IF9vcmlnaW5hbC4jdHJhbnNsYXRpb25EaXJ0eTtcclxuICAgICAgdGhpcy4jcm90YXRpb25EaXJ0eSA9IF9vcmlnaW5hbC4jcm90YXRpb25EaXJ0eTtcclxuICAgICAgdGhpcy4jc2NhbGluZ0RpcnR5ID0gX29yaWdpbmFsLiNzY2FsaW5nRGlydHk7XHJcbiAgICAgIHRoaXMuI3F1YXRlcm5pb25EaXJ0eSA9IF9vcmlnaW5hbC4jcXVhdGVybmlvbkRpcnR5O1xyXG4gICAgICBpZiAoIXRoaXMuI3RyYW5zbGF0aW9uRGlydHkpXHJcbiAgICAgICAgdGhpcy4jdHJhbnNsYXRpb24uY29weShfb3JpZ2luYWwuI3RyYW5zbGF0aW9uKTtcclxuICAgICAgaWYgKCF0aGlzLiNyb3RhdGlvbkRpcnR5KVxyXG4gICAgICAgIHRoaXMuI3JvdGF0aW9uLmNvcHkoX29yaWdpbmFsLiNyb3RhdGlvbik7XHJcbiAgICAgIGlmICghdGhpcy4jc2NhbGluZ0RpcnR5KVxyXG4gICAgICAgIHRoaXMuI3NjYWxpbmcuY29weShfb3JpZ2luYWwuI3NjYWxpbmcpO1xyXG4gICAgICBpZiAoIXRoaXMuI3F1YXRlcm5pb25EaXJ0eSlcclxuICAgICAgICB0aGlzLiNxdWF0ZXJuaW9uLmNvcHkoX29yaWdpbmFsLiNxdWF0ZXJuaW9uKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGDGki5NYXRyaXg0eDQodHJhbnNsYXRpb246ICR7dGhpcy50cmFuc2xhdGlvbi50b1N0cmluZygpfSwgcm90YXRpb246ICR7dGhpcy5yb3RhdGlvbi50b1N0cmluZygpfSwgc2NhbGluZzogJHt0aGlzLnNjYWxpbmcudG9TdHJpbmcoKX1gO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29weXMgdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IGludG8gdGhlIGdpdmVuIGFycmF5IHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBvZmZzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGUgZ2l2ZW4gYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b0FycmF5PFQgZXh0ZW5kcyB7IFtuOiBudW1iZXJdOiBudW1iZXIgfT4oX291dDogVCwgX29mZnNldDogbnVtYmVyID0gMCk6IFQge1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgMTY7IGkrKylcclxuICAgICAgICBfb3V0W19vZmZzZXQgKyBpXSA9IHRoaXMuZGF0YVtpXTtcclxuXHJcbiAgICAgIHJldHVybiBfb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4LlxyXG4gICAgICogQHJldHVybnMgQSByZWFkb25seSB2aWV3IG9mIHRoZSBpbnRlcm5hbCBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEFycmF5KCk6IEFycmF5TGlrZTxudW1iZXI+ICYgSXRlcmFibGU8bnVtYmVyPiAmIEFycmF5QnVmZmVyVmlldyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogUmV0dXJucyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhpcyBtYXRyaXguXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RGV0ZXJtaW5hbnQoKTogbnVtYmVyIHtcclxuICAgICAgY29uc3QgbTogRmxvYXQzMkFycmF5ID0gdGhpcy5kYXRhO1xyXG5cclxuICAgICAgY29uc3QgZGV0MDA6IG51bWJlciA9IG1bMTBdICogbVsxNV0gLSBtWzExXSAqIG1bMTRdO1xyXG4gICAgICBjb25zdCBkZXQwMTogbnVtYmVyID0gbVs5XSAqIG1bMTVdIC0gbVsxMV0gKiBtWzEzXTtcclxuICAgICAgY29uc3QgZGV0MDI6IG51bWJlciA9IG1bOV0gKiBtWzE0XSAtIG1bMTBdICogbVsxM107XHJcbiAgICAgIGNvbnN0IGRldDAzOiBudW1iZXIgPSBtWzhdICogbVsxNV0gLSBtWzExXSAqIG1bMTJdO1xyXG4gICAgICBjb25zdCBkZXQwNDogbnVtYmVyID0gbVs4XSAqIG1bMTRdIC0gbVsxMF0gKiBtWzEyXTtcclxuICAgICAgY29uc3QgZGV0MDU6IG51bWJlciA9IG1bOF0gKiBtWzEzXSAtIG1bOV0gKiBtWzEyXTtcclxuXHJcbiAgICAgIGNvbnN0IGRldDogbnVtYmVyID1cclxuICAgICAgICBtWzBdICogKG1bNV0gKiBkZXQwMCAtIG1bNl0gKiBkZXQwMSArIG1bN10gKiBkZXQwMikgLVxyXG4gICAgICAgIG1bMV0gKiAobVs0XSAqIGRldDAwIC0gbVs2XSAqIGRldDAzICsgbVs3XSAqIGRldDA0KSArXHJcbiAgICAgICAgbVsyXSAqIChtWzRdICogZGV0MDEgLSBtWzVdICogZGV0MDMgKyBtWzddICogZGV0MDUpIC1cclxuICAgICAgICBtWzNdICogKG1bNF0gKiBkZXQwMiAtIG1bNV0gKiBkZXQwNCArIG1bNl0gKiBkZXQwNSk7XHJcblxyXG4gICAgICByZXR1cm4gZGV0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHgtYXhpcy5cclxuICAgICAqIEBwYXJhbSBfdmN0T3V0IE9wdGlvbmFsIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0WChfdmN0T3V0OiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMykpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIF92Y3RPdXQuc2V0KHRoaXMuZGF0YVswXSwgdGhpcy5kYXRhWzFdLCB0aGlzLmRhdGFbMl0pOztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNhcmRpbmFsIHktYXhpcy5cclxuICAgICAqIEBwYXJhbSBfdmN0T3V0IE9wdGlvbmFsIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0WShfdmN0T3V0OiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMykpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIF92Y3RPdXQuc2V0KHRoaXMuZGF0YVs0XSwgdGhpcy5kYXRhWzVdLCB0aGlzLmRhdGFbNl0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gY2FyZGluYWwgei1heGlzLlxyXG4gICAgICogQHBhcmFtIF92Y3RPdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRaKF92Y3RPdXQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKSk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gX3ZjdE91dC5zZXQodGhpcy5kYXRhWzhdLCB0aGlzLmRhdGFbOV0sIHRoaXMuZGF0YVsxMF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbm9ybWFsaXplZCBjYXJkaW5hbCB4LWF4aXMuXHJcbiAgICAgKiBAcGFyYW0gX3ZjdE91dCBPcHRpb25hbCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFJpZ2h0KF92Y3RPdXQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKSk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gX3ZjdE91dC5zZXQodGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbMV0sIHRoaXMuZGF0YVsyXSkubm9ybWFsaXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIGNhcmRpbmFsIHktYXhpcy5cclxuICAgICAqIEBwYXJhbSBfdmN0T3V0IE9wdGlvbmFsIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VXAoX3ZjdE91dDogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBfdmN0T3V0LnNldCh0aGlzLmRhdGFbNF0sIHRoaXMuZGF0YVs1XSwgdGhpcy5kYXRhWzZdKS5ub3JtYWxpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgY2FyZGluYWwgei1heGlzLlxyXG4gICAgICogQHBhcmFtIF92Y3RPdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRGb3J3YXJkKF92Y3RPdXQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKSk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gX3ZjdE91dC5zZXQodGhpcy5kYXRhWzhdLCB0aGlzLmRhdGFbOV0sIHRoaXMuZGF0YVsxMF0pLm5vcm1hbGl6ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3dhcHMgdGhlIHR3byBjYXJkaW5hbCBheGlzIGFuZCByZXZlcnNlcyB0aGUgdGhpcmQsIGVmZmVjdGl2ZWx5IHJvdGF0aW5nIHRoZSB0cmFuc2Zvcm0gMTgwIGRlZ3JlZXMgYXJvdW5kIG9uZSBhbmQgOTAgZGVncmVlcyBhcm91bmQgYSBzZWNvbmQgYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3dhcFhZKCk6IHZvaWQge1xyXG4gICAgICBjb25zdCBtOiBGbG9hdDMyQXJyYXkgPSB0aGlzLmRhdGE7XHJcbiAgICAgIGNvbnN0IHhBeGlzOiBWZWN0b3IzID0gdGhpcy5nZXRYKCk7IC8vIHN0b3JlIHgtYXhpc1xyXG4gICAgICBtWzRdID0geEF4aXMueDsgbVs1XSA9IHhBeGlzLnk7IG1bNl0gPSB4QXhpcy56OyAvLyBvdmVyd3JpdGUgeS1heGlzIHdpdGggeC1heGlzXHJcbiAgICAgIG1bMF0gPSBtWzRdOyBtWzFdID0gbVs1XTsgbVsyXSA9IG1bNl07IC8vIG92ZXJ3cml0ZSB4LWF4aXMgd2l0aCB5LWF4aXNcclxuICAgICAgbVs4XSA9IC1tWzhdOyBtWzldID0gLW1bOV07IG1bMTBdID0gLW1bMTBdOyAvLyByZXZlcnNlIHotYXhpc1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh4QXhpcyk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3dhcHMgdGhlIHR3byBjYXJkaW5hbCBheGlzIGFuZCByZXZlcnNlcyB0aGUgdGhpcmQsIGVmZmVjdGl2ZWx5IHJvdGF0aW5nIHRoZSB0cmFuc2Zvcm0gMTgwIGRlZ3JlZXMgYXJvdW5kIG9uZSBhbmQgOTAgZGVncmVlcyBhcm91bmQgYSBzZWNvbmQgYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3dhcFhaKCk6IHZvaWQge1xyXG4gICAgICBjb25zdCBtOiBGbG9hdDMyQXJyYXkgPSB0aGlzLmRhdGE7XHJcbiAgICAgIGNvbnN0IHhBeGlzOiBWZWN0b3IzID0gdGhpcy5nZXRYKCk7IC8vIHN0b3JlIHgtYXhpc1xyXG4gICAgICBtWzRdID0gLW1bNF07IG1bNV0gPSAtbVs1XTsgbVs2XSA9IC1tWzZdOyAvLyByZXZlcnNlIHktYXhpc1xyXG4gICAgICBtWzBdID0gbVs4XTsgbVsxXSA9IG1bOV07IG1bMl0gPSBtWzEwXTsgLy8gb3ZlcndyaXRlIHgtYXhpcyB3aXRoIHotYXhpc1xyXG4gICAgICBtWzhdID0geEF4aXMueDsgbVs5XSA9IHhBeGlzLnk7IG1bMTBdID0geEF4aXMuejsgLy8gb3ZlcndyaXRlIHotYXhpcyB3aXRoIHgtYXhpc1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh4QXhpcyk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3dhcHMgdGhlIHR3byBjYXJkaW5hbCBheGlzIGFuZCByZXZlcnNlcyB0aGUgdGhpcmQsIGVmZmVjdGl2ZWx5IHJvdGF0aW5nIHRoZSB0cmFuc2Zvcm0gMTgwIGRlZ3JlZXMgYXJvdW5kIG9uZSBhbmQgOTAgZGVncmVlcyBhcm91bmQgYSBzZWNvbmQgYXhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3dhcFlaKCk6IHZvaWQge1xyXG4gICAgICBjb25zdCBtOiBGbG9hdDMyQXJyYXkgPSB0aGlzLmRhdGE7XHJcbiAgICAgIGNvbnN0IHlBeGlzOiBWZWN0b3IzID0gdGhpcy5nZXRZKCk7IC8vIHN0b3JlIHktYXhpc1xyXG4gICAgICBtWzBdID0gLW1bMF07IG1bMV0gPSAtbVsxXTsgbVsyXSA9IC1tWzJdOyAvLyByZXZlcnNlIHgtYXhpc1xyXG4gICAgICBtWzRdID0gbVs4XTsgbVs1XSA9IG1bOV07IG1bNl0gPSBtWzEwXTsgLy8gb3ZlcndyaXRlIHktYXhpcyB3aXRoIHotYXhpc1xyXG4gICAgICBtWzhdID0geUF4aXMueDsgbVs5XSA9IHlBeGlzLnk7IG1bMTBdID0geUF4aXMuejsgLy8gb3ZlcndyaXRlIHotYXhpcyB3aXRoIHktYXhpc1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZSh5QXhpcyk7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdHJhbmxhdGlvbiBmcm9tIHRoaXMgbWF0cml4IHRvIHRoZSB0YXJnZXQgbWF0cml4LlxyXG4gICAgICogQHBhcmFtIF92Y3RPdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUcmFuc2xhdGlvblRvKF9tdHhUYXJnZXQ6IE1hdHJpeDR4NCwgX3ZjdE91dDogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBfdmN0T3V0LnNldChfbXR4VGFyZ2V0LmRhdGFbMTJdIC0gdGhpcy5kYXRhWzEyXSwgX210eFRhcmdldC5kYXRhWzEzXSAtIHRoaXMuZGF0YVsxM10sIF9tdHhUYXJnZXQuZGF0YVsxNF0gLSB0aGlzLmRhdGFbMTRdKTs7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgLy8gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIHRyYW5zbGF0aW9uOiB0aGlzLnRyYW5zbGF0aW9uLnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLnNlcmlhbGl6ZSgpLFxyXG4gICAgICAgIHNjYWxpbmc6IHRoaXMuc2NhbGluZy5zZXJpYWxpemUoKVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHRyYW5zbGF0aW9uOiBhd2FpdCB0aGlzLnRyYW5zbGF0aW9uLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnRyYW5zbGF0aW9uKSxcclxuICAgICAgICByb3RhdGlvbjogYXdhaXQgdGhpcy5yb3RhdGlvbi5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5yb3RhdGlvbiksXHJcbiAgICAgICAgc2NhbGluZzogYXdhaXQgdGhpcy5zY2FsaW5nLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLnNjYWxpbmcpXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMubXV0YXRlKG11dGF0b3IpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgaWYgKHRoaXMubXV0YXRvcilcclxuICAgICAgICByZXR1cm4gdGhpcy5tdXRhdG9yO1xyXG5cclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XHJcbiAgICAgICAgdHJhbnNsYXRpb246IHRoaXMudHJhbnNsYXRpb24uZ2V0TXV0YXRvcigpLFxyXG4gICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLmdldE11dGF0b3IoKSxcclxuICAgICAgICBzY2FsaW5nOiB0aGlzLnNjYWxpbmcuZ2V0TXV0YXRvcigpXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBjYWNoZSBtdXRhdG9yXHJcbiAgICAgIHRoaXMubXV0YXRvciA9IG11dGF0b3I7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvdmVycmlkZSBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgdGhpcy5jb21wb3NlKF9tdXRhdG9yLnRyYW5zbGF0aW9uLCBfbXV0YXRvci5yb3RhdGlvbiwgX211dGF0b3Iuc2NhbGluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0ge307XHJcbiAgICAgIGlmIChfbXV0YXRvci50cmFuc2xhdGlvbikgdHlwZXMudHJhbnNsYXRpb24gPSBcIlZlY3RvcjNcIjtcclxuICAgICAgaWYgKF9tdXRhdG9yLnJvdGF0aW9uKSB0eXBlcy5yb3RhdGlvbiA9IFwiVmVjdG9yM1wiO1xyXG4gICAgICBpZiAoX211dGF0b3Iuc2NhbGluZykgdHlwZXMuc2NhbGluZyA9IFwiVmVjdG9yM1wiO1xyXG4gICAgICByZXR1cm4gdHlwZXM7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQgey8qKiAqLyB9XHJcblxyXG4gICAgcHJpdmF0ZSByZXNldENhY2hlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLiN0cmFuc2xhdGlvbkRpcnR5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy4jcm90YXRpb25EaXJ0eSA9IHRydWU7XHJcbiAgICAgIHRoaXMuI3F1YXRlcm5pb25EaXJ0eSA9IHRydWU7XHJcbiAgICAgIHRoaXMuI3NjYWxpbmdEaXJ0eSA9IHRydWU7XHJcbiAgICAgIHRoaXMubW9kaWZpZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyNlbmRyZWdpb25cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQmFzZWNsYXNzIGZvciBOb2lzZTIsIE5vaXNlMyBhbmQgTm9pc2U0XHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKiBUaGlzIGlzIGFuIGFkYXB0aW9uIG9mIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2Zhc3Qtc2ltcGxleC1ub2lzZVxyXG4gICAqL1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBOb2lzZSB7XHJcbiAgICBwcm90ZWN0ZWQgcGVybTogVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDUxMik7XHJcbiAgICBwcm90ZWN0ZWQgcGVybU1vZDEyOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoNTEyKTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tIHZhbHVlIGJldHdlZW4gLTEgYW5kIDEgYmFzZWQgb24gdGhlIGdpdmVuIHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBzYW1wbGU6ICguLi5fYXJnczogbnVtYmVyW10pID0+IG51bWJlcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3JhbmRvbTogRnVuY3Rpb24gPSBNYXRoLnJhbmRvbSkge1xyXG4gICAgICBjb25zdCBwOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IDI1NjsgaSsrKVxyXG4gICAgICAgIHBbaV0gPSBpO1xyXG5cclxuICAgICAgbGV0IG46IG51bWJlcjtcclxuICAgICAgbGV0IHE6IG51bWJlcjtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMjU1OyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgbiA9IE1hdGguZmxvb3IoKGkgKyAxKSAqIF9yYW5kb20oKSk7XHJcbiAgICAgICAgcSA9IHBbaV07XHJcbiAgICAgICAgcFtpXSA9IHBbbl07XHJcbiAgICAgICAgcFtuXSA9IHE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCA1MTI7IGkrKykge1xyXG4gICAgICAgIHRoaXMucGVybVtpXSA9IHBbaSAmIDI1NV07XHJcbiAgICAgICAgdGhpcy5wZXJtTW9kMTJbaV0gPSB0aGlzLnBlcm1baV0gJSAxMjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi9Ob2lzZS50c1wiLz5cclxuXHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGlzIGFuIGFkYXB0aW9uIG9mIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2Zhc3Qtc2ltcGxleC1ub2lzZVxyXG4gICAqIGRvbmUgYnkgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKlxyXG4gICAqIEJhc2VkIG9uIGV4YW1wbGUgY29kZSBieSBTdGVmYW4gR3VzdGF2c29uIChzdGVndUBpdG4ubGl1LnNlKS5cclxuICAgKiBPcHRpbWlzYXRpb25zIGJ5IFBldGVyIEVhc3RtYW4gKHBlYXN0bWFuQGRyaXp6bGUuc3RhbmZvcmQuZWR1KS5cclxuICAgKiBCZXR0ZXIgcmFuayBvcmRlcmluZyBtZXRob2QgYnkgU3RlZmFuIEd1c3RhdnNvbiBpbiAyMDEyLlxyXG4gICAqXHJcbiAgICogVGhpcyBjb2RlIHdhcyBwbGFjZWQgaW4gdGhlIHB1YmxpYyBkb21haW4gYnkgaXRzIG9yaWdpbmFsIGF1dGhvcixcclxuICAgKiBTdGVmYW4gR3VzdGF2c29uLiBZb3UgbWF5IHVzZSBpdCBhcyB5b3Ugc2VlIGZpdCwgYnV0XHJcbiAgICogYXR0cmlidXRpb24gaXMgYXBwcmVjaWF0ZWQuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE5vaXNlMiBleHRlbmRzIE5vaXNlIHtcclxuICAgIHByaXZhdGUgc3RhdGljIG9mZnNldDogbnVtYmVyID0gKDMuMCAtIE1hdGguc3FydCgzLjApKSAvIDYuMDtcclxuICAgIHByaXZhdGUgc3RhdGljIGdyYWRpZW50OiBudW1iZXJbXVtdID0gW1sxLCAxXSwgWy0xLCAxXSwgWzEsIC0xXSwgWy0xLCAtMV0sIFsxLCAwXSwgWy0xLCAwXSwgWzEsIDBdLCBbLTEsIDBdLCBbMCwgMV0sIFswLCAtMV0sIFswLCAxXSwgWzAsIC0xXV07XHJcbiAgICAjc2FtcGxlOiAoX3g6IG51bWJlciwgX3k6IG51bWJlcikgPT4gbnVtYmVyID0gbnVsbDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3JhbmRvbTogRnVuY3Rpb24gPSBNYXRoLnJhbmRvbSkge1xyXG4gICAgICBzdXBlcihfcmFuZG9tKTtcclxuXHJcbiAgICAgIHRoaXMuI3NhbXBsZSA9IChfeDogbnVtYmVyLCBfeTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgLy8gU2tldyB0aGUgaW5wdXQgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggY2VsbCB3ZSdyZSBpblxyXG4gICAgICAgIGNvbnN0IHM6IG51bWJlciA9IChfeCArIF95KSAqIDAuNSAqIChNYXRoLnNxcnQoMy4wKSAtIDEuMCk7IC8vIEhhaXJ5IGZhY3RvciBmb3IgMkRcclxuICAgICAgICBjb25zdCBpOiBudW1iZXIgPSBNYXRoLmZsb29yKF94ICsgcyk7XHJcbiAgICAgICAgY29uc3QgajogbnVtYmVyID0gTWF0aC5mbG9vcihfeSArIHMpO1xyXG4gICAgICAgIGNvbnN0IHQ6IG51bWJlciA9IChpICsgaikgKiBOb2lzZTIub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IFgwOiBudW1iZXIgPSBpIC0gdDsgLy8gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkpIHNwYWNlXHJcbiAgICAgICAgY29uc3QgWTA6IG51bWJlciA9IGogLSB0O1xyXG4gICAgICAgIGNvbnN0IHgwOiBudW1iZXIgPSBfeCAtIFgwOyAvLyBUaGUgeCx5IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpblxyXG4gICAgICAgIGNvbnN0IHkwOiBudW1iZXIgPSBfeSAtIFkwO1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW4uXHJcbiAgICAgICAgY29uc3QgaTE6IG51bWJlciA9IHgwID4geTAgPyAxIDogMDtcclxuICAgICAgICBjb25zdCBqMTogbnVtYmVyID0geDAgPiB5MCA/IDAgOiAxO1xyXG5cclxuICAgICAgICAvLyBPZmZzZXQ6bnVtYmVycyBmb3IgY29ybmVyc1xyXG4gICAgICAgIGNvbnN0IHgxOiBudW1iZXIgPSB4MCAtIGkxICsgTm9pc2UyLm9mZnNldDtcclxuICAgICAgICBjb25zdCB5MTogbnVtYmVyID0geTAgLSBqMSArIE5vaXNlMi5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgeDI6IG51bWJlciA9IHgwIC0gMS4wICsgMi4wICogTm9pc2UyLm9mZnNldDtcclxuICAgICAgICBjb25zdCB5MjogbnVtYmVyID0geTAgLSAxLjAgKyAyLjAgKiBOb2lzZTIub2Zmc2V0O1xyXG5cclxuICAgICAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIHRocmVlIHNpbXBsZXggY29ybmVyc1xyXG4gICAgICAgIGNvbnN0IGlpOiBudW1iZXIgPSBpICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGpqOiBudW1iZXIgPSBqICYgMjU1O1xyXG4gICAgICAgIGNvbnN0IGcwOiBudW1iZXJbXSA9IE5vaXNlMi5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIHRoaXMucGVybVtqal1dXTtcclxuICAgICAgICBjb25zdCBnMTogbnVtYmVyW10gPSBOb2lzZTIuZ3JhZGllbnRbdGhpcy5wZXJtTW9kMTJbaWkgKyBpMSArIHRoaXMucGVybVtqaiArIGoxXV1dO1xyXG4gICAgICAgIGNvbnN0IGcyOiBudW1iZXJbXSA9IE5vaXNlMi5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIDEgKyB0aGlzLnBlcm1bamogKyAxXV1dO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzXHJcbiAgICAgICAgY29uc3QgdDA6IG51bWJlciA9IDAuNSAtIHgwICogeDAgLSB5MCAqIHkwO1xyXG4gICAgICAgIGNvbnN0IG4wOiBudW1iZXIgPSB0MCA8IDAgPyAwLjAgOiBNYXRoLnBvdyh0MCwgNCkgKiAoZzBbMF0gKiB4MCArIGcwWzFdICogeTApO1xyXG5cclxuICAgICAgICBjb25zdCB0MTogbnVtYmVyID0gMC41IC0geDEgKiB4MSAtIHkxICogeTE7XHJcbiAgICAgICAgY29uc3QgbjE6IG51bWJlciA9IHQxIDwgMCA/IDAuMCA6IE1hdGgucG93KHQxLCA0KSAqIChnMVswXSAqIHgxICsgZzFbMV0gKiB5MSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHQyOiBudW1iZXIgPSAwLjUgLSB4MiAqIHgyIC0geTIgKiB5MjtcclxuICAgICAgICBjb25zdCBuMjogbnVtYmVyID0gdDIgPCAwID8gMC4wIDogTWF0aC5wb3codDIsIDQpICogKGcyWzBdICogeDIgKyBnMlsxXSAqIHkyKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGNvbnRyaWJ1dGlvbnMgZnJvbSBlYWNoIGNvcm5lciB0byBnZXQgdGhlIGZpbmFsIG5vaXNlIHZhbHVlLlxyXG4gICAgICAgIC8vIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHJldHVybiB2YWx1ZXMgaW4gdGhlIGludGVydmFsIFstMSwgMV1cclxuICAgICAgICByZXR1cm4gNzAuMTQ4MDU3NzA2NTM5NTIgKiAobjAgKyBuMSArIG4yKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2FtcGxlID0gKF94OiBudW1iZXIsIF95OiBudW1iZXIpOiBudW1iZXIgPT4ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc2FtcGxlKF94LCBfeSk7XHJcbiAgICB9O1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFRoaXMgaXMgYW4gYWRhcHRpb24gb2YgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZmFzdC1zaW1wbGV4LW5vaXNlXHJcbiAgICogZG9uZSBieSBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqXHJcbiAgICogQmFzZWQgb24gZXhhbXBsZSBjb2RlIGJ5IFN0ZWZhbiBHdXN0YXZzb24gKHN0ZWd1QGl0bi5saXUuc2UpLlxyXG4gICAqIE9wdGltaXNhdGlvbnMgYnkgUGV0ZXIgRWFzdG1hbiAocGVhc3RtYW5AZHJpenpsZS5zdGFuZm9yZC5lZHUpLlxyXG4gICAqIEJldHRlciByYW5rIG9yZGVyaW5nIG1ldGhvZCBieSBTdGVmYW4gR3VzdGF2c29uIGluIDIwMTIuXHJcbiAgICpcclxuICAgKiBUaGlzIGNvZGUgd2FzIHBsYWNlZCBpbiB0aGUgcHVibGljIGRvbWFpbiBieSBpdHMgb3JpZ2luYWwgYXV0aG9yLFxyXG4gICAqIFN0ZWZhbiBHdXN0YXZzb24uIFlvdSBtYXkgdXNlIGl0IGFzIHlvdSBzZWUgZml0LCBidXRcclxuICAgKiBhdHRyaWJ1dGlvbiBpcyBhcHByZWNpYXRlZC5cclxuICAgKi9cclxuICAvLyBUT0RPOiBUZXN0XHJcbiAgZXhwb3J0IGNsYXNzIE5vaXNlMyBleHRlbmRzIE5vaXNlIHtcclxuICAgIHByaXZhdGUgc3RhdGljIG9mZnNldDogbnVtYmVyID0gMS4wIC8gNi4wO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JhZGllbnQ6IG51bWJlcltdW10gPSBbWzEsIDEsIDBdLCBbLTEsIDEsIDBdLCBbMSwgLTEsIDBdLCBbLTEsIC0xLCAwXSwgWzEsIDAsIDFdLCBbLTEsIDAsIDFdLCBbMSwgMCwgLTFdLCBbLTEsIDAsIC0xXSwgWzAsIDEsIDFdLCBbMCwgLTEsIC0xXSwgWzAsIDEsIC0xXSwgWzAsIC0xLCAtMV1cclxuICAgIF07XHJcbiAgICAjc2FtcGxlOiAoX3g6IG51bWJlciwgX3k6IG51bWJlciwgX3o6IG51bWJlcikgPT4gbnVtYmVyID0gbnVsbDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3JhbmRvbTogRnVuY3Rpb24gPSBNYXRoLnJhbmRvbSkge1xyXG4gICAgICBzdXBlcihfcmFuZG9tKTtcclxuXHJcbiAgICAgIHRoaXMuI3NhbXBsZSA9IChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfejogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgLy8gU2tldyB0aGUgaW5wdXQgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggY2VsbCB3ZSdyZSBpblxyXG4gICAgICAgIGNvbnN0IHM6IG51bWJlciA9IChfeCArIF95ICsgX3opIC8gMy4wOyAvLyBWZXJ5IG5pY2UgYW5kIHNpbXBsZSBza2V3IGZhY3RvciBmb3IgM0RcclxuICAgICAgICBjb25zdCBpOiBudW1iZXIgPSBNYXRoLmZsb29yKF94ICsgcyk7XHJcbiAgICAgICAgY29uc3QgajogbnVtYmVyID0gTWF0aC5mbG9vcihfeSArIHMpO1xyXG4gICAgICAgIGNvbnN0IGs6IG51bWJlciA9IE1hdGguZmxvb3IoX3ogKyBzKTtcclxuICAgICAgICBjb25zdCB0OiBudW1iZXIgPSAoaSArIGogKyBrKSAqIE5vaXNlMy5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgWDA6IG51bWJlciA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSx6KSBzcGFjZVxyXG4gICAgICAgIGNvbnN0IFkwOiBudW1iZXIgPSBqIC0gdDtcclxuICAgICAgICBjb25zdCBaMDogbnVtYmVyID0gayAtIHQ7XHJcbiAgICAgICAgY29uc3QgeDA6IG51bWJlciA9IF94IC0gWDA7IC8vIFRoZSB4LHkseiBkaXN0YW5jZXMgZnJvbSB0aGUgY2VsbCBvcmlnaW5cclxuICAgICAgICBjb25zdCB5MDogbnVtYmVyID0gX3kgLSBZMDtcclxuICAgICAgICBjb25zdCB6MDogbnVtYmVyID0gX3ogLSBaMDtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJpbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW5cclxuICAgICAgICBsZXQgaTE6IG51bWJlciwgajE6IG51bWJlciwgazE6IG51bWJlciAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcclxuICAgICAgICAgIDtcclxuICAgICAgICBsZXQgaTI6IG51bWJlciwgajI6IG51bWJlciwgazI6IG51bWJlciAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3Jkc1xyXG4gICAgICAgICAgO1xyXG4gICAgICAgIGlmICh4MCA+PSB5MCkge1xyXG4gICAgICAgICAgaWYgKHkwID49IHowKSB7XHJcbiAgICAgICAgICAgIGkxID0gaTIgPSBqMiA9IDE7XHJcbiAgICAgICAgICAgIGoxID0gazEgPSBrMiA9IDA7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHgwID49IHowKSB7XHJcbiAgICAgICAgICAgIGkxID0gaTIgPSBrMiA9IDE7XHJcbiAgICAgICAgICAgIGoxID0gazEgPSBqMiA9IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBrMSA9IGkyID0gazIgPSAxO1xyXG4gICAgICAgICAgICBpMSA9IGoxID0gajIgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoeTAgPCB6MCkge1xyXG4gICAgICAgICAgICBrMSA9IGoyID0gazIgPSAxO1xyXG4gICAgICAgICAgICBpMSA9IGoxID0gaTIgPSAwO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh4MCA8IHowKSB7XHJcbiAgICAgICAgICAgIGoxID0gajIgPSBrMiA9IDE7XHJcbiAgICAgICAgICAgIGkxID0gazEgPSBpMiA9IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBqMSA9IGkyID0gajIgPSAxO1xyXG4gICAgICAgICAgICBpMSA9IGsxID0gazIgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgeDE6IG51bWJlciA9IHgwIC0gaTEgKyBOb2lzZTMub2Zmc2V0OyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGluICh4LHkseikgY29vcmRzXHJcbiAgICAgICAgY29uc3QgeTE6IG51bWJlciA9IHkwIC0gajEgKyBOb2lzZTMub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHoxOiBudW1iZXIgPSB6MCAtIGsxICsgTm9pc2UzLm9mZnNldDtcclxuICAgICAgICBjb25zdCB4MjogbnVtYmVyID0geDAgLSBpMiArIDIuMCAqIE5vaXNlMy5vZmZzZXQ7IC8vIE9mZnNldHMgZm9yIHRoaXJkIGNvcm5lciBpbiAoeCx5LHopIGNvb3Jkc1xyXG4gICAgICAgIGNvbnN0IHkyOiBudW1iZXIgPSB5MCAtIGoyICsgMi4wICogTm9pc2UzLm9mZnNldDtcclxuICAgICAgICBjb25zdCB6MjogbnVtYmVyID0gejAgLSBrMiArIDIuMCAqIE5vaXNlMy5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgeDM6IG51bWJlciA9IHgwIC0gMS4wICsgMy4wICogTm9pc2UzLm9mZnNldDsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHNcclxuICAgICAgICBjb25zdCB5MzogbnVtYmVyID0geTAgLSAxLjAgKyAzLjAgKiBOb2lzZTMub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHozOiBudW1iZXIgPSB6MCAtIDEuMCArIDMuMCAqIE5vaXNlMy5vZmZzZXQ7XHJcblxyXG4gICAgICAgIC8vIFdvcmsgOm51bWJlcnV0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgZm91ciBzaW1wbGV4IGNvcm5lcnNcclxuICAgICAgICBjb25zdCBpaTogbnVtYmVyID0gaSAmIDI1NTtcclxuICAgICAgICBjb25zdCBqajogbnVtYmVyID0gaiAmIDI1NTtcclxuICAgICAgICBjb25zdCBrazogbnVtYmVyID0gayAmIDI1NTtcclxuICAgICAgICBjb25zdCBnMDogbnVtYmVyW10gPSBOb2lzZTMuZ3JhZGllbnRbdGhpcy5wZXJtTW9kMTJbaWkgKyB0aGlzLnBlcm1bamogKyB0aGlzLnBlcm1ba2tdXV1dO1xyXG4gICAgICAgIGNvbnN0IGcxOiBudW1iZXJbXSA9IE5vaXNlMy5ncmFkaWVudFt0aGlzLnBlcm1Nb2QxMltpaSArIGkxICsgdGhpcy5wZXJtW2pqICsgajEgKyB0aGlzLnBlcm1ba2sgKyBrMV1dXV07XHJcbiAgICAgICAgY29uc3QgZzI6IG51bWJlcltdID0gTm9pc2UzLmdyYWRpZW50W3RoaXMucGVybU1vZDEyW2lpICsgaTIgKyB0aGlzLnBlcm1bamogKyBqMiArIHRoaXMucGVybVtrayArIGsyXV1dXTtcclxuICAgICAgICBjb25zdCBnMzogbnVtYmVyW10gPSBOb2lzZTMuZ3JhZGllbnRbdGhpcy5wZXJtTW9kMTJbaWkgKyAxICsgdGhpcy5wZXJtW2pqICsgMSArIHRoaXMucGVybVtrayArIDFdXV1dO1xyXG5cclxuICAgICAgICAvLyBDYWxjdTpudW1iZXJhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSBmb3VyIGNvcm5lcnNcclxuICAgICAgICBjb25zdCB0MDogbnVtYmVyID0gMC41IC0geDAgKiB4MCAtIHkwICogeTAgLSB6MCAqIHowO1xyXG4gICAgICAgIGNvbnN0IG4wOiBudW1iZXIgPSB0MCA8IDBcclxuICAgICAgICAgID8gMC4wXHJcbiAgICAgICAgICA6IE1hdGgucG93KHQwLCA0KSAqIChnMFswXSAqIHgwICsgZzBbMV0gKiB5MCArIGcwWzJdICogejApO1xyXG4gICAgICAgIGNvbnN0IHQxOiBudW1iZXIgPSAwLjUgLSB4MSAqIHgxIC0geTEgKiB5MSAtIHoxICogejE7XHJcbiAgICAgICAgY29uc3QgbjE6IG51bWJlciA9IHQxIDwgMFxyXG4gICAgICAgICAgPyAwLjBcclxuICAgICAgICAgIDogTWF0aC5wb3codDEsIDQpICogKGcxWzBdICogeDEgKyBnMVsxXSAqIHkxICsgZzFbMl0gKiB6MSk7XHJcbiAgICAgICAgY29uc3QgdDI6IG51bWJlciA9IDAuNSAtIHgyICogeDIgLSB5MiAqIHkyIC0gejIgKiB6MjtcclxuICAgICAgICBjb25zdCBuMjogbnVtYmVyID0gdDIgPCAwXHJcbiAgICAgICAgICA/IDAuMFxyXG4gICAgICAgICAgOiBNYXRoLnBvdyh0MiwgNCkgKiAoZzJbMF0gKiB4MiArIGcyWzFdICogeTIgKyBnMlsyXSAqIHoyKTtcclxuICAgICAgICBjb25zdCB0MzogbnVtYmVyID0gMC41IC0geDMgKiB4MyAtIHkzICogeTMgLSB6MyAqIHozO1xyXG4gICAgICAgIGNvbnN0IG4zOiBudW1iZXIgPSB0MyA8IDBcclxuICAgICAgICAgID8gMC4wXHJcbiAgICAgICAgICA6IE1hdGgucG93KHQzLCA0KSAqIChnM1swXSAqIHgzICsgZzNbMV0gKiB5MyArIGczWzJdICogejMpO1xyXG5cclxuICAgICAgICAvLyBBZGQgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggY29ybmVyIHRvIGdldCB0aGUgZmluYWwgbm9pc2UgdmFsdWUuXHJcbiAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gc3RheSBqdXN0IGluc2lkZSBbLTEsMV1cclxuICAgICAgICByZXR1cm4gOTQuNjg0OTMxNTA2ODE5NzIgKiAobjAgKyBuMSArIG4yICsgbjMpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzYW1wbGUgPSAoX3g6IG51bWJlciwgX3k6IG51bWJlciwgX3o6IG51bWJlcik6IG51bWJlciA9PiB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzYW1wbGUoX3gsIF95LCBfeik7XHJcbiAgICB9O1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8vIFRPRE86IFRlc3RcclxuICAvKipcclxuICAgKiBUaGlzIGlzIGFuIGFkYXB0aW9uIG9mIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2Zhc3Qtc2ltcGxleC1ub2lzZVxyXG4gICAqIGRvbmUgYnkgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKlxyXG4gICAqIEJhc2VkIG9uIGV4YW1wbGUgY29kZSBieSBTdGVmYW4gR3VzdGF2c29uIChzdGVndUBpdG4ubGl1LnNlKS5cclxuICAgKiBPcHRpbWlzYXRpb25zIGJ5IFBldGVyIEVhc3RtYW4gKHBlYXN0bWFuQGRyaXp6bGUuc3RhbmZvcmQuZWR1KS5cclxuICAgKiBCZXR0ZXIgcmFuayBvcmRlcmluZyBtZXRob2QgYnkgU3RlZmFuIEd1c3RhdnNvbiBpbiAyMDEyLlxyXG4gICAqXHJcbiAgICogVGhpcyBjb2RlIHdhcyBwbGFjZWQgaW4gdGhlIHB1YmxpYyBkb21haW4gYnkgaXRzIG9yaWdpbmFsIGF1dGhvcixcclxuICAgKiBTdGVmYW4gR3VzdGF2c29uLiBZb3UgbWF5IHVzZSBpdCBhcyB5b3Ugc2VlIGZpdCwgYnV0XHJcbiAgICogYXR0cmlidXRpb24gaXMgYXBwcmVjaWF0ZWQuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE5vaXNlNCBleHRlbmRzIE5vaXNlIHtcclxuICAgIHByaXZhdGUgc3RhdGljIG9mZnNldDogbnVtYmVyID0gKDUuMCAtIE1hdGguc3FydCg1LjApKSAvIDIwLjA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBncmFkaWVudDogbnVtYmVyW11bXSA9IFtbMCwgMSwgMSwgMV0sIFswLCAxLCAxLCAtMV0sIFswLCAxLCAtMSwgMV0sIFswLCAxLCAtMSwgLTFdLCBbMCwgLTEsIDEsIDFdLCBbMCwgLTEsIDEsIC0xXSwgWzAsIC0xLCAtMSwgMV0sIFswLCAtMSwgLTEsIC0xXSwgWzEsIDAsIDEsIDFdLCBbMSwgMCwgMSwgLTFdLCBbMSwgMCwgLTEsIDFdLCBbMSwgMCwgLTEsIC0xXSwgWy0xLCAwLCAxLCAxXSwgWy0xLCAwLCAxLCAtMV0sIFstMSwgMCwgLTEsIDFdLCBbLTEsIDAsIC0xLCAtMV0sIFsxLCAxLCAwLCAxXSwgWzEsIDEsIDAsIC0xXSwgWzEsIC0xLCAwLCAxXSwgWzEsIC0xLCAwLCAtMV0sIFstMSwgMSwgMCwgMV0sIFstMSwgMSwgMCwgLTFdLCBbLTEsIC0xLCAwLCAxXSwgWy0xLCAtMSwgMCwgLTFdLCBbMSwgMSwgMSwgMF0sIFsxLCAxLCAtMSwgMF0sIFsxLCAtMSwgMSwgMF0sIFsxLCAtMSwgLTEsIDBdLCBbLTEsIDEsIDEsIDBdLCBbLTEsIDEsIC0xLCAwXSwgWy0xLCAtMSwgMSwgMF0sIFstMSwgLTEsIC0xLCAwXV07XHJcbiAgICAjc2FtcGxlOiAoX3g6IG51bWJlciwgX3k6IG51bWJlciwgX3o6IG51bWJlciwgX3c6IG51bWJlcikgPT4gbnVtYmVyID0gbnVsbDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3JhbmRvbTogRnVuY3Rpb24gPSBNYXRoLnJhbmRvbSkge1xyXG4gICAgICBzdXBlcihfcmFuZG9tKTtcclxuXHJcbiAgICAgIHRoaXMuI3NhbXBsZSA9IChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfejogbnVtYmVyLCBfdzogbnVtYmVyKTogbnVtYmVyID0+IHtcclxuICAgICAgICAvLyBTa2V3IHRoZSAoeCx5LHosdykgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIGNlbGwgb2YgMjQgc2ltcGxpY2VzIHdlJ3JlIGluXHJcbiAgICAgICAgY29uc3QgczogbnVtYmVyID0gKF94ICsgX3kgKyBfeiArIF93KSAqIChNYXRoLnNxcnQoNS4wKSAtIDEuMCkgLyA0LjA7IC8vIEZhY3RvciBmb3IgNEQgc2tld2luZ1xyXG4gICAgICAgIGNvbnN0IGk6IG51bWJlciA9IE1hdGguZmxvb3IoX3ggKyBzKTtcclxuICAgICAgICBjb25zdCBqOiBudW1iZXIgPSBNYXRoLmZsb29yKF95ICsgcyk7XHJcbiAgICAgICAgY29uc3QgazogbnVtYmVyID0gTWF0aC5mbG9vcihfeiArIHMpO1xyXG4gICAgICAgIGNvbnN0IGw6IG51bWJlciA9IE1hdGguZmxvb3IoX3cgKyBzKTtcclxuICAgICAgICBjb25zdCB0OiBudW1iZXIgPSAoaSArIGogKyBrICsgbCkgKiBOb2lzZTQub2Zmc2V0OyAvLyBGYWN0b3IgZm9yIDREIHVuc2tld2luZ1xyXG4gICAgICAgIGNvbnN0IFgwOiBudW1iZXIgPSBpIC0gdDsgLy8gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkseix3KSBzcGFjZVxyXG4gICAgICAgIGNvbnN0IFkwOiBudW1iZXIgPSBqIC0gdDtcclxuICAgICAgICBjb25zdCBaMDogbnVtYmVyID0gayAtIHQ7XHJcbiAgICAgICAgY29uc3QgVzA6IG51bWJlciA9IGwgLSB0O1xyXG4gICAgICAgIGNvbnN0IHgwOiBudW1iZXIgPSBfeCAtIFgwOyAvLyBUaGUgeCx5LHosdyBkaXN0YW5jZXMgZnJvbSB0aGUgY2VsbCBvcmlnaW5cclxuICAgICAgICBjb25zdCB5MDogbnVtYmVyID0gX3kgLSBZMDtcclxuICAgICAgICBjb25zdCB6MDogbnVtYmVyID0gX3ogLSBaMDtcclxuICAgICAgICBjb25zdCB3MDogbnVtYmVyID0gX3cgLSBXMDtcclxuXHJcbiAgICAgICAgLy8gVG8gZmluZCBvdXQgd2hpY2ggb2YgdGhlIDI0IHBvc3NpYmxlIHNpbXBsaWNlcyB3ZSdyZSBpbiwgd2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlXHJcbiAgICAgICAgLy8gbWFnbml0dWRlIG9yZGVyaW5nIG9mIHgwLCB5MCwgejAgYW5kIHcwLiBTaXggcGFpci13aXNlIGNvbXBhcmlzb25zIGFyZSBwZXJmb3JtZWQgYmV0d2VlblxyXG4gICAgICAgIC8vIGVhY2ggcG9zc2libGUgcGFpciBvZiB0aGUgZm91ciBjb29yZGluYXRlcywgYW5kIHRoZSByZXN1bHRzIGFyZSB1c2VkIHRvIHJhbmsgdGhlIG51bWJlcnMuXHJcbiAgICAgICAgbGV0IHJhbmt4OiBudW1iZXIgPSAwO1xyXG4gICAgICAgIGxldCByYW5reTogbnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgcmFua3o6IG51bWJlciA9IDA7XHJcbiAgICAgICAgbGV0IHJhbmt3OiBudW1iZXIgPSAwO1xyXG4gICAgICAgIGlmICh4MCA+IHkwKSByYW5reCsrO1xyXG4gICAgICAgIGVsc2UgcmFua3krKztcclxuICAgICAgICBpZiAoeDAgPiB6MCkgcmFua3grKztcclxuICAgICAgICBlbHNlIHJhbmt6Kys7XHJcbiAgICAgICAgaWYgKHgwID4gdzApIHJhbmt4Kys7XHJcbiAgICAgICAgZWxzZSByYW5rdysrO1xyXG4gICAgICAgIGlmICh5MCA+IHowKSByYW5reSsrO1xyXG4gICAgICAgIGVsc2UgcmFua3orKztcclxuICAgICAgICBpZiAoeTAgPiB3MCkgcmFua3krKztcclxuICAgICAgICBlbHNlIHJhbmt3Kys7XHJcbiAgICAgICAgaWYgKHowID4gdzApIHJhbmt6Kys7XHJcbiAgICAgICAgZWxzZSByYW5rdysrO1xyXG5cclxuICAgICAgICAvLyBzaW1wbGV4W2NdIGlzIGEgNC12ZWN0b3Igd2l0aCB0aGUgbnVtYmVycyAwLCAxLCAyIGFuZCAzIGluIHNvbWUgb3JkZXIuXHJcbiAgICAgICAgLy8gTWFueSB2YWx1ZXMgb2YgYyB3aWxsIG5ldmVyIG9jY3VyLCBzaW5jZSBlLmcuIHg+eT56PncgbWFrZXMgeDx6LCB5PHcgYW5kIHg8d1xyXG4gICAgICAgIC8vIGltcG9zc2libGUuIE9ubHkgdGhlIDI0IGluZGljZXMgd2hpY2ggaGF2ZSBub24temVybyBlbnRyaWVzIG1ha2UgYW55IHNlbnNlLlxyXG4gICAgICAgIC8vIFdlIHVzZSBhIHRocmVzaG9sZGluZyB0byBzZXQgdGhlIGNvb3JkaW5hdGVzIGluIHR1cm4gZnJvbSB0aGUgbGFyZ2VzdCBtYWduaXR1ZGUuXHJcbiAgICAgICAgLy8gUmFuayAzIGRlbm90ZXMgdGhlIGxhcmdlc3QgY29vcmRpbmF0ZS5cclxuICAgICAgICBjb25zdCBpMTogbnVtYmVyID0gcmFua3ggPj0gMyA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGoxOiBudW1iZXIgPSByYW5reSA+PSAzID8gMSA6IDA7XHJcbiAgICAgICAgY29uc3QgazE6IG51bWJlciA9IHJhbmt6ID49IDMgPyAxIDogMDtcclxuICAgICAgICBjb25zdCBsMTogbnVtYmVyID0gcmFua3cgPj0gMyA/IDEgOiAwO1xyXG4gICAgICAgIC8vIFJhbmsgOiAyIGRlbm90ZXMgdGhlIHNlY29uZCBsYXJnZXN0IGNvb3JkaW5hdGUuXHJcbiAgICAgICAgY29uc3QgaTI6IG51bWJlciA9IHJhbmt4ID49IDIgPyAxIDogMDtcclxuICAgICAgICBjb25zdCBqMjogbnVtYmVyID0gcmFua3kgPj0gMiA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGsyOiBudW1iZXIgPSByYW5reiA+PSAyID8gMSA6IDA7XHJcbiAgICAgICAgY29uc3QgbDI6IG51bWJlciA9IHJhbmt3ID49IDIgPyAxIDogMDtcclxuICAgICAgICAvLyBSYW5rIDogMSBkZW5vdGVzIHRoZSBzZWNvbmQgc21hbGxlc3QgY29vcmRpbmF0ZS5cclxuICAgICAgICBjb25zdCBpMzogbnVtYmVyID0gcmFua3ggPj0gMSA/IDEgOiAwO1xyXG4gICAgICAgIGNvbnN0IGozOiBudW1iZXIgPSByYW5reSA+PSAxID8gMSA6IDA7XHJcbiAgICAgICAgY29uc3QgazM6IG51bWJlciA9IHJhbmt6ID49IDEgPyAxIDogMDtcclxuICAgICAgICBjb25zdCBsMzogbnVtYmVyID0gcmFua3cgPj0gMSA/IDEgOiAwO1xyXG5cclxuICAgICAgICAvLyBUaGUgZmlmdGggY29ybmVyIGhhcyBhbGwgY29vcmRpbmF0ZSBvZmZzZXRzID0gMSwgc28gbm8gbmVlZCB0byBjb21wdXRlIHRoYXQuXHJcbiAgICAgICAgY29uc3QgeDE6IG51bWJlciA9IHgwIC0gaTEgKyBOb2lzZTQub2Zmc2V0OyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcclxuICAgICAgICBjb25zdCB5MTogbnVtYmVyID0geTAgLSBqMSArIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgejE6IG51bWJlciA9IHowIC0gazEgKyBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHcxOiBudW1iZXIgPSB3MCAtIGwxICsgTm9pc2U0Lm9mZnNldDtcclxuICAgICAgICBjb25zdCB4MjogbnVtYmVyID0geDAgLSBpMiArIDIuMCAqIE5vaXNlNC5vZmZzZXQ7IC8vIE9mZnNldHMgZm9yIHRoaXJkIGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXHJcbiAgICAgICAgY29uc3QgeTI6IG51bWJlciA9IHkwIC0gajIgKyAyLjAgKiBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHoyOiBudW1iZXIgPSB6MCAtIGsyICsgMi4wICogTm9pc2U0Lm9mZnNldDtcclxuICAgICAgICBjb25zdCB3MjogbnVtYmVyID0gdzAgLSBsMiArIDIuMCAqIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgeDM6IG51bWJlciA9IHgwIC0gaTMgKyAzLjAgKiBOb2lzZTQub2Zmc2V0OyAvLyBPZmZzZXRzIGZvciBmb3VydGggY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcclxuICAgICAgICBjb25zdCB5MzogbnVtYmVyID0geTAgLSBqMyArIDMuMCAqIE5vaXNlNC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgejM6IG51bWJlciA9IHowIC0gazMgKyAzLjAgKiBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHczOiBudW1iZXIgPSB3MCAtIGwzICsgMy4wICogTm9pc2U0Lm9mZnNldDtcclxuICAgICAgICBjb25zdCB4NDogbnVtYmVyID0geDAgLSAxLjAgKyA0LjAgKiBOb2lzZTQub2Zmc2V0OyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzXHJcbiAgICAgICAgY29uc3QgeTQ6IG51bWJlciA9IHkwIC0gMS4wICsgNC4wICogTm9pc2U0Lm9mZnNldDtcclxuICAgICAgICBjb25zdCB6NDogbnVtYmVyID0gejAgLSAxLjAgKyA0LjAgKiBOb2lzZTQub2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHc0OiBudW1iZXIgPSB3MCAtIDEuMCArIDQuMCAqIE5vaXNlNC5vZmZzZXQ7XHJcblxyXG4gICAgICAgIC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgZml2ZSBzaW1wbGV4IGNvcm5lcnNcclxuICAgICAgICBjb25zdCBpaTogbnVtYmVyID0gaSAmIDI1NTtcclxuICAgICAgICBjb25zdCBqajogbnVtYmVyID0gaiAmIDI1NTtcclxuICAgICAgICBjb25zdCBrazogbnVtYmVyID0gayAmIDI1NTtcclxuICAgICAgICBjb25zdCBsbDogbnVtYmVyID0gbCAmIDI1NTtcclxuICAgICAgICBjb25zdCBnMDogbnVtYmVyW10gPSBOb2lzZTQuZ3JhZGllbnRbXHJcbiAgICAgICAgICB0aGlzLnBlcm1baWkgKyB0aGlzLnBlcm1bamogKyB0aGlzLnBlcm1ba2sgKyB0aGlzLnBlcm1bbGxdXV1dICVcclxuICAgICAgICAgIDMyXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCBnMTogbnVtYmVyW10gPSBOb2lzZTQuZ3JhZGllbnRbXHJcbiAgICAgICAgICB0aGlzLnBlcm1bXHJcbiAgICAgICAgICAgIGlpICsgaTEgKyB0aGlzLnBlcm1bamogKyBqMSArIHRoaXMucGVybVtrayArIGsxICsgdGhpcy5wZXJtW2xsICsgbDFdXV1cclxuICAgICAgICAgIF0gJSAzMlxyXG4gICAgICAgIF07XHJcbiAgICAgICAgY29uc3QgZzI6IG51bWJlcltdID0gTm9pc2U0LmdyYWRpZW50W1xyXG4gICAgICAgICAgdGhpcy5wZXJtW1xyXG4gICAgICAgICAgICBpaSArIGkyICsgdGhpcy5wZXJtW2pqICsgajIgKyB0aGlzLnBlcm1ba2sgKyBrMiArIHRoaXMucGVybVtsbCArIGwyXV1dXHJcbiAgICAgICAgICBdICUgMzJcclxuICAgICAgICBdO1xyXG4gICAgICAgIGNvbnN0IGczOiBudW1iZXJbXSA9IE5vaXNlNC5ncmFkaWVudFtcclxuICAgICAgICAgIHRoaXMucGVybVtcclxuICAgICAgICAgICAgaWkgKyBpMyArIHRoaXMucGVybVtqaiArIGozICsgdGhpcy5wZXJtW2trICsgazMgKyB0aGlzLnBlcm1bbGwgKyBsM11dXVxyXG4gICAgICAgICAgXSAlIDMyXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCBnNDogbnVtYmVyW10gPSBOb2lzZTQuZ3JhZGllbnRbXHJcbiAgICAgICAgICB0aGlzLnBlcm1bXHJcbiAgICAgICAgICAgIGlpICsgMSArIHRoaXMucGVybVtqaiArIDEgKyB0aGlzLnBlcm1ba2sgKyAxICsgdGhpcy5wZXJtW2xsICsgMV1dXVxyXG4gICAgICAgICAgXSAlIDMyXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgZml2ZSBjb3JuZXJzXHJcbiAgICAgICAgY29uc3QgdDA6IG51bWJlciA9IDAuNSAtIHgwICogeDAgLSB5MCAqIHkwIC0gejAgKiB6MCAtIHcwICogdzA7XHJcbiAgICAgICAgY29uc3QgbjA6IG51bWJlciA9IHQwIDwgMFxyXG4gICAgICAgICAgPyAwLjBcclxuICAgICAgICAgIDogTWF0aC5wb3codDAsIDQpICogKGcwWzBdICogeDAgKyBnMFsxXSAqIHkwICsgZzBbMl0gKiB6MCArIGcwWzNdICogdzApO1xyXG4gICAgICAgIGNvbnN0IHQxOiBudW1iZXIgPSAwLjUgLSB4MSAqIHgxIC0geTEgKiB5MSAtIHoxICogejEgLSB3MSAqIHcxO1xyXG4gICAgICAgIGNvbnN0IG4xOiBudW1iZXIgPSB0MSA8IDBcclxuICAgICAgICAgID8gMC4wXHJcbiAgICAgICAgICA6IE1hdGgucG93KHQxLCA0KSAqIChnMVswXSAqIHgxICsgZzFbMV0gKiB5MSArIGcxWzJdICogejEgKyBnMVszXSAqIHcxKTtcclxuICAgICAgICBjb25zdCB0MjogbnVtYmVyID0gMC41IC0geDIgKiB4MiAtIHkyICogeTIgLSB6MiAqIHoyIC0gdzIgKiB3MjtcclxuICAgICAgICBjb25zdCBuMjogbnVtYmVyID0gdDIgPCAwXHJcbiAgICAgICAgICA/IDAuMFxyXG4gICAgICAgICAgOiBNYXRoLnBvdyh0MiwgNCkgKiAoZzJbMF0gKiB4MiArIGcyWzFdICogeTIgKyBnMlsyXSAqIHoyICsgZzJbM10gKiB3Mik7XHJcbiAgICAgICAgY29uc3QgdDM6IG51bWJlciA9IDAuNSAtIHgzICogeDMgLSB5MyAqIHkzIC0gejMgKiB6MyAtIHczICogdzM7XHJcbiAgICAgICAgY29uc3QgbjM6IG51bWJlciA9IHQzIDwgMFxyXG4gICAgICAgICAgPyAwLjBcclxuICAgICAgICAgIDogTWF0aC5wb3codDMsIDQpICogKGczWzBdICogeDMgKyBnM1sxXSAqIHkzICsgZzNbMl0gKiB6MyArIGczWzNdICogdzMpO1xyXG4gICAgICAgIGNvbnN0IHQ0OiBudW1iZXIgPSAwLjUgLSB4NCAqIHg0IC0geTQgKiB5NCAtIHo0ICogejQgLSB3NCAqIHc0O1xyXG4gICAgICAgIGNvbnN0IG40OiBudW1iZXIgPSB0NCA8IDBcclxuICAgICAgICAgID8gMC4wXHJcbiAgICAgICAgICA6IE1hdGgucG93KHQ0LCA0KSAqIChnNFswXSAqIHg0ICsgZzRbMV0gKiB5NCArIGc0WzJdICogejQgKyBnNFszXSAqIHc0KTtcclxuXHJcbiAgICAgICAgLy8gU3VtIHVwIGFuZCBzY2FsZSB0aGUgcmVzdWx0IHRvIGNvdmVyIHRoZSByYW5nZSBbLTEsMV1cclxuICAgICAgICByZXR1cm4gNzIuMzc4NTU3NjUxNTM2NjUgKiAobjAgKyBuMSArIG4yICsgbjMgKyBuNCk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNhbXBsZSA9IChfeDogbnVtYmVyLCBfeTogbnVtYmVyLCBfejogbnVtYmVyLCBfdzogbnVtYmVyKTogbnVtYmVyID0+IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NhbXBsZShfeCwgX3ksIF96LCBfdyk7XHJcbiAgICB9O1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAgKiBTdG9yaW5nIGFuZCBtYW5pcHVsYXRpbmcgcm90YXRpb25zIGluIHRoZSBmb3JtIG9mIHF1YXRlcm5pb25zLlxyXG4gICAgKiBDb25zdHJ1Y3RlZCBvdXQgb2YgdGhlIDQgY29tcG9uZW50czogKHgsIHksIHosIHcpLiBNYXRoZW1hdGljYWwgbm90YXRpb246IHcgKyB4aSArIHlqICsgemsuXHJcbiAgICAqIEEgUXVhdGVybmlvbiBjYW4gYmUgZGVzY3JpYmVkIHdpdGggYW4gYXhpcyBhbmQgYW5nbGU6ICh4LCB5LCB6KSA9IHNpbihhbmdsZS8yKSpheGlzOyB3ID0gY29zKGFuZ2xlLzIpLlxyXG4gICAgKiByb2xsOiB4LCBwaXRjaDogeSwgeWF3OiB6LiBOb3RlIHRoYXQgb3BlcmF0aW9ucyBhcmUgYWRhcHRlZCB0byB3b3JrIHdpdGggdmVjdG9ycyB3aGVyZSB5IGlzIHVwIGFuZCB6IGlzIGZvcndhcmQuXHJcbiAgICAqIEBhdXRob3JzIE1hdHRoaWFzIFJvbWluZywgSEZVLCAyMDIzIHwgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXHJcbiAgICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBRdWF0ZXJuaW9uIGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSwgUmVjeWNhYmxlIHtcclxuICAgIHB1YmxpYyB4OiBudW1iZXI7XHJcbiAgICBwdWJsaWMgeTogbnVtYmVyO1xyXG4gICAgcHVibGljIHo6IG51bWJlcjtcclxuICAgIHB1YmxpYyB3OiBudW1iZXI7XHJcblxyXG4gICAgcmVhZG9ubHkgI2V1bGVyQW5nbGVzOiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7IC8vIGV1bGVyIGFuZ2xlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcXVhdGVybmlvbiBpbiBkZWdyZWVzLlxyXG4gICAgI2V1bGVyQW5nbGVzRGlydHk6IGJvb2xlYW47XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCwgX3o6IG51bWJlciA9IDAsIF93OiBudW1iZXIgPSAxKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2V0KF94LCBfeSwgX3osIF93KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIGEgbmV3IGlkZW50aXR5IHF1YXRlcm5pb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBJREVOVElUWSgpOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgcmV0dXJuIFJlY3ljbGVyLmdldChRdWF0ZXJuaW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBnaXZlbiBxdWF0ZXJuaW9uIHNjYWxlZCB0byBsZW5ndGggMSAoYSB1bml0IHF1YXRlcm5pb24pIG1ha2luZyBpdCBhIHZhbGlkIHJvdGF0aW9uIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgcXVhdGVybmlvbiB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE5PUk1BTElaQVRJT04oX3F1YXRlcm5pb246IFF1YXRlcm5pb24sIF9vdXQ6IFF1YXRlcm5pb24gPSBSZWN5Y2xlci5yZXVzZShRdWF0ZXJuaW9uKSk6IFF1YXRlcm5pb24ge1xyXG4gICAgICByZXR1cm4gX291dC5jb3B5KF9xdWF0ZXJuaW9uKS5ub3JtYWxpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyB3aGVuIG11bHRpcGxpZWQgYnksIHVzaW5nIHRoZSBhbmdsZXMgZ2l2ZW4uXHJcbiAgICAgKiBSb3RhdGlvbiBvY2N1cnMgYXJvdW5kIHRoZSBheGlzIGluIHRoZSBvcmRlciBaLVktWC5cclxuICAgICAqIEBwYXJhbSBfb3V0IE9wdGlvbmFsIHF1YXRlcm5pb24gdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTl9FVUxFUl9BTkdMRVMoX2V1bGVyQW5nbGVzOiBWZWN0b3IzLCBfb3V0OiBRdWF0ZXJuaW9uID0gUmVjeWNsZXIucmV1c2UoUXVhdGVybmlvbikpOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgX291dC5ldWxlckFuZ2xlcyA9IF9ldWxlckFuZ2xlcztcclxuICAgICAgcmV0dXJuIF9vdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcXVhdGVybmlvbiB0aGF0IHJvdGF0ZXMgY29vcmRpbmF0ZXMgd2hlbiBtdWx0aXBsaWVkIGJ5LCB1c2luZyB0aGUgYXhpcyBhbmQgYW5nbGUgZ2l2ZW4uXHJcbiAgICAgKiBBeGlzIG11c3QgYmUgbm9ybWFsaXplZC4gQW5nbGUgaXMgaW4gZGVncmVlcy5cclxuICAgICAqIEBwYXJhbSBfb3V0IE9wdGlvbmFsIHF1YXRlcm5pb24gdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTl9BWElTX0FOR0xFKF9heGlzOiBWZWN0b3IzLCBfYW5nbGU6IG51bWJlciwgX291dDogUXVhdGVybmlvbiA9IFJlY3ljbGVyLnJldXNlKFF1YXRlcm5pb24pKTogUXVhdGVybmlvbiB7XHJcbiAgICAgIGNvbnN0IGhhbGZBbmdsZTogbnVtYmVyID0gX2FuZ2xlICogQ2FsYy5kZWcycmFkIC8gMjtcclxuICAgICAgY29uc3Qgc2luSGFsZkFuZ2xlOiBudW1iZXIgPSBNYXRoLnNpbihoYWxmQW5nbGUpO1xyXG4gICAgICByZXR1cm4gX291dC5zZXQoXHJcbiAgICAgICAgX2F4aXMueCAqIHNpbkhhbGZBbmdsZSxcclxuICAgICAgICBfYXhpcy55ICogc2luSGFsZkFuZ2xlLFxyXG4gICAgICAgIF9heGlzLnogKiBzaW5IYWxmQW5nbGUsXHJcbiAgICAgICAgTWF0aC5jb3MoaGFsZkFuZ2xlKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHF1YXRlcm5pb24gd2l0aCB0aGUgZ2l2ZW4gZm9yd2FyZCBhbmQgdXAgZGlyZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIF9mb3J3YXJkIEEgdW5pdCB2ZWN0b3IgaW5kaWNhdGluZyB0aGUgZGVzaXJlZCBmb3J3YXJkLWRpcmVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBfdXAgQSB1bml0IHZlY3RvciBpbmRpY2F0aW5nIHRoZSB1cC1kaXJlY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCBxdWF0ZXJuaW9uIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT05fTE9PS19JTihfZm9yd2FyZDogVmVjdG9yMywgX3VwOiBWZWN0b3IzLCBfb3V0OiBRdWF0ZXJuaW9uID0gUmVjeWNsZXIucmV1c2UoUXVhdGVybmlvbikpOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgY29uc3QgcmlnaHQ6IFZlY3RvcjMgPSBWZWN0b3IzLkNST1NTKF91cCwgX2ZvcndhcmQpO1xyXG4gICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDR4NCk7XHJcbiAgICAgIG1hdHJpeC5zZXQoXHJcbiAgICAgICAgcmlnaHQueCwgcmlnaHQueSwgcmlnaHQueiwgMCxcclxuICAgICAgICBfdXAueCwgX3VwLnksIF91cC56LCAwLFxyXG4gICAgICAgIF9mb3J3YXJkLngsIF9mb3J3YXJkLnksIF9mb3J3YXJkLnosIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMVxyXG4gICAgICApO1xyXG4gICAgICBfb3V0LmNvcHkobWF0cml4LnF1YXRlcm5pb24pO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShyaWdodCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG1hdHJpeCk7XHJcbiAgICAgIHJldHVybiBfb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHF1YXRlcm5pb24gdGhhdCB3aWxsIHJvdGF0ZSBvbmUgdmVjdG9yIHRvIGFsaWduIHdpdGggYW5vdGhlci5cclxuICAgICAqIEBwYXJhbSBfZnJvbSBUaGUgbm9ybWFsaXplZCBkaXJlY3Rpb24gdmVjdG9yIHRvIHJvdGF0ZSBmcm9tLlxyXG4gICAgICogQHBhcmFtIF90byBUaGUgbm9ybWFsaXplZCBkaXJlY3Rpb24gdmVjdG9yIHRvIHJvdGF0ZSB0by5cclxuICAgICAqIEBwYXJhbSBfb3V0IE9wdGlvbmFsIHF1YXRlcm5pb24gdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBST1RBVElPTl9GUk9NX1RPKF9mcm9tOiBWZWN0b3IzLCBfdG86IFZlY3RvcjMsIF9vdXQ6IFF1YXRlcm5pb24gPSBSZWN5Y2xlci5yZXVzZShRdWF0ZXJuaW9uKSk6IFF1YXRlcm5pb24ge1xyXG4gICAgICBjb25zdCBhbmdsZTogbnVtYmVyID0gTWF0aC5hY29zKFZlY3RvcjMuRE9UKF9mcm9tLCBfdG8pKSAqIENhbGMucmFkMmRlZztcclxuICAgICAgY29uc3QgYXhpczogVmVjdG9yMyA9IFZlY3RvcjMuQ1JPU1MoX2Zyb20sIF90bykubm9ybWFsaXplKCk7XHJcbiAgICAgIFF1YXRlcm5pb24uUk9UQVRJT05fQVhJU19BTkdMRShheGlzLCBhbmdsZSwgX291dCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKGF4aXMpO1xyXG4gICAgICByZXR1cm4gX291dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyB3aGVuIG11bHRpcGxpZWQgYnksIHVzaW5nIHRoZSBhbmdsZXMgZ2l2ZW4uXHJcbiAgICAgKiBSb3RhdGlvbiBvY2N1cnMgYXJvdW5kIHRoZSBheGlzIGluIHRoZSBvcmRlciBaLVktWC5cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgUk9UQVRJT05fRVVMRVJfQU5HTEVTfSBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OKF9ldWxlckFuZ2xlczogVmVjdG9yMyk6IFF1YXRlcm5pb247XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyB3aGVuIG11bHRpcGxpZWQgYnksIHVzaW5nIHRoZSBheGlzIGFuZCBhbmdsZSBnaXZlbi5cclxuICAgICAqIEF4aXMgbXVzdCBiZSBub3JtYWxpemVkLiBBbmdsZSBpcyBpbiBkZWdyZWVzLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBST1RBVElPTl9BWElTX0FOR0xFfSBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OKF9heGlzOiBWZWN0b3IzLCBfYW5nbGU6IG51bWJlcik6IFF1YXRlcm5pb247XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHRoYXQgcm90YXRlcyBjb29yZGluYXRlcyB3aGVuIG11bHRpcGxpZWQgYnksIHVzaW5nIHRoZSBmb3J3YXJkIGFuZCB1cCBkaXJlY3Rpb24gZ2l2ZW4uXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIFJPVEFUSU9OX0xPT0tfSU59IGluc3RlYWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUk9UQVRJT04oX2ZvcndhcmQ6IFZlY3RvcjMsIF91cDogVmVjdG9yMyk6IFF1YXRlcm5pb247XHJcbiAgICBwdWJsaWMgc3RhdGljIFJPVEFUSU9OKF92ZWN0b3I6IFZlY3RvcjMsIF9hbmdsZU9yVXA/OiBudW1iZXIgfCBWZWN0b3IzKTogUXVhdGVybmlvbiB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdDogUXVhdGVybmlvbiA9IFJlY3ljbGVyLmdldChRdWF0ZXJuaW9uKTtcclxuICAgICAgaWYgKF9hbmdsZU9yVXAgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmVzdWx0LmV1bGVyQW5nbGVzID0gX3ZlY3RvcjtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgX2FuZ2xlT3JVcCA9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgbGV0IGhhbGZBbmdsZTogbnVtYmVyID0gX2FuZ2xlT3JVcCAqIENhbGMuZGVnMnJhZCAvIDI7XHJcbiAgICAgICAgbGV0IHNpbkhhbGZBbmdsZTogbnVtYmVyID0gTWF0aC5zaW4oaGFsZkFuZ2xlKTtcclxuXHJcbiAgICAgICAgcmVzdWx0LnNldChcclxuICAgICAgICAgIF92ZWN0b3IueCAqIHNpbkhhbGZBbmdsZSxcclxuICAgICAgICAgIF92ZWN0b3IueSAqIHNpbkhhbGZBbmdsZSxcclxuICAgICAgICAgIF92ZWN0b3IueiAqIHNpbkhhbGZBbmdsZSxcclxuICAgICAgICAgIE1hdGguY29zKGhhbGZBbmdsZSlcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0OiBWZWN0b3IzID0gVmVjdG9yMy5DUk9TUyhfYW5nbGVPclVwLCBfdmVjdG9yKTtcclxuICAgICAgICBjb25zdCBtYXRyaXg6IE1hdHJpeDR4NCA9IFJlY3ljbGVyLnJldXNlKE1hdHJpeDR4NCk7XHJcbiAgICAgICAgbWF0cml4LnNldChcclxuICAgICAgICAgIHJpZ2h0LngsIHJpZ2h0LnksIHJpZ2h0LnosIDAsXHJcbiAgICAgICAgICBfYW5nbGVPclVwLngsIF9hbmdsZU9yVXAueSwgX2FuZ2xlT3JVcC56LCAwLFxyXG4gICAgICAgICAgX3ZlY3Rvci54LCBfdmVjdG9yLnksIF92ZWN0b3IueiwgMCxcclxuICAgICAgICAgIDAsIDAsIDAsIDFcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXN1bHQuY29weShtYXRyaXgucXVhdGVybmlvbik7XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUocmlnaHQpO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG1hdHJpeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0d28gcGFzc2VkIHF1YXRlcm5pb25zLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgcXVhdGVybmlvbiB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFBST0RVQ1QoX2xlZnQ6IFF1YXRlcm5pb24sIF9yaWdodDogUXVhdGVybmlvbiwgX291dDogUXVhdGVybmlvbiA9IFJlY3ljbGVyLnJldXNlKFF1YXRlcm5pb24pKTogUXVhdGVybmlvbiB7XHJcbiAgICAgIC8vIGZyb206IGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cclxuICAgICAgY29uc3QgYXg6IG51bWJlciA9IF9sZWZ0Lng7XHJcbiAgICAgIGNvbnN0IGF5OiBudW1iZXIgPSBfbGVmdC55O1xyXG4gICAgICBjb25zdCBhejogbnVtYmVyID0gX2xlZnQuejtcclxuICAgICAgY29uc3QgYXc6IG51bWJlciA9IF9sZWZ0Lnc7XHJcbiAgICAgIGNvbnN0IGJ4OiBudW1iZXIgPSBfcmlnaHQueDtcclxuICAgICAgY29uc3QgYnk6IG51bWJlciA9IF9yaWdodC55O1xyXG4gICAgICBjb25zdCBiejogbnVtYmVyID0gX3JpZ2h0Lno7XHJcbiAgICAgIGNvbnN0IGJ3OiBudW1iZXIgPSBfcmlnaHQudztcclxuXHJcbiAgICAgIF9vdXQuc2V0KFxyXG4gICAgICAgIGF4ICogYncgKyBheSAqIGJ6IC0gYXogKiBieSArIGF3ICogYngsXHJcbiAgICAgICAgLWF4ICogYnogKyBheSAqIGJ3ICsgYXogKiBieCArIGF3ICogYnksXHJcbiAgICAgICAgYXggKiBieSAtIGF5ICogYnggKyBheiAqIGJ3ICsgYXcgKiBieixcclxuICAgICAgICAtYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6ICsgYXcgKiBid1xyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIF9vdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgaW52ZXJzZSBvZiBhIHBhc3NlZCBxdWF0ZXJuaW9uLlxyXG4gICAgICogUXVhdGVybmlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQuXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCBxdWF0ZXJuaW9uIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgSU5WRVJTRShfcXVhdGVybmlvbjogUXVhdGVybmlvbiwgX291dDogUXVhdGVybmlvbiA9IFJlY3ljbGVyLnJldXNlKFF1YXRlcm5pb24pKTogUXVhdGVybmlvbiB7XHJcbiAgICAgIHJldHVybiBRdWF0ZXJuaW9uLkNPTkpVR0FURShfcXVhdGVybmlvbiwgX291dCk7IC8vIHHigbvCuSA9IHEqIC8gfHF8wrIgPT4gfHF8wrIgPSAxID0+IHHigbvCuSA9IHEqXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgY29uanVnYXRlIG9mIGEgcGFzc2VkIHF1YXRlcm5pb24uXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCBxdWF0ZXJuaW9uIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQ09OSlVHQVRFKF9xdWF0ZXJuaW9uOiBRdWF0ZXJuaW9uLCBfb3V0OiBRdWF0ZXJuaW9uID0gUmVjeWNsZXIucmV1c2UoUXVhdGVybmlvbikpOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgcmV0dXJuIF9vdXQuc2V0KC1fcXVhdGVybmlvbi54LCAtX3F1YXRlcm5pb24ueSwgLV9xdWF0ZXJuaW9uLnosIF9xdWF0ZXJuaW9uLncpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXRlcm5pb25zLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERPVChfYTogUXVhdGVybmlvbiwgX2I6IFF1YXRlcm5pb24pOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gX2EueCAqIF9iLnggKyBfYS55ICogX2IueSArIF9hLnogKiBfYi56ICsgX2EudyAqIF9iLnc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRlcm5pb25zLiBXaGVuIHQgaXMgMCB0aGUgcmVzdWx0IGlzIGEsIHdoZW4gdCBpcyAxIHRoZSByZXN1bHQgaXMgYi4gQ2xhbXBzIHQgYmV0d2VlbiAwIGFuZCAxLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgcXVhdGVybmlvbiB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIExFUlAoX2E6IFF1YXRlcm5pb24sIF9iOiBRdWF0ZXJuaW9uLCBfdDogbnVtYmVyLCBfb3V0OiBRdWF0ZXJuaW9uID0gUmVjeWNsZXIucmV1c2UoUXVhdGVybmlvbikpOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgX3QgPSBDYWxjLmNsYW1wKF90LCAwLCAxKTtcclxuICAgICAgcmV0dXJuIF9vdXQuc2V0KFxyXG4gICAgICAgIChfYS54ICsgX3QgKiAoX2IueCAtIF9hLngpKSxcclxuICAgICAgICAoX2EueSArIF90ICogKF9iLnkgLSBfYS55KSksXHJcbiAgICAgICAgKF9hLnogKyBfdCAqIChfYi56IC0gX2EueikpLFxyXG4gICAgICAgIChfYS53ICsgX3QgKiAoX2IudyAtIF9hLncpKVxyXG4gICAgICApLm5vcm1hbGl6ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRlcm5pb25zLiBXaGVuIHQgaXMgMCB0aGUgcmVzdWx0IGlzIGEsIHdoZW4gdCBpcyAxIHRoZSByZXN1bHQgaXMgYi4gXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCBxdWF0ZXJuaW9uIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0xFUlAoX2E6IFF1YXRlcm5pb24sIF9iOiBRdWF0ZXJuaW9uLCBfdDogbnVtYmVyLCBfb3V0OiBRdWF0ZXJuaW9uID0gUmVjeWNsZXIucmV1c2UoUXVhdGVybmlvbikpOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgLy8gRnJvbTogaHR0cHM6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXHJcbiAgICAgIGxldCBjb3NIYWxmVGhldGE6IG51bWJlciA9IF9hLncgKiBfYi53ICsgX2EueCAqIF9iLnggKyBfYS55ICogX2IueSArIF9hLnogKiBfYi56O1xyXG4gICAgICBpZiAoTWF0aC5hYnMoY29zSGFsZlRoZXRhKSA+PSAxKVxyXG4gICAgICAgIHJldHVybiBfb3V0LmNvcHkoX2EpO1xyXG5cclxuICAgICAgbGV0IGhhbGZUaGV0YTogbnVtYmVyID0gTWF0aC5hY29zKGNvc0hhbGZUaGV0YSk7XHJcbiAgICAgIGxldCBzaW5IYWxmVGhldGE6IG51bWJlciA9IE1hdGguc3FydCgxIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhKTtcclxuICAgICAgaWYgKE1hdGguYWJzKHNpbkhhbGZUaGV0YSkgPCAxZS0zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9vdXQuc2V0KFxyXG4gICAgICAgICAgKF9hLnggKiAwLjUgKyBfYi54ICogMC41KSxcclxuICAgICAgICAgIChfYS55ICogMC41ICsgX2IueSAqIDAuNSksXHJcbiAgICAgICAgICAoX2EueiAqIDAuNSArIF9iLnogKiAwLjUpLFxyXG4gICAgICAgICAgKF9hLncgKiAwLjUgKyBfYi53ICogMC41KVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCByYXRpb0E6IG51bWJlciA9IE1hdGguc2luKCgxIC0gX3QpICogaGFsZlRoZXRhKSAvIHNpbkhhbGZUaGV0YTtcclxuICAgICAgbGV0IHJhdGlvQjogbnVtYmVyID0gTWF0aC5zaW4oX3QgKiBoYWxmVGhldGEpIC8gc2luSGFsZlRoZXRhO1xyXG4gICAgICByZXR1cm4gX291dC5zZXQoXHJcbiAgICAgICAgKF9hLnggKiByYXRpb0EgKyBfYi54ICogcmF0aW9CKSxcclxuICAgICAgICAoX2EueSAqIHJhdGlvQSArIF9iLnkgKiByYXRpb0IpLFxyXG4gICAgICAgIChfYS56ICogcmF0aW9BICsgX2IueiAqIHJhdGlvQiksXHJcbiAgICAgICAgKF9hLncgKiByYXRpb0EgKyBfYi53ICogcmF0aW9CKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBhbmdsZSBpbiBkZWdyZWVzIGJldHdlZW4gdGhlIHR3byBnaXZlbiBxdWF0ZXJuaW9ucy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBBTkdMRShfZnJvbTogUXVhdGVybmlvbiwgX3RvOiBRdWF0ZXJuaW9uKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIDIgKiBNYXRoLmFjb3MoTWF0aC5hYnMoQ2FsYy5jbGFtcChRdWF0ZXJuaW9uLkRPVChfZnJvbSwgX3RvKSwgLTEsIDEpKSkgKiBDYWxjLnJhZDJkZWc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOZWdhdGVzIHRoZSBnaXZlbiBxdWF0ZXJuaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIG5lZ2F0ZShfcTogUXVhdGVybmlvbik6IHZvaWQge1xyXG4gICAgICBfcS54ID0gLV9xLng7XHJcbiAgICAgIF9xLnkgPSAtX3EueTtcclxuICAgICAgX3EueiA9IC1fcS56O1xyXG4gICAgICBfcS53ID0gLV9xLnc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBxdWF0ZXJuaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNsb25lKCk6IFF1YXRlcm5pb24ge1xyXG4gICAgICByZXR1cm4gUmVjeWNsZXIucmV1c2UoUXVhdGVybmlvbikuY29weSh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIC0gZ2V0OiByZXR1cm4gdGhlIGV1bGVyIGFuZ2xlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByb3RhdGlvbiBpbiBkZWdyZWVzLiBcclxuICAgICAqICoqQ2F1dGlvbiEqKiBVc2UgaW1tZWRpYXRlbHkgYW5kIHJlYWRvbmx5LCBzaW5jZSB0aGUgdmVjdG9yIGlzIGdvaW5nIHRvIGJlIHJldXNlZCBpbnRlcm5hbGx5LiBDcmVhdGUgYSBjbG9uZSB0byBrZWVwIGxvbmdlciBhbmQgbWFuaXB1bGF0ZS4gXHJcbiAgICAgKiAtIHNldDogc2V0IHRoZSBldWxlciBhbmdsZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcm90YXRpb24gaW4gZGVncmVlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBldWxlckFuZ2xlcygpOiBWZWN0b3IzIHtcclxuICAgICAgaWYgKHRoaXMuI2V1bGVyQW5nbGVzRGlydHkpIHtcclxuICAgICAgICB0aGlzLiNldWxlckFuZ2xlc0RpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIHJvbGwgKHgtYXhpcyByb3RhdGlvbilcclxuICAgICAgICBsZXQgc2lucmNvc3A6IG51bWJlciA9IDIgKiAodGhpcy53ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy56KTtcclxuICAgICAgICBsZXQgY29zcmNvc3A6IG51bWJlciA9IDEgLSAyICogKHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XHJcbiAgICAgICAgdGhpcy4jZXVsZXJBbmdsZXMueCA9IE1hdGguYXRhbjIoc2lucmNvc3AsIGNvc3Jjb3NwKTtcclxuXHJcbiAgICAgICAgLy8gcGl0Y2ggKHktYXhpcyByb3RhdGlvbilcclxuICAgICAgICBsZXQgc2lucDogbnVtYmVyID0gMiAqICh0aGlzLncgKiB0aGlzLnkgLSB0aGlzLnogKiB0aGlzLngpO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhzaW5wKSA+PSAxKVxyXG4gICAgICAgICAgdGhpcy4jZXVsZXJBbmdsZXMueSA9IHNpbnAgPCAwID8gLU1hdGguYWJzKE1hdGguUEkgLyAyKSA6IE1hdGguYWJzKE1hdGguUEkgLyAyKTsgLy8gdXNlIDkwIGRlZ3JlZXMgaWYgb3V0IG9mIHJhbmdlXHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhpcy4jZXVsZXJBbmdsZXMueSA9IE1hdGguYXNpbihzaW5wKTtcclxuXHJcbiAgICAgICAgLy8geWF3ICh6LWF4aXMgcm90YXRpb24pXHJcbiAgICAgICAgbGV0IHNpbnljb3NwOiBudW1iZXIgPSAyICogKHRoaXMudyAqIHRoaXMueiArIHRoaXMueCAqIHRoaXMueSk7XHJcbiAgICAgICAgbGV0IGNvc3ljb3NwOiBudW1iZXIgPSAxIC0gMiAqICh0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnopO1xyXG4gICAgICAgIHRoaXMuI2V1bGVyQW5nbGVzLnogPSBNYXRoLmF0YW4yKHNpbnljb3NwLCBjb3N5Y29zcCk7XHJcblxyXG4gICAgICAgIHRoaXMuI2V1bGVyQW5nbGVzLnNjYWxlKENhbGMucmFkMmRlZyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLiNldWxlckFuZ2xlcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGV1bGVyQW5nbGVzKF9ldWxlckFuZ2xlczogVmVjdG9yMykge1xyXG4gICAgICBjb25zdCBoYWxmZGVnMnJhZDogbnVtYmVyID0gQ2FsYy5kZWcycmFkIC8gMjtcclxuICAgICAgY29uc3QgeDogbnVtYmVyID0gX2V1bGVyQW5nbGVzLnggKiBoYWxmZGVnMnJhZCwgeTogbnVtYmVyID0gX2V1bGVyQW5nbGVzLnkgKiBoYWxmZGVnMnJhZCwgejogbnVtYmVyID0gX2V1bGVyQW5nbGVzLnogKiBoYWxmZGVnMnJhZDtcclxuXHJcbiAgICAgIGNvbnN0IGNvc1g6IG51bWJlciA9IE1hdGguY29zKHgpO1xyXG4gICAgICBjb25zdCBjb3NZOiBudW1iZXIgPSBNYXRoLmNvcyh5KTtcclxuICAgICAgY29uc3QgY29zWjogbnVtYmVyID0gTWF0aC5jb3Moeik7XHJcbiAgICAgIGNvbnN0IHNpblg6IG51bWJlciA9IE1hdGguc2luKHgpO1xyXG4gICAgICBjb25zdCBzaW5ZOiBudW1iZXIgPSBNYXRoLnNpbih5KTtcclxuICAgICAgY29uc3Qgc2luWjogbnVtYmVyID0gTWF0aC5zaW4oeik7XHJcblxyXG4gICAgICB0aGlzLnggPSBzaW5YICogY29zWSAqIGNvc1ogLSBjb3NYICogc2luWSAqIHNpblo7XHJcbiAgICAgIHRoaXMueSA9IGNvc1ggKiBzaW5ZICogY29zWiArIHNpblggKiBjb3NZICogc2luWjtcclxuICAgICAgdGhpcy56ID0gY29zWCAqIGNvc1kgKiBzaW5aIC0gc2luWCAqIHNpblkgKiBjb3NaO1xyXG4gICAgICB0aGlzLncgPSBjb3NYICogY29zWSAqIGNvc1ogKyBzaW5YICogc2luWSAqIHNpblo7XHJcblxyXG4gICAgICAvLyB0aGlzLnNldChcclxuICAgICAgLy8gICBzaW5YICogY29zWSAqIGNvc1ogLSBjb3NYICogc2luWSAqIHNpblosXHJcbiAgICAgIC8vICAgY29zWCAqIHNpblkgKiBjb3NaICsgc2luWCAqIGNvc1kgKiBzaW5aLFxyXG4gICAgICAvLyAgIGNvc1ggKiBjb3NZICogc2luWiAtIHNpblggKiBzaW5ZICogY29zWixcclxuICAgICAgLy8gICBjb3NYICogY29zWSAqIGNvc1ogKyBzaW5YICogc2luWSAqIHNpblpcclxuICAgICAgLy8gKTtcclxuXHJcbiAgICAgIHRoaXMuI2V1bGVyQW5nbGVzLmNvcHkoX2V1bGVyQW5nbGVzKTtcclxuICAgICAgdGhpcy4jZXVsZXJBbmdsZXNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29waWVzIHRoZSBnaXZlbiBxdWF0ZXJuaW9uLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29weShfb3JpZ2luYWw6IFF1YXRlcm5pb24pOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgdGhpcy54ID0gX29yaWdpbmFsLng7XHJcbiAgICAgIHRoaXMueSA9IF9vcmlnaW5hbC55O1xyXG4gICAgICB0aGlzLnogPSBfb3JpZ2luYWwuejtcclxuICAgICAgdGhpcy53ID0gX29yaWdpbmFsLnc7XHJcbiAgICAgIHRoaXMuI2V1bGVyQW5nbGVzRGlydHkgPSBfb3JpZ2luYWwuI2V1bGVyQW5nbGVzRGlydHk7XHJcbiAgICAgIGlmICghdGhpcy4jZXVsZXJBbmdsZXNEaXJ0eSlcclxuICAgICAgICB0aGlzLiNldWxlckFuZ2xlcy5jb3B5KF9vcmlnaW5hbC4jZXVsZXJBbmdsZXMpO1xyXG4gICAgICAvLyB0aGlzLm11dGF0b3IgPSBudWxsO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgcXVhdGVybmlvbiB0byB0aGUgaWRlbnRpdHktcXVhdGVybmlvbiBhbmQgY2xlYXJzIGNhY2hlLiBVc2VkIGJ5IHRoZSByZWN5Y2xlciB0byByZXNldC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlY3ljbGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY29tcG9uZW50cyBvZiB0aGlzIHF1YXRlcm5pb24uXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHF1YXRlcm5pb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX3g6IG51bWJlciwgX3k6IG51bWJlciwgX3o6IG51bWJlciwgX3c6IG51bWJlcik6IFF1YXRlcm5pb24ge1xyXG4gICAgICB0aGlzLnggPSBfeDtcclxuICAgICAgdGhpcy55ID0gX3k7XHJcbiAgICAgIHRoaXMueiA9IF96O1xyXG4gICAgICB0aGlzLncgPSBfdztcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcXVhdGVybmlvbiBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gcXVhdGVybmlvbiB3aXRoaW4gdGhlIGdpdmVuIHRvbGVyYW5jZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGVxdWFscyhfY29tcGFyZTogUXVhdGVybmlvbiwgX3RvbGVyYW5jZTogbnVtYmVyID0gTnVtYmVyLkVQU0lMT04pOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueCAtIF9jb21wYXJlLngpIDw9IF90b2xlcmFuY2UgJiZcclxuICAgICAgICBNYXRoLmFicyh0aGlzLnkgLSBfY29tcGFyZS55KSA8PSBfdG9sZXJhbmNlICYmXHJcbiAgICAgICAgTWF0aC5hYnModGhpcy56IC0gX2NvbXBhcmUueikgPD0gX3RvbGVyYW5jZSAmJlxyXG4gICAgICAgIE1hdGguYWJzKHRoaXMudyAtIF9jb21wYXJlLncpIDw9IF90b2xlcmFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemVzIHRoaXMgcXVhdGVybmlvbiB0byBhIGxlbmd0aCBvZiAxIChhIHVuaXQgcXVhdGVybmlvbikgbWFraW5nIGl0IGEgdmFsaWQgcm90YXRpb24gcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHF1YXRlcm5pb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBub3JtYWxpemUoKTogUXVhdGVybmlvbiB7XHJcbiAgICAgIGxldCBsZW5ndGg6IG51bWJlciA9IE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncpO1xyXG4gICAgICBpZiAobGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGVuZ3RoID0gMSAvIGxlbmd0aDtcclxuICAgICAgICB0aGlzLnggKj0gbGVuZ3RoO1xyXG4gICAgICAgIHRoaXMueSAqPSBsZW5ndGg7XHJcbiAgICAgICAgdGhpcy56ICo9IGxlbmd0aDtcclxuICAgICAgICB0aGlzLncgKj0gbGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOZWdhdGVzIHRoaXMgcXVhdGVybmlvbi5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgcXVhdGVybmlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5lZ2F0ZSgpOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgdGhpcy54ID0gLXRoaXMueDtcclxuICAgICAgdGhpcy55ID0gLXRoaXMueTtcclxuICAgICAgdGhpcy56ID0gLXRoaXMuejtcclxuICAgICAgdGhpcy53ID0gLXRoaXMudztcclxuICAgICAgdGhpcy5yZXNldENhY2hlKCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW52ZXJ0IHRoaXMgcXVhdGVybmlvbi5cclxuICAgICAqIFF1YXRlcm5pb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW52ZXJ0KCk6IFF1YXRlcm5pb24ge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb25qdWdhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbmp1Z2F0ZXMgdGhpcyBxdWF0ZXJuaW9uIGFuZCByZXR1cm5zIGl0LlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29uanVnYXRlKCk6IFF1YXRlcm5pb24ge1xyXG4gICAgICB0aGlzLnggPSAtdGhpcy54O1xyXG4gICAgICB0aGlzLnkgPSAtdGhpcy55O1xyXG4gICAgICB0aGlzLnogPSAtdGhpcy56O1xyXG4gICAgICB0aGlzLnJlc2V0Q2FjaGUoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBseSB0aGlzIHF1YXRlcm5pb24gd2l0aCB0aGUgZ2l2ZW4gcXVhdGVybmlvbi5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgcXVhdGVybmlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG11bHRpcGx5KF9xdWF0ZXJuaW9uOiBRdWF0ZXJuaW9uLCBfZnJvbUxlZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IFF1YXRlcm5pb24ge1xyXG4gICAgICByZXR1cm4gUXVhdGVybmlvbi5QUk9EVUNUKHRoaXMsIF9xdWF0ZXJuaW9uLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByZW11bHRpcGx5IHRoaXMgcXVhdGVybmlvbiB3aXRoIHRoZSBnaXZlbiBxdWF0ZXJuaW9uLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcHJlbXVsdGlwbHkoX3F1YXRlcm5pb246IFF1YXRlcm5pb24pOiBRdWF0ZXJuaW9uIHtcclxuICAgICAgcmV0dXJuIFF1YXRlcm5pb24uUFJPRFVDVChfcXVhdGVybmlvbiwgdGhpcywgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHF1YXRlcm5pb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBgxpIuUXVhdGVybmlvbih4OiAke3RoaXMueH0sIHk6ICR7dGhpcy55fSwgejogJHt0aGlzLnp9LCB3OiAke3RoaXMud30pYDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjdXJyZW50bHkgcXVhdGVybmlvbnMgYXJlIG5ldmVyIHNlcmlhbGl6ZWQsIHNvIHRoaXMgaXMgbm90IG5lZWRlZC4gQnV0IG1heWJlIGl0IHdpbGwgYmUgaW4gdGhlIGZ1dHVyZS5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24udG9KU09OID0gKCkgPT4geyByZXR1cm4gYFske3RoaXMueH0sICR7dGhpcy55fSwgJHt0aGlzLnp9LCAke3RoaXMud31dYDsgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxRdWF0ZXJuaW9uPiB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9zZXJpYWxpemF0aW9uKSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgW3RoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMud10gPSBKU09OLnBhcnNlKDxzdHJpbmc+PHVua25vd24+X3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICB9IGVsc2VcclxuICAgICAgICB0aGlzLm11dGF0ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvdmVycmlkZSBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgaWYgKF9tdXRhdG9yLnggIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMueCA9IF9tdXRhdG9yLng7XHJcbiAgICAgIGlmIChfbXV0YXRvci55ICE9IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLnkgPSBfbXV0YXRvci55O1xyXG4gICAgICBpZiAoX211dGF0b3IueiAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy56ID0gX211dGF0b3IuejtcclxuICAgICAgaWYgKF9tdXRhdG9yLncgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMudyA9IF9tdXRhdG9yLnc7XHJcbiAgICAgIHRoaXMucmVzZXRDYWNoZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuXHJcbiAgICBwcml2YXRlIHJlc2V0Q2FjaGUoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI2V1bGVyQW5nbGVzRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIENsYXNzIGZvciBjcmVhdGluZyByYW5kb20gdmFsdWVzLCBzdXBwb3J0aW5nIEphdmFzY3JpcHQncyBNYXRoLnJhbmRvbSBhbmQgYSBkZXRlcm1pbmlzdGlnIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciAoUFJORykgXHJcbiAgICogdGhhdCBjYW4gYmUgZmVkIHdpdGggYSBzZWVkIGFuZCB0aGVuIHJldHVybnMgYSByZXByb2R1Y2FibGUgc2V0IG9mIHJhbmRvbSBudW1iZXJzIChpZiB0aGUgcHJlY2lzaW9uIG9mIEphdmFzY3JpcHQgYWxsb3dzKSBcclxuICAgKiBcclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFJhbmRvbSB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmF1bHQ6IFJhbmRvbSA9IG5ldyBSYW5kb20oKTtcclxuICAgIHByaXZhdGUgZ2VuZXJhdGU6IEZ1bmN0aW9uID0gTWF0aC5yYW5kb207XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFJhbmRvbX0uIFxyXG4gICAgICogSWYgYSBzZWVkIGlzIGdpdmVuLCBMRklCNCBpcyB1c2VkIGFzIGdlbmVyYXRvciwgcmVwcm9kdWNpbmcgYSBzZXJpZXMgb2YgbnVtYmVycyBmcm9tIHRoYXQgc2VlZC5cclxuICAgICAqIElmIGEgZnVuY3Rpb24gcHJvZHVjaW5nIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgdXNlZCBhcyBnZW5lcmF0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihfc2VlZE9yRnVuY3Rpb24/OiBudW1iZXIgfCBGdW5jdGlvbikge1xyXG4gICAgICBpZiAoX3NlZWRPckZ1bmN0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24pXHJcbiAgICAgICAgdGhpcy5nZW5lcmF0ZSA9IF9zZWVkT3JGdW5jdGlvbjtcclxuICAgICAgZWxzZSBpZiAoX3NlZWRPckZ1bmN0aW9uID09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLmdlbmVyYXRlID0gTWF0aC5yYW5kb207XHJcbiAgICAgIGVsc2VcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICB0aGlzLmdlbmVyYXRlID0gbmV3IExGSUI0KF9zZWVkT3JGdW5jdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbm9ybWVkIHJhbmRvbSBudW1iZXIsIHRodXMgaW4gdGhlIHJhbmdlIG9mIFswLCAxW1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Tm9ybSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBudW1iZXIgaW4gdGhlIHJhbmdlIG9mIGdpdmVuIFtfbWluLCBfbWF4W1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmFuZ2UoX21pbjogbnVtYmVyLCBfbWF4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gX21pbiArIHRoaXMuZ2VuZXJhdGUoKSAqIChfbWF4IC0gX21pbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgbnVtYmVyIGluIHRoZSByYW5nZSBvZiBnaXZlbiBmbG9vcmVkIFtfbWluLCBfbWF4W1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UmFuZ2VGbG9vcmVkKF9taW46IG51bWJlciwgX21heDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5nZXRSYW5nZShfbWluLCBfbWF4KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgcmFuZG9tbHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEJvb2xlYW4oKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlKCkgPCAwLjU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIC0xIG9yIDEgcmFuZG9tbHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFNpZ24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm9vbGVhbigpID8gMSA6IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbWx5IHNlbGVjdGVkIGluZGV4IGludG8gdGhlIGdpdmVuIGFycmF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRJbmRleDxUPihfYXJyYXk6IEFycmF5PFQ+KTogbnVtYmVyIHtcclxuICAgICAgaWYgKF9hcnJheS5sZW5ndGggPiAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFJhbmdlRmxvb3JlZCgwLCBfYXJyYXkubGVuZ3RoKTtcclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbWx5IHNlbGVjdGVkIGVsZW1lbnQgb2YgdGhlIGdpdmVuIGFycmF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRFbGVtZW50PFQ+KF9hcnJheTogQXJyYXk8VD4pOiBUIHtcclxuICAgICAgaWYgKF9hcnJheS5sZW5ndGggPiAwKVxyXG4gICAgICAgIHJldHVybiBfYXJyYXlbdGhpcy5nZXRJbmRleChfYXJyYXkpXTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgcmFuZG9tbHkgc2VsZWN0ZWQgZWxlbWVudCBmcm9tIHRoZSBnaXZlbiBhcnJheSBhbmQgcmV0dXJucyBpdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3BsaWNlPFQ+KF9hcnJheTogQXJyYXk8VD4pOiBUIHtcclxuICAgICAgcmV0dXJuIF9hcnJheS5zcGxpY2UodGhpcy5nZXRJbmRleChfYXJyYXkpLCAxKVswXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBrZXkgZnJvbSB0aGUgZ2l2ZW4gTWFwLWluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRLZXk8VCwgVT4oX21hcDogTWFwPFQsIFU+KTogVCB7XHJcbiAgICAgIGxldCBrZXlzOiBHZW5lcmFsID0gQXJyYXkuZnJvbShfbWFwLmtleXMoKSk7XHJcbiAgICAgIHJldHVybiBrZXlzW3RoaXMuZ2V0SW5kZXgoa2V5cyldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbWx5IHNlbGVjdGVkIHByb3BlcnR5IG5hbWUgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQcm9wZXJ0eU5hbWU8VD4oX29iamVjdDogVCk6IGtleW9mIFQge1xyXG4gICAgICBsZXQga2V5czogc3RyaW5nW10gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhfb2JqZWN0KTtcclxuICAgICAgcmV0dXJuIDxrZXlvZiBUPmtleXNbdGhpcy5nZXRJbmRleChrZXlzKV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tbHkgc2VsZWN0ZWQgc3ltYm9sIGZyb20gdGhlIGdpdmVuIG9iamVjdCwgaWYgc3ltYm9scyBhcmUgdXNlZCBhcyBrZXlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQcm9wZXJ0eVN5bWJvbDxUPihfb2JqZWN0OiBUKTogc3ltYm9sIHtcclxuICAgICAgbGV0IGtleXM6IHN5bWJvbFtdID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhfb2JqZWN0KTtcclxuICAgICAgcmV0dXJuIGtleXNbdGhpcy5nZXRJbmRleChrZXlzKV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tIHRocmVlLWRpbWVuc2lvbmFsIHZlY3RvciBpbiB0aGUgbGltaXRzIG9mIHRoZSBib3ggZGVmaW5lZCBieSB0aGUgdmVjdG9ycyBnaXZlbiBhcyBbX2Nvcm5lcjAsIF9jb3JuZXIxW1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VmVjdG9yMyhfY29ybmVyMDogVmVjdG9yMywgX2Nvcm5lcjE6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuZ2V0UmFuZ2UoX2Nvcm5lcjAueCwgX2Nvcm5lcjEueCksIHRoaXMuZ2V0UmFuZ2UoX2Nvcm5lcjAueSwgX2Nvcm5lcjEueSksIHRoaXMuZ2V0UmFuZ2UoX2Nvcm5lcjAueiwgX2Nvcm5lcjEueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSB0d28tZGltZW5zaW9uYWwgdmVjdG9yIGluIHRoZSBsaW1pdHMgb2YgdGhlIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHRoZSB2ZWN0b3JzIGdpdmVuIGFzIFtfY29ybmVyMCwgX2Nvcm5lcjFbXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRWZWN0b3IyKF9jb3JuZXIwOiBWZWN0b3IyLCBfY29ybmVyMTogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy5nZXRSYW5nZShfY29ybmVyMC54LCBfY29ybmVyMS54KSwgdGhpcy5nZXRSYW5nZShfY29ybmVyMC55LCBfY29ybmVyMS55KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29sb3Igd2l0aCBpdHMgciwgZywgYiB2YWx1ZXMgc2V0IHRvIHJhbmRvbSBudW1iZXJzIGluIHRoZSByYW5nZSBvZiBbMCwgMVsuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb2xvcigpOiBDb2xvciB7XHJcbiAgICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5nZXROb3JtKCksIHRoaXMuZ2V0Tm9ybSgpLCB0aGlzLmdldE5vcm0oKSwgMSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFuZGFyZCB7QGxpbmsgUmFuZG9tfS1pbnN0YW5jZSB1c2luZyBNYXRoLnJhbmRvbSgpLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjb25zdCByYW5kb206IFJhbmRvbSA9IG5ldyBSYW5kb20oKTtcclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFN0b3JlcyBhbmQgbWFuaXB1bGF0ZXMgYSB0aHJlZWRpbWVuc2lvbmFsIHZlY3RvciBjb21wcmlzZWQgb2YgdGhlIGNvbXBvbmVudHMgeCwgeSBhbmQgelxyXG4gICAqIGBgYHRleHRcclxuICAgKiAgICAgICAgICAgICt5XHJcbiAgICogICAgICAgICAgICAgfF9fICt4XHJcbiAgICogICAgICAgICAgICAvXHJcbiAgICogICAgICAgICAgK3ogICBcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5LTIwMjIgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVmVjdG9yMyBleHRlbmRzIE11dGFibGUgaW1wbGVtZW50cyBTZXJpYWxpemFibGUsIFJlY3ljYWJsZSB7XHJcbiAgICAvKiogXHJcbiAgICAgKiBBcnJheSBvZiB0aGUga2V5cyBvZiBhIHZlY3Rvci4gQWxsb3dzIHRvIHRyYW5zbGF0ZSBhbiBpbmRleCAoMCwgMSwgMikgdG8gYSBrZXkgKFwieFwiLCBcInlcIiwgXCJ6XCIpIG9yIHRvIGl0ZXJhdGUgb3ZlciBhIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBrZXlzOiByZWFkb25seSBbXCJ4XCIsIFwieVwiLCBcInpcIl0gPSBbXCJ4XCIsIFwieVwiLCBcInpcIl07XHJcblxyXG4gICAgcHVibGljIHg6IG51bWJlcjtcclxuICAgIHB1YmxpYyB5OiBudW1iZXI7XHJcbiAgICBwdWJsaWMgejogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF96OiBudW1iZXIgPSAwKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2V0KF94LCBfeSwgX3opO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBTdGF0aWNcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gbGVuZ3RoIHBvaW50aW5nIGluIHgtZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgWChfc2NhbGU6IG51bWJlciA9IDEpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpLnNldChfc2NhbGUsIDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBsZW5ndGggcG9pbnRpbmcgaW4geS1kaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBZKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gUmVjeWNsZXIucmV1c2UoVmVjdG9yMykuc2V0KDAsIF9zY2FsZSwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGxlbmd0aCBwb2ludGluZyBpbiB6LWRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFooX3NjYWxlOiBudW1iZXIgPSAxKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKS5zZXQoMCwgMCwgX3NjYWxlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3Igd2l0aCB0aGUgdmFsdWUgMCBvbiBlYWNoIGF4aXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBaRVJPKCk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciBvZiB0aGUgZ2l2ZW4gc2l6ZSBvbiBlYWNoIG9mIHRoZSB0aHJlZSBheGlzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgT05FKF9zY2FsZTogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gUmVjeWNsZXIucmV1c2UoVmVjdG9yMykuc2V0KF9zY2FsZSwgX3NjYWxlLCBfc2NhbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB0aHJvdWdoIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBnaXZlbiB2ZWN0b3IgYnkgdGhlIGdpdmVuIG1hdHJpeCBvciByb3RhdGlvbiBxdWF0ZXJuaW9uLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVFJBTlNGT1JNQVRJT04oX3ZlY3RvcjogVmVjdG9yMywgX3RyYW5zZm9ybTogTWF0cml4NHg0IHwgUXVhdGVybmlvbiwgX2luY2x1ZGVUcmFuc2xhdGlvbjogYm9vbGVhbiA9IHRydWUsIF9vdXQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKSk6IFZlY3RvcjMge1xyXG4gICAgICBpZiAoX3RyYW5zZm9ybSBpbnN0YW5jZW9mIE1hdHJpeDR4NCkge1xyXG4gICAgICAgIGNvbnN0IG06IEFycmF5TGlrZTxudW1iZXI+ID0gX3RyYW5zZm9ybS5nZXRBcnJheSgpO1xyXG5cclxuICAgICAgICBfb3V0LnNldChcclxuICAgICAgICAgIG1bMF0gKiBfdmVjdG9yLnggKyBtWzRdICogX3ZlY3Rvci55ICsgbVs4XSAqIF92ZWN0b3IueixcclxuICAgICAgICAgIG1bMV0gKiBfdmVjdG9yLnggKyBtWzVdICogX3ZlY3Rvci55ICsgbVs5XSAqIF92ZWN0b3IueixcclxuICAgICAgICAgIG1bMl0gKiBfdmVjdG9yLnggKyBtWzZdICogX3ZlY3Rvci55ICsgbVsxMF0gKiBfdmVjdG9yLnpcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoX2luY2x1ZGVUcmFuc2xhdGlvbilcclxuICAgICAgICAgIF9vdXQuYWRkKF90cmFuc2Zvcm0udHJhbnNsYXRpb24pO1xyXG5cclxuICAgICAgICByZXR1cm4gX291dDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRnJvbTogaHR0cHM6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvdHJhbnNmb3Jtcy9pbmRleC5odG1cclxuICAgICAgLy8gb3V0ID0gcSAqIHF1YXRlcm5pb24odmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiwgMCkgKiBjb25qKHEpXHJcblxyXG4gICAgICAvLyBxICogcXVhdGVybmlvbih2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56LCAwKSAuLi5cclxuICAgICAgY29uc3QgcXg6IG51bWJlciA9IF90cmFuc2Zvcm0udyAqIF92ZWN0b3IueCArIF90cmFuc2Zvcm0ueSAqIF92ZWN0b3IueiAtIF90cmFuc2Zvcm0ueiAqIF92ZWN0b3IueTtcclxuICAgICAgY29uc3QgcXk6IG51bWJlciA9IF90cmFuc2Zvcm0udyAqIF92ZWN0b3IueSArIF90cmFuc2Zvcm0ueiAqIF92ZWN0b3IueCAtIF90cmFuc2Zvcm0ueCAqIF92ZWN0b3IuejtcclxuICAgICAgY29uc3QgcXo6IG51bWJlciA9IF90cmFuc2Zvcm0udyAqIF92ZWN0b3IueiArIF90cmFuc2Zvcm0ueCAqIF92ZWN0b3IueSAtIF90cmFuc2Zvcm0ueSAqIF92ZWN0b3IueDtcclxuICAgICAgY29uc3QgcXc6IG51bWJlciA9IC1fdHJhbnNmb3JtLnggKiBfdmVjdG9yLnggLSBfdHJhbnNmb3JtLnkgKiBfdmVjdG9yLnkgLSBfdHJhbnNmb3JtLnogKiBfdmVjdG9yLno7XHJcblxyXG4gICAgICAvLyAuLi4gKiBjb25qKHEpXHJcbiAgICAgIHJldHVybiBfb3V0LnNldChcclxuICAgICAgICBxeCAqIF90cmFuc2Zvcm0udyArIHF3ICogLSBfdHJhbnNmb3JtLnggKyBxeSAqIC0gX3RyYW5zZm9ybS56IC0gcXogKiAtIF90cmFuc2Zvcm0ueSxcclxuICAgICAgICBxeSAqIF90cmFuc2Zvcm0udyArIHF3ICogLSBfdHJhbnNmb3JtLnkgKyBxeiAqIC0gX3RyYW5zZm9ybS54IC0gcXggKiAtIF90cmFuc2Zvcm0ueixcclxuICAgICAgICBxeiAqIF90cmFuc2Zvcm0udyArIHF3ICogLSBfdHJhbnNmb3JtLnogKyBxeCAqIC0gX3RyYW5zZm9ybS55IC0gcXkgKiAtIF90cmFuc2Zvcm0ueFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHZlY3RvciB3aGljaCBpcyBhIGNvcHkgb2YgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgdG8gdGhlIGdpdmVuIGxlbmd0aC5cclxuICAgICAqIEBwYXJhbSBfb3V0IE9wdGlvbmFsIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE5PUk1BTElaQVRJT04oX3ZlY3RvcjogVmVjdG9yMywgX2xlbmd0aDogbnVtYmVyID0gMSwgX291dDogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBfb3V0LmNvcHkoX3ZlY3Rvcikubm9ybWFsaXplKF9sZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbiBvZiB0d28gdmVjdG9ycy5cclxuICAgICAqIEBwYXJhbSBfb3V0IE9wdGlvbmFsIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNVTShfYTogVmVjdG9yMywgX2I6IFZlY3RvcjMsIF9vdXQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKSk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gX291dC5zZXQoX2EueCArIF9iLngsIF9hLnkgKyBfYi55LCBfYS56ICsgX2Iueik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uIG9mIHR3byB2ZWN0b3JzLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRElGRkVSRU5DRShfbWludWVuZDogVmVjdG9yMywgX3N1YnRyYWhlbmQ6IFZlY3RvcjMsIF9vdXQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKSk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gX291dC5zZXQoX21pbnVlbmQueCAtIF9zdWJ0cmFoZW5kLngsIF9taW51ZW5kLnkgLSBfc3VidHJhaGVuZC55LCBfbWludWVuZC56IC0gX3N1YnRyYWhlbmQueik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIHNjYWxpbmcgZmFjdG9yLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0NBTEUoX3ZlY3RvcjogVmVjdG9yMywgX3NjYWxpbmc6IG51bWJlciwgX291dDogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBfb3V0LnNldChfdmVjdG9yLnggKiBfc2NhbGluZywgX3ZlY3Rvci55ICogX3NjYWxpbmcsIF92ZWN0b3IueiAqIF9zY2FsaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmVjdG9yIHNjYWxlZCBieSB0aGUgZ2l2ZW4gc2NhbGluZyBmYWN0b3IuXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBORUdBVElPTihfdmVjdG9yOiBWZWN0b3IzLCBfb3V0OiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMykpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIF9vdXQuc2V0KC1fdmVjdG9yLngsIC1fdmVjdG9yLnksIC1fdmVjdG9yLnopO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGl2aWRlcyB0aGUgZGl2aWRlbmQgYnkgdGhlIGRpdmlzb3IgY29tcG9uZW50IGJ5IGNvbXBvbmVudCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUkFUSU8oX2RpdmlkZW5kOiBWZWN0b3IzLCBfZGl2aXNvcjogVmVjdG9yMywgX291dDogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBfb3V0LnNldChfZGl2aWRlbmQueCAvIF9kaXZpc29yLngsIF9kaXZpZGVuZC55IC8gX2Rpdmlzb3IueSwgX2RpdmlkZW5kLnogLyBfZGl2aXNvci56KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBjcm9zc3Byb2R1Y3Qgb2YgMiB2ZWN0b3JzLiBcclxuICAgICAqIEBwYXJhbSBfb3V0IE9wdGlvbmFsIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENST1NTKF9hOiBWZWN0b3IzLCBfYjogVmVjdG9yMywgX291dDogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBfb3V0LnNldChcclxuICAgICAgICBfYS55ICogX2IueiAtIF9hLnogKiBfYi55LFxyXG4gICAgICAgIF9hLnogKiBfYi54IC0gX2EueCAqIF9iLnosXHJcbiAgICAgICAgX2EueCAqIF9iLnkgLSBfYS55ICogX2IueFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIGRvdHByb2R1Y3Qgb2YgMiB2ZWN0b3JzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERPVChfYTogVmVjdG9yMywgX2I6IFZlY3RvcjMpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gX2EueCAqIF9iLnggKyBfYS55ICogX2IueSArIF9hLnogKiBfYi56O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgaW5jb21pbmcgdmVjdG9yIGF0IHRoZSBnaXZlbiBub3JtYWwgdmVjdG9yLiBUaGUgbGVuZ3RoIG9mIG5vcm1hbCBzaG91bGQgYmUgMS5cclxuICAgICAqIGBgYHRleHRcclxuICAgICAqIF9fX19fX19fX19fX19fX19fX19fX19fX19cclxuICAgICAqICAgICAgICAgICAvfFxcXHJcbiAgICAgKiBpbmNvbWluZyAvIHwgXFwgcmVmbGVjdGlvblxyXG4gICAgICogICAgICAgICAvICB8ICBcXCAgIFxyXG4gICAgICogICAgICAgICAgbm9ybWFsXHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBwYXJhbSBfb3V0IE9wdGlvbmFsIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJFRkxFQ1RJT04oX2luY29taW5nOiBWZWN0b3IzLCBfbm9ybWFsOiBWZWN0b3IzLCBfb3V0OiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMykpOiBWZWN0b3IzIHtcclxuICAgICAgaWYgKF9vdXQgPT0gX2luY29taW5nKSAvLyBjbG9uZSBfaW5jb21pbmcgdG8gYWxsb3cgcmVhZGluZyBmcm9tIGl0XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUoX2luY29taW5nID0gX2luY29taW5nLmNsb25lKTsgLy8gZGFuZ2Vyb3VzLCB0aGlzIG9ubHkgd29ya3MgYmVjYXVzZSBzdXAtbWV0aG9kIGNhbGxzIGRvbid0IGZldGNoIGZyb20gcmVjeWNsZXJcclxuXHJcbiAgICAgIHJldHVybiBWZWN0b3IzLlNVTShfaW5jb21pbmcsIFZlY3RvcjMuU0NBTEUoX25vcm1hbCwgMiAqIC1WZWN0b3IzLkRPVChfaW5jb21pbmcsIF9ub3JtYWwpLCBfb3V0KSwgX291dCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY2FydGVzaWFuIHZlY3RvciBmcm9tIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBHRU8oX2xvbmdpdHVkZTogbnVtYmVyID0gMCwgX2xhdGl0dWRlOiBudW1iZXIgPSAwLCBfbWFnbml0dWRlOiBudW1iZXIgPSAxLCBfb3V0OiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMykpOiBWZWN0b3IzIHtcclxuICAgICAgY29uc3QgZ2VvOiBHZW8zID0gUmVjeWNsZXIucmV1c2UoR2VvMykuc2V0KF9sb25naXR1ZGUsIF9sYXRpdHVkZSwgX21hZ25pdHVkZSk7XHJcbiAgICAgIF9vdXQuZ2VvID0gZ2VvO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShnZW8pO1xyXG4gICAgICByZXR1cm4gX291dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgYW5nbGUgaW4gZGVncmVlcyBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gdmVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBBTkdMRShfZnJvbTogVmVjdG9yMywgX3RvOiBWZWN0b3IzKTogbnVtYmVyIHtcclxuICAgICAgbGV0IGFuZ2xlOiBudW1iZXIgPSBNYXRoLmFjb3MoQ2FsYy5jbGFtcChWZWN0b3IzLkRPVChfZnJvbSwgX3RvKSAvIChfZnJvbS5tYWduaXR1ZGUgKiBfdG8ubWFnbml0dWRlKSwgLTEsIDEpKTsgLy8gY2xhbXAgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBlcnJvcnMgd2hlbiBmcm9tID09IHRvXHJcbiAgICAgIHJldHVybiBhbmdsZSAqIENhbGMucmFkMmRlZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgcHJvamVjdGlvbiBvZiBhIG9udG8gYi5cclxuICAgICAqIEBwYXJhbSBfb3V0IE9wdGlvbmFsIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFBST0pFQ1RJT04oX2E6IFZlY3RvcjMsIF9iOiBWZWN0b3IzLCBfb3V0OiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMykpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIF9vdXQuY29weShfYSkucHJvamVjdChfYik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWN0b3JzLiBXaGVuIHQgaXMgMCB0aGUgcmVzdWx0IGlzIGEsIHdoZW4gdCBpcyAxIHRoZSByZXN1bHQgaXMgYi4gQ2xhbXBzIHQgYmV0d2VlbiAwIGFuZCAxLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTEVSUChfYTogVmVjdG9yMywgX2I6IFZlY3RvcjMsIF90OiBudW1iZXIsIF9vdXQ6IFZlY3RvcjMgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKSk6IFZlY3RvcjMge1xyXG4gICAgICBfdCA9IENhbGMuY2xhbXAoX3QsIDAsIDEpO1xyXG4gICAgICByZXR1cm4gX291dC5zZXQoXHJcbiAgICAgICAgX2EueCArIF90ICogKF9iLnggLSBfYS54KSxcclxuICAgICAgICBfYS55ICsgX3QgKiAoX2IueSAtIF9hLnkpLFxyXG4gICAgICAgIF9hLnogKyBfdCAqIChfYi56IC0gX2EueilcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNtb290aGx5IGludGVycG9sYXRlcyBiZXR3ZWVuIHR3byB2ZWN0b3JzIGJhc2VkIG9uIGEgY3JpdGljYWxseSBkYW1wZWQgc3ByaW5nIG1vZGVsLiBcclxuICAgICAqIEFsbG93cyB0byBzbW9vdGggdG93YXJkIGEgbW92aW5nIHRhcmdldCB3aXRoIGFuIGVhc2UtaW4vZWFzZS1vdXQgbW90aW9uIG1haW50YWluaW5nIGEgY29udGludW91cyB2ZWxvY2l0eS5cclxuICAgICAqIERvZXMgbm90IG92ZXJzaG9vdC5cclxuICAgICAqIEBwYXJhbSBfY3VycmVudCAtIFRoZSBjdXJyZW50IHZhbHVlLlxyXG4gICAgICogQHBhcmFtIF90YXJnZXQgLSBUaGUgdGFyZ2V0IHZhbHVlLlxyXG4gICAgICogQHBhcmFtIF92ZWxvY2l0eSAtIFRoZSB2ZWxvY2l0eSBhdCB3aGljaCB0aGUgdmFsdWUgaXMgbW92aW5nLiBUaGlzIHZhbHVlIGlzICoqbW9kaWZpZWQqKiBieSB0aGUgZnVuY3Rpb24gYW5kIG11c3QgYmUgbWFpbnRhaW5lZCBpbiB0aGUgb3V0c2lkZSBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIF9zbW9vdGhUaW1lIC0gVGhlIHRpbWUgaXQgd291bGQgdGFrZSBmb3IgdGhlIHZhbHVlIHRvIHJlYWNoIHRoZSB0YXJnZXQgaWYgaXQgd2VyZSBtb3ZpbmcgYXQgbWF4aW11bSB2ZWxvY2l0eSBmb3IgdGhlIGVudGlyZSBkdXJhdGlvbi4gV2hlbiBmb2xsb3dpbmcgYSBtb3ZpbmcgdGFyZ2V0IHRoZSBzbW9vdGggdGltZSBlcXVhbHMgdGhlIGxhZyB0aW1lIGFsbG93aW5nIHRvIGNhbGN1bGF0ZSB0aGUgYGxhZyBkaXN0YW5jZSA9IHRhcmdldCB2ZWxvY2l0eSAqIHNtb290aCB0aW1lYC5cclxuICAgICAqIEBwYXJhbSBfdGltZUZyYW1lIC0gVGhlIGVsYXBzZWQgdGltZSBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBmdW5jdGlvbi5cclxuICAgICAqIEBwYXJhbSBfbWF4U3BlZWQgLSBBbiBvcHRpb25hbCBtYXhpbXVtIHNwZWVkIHRoYXQgbGltaXRzIHRoZSB2ZWxvY2l0eSBvZiB0aGUgdmFsdWUuIERlZmF1bHRzIHRvIEluZmluaXR5LlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKiBAc291cmNlIGZyb20gQW5kcmV3IEtpcm1zZSwgR2FtZSBQcm9ncmFtbWluZyBHZW1zIDQsIENoYXB0ZXIgMS4xMFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNNT09USERBTVAoX2N1cnJlbnQ6IFZlY3RvcjMsIF90YXJnZXQ6IFZlY3RvcjMsIF92ZWxvY2l0eTogVmVjdG9yMywgX3Ntb290aFRpbWU6IG51bWJlciwgX3RpbWVGcmFtZTogbnVtYmVyLCBfbWF4U3BlZWQ6IG51bWJlciA9IEluZmluaXR5LCBfb3V0OiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMykpOiBWZWN0b3IzIHtcclxuICAgICAgY29uc3Qgb21lZ2E6IG51bWJlciA9IDIgLyBfc21vb3RoVGltZTtcclxuICAgICAgY29uc3QgeDogbnVtYmVyID0gb21lZ2EgKiBfdGltZUZyYW1lO1xyXG4gICAgICBjb25zdCBleHA6IG51bWJlciA9IDEgLyAoMSArIHggKyAwLjQ4ICogeCAqIHggKyAwLjIzNSAqIHggKiB4ICogeCk7IC8vIGFwcHJveGltYXRpb24gb2YgZSBeIC1vbWVnYSAqIHRpbWVGcmFtZVxyXG5cclxuICAgICAgbGV0IGNoYW5nZVg6IG51bWJlciA9IF9jdXJyZW50LnggLSBfdGFyZ2V0Lng7XHJcbiAgICAgIGxldCBjaGFuZ2VZOiBudW1iZXIgPSBfY3VycmVudC55IC0gX3RhcmdldC55O1xyXG4gICAgICBsZXQgY2hhbmdlWjogbnVtYmVyID0gX2N1cnJlbnQueiAtIF90YXJnZXQuejtcclxuXHJcbiAgICAgIGNvbnN0IG1heENoYW5nZTogbnVtYmVyID0gX21heFNwZWVkICogX3Ntb290aFRpbWU7XHJcbiAgICAgIGNvbnN0IG1hZ25pdHVkZVNxdWFyZWQ6IG51bWJlciA9IGNoYW5nZVggKiBjaGFuZ2VYICsgY2hhbmdlWSAqIGNoYW5nZVkgKyBjaGFuZ2VaICogY2hhbmdlWjtcclxuXHJcbiAgICAgIGxldCB0YXJnZXRYOiBudW1iZXI7XHJcbiAgICAgIGxldCB0YXJnZXRZOiBudW1iZXI7XHJcbiAgICAgIGxldCB0YXJnZXRaOiBudW1iZXI7XHJcbiAgICAgIGlmIChtYWduaXR1ZGVTcXVhcmVkID4gbWF4Q2hhbmdlICogbWF4Q2hhbmdlKSB7XHJcbiAgICAgICAgbGV0IHNjYWxhcjogbnVtYmVyID0gbWF4Q2hhbmdlIC8gTWF0aC5zcXJ0KG1hZ25pdHVkZVNxdWFyZWQpOyAvLyBub3JtYWxpemUgdG8gbWF4Q2hhbmdlXHJcbiAgICAgICAgY2hhbmdlWCAqPSBzY2FsYXI7XHJcbiAgICAgICAgY2hhbmdlWSAqPSBzY2FsYXI7XHJcbiAgICAgICAgY2hhbmdlWiAqPSBzY2FsYXI7XHJcblxyXG4gICAgICAgIC8vIGNoYW5nZSA9IGN1cnJlbnQgLSB0YXJnZXQgID09ICB0YXJnZXQgPSBjdXJyZW50IC0gY2hhbmdlXHJcbiAgICAgICAgdGFyZ2V0WCA9IF9jdXJyZW50LnggLSBjaGFuZ2VYO1xyXG4gICAgICAgIHRhcmdldFkgPSBfY3VycmVudC55IC0gY2hhbmdlWTtcclxuICAgICAgICB0YXJnZXRaID0gX2N1cnJlbnQueiAtIGNoYW5nZVo7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGFyZ2V0WCA9IF90YXJnZXQueDtcclxuICAgICAgICB0YXJnZXRZID0gX3RhcmdldC55O1xyXG4gICAgICAgIHRhcmdldFogPSBfdGFyZ2V0Lno7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCB0ZW1wWDogbnVtYmVyID0gKF92ZWxvY2l0eS54ICsgb21lZ2EgKiBjaGFuZ2VYKSAqIF90aW1lRnJhbWU7XHJcbiAgICAgIGxldCB0ZW1wWTogbnVtYmVyID0gKF92ZWxvY2l0eS55ICsgb21lZ2EgKiBjaGFuZ2VZKSAqIF90aW1lRnJhbWU7XHJcbiAgICAgIGxldCB0ZW1wWjogbnVtYmVyID0gKF92ZWxvY2l0eS56ICsgb21lZ2EgKiBjaGFuZ2VaKSAqIF90aW1lRnJhbWU7XHJcblxyXG4gICAgICBfdmVsb2NpdHkueCA9IChfdmVsb2NpdHkueCAtIG9tZWdhICogdGVtcFgpICogZXhwO1xyXG4gICAgICBfdmVsb2NpdHkueSA9IChfdmVsb2NpdHkueSAtIG9tZWdhICogdGVtcFkpICogZXhwO1xyXG4gICAgICBfdmVsb2NpdHkueiA9IChfdmVsb2NpdHkueiAtIG9tZWdhICogdGVtcFopICogZXhwO1xyXG5cclxuICAgICAgX291dC54ID0gdGFyZ2V0WCArIChjaGFuZ2VYICsgdGVtcFgpICogZXhwO1xyXG4gICAgICBfb3V0LnkgPSB0YXJnZXRZICsgKGNoYW5nZVkgKyB0ZW1wWSkgKiBleHA7XHJcbiAgICAgIF9vdXQueiA9IHRhcmdldFogKyAoY2hhbmdlWiArIHRlbXBaKSAqIGV4cDtcclxuXHJcbiAgICAgIHJldHVybiBfb3V0O1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIEFjY2Vzc29yc1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1hZ25pdHVkZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzcXVhcmUgb2YgdGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yIHdpdGhvdXQgY2FsY3VsYXRpbmcgYSBzcXVhcmUgcm9vdC4gRmFzdGVyIGZvciBzaW1wbGUgcHJveGltaXR5IGV2YWx1YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWFnbml0dWRlU3F1YXJlZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogLSBnZXQ6IFJldHVybnMgYSBnZW9ncmFwaGljIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yICBcclxuICAgICAqIC0gc2V0OiBBZGp1c3RzIHRoZSBjYXJ0ZXNpYW4gdmFsdWVzIG9mIHRoaXMgdmVjdG9yIHRvIHJlcHJlc2VudCB0aGUgZ2l2ZW4gYXMgZ2VvZ3JhcGhpYyBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGdlbygpOiBHZW8zIHtcclxuICAgICAgbGV0IGdlbzogR2VvMyA9IFJlY3ljbGVyLmdldChHZW8zKTtcclxuICAgICAgZ2VvLm1hZ25pdHVkZSA9IHRoaXMubWFnbml0dWRlO1xyXG5cclxuICAgICAgaWYgKGdlby5tYWduaXR1ZGUgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIGdlbztcclxuXHJcbiAgICAgIGdlby5sb25naXR1ZGUgPSAxODAgKiBNYXRoLmF0YW4yKHRoaXMueCAvIGdlby5tYWduaXR1ZGUsIHRoaXMueiAvIGdlby5tYWduaXR1ZGUpIC8gTWF0aC5QSTtcclxuICAgICAgZ2VvLmxhdGl0dWRlID0gMTgwICogTWF0aC5hc2luKHRoaXMueSAvIGdlby5tYWduaXR1ZGUpIC8gTWF0aC5QSTtcclxuICAgICAgcmV0dXJuIGdlbztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IGdlbyhfZ2VvOiBHZW8zKSB7XHJcbiAgICAgIHRoaXMuc2V0KDAsIDAsIF9nZW8ubWFnbml0dWRlKTtcclxuICAgICAgY29uc3QgbXR4Um90YXRpb25YOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT05fWChfZ2VvLmxhdGl0dWRlKTtcclxuICAgICAgY29uc3QgbXR4Um90YXRpb25ZOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT05fWShfZ2VvLmxvbmdpdHVkZSk7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtKG10eFJvdGF0aW9uWCk7XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtKG10eFJvdGF0aW9uWSk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJvdGF0aW9uWCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFJvdGF0aW9uWSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY2xvbmUoKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBSZWN5Y2xlci5yZXVzZShWZWN0b3IzKS5jb3B5KHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgdGhlIGNvbXBvbmVudHMgb2YgdGhlIGdpdmVuIHZlY3RvciBpbnRvIHRoaXMgdmVjdG9yLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb3B5KF9vcmlnaW5hbDogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICB0aGlzLnggPSBfb3JpZ2luYWwueDtcclxuICAgICAgdGhpcy55ID0gX29yaWdpbmFsLnk7XHJcbiAgICAgIHRoaXMueiA9IF9vcmlnaW5hbC56O1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IgYW5kIHJldHVybnMgaXQuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldChfeDogbnVtYmVyID0gMCwgX3k6IG51bWJlciA9IDAsIF96OiBudW1iZXIgPSAwKTogVmVjdG9yMyB7XHJcbiAgICAgIHRoaXMueCA9IF94O1xyXG4gICAgICB0aGlzLnkgPSBfeTtcclxuICAgICAgdGhpcy56ID0gX3o7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldCgwLCAwLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHZlY3RvciBhcmUgdG8gYmUgY29uc2lkZXJlZCBpZGVudGljYWwgd2l0aGluIHRoZSBnaXZlbiB0b2xlcmFuY2VcclxuICAgICAqIFRPRE86IGV4YW1pbmUsIGlmIHRvbGVyYW5jZSBhcyBjcml0ZXJpdW0gZm9yIHRoZSBkaWZmZXJlbmNlIGlzIGFwcHJvcHJpYXRlIHdpdGggdmVyeSBsYXJnZSBjb29yZGluYXRlIHZhbHVlcyBvciBpZiBfdG9sZXJhbmNlIHNob3VsZCBiZSBtdWx0aXBsaWVkIGJ5IGNvb3JkaW5hdGUgdmFsdWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGVxdWFscyhfY29tcGFyZTogVmVjdG9yMywgX3RvbGVyYW5jZTogbnVtYmVyID0gTnVtYmVyLkVQU0lMT04pOiBib29sZWFuIHtcclxuICAgICAgaWYgKE1hdGguYWJzKHRoaXMueCAtIF9jb21wYXJlLngpID4gX3RvbGVyYW5jZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoTWF0aC5hYnModGhpcy55IC0gX2NvbXBhcmUueSkgPiBfdG9sZXJhbmNlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzLnogLSBfY29tcGFyZS56KSA+IF90b2xlcmFuY2UpIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGRlc2NyaWJlZCBieSB0aGlzIGlzIHdpdGhpbiBhIGN1YmUgd2l0aCB0aGUgb3Bwb3NpdGUgY29ybmVycyAxIGFuZCAyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNJbnNpZGVDdWJlKF9jb3JuZXIxOiBWZWN0b3IzLCBfY29ybmVyMjogVmVjdG9yMyk6IGJvb2xlYW4ge1xyXG4gICAgICBjb25zdCBkaWFnb25hbDogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfY29ybmVyMiwgX2Nvcm5lcjEpO1xyXG4gICAgICBjb25zdCByZWxhdGl2ZTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh0aGlzLCBfY29ybmVyMSk7XHJcbiAgICAgIGNvbnN0IHJhdGlvOiBWZWN0b3IzID0gVmVjdG9yMy5SQVRJTyhyZWxhdGl2ZSwgZGlhZ29uYWwpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShkaWFnb25hbCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJlbGF0aXZlKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUocmF0aW8pO1xyXG4gICAgICBpZiAocmF0aW8ueCA+IDEgfHwgcmF0aW8ueCA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAocmF0aW8ueSA+IDEgfHwgcmF0aW8ueSA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAocmF0aW8ueiA+IDEgfHwgcmF0aW8ueiA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gZGVzY3JpYmVkIGJ5IHRoaXMgaXMgd2l0aGluIGEgc3BoZXJlIHdpdGggdGhlIGdpdmVuIGNlbnRlciBhbmQgcmFkaXVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNJbnNpZGVTcGhlcmUoX2NlbnRlcjogVmVjdG9yMywgX3JhZGl1czogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgIGNvbnN0IGRpZmZlcmVuY2U6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodGhpcywgX2NlbnRlcik7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKGRpZmZlcmVuY2UpO1xyXG4gICAgICByZXR1cm4gZGlmZmVyZW5jZS5tYWduaXR1ZGVTcXVhcmVkIDwgKF9yYWRpdXMgKiBfcmFkaXVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGJld3R3ZWVuIHRoaXMgdmVjdG9yIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RGlzdGFuY2UoX3RvOiBWZWN0b3IzKTogbnVtYmVyIHtcclxuICAgICAgbGV0IGRpZmZlcmVuY2U6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodGhpcywgX3RvKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoZGlmZmVyZW5jZSk7XHJcbiAgICAgIHJldHVybiBkaWZmZXJlbmNlLm1hZ25pdHVkZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHZlY3RvciB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkKF9hZGRlbmQ6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgdGhpcy54ICs9IF9hZGRlbmQueDtcclxuICAgICAgdGhpcy55ICs9IF9hZGRlbmQueTtcclxuICAgICAgdGhpcy56ICs9IF9hZGRlbmQuejtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJ0cmFjdHMgdGhlIGdpdmVuIHZlY3RvciBmcm9tIHRoaXMgdmVjdG9yLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdWJ0cmFjdChfc3VidHJhaGVuZDogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICB0aGlzLnggLT0gX3N1YnRyYWhlbmQueDtcclxuICAgICAgdGhpcy55IC09IF9zdWJ0cmFoZW5kLnk7XHJcbiAgICAgIHRoaXMueiAtPSBfc3VidHJhaGVuZC56O1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlcyB0aGlzIHZlY3RvciBieSB0aGUgZ2l2ZW4gc2NhbGFyLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZShfc2NhbGFyOiBudW1iZXIpOiBWZWN0b3IzIHtcclxuICAgICAgdGhpcy54ICo9IF9zY2FsYXI7XHJcbiAgICAgIHRoaXMueSAqPSBfc2NhbGFyO1xyXG4gICAgICB0aGlzLnogKj0gX3NjYWxhcjtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOZWdhdGVzIHRoaXMgdmVjdG9yIGJ5IGZsaXBwaW5nIHRoZSBzaWducyBvZiBpdHMgY29tcG9uZW50c1xyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZWdhdGUoKTogVmVjdG9yMyB7XHJcbiAgICAgIHRoaXMueCA9IC10aGlzLng7XHJcbiAgICAgIHRoaXMueSA9IC10aGlzLnk7XHJcbiAgICAgIHRoaXMueiA9IC10aGlzLno7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9ybWFsaXplcyB0aGlzIHRvIHRoZSBnaXZlbiBsZW5ndGgsIDEgYnkgZGVmYXVsdFxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBub3JtYWxpemUoX2xlbmd0aDogbnVtYmVyID0gMSk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgbWFnbml0dWRlU3F1YXJlZDogbnVtYmVyID0gdGhpcy5tYWduaXR1ZGVTcXVhcmVkO1xyXG4gICAgICBpZiAobWFnbml0dWRlU3F1YXJlZCA9PSAwKVxyXG4gICAgICAgIHRocm93IChuZXcgUmFuZ2VFcnJvcihcIkltcG9zc2libGUgbm9ybWFsaXphdGlvblwiKSk7XHJcblxyXG4gICAgICB0aGlzLnNjYWxlKF9sZW5ndGggLyBNYXRoLnNxcnQobWFnbml0dWRlU3F1YXJlZCkpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmxlY3RzIHRoaXMgdmVjdG9yIGF0IGEgZ2l2ZW4gbm9ybWFsLiBTZWUge0BsaW5rIFZlY3RvcjMuUkVGTEVDVElPTn0uXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlZmxlY3QoX25vcm1hbDogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gVmVjdG9yMy5SRUZMRUNUSU9OKHRoaXMsIF9ub3JtYWwsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvamVjdHMgdGhpcyB2ZWN0b3Igb250byB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwcm9qZWN0KF9vbjogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgc2NhbGFyOiBudW1iZXIgPSBWZWN0b3IzLkRPVCh0aGlzLCBfb24pIC8gX29uLm1hZ25pdHVkZVNxdWFyZWQ7XHJcbiAgICAgIHRoaXMueCA9IF9vbi54ICogc2NhbGFyO1xyXG4gICAgICB0aGlzLnkgPSBfb24ueSAqIHNjYWxhcjtcclxuICAgICAgdGhpcy56ID0gX29uLnogKiBzY2FsYXI7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtcyB0aGlzIHZlY3RvciBieSB0aGUgZ2l2ZW4gbWF0cml4IG9yIHJvdGF0aW9uIHF1YXRlcm5pb24uIFxyXG4gICAgICogSW5jbHVkaW5nIG9yIGV4bHVkaW5nIHRoZSB0cmFuc2xhdGlvbiBpZiBhIG1hdHJpeCBpcyBwYXNzZWQuXHJcbiAgICAgKiBJbmNsdWRpbmcgaXMgdGhlIGRlZmF1bHQsIGV4Y2x1ZGluZyB3aWxsIG9ubHkgcm90YXRlIGFuZCBzY2FsZSB0aGlzIHZlY3Rvci5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNmb3JtKF90cmFuc2Zvcm06IE1hdHJpeDR4NCB8IFF1YXRlcm5pb24sIF9pbmNsdWRlVHJhbnNsYXRpb246IGJvb2xlYW4gPSB0cnVlKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKHRoaXMsIF90cmFuc2Zvcm0sIF9pbmNsdWRlVHJhbnNsYXRpb24sIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2h1ZmZsZXMgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNodWZmbGUoKTogVmVjdG9yMyB7XHJcbiAgICAgIC8vIER1cnN0ZW5mZWxkIHNodWZmbGVcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gVmVjdG9yMy5rZXlzLmxlbmd0aCAtIDEsIGo6IG51bWJlcjsgaSA+IDA7IGktLSkge1xyXG4gICAgICAgIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTsgLy8gUmFuZG9tLmRlZmF1bHQuZ2V0UmFuZ2VGbG9vcmVkKDAsIGkgKyAxKTtcclxuICAgICAgICBjb25zdCB0ZW1wOiBudW1iZXIgPSB0aGlzW1ZlY3RvcjMua2V5c1tpXV07XHJcbiAgICAgICAgdGhpc1tWZWN0b3IzLmtleXNbaV1dID0gdGhpc1tWZWN0b3IzLmtleXNbal1dO1xyXG4gICAgICAgIHRoaXNbVmVjdG9yMy5rZXlzW2pdXSA9IHRlbXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yIGVhY2ggZGltZW5zaW9uLCBtb3ZlcyB0aGUgY29tcG9uZW50IHRvIHRoZSBtaW5pbXVtIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiB2ZWN0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG1pbihfY29tcGFyZTogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICB0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIF9jb21wYXJlLngpO1xyXG4gICAgICB0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIF9jb21wYXJlLnkpO1xyXG4gICAgICB0aGlzLnogPSBNYXRoLm1pbih0aGlzLnosIF9jb21wYXJlLnopO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvciBlYWNoIGRpbWVuc2lvbiwgbW92ZXMgdGhlIGNvbXBvbmVudCB0byB0aGUgbWF4aW11bSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtYXgoX2NvbXBhcmU6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgdGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCBfY29tcGFyZS54KTtcclxuICAgICAgdGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCBfY29tcGFyZS55KTtcclxuICAgICAgdGhpcy56ID0gTWF0aC5tYXgodGhpcy56LCBfY29tcGFyZS56KTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxscyBhIGRlZmluZWQgY2FsbGJhY2sgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvciwgYW5kIHJldHVybnMgYSBuZXcgdmVjdG9yIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdHMuIFNpbWlsYXIgdG8ge0BsaW5rIEFycmF5Lm1hcH0uXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG1hcChfZnVuY3Rpb246IChfdmFsdWU6IG51bWJlciwgX2luZGV4OiBudW1iZXIsIF9jb21wb25lbnQ6IFwieFwiIHwgXCJ5XCIgfCBcInpcIiwgX3ZlY3RvcjogVmVjdG9yMykgPT4gbnVtYmVyLCBfb3V0OiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMykpOiBWZWN0b3IzIHtcclxuICAgICAgX291dC54ID0gX2Z1bmN0aW9uKHRoaXMueCwgMCwgXCJ4XCIsIHRoaXMpO1xyXG4gICAgICBfb3V0LnkgPSBfZnVuY3Rpb24odGhpcy55LCAxLCBcInlcIiwgdGhpcyk7XHJcbiAgICAgIF9vdXQueiA9IF9mdW5jdGlvbih0aGlzLnosIDIsIFwielwiLCB0aGlzKTtcclxuICAgICAgcmV0dXJuIF9vdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxscyBhIGRlZmluZWQgY2FsbGJhY2sgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvciBhbmQgYXNzaWducyB0aGUgcmVzdWx0IHRvIHRoZSBjb21wb25lbnQuIFNpbWlsYXIgdG8ge0BsaW5rIFZlY3RvcjMubWFwfSBidXQgbXV0YXRlcyB0aGlzIHZlY3RvciBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9uZS5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXBwbHkoX2Z1bmN0aW9uOiAoX3ZhbHVlOiBudW1iZXIsIF9pbmRleDogbnVtYmVyLCBfY29tcG9uZW50OiBcInhcIiB8IFwieVwiIHwgXCJ6XCIsIF92ZWN0b3I6IFZlY3RvcjMpID0+IG51bWJlcik6IFZlY3RvcjMge1xyXG4gICAgICB0aGlzLnggPSBfZnVuY3Rpb24odGhpcy54LCAwLCBcInhcIiwgdGhpcyk7XHJcbiAgICAgIHRoaXMueSA9IF9mdW5jdGlvbih0aGlzLnksIDEsIFwieVwiLCB0aGlzKTtcclxuICAgICAgdGhpcy56ID0gX2Z1bmN0aW9uKHRoaXMueiwgMiwgXCJ6XCIsIHRoaXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQoKTogRmxvYXQzMkFycmF5IHsgLy8gVE9ETzogcmVuYW1lIHRvIHRvQXJyYXksIGFsbG93IHBhc3Npbmcgb2YgYW4gYXJyYXkgaW50byB0aGlzIG1ldGhvZCB0byBhdm9pZCBhbGxvY2F0aW9uXHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFt0aGlzLngsIHRoaXMueSwgdGhpcy56XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3B5cyB0aGUgZWxlbWVudHMgb2YgdGhpcyB2ZWN0b3IgaW50byB0aGUgZ2l2ZW4gYXJyYXkgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIG9mZnNldC5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoZSBnaXZlbiBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvQXJyYXk8VCBleHRlbmRzIHsgW246IG51bWJlcl06IG51bWJlciB9Pihfb3V0OiBULCBfb2Zmc2V0OiBudW1iZXIgPSAwKTogVCB7XHJcbiAgICAgIF9vdXRbX29mZnNldF0gPSB0aGlzLng7XHJcbiAgICAgIF9vdXRbX29mZnNldCArIDFdID0gdGhpcy55O1xyXG4gICAgICBfb3V0W19vZmZzZXQgKyAyXSA9IHRoaXMuejtcclxuXHJcbiAgICAgIHJldHVybiBfb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJvcHMgdGhlIHotY29tcG9uZW50IGFuZCByZXR1cm5zIGEgVmVjdG9yMiBjb25zaXN0aW5nIG9mIHRoZSB4LSBhbmQgeS1jb21wb25lbnRzLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1ZlY3RvcjIoX291dDogVmVjdG9yMiA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjIpKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiBfb3V0LnNldCh0aGlzLngsIHRoaXMueSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgbGV0IHJlc3VsdDogc3RyaW5nID0gYCgke3RoaXMueC50b1ByZWNpc2lvbig1KX0sICR7dGhpcy55LnRvUHJlY2lzaW9uKDUpfSwgJHt0aGlzLnoudG9QcmVjaXNpb24oNSl9KWA7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZmVyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgICAvLyBzZXJpYWxpemF0aW9uLnRvSlNPTiA9ICgpID0+IHsgcmV0dXJuIGB7IFwiclwiOiAke3RoaXMucn0sIFwiZ1wiOiAke3RoaXMuZ30sIFwiYlwiOiAke3RoaXMuYn0sIFwiYVwiOiAke3RoaXMuYX19YDsgfTtcclxuICAgICAgc2VyaWFsaXphdGlvbi50b0pTT04gPSAoKSA9PiB7IHJldHVybiBgWyR7dGhpcy54fSwgJHt0aGlzLnl9LCAke3RoaXMuen1dYDsgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxWZWN0b3IzPiB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9zZXJpYWxpemF0aW9uKSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgW3RoaXMueCwgdGhpcy55LCB0aGlzLnpdID0gSlNPTi5wYXJzZSg8c3RyaW5nPjx1bmtub3duPl9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgfSBlbHNlXHJcbiAgICAgICAgdGhpcy5tdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb3ZlcnJpZGUgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGlmIChfbXV0YXRvci54ICE9IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLnggPSBfbXV0YXRvci54O1xyXG4gICAgICBpZiAoX211dGF0b3IueSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy55ID0gX211dGF0b3IueTtcclxuICAgICAgaWYgKF9tdXRhdG9yLnogIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMueiA9IF9tdXRhdG9yLno7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0geyB4OiB0aGlzLngsIHk6IHRoaXMueSwgejogdGhpcy56IH07XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7LyoqICovIH1cclxuICAgIC8vI2VuZHJlZ2lvbiBUcmFuc2ZlclxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIFN0b3JlcyBhbmQgbWFuaXB1bGF0ZXMgYSBmb3VyZGltZW5zaW9uYWwgdmVjdG9yIGNvbXByaXNlZCBvZiB0aGUgY29tcG9uZW50cyB4LCB5LCB6IGFuZCB3LlxyXG4gICAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBWZWN0b3I0IGV4dGVuZHMgTXV0YWJsZSBpbXBsZW1lbnRzIFNlcmlhbGl6YWJsZSwgUmVjeWNhYmxlIHtcclxuICAgIHB1YmxpYyB4OiBudW1iZXI7XHJcbiAgICBwdWJsaWMgeTogbnVtYmVyO1xyXG4gICAgcHVibGljIHo6IG51bWJlcjtcclxuICAgIHB1YmxpYyB3OiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF94OiBudW1iZXIgPSAwLCBfeTogbnVtYmVyID0gMCwgX3o6IG51bWJlciA9IDAsIF93OiBudW1iZXIgPSAwKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuc2V0KF94LCBfeSwgX3osIF93KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSB2ZWN0b3Igd2hpY2ggaXMgYSBjb3B5IG9mIHRoZSBnaXZlbiB2ZWN0b3Igc2NhbGVkIHRvIHRoZSBnaXZlbiBsZW5ndGguXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBOT1JNQUxJWkFUSU9OKF92ZWN0b3I6IFZlY3RvcjQsIF9sZW5ndGg6IG51bWJlciA9IDEsIF9vdXQ6IFZlY3RvcjQgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3I0KSk6IFZlY3RvcjQge1xyXG4gICAgICByZXR1cm4gX291dC5jb3B5KF92ZWN0b3IpLm5vcm1hbGl6ZShfbGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24gb2YgdHdvIHZlY3RvcnMuXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTVU0oX2E6IFZlY3RvcjQsIF9iOiBWZWN0b3I0LCBfb3V0OiBWZWN0b3I0ID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yNCkpOiBWZWN0b3I0IHtcclxuICAgICAgcmV0dXJuIF9vdXQuc2V0KF9hLnggKyBfYi54LCBfYS55ICsgX2IueSwgX2EueiArIF9iLnosIF9hLncgKyBfYi53KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24gb2YgdHdvIHZlY3RvcnMuXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBESUZGRVJFTkNFKF9taW51ZW5kOiBWZWN0b3I0LCBfc3VidHJhaGVuZDogVmVjdG9yNCwgX291dDogVmVjdG9yNCA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjQpKTogVmVjdG9yNCB7XHJcbiAgICAgIHJldHVybiBfb3V0LnNldChfbWludWVuZC54IC0gX3N1YnRyYWhlbmQueCwgX21pbnVlbmQueSAtIF9zdWJ0cmFoZW5kLnksIF9taW51ZW5kLnogLSBfc3VidHJhaGVuZC56LCBfbWludWVuZC53IC0gX3N1YnRyYWhlbmQudyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIHNjYWxpbmcgZmFjdG9yLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU0NBTEUoX3ZlY3RvcjogVmVjdG9yNCwgX3NjYWxpbmc6IG51bWJlciwgX291dDogVmVjdG9yNCA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjQpKTogVmVjdG9yNCB7XHJcbiAgICAgIHJldHVybiBfb3V0LnNldChfdmVjdG9yLnggKiBfc2NhbGluZywgX3ZlY3Rvci55ICogX3NjYWxpbmcsIF92ZWN0b3IueiAqIF9zY2FsaW5nLCBfdmVjdG9yLncgKiBfc2NhbGluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZlY3RvciBzY2FsZWQgYnkgdGhlIGdpdmVuIHNjYWxpbmcgZmFjdG9yLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgTkVHQVRJT04oX3ZlY3RvcjogVmVjdG9yNCwgX291dDogVmVjdG9yNCA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjQpKTogVmVjdG9yNCB7XHJcbiAgICAgIHJldHVybiBfb3V0LnNldCgtX3ZlY3Rvci54LCAtX3ZlY3Rvci55LCAtX3ZlY3Rvci56LCAtX3ZlY3Rvci53KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBkb3Rwcm9kdWN0IG9mIDIgdmVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBET1QoX2E6IFZlY3RvcjQsIF9iOiBWZWN0b3I0KTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIF9hLnggKiBfYi54ICsgX2EueSAqIF9iLnkgKyBfYS56ICogX2IueiArIF9hLncgKiBfYi53O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1hZ25pdHVkZSAobGVuZ3RoKSBvZiB0aGUgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1hZ25pdHVkZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3F1YXJlZCBtYWduaXR1ZGUgKGxlbmd0aCkgb2YgdGhlIHZlY3Rvci4gRmFzdGVyIGZvciBzaW1wbGUgcHJveGltaXR5IGV2YWx1YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWFnbml0dWRlU3F1YXJlZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gVmVjdG9yNC5ET1QodGhpcywgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY2xvbmUoKTogVmVjdG9yNCB7XHJcbiAgICAgIHJldHVybiBSZWN5Y2xlci5yZXVzZShWZWN0b3I0KS5jb3B5KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29waWVzIHRoZSBjb21wb25lbnRzIG9mIHRoZSBnaXZlbiB2ZWN0b3IgaW50byB0aGlzIHZlY3Rvci5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29weShfb3JpZ2luYWw6IFZlY3RvcjQpOiBWZWN0b3I0IHtcclxuICAgICAgdGhpcy54ID0gX29yaWdpbmFsLng7XHJcbiAgICAgIHRoaXMueSA9IF9vcmlnaW5hbC55O1xyXG4gICAgICB0aGlzLnogPSBfb3JpZ2luYWwuejtcclxuICAgICAgdGhpcy53ID0gX29yaWdpbmFsLnc7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY29tcG9uZW50cyBvZiB0aGlzIHZlY3RvciBhbmQgcmV0dXJucyBpdC5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0KF94OiBudW1iZXIsIF95OiBudW1iZXIsIF96OiBudW1iZXIsIF93OiBudW1iZXIpOiBWZWN0b3I0IHtcclxuICAgICAgdGhpcy54ID0gX3g7XHJcbiAgICAgIHRoaXMueSA9IF95O1xyXG4gICAgICB0aGlzLnogPSBfejtcclxuICAgICAgdGhpcy53ID0gX3c7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgY29tcG9uZW50cyBvZiB0aGlzIHZlY3Rvci4gLy8gVE9ETzogcmVtb3ZlIHRoaXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCgpOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XHJcbiAgICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53XTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVjeWNsZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2ZWN0b3IgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIHZlY3RvciB3aXRoaW4gdGhlIGdpdmVuIHRvbGVyYW5jZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGVxdWFscyhfY29tcGFyZTogVmVjdG9yNCwgX3RvbGVyYW5jZTogbnVtYmVyID0gTnVtYmVyLkVQU0lMT04pOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueCAtIF9jb21wYXJlLngpIDw9IF90b2xlcmFuY2UgJiZcclxuICAgICAgICBNYXRoLmFicyh0aGlzLnkgLSBfY29tcGFyZS55KSA8PSBfdG9sZXJhbmNlICYmXHJcbiAgICAgICAgTWF0aC5hYnModGhpcy56IC0gX2NvbXBhcmUueikgPD0gX3RvbGVyYW5jZSAmJlxyXG4gICAgICAgIE1hdGguYWJzKHRoaXMudyAtIF9jb21wYXJlLncpIDw9IF90b2xlcmFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZChfYWRkZW5kOiBWZWN0b3I0KTogVmVjdG9yNCB7XHJcbiAgICAgIHRoaXMueCArPSBfYWRkZW5kLng7XHJcbiAgICAgIHRoaXMueSArPSBfYWRkZW5kLnk7XHJcbiAgICAgIHRoaXMueiArPSBfYWRkZW5kLno7XHJcbiAgICAgIHRoaXMudyArPSBfYWRkZW5kLnc7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIHRoZSBnaXZlbiB2ZWN0b3IgZnJvbSB0aGlzIHZlY3Rvci5cclxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3VidHJhY3QoX3N1YnRyYWhlbmQ6IFZlY3RvcjQpOiBWZWN0b3I0IHtcclxuICAgICAgdGhpcy54IC09IF9zdWJ0cmFoZW5kLng7XHJcbiAgICAgIHRoaXMueSAtPSBfc3VidHJhaGVuZC55O1xyXG4gICAgICB0aGlzLnogLT0gX3N1YnRyYWhlbmQuejtcclxuICAgICAgdGhpcy53IC09IF9zdWJ0cmFoZW5kLnc7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIHRoaXMgdmVjdG9yIGJ5IHRoZSBnaXZlbiBzY2FsYXIuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjYWxlKF9zY2FsYXI6IG51bWJlcik6IFZlY3RvcjQge1xyXG4gICAgICB0aGlzLnggKj0gX3NjYWxhcjtcclxuICAgICAgdGhpcy55ICo9IF9zY2FsYXI7XHJcbiAgICAgIHRoaXMueiAqPSBfc2NhbGFyO1xyXG4gICAgICB0aGlzLncgKj0gX3NjYWxhcjtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOZWdhdGVzIHRoaXMgdmVjdG9yIGJ5IGZsaXBwaW5nIHRoZSBzaWducyBvZiBpdHMgY29tcG9uZW50c1xyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZWdhdGUoKTogVmVjdG9yNCB7XHJcbiAgICAgIHRoaXMueCA9IC10aGlzLng7XHJcbiAgICAgIHRoaXMueSA9IC10aGlzLnk7XHJcbiAgICAgIHRoaXMueiA9IC10aGlzLno7XHJcbiAgICAgIHRoaXMudyA9IC10aGlzLnc7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9ybWFsaXplcyB0aGlzIHZlY3RvciB0byB0aGUgZ2l2ZW4gbGVuZ3RoLCAxIGJ5IGRlZmF1bHQuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vcm1hbGl6ZShfbGVuZ3RoOiBudW1iZXIgPSAxKTogVmVjdG9yNCB7XHJcbiAgICAgIGxldCBtYWduaXR1ZGVTcXVhcmVkOiBudW1iZXIgPSB0aGlzLm1hZ25pdHVkZVNxdWFyZWQ7XHJcbiAgICAgIGlmIChtYWduaXR1ZGVTcXVhcmVkID09IDApXHJcbiAgICAgICAgdGhyb3cgKG5ldyBSYW5nZUVycm9yKFwiSW1wb3NzaWJsZSBub3JtYWxpemF0aW9uXCIpKTtcclxuXHJcbiAgICAgIHRoaXMuc2NhbGUoX2xlbmd0aCAvIE1hdGguc3FydChtYWduaXR1ZGVTcXVhcmVkKSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yIGVhY2ggZGltZW5zaW9uLCBtb3ZlcyB0aGUgY29tcG9uZW50IHRvIHRoZSBtaW5pbXVtIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiB2ZWN0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG1pbihfY29tcGFyZTogVmVjdG9yNCk6IFZlY3RvcjQge1xyXG4gICAgICB0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIF9jb21wYXJlLngpO1xyXG4gICAgICB0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIF9jb21wYXJlLnkpO1xyXG4gICAgICB0aGlzLnogPSBNYXRoLm1pbih0aGlzLnosIF9jb21wYXJlLnopO1xyXG4gICAgICB0aGlzLncgPSBNYXRoLm1pbih0aGlzLncsIF9jb21wYXJlLncpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvciBlYWNoIGRpbWVuc2lvbiwgbW92ZXMgdGhlIGNvbXBvbmVudCB0byB0aGUgbWF4aW11bSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yLlxyXG4gICAgICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhpcyB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtYXgoX2NvbXBhcmU6IFZlY3RvcjQpOiBWZWN0b3I0IHtcclxuICAgICAgdGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCBfY29tcGFyZS54KTtcclxuICAgICAgdGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCBfY29tcGFyZS55KTtcclxuICAgICAgdGhpcy56ID0gTWF0aC5tYXgodGhpcy56LCBfY29tcGFyZS56KTtcclxuICAgICAgdGhpcy53ID0gTWF0aC5tYXgodGhpcy53LCBfY29tcGFyZS53KTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxscyBhIGRlZmluZWQgY2FsbGJhY2sgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvciwgYW5kIHJldHVybnMgYSBuZXcgdmVjdG9yIHRoYXQgY29udGFpbnMgdGhlIHJlc3VsdHMuIFNpbWlsYXIgdG8ge0BsaW5rIEFycmF5Lm1hcH0uXHJcbiAgICAgKiBAcGFyYW0gX291dCBPcHRpb25hbCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG1hcChfZnVuY3Rpb246IChfdmFsdWU6IG51bWJlciwgX2luZGV4OiBudW1iZXIsIF9jb21wb25lbnQ6IFwieFwiIHwgXCJ5XCIgfCBcInpcIiB8IFwid1wiLCBfdmVjdG9yOiBWZWN0b3I0KSA9PiBudW1iZXIsIF9vdXQ6IFZlY3RvcjQgPSBSZWN5Y2xlci5yZXVzZShWZWN0b3I0KSk6IFZlY3RvcjQge1xyXG4gICAgICBfb3V0LnggPSBfZnVuY3Rpb24odGhpcy54LCAwLCBcInhcIiwgdGhpcyk7XHJcbiAgICAgIF9vdXQueSA9IF9mdW5jdGlvbih0aGlzLnksIDEsIFwieVwiLCB0aGlzKTtcclxuICAgICAgX291dC56ID0gX2Z1bmN0aW9uKHRoaXMueiwgMiwgXCJ6XCIsIHRoaXMpO1xyXG4gICAgICBfb3V0LncgPSBfZnVuY3Rpb24odGhpcy53LCAzLCBcIndcIiwgdGhpcyk7XHJcbiAgICAgIHJldHVybiBfb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbHMgYSBkZWZpbmVkIGNhbGxiYWNrIGZ1bmN0aW9uIG9uIGVhY2ggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IgYW5kIGFzc2lnbnMgdGhlIHJlc3VsdCB0byB0aGUgY29tcG9uZW50LiBTaW1pbGFyIHRvIHtAbGluayBWZWN0b3I0Lm1hcH0gYnV0IG11dGF0ZXMgdGhpcyB2ZWN0b3IgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvbmUuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5KF9mdW5jdGlvbjogKF92YWx1ZTogbnVtYmVyLCBfaW5kZXg6IG51bWJlciwgX2NvbXBvbmVudDogXCJ4XCIgfCBcInlcIiB8IFwielwiIHwgXCJ3XCIsIF92ZWN0b3I6IFZlY3RvcjQpID0+IG51bWJlcik6IFZlY3RvcjQge1xyXG4gICAgICB0aGlzLnggPSBfZnVuY3Rpb24odGhpcy54LCAwLCBcInhcIiwgdGhpcyk7XHJcbiAgICAgIHRoaXMueSA9IF9mdW5jdGlvbih0aGlzLnksIDEsIFwieVwiLCB0aGlzKTtcclxuICAgICAgdGhpcy56ID0gX2Z1bmN0aW9uKHRoaXMueiwgMiwgXCJ6XCIsIHRoaXMpO1xyXG4gICAgICB0aGlzLncgPSBfZnVuY3Rpb24odGhpcy53LCAzLCBcIndcIiwgdGhpcyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29weXMgdGhlIGVsZW1lbnRzIG9mIHRoaXMgdmVjdG9yIGludG8gdGhlIGdpdmVuIGFycmF5IHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBvZmZzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGUgZ2l2ZW4gYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b0FycmF5PFQgZXh0ZW5kcyB7IFtuOiBudW1iZXJdOiBudW1iZXIgfT4oX291dDogVCwgX29mZnNldDogbnVtYmVyID0gMCk6IFQge1xyXG4gICAgICBfb3V0W19vZmZzZXRdID0gdGhpcy54O1xyXG4gICAgICBfb3V0W19vZmZzZXQgKyAxXSA9IHRoaXMueTtcclxuICAgICAgX291dFtfb2Zmc2V0ICsgMl0gPSB0aGlzLno7XHJcbiAgICAgIF9vdXRbX29mZnNldCArIDNdID0gdGhpcy53O1xyXG5cclxuICAgICAgcmV0dXJuIF9vdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcm9wcyB0aGUgei1jb21wb25lbnQgYW5kIHctY29tcG9uZW50IGFuZCByZXR1cm5zIGEgVmVjdG9yMiBjb25zaXN0aW5nIG9mIHRoZSB4LSBhbmQgeS1jb21wb25lbnRzLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1ZlY3RvcjIoX291dDogVmVjdG9yMiA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjIpKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiBfb3V0LnNldCh0aGlzLngsIHRoaXMueSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcm9wcyB0aGUgdy1jb21wb25lbnQgYW5kIHJldHVybnMgYSBWZWN0b3IzIGNvbnNpc3Rpbmcgb2YgdGhlIHgtLCB5LSBhbmQgei1jb21wb25lbnRzLlxyXG4gICAgICogQHBhcmFtIF9vdXQgT3B0aW9uYWwgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1ZlY3RvcjMoX291dDogVmVjdG9yMyA9IFJlY3ljbGVyLnJldXNlKFZlY3RvcjMpKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBfb3V0LnNldCh0aGlzLngsIHRoaXMueSwgdGhpcy56KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBmb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgbGV0IHJlc3VsdDogc3RyaW5nID0gYCgke3RoaXMueC50b1ByZWNpc2lvbig1KX0sICR7dGhpcy55LnRvUHJlY2lzaW9uKDUpfSwgJHt0aGlzLnoudG9QcmVjaXNpb24oNSl9LCAke3RoaXMudy50b1ByZWNpc2lvbig1KX0pYDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICByZXR1cm4geyB0b0pTT046ICgpID0+IGBbJHt0aGlzLnh9LCAke3RoaXMueX0sICR7dGhpcy56fSwgJHt0aGlzLnd9XWAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFZlY3RvcjQ+IHtcclxuICAgICAgW3RoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMud10gPSBKU09OLnBhcnNlKDxzdHJpbmc+PHVua25vd24+X3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb3ZlcnJpZGUgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIGlmIChfbXV0YXRvci54ICE9IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLnggPSBfbXV0YXRvci54O1xyXG4gICAgICBpZiAoX211dGF0b3IueSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy55ID0gX211dGF0b3IueTtcclxuICAgICAgaWYgKF9tdXRhdG9yLnogIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMueiA9IF9tdXRhdG9yLno7XHJcbiAgICAgIGlmIChfbXV0YXRvci53ICE9IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLncgPSBfbXV0YXRvci53O1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7IC8qKiAqLyB9O1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERlc2NyaWJlcyBhIGZhY2Ugb2YgYSB7QGxpbmsgTWVzaH0gYnkgcmVmZXJlbmNpbmcgdGhyZWUge0BsaW5rIFZlcnRpY2VzfSB3aXRoIHRoZWlyIGluZGl6ZXNcclxuICAgKiBhbmQgY2FsY3VsYXRlcyBmYWNlIG5vcm1hbHMuXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRmFjZSB7XHJcbiAgICBwdWJsaWMgaW5kaWNlczogbnVtYmVyW10gPSBbXTtcclxuICAgIHB1YmxpYyBhbmdsZXM6IG51bWJlcltdID0gW107XHJcbiAgICBwdWJsaWMgbm9ybWFsVW5zY2FsZWQ6IFZlY3RvcjM7XHJcbiAgICBwdWJsaWMgbm9ybWFsOiBWZWN0b3IzO1xyXG4gICAgcHJpdmF0ZSB2ZXJ0aWNlczogVmVydGljZXM7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF92ZXJ0aWNlczogVmVydGljZXMsIF9pbmRleDA6IG51bWJlciwgX2luZGV4MTogbnVtYmVyLCBfaW5kZXgyOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5pbmRpY2VzID0gW19pbmRleDAsIF9pbmRleDEsIF9pbmRleDJdO1xyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gX3ZlcnRpY2VzO1xyXG4gICAgICB0aGlzLmNhbGN1bGF0ZU5vcm1hbHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXggcmVmZXJlbmNlZCBieSB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFBvc2l0aW9uKF9pbmRleDogbnVtYmVyKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzLnBvc2l0aW9uKHRoaXMuaW5kaWNlc1tfaW5kZXhdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIG11c3QgYmUgY29wbGFuYXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzSW5zaWRlKF9wb2ludDogVmVjdG9yMyk6IGJvb2xlYW4ge1xyXG4gICAgICBsZXQgZGlmZnM6IFZlY3RvcjNbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBpbmRleCBvZiB0aGlzLmluZGljZXMpIHtcclxuICAgICAgICBsZXQgZGlmZjogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh0aGlzLnZlcnRpY2VzLnBvc2l0aW9uKGluZGV4KSwgX3BvaW50KTtcclxuICAgICAgICBkaWZmcy5wdXNoKGRpZmYpO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBuMDogVmVjdG9yMyA9IFZlY3RvcjMuQ1JPU1MoZGlmZnNbMV0sIGRpZmZzWzBdKTtcclxuICAgICAgbGV0IG4xOiBWZWN0b3IzID0gVmVjdG9yMy5DUk9TUyhkaWZmc1syXSwgZGlmZnNbMV0pO1xyXG4gICAgICBsZXQgbjI6IFZlY3RvcjMgPSBWZWN0b3IzLkNST1NTKGRpZmZzWzBdLCBkaWZmc1syXSk7XHJcblxyXG4gICAgICBsZXQgZG90MTogbnVtYmVyID0gVmVjdG9yMy5ET1QobjAsIG4xKTtcclxuICAgICAgbGV0IGRvdDI6IG51bWJlciA9IFZlY3RvcjMuRE9UKG4wLCBuMik7XHJcblxyXG4gICAgICByZXR1cm4gIShkb3QxIDwgMCB8fCBkb3QyIDwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVOb3JtYWxzKCk6IHZvaWQge1xyXG4gICAgICBsZXQgdHJpZ29uOiBWZWN0b3IzW10gPSB0aGlzLmluZGljZXMubWFwKChfaW5kZXg6IG51bWJlcikgPT4gdGhpcy52ZXJ0aWNlcy5wb3NpdGlvbihfaW5kZXgpKTtcclxuICAgICAgbGV0IHYxOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKHRyaWdvblsxXSwgdHJpZ29uWzBdKTtcclxuICAgICAgbGV0IHYyOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKHRyaWdvblsyXSwgdHJpZ29uWzBdKTtcclxuICAgICAgdGhpcy5ub3JtYWxVbnNjYWxlZCA9IFZlY3RvcjMuQ1JPU1ModjEsIHYyKTtcclxuICAgICAgdGhpcy5ub3JtYWwgPSBWZWN0b3IzLk5PUk1BTElaQVRJT04odGhpcy5ub3JtYWxVbnNjYWxlZCk7XHJcbiAgICAgIHRoaXMuYW5nbGVzLnB1c2goXHJcbiAgICAgICAgVmVjdG9yMy5BTkdMRSh2MSwgdjIpLFxyXG4gICAgICAgIFZlY3RvcjMuQU5HTEUoVmVjdG9yMy5ESUZGRVJFTkNFKHRyaWdvblsyXSwgdHJpZ29uWzFdKSwgVmVjdG9yMy5ESUZGRVJFTkNFKHRyaWdvblswXSwgdHJpZ29uWzFdKSksXHJcbiAgICAgICAgVmVjdG9yMy5BTkdMRShWZWN0b3IzLkRJRkZFUkVOQ0UodHJpZ29uWzBdLCB0cmlnb25bMl0pLCBWZWN0b3IzLkRJRkZFUkVOQ0UodHJpZ29uWzFdLCB0cmlnb25bMl0pKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgc2ltcGxlIGN1YmUgd2l0aCBlZGdlcyBvZiBsZW5ndGggMSwgZWFjaCBmYWNlIGNvbnNpc3Rpbmcgb2YgdHdvIHRyaWdvbnNcclxuICAgKiBgYGB0ZXh0XHJcbiAgICogICAgICAgKDEyKSA0X19fXzcgICgxMSlcclxuICAgKiAgICAgICAoOCkgMC9fXzMvfCAoMTApXHJcbiAgICogICAgICAgKDE1KSB8fDVffHw2ICgxNClcclxuICAgKiAgICAgICAoOSkgMXwvXzJ8LyAoMTMpXHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaEN1YmUgZXh0ZW5kcyBNZXNoIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaEN1YmUpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoQ3ViZVwiKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuXHJcbiAgICAgIC8vIG5vIHNoYXJlZCB2ZXJ0aWNlcywgY29ybmVycyBuZWVkIHRocmVlIG5vcm1hbHMgZm9yIFBob25nIGFuZCBHb3VyYXVkXHJcbiAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgVmVydGljZXMoXHJcbiAgICAgICAgLy8gZnJvbnQgdmVydGljZXNcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKC0wLjUsIDAuNSwgMC41KSwgbmV3IFZlY3RvcjIoMCwgMCkpLCAvLyAwXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygtMC41LCAtMC41LCAwLjUpLCBuZXcgVmVjdG9yMigwLCAxKSksIC8vIDFcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKDAuNSwgLTAuNSwgMC41KSwgbmV3IFZlY3RvcjIoMSwgMSkpLCAvLyAyXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjUsIDAuNSwgMC41KSwgbmV3IFZlY3RvcjIoMSwgMCkpIC8vM1xyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gZ2VuZXJhdGUgdmVydGljZXMgb24gc2lkZXNcclxuICAgICAgZm9yIChsZXQgYW5nbGU6IG51bWJlciA9IDkwOyBhbmdsZSA8IDM2MDsgYW5nbGUgKz0gOTApIHtcclxuICAgICAgICBsZXQgdHJhbnNmb3JtOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT04oVmVjdG9yMy5ZKGFuZ2xlKSk7XHJcbiAgICAgICAgbGV0IHNpZGU6IFZlcnRleFtdID0gdGhpcy52ZXJ0aWNlcy5zbGljZSgwLCA0KS5tYXAoKF92OiBWZXJ0ZXgpID0+XHJcbiAgICAgICAgICBuZXcgVmVydGV4KFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3YucG9zaXRpb24sIHRyYW5zZm9ybSksIF92LnV2KSk7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKC4uLnNpZGUpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGdlbmVyYXRlIHZlcnRpY2VzIGZvciB0b3AgYW5kIGJvdHRvbVxyXG4gICAgICBmb3IgKGxldCBhbmdsZTogbnVtYmVyID0gOTA7IGFuZ2xlIDwgMzYwOyBhbmdsZSArPSAxODApIHtcclxuICAgICAgICBsZXQgdHJhbnNmb3JtOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT04oVmVjdG9yMy5YKGFuZ2xlKSk7XHJcbiAgICAgICAgbGV0IHNpZGU6IFZlcnRleFtdID0gdGhpcy52ZXJ0aWNlcy5zbGljZSgwLCA0KS5tYXAoKF92OiBWZXJ0ZXgpID0+XHJcbiAgICAgICAgICBuZXcgVmVydGV4KFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3YucG9zaXRpb24sIHRyYW5zZm9ybSksIF92LnV2KSk7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKC4uLnNpZGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmZhY2VzID0gW107XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCAyNDsgaSArPSA0KVxyXG4gICAgICAgIC8vIGdlbmVyYXRlIGZhY2VzXHJcbiAgICAgICAgdGhpcy5mYWNlcy5wdXNoKC4uLm5ldyBRdWFkKHRoaXMudmVydGljZXMsIGkgKyAwLCBpICsgMSwgaSArIDIsIGkgKyAzKS5mYWNlcyk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSBmbGF0IHBvbHlnb24uIEFsbCB0cmlnb25zIHNoYXJlIHZlcnRleCAwLCBzbyBjYXJlZnVsIGRlc2lnbiBpcyByZXF1aXJlZCB0byBjcmVhdGUgY29uY2F2ZSBwb2x5Z29ucy4gXHJcbiAgICogVmVydGV4IDAgaXMgYWxzbyBhc3NvY2lhdGVkIHdpdGggdGhlIGZhY2Ugbm9ybWFsLlxyXG4gICAqIGBgYHRleHRcclxuICAgKiAgICAgICAgICAgICAwIFxyXG4gICAqICAgICAgICAgICAx4pWxfOKVsiAgNCAuLi5cclxuICAgKiAgICAgICAgICAgIOKVsnxf4pWy4pWxIFxyXG4gICAqICAgICAgICAgICAgMiAgIDNcclxuICAgKiBgYGBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMS0yMDIyXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hQb2x5Z29uIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hQb2x5Z29uKTtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgc2hhcGVEZWZhdWx0OiBWZWN0b3IyW10gPSBbIC8vIHRyaWdvbiBpcyB0aGUgbWluaW1hbCBzaGFwZVxyXG4gICAgICBuZXcgVmVjdG9yMigtMSwgLTEpLFxyXG4gICAgICBuZXcgVmVjdG9yMigxLCAtMSksXHJcbiAgICAgIG5ldyBWZWN0b3IyKDAsIDEpXHJcbiAgICBdO1xyXG4gICAgcHJvdGVjdGVkIHNoYXBlOiBNdXRhYmxlQXJyYXk8VmVjdG9yMj4gPSBuZXcgTXV0YWJsZUFycmF5PFZlY3RvcjI+KFZlY3RvcjIpO1xyXG4gICAgcHJvdGVjdGVkIGZpdFRleHR1cmU6IGJvb2xlYW47XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hQb2x5Z29uXCIsIF9zaGFwZTogVmVjdG9yMltdID0gTWVzaFBvbHlnb24uc2hhcGVEZWZhdWx0LCBfZml0VGV4dHVyZTogYm9vbGVhbiA9IHRydWUpIHtcclxuICAgICAgc3VwZXIoX25hbWUpO1xyXG4gICAgICB0aGlzLmNyZWF0ZShfc2hhcGUsIF9maXRUZXh0dXJlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgZ2V0IG1pblZlcnRpY2VzKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiAzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRoaXMgbWVzaCBmcm9tIHRoZSBnaXZlbiB2ZXJ0aWNlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZShfc2hhcGU6IFZlY3RvcjJbXSA9IFtdLCBfZml0VGV4dHVyZTogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgdGhpcy5zaGFwZSA9IDxNdXRhYmxlQXJyYXk8VmVjdG9yMj4+TXV0YWJsZUFycmF5LmZyb20oX3NoYXBlLm1hcChfdmVydGV4ID0+IF92ZXJ0ZXguY2xvbmUpKTtcclxuICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICB0aGlzLmZpdFRleHR1cmUgPSBfZml0VGV4dHVyZTtcclxuXHJcbiAgICAgIGlmIChfc2hhcGUubGVuZ3RoIDwgdGhpcy5taW5WZXJ0aWNlcykge1xyXG4gICAgICAgIERlYnVnLndhcm4oYEF0IGxlYXN0ICR7dGhpcy5taW5WZXJ0aWNlc30gdmVydGljZXMgbmVlZGVkIHRvIGNvbnN0cnVjdCBNZXNoUG9seWdvbiwgZGVmYXVsdCB0cmlnb24gdXNlZGApO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlKE1lc2hQb2x5Z29uLnNoYXBlRGVmYXVsdCwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgc2hhcGU6IFZlY3RvcjJbXSA9IF9zaGFwZTtcclxuXHJcbiAgICAgIGxldCBtaW46IFZlY3RvcjIgPSBWZWN0b3IyLlpFUk8oKTtcclxuICAgICAgbGV0IG1heDogVmVjdG9yMiA9IFZlY3RvcjIuWkVSTygpO1xyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgIGZvciAobGV0IHZlcnRleCBvZiBzaGFwZSkge1xyXG4gICAgICAgIHRoaXMudmVydGljZXMucHVzaChuZXcgVmVydGV4KHZlcnRleC50b1ZlY3RvcjMoKSkpO1xyXG5cclxuICAgICAgICBtaW4ueCA9IE1hdGgubWluKG1pbi54LCB2ZXJ0ZXgueCk7XHJcbiAgICAgICAgbWF4LnggPSBNYXRoLm1heChtYXgueCwgdmVydGV4LngpO1xyXG4gICAgICAgIG1pbi55ID0gTWF0aC5taW4obWluLnksIHZlcnRleC55KTtcclxuICAgICAgICBtYXgueSA9IE1hdGgubWF4KG1heC55LCB2ZXJ0ZXgueSk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IHNpemU6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihtYXgueCAtIG1pbi54LCBtYXgueSAtIG1pbi55KTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmZpdFRleHR1cmUpIHtcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGxldCB0ZXh0dXJlVVY6IFZlY3RvcjIgPSBWZWN0b3IyLkRJRkZFUkVOQ0Uoc2hhcGVbaV0sIG1pbik7XHJcbiAgICAgICAgICB0aGlzLnZlcnRpY2VzW2ldLnV2ID0gbmV3IFZlY3RvcjIodGV4dHVyZVVWLnggLyBzaXplLngsIDEgLSB0ZXh0dXJlVVYueSAvIHNpemUueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9zaGFwZS5mb3JFYWNoKChfdmVydGV4LCBfaSkgPT4gdGhpcy52ZXJ0aWNlc1tfaV0udXYgPSBuZXcgVmVjdG9yMihfdmVydGV4LngsIC1fdmVydGV4LnkpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5mYWNlcyA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAyOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKylcclxuICAgICAgICB0aGlzLmZhY2VzLnB1c2gobmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgaSAtIDEsIGksIDApKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc2hhcGUgPSBTZXJpYWxpemVyLnNlcmlhbGl6ZUFycmF5KFZlY3RvcjIsIHRoaXMuc2hhcGUpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmZpdFRleHR1cmUgPSB0aGlzLmZpdFRleHR1cmU7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBsZXQgdmVjdG9yczogVmVjdG9yMltdID0gPFZlY3RvcjJbXT5hd2FpdCBTZXJpYWxpemVyLmRlc2VyaWFsaXplQXJyYXkoX3NlcmlhbGl6YXRpb24uc2hhcGUpO1xyXG4gICAgICB0aGlzLmNyZWF0ZSh2ZWN0b3JzLCBfc2VyaWFsaXphdGlvbi5maXRUZXh0dXJlKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgICAgdGhpcy5jcmVhdGUodGhpcy5zaGFwZSwgdGhpcy5maXRUZXh0dXJlKTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5NVVRBVEUpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIi8vLzxyZWZlcmVuY2UgcGF0aD1cIk1lc2hQb2x5Z29uLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZXMgYW4gZXh0cnVzaW9uIG9mIGEgcG9seWdvbiBieSBhIHNlcmllcyBvZiB0cmFuc2Zvcm1hdGlvbnNcclxuICAgKiBgYGB0ZXh0ICBcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICBfX19fXHJcbiAgICogUG9seWdvbiAgICAgICAgIF9fX1/ilbHilbIgICDilbIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlcclxuICAgKiBUcmFuc2Zvcm0gMCAg4oaSIOKVsSDilbJfX+KVsl/ilbJfX1/ilbIg4oaQIFRyYW5zZm9ybSAyICAgICAgICAgIHogX1/ilIJcclxuICAgKiAoYmFzZSkgICAgICAgICDilbJf4pWxX1/ilbEg4pWxICAg4pWxICAgKGxpZCkgICAgICAgICAgICAgICAgICAgICDilbIgICAgICAgXHJcbiAgICogICAgIFRyYW5zZm9ybSAxICDihpIgIOKVsuKVsV9fX+KVsSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4XHJcbiAgICogYGBgXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoRXh0cnVzaW9uIGV4dGVuZHMgTWVzaFBvbHlnb24ge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoRXh0cnVzaW9uKTtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgbXR4RGVmYXVsdHM6IE1hdHJpeDR4NFtdID0gWyAvLyBvZmZzZXQgb2YgKzAuNXogYW5kIC0wLjV6IGFzIGRlZmF1bHRcclxuICAgICAgTWF0cml4NHg0LlRSQU5TTEFUSU9OKFZlY3RvcjMuWigwLjUpKSxcclxuICAgICAgTWF0cml4NHg0LlRSQU5TTEFUSU9OKFZlY3RvcjMuWigtMC41KSlcclxuICAgIF07XHJcbiAgICBwcml2YXRlIG10eFRyYW5zZm9ybXM6IE11dGFibGVBcnJheTxNYXRyaXg0eDQ+ID0gbmV3IE11dGFibGVBcnJheShNYXRyaXg0eDQpO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoRXh0cnVzaW9uXCIsIF92ZXJ0aWNlczogVmVjdG9yMltdID0gTWVzaFBvbHlnb24uc2hhcGVEZWZhdWx0LCBfbXR4VHJhbnNmb3JtczogTWF0cml4NHg0W10gPSBNZXNoRXh0cnVzaW9uLm10eERlZmF1bHRzLCBfZml0VGV4dHVyZTogYm9vbGVhbiA9IHRydWUpIHtcclxuICAgICAgc3VwZXIoX25hbWUsIF92ZXJ0aWNlcywgX2ZpdFRleHR1cmUpO1xyXG4gICAgICB0aGlzLmV4dHJ1ZGUoX210eFRyYW5zZm9ybXMpO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhcIk11dGF0b3JcIiwgdGhpcy5nZXRNdXRhdG9yKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi50cmFuc2Zvcm1zID0gU2VyaWFsaXplci5zZXJpYWxpemVBcnJheShNYXRyaXg0eDQsIHRoaXMubXR4VHJhbnNmb3Jtcyk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgbGV0IG10eFRyYW5zZm9ybXM6IE1hdHJpeDR4NFtdO1xyXG4gICAgICBpZiAoX3NlcmlhbGl6YXRpb24udHJhbnNmb3JtcylcclxuICAgICAgICBtdHhUcmFuc2Zvcm1zID0gPE1hdHJpeDR4NFtdPmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemVBcnJheShfc2VyaWFsaXphdGlvbi50cmFuc2Zvcm1zKTtcclxuICAgICAgdGhpcy5leHRydWRlKG10eFRyYW5zZm9ybXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgYXdhaXQgc3VwZXIubXV0YXRlKF9tdXRhdG9yLCBfc2VsZWN0aW9uLCBfZGlzcGF0Y2hNdXRhdGUpO1xyXG4gICAgICB0aGlzLmV4dHJ1ZGUodGhpcy5tdHhUcmFuc2Zvcm1zKTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVkVOVC5NVVRBVEUpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByaXZhdGUgZXh0cnVkZShfbXR4VHJhbnNmb3JtczogTWF0cml4NHg0W10gPSBNZXNoRXh0cnVzaW9uLm10eERlZmF1bHRzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMubXR4VHJhbnNmb3JtcyA9IDxNdXRhYmxlQXJyYXk8TWF0cml4NHg0Pj5NdXRhYmxlQXJyYXkuZnJvbSg8TXV0YWJsZUFycmF5PE1hdHJpeDR4ND4+X210eFRyYW5zZm9ybXMpO1xyXG4gICAgICBsZXQgblRyYW5zZm9ybXM6IG51bWJlciA9IF9tdHhUcmFuc2Zvcm1zLmxlbmd0aDtcclxuICAgICAgbGV0IG5WZXJ0aWNlc1NoYXBlOiBudW1iZXIgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIGNyZWF0ZSBuZXcgdmVydGV4IGNsb3VkLCBjdXJyZW50IGNsb3VkIGhvbGRzIE1lc2hQb2x5Z29uXHJcbiAgICAgIGxldCB2ZXJ0aWNlczogVmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuXHJcbiAgICAgIC8vIGNyZWF0ZSBiYXNlIGJ5IHRyYW5zZm9ybWF0aW9uIG9mIHBvbHlnb24gd2l0aCBmaXJzdCB0cmFuc2Zvcm1cclxuICAgICAgbGV0IGJhc2U6IFZlcnRleFtdID0gdGhpcy52ZXJ0aWNlcy5tYXAoKF92OiBWZXJ0ZXgpID0+IG5ldyBWZXJ0ZXgoVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfdi5wb3NpdGlvbiwgX210eFRyYW5zZm9ybXNbMF0sIHRydWUpLCBfdi51dikpO1xyXG4gICAgICB2ZXJ0aWNlcy5wdXNoKC4uLmJhc2UpO1xyXG4gICAgICAvLyBjcmVhdGUgbGlkIGJ5IHRyYW5zZm9ybWF0aW9uIG9mIHBvbHlnb24gd2l0aCBsYXN0IHRyYW5zZm9ybVxyXG4gICAgICBsZXQgbGlkOiBWZXJ0ZXhbXSA9IHRoaXMudmVydGljZXMubWFwKChfdjogVmVydGV4KSA9PiBuZXcgVmVydGV4KFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3YucG9zaXRpb24sIF9tdHhUcmFuc2Zvcm1zW25UcmFuc2Zvcm1zIC0gMV0sIHRydWUpLCBfdi51dikpO1xyXG4gICAgICB2ZXJ0aWNlcy5wdXNoKC4uLmxpZCk7XHJcblxyXG4gICAgICAvLyByZWNyZWF0ZSBiYXNlIGZhY2VzIHRvIHJlY2FsY3VsYXRlIG5vcm1hbHNcclxuICAgICAgdGhpcy5mYWNlcyA9IHRoaXMuZmFjZXMubWFwKChfZmFjZTogRmFjZSkgPT4gbmV3IEZhY2UodmVydGljZXMsIF9mYWNlLmluZGljZXNbMF0sIF9mYWNlLmluZGljZXNbMV0sIF9mYWNlLmluZGljZXNbMl0pKTtcclxuICAgICAgLy8gY3JlYXRlIHRoZSBsaWQgZmFjZXMgdXNpbmcgdGhlIGluZGljZXMgb2YgdGhlIGJhc2UgZmFjZXMsIGJ1dCB3aXRoIGFuIGluZGV4IG9mZnNldCBhbmQgcmV2ZXJzZSBvcmRlciBvZiBpbmRpY2VzXHJcbiAgICAgIHRoaXMuZmFjZXMucHVzaCguLi50aGlzLmZhY2VzLm1hcChfZmFjZSA9PlxyXG4gICAgICAgIG5ldyBGYWNlKHZlcnRpY2VzLCBfZmFjZS5pbmRpY2VzWzJdICsgblZlcnRpY2VzU2hhcGUsIF9mYWNlLmluZGljZXNbMV0gKyBuVmVydGljZXNTaGFwZSwgX2ZhY2UuaW5kaWNlc1swXSArIG5WZXJ0aWNlc1NoYXBlKVxyXG4gICAgICApKTtcclxuXHJcbiAgICAgIGZvciAobGV0IHQ6IG51bWJlciA9IDA7IHQgPCBuVHJhbnNmb3JtczsgdCsrKSB7XHJcbiAgICAgICAgbGV0IG10eFRyYW5zZm9ybTogTWF0cml4NHg0ID0gX210eFRyYW5zZm9ybXNbdF07XHJcbiAgICAgICAgbGV0IHJlZmVyVG9DbG9zZTogbnVtYmVyID0gdmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgIGxldCB3cmFwOiBWZXJ0ZXhbXSA9IHRoaXMudmVydGljZXMubWFwKChfdjogVmVydGV4LCBfaTogbnVtYmVyKSA9PlxyXG4gICAgICAgICAgbmV3IFZlcnRleChWZWN0b3IzLlRSQU5TRk9STUFUSU9OKF92LnBvc2l0aW9uLCBtdHhUcmFuc2Zvcm0sIHRydWUpLCBuZXcgVmVjdG9yMihfaSAvIG5WZXJ0aWNlc1NoYXBlLCB0IC8gblRyYW5zZm9ybXMpKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmVydGljZXMucHVzaCguLi53cmFwKTtcclxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZXJ0ZXgocmVmZXJUb0Nsb3NlLCBuZXcgVmVjdG9yMigxLCB0IC8gblRyYW5zZm9ybXMpKSk7XHJcbiAgICAgICAgLy8gaWYgKGkgPiAwICYmIGkgPCBuVHJhbnNmb3JtcyAtIDEpXHJcbiAgICAgICAgLy8gICB2ZXJ0aWNlcy5wdXNoKC4uLndyYXAubWFwKChfdmVjdG9yOiBWZWN0b3IzKSA9PiBfdmVjdG9yLmNsb25lKSk7IDwtIG5vIHNsaWNpbmcgZm9yIGZsYXQgc2hhZGluZyB5ZXQuLi5cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY3JlYXRlIGluZGl6ZXMgZm9yIHdyYXBwZXJcclxuICAgICAgZm9yIChsZXQgdDogbnVtYmVyID0gMDsgdCA8IG5UcmFuc2Zvcm1zIC0gMTsgdCsrKVxyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBuVmVydGljZXNTaGFwZTsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgaW5kZXg6IG51bWJlciA9XHJcbiAgICAgICAgICAgICsgMiAqIG5WZXJ0aWNlc1NoYXBlIC8vIGJhc2UgJiBsaWQgYXJlIG9mZnNldHMgXHJcbiAgICAgICAgICAgICsgdCAqIChuVmVydGljZXNTaGFwZSArIDEpIC8vIG9mZnNldCBmb3IgZWFjaCB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgICAgICArIGk7XHJcbiAgICAgICAgICBsZXQgcXVhZDogUXVhZCA9IG5ldyBRdWFkKHZlcnRpY2VzLCBpbmRleCwgaW5kZXggKyBuVmVydGljZXNTaGFwZSArIDEsIGluZGV4ICsgblZlcnRpY2VzU2hhcGUgKyAyLCBpbmRleCArIDEsIFFVQURTUExJVC5BVF8wKTtcclxuICAgICAgICAgIHRoaXMuZmFjZXMucHVzaCguLi5xdWFkLmZhY2VzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXM7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gcHJpdmF0ZSBjYWxjdWxhdGVQb2x5Z29uTGVuZ3RocygpOiBudW1iZXJbXSB7XHJcbiAgICAvLyAgIGxldCByZXN1bHQ6IG51bWJlcltdID0gW107XHJcbiAgICAvLyAgIGxldCBmaXJzdDogVmVjdG9yMztcclxuICAgIC8vICAgbGV0IHByZXY6IFZlY3RvcjM7XHJcbiAgICAvLyAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAvLyAgICAgbGV0IGN1cnJlbnQ6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMyh0aGlzLnZlcnRpY2VzW2ldLCB0aGlzLnZlcnRpY2VzW2kgKyAxXSwgdGhpcy52ZXJ0aWNlc1tpICsgMl0pO1xyXG4gICAgLy8gICAgIGlmIChwcmV2KVxyXG4gICAgLy8gICAgICAgcmVzdWx0LnB1c2goVmVjdG9yMy5ESUZGRVJFTkNFKGN1cnJlbnQsIHByZXYpLm1hZ25pdHVkZSk7XHJcbiAgICAvLyAgICAgZWxzZVxyXG4gICAgLy8gICAgICAgZmlyc3QgPSBjdXJyZW50O1xyXG4gICAgLy8gICAgIHByZXYgPSBjdXJyZW50O1xyXG4gICAgLy8gICB9XHJcbiAgICAvLyAgIHJlc3VsdC5wdXNoKFZlY3RvcjMuRElGRkVSRU5DRShmaXJzdCwgcHJldikubWFnbml0dWRlKTtcclxuICAgIC8vICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIC8vIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBtZXNoIGxvYWRlZCBmcm9tIGFuIEZCWC1GaWxlLlxyXG4gICAqIEBhdXRob3JzIE1hdHRoaWFzIFJvbWluZywgSEZVLCAyMDIzIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hGQlggZXh0ZW5kcyBtaXhpblNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWwoTWVzaCkge1xyXG4gICAgLy8gcHVibGljIHVybDogUmVxdWVzdEluZm87XHJcbiAgICBwdWJsaWMgaU1lc2g6IG51bWJlcjtcclxuICAgIHB1YmxpYyBhc3luYyBsb2FkKF91cmw6IFJlcXVlc3RJbmZvID0gdGhpcy51cmwsIF9pTWVzaDogbnVtYmVyID0gdGhpcy5pTWVzaCk6IFByb21pc2U8TWVzaEZCWD4ge1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMudXJsID0gX3VybDtcclxuICAgICAgdGhpcy5pTWVzaCA9IF9pTWVzaDtcclxuICAgICAgY29uc3QgbG9hZGVyOiBGQlhMb2FkZXIgPSBhd2FpdCBGQlhMb2FkZXIuTE9BRCh0aGlzLnVybC50b1N0cmluZygpKTtcclxuICAgICAgY29uc3QgZ2VvbWV0cnlGQlg6IEZCWC5HZW9tZXRyeSA9IChcclxuICAgICAgICBsb2FkZXIuZmJ4Lm9iamVjdHMuZ2VvbWV0cmllc1tfaU1lc2hdIHx8XHJcbiAgICAgICAgbG9hZGVyLmZieC5vYmplY3RzLmdlb21ldHJpZXMuZmluZChfb2JqZWN0ID0+IF9vYmplY3QubmFtZSA9PSB0aGlzLm5hbWUpIHx8XHJcbiAgICAgICAgbG9hZGVyLmZieC5vYmplY3RzLm1vZGVscy5maW5kKF9vYmplY3QgPT4gX29iamVjdC5uYW1lID09IHRoaXMubmFtZSAmJiBfb2JqZWN0LnN1YnR5cGUgPT0gXCJNZXNoXCIpLmNoaWxkcmVuWzBdXHJcbiAgICAgICkubG9hZCgpO1xyXG4gICAgICBpZiAoZ2VvbWV0cnlGQlgpXHJcbiAgICAgICAgdGhpcy5uYW1lID0gZ2VvbWV0cnlGQlgubmFtZS5sZW5ndGggPiAwID8gZ2VvbWV0cnlGQlgubmFtZSA6IGdlb21ldHJ5RkJYLnBhcmVudHNbMF0ubmFtZTtcclxuXHJcbiAgICAgIGxldCBwb3NpdGlvbnM6IFZlY3RvcjNbXSA9IFtdO1xyXG4gICAgICBsZXQgdmVydGV4QnVmZmVyOiBGbG9hdDMyQXJyYXkgPSBnZW9tZXRyeUZCWC5WZXJ0aWNlcztcclxuICAgICAgZm9yIChsZXQgaVZlcnRleDogbnVtYmVyID0gMDsgaVZlcnRleCA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGlWZXJ0ZXggKz0gMykge1xyXG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKG5ldyBWZWN0b3IzKHZlcnRleEJ1ZmZlcltpVmVydGV4ICsgMF0sIHZlcnRleEJ1ZmZlcltpVmVydGV4ICsgMV0sIHZlcnRleEJ1ZmZlcltpVmVydGV4ICsgMl0pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHV2czogVmVjdG9yMltdID0gW107XHJcbiAgICAgIGlmIChnZW9tZXRyeUZCWC5MYXllckVsZW1lbnRVVikge1xyXG4gICAgICAgIGxldCB1dkJ1ZmZlcjogRmxvYXQzMkFycmF5ID0gZ2VvbWV0cnlGQlguTGF5ZXJFbGVtZW50VVYuVVY7XHJcbiAgICAgICAgZm9yIChsZXQgaXV2OiBudW1iZXIgPSAwOyBpdXYgPCB1dkJ1ZmZlci5sZW5ndGg7IGl1diArPSAyKSB7XHJcbiAgICAgICAgICB1dnMucHVzaChuZXcgVmVjdG9yMih1dkJ1ZmZlcltpdXZdLCAxIC0gdXZCdWZmZXJbaXV2ICsgMV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBub3JtYWxzOiBWZWN0b3IzW10gPSBbXTtcclxuICAgICAgaWYgKGdlb21ldHJ5RkJYLkxheWVyRWxlbWVudE5vcm1hbCkge1xyXG4gICAgICAgIGxldCBub3JtYWxCdWZmZXI6IEZsb2F0MzJBcnJheSA9IGdlb21ldHJ5RkJYLkxheWVyRWxlbWVudE5vcm1hbC5Ob3JtYWxzO1xyXG4gICAgICAgIGZvciAobGV0IGlOb3JtYWw6IG51bWJlciA9IDA7IGlOb3JtYWwgPCBub3JtYWxCdWZmZXIubGVuZ3RoOyBpTm9ybWFsICs9IDMpIHtcclxuICAgICAgICAgIG5vcm1hbHMucHVzaChuZXcgVmVjdG9yMyhub3JtYWxCdWZmZXJbaU5vcm1hbF0sIG5vcm1hbEJ1ZmZlcltpTm9ybWFsICsgMV0sIG5vcm1hbEJ1ZmZlcltpTm9ybWFsICsgMl0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBtYXBWZXJ0ZXhUb0luZGV4OiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xyXG4gICAgICBsZXQgbmV3VmVydGV4SW5kaWNlczogbnVtYmVyW11bXSA9IFtdO1xyXG4gICAgICBsZXQgaVBvbHlnb246IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCBpc0VuZE9mUG9seWdvbjogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICBsZXQgcG9seWdvbjogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICAgIGdlb21ldHJ5RkJYLlBvbHlnb25WZXJ0ZXhJbmRleC5mb3JFYWNoKChfaVZlcnRleCwgX2lQb2x5Z29uVmVydGV4KSA9PiB7XHJcbiAgICAgICAgaWYgKF9pVmVydGV4IDwgMCkge1xyXG4gICAgICAgICAgX2lWZXJ0ZXggPSBfaVZlcnRleCBeIC0gMTtcclxuICAgICAgICAgIGlzRW5kT2ZQb2x5Z29uID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBwb3NpdGlvbjogVmVjdG9yMyA9IHBvc2l0aW9uc1tfaVZlcnRleF07XHJcbiAgICAgICAgbGV0IHV2OiBWZWN0b3IyID0gdXZzW3RoaXMuZ2V0RGF0YUluZGV4KGdlb21ldHJ5RkJYLkxheWVyRWxlbWVudFVWLCBfaVZlcnRleCwgaVBvbHlnb24sIF9pUG9seWdvblZlcnRleCldO1xyXG5cclxuICAgICAgICBsZXQgdmVydGV4S2V5OiBzdHJpbmcgPSBwb3NpdGlvbi50b1N0cmluZygpICsgdXYudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAoIW1hcFZlcnRleFRvSW5kZXguaGFzKHZlcnRleEtleSkpIHtcclxuICAgICAgICAgIGxldCBub3JtYWw6IFZlY3RvcjMgPSBub3JtYWxzW3RoaXMuZ2V0RGF0YUluZGV4KGdlb21ldHJ5RkJYLkxheWVyRWxlbWVudE5vcm1hbCwgX2lWZXJ0ZXgsIGlQb2x5Z29uLCBfaVBvbHlnb25WZXJ0ZXgpXTtcclxuXHJcbiAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2gobmV3IFZlcnRleChwb3NpdGlvbiwgdXYsIG5vcm1hbCkpO1xyXG4gICAgICAgICAgbWFwVmVydGV4VG9JbmRleC5zZXQodmVydGV4S2V5LCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgaWYgKCFuZXdWZXJ0ZXhJbmRpY2VzW19pVmVydGV4XSlcclxuICAgICAgICAgICAgbmV3VmVydGV4SW5kaWNlc1tfaVZlcnRleF0gPSBbXTtcclxuICAgICAgICAgIG5ld1ZlcnRleEluZGljZXNbX2lWZXJ0ZXhdLnB1c2godGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9seWdvbi5wdXNoKG1hcFZlcnRleFRvSW5kZXguZ2V0KHZlcnRleEtleSkpO1xyXG5cclxuICAgICAgICBpZiAoaXNFbmRPZlBvbHlnb24pIHtcclxuICAgICAgICAgIGlmIChwb2x5Z29uLmxlbmd0aCA9PSAzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChuZXcgRmFjZSh0aGlzLnZlcnRpY2VzLCBwb2x5Z29uWzBdLCBwb2x5Z29uWzFdLCBwb2x5Z29uWzJdKSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHBvbHlnb24ubGVuZ3RoID09IDQpIHtcclxuICAgICAgICAgICAgbGV0IHF1YWQ6IFF1YWQgPSBuZXcgUXVhZCh0aGlzLnZlcnRpY2VzLCBwb2x5Z29uWzBdLCBwb2x5Z29uWzFdLCBwb2x5Z29uWzJdLCBwb2x5Z29uWzNdKTtcclxuICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKC4uLnF1YWQuZmFjZXMpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMjsgaSA8IHBvbHlnb24ubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKG5ldyBGYWNlKHRoaXMudmVydGljZXMsIHBvbHlnb25bMF0sIHBvbHlnb25baSAtIDFdLCBwb2x5Z29uW2kgLSAwXSkpO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oYCR7TWVzaExvYWRlckZCWC5uYW1lfTogUG9seWdvbnMgd2l0aCBtb3JlIHRoYW4gNCB2ZXJ0aWNlcyBhcmUgbm90IHN1cHBvcnRlZC5gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBvbHlnb24gPSBbXTtcclxuICAgICAgICAgIGlzRW5kT2ZQb2x5Z29uID0gZmFsc2U7XHJcbiAgICAgICAgICBpUG9seWdvbisrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoZ2VvbWV0cnlGQlguY2hpbGRyZW4/LlswXS50eXBlID09IFwiRGVmb3JtZXJcIikge1xyXG4gICAgICAgIGNvbnN0IGZieERlZm9ybWVyOiBGQlguRGVmb3JtZXIgPSBnZW9tZXRyeUZCWC5jaGlsZHJlblswXTtcclxuICAgICAgICBjb25zdCBza2VsZXRvbjogQ29tcG9uZW50U2tlbGV0b24gPSBhd2FpdCBsb2FkZXIuZ2V0U2tlbGV0b24oZmJ4RGVmb3JtZXIuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0pOyAvLyBEZWZvcm1lci5TdWJEZWZvcm1lci5MaW1iTm9kZVxyXG4gICAgICAgIHRoaXMuY3JlYXRlQm9uZXMoZmJ4RGVmb3JtZXIsIHNrZWxldG9uLCB0aGlzLnZlcnRpY2VzLCBuZXdWZXJ0ZXhJbmRpY2VzKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBjb25zdCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uaU1lc2ggPSB0aGlzLmlNZXNoO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLmlNZXNoID0gX3NlcmlhbGl6YXRpb24uaU1lc2g7XHJcbiAgICAgIHJldHVybiBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXREYXRhSW5kZXgoX2xheWVyRWxlbWVudDogRkJYLkxheWVyRWxlbWVudFVWIHwgRkJYLkxheWVyRWxlbWVudE5vcm1hbCwgX2lWZXJ0ZXg6IG51bWJlciwgX2lQb2x5Z29uOiBudW1iZXIsIF9pUG9seWdvblZlcnRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgbGV0IGluZGV4OiBudW1iZXIgPVxyXG4gICAgICAgIF9sYXllckVsZW1lbnQuTWFwcGluZ0luZm9ybWF0aW9uVHlwZSA9PSBcIkJ5VmVydGV4XCIgP1xyXG4gICAgICAgICAgX2lWZXJ0ZXggOlxyXG4gICAgICAgICAgX2xheWVyRWxlbWVudC5NYXBwaW5nSW5mb3JtYXRpb25UeXBlID09IFwiQnlQb2x5Z29uXCIgP1xyXG4gICAgICAgICAgICBfaVBvbHlnb24gOlxyXG4gICAgICAgICAgICBfaVBvbHlnb25WZXJ0ZXg7XHJcblxyXG4gICAgICBpZiAoX2xheWVyRWxlbWVudC5SZWZlcmVuY2VJbmZvcm1hdGlvblR5cGUgPT09ICdJbmRleFRvRGlyZWN0Jykge1xyXG4gICAgICAgIGxldCBpbmRpY2VzOiBVaW50MTZBcnJheSA9IChfbGF5ZXJFbGVtZW50IGFzIEZCWC5MYXllckVsZW1lbnRVVikuVVZJbmRleCB8fCAoX2xheWVyRWxlbWVudCBhcyBGQlguTGF5ZXJFbGVtZW50Tm9ybWFsKS5Ob3JtYWxzSW5kZXg7XHJcbiAgICAgICAgaW5kZXggPSBpbmRpY2VzW2luZGV4XTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY3JlYXRlQm9uZXMoX2RlZm9ybWVyRkJYOiBGQlguRGVmb3JtZXIsIF9za2VsZXRvbjogQ29tcG9uZW50U2tlbGV0b24sIF92ZXJ0aWNlczogVmVydGljZXMsIF9uZXdWZXJ0ZXhJbmRpY2VzPzogbnVtYmVyW11bXSk6IHZvaWQge1xyXG4gICAgICBmb3IgKGNvbnN0IGZieFN1YkRlZm9ybWVyIG9mIF9kZWZvcm1lckZCWC5jaGlsZHJlbiBhcyBGQlguU3ViRGVmb3JtZXJbXSkge1xyXG4gICAgICAgIGZieFN1YkRlZm9ybWVyLmxvYWQoKTtcclxuICAgICAgICBpZiAoZmJ4U3ViRGVmb3JtZXIuSW5kZXhlcylcclxuICAgICAgICAgIGZvciAobGV0IGlCb25lSW5mbHVlbmNlOiBudW1iZXIgPSAwOyBpQm9uZUluZmx1ZW5jZSA8IGZieFN1YkRlZm9ybWVyLkluZGV4ZXMubGVuZ3RoOyBpQm9uZUluZmx1ZW5jZSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlWZXJ0ZXg6IG51bWJlciA9IGZieFN1YkRlZm9ybWVyLkluZGV4ZXNbaUJvbmVJbmZsdWVuY2VdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlWZXJ0ZXhOZXcgb2YgX25ld1ZlcnRleEluZGljZXMgPyBfbmV3VmVydGV4SW5kaWNlc1tpVmVydGV4XSA6IFtpVmVydGV4XSkge1xyXG4gICAgICAgICAgICAgIChfdmVydGljZXNbaVZlcnRleE5ld10uYm9uZXMgfHwgKF92ZXJ0aWNlc1tpVmVydGV4TmV3XS5ib25lcyA9IFtdKSkucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBpbmRleDogX3NrZWxldG9uLmluZGV4T2YoZmJ4U3ViRGVmb3JtZXIuY2hpbGRyZW5bMF0ubmFtZSksXHJcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IGZieFN1YkRlZm9ybWVyLldlaWdodHNbaUJvbmVJbmZsdWVuY2VdIHx8IDFcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqIEFsbG93cyB0byBjcmVhdGUgY3VzdG9tIG1lc2hlcyBmcm9tIGdpdmVuIERhdGEgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaEZyb21EYXRhIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwcm90ZWN0ZWQgdmVydGljZXNUb1NldDogRmxvYXQzMkFycmF5O1xyXG4gICAgcHJvdGVjdGVkIHRleHR1cmVVVnNUb1NldDogRmxvYXQzMkFycmF5O1xyXG4gICAgcHJvdGVjdGVkIGluZGljZXNUb1NldDogVWludDE2QXJyYXk7XHJcbiAgICBwcm90ZWN0ZWQgZmFjZU5vcm1hbHNUb1NldDogRmxvYXQzMkFycmF5O1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfdmVydGljZXM6IEZsb2F0MzJBcnJheSwgX3RleHR1cmVVVnM6IEZsb2F0MzJBcnJheSwgX2luZGljZXM6IFVpbnQxNkFycmF5LCBfZmFjZU5vcm1hbHM6IEZsb2F0MzJBcnJheSkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzLnZlcnRpY2VzVG9TZXQgPSBfdmVydGljZXM7XHJcbiAgICAgIHRoaXMudGV4dHVyZVVWc1RvU2V0ID0gX3RleHR1cmVVVnM7XHJcbiAgICAgIHRoaXMuaW5kaWNlc1RvU2V0ID0gX2luZGljZXM7XHJcbiAgICAgIHRoaXMuZmFjZU5vcm1hbHNUb1NldCA9IF9mYWNlTm9ybWFscztcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVmVydGljZXMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMudmVydGljZXNUb1NldDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVGV4dHVyZVVWcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy50ZXh0dXJlVVZzVG9TZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUluZGljZXMoKTogVWludDE2QXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbmRpY2VzVG9TZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUZsYXROb3JtYWxzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZhY2VOb3JtYWxzVG9TZXQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBBIHtAbGluayBNZXNofSBsb2FkZWQgZnJvbSBhIGdsVEYtRmlsZS5cclxuICAgKiBAYXV0aG9ycyBKb25hcyBQbG90emt5LCBIRlUsIDIwMjRcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaEdMVEYgZXh0ZW5kcyBtaXhpblNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWwoTWVzaCkge1xyXG4gICAgcHVibGljIGlQcmltaXRpdmU6IG51bWJlcjsgLy8gbW9zdCBsaWtlbHkgd2lsbCBub3Qgc3RheSBjb25zaXN0ZW50IHdpdGggdGhlIGdsVEYgZmlsZS4uLlxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkKF91cmw6IFJlcXVlc3RJbmZvID0gdGhpcy51cmwsIF9uYW1lOiBzdHJpbmcgPSB0aGlzLm5hbWUsIF9pUHJpbWl0aXZlOiBudW1iZXIgPSB0aGlzLmlQcmltaXRpdmUpOiBQcm9taXNlPE1lc2hHTFRGPiB7XHJcbiAgICAgIHRoaXMudXJsID0gX3VybDtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMuaVByaW1pdGl2ZSA9IF9pUHJpbWl0aXZlO1xyXG4gICAgICByZXR1cm4gR0xURkxvYWRlci5sb2FkUmVzb3VyY2UodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgY29uc3Qgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmlQcmltaXRpdmUgPSB0aGlzLmlQcmltaXRpdmU7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuaVByaW1pdGl2ZSA9IF9zZXJpYWxpemF0aW9uLmlQcmltaXRpdmU7XHJcbiAgICAgIHJldHVybiBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQSBtZXNoIGxvYWRlZCBmcm9tIGFuIE9CSi1maWxlLlxyXG4gICAqIFNpbXBsZSBXYXZlZnJvbnQgT0JKIGltcG9ydC4gVGFrZXMgYSB3YXZlZnJvbnQgb2JqIHN0cmluZy4gVG8gTG9hZCBmcm9tIGEgZmlsZSB1cmwsIHVzZSB0aGVcclxuICAgKiBzdGF0aWMgTE9BRCBNZXRob2QuIEN1cnJlbnRseSBvbmx5IHdvcmtzIHdpdGggdHJpYW5ndWxhdGVkIE1lc2hlc1xyXG4gICAqIChhY3RpdmF0ZSAnR2VvbWVudHJ5IOKGkiBUcmlhbmd1bGF0ZSBGYWNlcycgaW4gQmxlbmRlcnMgb2JqIGV4cG9ydGVyKVxyXG4gICAqIEB0b2RvIExvYWQgTWF0ZXJpYWxzLCBTdXBwb3J0IFF1YWRzXHJcbiAgICogQGF1dGhvcnMgU2ltb24gU3RvcmwtU2NodWxrZSAyMDIxIHwgTHVpcyBLZWNrLCBIRlUsIDIwMjEgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMS0yMDIyIHwgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjMgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaE9CSiBleHRlbmRzIG1peGluU2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbChNZXNoKSB7XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGxvYWQoX3VybDogUmVxdWVzdEluZm8gPSB0aGlzLnVybCk6IFByb21pc2U8TWVzaE9CSj4ge1xyXG4gICAgICBjb25zdCB1cmw6IHN0cmluZyA9IG5ldyBVUkwoX3VybC50b1N0cmluZygpLCBQcm9qZWN0LmJhc2VVUkwpLnRvU3RyaW5nKCk7XHJcbiAgICAgIGNvbnN0IGRhdGE6IHN0cmluZyA9IGF3YWl0IChhd2FpdCBmZXRjaCh1cmwpKS50ZXh0KCk7XHJcbiAgICAgIHRoaXMubmFtZSA9IHVybC5zcGxpdChcIi9cIikucG9wKCk7XHJcbiAgICAgIHRoaXMudXJsID0gX3VybDtcclxuXHJcbiAgICAgIGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IGRhdGEuc3BsaXQoXCJcXG5cIik7XHJcblxyXG4gICAgICBjb25zdCBpbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICBjb25zdCBwb3NpdGlvbnM6IFZlY3RvcjNbXSA9IFtdO1xyXG4gICAgICBjb25zdCB1dnM6IFZlY3RvcjJbXSA9IFtdO1xyXG4gICAgICBjb25zdCBub3JtYWxzOiBWZWN0b3IzW10gPSBbXTtcclxuICAgICAgY29uc3Qgbm9ybXM6IG51bWJlcltdID0gW107XHJcblxyXG4gICAgICBjb25zdCB2ZXJ0aWNlczogVmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgY29uc3QgZmFjZXM6IEZhY2VbXSA9IFtdO1xyXG4gICAgICBjb25zdCBtYXBQb3NpdGlvblVWTm9ybWFsVG9JbmRleDogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xyXG4gICAgICBjb25zdCBtYXBQb3NpdGlvbk5vcm1hbFRvSW5kZXg6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7fTtcclxuXHJcbiAgICAgIC8vIFRPRE86IHRoaW5rIGFib3V0IGNyZWF0aW5nIHRoZSBuZWVkZWQgYnVmZmVycyBmb3IgcmVuZGVybWVzaCBoZXJlIGFscmVhZHkuLi5cclxuICAgICAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xyXG4gICAgICAgIGNvbnN0IHBhcnRzOiBzdHJpbmdbXSA9IGxpbmUudHJpbSgpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICBzd2l0Y2ggKHBhcnRzLnNoaWZ0KCkpIHtcclxuICAgICAgICAgIGNhc2UgXCJ2XCI6IC8vVmVydGV4IC0gZXhhbXBsZTogdiAwLjcwIC0wLjQ1IC0wLjUyICAgICAgICAgXHJcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKG5ldyBWZWN0b3IzKC4uLnBhcnRzLm1hcChfdmFsdWUgPT4gK192YWx1ZSkpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwidm5cIjogLy9Ob3JtYWwgLSBleGFtcGxlOiB2biAwLjAwIDAuMDAgMS4wMFxyXG4gICAgICAgICAgICBub3JtYWxzLnB1c2gobmV3IFZlY3RvcjMoLi4ucGFydHMubWFwKF92YWx1ZSA9PiArX3ZhbHVlKSkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgXCJ2dFwiOiAvL1RleGNvb3JkIC0gZXhhbXBsZTogdnQgMC41NDU0NTQgMC40NzIzODJcclxuICAgICAgICAgICAgdXZzLnB1c2gobmV3IFZlY3RvcjIoLi4ucGFydHMubWFwKChfdmFsdWUsIF9pbmRleCkgPT4gK192YWx1ZSAqIChfaW5kZXggPT0gMSA/IC0xIDogMSkpKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcImZcIjogLypGYWNlIEluZGljZXMgLSBleGFtcGxlOiBmIDEvMS8xIDIvMi8xIDMvMy8xIC0tPiB2ZXJ0ZXgxL3RleGNvb3JkMS9ub3JtYWwxIHZlcnRleDIvdGV4Y29vcmQyL25vcm1hbDIgdmVydGV4My90ZXhjb29yZDMvbm9ybWFsMyovXHJcbiAgICAgICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCAzOyBpKyspIHtcclxuICAgICAgICAgICAgICBsZXQga2V5OiBzdHJpbmcgPSBwYXJ0c1tpXTtcclxuICAgICAgICAgICAgICBsZXQgaW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZCA9IG1hcFBvc2l0aW9uVVZOb3JtYWxUb0luZGV4W2tleV07XHJcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gdmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmVydGV4SW5mbzogc3RyaW5nW10gPSBwYXJ0c1tpXS5zcGxpdChcIi9cIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb246IFZlY3RvcjMgPSBwb3NpdGlvbnNbK3ZlcnRleEluZm9bMF0gLSAxXTsgLy8gb2JqIHVzZXMgMS1iYXNlZCBpbmRpY2VzXHJcbiAgICAgICAgICAgICAgICBsZXQgdXY6IFZlY3RvcjIgPSB1dnNbK3ZlcnRleEluZm9bMV0gLSAxXSA/PyB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgbm9ybWFsOiBWZWN0b3IzID0gbm9ybWFsc1srdmVydGV4SW5mb1syXSAtIDFdID8/IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsKVxyXG4gICAgICAgICAgICAgICAgICBub3Jtcy5wdXNoKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBrZXlQb3NOb3JtOiBzdHJpbmcgPSBgJHt2ZXJ0ZXhJbmZvWzBdfS8ke3ZlcnRleEluZm9bMl19YDtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlcnRleChtYXBQb3NpdGlvbk5vcm1hbFRvSW5kZXhba2V5UG9zTm9ybV0gPz8gcG9zaXRpb24sIHV2LCBub3JtYWwpKTtcclxuICAgICAgICAgICAgICAgIG1hcFBvc2l0aW9uVVZOb3JtYWxUb0luZGV4W2tleV0gPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChtYXBQb3NpdGlvbk5vcm1hbFRvSW5kZXhba2V5UG9zTm9ybV0gPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICBtYXBQb3NpdGlvbk5vcm1hbFRvSW5kZXhba2V5UG9zTm9ybV0gPSBpbmRleDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGZhY2VzLnB1c2gobmV3IEZhY2UodmVydGljZXMsIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAyXSwgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdLCBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gM10pKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoX2U6IHVua25vd24pIHtcclxuICAgICAgICAgICAgICBEZWJ1Zy5mdWRnZShcIkZhY2UgZXhjbHVkZWRcIiwgKDxFcnJvcj5fZSkubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlcztcclxuICAgICAgdGhpcy5mYWNlcyA9IGZhY2VzO1xyXG4gICAgICBpZiAobm9ybXMubGVuZ3RoID4gMCkgLy8gVE9ETzogcmVuZGVybWVzaCBzaG91bGQgYmUgYWJsZSB0byBoYW5kbGUgdW5kZWZpbmVkIG5vcm1hbHMgY29ycmVjdGx5LCBpLmUuIGNhbGN1bGF0ZSB0aGVtIG9ubHkgaWYgdGhleSBhcmUgbm90IHByZXNlbnQgaW4gdGhlIHZlcnRpY2VzXHJcbiAgICAgICAgdGhpcy5yZW5kZXJNZXNoLm5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KG5vcm1zKTtcclxuICAgICAgLy8gX21lc2gucmVuZGVyTWVzaC5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KGluZGljZXMpOyAvLyBkb2Vucyd0IHNlZW0gdG8gYWZmZWN0IHNjZW5lIGxvYWRpbmcgdGltZS4uLlxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSBzaW1wbGUgcHlyYW1pZCB3aXRoIGVkZ2VzIGF0IHRoZSBiYXNlIG9mIGxlbmd0aCAxIGFuZCBhIGhlaWdodCBvZiAxLiBUaGUgc2lkZXMgY29uc2lzdGluZyBvZiBvbmUsIHRoZSBiYXNlIG9mIHR3byB0cmlnb25zXHJcbiAgICogYGBgdGV4dFxyXG4gICAqICAgICAgICAgICAgICAgNFxyXG4gICAqICAgICAgICAgICAgICAvXFxgLlxyXG4gICAqICAgICAgICAgICAgMy9fX1xcX1xcIDJcclxuICAgKiAgICAgICAgICAgMC9fX19fXFwvMVxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hQeXJhbWlkIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hQeXJhbWlkKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFB5cmFtaWRcIikge1xyXG4gICAgICBzdXBlcihfbmFtZSk7XHJcbiAgICAgIC8vIHRoaXMuY3JlYXRlKCk7XHJcblxyXG4gICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKFxyXG4gICAgICAgIC8vIGdyb3VuZCB2ZXJ0aWNlc1xyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoLTAuNSwgMC4wLCAwLjUpLCBuZXcgVmVjdG9yMigwLCAxKSksXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjUsIDAuMCwgMC41KSwgbmV3IFZlY3RvcjIoMSwgMSkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgobmV3IFZlY3RvcjMoMC41LCAwLjAsIC0wLjUpLCBuZXcgVmVjdG9yMigxLCAwKSksXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygtMC41LCAwLjAsIC0wLjUpLCBuZXcgVmVjdG9yMigwLCAwKSksXHJcbiAgICAgICAgLy8gdGlwICh2ZXJ0ZXggIzQpXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjAsIDEuMCwgMC4wKSwgbmV3IFZlY3RvcjIoMC41LCAwLjUpKSxcclxuICAgICAgICAvLyBmbG9vciBhZ2FpbiBmb3IgZG93bnNpZGUgdGV4dHVyZVxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMCwgbmV3IFZlY3RvcjIoMCwgMCkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMSwgbmV3IFZlY3RvcjIoMSwgMCkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMiwgbmV3IFZlY3RvcjIoMSwgMSkpLFxyXG4gICAgICAgIG5ldyBWZXJ0ZXgoMywgbmV3IFZlY3RvcjIoMCwgMSkpXHJcbiAgICAgICk7XHJcbiAgICAgIHRoaXMuZmFjZXMgPSBbXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgNCwgMCwgMSksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgNCwgMSwgMiksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgNCwgMiwgMyksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgNCwgMywgMCksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgNSArIDAsIDUgKyAyLCA1ICsgMSksXHJcbiAgICAgICAgbmV3IEZhY2UodGhpcy52ZXJ0aWNlcywgNSArIDAsIDUgKyAzLCA1ICsgMilcclxuICAgICAgXTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIHNpbXBsZSBxdWFkIHdpdGggZWRnZXMgb2YgbGVuZ3RoIDEsIHRoZSBmYWNlIGNvbnNpc3Rpbmcgb2YgdHdvIHRyaWdvbnNcclxuICAgKiBgYGB0ZXh0XHJcbiAgICogICAgICAgIDAgX18gM1xyXG4gICAqICAgICAgICAgfF9cXHxcclxuICAgKiAgICAgICAgMSAgICAyICAgICAgICAgICAgIFxyXG4gICAqIGBgYCBcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOS0yMDIyXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE1lc2hRdWFkIGV4dGVuZHMgTWVzaFBvbHlnb24ge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoUXVhZCk7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHNoYXBlOiBWZWN0b3IyW10gPSBbXHJcbiAgICAgIG5ldyBWZWN0b3IyKC0wLjUsIDAuNSksIG5ldyBWZWN0b3IyKC0wLjUsIC0wLjUpLCBuZXcgVmVjdG9yMigwLjUsIC0wLjUpLCBuZXcgVmVjdG9yMigwLjUsIDAuNSlcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hRdWFkXCIpIHtcclxuICAgICAgc3VwZXIoX25hbWUsIE1lc2hRdWFkLnNoYXBlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAvLyBmbGF0IGVxdWFscyBzbW9vdGhcclxuICAgIC8vIHB1YmxpYyBnZXQgdmVydGljZXNGbGF0KCk6IEZsb2F0MzJBcnJheSB7IHJldHVybiB0aGlzLnZlcnRpY2VzOyB9XHJcbiAgICAvLyBwdWJsaWMgZ2V0IGluZGljZXNGbGF0KCk6IFVpbnQxNkFycmF5IHsgcmV0dXJuIHRoaXMuaW5kaWNlczsgfVxyXG4gICAgLy8gcHVibGljIGdldCBub3JtYWxzRmxhdCgpOiBGbG9hdDMyQXJyYXkgeyByZXR1cm4gdGhpcy5ub3JtYWxzVmVydGV4OyB9XHJcblxyXG4gICAgLy8jcmVnaW9uIFRyYW5zZ2VyXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuZ2V0TXV0YXRvcigpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgdGhpcy5jcmVhdGUoTWVzaFF1YWQuc2hhcGUsIHRydWUpOyAvLyB0aGlzIHNlZW1zIHRvIGJlIGRpc3BhdGNoZWQgZG91YmxlZCB3aGlsZSBkZXNlcmlhbGl6aW5nIHRoZSByZXNvdXJjZXNcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgcmVkdWNlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBzdXBlci5yZWR1Y2VNdXRhdG9yKF9tdXRhdG9yKTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNoYXBlO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuZml0VGV4dHVyZTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqIFxyXG4gICAqIFRoaXMgZnVuY3Rpb24gdHlwZSB0YWtlcyB4IGFuZCB6IGFzIFBhcmFtZXRlcnMgYW5kIHJldHVybnMgYSBudW1iZXIgYmV0d2VlbiAtMSBhbmQgMSB0byBiZSB1c2VkIGFzIGEgaGVpZ2h0bWFwLiBcclxuICAgKiB4ICogeiAqIDIgcmVwcmVzZW50IHRoZSBhbW91dCBvZiBmYWNlcyB3aGljaCBhcmUgY3JlYXRlZC4gQXMgYSByZXN1bHQgeW91IGdldCAxIHZlcnRleCBtb3JlIGluIGVhY2ggZGlyZWN0aW9uICh4IGFuZCB6IGF4aXMpXHJcbiAgICogVGhlIHktY29tcG9uZW50IG9mIHRoZSByZXN1bHRpbmcgbWVzaCBtYXkgYmUgbW92ZWQgdG8gdmFsdWVzIGJldHdlZW4gMCBhbmQgYSBtYXhpbXVtIGhlaWdodC5cclxuICAgKiBAYXV0aG9ycyBTaW1vbiBTdG9ybC1TY2h1bGtlLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMS0yMDIyXHJcbiAgICovXHJcbiAgZXhwb3J0IHR5cGUgSGVpZ2h0TWFwRnVuY3Rpb24gPSAoeDogbnVtYmVyLCB6OiBudW1iZXIpID0+IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIHZlcnRpY2FsIHByb2plY3Rpb24gb2YgYSBnaXZlbiBwb3NpdGlvbiBvbnRvIHRoZSB0ZXJyYWluXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFRlcnJhaW5JbmZvIHtcclxuICAgIC8qKiB0aGUgcG9zaXRpb24gb2YgdGhlIHBvaW50IHZlcnRpY2FsbHkgcHJvamVjdGVkIG9uIHRoZSB0ZXJyYWluIGluIHdvcmxkIGNvb3JkaW5hdGVzICovXHJcbiAgICBwdWJsaWMgcG9zaXRpb246IFZlY3RvcjM7XHJcbiAgICAvKiogdGhlIG5vcm1hbCBvZiB0aGUgZmFjZSBvZiB0aGUgdGVycmFpbiB1bmRlciB0aGUgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMgKi9cclxuICAgIHB1YmxpYyBub3JtYWw6IFZlY3RvcjM7XHJcbiAgICAvKiogdmVydGljYWwgZGlzdGFuY2Ugb2YgdGhlIHBvaW50IHRvIHRoZSB0ZXJyYWluLCBuZWdhdGl2ZSBpZiBiZWxvdyAqL1xyXG4gICAgcHVibGljIGRpc3RhbmNlOiBudW1iZXI7XHJcbiAgICAvKiogdGhlIHBvc2l0aW9uIGluIGZhY2UgY29vcmRpbmF0ZXMgKi9cclxuICAgIHB1YmxpYyBwb3NpdGlvbkZhY2U6IFZlY3RvcjM7XHJcbiAgICAvKiogdGhlIGluZGV4IG9mIHRoZSBmYWNlIHRoZSBwb3NpdGlvbiBpcyBpbnNpZGUgKi9cclxuICAgIHB1YmxpYyBpbmRleDogbnVtYmVyO1xyXG4gICAgLyoqIHRoZSBncmlkIGNvb3JkaW5hdGVzIG9mIHRoZSBxdWFkIHRoZSBmYWNlIGJlbG9uZ3MgdG8gKi9cclxuICAgIHB1YmxpYyBncmlkOiBWZWN0b3IyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSB0ZXJyYWluIHNwcmVhZHMgb3V0IGluIHRoZSB4LXotcGxhbmUsIHkgaXMgdGhlIGhlaWdodCBkZXJpdmVkIGZyb20gdGhlIGhlaWdodG1hcCBmdW5jdGlvbi4gXHJcbiAgICogVGhlIHRlcnJhaW4gaXMgYWx3YXlzIDEgaW4gc2l6ZSBpbiBhbGwgZGltZW5zaW9ucywgZml0dGluZyBpbnRvIHRoZSB1bml0LWN1YmUuIFxyXG4gICAqIFJlc29sdXRpb24gZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIHF1YWRzIGluIHggYW5kIHogZGltZW5zaW9uLCBzY2FsZSB0aGUgZmFjdG9yIGFwcGxpZWQgdG8gdGhlIHgsei1jb29yZGluYXRlcyBwYXNzZWQgdG8gdGhlIGhlaWdodG1hcCBmdW5jdGlvbi5cclxuICAgKiBTdGFuZGFyZCBmdW5jdGlvbiBpcyB0aGUgc2ltcGxleCBub2lzZSBpbXBsZW1lbnRlZCB3aXRoIEZVREdFLCBidXQgYW5vdGhlciBmdW5jdGlvbiBjYW4gYmUgZ2l2ZW4uXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEtMjAyMiB8IFNpbW9uIFN0b3JsLVNjaHVsa2UsIEhGVSwgMjAyMCB8IE1vcml0eiBCZWF1Z3JhbmQsIEhGVSwgMjAyMVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoVGVycmFpbiBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoVGVycmFpbik7XHJcbiAgICBwcm90ZWN0ZWQgcmVzb2x1dGlvbjogVmVjdG9yMjtcclxuICAgIHByb3RlY3RlZCBzY2FsZTogVmVjdG9yMjtcclxuICAgIHByb3RlY3RlZCBzZWVkOiBudW1iZXI7XHJcbiAgICBwcm90ZWN0ZWQgaGVpZ2h0TWFwRnVuY3Rpb246IEhlaWdodE1hcEZ1bmN0aW9uID0gbnVsbDtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFRlcnJhaW5cIiwgX3Jlc29sdXRpb246IFZlY3RvcjIgPSBWZWN0b3IyLk9ORSgyKSwgX3NjYWxlSW5wdXQ6IFZlY3RvcjIgPSBWZWN0b3IyLk9ORSgpLCBfZnVuY3Rpb25PclNlZWQ6IEhlaWdodE1hcEZ1bmN0aW9uIHwgbnVtYmVyID0gMCkge1xyXG4gICAgICBzdXBlcihfbmFtZSk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKF9yZXNvbHV0aW9uLCBfc2NhbGVJbnB1dCwgX2Z1bmN0aW9uT3JTZWVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0aGlzIG1lc2ggZnJvbSB0aGUgZ2l2ZW4gcGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlKF9yZXNvbHV0aW9uOiBWZWN0b3IyID0gVmVjdG9yMi5PTkUoMiksIF9zY2FsZUlucHV0OiBWZWN0b3IyID0gVmVjdG9yMi5PTkUoKSwgX2Z1bmN0aW9uT3JTZWVkOiBIZWlnaHRNYXBGdW5jdGlvbiB8IG51bWJlciA9IDApOiB2b2lkIHtcclxuICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICB0aGlzLnNlZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMucmVzb2x1dGlvbiA9IG5ldyBWZWN0b3IyKE1hdGgucm91bmQoX3Jlc29sdXRpb24ueCksIE1hdGgucm91bmQoX3Jlc29sdXRpb24ueSkpO1xyXG4gICAgICB0aGlzLnNjYWxlID0gX3NjYWxlSW5wdXQuY2xvbmU7XHJcblxyXG4gICAgICBpZiAoX2Z1bmN0aW9uT3JTZWVkIGluc3RhbmNlb2YgRnVuY3Rpb24pXHJcbiAgICAgICAgdGhpcy5oZWlnaHRNYXBGdW5jdGlvbiA9IF9mdW5jdGlvbk9yU2VlZDtcclxuICAgICAgZWxzZSBpZiAodHlwZW9mIChfZnVuY3Rpb25PclNlZWQpID09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICB0aGlzLnNlZWQgPSBfZnVuY3Rpb25PclNlZWQ7XHJcbiAgICAgICAgbGV0IHBybmc6IFJhbmRvbSA9IG5ldyBSYW5kb20odGhpcy5zZWVkKTtcclxuICAgICAgICB0aGlzLmhlaWdodE1hcEZ1bmN0aW9uID0gbmV3IE5vaXNlMigoKSA9PiBwcm5nLmdldE5vcm0oKSkuc2FtcGxlOyAvLyBUT0RPIGNhbGwgUFJOR1xyXG4gICAgICB9IGVsc2VcclxuICAgICAgICB0aGlzLmhlaWdodE1hcEZ1bmN0aW9uID0gbmV3IE5vaXNlMigpLnNhbXBsZTtcclxuXHJcbiAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgLy9JdGVyYXRlIG92ZXIgZWFjaCBjZWxsIHRvIGdlbmVyYXRlIGdyaWQgb2YgdmVydGljZXNcclxuICAgICAgZm9yIChsZXQgejogbnVtYmVyID0gMDsgeiA8PSB0aGlzLnJlc29sdXRpb24ueTsgeisrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeDogbnVtYmVyID0gMDsgeCA8PSB0aGlzLnJlc29sdXRpb24ueDsgeCsrKSB7XHJcbiAgICAgICAgICBsZXQgeE5vcm06IG51bWJlciA9IHggLyB0aGlzLnJlc29sdXRpb24ueDtcclxuICAgICAgICAgIGxldCB6Tm9ybTogbnVtYmVyID0geiAvIHRoaXMucmVzb2x1dGlvbi55O1xyXG4gICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBWZXJ0ZXgoXHJcbiAgICAgICAgICAgIG5ldyBWZWN0b3IzKHhOb3JtIC0gMC41LCB0aGlzLmhlaWdodE1hcEZ1bmN0aW9uKHhOb3JtICogdGhpcy5zY2FsZS54LCB6Tm9ybSAqIHRoaXMuc2NhbGUueSksIHpOb3JtIC0gMC41KSxcclxuICAgICAgICAgICAgbmV3IFZlY3RvcjIoeE5vcm0sIHpOb3JtKVxyXG4gICAgICAgICAgKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgcXVhZHM6IFF1YWRbXSA9IFtdO1xyXG4gICAgICBsZXQgc3BsaXQ6IFFVQURTUExJVCA9IFFVQURTUExJVC5BVF8wO1xyXG4gICAgICBmb3IgKGxldCB6OiBudW1iZXIgPSAwOyB6IDwgdGhpcy5yZXNvbHV0aW9uLnk7IHorKykge1xyXG4gICAgICAgIGZvciAobGV0IHg6IG51bWJlciA9IDA7IHggPCB0aGlzLnJlc29sdXRpb24ueDsgeCsrKSB7XHJcbiAgICAgICAgICBxdWFkcy5wdXNoKG5ldyBRdWFkKFxyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLFxyXG4gICAgICAgICAgICAoeCArIDApICsgKHogKyAwKSAqICh0aGlzLnJlc29sdXRpb24ueCArIDEpLFxyXG4gICAgICAgICAgICAoeCArIDApICsgKHogKyAxKSAqICh0aGlzLnJlc29sdXRpb24ueCArIDEpLFxyXG4gICAgICAgICAgICAoeCArIDEpICsgKHogKyAxKSAqICh0aGlzLnJlc29sdXRpb24ueCArIDEpLFxyXG4gICAgICAgICAgICAoeCArIDEpICsgKHogKyAwKSAqICh0aGlzLnJlc29sdXRpb24ueCArIDEpLFxyXG4gICAgICAgICAgICBzcGxpdFxyXG4gICAgICAgICAgKSk7XHJcbiAgICAgICAgICBzcGxpdCA9IChzcGxpdCA9PSBRVUFEU1BMSVQuQVRfMCkgPyBRVUFEU1BMSVQuQVRfMSA6IFFVQURTUExJVC5BVF8wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yZXNvbHV0aW9uLnggJSAyID09IDApIC8vIHJldmVyc2UgbGFzdCBzcGxpdCBjaGFuZ2UgaWYgeC1yZXNvbHV0aW9uIGlzIGV2ZW5cclxuICAgICAgICAgIHNwbGl0ID0gKHNwbGl0ID09IFFVQURTUExJVC5BVF8wKSA/IFFVQURTUExJVC5BVF8xIDogUVVBRFNQTElULkFUXzA7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5mYWNlcyA9IHF1YWRzLmZsYXRNYXAoKF9xdWFkOiBRdWFkKSA9PiBfcXVhZC5mYWNlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2ZXJ0aWNhbCBwcm9qZWN0aW9uIG9mIHRoZSBnaXZlbiBwb3NpdGlvbiBvbnRvIHRoZSB0ZXJyYWluLlxyXG4gICAgICogUGFzcyB0aGUgb3ZlcmFsbCB3b3JsZCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgdGVycmFpbiBpZiB0aGUgcG9zaXRpb24gaXMgZ2l2ZW4gaW4gd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBJZiBhdCBoYW5kLCBwYXNzIHRoZSBpbnZlcnNlIHRvbyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjYWxjdWxhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFRlcnJhaW5JbmZvKF9wb3NpdGlvbjogVmVjdG9yMywgX210eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKSwgX210eEludmVyc2U/OiBNYXRyaXg0eDQpOiBUZXJyYWluSW5mbyB7XHJcbiAgICAgIGlmICghX210eEludmVyc2UpXHJcbiAgICAgICAgX210eEludmVyc2UgPSBNYXRyaXg0eDQuSU5WRVJTRShfbXR4V29ybGQpO1xyXG5cclxuICAgICAgbGV0IHRlcnJhaW5JbmZvOiBUZXJyYWluSW5mbyA9IG5ldyBUZXJyYWluSW5mbztcclxuXHJcbiAgICAgIGxldCBwb3NMb2NhbDogVmVjdG9yMyA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oX3Bvc2l0aW9uLCBfbXR4SW52ZXJzZSwgdHJ1ZSk7XHJcblxyXG5cclxuICAgICAgbGV0IHo6IG51bWJlciA9IE1hdGguZmxvb3IoKHBvc0xvY2FsLnogKyAwLjUpICogdGhpcy5yZXNvbHV0aW9uLnkpO1xyXG4gICAgICBsZXQgeDogbnVtYmVyID0gTWF0aC5mbG9vcigocG9zTG9jYWwueCArIDAuNSkgKiB0aGlzLnJlc29sdXRpb24ueCk7XHJcbiAgICAgIGlmICh6IDwgMCB8fCB6ID4gdGhpcy5yZXNvbHV0aW9uLnkgLSAxIHx8IHggPCAwIHx8IHggPiB0aGlzLnJlc29sdXRpb24ueCAtIDEpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICBsZXQgaW5kZXg6IG51bWJlciA9ICh6ICogdGhpcy5yZXNvbHV0aW9uLnggKyB4KSAqIDI7XHJcbiAgICAgIGxldCBmYWNlOiBGYWNlID0gdGhpcy5mYWNlc1tpbmRleF07XHJcblxyXG4gICAgICBsZXQgcmF5OiBSYXkgPSBuZXcgUmF5KFZlY3RvcjMuWSgpLCBwb3NMb2NhbCk7XHJcbiAgICAgIGxldCBwb2ludDogVmVjdG9yMyA9IHJheS5pbnRlcnNlY3RGYWNlUGxhbmUoZmFjZSk7XHJcbiAgICAgIGlmICghZmFjZS5pc0luc2lkZShwb2ludCkpIHtcclxuICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgIGZhY2UgPSB0aGlzLmZhY2VzW2luZGV4XTtcclxuICAgICAgICBwb2ludCA9IHJheS5pbnRlcnNlY3RGYWNlUGxhbmUoZmFjZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRlcnJhaW5JbmZvLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgIHRlcnJhaW5JbmZvLnBvc2l0aW9uRmFjZSA9IHBvaW50O1xyXG4gICAgICB0ZXJyYWluSW5mby5wb3NpdGlvbiA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04ocG9pbnQsIF9tdHhXb3JsZCwgdHJ1ZSk7XHJcbiAgICAgIHRlcnJhaW5JbmZvLm5vcm1hbCA9IFZlY3RvcjMuVFJBTlNGT1JNQVRJT04oZmFjZS5ub3JtYWwsIE1hdHJpeDR4NC5UUkFOU1BPU0UoX210eEludmVyc2UpLCBmYWxzZSk7XHJcbiAgICAgIHRlcnJhaW5JbmZvLmRpc3RhbmNlID0gX3Bvc2l0aW9uLnkgLSB0ZXJyYWluSW5mby5wb3NpdGlvbi55O1xyXG4gICAgICB0ZXJyYWluSW5mby5ncmlkID0gdGhpcy5nZXRHcmlkRnJvbUZhY2VJbmRleChpbmRleCk7XHJcbiAgICAgIHJldHVybiB0ZXJyYWluSW5mbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGdyaWQgY29vcmRpbmF0ZXMgb2YgdGhlIHF1YWQgdGhlIGdpdmVuIGZhY2UgYmVsb25ncyB0by5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEdyaWRGcm9tRmFjZUluZGV4KF9pbmRleDogbnVtYmVyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMik7XHJcbiAgICAgIGxldCBpUXVhZDogbnVtYmVyID0gTWF0aC5mbG9vcihfaW5kZXggLyAyKTtcclxuICAgICAgcmVzdWx0LnNldChpUXVhZCAlIHRoaXMucmVzb2x1dGlvbi55LCBNYXRoLmZsb29yKGlRdWFkIC8gdGhpcy5yZXNvbHV0aW9uLngpKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGluZGljZXMgb2YgdGhlIHR3byBmYWNlcyBmb3JtaW5nIHRoZSBxdWFkIHRoZSBnaXZlbiBncmlkIHBvc2l0aW9uIGJlbG9uZ3MgdG8uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRGYWNlSW5kaWNlc0Zyb21HcmlkKF9ncmlkOiBWZWN0b3IyKTogbnVtYmVyW10ge1xyXG4gICAgICBsZXQgaVF1YWQ6IG51bWJlciA9IF9ncmlkLnkgKiAyICogdGhpcy5yZXNvbHV0aW9uLnggKyBfZ3JpZC54ICogMjtcclxuICAgICAgcmV0dXJuIFtpUXVhZCwgaVF1YWQgKyAxXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc2VlZCA9IHRoaXMuc2VlZDtcclxuICAgICAgc2VyaWFsaXphdGlvbi5zY2FsZSA9IHRoaXMuc2NhbGUuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24ucmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbi5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIGF3YWl0IHRoaXMucmVzb2x1dGlvbi5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5yZXNvbHV0aW9uKTtcclxuICAgICAgYXdhaXQgdGhpcy5zY2FsZS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5zY2FsZSk7XHJcbiAgICAgIHRoaXMuc2VlZCA9IF9zZXJpYWxpemF0aW9uLnNlZWQ7XHJcbiAgICAgIHRoaXMuY3JlYXRlKHRoaXMucmVzb2x1dGlvbiwgdGhpcy5zY2FsZSwgdGhpcy5zZWVkKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgICAgdGhpcy5jcmVhdGUodGhpcy5yZXNvbHV0aW9uLCB0aGlzLnNjYWxlLCB0aGlzLnNlZWQpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwiLy8vPHJlZmVyZW5jZSBwYXRoPVwiTWVzaFRlcnJhaW4udHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIHBsYW5hciBHcmlkIGFuZCBhcHBsaWVzIGEgSGVpZ2h0bWFwLUZ1bmN0aW9uIHRvIGl0LlxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxIHwgTW9yaXR6IEJlYXVncmFuZCwgSEZVLCAyMDIwXHJcbiAgICovXHJcbiAgQGVudW1lcmF0ZVxyXG4gIGV4cG9ydCBjbGFzcyBNZXNoUmVsaWVmIGV4dGVuZHMgTWVzaFRlcnJhaW4ge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoUmVsaWVmKTtcclxuXHJcbiAgICAjdGV4dHVyZTogVGV4dHVyZUltYWdlO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoUmVsaWVmXCIsIF90ZXh0dXJlPzogVGV4dHVyZUltYWdlKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lLCBWZWN0b3IyLk9ORSgyKSwgdW5kZWZpbmVkLCAoX3g6IG51bWJlciwgX3o6IG51bWJlcikgPT4gMCk7XHJcbiAgICAgIHRoaXMudGV4dHVyZSA9IF90ZXh0dXJlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZUhlaWdodE1hcEZ1bmN0aW9uKF90ZXh0dXJlOiBUZXh0dXJlSW1hZ2UpOiBIZWlnaHRNYXBGdW5jdGlvbiB7XHJcbiAgICAgIGxldCBhcnJheTogVWludDhDbGFtcGVkQXJyYXkgPSBNZXNoUmVsaWVmLnRleHR1cmVUb0NsYW1wZWRBcnJheShfdGV4dHVyZSk7XHJcbiAgICAgIGxldCBoZWlnaHRNYXBGdW5jdGlvbjogSGVpZ2h0TWFwRnVuY3Rpb24gPSAoX3g6IG51bWJlciwgX3o6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGxldCBwaXhlbDogbnVtYmVyID0gTWF0aC5yb3VuZChfeiAqIF90ZXh0dXJlLmltYWdlLndpZHRoICsgX3gpO1xyXG4gICAgICAgIHJldHVybiBhcnJheVtwaXhlbCAqIDRdIC8gMjU1O1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gaGVpZ2h0TWFwRnVuY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgdGV4dHVyZVRvQ2xhbXBlZEFycmF5KF90ZXh0dXJlOiBUZXh0dXJlSW1hZ2UpOiBVaW50OENsYW1wZWRBcnJheSB7XHJcbiAgICAgIGxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgY2FudmFzLndpZHRoID0gX3RleHR1cmUuaW1hZ2Uud2lkdGg7XHJcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBfdGV4dHVyZS5pbWFnZS5oZWlnaHQ7XHJcblxyXG4gICAgICBsZXQgY3JjOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICBjcmMuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgIGNyYy5kcmF3SW1hZ2UoX3RleHR1cmUuaW1hZ2UsIDAsIDApO1xyXG5cclxuICAgICAgcmV0dXJuIGNyYy5nZXRJbWFnZURhdGEoMCwgMCwgX3RleHR1cmUuaW1hZ2Uud2lkdGgsIF90ZXh0dXJlLmltYWdlLmhlaWdodCkuZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBUaGUgdGV4dHVyZSB0byBiZSB1c2VkIGFzIHRoZSBoZWlnaHRtYXAuXHJcbiAgICAgKiAqKkNhdXRpb24hKiogU2V0dGluZyB0aGlzIGNhdXNlcyB0aGUgbWVzaCB0byBiZSByZWNyZWF0ZWQgd2hpY2ggY2FuIGJlIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIEBlbnVtZXJhdGVcclxuICAgIEB0eXBlKFRleHR1cmVJbWFnZSlcclxuICAgIHB1YmxpYyBnZXQgdGV4dHVyZSgpOiBUZXh0dXJlSW1hZ2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy4jdGV4dHVyZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgdGV4dHVyZShfdGV4dHVyZTogVGV4dHVyZUltYWdlKSB7XHJcbiAgICAgIHRoaXMuI3RleHR1cmUgPSBfdGV4dHVyZTtcclxuICAgICAgaWYgKCFfdGV4dHVyZSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGxldCByZXNvbHV0aW9uOiBWZWN0b3IyID0gX3RleHR1cmUgPyBuZXcgVmVjdG9yMihfdGV4dHVyZS5pbWFnZS53aWR0aCAtIDEsIF90ZXh0dXJlLmltYWdlLmhlaWdodCAtIDEpIDogdW5kZWZpbmVkO1xyXG4gICAgICBzdXBlci5jcmVhdGUocmVzb2x1dGlvbiwgcmVzb2x1dGlvbiwgTWVzaFJlbGllZi5jcmVhdGVIZWlnaHRNYXBGdW5jdGlvbihfdGV4dHVyZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb24uc2VlZDtcclxuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb24uc2NhbGU7XHJcbiAgICAgIGRlbGV0ZSBzZXJpYWxpemF0aW9uLnJlc29sdXRpb247XHJcblxyXG4gICAgICBpZiAodGhpcy4jdGV4dHVyZSlcclxuICAgICAgICBzZXJpYWxpemF0aW9uLmlkVGV4dHVyZSA9IHRoaXMudGV4dHVyZS5pZFJlc291cmNlO1xyXG5cclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbik7XHJcbiAgICAgIGlmIChfc2VyaWFsaXphdGlvbi5pZFRleHR1cmUpIFxyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IDxUZXh0dXJlSW1hZ2U+YXdhaXQgUHJvamVjdC5nZXRSZXNvdXJjZShfc2VyaWFsaXphdGlvbi5pZFRleHR1cmUpO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zZWVkO1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iuc2NhbGU7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5yZXNvbHV0aW9uO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59IiwiLy8gLzxyZWZlcmVuY2UgcGF0aD1cIk1lc2hQb2x5Z29uLnRzXCIvPlxyXG5uYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZXMgYSByb3RhdGlvbiBvZiBhIHBvbHlnb24gYXJvdW5kIHRoZSB5LWF4aXNcclxuICAgKiBgYGB0ZXh0ICAgICAgIFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgeVxyXG4gICAqICAgICAgICAgICAgICAgICAgXyAg4oaRIDBfMVxyXG4gICAqICAgICAgICAgICAgICAgICDilIIgICDilILihpJ4IOKUgjIgICAgICAgICBcclxuICAgKiAgICAgICAgICAgICAgICAgIOKVsiAg4pSCICDilbEzICAgICAgICAgXHJcbiAgICogICAgICAgICAgICAgICAgICDilbEgIOKUgiAg4pWyICAgXHJcbiAgICogICAgICAgICAgICAgICAgIOKVsV9fX+KUgl9fX+KVsjQgXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgNVxyXG4gICAqIGBgYFxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxLTIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaFJvdGF0aW9uIGV4dGVuZHMgTWVzaCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gTWVzaC5yZWdpc3RlclN1YmNsYXNzKE1lc2hSb3RhdGlvbik7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHZlcnRpY2VzRGVmYXVsdDogVmVjdG9yMltdID0gWyAvLyBsaW5lIGlzIHRoZSBtaW5pbWFsIHNoYXBlXHJcbiAgICAgIG5ldyBWZWN0b3IyKDAuNSwgMC41KSxcclxuICAgICAgbmV3IFZlY3RvcjIoMC41LCAtMC41KVxyXG4gICAgXTtcclxuICAgIHByb3RlY3RlZCBzaGFwZTogTXV0YWJsZUFycmF5PFZlY3RvcjI+ID0gbmV3IE11dGFibGVBcnJheTxWZWN0b3IyPihWZWN0b3IyKTtcclxuICAgIHByb3RlY3RlZCBsb25naXR1ZGVzOiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9uYW1lOiBzdHJpbmcgPSBcIk1lc2hSb3RhdGlvblwiLCBfc2hhcGU6IFZlY3RvcjJbXSA9IE1lc2hSb3RhdGlvbi52ZXJ0aWNlc0RlZmF1bHQsIF9sb25naXR1ZGVzOiBudW1iZXIgPSAzKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgdGhpcy5yb3RhdGUoX3NoYXBlLCBfbG9uZ2l0dWRlcyk7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiTXV0YXRvclwiLCB0aGlzLmdldE11dGF0b3IoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGdldCBtaW5WZXJ0aWNlcygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gMjtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gVHJhbnNmZXJcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24uc2hhcGUgPSBTZXJpYWxpemVyLnNlcmlhbGl6ZUFycmF5KFZlY3RvcjIsIHRoaXMuc2hhcGUpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmxvbmdpdHVkZXMgPSB0aGlzLmxvbmdpdHVkZXM7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgbGV0IHNoYXBlOiBWZWN0b3IyW10gPSA8VmVjdG9yMltdPmF3YWl0IFNlcmlhbGl6ZXIuZGVzZXJpYWxpemVBcnJheShfc2VyaWFsaXphdGlvbi5zaGFwZSk7XHJcbiAgICAgIHRoaXMubG9uZ2l0dWRlcyA9IF9zZXJpYWxpemF0aW9uLmxvbmdpdHVkZXM7XHJcbiAgICAgIHRoaXMucm90YXRlKHNoYXBlLCB0aGlzLmxvbmdpdHVkZXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgYXdhaXQgc3VwZXIubXV0YXRlKF9tdXRhdG9yLCBfc2VsZWN0aW9uLCBfZGlzcGF0Y2hNdXRhdGUpO1xyXG4gICAgICB0aGlzLnJvdGF0ZSh0aGlzLnNoYXBlLCB0aGlzLmxvbmdpdHVkZXMpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk1VVEFURSkpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgcHJvdGVjdGVkIHJvdGF0ZShfc2hhcGU6IFZlY3RvcjJbXSwgX2xvbmdpdHVkZXM6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMuc2hhcGUgPSA8TXV0YWJsZUFycmF5PFZlY3RvcjI+Pk11dGFibGVBcnJheS5mcm9tKF9zaGFwZS5tYXAoX3ZlcnRleCA9PiBfdmVydGV4LmNsb25lKSk7XHJcbiAgICAgIHRoaXMubG9uZ2l0dWRlcyA9IE1hdGgucm91bmQoX2xvbmdpdHVkZXMpO1xyXG4gICAgICBsZXQgYW5nbGU6IG51bWJlciA9IDM2MCAvIHRoaXMubG9uZ2l0dWRlcztcclxuICAgICAgbGV0IG10eFJvdGF0ZTogTWF0cml4NHg0ID0gTWF0cml4NHg0LlJPVEFUSU9OX1koYW5nbGUpO1xyXG4gICAgICAvLyBjb3B5IG9yaWdpbmFsIHBvbHlnb24gYXMgVmVjdG9yMyBhcnJheVxyXG4gICAgICBsZXQgcG9seWdvbjogVmVjdG9yM1tdID0gW107XHJcbiAgICAgIGxldCBkaXN0YW5jZXM6IG51bWJlcltdID0gWzBdO1xyXG4gICAgICBsZXQgdG90YWw6IG51bWJlciA9IDA7XHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLnNoYXBlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcG9seWdvbi5wdXNoKHRoaXMuc2hhcGVbaV0udG9WZWN0b3IzKCkpO1xyXG4gICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgbGV0IGRpc3RhbmNlOiBudW1iZXIgPSBWZWN0b3IyLkRJRkZFUkVOQ0UodGhpcy5zaGFwZVtpXSwgdGhpcy5zaGFwZVtpIC0gMV0pLm1hZ25pdHVkZTtcclxuICAgICAgICAgIHRvdGFsICs9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgZGlzdGFuY2VzLnB1c2godG90YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBkaXN0YW5jZXMuZm9yRWFjaCgoX2VudHJ5LCBfaW5kZXgpID0+IHsgZGlzdGFuY2VzW19pbmRleF0gPSBfZW50cnkgLyB0b3RhbDsgfSk7XHJcblxyXG4gICAgICBsZXQgblZlcnRpY2VzUG9seWdvbjogbnVtYmVyID0gcG9seWdvbi5sZW5ndGg7XHJcblxyXG4gICAgICBsZXQgY2xvdWQ6IFZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgIGZvciAobGV0IGxvbmdpdHVkZTogbnVtYmVyID0gMDsgbG9uZ2l0dWRlIDw9IHRoaXMubG9uZ2l0dWRlczsgbG9uZ2l0dWRlKyspIHtcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgblZlcnRpY2VzUG9seWdvbjsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgdXY6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihsb25naXR1ZGUgLyB0aGlzLmxvbmdpdHVkZXMsIGRpc3RhbmNlc1tpXSk7XHJcbiAgICAgICAgICAvLyBUT0RPOiBsYXN0IHNlY3RvciBzaG91bGQgb25seSBiZSByZWZlcmVuY2VzIHRvIHRoZSBmaXJzdCBtZXJpZGlhblxyXG4gICAgICAgICAgaWYgKGxvbmdpdHVkZSA9PSB0aGlzLmxvbmdpdHVkZXMpXHJcbiAgICAgICAgICAgIGNsb3VkLnB1c2gobmV3IFZlcnRleChpLCB1dikpO1xyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsb25naXR1ZGUgPiAwICYmIHRoaXMuc2hhcGVbaV0ueCA9PSAwKSAvLyB1c2UgYSBzaW5nbGUgdmVydGV4IHdoZW4gaXQncyBvbiB0aGUgcm90YXRpb24gYXhpc1xyXG4gICAgICAgICAgICAgIGNsb3VkLnB1c2gobmV3IFZlcnRleChpLCB1dikpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgY2xvdWQucHVzaChuZXcgVmVydGV4KHBvbHlnb25baV0uY2xvbmUsIHV2KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvbHlnb24uZm9yRWFjaCgoX3ZlY3RvcjogVmVjdG9yMykgPT4gX3ZlY3Rvci50cmFuc2Zvcm0obXR4Um90YXRlKSk7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICAvLyBjb3B5IGluZGljZXMgdG8gbmV3IGluZGV4IGFycmF5XHJcbiAgICAgIGxldCBmYWNlczogRmFjZVtdID0gW107XHJcblxyXG4gICAgICBmb3IgKGxldCBsb25naXR1ZGU6IG51bWJlciA9IDA7IGxvbmdpdHVkZSA8IHRoaXMubG9uZ2l0dWRlczsgbG9uZ2l0dWRlKyspIHtcclxuICAgICAgICBmb3IgKGxldCBsYXRpdHVkZTogbnVtYmVyID0gMDsgbGF0aXR1ZGUgPCBuVmVydGljZXNQb2x5Z29uIC0gMTsgbGF0aXR1ZGUrKykge1xyXG4gICAgICAgICAgbGV0IHN0YXJ0OiBudW1iZXIgPSBsb25naXR1ZGUgKiBuVmVydGljZXNQb2x5Z29uICsgbGF0aXR1ZGU7XHJcbiAgICAgICAgICBsZXQgcXVhZDogUXVhZCA9IG5ldyBRdWFkKGNsb3VkLCBzdGFydCArIDEsIHN0YXJ0ICsgMSArIG5WZXJ0aWNlc1BvbHlnb24sIHN0YXJ0ICsgblZlcnRpY2VzUG9seWdvbiwgc3RhcnQpO1xyXG4gICAgICAgICAgZmFjZXMucHVzaCguLi5xdWFkLmZhY2VzKTtcclxuICAgICAgICAgIC8vIFRPRE86IGNhdGNoIGludmFsaWQgZmFjZXMgcmlnaHQgaGVyZS4uLlxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IGNsb3VkO1xyXG4gICAgICB0aGlzLmZhY2VzID0gZmFjZXM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYSBVViBTcGhlcmUgd2l0aCBhIGdpdmVuIG51bWJlciBvZiBzZWN0b3JzIGFuZCBzdGFja3MgKGNsYW1wZWQgYXQgMTI4KjEyOClcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBodHRwOi8vd3d3LnNvbmdoby5jYS9vcGVuZ2wvZ2xfc3BoZXJlLmh0bWxcclxuICAgKiBAYXV0aG9ycyBTaW1vbiBTdG9ybC1TY2h1bGtlLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMFxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBNZXNoU3BoZXJlIGV4dGVuZHMgTWVzaFJvdGF0aW9uIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFNwaGVyZSk7XHJcbiAgICBwcml2YXRlIGxhdGl0dWRlczogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoU3BoZXJlXCIsIF9sb25naXR1ZGVzOiBudW1iZXIgPSA4LCBfbGF0aXR1ZGVzOiBudW1iZXIgPSA4KSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgdGhpcy5jcmVhdGUoX2xvbmdpdHVkZXMsIF9sYXRpdHVkZXMpOyAvLyBUT0RPOiB3aGVuIGRlc2VyaWFsaXplZCB0aGlzIGNhdXNlcyB0aGlzIGNhdXNlcyB0aGUgbWVzaCB0byBiZSBjcmVhdGVkIHR3aWNlXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgdGhpcyBzcGhlcmUgd2l0aCBhIGdpdmVuIG51bWJlciBvZiBsb25naXR1ZGVzIGFuZCBsYXRpdHVkZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZShfbG9uZ2l0dWRlczogbnVtYmVyID0gMywgX2xhdGl0dWRlczogbnVtYmVyID0gMik6IHZvaWQge1xyXG4gICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgIC8vQ2xhbXAgcmVzb2x1dGlvbiB0byBwcmV2ZW50IHBlcmZvcm1hbmNlIGlzc3Vlc1xyXG4gICAgICB0aGlzLmxvbmdpdHVkZXMgPSBNYXRoLm1pbihNYXRoLnJvdW5kKF9sb25naXR1ZGVzKSwgMTI4KTtcclxuICAgICAgdGhpcy5sYXRpdHVkZXMgPSBNYXRoLm1pbihNYXRoLnJvdW5kKF9sYXRpdHVkZXMpLCAxMjgpO1xyXG5cclxuICAgICAgaWYgKF9sb25naXR1ZGVzIDwgMyB8fCBfbGF0aXR1ZGVzIDwgMikge1xyXG4gICAgICAgIERlYnVnLndhcm4oXCJVViBTcGhlcmUgbXVzdCBoYXZlIGF0IGxlYXN0IDMgbG9uZ2l0dWRlcyBhbmQgMiBsYXRpdHVkZXMgdG8gZm9ybSBhIDMtZGltZW5zaW9uYWwgc2hhcGUuXCIpO1xyXG4gICAgICAgIHRoaXMubG9uZ2l0dWRlcyA9IE1hdGgubWF4KDMsIF9sb25naXR1ZGVzKTtcclxuICAgICAgICB0aGlzLmxhdGl0dWRlcyA9IE1hdGgubWF4KDIsIF9sYXRpdHVkZXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgc2hhcGU6IFZlY3RvcjJbXSA9IFtdO1xyXG4gICAgICBsZXQgc3RlcDogbnVtYmVyID0gTWF0aC5QSSAvIHRoaXMubGF0aXR1ZGVzO1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDw9IHRoaXMubGF0aXR1ZGVzOyArK2kpIHtcclxuICAgICAgICBsZXQgYW5nbGU6IG51bWJlciA9IE1hdGguUEkgLyAyIC0gaSAqIHN0ZXA7XHJcbiAgICAgICAgbGV0IHg6IG51bWJlciA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICBsZXQgeTogbnVtYmVyID0gTWF0aC5zaW4oYW5nbGUpO1xyXG5cclxuICAgICAgICBzaGFwZS5wdXNoKG5ldyBWZWN0b3IyKHggLyAyLCB5IC8gMikpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHBsYWNlIGZpcnN0IGFuZCBsYXN0IHZlcnRleCBleGFjdGx5IG9uIHJvdGF0aW9uIGF4aXNcclxuICAgICAgc2hhcGVbMF0ueCA9IDA7XHJcbiAgICAgIHNoYXBlW3NoYXBlLmxlbmd0aCAtIDFdLnggPSAwO1xyXG5cclxuICAgICAgc3VwZXIucm90YXRlKHNoYXBlLCBfbG9uZ2l0dWRlcyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb24uc2hhcGU7XHJcbiAgICAgIHNlcmlhbGl6YXRpb24ubGF0aXR1ZGVzID0gdGhpcy5sYXRpdHVkZXM7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgdGhpcy5jcmVhdGUoX3NlcmlhbGl6YXRpb24ubG9uZ2l0dWRlcywgX3NlcmlhbGl6YXRpb24ubGF0aXR1ZGVzKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgICAgdGhpcy5jcmVhdGUodGhpcy5sb25naXR1ZGVzLCB0aGlzLmxhdGl0dWRlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlZHVjZU11dGF0b3IoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHtcclxuICAgICAgc3VwZXIucmVkdWNlTXV0YXRvcihfbXV0YXRvcik7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zaGFwZTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIHR3byBxdWFkcyBwbGFjZWQgYmFjayB0byBiYWNrLCB0aGUgb25lIGZhY2luZyBpbiBuZWdhdGl2ZSBaLWRpcmVjdGlvbiBpcyB0ZXh0dXJlZCByZXZlcnNlZFxyXG4gICAqIGBgYHRleHRcclxuICAgKiAgICAgICAgMCBfXyAzXHJcbiAgICogICAgICAgICB8X198XHJcbiAgICogICAgICAgIDEgICAgMiAgICAgICAgICAgICBcclxuICAgKiBgYGAgXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaFNwcml0ZSBleHRlbmRzIE1lc2gge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IE1lc2gucmVnaXN0ZXJTdWJjbGFzcyhNZXNoU3ByaXRlKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25hbWU6IHN0cmluZyA9IFwiTWVzaFNwcml0ZVwiKSB7XHJcbiAgICAgIHN1cGVyKF9uYW1lKTtcclxuICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcyhcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKC0wLjUsIDAuNSwgMCksIG5ldyBWZWN0b3IyKDAsIDApKSxcclxuICAgICAgICBuZXcgVmVydGV4KG5ldyBWZWN0b3IzKC0wLjUsIC0wLjUsIDApLCBuZXcgVmVjdG9yMigwLCAxKSksXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjUsIC0wLjUsIDApLCBuZXcgVmVjdG9yMigxLCAxKSksXHJcbiAgICAgICAgbmV3IFZlcnRleChuZXcgVmVjdG9yMygwLjUsIDAuNSwgMCksIG5ldyBWZWN0b3IyKDEsIDApKVxyXG4gICAgICApO1xyXG4gICAgICB0aGlzLmZhY2VzID0gW1xyXG4gICAgICAgIG5ldyBGYWNlKHRoaXMudmVydGljZXMsIDEsIDIsIDApLFxyXG4gICAgICAgIG5ldyBGYWNlKHRoaXMudmVydGljZXMsIDIsIDMsIDApLFxyXG4gICAgICAgIG5ldyBGYWNlKHRoaXMudmVydGljZXMsIDAsIDMsIDEpLFxyXG4gICAgICAgIG5ldyBGYWNlKHRoaXMudmVydGljZXMsIDMsIDIsIDEpXHJcbiAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmxhdCBpcyBzdGFuZGFyZCBoZXJlIC8vIFRPRE86IGlzIHRoaXMgc3RpbGwgbmVlZGVkP1xyXG4gICAgcHVibGljIGdldCB2ZXJ0aWNlc0ZsYXQoKTogRmxvYXQzMkFycmF5IHsgcmV0dXJuIHRoaXMucmVuZGVyTWVzaC5wb3NpdGlvbnM7IH1cclxuICAgIHB1YmxpYyBnZXQgaW5kaWNlc0ZsYXQoKTogVWludDE2QXJyYXkgeyByZXR1cm4gdGhpcy5yZW5kZXJNZXNoLmluZGljZXM7IH1cclxuXHJcbiAgICAvLyBpbnN0ZWFkLCBzbW9vdGggc2hhZGluZyB3b3VsZCBuZWVkIGV4dHJhIGF0dGVudGlvbiBidXQgaXMgbm90IHJlbGV2YW50Li4uXHJcblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGEgdG9ydXMgd2l0aCBhIGdpdmVuIHJpbmcgcmFkaXVzLCB0dWJlIHJhZGl1cyBhbmQgdGhlIG51bWJlciBvZiBtYWpvci0gYW5kIG1pbm9yIHNlZ21lbnRzXHJcbiAgICogQGF1dGhvcnMgU2ltb24gU3RvcmwtU2NodWxrZSwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjBcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTWVzaFRvcnVzIGV4dGVuZHMgTWVzaFJvdGF0aW9uIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBNZXNoLnJlZ2lzdGVyU3ViY2xhc3MoTWVzaFRvcnVzKTtcclxuICAgIHByaXZhdGUgbGF0aXR1ZGVzOiBudW1iZXIgPSAxMjtcclxuICAgIHByaXZhdGUgcmFkaXVzUmluZzogbnVtYmVyID0gMC41IC0gMC4xMjU7XHJcbiAgICBwcml2YXRlIHJhZGl1c1R1YmU6IG51bWJlciA9IDAuMTI1O1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nID0gXCJNZXNoVG9ydXNcIiwgX3JhZGl1c1Jpbmc6IG51bWJlciA9IDAuNSAtIDAuMTI1LCBfcmFkaXVzVHViZTogbnVtYmVyID0gMC4xMjUgLCBfbG9uZ2l0dWRlczogbnVtYmVyID0gOCwgX2xhdGl0dWRlczogbnVtYmVyID0gNikge1xyXG4gICAgICBzdXBlcihfbmFtZSwgTWVzaFRvcnVzLmdldFNoYXBlKF9yYWRpdXNSaW5nLCBfcmFkaXVzVHViZSwgTWF0aC5tYXgoMywgX2xhdGl0dWRlcykpLCBfbG9uZ2l0dWRlcyk7XHJcbiAgICAgIHRoaXMucmFkaXVzVHViZSA9IF9yYWRpdXNUdWJlO1xyXG4gICAgICB0aGlzLnJhZGl1c1JpbmcgPSBfcmFkaXVzUmluZztcclxuICAgICAgdGhpcy5sb25naXR1ZGVzID0gX2xvbmdpdHVkZXM7XHJcbiAgICAgIHRoaXMubGF0aXR1ZGVzID0gTWF0aC5tYXgoMywgX2xhdGl0dWRlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0U2hhcGUoX3JhZGl1c1Jpbmc6IG51bWJlciwgX3JhZGl1c1R1YmU6IG51bWJlciwgX2xhdGl0dWRlczogbnVtYmVyKTogVmVjdG9yMltdIHtcclxuICAgICAgbGV0IHNoYXBlOiBWZWN0b3IyW10gPSBbXTtcclxuICAgICAgbGV0IGNlbnRlcjogVmVjdG9yMiA9IG5ldyBWZWN0b3IyKF9yYWRpdXNSaW5nLCAwKTtcclxuICAgICAgZm9yIChsZXQgbGF0aXR1ZGU6IG51bWJlciA9IDA7IGxhdGl0dWRlIDw9IF9sYXRpdHVkZXM7IGxhdGl0dWRlKyspIHtcclxuICAgICAgICBsZXQgYW5nbGU6IG51bWJlciA9IDIgKiBNYXRoLlBJICogbGF0aXR1ZGUgLyBfbGF0aXR1ZGVzO1xyXG4gICAgICAgIHNoYXBlLnB1c2goVmVjdG9yMi5TVU0oY2VudGVyLCBuZXcgVmVjdG9yMihfcmFkaXVzVHViZSAqIC1NYXRoLmNvcyhhbmdsZSksIF9yYWRpdXNUdWJlICogTWF0aC5zaW4oYW5nbGUpKSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzaGFwZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0aGlzIHRvcnVzIGZyb20gdGhlIGdpdmVuIHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZShfcmFkaXVzUmluZzogbnVtYmVyID0gMC41IC0gMC4xMjUsIF9yYWRpdXNUdWJlOiBudW1iZXIgPSAwLjEyNSwgIF9sb25naXR1ZGVzOiBudW1iZXIgPSA4LCBfbGF0aXR1ZGVzOiBudW1iZXIgPSA2KTogdm9pZCB7XHJcbiAgICAgIHRoaXMucmFkaXVzVHViZSA9IF9yYWRpdXNUdWJlO1xyXG4gICAgICB0aGlzLmxhdGl0dWRlcyA9IE1hdGgubWF4KDMsIF9sYXRpdHVkZXMpO1xyXG4gICAgICB0aGlzLnJhZGl1c1JpbmcgPSBfcmFkaXVzUmluZztcclxuICAgICAgc3VwZXIucm90YXRlKE1lc2hUb3J1cy5nZXRTaGFwZShfcmFkaXVzUmluZywgX3JhZGl1c1R1YmUsIF9sYXRpdHVkZXMpLCBfbG9uZ2l0dWRlcyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2ZlclxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5sYXRpdHVkZXMgPSB0aGlzLmxhdGl0dWRlcztcclxuICAgICAgc2VyaWFsaXphdGlvbi5yYWRpdXNSaW5nID0gdGhpcy5yYWRpdXNSaW5nO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnJhZGl1c1R1YmUgPSB0aGlzLnJhZGl1c1R1YmU7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uKTtcclxuICAgICAgdGhpcy5jcmVhdGUoX3NlcmlhbGl6YXRpb24ucmFkaXVzUmluZywgX3NlcmlhbGl6YXRpb24ucmFkaXVzVHViZSwgX3NlcmlhbGl6YXRpb24ubG9uZ2l0dWRlcywgX3NlcmlhbGl6YXRpb24ubGF0aXR1ZGVzKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgICAgdGhpcy5jcmVhdGUodGhpcy5yYWRpdXNSaW5nLCB0aGlzLnJhZGl1c1R1YmUsIHRoaXMubG9uZ2l0dWRlcywgdGhpcy5sYXRpdHVkZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgICBkZWxldGUgX211dGF0b3Iuc2hhcGU7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgZW51bSBRVUFEU1BMSVQge1xyXG4gICAgUExBTkFSLCBBVF8wLCBBVF8xXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHN1cmZhY2UgY3JlYXRlZCB3aXRoIGZvdXIgdmVydGljZXMgd2hpY2ggaW1tZWRpYXRlbHkgY3JlYXRlcyBub25lLCBvbmUgb3IgdHdvIHtAbGluayBGYWNlfXMgZGVwZW5kaW5nIG9uIHZlcnRpY2VzIGF0IGlkZW50aWNhbCBwb3NpdGlvbnMuXHJcbiAgICogYGBgdGV4dFxyXG4gICAqIFFVQURTUExJVDogIFBMQU5BUiAgICAgICAgICAgICAgICAgIEFUXzAgICAgICAgICAgICAgICAgICAgICBBVF8xXHJcbiAgICogICAgICAgICAgICAgMCBfIDMgICAgICAgICAgICAgICAgICAgMCBfIDMgICAgICAgICAgICAgICAgICAgIDAgXyAzICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAqICAgICAgICAgICAgICB8XFx8ICAgICAgICAgICAgICAgICAgICAgfFxcfCAgICAgICAgICAgICAgICAgICAgICB8L3wgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICogICAgICAgICAgICAgMSDigL4gMiAgICAgICAgICAgICAgICAgICAxIOKAviAyICAgICAgICAgICAgICAgICAgICAxIOKAviAyICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICogIHNoYXJlZCBsYXN0IHZlcnRleCAyICAgICAgbGFzdCB2ZXJ0aWNlcyAyICsgMyAgICAgIGxhc3QgdmVydGljZXMgMyArIDAgXHJcbiAgICogICAgICBcclxuICAgKiBgYGAgXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjJcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUXVhZCB7XHJcbiAgICBwdWJsaWMgZmFjZXM6IEZhY2VbXTtcclxuICAgICNzcGxpdDogUVVBRFNQTElUO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfdmVydGljZXM6IFZlcnRpY2VzLCBfaW5kZXgwOiBudW1iZXIsIF9pbmRleDE6IG51bWJlciwgX2luZGV4MjogbnVtYmVyLCBfaW5kZXgzOiBudW1iZXIsIF9zcGxpdDogUVVBRFNQTElUID0gUVVBRFNQTElULlBMQU5BUikge1xyXG4gICAgICB0aGlzLmZhY2VzID0gW107XHJcbiAgICAgIHRoaXMuI3NwbGl0ID0gX3NwbGl0O1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChfc3BsaXQgIT0gUVVBRFNQTElULkFUXzEpXHJcbiAgICAgICAgICB0aGlzLmZhY2VzLnB1c2gobmV3IEZhY2UoX3ZlcnRpY2VzLCBfaW5kZXgwLCBfaW5kZXgxLCBfaW5kZXgyKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKG5ldyBGYWNlKF92ZXJ0aWNlcywgX2luZGV4MSwgX2luZGV4MiwgX2luZGV4MykpO1xyXG4gICAgICB9IGNhdGNoIChfZTogdW5rbm93bikge1xyXG4gICAgICAgIERlYnVnLmZ1ZGdlKFwiRmFjZSBleGNsdWRlZFwiLCAoPEVycm9yPl9lKS5tZXNzYWdlKTtcclxuICAgICAgfVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChfc3BsaXQgPT0gUVVBRFNQTElULlBMQU5BUilcclxuICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChuZXcgRmFjZShfdmVydGljZXMsIF9pbmRleDMsIF9pbmRleDAsIF9pbmRleDIpKTtcclxuICAgICAgICBlbHNlIGlmIChfc3BsaXQgPT0gUVVBRFNQTElULkFUXzApXHJcbiAgICAgICAgICB0aGlzLmZhY2VzLnB1c2gobmV3IEZhY2UoX3ZlcnRpY2VzLCBfaW5kZXgwLCBfaW5kZXgyLCBfaW5kZXgzKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKG5ldyBGYWNlKF92ZXJ0aWNlcywgX2luZGV4MSwgX2luZGV4MywgX2luZGV4MCkpO1xyXG4gICAgICB9IGNhdGNoIChfZTogdW5rbm93bikge1xyXG4gICAgICAgIERlYnVnLmZ1ZGdlKFwiRmFjZSBleGNsdWRlZFwiLCAoPEVycm9yPl9lKS5tZXNzYWdlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgc3BsaXQoKTogUVVBRFNQTElUIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwbGl0O1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIEJvbmUge1xyXG4gICAgaW5kZXg6IG51bWJlcjtcclxuICAgIHdlaWdodDogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogdGhlIHJlZmVyIHRvICBkZXNjcmlwdGlvbiBpcyBubyBsb25nZXIgY29ycmVjdCBhcyByZWZlciB0byBhbHNvIHdvcmtzIGZvciBib25lIGluZGljZXNcclxuICAvKipcclxuICAgKiBSZXByZXNlbnRzIGEgdmVydGV4IG9mIGEgbWVzaCB3aXRoIGV4dGVuZGVkIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHV2IGNvb3JkaW5hdGVzIGFuZCB0aGUgdmVydGV4IG5vcm1hbC5cclxuICAgKiBJdCBtYXkgcmVmZXIgdG8gYW5vdGhlciB2ZXJ0ZXggdmlhIGFuIGluZGV4IGludG8gc29tZSBhcnJheSwgaW4gd2hpY2ggY2FzZSB0aGUgcG9zaXRpb24gYW5kIHRoZSBub3JtYWwgYXJlIHN0b3JlZCB0aGVyZS5cclxuICAgKiBUaGlzIHdheSwgdmVydGV4IHBvc2l0aW9uIGFuZCBub3JtYWwgaXMgYSAxOjEgYXNzb2NpYXRpb24sIHZlcnRleCB0byB0ZXh0dXJlIGNvb3JkaW5hdGVzIGEgMTpuIGFzc29jaWF0aW9uLlxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIyXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFZlcnRleCB7XHJcbiAgICBwdWJsaWMgcG9zaXRpb246IFZlY3RvcjM7XHJcbiAgICBwdWJsaWMgdXY6IFZlY3RvcjIgfCBudWxsO1xyXG4gICAgcHVibGljIG5vcm1hbDogVmVjdG9yMztcclxuICAgIHB1YmxpYyBjb2xvcjogQ29sb3I7XHJcbiAgICBwdWJsaWMgdGFuZ2VudDogVmVjdG9yNCB8IG51bGw7XHJcbiAgICBwdWJsaWMgcmVmZXJUbzogbnVtYmVyO1xyXG4gICAgcHVibGljIGJvbmVzOiBCb25lW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIGEgdmVydGV4IG9mIGEgbWVzaCB3aXRoIGV4dGVuZGVkIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHV2IGNvb3JkaW5hdGVzIHRoZSB2ZXJ0ZXggbm9ybWFsIGFuZCBpdHMgdGFuZ2VudHMuXHJcbiAgICAgKiBJdCBtYXkgcmVmZXIgdG8gYW5vdGhlciB2ZXJ0ZXggdmlhIGFuIGluZGV4IGludG8gc29tZSBhcnJheSwgaW4gd2hpY2ggY2FzZSB0aGUgcG9zaXRpb24gYW5kIHRoZSBub3JtYWwgYXJlIHN0b3JlZCB0aGVyZS5cclxuICAgICAqIFRoaXMgd2F5LCB2ZXJ0ZXggcG9zaXRpb24gYW5kIG5vcm1hbCBpcyBhIDE6MSBhc3NvY2lhdGlvbiwgdmVydGV4IHRvIHRleHR1cmUgY29vcmRpbmF0ZXMgYSAxOm4gYXNzb2NpYXRpb24uXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9wb3NpdGlvbk9ySW5kZXg6IFZlY3RvcjMgfCBudW1iZXIsIF91djogVmVjdG9yMiA9IG51bGwsIF9ub3JtYWw6IFZlY3RvcjMgPSBWZWN0b3IzLlpFUk8oKSwgX3RhbmdlbnQ6IFZlY3RvcjQgPSBudWxsLCBfY29sb3I6IENvbG9yID0gbmV3IENvbG9yKDEsIDEsIDEsIDEpLCBfYm9uZXM6IEJvbmVbXSA9IG51bGwpIHtcclxuICAgICAgaWYgKF9wb3NpdGlvbk9ySW5kZXggaW5zdGFuY2VvZiBWZWN0b3IzKVxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBfcG9zaXRpb25PckluZGV4O1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5yZWZlclRvID0gX3Bvc2l0aW9uT3JJbmRleDtcclxuXHJcbiAgICAgIHRoaXMudXYgPSBfdXY7XHJcbiAgICAgIHRoaXMubm9ybWFsID0gX25vcm1hbDtcclxuICAgICAgdGhpcy50YW5nZW50ID0gX3RhbmdlbnQ7XHJcbiAgICAgIHRoaXMuY29sb3IgPSBfY29sb3I7XHJcbiAgICAgIHRoaXMuYm9uZXMgPSBfYm9uZXM7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogQXJyYXkgd2l0aCBleHRlbmRlZCBmdW5jdGlvbmFsaXR5IHRvIHNlcnZlIGFzIGEge0BsaW5rIFZlcnRleH0tY2xvdWQuIFxyXG4gICAqIEFjY2Vzc29ycyB5aWVsZCBwb3NpdGlvbiBvciBub3JtYWwgYWxzbyBmb3IgdmVydGljZXMgcmVmZXJlbmNpbmcgb3RoZXIgdmVydGljZXNcclxuICAgKiBAYXV0aG9ycyBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBWZXJ0aWNlcyBleHRlbmRzIEFycmF5PFZlcnRleD4ge1xyXG4gICAgLy8gVE9ETzogdGhpcyBjbGFzcyBtYXkgYmVjb21lIG1vcmUgcG93ZXJmdWwgYnkgaGlkaW5nIHRoZSBhcnJheSBhbmQgYWRkIG1vcmUgc2VydmljZSBtZXRob2RzIGxpa2UgY2FsY3VsYXRpbmcgYm91bmRpbmcgYm94LCByYWRpdXMgZXRjLlxyXG4gICAgLy8gc2VlIGlmIGEgcHJveHkgb2YgdGhlIGFycmF5IGludGVyZmFjaW5nIFtdIHdvdWxkIGRvIGEgZ29vZCBqb2IgLT4gdGVzdGVkOiBwcm94eSBpcyBhYm91dCAyMCB0aW1lcyBzbG93ZXIhXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzdWJzZXQgb2YgdmVydGljZXMgdGhhdCBkbyBub3QgcmVmZXIgdG8gb3RoZXIgdmVydGljZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBvcmlnaW5hbHMoKTogQXJyYXk8VmVydGV4PiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihfdmVydGV4ID0+IF92ZXJ0ZXgucmVmZXJUbyA9PSB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB0aGUgcG9zaXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSB2ZXJ0ZXggYWRkcmVzc2VkLCByZXNvbHZpbmcgcmVmZXJlbmNlcyBiZXR3ZWVuIHZlcnRpY2VzIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9zaXRpb24oX2luZGV4OiBudW1iZXIpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHZlcnRleDogVmVydGV4ID0gdGhpc1tfaW5kZXhdO1xyXG4gICAgICByZXR1cm4gKHZlcnRleC5yZWZlclRvID09IHVuZGVmaW5lZCkgPyB2ZXJ0ZXgucG9zaXRpb24gOiB0aGlzW3ZlcnRleC5yZWZlclRvXS5wb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgdGhlIG5vcm1hbCBhc3NvY2lhdGVkIHdpdGggdGhlIHZlcnRleCBhZGRyZXNzZWQsIHJlc29sdmluZyByZWZlcmVuY2VzIGJldHdlZW4gdmVydGljZXMgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBub3JtYWwoX2luZGV4OiBudW1iZXIpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHZlcnRleDogVmVydGV4ID0gdGhpc1tfaW5kZXhdO1xyXG4gICAgICByZXR1cm4gKHZlcnRleC5yZWZlclRvID09IHVuZGVmaW5lZCkgPyB2ZXJ0ZXgubm9ybWFsIDogdGhpc1t2ZXJ0ZXgucmVmZXJUb10ubm9ybWFsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB0aGUgdGFuZ2VudCBhc3NvY2lhdGVkIHdpdGggdGhlIHZlcnRleCBhZGRyZXNzZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRhbmdlbnQoX2luZGV4OiBudW1iZXIpOiBWZWN0b3I0IHtcclxuICAgICAgcmV0dXJuIHRoaXNbX2luZGV4XS50YW5nZW50OyAvLyB0YW5nZW50cyBjYW4gbm90IGJlIHNoYXJlZCBhcyB0aGV5IGFyZSBkZXBlbmRlbnQgb24gdGhlIHV2LWNvb3JkaW5hdGVzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSB1di1jb29yZGluYXRlcyBhc3NvY2lhdGVkIHdpdGggdGhlIHZlcnRleCBhZGRyZXNzZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHV2KF9pbmRleDogbnVtYmVyKTogVmVjdG9yMiB7XHJcbiAgICAgIHJldHVybiB0aGlzW19pbmRleF0udXY7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSBjb2xvciBhc3NvY2lhdGVkIHdpdGggdGhlIHZlcnRleCBhZGRyZXNzZWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbG9yKF9pbmRleDogbnVtYmVyKTogQ29sb3Ige1xyXG4gICAgICByZXR1cm4gdGhpc1tfaW5kZXhdLmNvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB0aGUgYm9uZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSB2ZXJ0ZXggYWRkcmVzc2VkLCByZXNvbHZpbmcgcmVmZXJlbmNlcyBiZXR3ZWVuIHZlcnRpY2VzIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYm9uZXMoX2luZGV4OiBudW1iZXIpOiBCb25lW10ge1xyXG4gICAgICBsZXQgdmVydGV4OiBWZXJ0ZXggPSB0aGlzW19pbmRleF07XHJcbiAgICAgIHJldHVybiAodmVydGV4LnJlZmVyVG8gPT0gdW5kZWZpbmVkKSA/IHZlcnRleC5ib25lcyA6IHRoaXNbdmVydGV4LnJlZmVyVG9dLmJvbmVzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG5cclxuICAvKipcclxuICAgKiBBIFdlYkdMIHNoYWRlcnByb2dyYW0gZm9yIGEgcGFydGljbGUgc3lzdGVtLiBNYW5hZ2VkIGJ5IGEge0BsaW5rIFBhcnRpY2xlU3lzdGVtfS4gSXQgdXNlcyB7QGxpbmsgUGFydGljbGVTeXN0ZW0uZGF0YX0gdG8gZ2VuZXJhdGUgYW5kIGluamVjdCBjb2RlIGludG8gYSBzaGFkZXIgdW5pdmVyc2FsIGRlcml2YXRlIChHTFNMKSB0aHVzIGNyZWF0aW5nIGEgc2hhZGVyIHBhcnRpY2xlIHN5c3RlbSBmcm9tIGEgc3VwcGxpZWQge0BsaW5rIFNoYWRlcn1zIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZSBjb2RlLlxyXG4gICAqIEBhdXRob3IgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIyXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgQFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW0uZGVjb3JhdGVcclxuICBleHBvcnQgY2xhc3MgU2hhZGVyUGFydGljbGVTeXN0ZW0gaW1wbGVtZW50cyBTaGFkZXJJbnRlcmZhY2Uge1xyXG4gICAgcHVibGljIGRhdGE6IFBhcnRpY2xlRGF0YS5TeXN0ZW07XHJcbiAgICBwdWJsaWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcIlBBUlRJQ0xFXCJdO1xyXG4gICAgcHVibGljIHZlcnRleFNoYWRlclNvdXJjZTogc3RyaW5nO1xyXG4gICAgcHVibGljIGZyYWdtZW50U2hhZGVyU291cmNlOiBzdHJpbmc7XHJcblxyXG4gICAgcHVibGljIHByb2dyYW06IFdlYkdMUHJvZ3JhbTtcclxuICAgIHB1YmxpYyBhdHRyaWJ1dGVzOiB7IFtuYW1lOiBzdHJpbmddOiBudW1iZXIgfTtcclxuICAgIHB1YmxpYyB1bmlmb3JtczogeyBbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtfS4gVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7IHJldHVybiBcIlwiOyAvKiBpbmplY3RlZCBieSBkZWNvcmF0b3IgKi8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW19LiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcgeyByZXR1cm4gXCJcIjsgLyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluamVjdGVkIGJ5IHtAbGluayBSZW5kZXJJbmplY3RvclNoYWRlclBhcnRpY2xlU3lzdGVtfS4gVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVsZXRlUHJvZ3JhbSgpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBkZWNvcmF0b3IgKi8gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5qZWN0ZWQgYnkge0BsaW5rIFJlbmRlckluamVjdG9yU2hhZGVyUGFydGljbGVTeXN0ZW19LiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1c2VQcm9ncmFtKCk6IHZvaWQgey8qIGluamVjdGVkIGJ5IGRlY29yYXRvciAqLyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JTaGFkZXJQYXJ0aWNsZVN5c3RlbX0uIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNyZWF0ZVByb2dyYW0oKTogdm9pZCB7LyogaW5qZWN0ZWQgYnkgZGVjb3JhdG9yICovIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBFbmFibGVzIHRoaXMgbm9kZSB0byBhY2Nlc3MgdGhlIHdheXBvaW50IGdyaWQgZXN0YWJsaXNoZWQgdGhyb3VnaCB7QGxpbmsgQ29tcG9uZW50V2F5cG9pbnR9cyBhbmQgdGhlaXIge0BsaW5rIENvbm5lY3Rpb259cyxcclxuICAgKiBmaW5kIGEgcGF0aCB0aHJvdWdoIHRoZW0gYW5kIGV2ZW4gd2FsayBkb3duIHRoZSBwYXRoLlxyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMjRcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50V2Fsa2VyIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBDb21wb25lbnQucmVnaXN0ZXJTdWJjbGFzcyhDb21wb25lbnRXYWxrZXIpO1xyXG4gICAgLyoqIFRoZSBzcGVlZCB0aGUgd2Fsa2VyIHNob3VsZCBtb3ZlIHdpdGguIENvcnJlc3BvbmRzIHRvIHVuaXRzL3MuICovXHJcbiAgICBwdWJsaWMgc3BlZWQ6IG51bWJlciA9IDE7XHJcbiAgICAvKiogSWYgdHJ1ZSwgbW92ZSB0aGUgbm9kZSB0aGlzIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0byB0aHJvdWdoIGZvcmNlcyBpbnN0ZWFkIG9mIGRpcmVjdGx5IHRocm91Z2ggdGhlIHRyYW5zZm9ybS4gUmVxdWlyZXMgYSBbW0NvbXBvbmVudFJpZ2lkYm9keV1dIGlmIHRydWUuICovXHJcbiAgICAvLyBwdWJsaWMgbW92ZVRocm91Z2hQaHlzaWNzOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIGtlZXBzIHRoZSBkYXRhIG5lZWRlZCBmb3IgdGhlIGN1cnJlbnQgd2FsayAqL1xyXG4gICAgI3dhbGtEYXRhOiBXYWxrRGF0YSA9IHsgcGF0aDogW10sIHRvdGFsUHJvZ3Jlc3M6IC0xIH07XHJcbiAgICAvKioga2VlcHMgdGhlIHByb21pc2UgdG8gcmVzb2x2ZSB3aGVuIHRoZSB3YWxrZXIgaGFzIHJlYWNoZWQgdGhlIGdvYWwgKi9cclxuICAgICNwcm9taXNlUmVzb2x2ZXJPbldhbGtGaW5pc2hlZDogKCkgPT4gdm9pZDtcclxuICAgIC8qKiBzdGF0dXMgb2Ygd2hldGhlciBpdCBzaG91bGQgcm90YXRlIHRoZSB3YWxrZXIgdG8gdGhlIHdhbGtpbmcgZGlyZWN0aW9uICovXHJcbiAgICAjcm90YXRlSW5XYWxrRGlyZWN0aW9uOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgIGlmIChQcm9qZWN0Lm1vZGUgPT0gTU9ERS5FRElUT1IpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy4jaGFuZGxlQXR0YWNoLmJpbmQodGhpcykpO1xyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgdGhpcy4jaGFuZGxlRGV0YWNoLmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKCksXHJcbiAgICAgICAgc3BlZWQ6IHRoaXMuc3BlZWRcclxuICAgICAgICAvLyBtb3ZlVGhyb3VnaFBoeXNpY3M6IHRoaXMubW92ZVRocm91Z2hQaHlzaWNzLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5zcGVlZCA9IF9zZXJpYWxpemF0aW9uLnNwZWVkO1xyXG4gICAgICAvLyB0aGlzLm1vdmVUaHJvdWdoUGh5c2ljcyA9IF9zZXJpYWxpemF0aW9uLm1vdmVUaHJvdWdoUGh5c2ljcztcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGVwb3J0cyAobW92ZXMgaW5zdGFudGx5KSB0byB0aGUgX3RhcmdldCBXYXlwb2ludC5cclxuICAgICAqIEBwYXJhbSBfdGFyZ2V0XHJcbiAgICAgKiBAcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyBpbW1lZGlhdGVseS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIG1vdmVUbyhfdGFyZ2V0OiBXYXlwb2ludCk6IFByb21pc2U8dm9pZD47XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRoZSB3YWxrZXIgZnJvbSB0aGUgX3N0YXJ0IHRvIHRoZSBfZW5kIFdheXBvaW50LlxyXG4gICAgICogVGVsZXBvcnRzIChtb3ZlcyBpbnN0YW50bHkpIHRvIHRoZSBfc3RhcnQgcG9pbnQsIHRoZW4gbW92ZXMgdGhyb3VnaCB0aGUgd2F5cG9pbnQgY29ubmVjdGlvbnMgdG8gdGhlIF9lbmQgcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0gX3N0YXJ0IFxyXG4gICAgICogQHBhcmFtIF9lbmRcclxuICAgICAqIEBwYXJhbSBfcm90YXRlIFJvdGF0ZXMgdGhlIHdhbGtlciB0byBsb29rIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHdheXBvaW50XHJcbiAgICAgKiBAcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBfZW5kIHBvaW50IGlzIHJlYWNoZWQuIFJlamVjdHMgaWYgX2VuZCBjYW4ndCBiZSByZWFjaGVkIChubyBwYXRoIGZvdW5kKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIG1vdmVUbyhfc3RhcnQ6IFdheXBvaW50LCBfZW5kOiBXYXlwb2ludCwgX3JvdGF0ZT86IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xyXG4gICAgcHVibGljIGFzeW5jIG1vdmVUbyhfc3RhcnQ6IFdheXBvaW50LCBfZW5kPzogV2F5cG9pbnQsIF9yb3RhdGU6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAoIV9zdGFydCkgcmV0dXJuO1xyXG4gICAgICBsZXQgdHJhbnNsYXRlOiBWZWN0b3IzID0gVmVjdG9yMy5ESUZGRVJFTkNFKF9zdGFydC5tdHhXb3JsZC50cmFuc2xhdGlvbiwgdGhpcy5ub2RlLm10eFdvcmxkLnRyYW5zbGF0aW9uKTtcclxuICAgICAgdGhpcy5ub2RlLm10eExvY2FsLnRyYW5zbGF0ZSh0cmFuc2xhdGUpO1xyXG4gICAgICBpZiAoIV9lbmQgfHwgX3N0YXJ0ID09PSBfZW5kKSB7XHJcbiAgICAgICAgdGhpcy4jd2Fsa0RhdGEgPSB7IHBhdGg6IFtdLCB0b3RhbFByb2dyZXNzOiAtMSB9O1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLiNyb3RhdGVJbldhbGtEaXJlY3Rpb24gPSBfcm90YXRlO1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xyXG4gICAgICAgIGxldCBwYXRoOiBQYXRoaW5nTm9kZVtdIHwgbnVsbCA9IHRoaXMuZ2V0UGF0aChfc3RhcnQsIF9lbmQpO1xyXG4gICAgICAgIGlmICghcGF0aCB8fCBwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgX3JlamVjdCgpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiN3YWxrRGF0YSA9IHsgcGF0aCwgdG90YWxQcm9ncmVzczogMCB9O1xyXG4gICAgICAgIHRoaXMuI3Byb21pc2VSZXNvbHZlck9uV2Fsa0ZpbmlzaGVkID0gX3Jlc29sdmU7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLiNyb3RhdGVJbldhbGtEaXJlY3Rpb24gJiYgdGhpcy4jd2Fsa0RhdGEucGF0aC5sZW5ndGggPj0gMSkge1xyXG4gICAgICAgICAgdGhpcy5yb3RhdGVUb3dhcmRzKHRoaXMuI3dhbGtEYXRhLnBhdGhbMF0ud2F5cG9pbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRha2VzIGNhcmUgb2YgdGhlIG1vdmluZyBhbGdvcml0aG0gYnkgY2FsY3VsYXRpbmcgdGhlIG5leHQgc3RlcCBhbmQgbW92aW5nIGFsb25nIHRoaXMgc3RlcCAqL1xyXG4gICAgcHJvdGVjdGVkIG1vdmluZygpOiB2b2lkIHtcclxuICAgICAgLy8gYXJlIHdlIGN1cnJlbnRseSBtb3Zpbmc/XHJcbiAgICAgIGlmICh0aGlzLiN3YWxrRGF0YS50b3RhbFByb2dyZXNzIDwgMCB8fCB0aGlzLiN3YWxrRGF0YS5wYXRoLmxlbmd0aCA9PSAwKSByZXR1cm47XHJcbiAgICAgIC8vIGRvIHdlIGhhdmUgYSBjdXJyZW50IHBhdGggd2UgY2FuIGZvbGxvd1xyXG4gICAgICBsZXQgY3VycmVudFBhdGg6IFBhdGhpbmdOb2RlID0gdGhpcy4jd2Fsa0RhdGEucGF0aFt0aGlzLiN3YWxrRGF0YS50b3RhbFByb2dyZXNzXTtcclxuICAgICAgaWYgKCFjdXJyZW50UGF0aCkgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gaG93IGJpZyBvZiBhIHN0ZXAgYXJlIHdlIHRha2luZyB0aGlzIGZyYW1lP1xyXG4gICAgICBsZXQgZGVsdGE6IG51bWJlciA9IHRoaXMuc3BlZWQgKiBjdXJyZW50UGF0aC5wcmV2aW91c0Nvbm5lY3Rpb24uc3BlZWRNb2RpZmllciAqIExvb3AudGltZUZyYW1lR2FtZSAvIDEwMDA7XHJcbiAgICAgIC8vIGhvdyBmYXIgYXdheSBhcmUgd2UgZnJvbSB0aGUgbmV4dCB3YXlwb2ludD9cclxuICAgICAgbGV0IHN0ZXA6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoXHJcbiAgICAgICAgY3VycmVudFBhdGgud2F5cG9pbnQubXR4V29ybGQudHJhbnNsYXRpb24sXHJcbiAgICAgICAgdGhpcy5ub2RlLm10eFdvcmxkLnRyYW5zbGF0aW9uXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBsZXQgc3RlcFJvdGF0aW9uOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuQ09OU1RSVUNUSU9OKHN0ZXApO1xyXG4gICAgICAvLyBzdGVwUm90YXRpb24ucm90YXRlKHRoaXMubm9kZS5tdHhXb3JsZC5yb3RhdGlvbik7XHJcbiAgICAgIC8vIHN0ZXAgPSBzdGVwUm90YXRpb24udHJhbnNsYXRpb247XHJcblxyXG4gICAgICBsZXQgc2NhbGU6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoXHJcbiAgICAgICAgY3VycmVudFBhdGgud2F5cG9pbnQubXR4V29ybGQuc2NhbGluZyxcclxuICAgICAgICB0aGlzLm5vZGUubXR4V29ybGQuc2NhbGluZ1xyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKGRlbHRhICogZGVsdGEgPCBzdGVwLm1hZ25pdHVkZVNxdWFyZWQpIHsgLy8gd29uJ3QgcmVhY2ggbmV4dCB3YXlwb2ludCB5ZXQuIFVzaW5nIHNxdWFyZXMgYmVjYXVzZSB0aGF0J3MgZmFzdGVyIHRvIGNvbXB1dGUgdGhhbiBzcXJ0XHJcbiAgICAgICAgc3RlcC5ub3JtYWxpemUoZGVsdGEpO1xyXG4gICAgICAgIHRoaXMubm9kZS5tdHhMb2NhbC50cmFuc2xhdGUoc3RlcCwgZmFsc2UpO1xyXG4gICAgICAgIGlmIChzY2FsZS5tYWduaXR1ZGVTcXVhcmVkID4gMCkge1xyXG4gICAgICAgICAgc2NhbGUubm9ybWFsaXplKGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ub2RlLm10eExvY2FsLnNjYWxpbmcgPSBWZWN0b3IzLlNVTShzY2FsZSwgdGhpcy5ub2RlLm10eExvY2FsLnNjYWxpbmcpO1xyXG4gICAgICAgIC8vIHRoaXMubm9kZS5tdHhMb2NhbC5zY2FsZShWZWN0b3IzLlNVTShzY2FsZSwgdGhpcy5ub2RlLm10eExvY2FsLnNjYWxpbmcpKTtcclxuICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBtb3ZlbWVudCB0aHJvdWdoIHBoeXNpY3NcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLy8gcmVhY2hlZCBuZXh0IHBvaW50XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuV0FZUE9JTlRfUkVBQ0hFRCwgeyBidWJibGVzOiB0cnVlLCBkZXRhaWw6IGN1cnJlbnRQYXRoLndheXBvaW50IH0pKTtcclxuICAgICAgKDxDb21wb25lbnRXYXlwb2ludD5jdXJyZW50UGF0aC53YXlwb2ludCkuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuV0FZUE9JTlRfUkVBQ0hFRCwgeyBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHRoaXMgfSkpO1xyXG4gICAgICBcclxuICAgICAgbGV0IHRyYW5zbGF0ZTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShjdXJyZW50UGF0aC53YXlwb2ludC5tdHhXb3JsZC50cmFuc2xhdGlvbiwgdGhpcy5ub2RlLm10eFdvcmxkLnRyYW5zbGF0aW9uKTtcclxuICAgICAgdGhpcy5ub2RlLm10eExvY2FsLnRyYW5zbGF0ZSh0cmFuc2xhdGUsIGZhbHNlKTtcclxuICAgICAgdGhpcy5ub2RlLm10eExvY2FsLnNjYWxpbmcgPSBjdXJyZW50UGF0aC53YXlwb2ludC5tdHhXb3JsZC5zY2FsaW5nO1xyXG4gICAgICB0aGlzLiN3YWxrRGF0YS50b3RhbFByb2dyZXNzKys7XHJcblxyXG4gICAgICAvLyByZWFjaGVkIGZpbmFsIHBvaW50LCBmaW5pc2hlZCB3YWxraW5nXHJcbiAgICAgIGlmICh0aGlzLiN3YWxrRGF0YS50b3RhbFByb2dyZXNzID49IHRoaXMuI3dhbGtEYXRhLnBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuI3Byb21pc2VSZXNvbHZlck9uV2Fsa0ZpbmlzaGVkKSB0aGlzLiNwcm9taXNlUmVzb2x2ZXJPbldhbGtGaW5pc2hlZCgpO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoRVZFTlQuUEFUSElOR19DT05DTFVERUQsIHsgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiBjdXJyZW50UGF0aC53YXlwb2ludCB9KSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzaG91bGQgd2Ugcm90YXRlIHdhbGtlcj9cclxuICAgICAgaWYgKHRoaXMuI3JvdGF0ZUluV2Fsa0RpcmVjdGlvbikge1xyXG4gICAgICAgIHRoaXMucm90YXRlVG93YXJkcyh0aGlzLiN3YWxrRGF0YS5wYXRoW3RoaXMuI3dhbGtEYXRhLnRvdGFsUHJvZ3Jlc3NdLndheXBvaW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBmaW5kIHRoZSBwYXRoIGJldHdlZW4gdHdvIGdpdmVuIHdheXBvaW50cyAqL1xyXG4gICAgcHJvdGVjdGVkIGdldFBhdGgoX3N0YXJ0OiBXYXlwb2ludCwgX2VuZDogV2F5cG9pbnQpOiBQYXRoaW5nTm9kZVtdIHtcclxuICAgICAgLy8gVE9ETzogdXNlIGEgbW9yZSBlZmZpY2llbnQgYWxnb3JpdGhtIGxpa2UgQSogaW5zdGVhZCBvZiBEaWprc3RyYVxyXG4gICAgICAvLyBzZXR1cCB0aGUgZ3JhcGggb2YgcGF0aHMgYmFzZWQgb24gdGhlIHN0YXJ0IG5vZGVcclxuICAgICAgbGV0IHVudmlzaXRlZE5vZGVzOiBQYXRoaW5nTm9kZVtdID0gW107XHJcbiAgICAgIGxldCBwcm9jZXNzZWRXYXlwb2ludHM6IFdheXBvaW50W10gPSBbX3N0YXJ0XTtcclxuICAgICAgbGV0IHdheXBvaW50c1RvU2VhcmNoVGhyb3VnaDogV2F5cG9pbnRbXSA9IFtfc3RhcnRdO1xyXG4gICAgICBkbyB7XHJcbiAgICAgICAgbGV0IHdheXBvaW50OiBXYXlwb2ludCA9IHdheXBvaW50c1RvU2VhcmNoVGhyb3VnaC5wb3AoKTtcclxuICAgICAgICBmb3IgKGxldCBjb25uZWN0aW9uIG9mIHdheXBvaW50LmNvbm5lY3Rpb25zKSB7XHJcbiAgICAgICAgICBpZiAoIXByb2Nlc3NlZFdheXBvaW50cy5pbmNsdWRlcyhjb25uZWN0aW9uLmVuZCkgJiYgY29ubmVjdGlvbi5zdGFydC5pc0FjdGl2ZSAmJiBjb25uZWN0aW9uLmVuZC5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICB3YXlwb2ludHNUb1NlYXJjaFRocm91Z2gucHVzaChjb25uZWN0aW9uLmVuZCk7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZFdheXBvaW50cy5wdXNoKGNvbm5lY3Rpb24uZW5kKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdW52aXNpdGVkTm9kZXMucHVzaCh7IHdheXBvaW50LCBkaXN0YW5jZTogd2F5cG9pbnQgPT09IF9zdGFydCA/IDAgOiBJbmZpbml0eSwgcHJldmlvdXM6IG51bGwsIHByZXZpb3VzQ29ubmVjdGlvbjogbnVsbCB9KTtcclxuICAgICAgfSB3aGlsZSAod2F5cG9pbnRzVG9TZWFyY2hUaHJvdWdoLmxlbmd0aCA+IDApO1xyXG5cclxuICAgICAgLy8gZG8gdGhlIGRpamtzdHJhXHJcbiAgICAgIHdoaWxlICh1bnZpc2l0ZWROb2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdW52aXNpdGVkTm9kZXMuc29ydCgoX2E6IFBhdGhpbmdOb2RlLCBfYjogUGF0aGluZ05vZGUpID0+IF9hLmRpc3RhbmNlIC0gX2IuZGlzdGFuY2UpO1xyXG4gICAgICAgIGxldCBjdXJyZW50Tm9kZTogUGF0aGluZ05vZGUgPSB1bnZpc2l0ZWROb2Rlcy5zaGlmdCgpO1xyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS53YXlwb2ludCA9PT0gX2VuZCkgcmV0dXJuIHRoaXMucGF0aGluZ05vZGVUb1BhdGgoY3VycmVudE5vZGUpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBjb24gb2YgY3VycmVudE5vZGUud2F5cG9pbnQuY29ubmVjdGlvbnMpIHtcclxuICAgICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3Rpb25Vc2FibGUoY29uKSkgY29udGludWU7XHJcbiAgICAgICAgICBsZXQgZW5kTm9kZTogUGF0aGluZ05vZGUgPSB1bnZpc2l0ZWROb2Rlcy5maW5kKF9uID0+IF9uLndheXBvaW50ID09PSBjb24uZW5kKTtcclxuICAgICAgICAgIGlmICghZW5kTm9kZSkgY29udGludWU7XHJcbiAgICAgICAgICBsZXQgbmV3RGlzdGFuY2U6IG51bWJlciA9IGN1cnJlbnROb2RlLmRpc3RhbmNlICsgdGhpcy5jYWxjdWxhdGVDb25uZWN0aW9uQ29zdChjb24pO1xyXG4gICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlID49IGVuZE5vZGUuZGlzdGFuY2UpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgZW5kTm9kZS5kaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xyXG4gICAgICAgICAgZW5kTm9kZS5wcmV2aW91cyA9IGN1cnJlbnROb2RlO1xyXG4gICAgICAgICAgZW5kTm9kZS5wcmV2aW91c0Nvbm5lY3Rpb24gPSBjb247XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgY29ubmVjdGlvbiBpcyB1c2FibGUgYnkgdGhpcyBzcGVjaWZpYyB3YWxrZXIuXHJcbiAgICAgKiAqKkFsd2F5cyByZXR1cm5zIHRydWUsIHVubGVzcyBvdmVyd3JpdHRlbiBpbiBhIGN1c3RvbSBXYWxrZXIgc3ViY2xhc3MuKipcclxuICAgICAqIENhbiBiZSB1c2VkIHRvIGluZmx1ZW5jZSB0aGUgcGF0aGZpbmRpbmcgYWxnb3JpdGhtIGZvciBjdXN0b20gd2F5cG9pbnQgLyBjb25uZWN0aW9uIHN5c3RlbXMuXHJcbiAgICAgKiBAcGFyYW0gX2Nvbm5lY3Rpb24gQSBjb25uZWN0aW9uIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBjb25uZWN0aW9uIGlzIHVzYWJsZSBieSB0aGlzIHdhbGtlciwgZmFsc2UgaWYgbm90XHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBpc0Nvbm5lY3Rpb25Vc2FibGUoX2Nvbm5lY3Rpb246IENvbm5lY3Rpb24pOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBuZXcgZGlzdGFuY2UgYmFzZWQgb24gYSBjb25uZWN0aW9uLlxyXG4gICAgICogKipBbHdheXMgcmV0dXJucyB0aGUgcGxhaW4gY29ubmVjdGlvbnMgY29zdCB1bmxlc3Mgb3ZlcndyaXR0ZW4gaW4gYSBjdXN0b20gd2Fsa2VyIHN1YmNsYXNzLioqXHJcbiAgICAgKiBDYW4gYmUgdXNlZCB0byBpbmZsdWVuY2UgdGhlIHBhdGhmaW5kaW5nIGFsZ29yaXRobSBmb3IgY3VzdG9tIHdheXBvaW50IC8gY29ubmVjdGlvbiBzeXN0ZW1zLlxyXG4gICAgICogQHBhcmFtIF9jb25uZWN0aW9uIEEgY29ubmVjdGlvbiB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMgdGhlIGFtb3VudCBvZiBjb3N0IGEgY29ubmVjdGlvbiBlbmN1cnMgdG8gdGhlIGN1cnJlbnQgd2Fsa2VyIG9yIDAgaWYgY29zdCBpcyBuZWdhdGl2ZS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNhbGN1bGF0ZUNvbm5lY3Rpb25Db3N0KF9jb25uZWN0aW9uOiBDb25uZWN0aW9uKTogbnVtYmVyIHtcclxuICAgICAgaWYgKF9jb25uZWN0aW9uLmNvc3QgPj0gMClcclxuICAgICAgICByZXR1cm4gX2Nvbm5lY3Rpb24uY29zdDtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBwYXRoaW5nTm9kZVRvUGF0aChfbm9kZTogUGF0aGluZ05vZGUpOiBQYXRoaW5nTm9kZVtdIHtcclxuICAgICAgbGV0IHBhdGg6IFBhdGhpbmdOb2RlW10gPSBbXTtcclxuICAgICAgaWYgKCFfbm9kZSkgcmV0dXJuIHBhdGg7XHJcbiAgICAgIGRvIHtcclxuICAgICAgICBwYXRoLnB1c2goX25vZGUpO1xyXG4gICAgICAgIF9ub2RlID0gX25vZGUucHJldmlvdXM7XHJcbiAgICAgIH0gd2hpbGUgKF9ub2RlPy5wcmV2aW91cyk7XHJcbiAgICAgIHJldHVybiBwYXRoLnJldmVyc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJvdGF0ZVRvd2FyZHMoX3dheXBvaW50OiBXYXlwb2ludCk6IHZvaWQge1xyXG4gICAgICBsZXQgbXR4TG9vazogTWF0cml4NHg0ID0gTWF0cml4NHg0LkxPT0tfQVQodGhpcy5ub2RlLm10eFdvcmxkLnRyYW5zbGF0aW9uLCBfd2F5cG9pbnQubXR4V29ybGQudHJhbnNsYXRpb24pO1xyXG4gICAgICB0aGlzLm5vZGUubXR4TG9jYWwucm90YXRpb24gPSBtdHhMb29rLnJvdGF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgICNoYW5kbGVBdHRhY2goKTogdm9pZCB7XHJcbiAgICAgIExvb3AuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5MT09QX0ZSQU1FLCB0aGlzLm1vdmluZy5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgICAjaGFuZGxlRGV0YWNoKCk6IHZvaWQge1xyXG4gICAgICBMb29wLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuTE9PUF9GUkFNRSwgdGhpcy5tb3ZpbmcuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW4gaW50ZXJuYWwgaW50ZXJmYWNlIHRvIG1hbmFnZSBwYXRoaW5nIGRhdGEgaW5zaWRlIHRoZSBXYWxrZXJcclxuICAgKi9cclxuICBpbnRlcmZhY2UgUGF0aGluZ05vZGUge1xyXG4gICAgd2F5cG9pbnQ6IFdheXBvaW50O1xyXG4gICAgZGlzdGFuY2U6IG51bWJlcjtcclxuICAgIHByZXZpb3VzOiBQYXRoaW5nTm9kZTtcclxuICAgIHByZXZpb3VzQ29ubmVjdGlvbjogQ29ubmVjdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuIGludGVybmFsIGludGVyZmFjZSB0byBtYW5hZ2UgdGhlIGRhdGEgb2YgdGhlIGN1cnJlbnRseSB3YWxrZWQgcGF0aFxyXG4gICAqL1xyXG4gIGludGVyZmFjZSBXYWxrRGF0YSB7XHJcbiAgICBwYXRoOiBQYXRoaW5nTm9kZVtdO1xyXG4gICAgdG90YWxQcm9ncmVzczogbnVtYmVyO1xyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBVbmlmaWVzIFdheXBvaW50cyBvZiB0aGUgcGF0aGluZyBhbGdvcml0aG1zXHJcbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAyNFxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2F5cG9pbnQge1xyXG4gICAgY29ubmVjdGlvbnM6IENvbm5lY3Rpb25bXTtcclxuICAgIG10eExvY2FsOiBNYXRyaXg0eDQ7XHJcbiAgICBtdHhXb3JsZDogTWF0cml4NHg0O1xyXG4gICAgaXNBY3RpdmU6IGJvb2xlYW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGEgcG9zaXRpb24gdGhhdCBhIHtAbGluayBDb21wb25lbnRXYWxrZXJ9IGNhbiB1c2UgYXMgYSB0YXJnZXQgcG9pbnQuXHJcbiAgICogSW1wbGVtZW50cyB7QGxpbmsgV2F5cG9pbnR9LlxyXG4gICAqIFJlZ2lzdGVycyBpdHNlbGYgdG8gYSBzdGF0aWMgbGlzdCBvZiBhbGwgYXZhaWxhYmxlIHdheXBvaW50c1xyXG4gICAqIEBhdXRob3IgTHVrYXMgU2NoZXVlcmxlLCBIRlUsIDIwMjRcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQ29tcG9uZW50V2F5cG9pbnQgZXh0ZW5kcyBDb21wb25lbnQgaW1wbGVtZW50cyBXYXlwb2ludCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gQ29tcG9uZW50LnJlZ2lzdGVyU3ViY2xhc3ModGhpcyk7XHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgI3dheXBvaW50czogQ29tcG9uZW50V2F5cG9pbnRbXSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBtdHhMb2NhbDogTWF0cml4NHg0O1xyXG5cclxuICAgICNjb25uZWN0aW9uczogQ29ubmVjdGlvbltdO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbXR4SW5pdDogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCksIF9jb25uZWN0aW9uczogQ29ubmVjdGlvbltdID0gW10pIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy4jY29ubmVjdGlvbnMgPSBfY29ubmVjdGlvbnM7XHJcbiAgICAgIHRoaXMubXR4TG9jYWwgPSBfbXR4SW5pdDtcclxuICAgICAgdGhpcy5zaW5nbGV0b24gPSBmYWxzZTtcclxuXHJcbiAgICAgIGlmIChQcm9qZWN0Lm1vZGUgPT0gTU9ERS5FRElUT1IpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIHRoaXMuI2hhbmRsZUF0dGFjaC5iaW5kKHRoaXMpKTtcclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9SRU1PVkUsIHRoaXMuI2hhbmRsZURldGFjaC5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQWxsIHRoZSB3YXlwb2ludHMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZCBpbiB0aGUgc2NlbmUuICoqRG8gbm90IGVkaXQsIHRyZWF0IGFzIHJlYWRvbmx5ISoqICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCB3YXlwb2ludHMoKTogQ29tcG9uZW50V2F5cG9pbnRbXSB7XHJcbiAgICAgIHJldHVybiBDb21wb25lbnRXYXlwb2ludC4jd2F5cG9pbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBzaG9ydGhhbmQgdG8gY3JlYXRlIGEgY29ubmVjdGlvbiBiZXR3ZWVuIHR3byB7QGxpbmsgQ29tcG9uZW50V2F5cG9pbnR9c1xyXG4gICAgICogQHBhcmFtIF9zdGFydCBUaGUge0BsaW5rIENvbXBvbmVudFdheXBvaW50fSBmcm9tIHdoaWNoIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIF9lbmQgVGhlIHtAbGluayBDb21wb25lbnRXYXlwb2ludH0gdG8gd2hpY2ggdGhlIGNvbm5lY3Rpb24gbGVhZHMuXHJcbiAgICAgKiBAcGFyYW0gX2Nvc3QgVGhlIGNvc3Qgb2YgdGhlIGNvbm5lY3Rpb24uIFRoZSBoaWdoZXIgdGhlIHZhbHVlLCB0aGUgbGVzcyBsaWtlbHkgaXQgaXMgdG8gYmUgdGFrZW4uIENhbm5vdCBiZSBuZWdhdGl2ZS5cclxuICAgICAqIEBwYXJhbSBfc3BlZWRNb2RpZmllciBIb3cgZmFzdCB0aGUgY29ubmVjdGlvbiBjYW4gYmUgd2Fsa2VkIG9uLiBEZWZhdWx0cyB0byAxXHJcbiAgICAgKiBAcGFyYW0gX2JvdGhXYXlzIElmIHRydWUsIGNyZWF0ZXMgYSBjb25uZWN0aW9uIGluIGJvdGggZGlyZWN0aW9ucy4gRGVmYXVsdDogZmFsc2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhZGRDb25uZWN0aW9uKF9zdGFydDogQ29tcG9uZW50V2F5cG9pbnQsIF9lbmQ6IENvbXBvbmVudFdheXBvaW50LCBfY29zdDogbnVtYmVyLCBfc3BlZWRNb2RpZmllcjogbnVtYmVyID0gMSwgX2JvdGhXYXlzOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgX3N0YXJ0LmFkZENvbm5lY3Rpb24oeyBjb3N0OiBfY29zdCwgZW5kOiBfZW5kLCBzdGFydDogX3N0YXJ0LCBzcGVlZE1vZGlmaWVyOiBfc3BlZWRNb2RpZmllciB9KTtcclxuICAgICAgaWYgKF9ib3RoV2F5cylcclxuICAgICAgICBfZW5kLmFkZENvbm5lY3Rpb24oeyBjb3N0OiBfY29zdCwgZW5kOiBfc3RhcnQsIHN0YXJ0OiBfZW5kLCBzcGVlZE1vZGlmaWVyOiBfc3BlZWRNb2RpZmllciB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzQWN0aXZlKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBjb25uZWN0aW9ucygpOiBDb25uZWN0aW9uW10ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY29ubmVjdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBjdXJyZW50IHdvcmxkIHBvc2l0aW9uIG9mIHRoZSBXYXlwb2ludC4gUmV0dXJucyBhIG5ldyBNYXRyaXggd2l0aG91dCBjb25uZWN0aW9uIHRvIHRoZSBXYXlwb2ludCAqL1xyXG4gICAgcHVibGljIGdldCBtdHhXb3JsZCgpOiBNYXRyaXg0eDQge1xyXG4gICAgICByZXR1cm4gTWF0cml4NHg0LlBST0RVQ1QodGhpcy5tdHhMb2NhbCwgdGhpcy5ub2RlLm10eFdvcmxkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQWRkcyBhIG5ldyB7QGxpbmsgQ29ubmVjdGlvbn0gdG8gdGhpcyB3YXlwb2ludCAqL1xyXG4gICAgcHVibGljIGFkZENvbm5lY3Rpb24oX2Nvbm5lY3Rpb246IENvbm5lY3Rpb24pOiB2b2lkIHtcclxuICAgICAgdGhpcy4jY29ubmVjdGlvbnMucHVzaChfY29ubmVjdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJlbW92ZXMgYSB7QGxpbmsgQ29ubmVjdGlvbn0gZnJvbSB0aGlzIHdheXBvaW50ICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlQ29ubmVjdGlvbihfY29ubmVjdGlvbjogQ29ubmVjdGlvbik6IHZvaWQge1xyXG4gICAgICBsZXQgaW5kZXg6IG51bWJlciA9IHRoaXMuI2Nvbm5lY3Rpb25zLmluZGV4T2YoX2Nvbm5lY3Rpb24pO1xyXG4gICAgICBpZiAoaW5kZXggPCAwKSByZXR1cm47XHJcbiAgICAgIHRoaXMuI2Nvbm5lY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKSxcclxuICAgICAgICBtYXRyaXg6IHRoaXMubXR4TG9jYWwuc2VyaWFsaXplKCksXHJcbiAgICAgICAgY29ubmVjdGlvbnM6IHRoaXMuI2Nvbm5lY3Rpb25zLm1hcChfY29uID0+IHtcclxuICAgICAgICAgIGxldCBjb25uZWN0aW9uOiBTZXJpYWxpemVkQ29ubmVjdGlvbiA9IHsgY29zdDogX2Nvbi5jb3N0LCBlbmQ6IF9jb24uZW5kLCBzcGVlZE1vZGlmaWVyOiBfY29uLnNwZWVkTW9kaWZpZXIgfTtcclxuICAgICAgICAgIGlmIChjb25uZWN0aW9uLmVuZCBpbnN0YW5jZW9mIENvbXBvbmVudFdheXBvaW50KSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uZW5kID0gTm9kZS5QQVRIX0ZST01fVE8odGhpcywgY29ubmVjdGlvbi5lbmQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XHJcbiAgICAgICAgfSlcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5tdHhMb2NhbC5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5tYXRyaXgpO1xyXG4gICAgICBjb25zdCBobmROb2RlRGVzZXJpYWxpemVkOiBFdmVudExpc3RlbmVyVW5pZmllZCA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLiNjb25uZWN0aW9ucyA9IF9zZXJpYWxpemF0aW9uLmNvbm5lY3Rpb25zLm1hcCgoX2NvbjogU2VyaWFsaXplZENvbm5lY3Rpb24pID0+IHtcclxuICAgICAgICAgIGxldCBjb25uZWN0aW9uOiBDb25uZWN0aW9uID0geyBjb3N0OiBfY29uLmNvc3QsIGVuZDogdGhpcy5zZXJpYWxpemVkV2F5cG9pbnRUb1dheXBvaW50KF9jb24uZW5kKSwgc3BlZWRNb2RpZmllcjogX2Nvbi5zcGVlZE1vZGlmaWVyLCBzdGFydDogdGhpcyB9O1xyXG4gICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVTRVJJQUxJWkVELCBobmROb2RlRGVzZXJpYWxpemVkKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVTRVJJQUxJWkVELCBobmROb2RlRGVzZXJpYWxpemVkKTtcclxuICAgICAgYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZHJhd0dpem1vcygpOiB2b2lkIHtcclxuICAgICAgbGV0IHNjYWxlVmVjdG9yOiBWZWN0b3IzID0gVmVjdG9yMy5TQ0FMRShWZWN0b3IzLk9ORSgpLCAwLjEpO1xyXG4gICAgICBsZXQgbXR4OiBNYXRyaXg0eDQgPSB0aGlzLm10eFdvcmxkO1xyXG4gICAgICBHaXptb3MuZHJhd1NwaGVyZShNYXRyaXg0eDQuQ09NUE9TSVRJT04obXR4LnRyYW5zbGF0aW9uLCBWZWN0b3IzLlpFUk8oKSwgc2NhbGVWZWN0b3IpLCBDb2xvci5DU1MoXCJvcmFuZ2VcIikpO1xyXG4gICAgICAvLyByZXR1cm47XHJcbiAgICAgIGxldCBsaW5lczogVmVjdG9yM1tdID0gW107XHJcbiAgICAgIGZvciAobGV0IGNvbm5lY3Rpb24gb2YgdGhpcy5jb25uZWN0aW9ucykge1xyXG4gICAgICAgIC8vIGlmIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50IGFyZSBvbiB0aGUgc2FtZSBwb2ludCwgZG9uJ3QgZHJhdyBsaW5lLlxyXG4gICAgICAgIGxldCB0bXBNdHg6IE1hdHJpeDR4NCA9IGNvbm5lY3Rpb24uZW5kLm10eFdvcmxkLmNsb25lO1xyXG4gICAgICAgIGxldCBkaXJlY3Rpb25WZWN0b3I6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UobXR4LnRyYW5zbGF0aW9uLCB0bXBNdHgudHJhbnNsYXRpb24pO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb25WZWN0b3IubWFnbml0dWRlU3F1YXJlZCA9PT0gMCkgY29udGludWU7XHJcbiAgICAgICAgZGlyZWN0aW9uVmVjdG9yLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIHdheXBvaW50cyBpcyBpbmFjdGl2ZSwgZG9uJ3QgZHJhdyBnaXptb3NcclxuICAgICAgICBpZiAoIWNvbm5lY3Rpb24uZW5kLmlzQWN0aXZlIHx8ICFjb25uZWN0aW9uLnN0YXJ0LmlzQWN0aXZlKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgLy8gYWN0dWFsIGxpbmVcclxuICAgICAgICBsaW5lcy5wdXNoKG10eC50cmFuc2xhdGlvbik7XHJcbiAgICAgICAgbGluZXMucHVzaCh0bXBNdHgudHJhbnNsYXRpb24pO1xyXG5cclxuICAgICAgICAvLyBhcnJvdyBoZWFkc1xyXG4gICAgICAgIGxldCBkaXJlY3Rpb25NdHg6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5MT09LX0lOKGRpcmVjdGlvblZlY3RvciwgdW5kZWZpbmVkLCBmYWxzZSwgdG1wTXR4LnRyYW5zbGF0aW9uKTtcclxuICAgICAgICBkaXJlY3Rpb25NdHguc2NhbGUoc2NhbGVWZWN0b3IpO1xyXG4gICAgICAgIEdpem1vcy5kcmF3V2lyZUNvbmUoZGlyZWN0aW9uTXR4LCBDb2xvci5DU1MoXCJvcmFuZ2VcIikpO1xyXG4gICAgICB9XHJcbiAgICAgIEdpem1vcy5kcmF3TGluZXMobGluZXMsIE1hdHJpeDR4NC5JREVOVElUWSgpLCBDb2xvci5DU1MoXCJvcmFuZ2VcIikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBBbiBpbnRlcm5hbCBmdW5jdGlvbiB0byBoZWxwIHRoZSBkZXNlcmlhbGl6YXp0aW9uIHByb2Nlc3MuICovXHJcbiAgICBwcml2YXRlIHNlcmlhbGl6ZWRXYXlwb2ludFRvV2F5cG9pbnQoX3BvaW50OiBzdHJpbmcgfCBXYXlwb2ludCk6IFdheXBvaW50IHtcclxuICAgICAgaWYgKHR5cGVvZiBfcG9pbnQgIT09IFwic3RyaW5nXCIpIHJldHVybiBfcG9pbnQ7XHJcbiAgICAgIHJldHVybiBOb2RlLkZJTkQodGhpcywgX3BvaW50KSBhcyBDb21wb25lbnRXYXlwb2ludDtcclxuICAgIH1cclxuXHJcbiAgICAjaGFuZGxlQXR0YWNoKCk6IHZvaWQge1xyXG4gICAgICBDb21wb25lbnRXYXlwb2ludC4jd2F5cG9pbnRzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgI2hhbmRsZURldGFjaCgpOiB2b2lkIHtcclxuICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSBDb21wb25lbnRXYXlwb2ludC4jd2F5cG9pbnRzLmluZGV4T2YodGhpcyk7XHJcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgQ29tcG9uZW50V2F5cG9pbnQuI3dheXBvaW50cy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogRGVmaW5lcyBhIENvbm5lY3Rpb24gaW4gdGhlIHdheSBpdCdzIHNlcmlhbGl6ZWQgaW4gcmVzb3VyY2VzIEBpbnRlcm5hbCAqL1xyXG4gIGludGVyZmFjZSBTZXJpYWxpemVkQ29ubmVjdGlvbiB7XHJcbiAgICBlbmQ6IFdheXBvaW50IHwgc3RyaW5nO1xyXG4gICAgY29zdDogbnVtYmVyO1xyXG4gICAgc3BlZWRNb2RpZmllcjogbnVtYmVyO1xyXG4gIH1cclxufVxyXG4iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIGRpcmVjdGVkIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gd2F5cG9pbnRzXHJcbiAgICogQGF1dGhvciBMdWthcyBTY2hldWVybGUsIEhGVSwgMjAyNFxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29ubmVjdGlvbiB7XHJcbiAgICAvKiogVGhlIHN0YXJ0IC8gb3JpZ2luIHdheXBvaW50IG9mIHRoaXMgY29ubmVjdGlvbi4gKi9cclxuICAgIHN0YXJ0OiBXYXlwb2ludDtcclxuICAgIC8qKiBUaGUgZW5kIC8gdGFyZ2V0IHdheXBvaW50IG9mIHRoaXMgY29ubmVjdGlvbi4gKi9cclxuICAgIGVuZDogV2F5cG9pbnQ7XHJcbiAgICAvKiogVGhlIGNvc3Qgb2YgdGhlIGNvbm5lY3Rpb24sIHRoZSBoaWdoZXIgdGhlIGxlc3MgbGlrZWx5IHRvIGJlIHRha2VuLiBDYW5ub3QgYmUgbmVnYXRpdmUuICovXHJcbiAgICBjb3N0OiBudW1iZXI7XHJcbiAgICAvKiogTW9kaWZpZXMgdGhlIHNwZWVkIHRoYXQgYSB3YWxrZXIgY2FuIHdhbGsgcGFzdCB0aGlzIGNvbm5lY3Rpb24gYnkgbXVsdGlwbHlpbmcgdGhlIHNwZWVkIHdpdGggdGhpcyB2YWx1ZS4gTmVlZHMgdG8gYmUgPjAgKi9cclxuICAgIHNwZWVkTW9kaWZpZXI6IG51bWJlcjtcclxuICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGVmaW5lcyBhdXRvbWF0aWMgYWRqdXN0bWVudCBvZiB0aGUgY29sbGlkZXJcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBCT0RZX0lOSVQge1xyXG4gICAgLyoqIENvbGxpZGVyIHVzZXMgdGhlIHBpdm90IG9mIHRoZSBtZXNoIGZvciBpbml0aWxpYWxpemF0aW9uICovXHJcbiAgICBUT19NRVNILFxyXG4gICAgLyoqIENvbGxpZGVyIHVzZXMgdGhlIHRyYW5zZm9ybSBvZiB0aGUgbm9kZSBmb3IgaW5pdGlsaWFsaXphdGlvbiAqL1xyXG4gICAgVE9fTk9ERSxcclxuICAgIC8qKiBDb2xsaWRlciB1c2VzIGl0cyBvd24gcGl2b3QgZm9yIGluaXRpbGlhbGl6YXRpb24gKi9cclxuICAgIFRPX1BJVk9UXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBY3RzIGFzIHRoZSBwaHlzaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUge0BsaW5rIE5vZGV9IGl0J3MgYXR0YWNoZWQgdG8uXHJcbiAgICogSXQncyB0aGUgY29ubmVjdGlvbiBiZXR3ZWVuIHRoZSBGVURHRSByZW5kZXJlZCB3b3JsZCBhbmQgdGhlIFBoeXNpY3Mgd29ybGQuXHJcbiAgICogRm9yIHRoZSBwaHlzaWNzIHRvIGNvcnJlY3RseSBnZXQgdGhlIHRyYW5zZm9ybWF0aW9ucyByb3RhdGlvbnMgbmVlZCB0byBiZSBhcHBsaWVkIHdpdGggZnJvbSBsZWZ0ID0gdHJ1ZS5cclxuICAgKiBPciByb3RhdGlvbnMgbmVlZCB0byBoYXBwZW4gYmVmb3JlIHNjYWxpbmcuXHJcbiAgICogQGF1dGhvciBNYXJrbyBGZWhyZW5iYWNoLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBDb21wb25lbnRSaWdpZGJvZHkgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IENvbXBvbmVudC5yZWdpc3RlclN1YmNsYXNzKENvbXBvbmVudFJpZ2lkYm9keSk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBtYXBCb2R5VHlwZTogeyBbdHlwZTogbnVtYmVyXTogbnVtYmVyIH0gPSAodHlwZW9mIE9JTU8gPT0gXCJ1bmRlZmluZWRcIikgP1xyXG4gICAgICB7XHJcbiAgICAgICAgW0JPRFlfVFlQRS5EWU5BTUlDXTogQk9EWV9UWVBFLkRZTkFNSUMsIFtCT0RZX1RZUEUuU1RBVElDXTogQk9EWV9UWVBFLlNUQVRJQywgW0JPRFlfVFlQRS5LSU5FTUFUSUNdOiBCT0RZX1RZUEUuS0lORU1BVElDXHJcbiAgICAgIH0gOiB7XHJcbiAgICAgICAgW0JPRFlfVFlQRS5EWU5BTUlDXTogT0lNTy5SaWdpZEJvZHlUeXBlLkRZTkFNSUMsIFtCT0RZX1RZUEUuU1RBVElDXTogT0lNTy5SaWdpZEJvZHlUeXBlLlNUQVRJQywgW0JPRFlfVFlQRS5LSU5FTUFUSUNdOiBPSU1PLlJpZ2lkQm9keVR5cGUuS0lORU1BVElDXHJcbiAgICAgIH07XHJcblxyXG4gICAgLyoqIFRyYW5zZm9ybWF0aW9uIG9mIHRoZSBjb2xsaWRlciByZWxhdGl2ZSB0byB0aGUgbm9kZSdzIHRyYW5zZm9ybS4gT25jZSBzZXQgbW9zdGx5IHJlbWFpbnMgY29uc3RhbnQuIFxyXG4gICAgICogSWYgYWx0ZXJlZCwge0BsaW5rIGlzSW5pdGlhbGl6ZWR9IG11c3QgYmUgcmVzZXQgdG8gZmFsc2UgdG8gcmVjcmVhdGUgdGhlIGNvbGxpZGVyIGluIHRoZSBuZXh0IHtAbGluayBSZW5kZXIucHJlcGFyZX1cclxuICAgICAqL1xyXG4gICAgcHVibGljIG10eFBpdm90OiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSURFTlRJVFkoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBWZXJ0aWNlcyB0aGF0IGJ1aWxkIGEgY29udmV4IG1lc2ggKGZvcm0gdGhhdCBpcyBpbiBpdHNlbGYgY2xvc2VkKS4gTmVlZHMgdG8gc2V0IGluIHRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIHJiIGlmIG5vbmUgb2YgdGhlIHN0YW5kYXJkIGNvbGxpZGVycyBpcyB1c2VkLiBcclxuICAgICAqIFVudGVzdGVkIGFuZCBub3QgeWV0IGZ1bGx5IHN1cHBvcnRlZCBieSBzZXJpYWxpemF0aW9uIGFuZCBtdXRhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbnZleE1lc2g6IEZsb2F0MzJBcnJheSA9IG51bGw7XHJcblxyXG4gICAgLyoqIENvbGxpc2lvbnMgd2l0aCByaWdpZGJvZGllcyBoYXBwZW5pbmcgdG8gdGhpcyBib2R5LCBjYW4gYmUgdXNlZCB0byBidWlsZCBhIGN1c3RvbSBvbkNvbGxpc2lvblN0YXkgZnVuY3Rpb25hbGl0eS4gKi9cclxuICAgIHB1YmxpYyBjb2xsaXNpb25zOiBDb21wb25lbnRSaWdpZGJvZHlbXSA9IG5ldyBBcnJheSgpO1xyXG4gICAgLyoqIFRyaWdnZXJzIHRoYXQgYXJlIGN1cnJlbnRseSB0cmlnZ2VyaW5nIHRoaXMgYm9keSAqL1xyXG4gICAgcHVibGljIHRyaWdnZXJpbmdzOiBDb21wb25lbnRSaWdpZGJvZHlbXSA9IG5ldyBBcnJheSgpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIFRoZSBncm91cHMgdGhpcyBvYmplY3QgY29sbGlkZXMgd2l0aC4gR3JvdXBzIG11c3QgYmUgd3JpdGVuIGluIGZvcm0gb2ZcclxuICAgICAqICBlLmcuIGNvbGxpc2lvbk1hc2sgPSB7QGxpbmsgQ09MTElTSU9OX0dST1VQLkRFRkFVTFR9IHwge0BsaW5rIENPTExJU0lPTl9HUk9VUH0uLi4uIGFuZCBzbyBvbiB0byBjb2xsaWRlIHdpdGggbXVsdGlwbGUgZ3JvdXBzLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbGxpc2lvbk1hc2s6IG51bWJlcjtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBBdXRvbWF0aWMgYWRqdXN0bWVudCBvZiB0aGUgcGl2b3Qgd2hlbiB7QGxpbmsgUmVuZGVyLnByZXBhcmV9IGlzIGNhbGxlZCBhY2NvcmRpbmcgdG8ge0BsaW5rIEJPRFlfSU5JVH1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGluaXRpYWxpemF0aW9uOiBCT0RZX0lOSVQgPSBCT0RZX0lOSVQuVE9fUElWT1Q7XHJcbiAgICAvKiogTWFya3MgaWYgY29sbGlkZXIgd2FzIGluaXRpYWxpemVkLiBSZXNldCB0byBmYWxzZSB0byBpbml0aWFsaXplIGFnYWluIGUuZy4gYWZ0ZXIgbWFuaXB1bGF0aW9uIG9mIG10eFBpdm90ICovXHJcbiAgICBwdWJsaWMgaXNJbml0aWFsaXplZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBJRCB0byByZWZlcmVuY2UgdGhpcyBzcGVjaWZpYyBDb21wb25lbnRSaWdpZGJvZHkgKi9cclxuICAgICNpZDogbnVtYmVyID0gMDtcclxuXHJcbiAgICAvL1ByaXZhdGUgaW5mb3JtYXRpb25zIC0gTW9zdGx5IE9pbW9QaHlzaWNzIHZhcmlhYmxlcyB0aGF0IHNob3VsZCBub3QgYmUgZXhwb3NlZCB0byB0aGUgRlVER0UgVXNlciBhbmQgbWFuaXB1bGF0ZWQgYnkgdGhlbVxyXG4gICAgI2NvbGxpZGVyOiBPSU1PLlNoYXBlO1xyXG4gICAgI2NvbGxpZGVySW5mbzogT0lNTy5TaGFwZUNvbmZpZztcclxuICAgICNjb2xsaXNpb25Hcm91cDogQ09MTElTSU9OX0dST1VQID0gQ09MTElTSU9OX0dST1VQLkRFRkFVTFQ7XHJcbiAgICAjdHlwZUNvbGxpZGVyOiBDT0xMSURFUl9UWVBFID0gQ09MTElERVJfVFlQRS5DVUJFO1xyXG5cclxuICAgICNyaWdpZGJvZHk6IE9JTU8uUmlnaWRCb2R5O1xyXG4gICAgI3JpZ2lkYm9keUluZm86IE9JTU8uUmlnaWRCb2R5Q29uZmlnID0gbmV3IE9JTU8uUmlnaWRCb2R5Q29uZmlnKCk7XHJcbiAgICAjdHlwZUJvZHk6IEJPRFlfVFlQRSA9IEJPRFlfVFlQRS5EWU5BTUlDO1xyXG5cclxuICAgICNtYXNzRGF0YTogT0lNTy5NYXNzRGF0YSA9IG5ldyBPSU1PLk1hc3NEYXRhKCk7XHJcbiAgICAjcmVzdGl0dXRpb246IG51bWJlcjtcclxuICAgICNmcmljdGlvbjogbnVtYmVyO1xyXG4gICAgI2RhbXBpbmdMaW5lYXI6IG51bWJlciA9IDAuMTtcclxuICAgICNkYW1waW5nQW5ndWxhcjogbnVtYmVyID0gMC4xO1xyXG4gICAgI2VmZmVjdFJvdGF0aW9uOiBWZWN0b3IzID0gVmVjdG9yMy5PTkUoKTtcclxuICAgICNlZmZlY3RHcmF2aXR5OiBudW1iZXIgPSAxO1xyXG4gICAgI2lzVHJpZ2dlcjogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgI210eFBpdm90VW5zY2FsZWQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JREVOVElUWSgpO1xyXG4gICAgI210eFBpdm90SW52ZXJzZTogTWF0cml4NHg0ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcblxyXG4gICAgI2NhbGxiYWNrczogT0lNTy5Db250YWN0Q2FsbGJhY2s7IC8vQ2FsbGJhY2sgTWV0aG9kcyB3aGVuIHdpdGhpbiB0aGUgb2ltb1N5c3RlbSBhIGV2ZW50IGlzIGhhcHBlbmluZ1xyXG5cclxuICAgIC8vICNwaHlzaWNzOiBQaHlzaWNzOyAvL1RPRE86IGtlZXAgYSBwb2ludGVyIHRvIHRoZSBwaHlzaWNzIGluc3RhbmNlIHVzZWQgYnkgdGhpcyBjb21wb25lbnRcclxuXHJcbiAgICAvKiogQ3JlYXRpbmcgYSBuZXcgcmlnaWRib2R5IHdpdGggYSB3ZWlnaHQgaW4ga2csIGEgcGh5c2ljcyB0eXBlIChkZWZhdWx0ID0gZHluYW1pYyksIGEgY29sbGlkZXIgdHlwZSB3aGF0IHBoeXNpY2FsIGZvcm0gaGFzIHRoZSBjb2xsaWRlciwgdG8gd2hhdCBncm91cCBkb2VzIGl0IGJlbG9uZywgaXMgdGhlcmUgYSB0cmFuc2Zvcm0gTWF0cml4IHRoYXQgc2hvdWxkIGJlIHVzZWQsIGFuZCBpcyB0aGUgY29sbGlkZXIgZGVmaW5lZCBhcyBhIGdyb3VwIG9mIHBvaW50cyB0aGF0IHJlcHJlc2VudCBhIGNvbnZleCBtZXNoLiAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9tYXNzOiBudW1iZXIgPSAxLCBfdHlwZTogQk9EWV9UWVBFID0gQk9EWV9UWVBFLkRZTkFNSUMsIF9jb2xsaWRlclR5cGU6IENPTExJREVSX1RZUEUgPSBDT0xMSURFUl9UWVBFLkNVQkUsIF9ncm91cDogQ09MTElTSU9OX0dST1VQID0gUGh5c2ljcy5zZXR0aW5ncy5kZWZhdWx0Q29sbGlzaW9uR3JvdXAsIF9tdHhUcmFuc2Zvcm06IE1hdHJpeDR4NCA9IG51bGwsIF9jb252ZXhNZXNoOiBGbG9hdDMyQXJyYXkgPSBudWxsKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuY3JlYXRlKF9tYXNzLCBfdHlwZSwgX2NvbGxpZGVyVHlwZSwgX2dyb3VwLCBfbXR4VHJhbnNmb3JtLCBfY29udmV4TWVzaCk7XHJcblxyXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0FERCwgdGhpcy5obmRFdmVudCk7XHJcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfUkVNT1ZFLCB0aGlzLmhuZEV2ZW50KTtcclxuICAgICAgLy8gdGhpcy5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVTRVJJQUxJWkVELCB0aGlzLmhuZEV2ZW50KTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBBY2Nlc3NvcnNcclxuICAgIHB1YmxpYyBnZXQgaWQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2lkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBVc2VkIGZvciBjYWxjdWxhdGlvbiBvZiB0aGUgZ2VvbWV0cmljYWwgcmVsYXRpb25zaGlwIG9mIG5vZGUgYW5kIGNvbGxpZGVyIGJ5IHtAbGluayBSZW5kZXJ9Ki9cclxuICAgIHB1YmxpYyBnZXQgbXR4UGl2b3RJbnZlcnNlKCk6IE1hdHJpeDR4NCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtdHhQaXZvdEludmVyc2U7XHJcbiAgICB9XHJcbiAgICAvKiogVXNlZCBmb3IgY2FsY3VsYXRpb24gb2YgdGhlIGdlb21ldHJpY2FsIHJlbGF0aW9uc2hpcCBvZiBub2RlIGFuZCBjb2xsaWRlciBieSB7QGxpbmsgUmVuZGVyfSovXHJcbiAgICBwdWJsaWMgZ2V0IG10eFBpdm90VW5zY2FsZWQoKTogTWF0cml4NHg0IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI210eFBpdm90VW5zY2FsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJldHJpZXZlIHRoZSBib2R5IHR5cGUuIFNlZSB7QGxpbmsgQk9EWV9UWVBFfSAqL1xyXG4gICAgcHVibGljIGdldCB0eXBlQm9keSgpOiBCT0RZX1RZUEUge1xyXG4gICAgICByZXR1cm4gdGhpcy4jdHlwZUJvZHk7XHJcbiAgICB9XHJcbiAgICAvKiogU2V0IHRoZSBib2R5IHR5cGUuIFNlZSB7QGxpbmsgQk9EWV9UWVBFfSAqL1xyXG4gICAgcHVibGljIHNldCB0eXBlQm9keShfdmFsdWU6IEJPRFlfVFlQRSkge1xyXG4gICAgICB0aGlzLiN0eXBlQm9keSA9IF92YWx1ZTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldFR5cGUoQ29tcG9uZW50UmlnaWRib2R5Lm1hcEJvZHlUeXBlW3RoaXMuI3R5cGVCb2R5XSk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRNYXNzRGF0YSh0aGlzLiNtYXNzRGF0YSk7IC8vaGF2ZSB0byByZXNldCBtYXNzIGFmdGVyIGNoYW5naW5nIHRoZSB0eXBlLCBzaW5jZSBPaW1vIGlzIGhhbmRsaW5nIG1hc3MgaW50ZXJuYWxseSB3cm9uZyB3aGVuIHN3aXRjaGluZyB0eXBlc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgc2hhcGUgdGhhdCByZXByZXNlbnRzIHRoZSB7QGxpbmsgTm9kZX0gaW4gdGhlIHBoeXNpY2FsIHdvcmxkLiBEZWZhdWx0IGlzIGEgQ3ViZS4gKi9cclxuICAgIHB1YmxpYyBnZXQgdHlwZUNvbGxpZGVyKCk6IENPTExJREVSX1RZUEUge1xyXG4gICAgICByZXR1cm4gdGhpcy4jdHlwZUNvbGxpZGVyO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCB0eXBlQ29sbGlkZXIoX3ZhbHVlOiBDT0xMSURFUl9UWVBFKSB7XHJcbiAgICAgIGlmIChfdmFsdWUgIT0gdGhpcy4jdHlwZUNvbGxpZGVyICYmIHRoaXMuI3JpZ2lkYm9keSAhPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy4jdHlwZUNvbGxpZGVyID0gX3ZhbHVlO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBjb2xsaXNpb24gZ3JvdXAgdGhpcyB7QGxpbmsgTm9kZX0gYmVsb25ncyB0byBpdCdzIHRoZSBkZWZhdWx0IGdyb3VwIG5vcm1hbGx5IHdoaWNoIG1lYW5zIGl0IHBoeXNpY2FsbHkgY29sbGlkZXMgd2l0aCBldmVyeSBncm91cCBiZXNpZGVzIHRyaWdnZXIuICovXHJcbiAgICBwdWJsaWMgZ2V0IGNvbGxpc2lvbkdyb3VwKCk6IENPTExJU0lPTl9HUk9VUCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNjb2xsaXNpb25Hcm91cDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgY29sbGlzaW9uR3JvdXAoX3ZhbHVlOiBDT0xMSVNJT05fR1JPVVApIHtcclxuICAgICAgdGhpcy4jY29sbGlzaW9uR3JvdXAgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLiNyaWdpZGJvZHkgIT0gbnVsbClcclxuICAgICAgICB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkuc2V0Q29sbGlzaW9uR3JvdXAodGhpcy4jY29sbGlzaW9uR3JvdXApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBNYXJraW5nIHRoZSBCb2R5IGFzIGEgdHJpZ2dlciB0aGVyZWZvcmUgbm90IGluZmx1ZW5jaW5nIHRoZSBjb2xsaXNpb24gc3lzdGVtIGJ1dCBvbmx5IHNlbmRpbmcgdHJpZ2dlckV2ZW50cyAqL1xyXG4gICAgcHVibGljIGdldCBpc1RyaWdnZXIoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNpc1RyaWdnZXI7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGlzVHJpZ2dlcihfdmFsdWU6IGJvb2xlYW4pIHtcclxuICAgICAgdGhpcy4jaXNUcmlnZ2VyID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5nZXRPaW1vUmlnaWRib2R5KCkgIT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuZ2V0T2ltb1JpZ2lkYm9keSgpLl9pc1RyaWdnZXIgPSB0aGlzLiNpc1RyaWdnZXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBoeXNpY2FsIHdlaWdodCBvZiB0aGUge0BsaW5rIE5vZGV9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWFzcygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcmlnaWRib2R5LmdldE1hc3MoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0dGluZyB0aGUgcGh5c2ljYWwgd2VpZ2h0IG9mIHRoZSB7QGxpbmsgTm9kZX0gaW4ga2dcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBtYXNzKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21hc3NEYXRhLm1hc3MgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLm5vZGUgIT0gbnVsbClcclxuICAgICAgICBpZiAodGhpcy4jcmlnaWRib2R5ICE9IG51bGwpXHJcbiAgICAgICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0TWFzc0RhdGEodGhpcy4jbWFzc0RhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBEcmFnIG9mIGxpbmVhciBtb3ZlbWVudC4gQSBCb2R5IGRvZXMgc2xvdyBkb3duIGV2ZW4gb24gYSBzdXJmYWNlIHdpdGhvdXQgZnJpY3Rpb24uICovXHJcbiAgICBwdWJsaWMgZ2V0IGRhbXBUcmFuc2xhdGlvbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcmlnaWRib2R5LmdldExpbmVhckRhbXBpbmcoKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgZGFtcFRyYW5zbGF0aW9uKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI2RhbXBpbmdMaW5lYXIgPSBfdmFsdWU7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRMaW5lYXJEYW1waW5nKF92YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIERyYWcgb2Ygcm90YXRpb24uICovXHJcbiAgICBwdWJsaWMgZ2V0IGRhbXBSb3RhdGlvbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcmlnaWRib2R5LmdldEFuZ3VsYXJEYW1waW5nKCk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGRhbXBSb3RhdGlvbihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNkYW1waW5nQW5ndWxhciA9IF92YWx1ZTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldEFuZ3VsYXJEYW1waW5nKF92YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBmYWN0b3IgdGhpcyByaWdpZGJvZHkgcmVhY3RzIHJvdGF0aW9ucyB0aGF0IGhhcHBlbiBpbiB0aGUgcGh5c2ljYWwgd29ybGQuIDAgdG8gbG9jayByb3RhdGlvbiB0aGlzIGF4aXMuICovXHJcbiAgICBwdWJsaWMgZ2V0IGVmZmVjdFJvdGF0aW9uKCk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gdGhpcy4jZWZmZWN0Um90YXRpb247XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGVmZmVjdFJvdGF0aW9uKF9lZmZlY3Q6IFZlY3RvcjMpIHtcclxuICAgICAgdGhpcy4jZWZmZWN0Um90YXRpb24gPSBfZWZmZWN0O1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0Um90YXRpb25GYWN0b3IobmV3IE9JTU8uVmVjMyh0aGlzLiNlZmZlY3RSb3RhdGlvbi54LCB0aGlzLiNlZmZlY3RSb3RhdGlvbi55LCB0aGlzLiNlZmZlY3RSb3RhdGlvbi56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBmYWN0b3IgdGhpcyByaWdpZGJvZHkgcmVhY3RzIHRvIHdvcmxkIGdyYXZpdHkuIERlZmF1bHQgPSAxIGUuZy4gMSo5LjgxIG0vcy4gKi9cclxuICAgIHB1YmxpYyBnZXQgZWZmZWN0R3Jhdml0eSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jZWZmZWN0R3Jhdml0eTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgZWZmZWN0R3Jhdml0eShfZWZmZWN0OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jZWZmZWN0R3Jhdml0eSA9IF9lZmZlY3Q7XHJcbiAgICAgIGlmICh0aGlzLiNyaWdpZGJvZHkgIT0gbnVsbCkgdGhpcy4jcmlnaWRib2R5LnNldEdyYXZpdHlTY2FsZSh0aGlzLiNlZmZlY3RHcmF2aXR5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZnJpY3Rpb24gb2YgdGhlIHJpZ2lkYm9keSwgd2hpY2ggaXMgdGhlIGZhY3RvciBvZiBzbGlkaW5nIHJlc2lzdGFuY2Ugb2YgdGhpcyByaWdpZGJvZHkgb24gc3VyZmFjZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBmcmljdGlvbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jZnJpY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGZyaWN0aW9uIG9mIHRoZSByaWdpZGJvZHksIHdoaWNoIGlzIHRoZSBmYWN0b3Igb2YgIHNsaWRpbmcgcmVzaXN0YW5jZSBvZiB0aGlzIHJpZ2lkYm9keSBvbiBzdXJmYWNlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IGZyaWN0aW9uKF9mcmljdGlvbjogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI2ZyaWN0aW9uID0gX2ZyaWN0aW9uO1xyXG4gICAgICBpZiAodGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpICE9IG51bGwpXHJcbiAgICAgICAgdGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpLnNldEZyaWN0aW9uKHRoaXMuI2ZyaWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgcmVzdGl0dXRpb24gb2YgdGhlIHJpZ2lkYm9keSwgd2hpY2ggaXMgdGhlIGZhY3RvciBvZiBib3VuY2luZXNzIG9mIHRoaXMgcmlnaWRib2R5IG9uIHN1cmZhY2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcmVzdGl0dXRpb24oKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3Jlc3RpdHV0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSByZXN0aXR1dGlvbiBvZiB0aGUgcmlnaWRib2R5LCB3aGljaCBpcyB0aGUgZmFjdG9yIG9mIGJvdW5jaW5lc3Mgb2YgdGhpcyByaWdpZGJvZHkgb24gc3VyZmFjZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCByZXN0aXR1dGlvbihfcmVzdGl0dXRpb246IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyZXN0aXR1dGlvbiA9IF9yZXN0aXR1dGlvbjtcclxuICAgICAgaWYgKHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKSAhPSBudWxsKVxyXG4gICAgICAgIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5zZXRSZXN0aXR1dGlvbih0aGlzLiNyZXN0aXR1dGlvbik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBUcmFuc2Zvcm1hdGlvblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByaWdpZGJvZHkgaW4gdGhlIGZvcm0gdGhlIHBoeXNpY3MgZW5naW5lIGlzIHVzaW5nIGl0LCBzaG91bGQgbm90IGJlIHVzZWQgdW5sZXNzIGEgZnVuY3Rpb25hbGl0eVxyXG4gICAgICogaXMgbm90IHByb3ZpZGVkIHRocm91Z2ggdGhlIEZVREdFIEludGVncmF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0T2ltb1JpZ2lkYm9keSgpOiBPSU1PLlJpZ2lkQm9keSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyaWdpZGJvZHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJvdGF0aW5nIHRoZSByaWdpZGJvZHkgdGhlcmVmb3JlIGNoYW5naW5nIGl0J3Mgcm90YXRpb24gb3ZlciB0aW1lIGRpcmVjdGx5IGluIHBoeXNpY3MuIFRoaXMgd2F5IHBoeXNpY3MgaXMgY2hhbmdpbmcgaW5zdGVhZCBvZiB0cmFuc2Zvcm0uIFxyXG4gICAgICogIEJ1dCB5b3UgYXJlIGFibGUgdG8gaW5jcmVtZW50YWwgY2hhbmdpbmcgaXQgaW5zdGVhZCBvZiBhIGRpcmVjdCByb3RhdGlvbi4gIEFsdGhvdWdoIGl0J3MgYWx3YXlzIHByZWZlcmVkIHRvIHVzZSBmb3JjZXMgaW4gcGh5c2ljcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJvdGF0ZUJvZHkoX3JvdGF0aW9uQ2hhbmdlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5yb3RhdGVYeXoobmV3IE9JTU8uVmVjMyhfcm90YXRpb25DaGFuZ2UueCAqIENhbGMuZGVnMnJhZCwgX3JvdGF0aW9uQ2hhbmdlLnkgKiBDYWxjLmRlZzJyYWQsIF9yb3RhdGlvbkNoYW5nZS56ICogQ2FsYy5kZWcycmFkKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRyYW5zbGF0aW5nIHRoZSByaWdpZGJvZHkgdGhlcmVmb3JlIGNoYW5naW5nIGl0J3MgcGxhY2Ugb3ZlciB0aW1lIGRpcmVjdGx5IGluIHBoeXNpY3MuIFRoaXMgd2F5IHBoeXNpY3MgaXMgY2hhbmdpbmcgaW5zdGVhZCBvZiB0cmFuc2Zvcm0uIFxyXG4gICAgICogIEJ1dCB5b3UgYXJlIGFibGUgdG8gaW5jcmVtZW50YWxseSBjaGFuZ2luZyBpdCBpbnN0ZWFkIG9mIGEgZGlyZWN0IHBvc2l0aW9uLiBBbHRob3VnaCBpdCdzIGFsd2F5cyBwcmVmZXJlZCB0byB1c2UgZm9yY2VzIGluIHBoeXNpY3MuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNsYXRlQm9keShfdHJhbnNsYXRpb25DaGFuZ2U6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnRyYW5zbGF0ZShuZXcgT0lNTy5WZWMzKF90cmFuc2xhdGlvbkNoYW5nZS54LCBfdHJhbnNsYXRpb25DaGFuZ2UueSwgX3RyYW5zbGF0aW9uQ2hhbmdlLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY3VycmVudCBQT1NJVElPTiBvZiB0aGUge0BsaW5rIE5vZGV9IGluIHRoZSBwaHlzaWNhbCBzcGFjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0UG9zaXRpb24oKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB0bXBQb3M6IE9JTU8uVmVjMyA9IHRoaXMuI3JpZ2lkYm9keS5nZXRQb3NpdGlvbigpO1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjModG1wUG9zLngsIHRtcFBvcy55LCB0bXBQb3Mueik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IFBPU0lUSU9OIG9mIHRoZSB7QGxpbmsgTm9kZX0gaW4gdGhlIHBoeXNpY2FsIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRQb3NpdGlvbihfdmFsdWU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldFBvc2l0aW9uKG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjdXJyZW50IFJPVEFUSU9OIG9mIHRoZSB7QGxpbmsgTm9kZX0gaW4gdGhlIHBoeXNpY2FsIHNwYWNlLiBOb3RlIHRoaXMgcmFuZ2UgZnJvbSAtcGkgdG8gcGksIHNvIC05MCB0byA5MC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFJvdGF0aW9uKCk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgb3JpZW50YXRpb246IE9JTU8uUXVhdCA9IHRoaXMuI3JpZ2lkYm9keS5nZXRPcmllbnRhdGlvbigpO1xyXG4gICAgICBsZXQgdG1wUXVhdDogUXVhdGVybmlvbiA9IFJlY3ljbGVyLmdldChRdWF0ZXJuaW9uKTtcclxuICAgICAgdG1wUXVhdC5zZXQob3JpZW50YXRpb24ueCwgb3JpZW50YXRpb24ueSwgb3JpZW50YXRpb24ueiwgb3JpZW50YXRpb24udyk7XHJcbiAgICAgIGxldCBldWxlckFuZ2xlczogVmVjdG9yMyA9IHRtcFF1YXQuZXVsZXJBbmdsZXMuY2xvbmU7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHRtcFF1YXQpO1xyXG4gICAgICByZXR1cm4gZXVsZXJBbmdsZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IFJPVEFUSU9OIG9mIHRoZSB7QGxpbmsgTm9kZX0gaW4gdGhlIHBoeXNpY2FsIHNwYWNlLCBpbiBkZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRSb3RhdGlvbihfdmFsdWU6IFZlY3RvcjMgfCBRdWF0ZXJuaW9uKTogdm9pZCB7XHJcbiAgICAgIGxldCBxdWF0ZXJuaW9uOiBRdWF0ZXJuaW9uID0gX3ZhbHVlIGluc3RhbmNlb2YgVmVjdG9yMyA/IFF1YXRlcm5pb24uUk9UQVRJT04oX3ZhbHVlKSA6IF92YWx1ZTtcclxuICAgICAgbGV0IHF1YXQ6IE9JTU8uUXVhdCA9IG5ldyBPSU1PLlF1YXQocXVhdGVybmlvbi54LCBxdWF0ZXJuaW9uLnksIHF1YXRlcm5pb24ueiwgcXVhdGVybmlvbi53KTtcclxuICAgICAgaWYgKF92YWx1ZSBpbnN0YW5jZW9mIFZlY3RvcjMpXHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUocXVhdGVybmlvbik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRPcmllbnRhdGlvbihxdWF0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IHRoZSBjdXJyZW50IFNDQUxJTkcgaW4gdGhlIHBoeXNpY2FsIHNwYWNlLiAqL1xyXG4gICAgcHVibGljIGdldFNjYWxpbmcoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gdGhpcy5ub2RlLm10eFdvcmxkLnNjYWxpbmcuY2xvbmU7XHJcbiAgICAgIHNjYWxpbmcueCAqPSB0aGlzLm10eFBpdm90LnNjYWxpbmcueDtcclxuICAgICAgc2NhbGluZy55ICo9IHRoaXMubXR4UGl2b3Quc2NhbGluZy55O1xyXG4gICAgICBzY2FsaW5nLnogKj0gdGhpcy5tdHhQaXZvdC5zY2FsaW5nLno7XHJcbiAgICAgIHJldHVybiBzY2FsaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBTY2FsaW5nIHJlcXVpcmVzIHRoZSBjb2xsaWRlciB0byBiZSBjb21wbGV0ZWx5IHJlY3JlYXRlZCBhbmV3ICovXHJcbiAgICBwdWJsaWMgc2V0U2NhbGluZyhfdmFsdWU6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgLy8gbGV0IHNjYWxpbmc6IFZlY3RvcjMgPSBfdmFsdWUuY2xvbmU7ICAgXHJcbiAgICAgIHRoaXMuY3JlYXRlQ29sbGlkZXIobmV3IE9JTU8uVmVjMyhfdmFsdWUueCAvIDIsIF92YWx1ZS55IC8gMiwgX3ZhbHVlLnogLyAyKSwgdGhpcy4jdHlwZUNvbGxpZGVyKTsgLy9yZWNyZWF0ZSB0aGUgY29sbGlkZXJcclxuICAgICAgdGhpcy4jY29sbGlkZXIgPSBuZXcgT0lNTy5TaGFwZSh0aGlzLiNjb2xsaWRlckluZm8pO1xyXG4gICAgICBsZXQgb2xkQ29sbGlkZXI6IE9JTU8uU2hhcGUgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCk7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hZGRTaGFwZSh0aGlzLiNjb2xsaWRlcik7IC8vYWRkIG5ldyBjb2xsaWRlciwgYmVmb3JlIHJlbW92aW5nIHRoZSBvbGQsIHNvIHRoZSByYiBpcyBuZXZlciBhY3RpdmUgd2l0aCAwIGNvbGxpZGVyc1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkucmVtb3ZlU2hhcGUob2xkQ29sbGlkZXIpOyAvL3JlbW92ZSB0aGUgb2xkIGNvbGxpZGVyXHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyLnVzZXJEYXRhID0gdGhpczsgLy9yZXNldCB0aGUgZXh0cmEgaW5mb3JtYXRpb24gc28gdGhhdCB0aGlzIGNvbGxpZGVyIGtub3dzIHRvIHdoaWNoIEZVREdFIENvbXBvbmVudCBpdCdzIGNvbm5lY3RlZFxyXG4gICAgICB0aGlzLiNjb2xsaWRlci5zZXRDb2xsaXNpb25Hcm91cCh0aGlzLmNvbGxpc2lvbkdyb3VwKTtcclxuICAgICAgdGhpcy4jY29sbGlkZXIuc2V0Q29sbGlzaW9uTWFzayh0aGlzLmNvbGxpc2lvbk1hc2spO1xyXG5cclxuICAgICAgdGhpcy4jY29sbGlkZXIuc2V0UmVzdGl0dXRpb24odGhpcy4jcmVzdGl0dXRpb24pO1xyXG4gICAgICB0aGlzLiNjb2xsaWRlci5zZXRGcmljdGlvbih0aGlzLiNmcmljdGlvbik7XHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyLnNldENvbnRhY3RDYWxsYmFjayh0aGlzLiNjYWxsYmFja3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHJpZ2lkYm9keSBhY2NvcmRpbmcgdG8gaXRzIGluaXRpYWxpemF0aW9uIHNldHRpbmcgdG8gbWF0Y2ggdGhlIG1lc2gsIHRoZSBub2RlIG9yIGl0cyBvd24gcGl2b3QgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbml0aWFsaXplKCk6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMubm9kZSkgLy8gZGVsYXkgaW5pdGlhbGl6YXRpb24gdW50aWwgdGhpcyByaWdpZGJvZHkgaXMgYXR0YWNoZWQgdG8gYSBub2RlXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBzd2l0Y2ggKE51bWJlcih0aGlzLmluaXRpYWxpemF0aW9uKSkge1xyXG4gICAgICAgIGNhc2UgQk9EWV9JTklULlRPX05PREU6XHJcbiAgICAgICAgICB0aGlzLm10eFBpdm90ID0gTWF0cml4NHg0LklERU5USVRZKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEJPRFlfSU5JVC5UT19NRVNIOlxyXG4gICAgICAgICAgbGV0IGNtcE1lc2g6IENvbXBvbmVudE1lc2ggPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpO1xyXG4gICAgICAgICAgaWYgKGNtcE1lc2gpXHJcbiAgICAgICAgICAgIHRoaXMubXR4UGl2b3QgPSBjbXBNZXNoLm10eFBpdm90LmNsb25lO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCT0RZX0lOSVQuVE9fUElWT1Q6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBsZXQgbXR4V29ybGQ6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5QUk9EVUNUKHRoaXMubm9kZS5tdHhXb3JsZCwgdGhpcy5tdHhQaXZvdCk7XHJcblxyXG4gICAgICBsZXQgcG9zaXRpb246IFZlY3RvcjMgPSBtdHhXb3JsZC50cmFuc2xhdGlvbjsgLy9BZGRpbmcgdGhlIG9mZnNldHMgZnJvbSB0aGUgcGl2b3RcclxuICAgICAgbGV0IHJvdGF0aW9uOiBWZWN0b3IzID0gbXR4V29ybGQucm90YXRpb247XHJcbiAgICAgIGxldCBzY2FsaW5nOiBWZWN0b3IzID0gbXR4V29ybGQuc2NhbGluZztcclxuICAgICAgLy9zY2FsaW5nIHJlcXVpcmVzIGNvbGxpZGVyIHRvIGJlIHJlY3JlYXRlZFxyXG4gICAgICB0aGlzLnNldFNjYWxpbmcoc2NhbGluZyk7XHJcblxyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0TWFzc0RhdGEodGhpcy4jbWFzc0RhdGEpO1xyXG4gICAgICB0aGlzLnNldFBvc2l0aW9uKHBvc2l0aW9uKTsgLy9zZXQgdGhlIGFjdHVhbCBuZXcgcm90YXRpb24vcG9zaXRpb24gZm9yIHRoaXMgUmIgYWdhaW4gc2luY2UgaXQncyBub3cgdXBkYXRlZFxyXG4gICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uKTtcclxuXHJcbiAgICAgIGxldCBzY2FsaW5nSW52ZXJzZTogVmVjdG9yMyA9IHRoaXMubm9kZS5tdHhXb3JsZC5zY2FsaW5nLm1hcChfaSA9PiAxIC8gX2kpO1xyXG4gICAgICB0aGlzLiNtdHhQaXZvdFVuc2NhbGVkID0gTWF0cml4NHg0LkNPTVBPU0lUSU9OKHRoaXMubXR4UGl2b3QudHJhbnNsYXRpb24sIHRoaXMubXR4UGl2b3Qucm90YXRpb24sIHNjYWxpbmdJbnZlcnNlKTtcclxuICAgICAgdGhpcy4jbXR4UGl2b3RJbnZlcnNlID0gTWF0cml4NHg0LklOVkVSU0UodGhpcy4jbXR4UGl2b3RVbnNjYWxlZCk7XHJcblxyXG4gICAgICB0aGlzLmFkZFJpZ2lkYm9keVRvV29ybGQoKTtcclxuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBWZWxvY2l0eSBhbmQgRm9yY2VzXHJcbiAgICAvKipcclxuICAgICogR2V0IHRoZSBjdXJyZW50IFZFTE9DSVRZIG9mIHRoZSB7QGxpbmsgTm9kZX1cclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VmVsb2NpdHkoKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB2ZWxvY2l0eTogT0lNTy5WZWMzID0gdGhpcy4jcmlnaWRib2R5LmdldExpbmVhclZlbG9jaXR5KCk7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh2ZWxvY2l0eS54LCB2ZWxvY2l0eS55LCB2ZWxvY2l0eS56KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IFZFTE9DSVRZIG9mIHRoZSB7QGxpbmsgTm9kZX1cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFZlbG9jaXR5KF92YWx1ZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICBsZXQgdmVsb2NpdHk6IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5zZXRMaW5lYXJWZWxvY2l0eSh2ZWxvY2l0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgQU5HVUxBUiAtIFZFTE9DSVRZIG9mIHRoZSB7QGxpbmsgTm9kZX1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEFuZ3VsYXJWZWxvY2l0eSgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHZlbG9jaXR5OiBPSU1PLlZlYzMgPSB0aGlzLiNyaWdpZGJvZHkuZ2V0QW5ndWxhclZlbG9jaXR5KCk7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh2ZWxvY2l0eS54LCB2ZWxvY2l0eS55LCB2ZWxvY2l0eS56KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IEFOR1VMQVIgLSBWRUxPQ0lUWSBvZiB0aGUge0BsaW5rIE5vZGV9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRBbmd1bGFyVmVsb2NpdHkoX3ZhbHVlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIGxldCB2ZWxvY2l0eTogT0lNTy5WZWMzID0gbmV3IE9JTU8uVmVjMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldEFuZ3VsYXJWZWxvY2l0eSh2ZWxvY2l0eSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBcHBsaWVzIGEgY29udGlub3VzIEZPUkNFIGF0IHRoZSBjZW50ZXIgb2YgdGhlIFJJR0lEQk9EWSBpbiB0aGUgdGhyZWUgZGltZW5zaW9ucy4gQ29uc2lkZXJpbmcgdGhlIHJpZ2lkYm9keSdzIE1BU1MuXHJcbiAgICAqIFRoZSBmb3JjZSBpcyBtZWFzdXJlZCBpbiBuZXd0b24sIDFrZyBuZWVkcyBhYm91dCAxMCBOZXd0b24gdG8gZmlnaHQgYWdhaW5zdCBncmF2aXR5LlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBhcHBseUZvcmNlKF9mb3JjZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYXBwbHlGb3JjZVRvQ2VudGVyKG5ldyBPSU1PLlZlYzMoX2ZvcmNlLngsIF9mb3JjZS55LCBfZm9yY2UueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBcHBsaWVzIGEgY29udGlub3VzIEZPUkNFIGF0IGEgc3BlY2lmaWMgcG9pbnQgaW4gdGhlIHdvcmxkIHRvIHRoZSBSSUdJREJPRFkgaW4gdGhlIHRocmVlIGRpbWVuc2lvbnMuIENvbnNpZGVyaW5nIHRoZSByaWdpZGJvZHkncyBNQVNTXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5Rm9yY2VBdFBvaW50KF9mb3JjZTogVmVjdG9yMywgX3dvcmxkUG9pbnQ6IFZlY3RvcjMpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFwcGx5Rm9yY2UobmV3IE9JTU8uVmVjMyhfZm9yY2UueCwgX2ZvcmNlLnksIF9mb3JjZS56KSwgbmV3IE9JTU8uVmVjMyhfd29ybGRQb2ludC54LCBfd29ybGRQb2ludC55LCBfd29ybGRQb2ludC56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFwcGxpZXMgYSBjb250aW5vdXMgUk9UQVRJT05BTCBGT1JDRSAoVG9ycXVlKSB0byB0aGUgUklHSURCT0RZIGluIHRoZSB0aHJlZSBkaW1lbnNpb25zLiBDb25zaWRlcmluZyB0aGUgcmlnaWRib2R5J3MgTUFTU1xyXG4gICAgKi9cclxuICAgIHB1YmxpYyBhcHBseVRvcnF1ZShfcm90YXRpb25hbEZvcmNlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hcHBseVRvcnF1ZShuZXcgT0lNTy5WZWMzKF9yb3RhdGlvbmFsRm9yY2UueCwgX3JvdGF0aW9uYWxGb3JjZS55LCBfcm90YXRpb25hbEZvcmNlLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQXBwbGllcyBhIGluc3RhbnQgRk9SQ0UgYXQgYSBwb2ludC9yaWdpZGJvZHljZW50ZXIgdG8gdGhlIFJJR0lEQk9EWSBpbiB0aGUgdGhyZWUgZGltZW5zaW9ucy4gQ29uc2lkZXJpbmcgdGhlIHJpZ2lkYm9kJ3MgTUFTU1xyXG4gICAgKiBJbmZsdWVuY2luZyB0aGUgYW5ndWxhciBzcGVlZCBhbmQgdGhlIGxpbmVhciBzcGVlZC4gXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5SW1wdWxzZUF0UG9pbnQoX2ltcHVsc2U6IFZlY3RvcjMsIF93b3JsZFBvaW50OiBWZWN0b3IzID0gbnVsbCk6IHZvaWQge1xyXG4gICAgICBfd29ybGRQb2ludCA9IF93b3JsZFBvaW50ICE9IG51bGwgPyBfd29ybGRQb2ludCA6IHRoaXMuZ2V0UG9zaXRpb24oKTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFwcGx5SW1wdWxzZShuZXcgT0lNTy5WZWMzKF9pbXB1bHNlLngsIF9pbXB1bHNlLnksIF9pbXB1bHNlLnopLCBuZXcgT0lNTy5WZWMzKF93b3JsZFBvaW50LngsIF93b3JsZFBvaW50LnksIF93b3JsZFBvaW50LnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQXBwbGllcyBhIGluc3RhbnQgRk9SQ0UgdG8gdGhlIFJJR0lEQk9EWSBpbiB0aGUgdGhyZWUgZGltZW5zaW9ucy4gQ29uc2lkZXJpbmcgdGhlIHJpZ2lkYm9keSdzIE1BU1NcclxuICAgICogT25seSBpbmZsdWVuY2luZyBpdCdzIHNwZWVkIG5vdCByb3RhdGlvbi5cclxuICAgICovXHJcbiAgICBwdWJsaWMgYXBwbHlMaW5lYXJJbXB1bHNlKF9pbXB1bHNlOiBWZWN0b3IzKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JpZ2lkYm9keS5hcHBseUxpbmVhckltcHVsc2UobmV3IE9JTU8uVmVjMyhfaW1wdWxzZS54LCBfaW1wdWxzZS55LCBfaW1wdWxzZS56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGEgaW5zdGFudCBST1RBVElPTkFMLUZPUkNFIHRvIHRoZSBSSUdJREJPRFkgaW4gdGhlIHRocmVlIGRpbWVuc2lvbnMuIENvbnNpZGVyaW5nIHRoZSByaWdpZGJvZHkncyBNQVNTXHJcbiAgICAgKiBPbmx5IGluZmx1ZW5jaW5nIGl0J3Mgcm90YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhcHBseUFuZ3VsYXJJbXB1bHNlKF9yb3RhdGlvbmFsSW1wdWxzZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYXBwbHlBbmd1bGFySW1wdWxzZShuZXcgT0lNTy5WZWMzKF9yb3RhdGlvbmFsSW1wdWxzZS54LCBfcm90YXRpb25hbEltcHVsc2UueSwgX3JvdGF0aW9uYWxJbXB1bHNlLnopKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5naW5nIHRoZSBWRUxPQ0lUWSBvZiB0aGUgUklHSURCT0RZLiBPbmx5IGluZmx1ZW5jaW5nIHRoZSBsaW5lYXIgc3BlZWQgbm90IGFuZ3VsYXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZFZlbG9jaXR5KF92YWx1ZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYWRkTGluZWFyVmVsb2NpdHkobmV3IE9JTU8uVmVjMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2luZyB0aGUgVkVMT0NJVFkgb2YgdGhlIFJJR0lEQk9EWS4gT25seSBpbmZsdWVuY2luZyB0aGUgYW5ndWxhciBzcGVlZCBub3QgdGhlIGxpbmVhclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkQW5ndWxhclZlbG9jaXR5KF92YWx1ZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuYWRkQW5ndWxhclZlbG9jaXR5KG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGUtIC8gQWN0aXZhdGUgdGhlIHJpZ2lkYm9kaWVzIGF1dG8tc2xlZXBpbmcgZnVuY3Rpb24uXHJcbiAgICAgKiBJZiBhY3RpdmF0ZWQgdGhlIHJpZ2lkYm9keSB3aWxsIGF1dG9tYXRpY2FsbHkgc2xlZXAgd2hlbiBuZWVkZWQsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcbiAgICAgKiBJZiBkZWFjdGl2YXRlZCB0aGUgcmlnaWRib2R5IGdldHMgc3RvcHBlZCBmcm9tIHNsZWVwaW5nIHdoZW4gbW92ZW1lbnQgaXMgdG9vIG1pbmltYWwuIERlY3JlYXNpbmcgcGVyZm9ybWFuY2UsIGZvciByYXJlbHkgbW9yZSBwcmVjaXNlIHBoeXNpY3MgcmVzdWx0cyBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFjdGl2YXRlQXV0b1NsZWVwKF9vbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0QXV0b1NsZWVwKF9vbik7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gQ29sbGlzaW9uXHJcbiAgICAvLyAvKipcclxuICAgIC8vICAqIENoZWNraW5nIGZvciBDb2xsaXNpb24gd2l0aCBvdGhlciBDb2xsaWRlcnMgYW5kIGRpc3BhdGNoZXMgYSBjdXN0b20gZXZlbnQgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29sbGlkZXIuXHJcbiAgICAvLyAgKiBBdXRvbWF0aWNhbGx5IGNhbGxlZCBpbiB0aGUgUmVuZGVyTWFuYWdlciwgbm8gaW50ZXJhY3Rpb24gbmVlZGVkLlxyXG4gICAgLy8gICovXHJcbiAgICAvLyBwdWJsaWMgY2hlY2tDb2xsaXNpb25FdmVudHMoKTogdm9pZCB7XHJcbiAgICAvLyAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSAvLyBjaGVjayBjb2xsaXNpb25zIG9ubHkgaWYgaW5pdGlhbGl6YXRpb24gY29tcGxldGVkXHJcbiAgICAvLyAgICAgcmV0dXJuO1xyXG5cclxuICAgIC8vICAgbGV0IGNvbnRhY3RMaW5rOiBPSU1PLkNvbnRhY3RMaW5rID0gdGhpcy4jcmlnaWRib2R5LmdldENvbnRhY3RMaW5rTGlzdCgpOyAvLyBhbGwgcGh5c2ljYWwgY29udGFjdHMgYmV0d2VlbiBjb2xsaWRpbmcgYm9kaWVzIG9uIHRoaXMgcmJcclxuICAgIC8vICAgd2hpbGUgKGNvbnRhY3RMaW5rICE9IG51bGwpIHtcclxuICAgIC8vICAgICBsZXQgb3RoZXI6IENvbXBvbmVudFJpZ2lkYm9keSA9IGNvbnRhY3RMaW5rLmdldE90aGVyKCkudXNlckRhdGE7IC8vIGdldCB0aGUgb3RoZXIgY29tcG9uZW50IHJpZ2lkYm9keSBpbnZvbHZlZCBpbiB0aGUgY29sbGlzaW9uXHJcbiAgICAvLyAgICAgaWYgKCFvdGhlci5pc0luaXRpYWxpemVkKSB7XHJcbiAgICAvLyAgICAgICBjb250YWN0TGluayA9IGNvbnRhY3RMaW5rLmdldE5leHQoKTtcclxuICAgIC8vICAgICAgIGNvbnRpbnVlO1xyXG4gICAgLy8gICAgIH1cclxuXHJcbiAgICAvLyAgICAgbGV0IGNvbnRhY3Q6IE9JTU8uQ29udGFjdCA9IGNvbnRhY3RMaW5rLmdldENvbnRhY3QoKTtcclxuICAgIC8vICAgICBsZXQgd2FzVG91Y2hpbmc6IGJvb2xlYW4gPSB0aGlzLmNvbGxpc2lvbnMuaW5jbHVkZXMob3RoZXIpO1xyXG4gICAgLy8gICAgIGxldCBpc1RvdWNoaW5nOiBib29sZWFuID0gY29udGFjdC5pc1RvdWNoaW5nKCk7XHJcblxyXG4gICAgLy8gICAgIGlmICghd2FzVG91Y2hpbmcgJiYgaXNUb3VjaGluZykgeyAvLyBFTlRFUlxyXG4gICAgLy8gICAgICAgbGV0IG1hbmlmb2xkOiBPSU1PLk1hbmlmb2xkID0gY29udGFjdC5nZXRNYW5pZm9sZCgpO1xyXG4gICAgLy8gICAgICAgbGV0IHBvaW50czogT0lNTy5NYW5pZm9sZFBvaW50W10gPSBtYW5pZm9sZC5nZXRQb2ludHMoKTsgLy8gQWxsIHBvaW50cyBpbiB0aGUgY29sbGlzaW9uIHdoZXJlIHRoZSB0d28gYm9kaWVzIGFyZSB0b3VjaGluZywgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGZ1bGwgaW1wYWN0XHJcbiAgICAvLyAgICAgICBsZXQgbm9ybWFsSW1wdWxzZTogbnVtYmVyID0gMDtcclxuICAgIC8vICAgICAgIGxldCBiaW5vcm1hbEltcHVsc2U6IG51bWJlciA9IDA7XHJcbiAgICAvLyAgICAgICBsZXQgdGFuZ2VudEltcHVsc2U6IG51bWJlciA9IDA7XHJcbiAgICAvLyAgICAgICBmb3IgKGxldCBtYW5pZm9sZFBvaW50IG9mIHBvaW50cykgeyAvLyBUaGUgaW1wYWN0IG9mIHRoZSBjb2xsaXNpb24gaW52b2x2aW5nIGFsbCB0b3VjaGluZyBwb2ludHNcclxuICAgIC8vICAgICAgICAgbm9ybWFsSW1wdWxzZSArPSBtYW5pZm9sZFBvaW50LmdldE5vcm1hbEltcHVsc2UoKTtcclxuICAgIC8vICAgICAgICAgYmlub3JtYWxJbXB1bHNlICs9IG1hbmlmb2xkUG9pbnQuZ2V0Qmlub3JtYWxJbXB1bHNlKCk7XHJcbiAgICAvLyAgICAgICAgIHRhbmdlbnRJbXB1bHNlICs9IG1hbmlmb2xkUG9pbnQuZ2V0VGFuZ2VudEltcHVsc2UoKTtcclxuICAgIC8vICAgICAgIH1cclxuICAgIC8vICAgICAgIGxldCBub3JtYWw6IE9JTU8uVmVjMyA9IG1hbmlmb2xkLmdldE5vcm1hbCgpO1xyXG4gICAgLy8gICAgICAgbGV0IGNvbGxpc2lvbk5vcm1hbDogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopO1xyXG4gICAgLy8gICAgICAgbGV0IGNvbGxpc2lvbkNlbnRlclBvaW50OiBWZWN0b3IzID0gdGhpcy5jb2xsaXNpb25DZW50ZXJQb2ludChwb2ludHMsIG1hbmlmb2xkLmdldE51bVBvaW50cygpKTtcclxuICAgIC8vICAgICAgIHRoaXMuY29sbGlzaW9ucy5wdXNoKG90aGVyKTtcclxuICAgIC8vICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnRQaHlzaWNzKEVWRU5UX1BIWVNJQ1MuQ09MTElTSU9OX0VOVEVSLCBvdGhlciwgbm9ybWFsSW1wdWxzZSwgdGFuZ2VudEltcHVsc2UsIGJpbm9ybWFsSW1wdWxzZSwgY29sbGlzaW9uQ2VudGVyUG9pbnQsIGNvbGxpc2lvbk5vcm1hbCkpOyAvLyBTZW5kaW5nIHRoZSBnaXZlbiBldmVudFxyXG4gICAgLy8gICAgIH0gZWxzZSBpZiAod2FzVG91Y2hpbmcgJiYgIWlzVG91Y2hpbmcpIHsgLy8gRVhJVFxyXG4gICAgLy8gICAgICAgdGhpcy5jb2xsaXNpb25zLnNwbGljZSh0aGlzLmNvbGxpc2lvbnMuaW5kZXhPZihvdGhlciksIDEpO1xyXG4gICAgLy8gICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5DT0xMSVNJT05fRVhJVCwgb3RoZXIsIDAsIDAsIDApKTtcclxuICAgIC8vICAgICB9XHJcblxyXG4gICAgLy8gICAgIGNvbnRhY3RMaW5rID0gY29udGFjdExpbmsuZ2V0TmV4dCgpOyAvLyBTdGFydCB0aGUgc2FtZSByb3V0aW5lIHdpdGggdGhlIG5leHQgY29sbGlzaW9uIGluIHRoZSBsaXN0XHJcbiAgICAvLyAgIH1cclxuICAgIC8vIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIGEgcmF5IHRocm91Z2ggdGhpcyBzcGVjaWZpYyBib2R5IGlnbm9yaW5nIHRoZSByZXN0IG9mIHRoZSB3b3JsZCBhbmQgY2hlY2tzIGlmIHRoaXMgYm9keSB3YXMgaGl0IGJ5IHRoZSByYXksXHJcbiAgICAgKiByZXR1cm5pbmcgaW5mbyBhYm91dCB0aGUgaGl0LiBQcm92aWRlcyB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5IGFuZCBpbmZvcm1hdGlvbiBhIHJlZ3VsYXIgcmF5Y2FzdCBkb2VzIGJ1dCB0aGUgcmF5IGlzIG9ubHkgdGVzdGluZyBhZ2FpbnN0IHRoaXMgc3BlY2lmaWMgYm9keS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJheWNhc3RUaGlzQm9keShfb3JpZ2luOiBWZWN0b3IzLCBfZGlyZWN0aW9uOiBWZWN0b3IzLCBfbGVuZ3RoOiBudW1iZXIsIF9kZWJ1Z0RyYXc6IGJvb2xlYW4gPSBmYWxzZSk6IFJheUhpdEluZm8ge1xyXG4gICAgICBsZXQgaGl0SW5mbzogUmF5SGl0SW5mbyA9IG5ldyBSYXlIaXRJbmZvKCk7XHJcbiAgICAgIGxldCBnZW9tZXRyeTogT0lNTy5HZW9tZXRyeSA9IHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKS5nZXRHZW9tZXRyeSgpO1xyXG4gICAgICBsZXQgdHJhbnNmb3JtOiBPSU1PLlRyYW5zZm9ybSA9IHRoaXMuI3JpZ2lkYm9keS5nZXRUcmFuc2Zvcm0oKTtcclxuICAgICAgbGV0IHNjYWxlZERpcmVjdGlvbjogVmVjdG9yMyA9IF9kaXJlY3Rpb24uY2xvbmU7XHJcbiAgICAgIHNjYWxlZERpcmVjdGlvbi5zY2FsZShfbGVuZ3RoKTtcclxuICAgICAgbGV0IGVuZHBvaW50OiBWZWN0b3IzID0gVmVjdG9yMy5TVU0oc2NhbGVkRGlyZWN0aW9uLCBfb3JpZ2luLmNsb25lKTtcclxuICAgICAgbGV0IG9pbW9SYXk6IE9JTU8uUmF5Q2FzdEhpdCA9IG5ldyBPSU1PLlJheUNhc3RIaXQoKTtcclxuICAgICAgbGV0IGhpdDogYm9vbGVhbiA9IGdlb21ldHJ5LnJheUNhc3QobmV3IE9JTU8uVmVjMyhfb3JpZ2luLngsIF9vcmlnaW4ueSwgX29yaWdpbi56KSwgbmV3IE9JTU8uVmVjMyhlbmRwb2ludC54LCBlbmRwb2ludC55LCBlbmRwb2ludC56KSwgdHJhbnNmb3JtLCBvaW1vUmF5KTsgLy90aGUgYWN0dWFsIE9pbW9QaHlzaWNzIFJheWNhc3RcclxuICAgICAgaWYgKGhpdCkgeyAgLy9JZiBoaXQgcmV0dXJuIGEgYnVuY2ggb2YgaW5mb3JtYXRpb25zIGFib3V0IHRoZSBoaXRcclxuICAgICAgICBoaXRJbmZvLmhpdCA9IHRydWU7XHJcbiAgICAgICAgaGl0SW5mby5oaXRQb2ludCA9IG5ldyBWZWN0b3IzKG9pbW9SYXkucG9zaXRpb24ueCwgb2ltb1JheS5wb3NpdGlvbi55LCBvaW1vUmF5LnBvc2l0aW9uLnopO1xyXG4gICAgICAgIGhpdEluZm8uaGl0Tm9ybWFsID0gbmV3IFZlY3RvcjMob2ltb1JheS5ub3JtYWwueCwgb2ltb1JheS5ub3JtYWwueSwgb2ltb1JheS5ub3JtYWwueik7XHJcbiAgICAgICAgbGV0IGR4OiBudW1iZXIgPSBfb3JpZ2luLnggLSBoaXRJbmZvLmhpdFBvaW50Lng7ICAvL2NhbGN1bGF0ZSBoaXQgZGlzdGFuY2VcclxuICAgICAgICBsZXQgZHk6IG51bWJlciA9IF9vcmlnaW4ueSAtIGhpdEluZm8uaGl0UG9pbnQueTtcclxuICAgICAgICBsZXQgZHo6IG51bWJlciA9IF9vcmlnaW4ueiAtIGhpdEluZm8uaGl0UG9pbnQuejtcclxuICAgICAgICBoaXRJbmZvLmhpdERpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XHJcbiAgICAgICAgaGl0SW5mby5yaWdpZGJvZHlDb21wb25lbnQgPSB0aGlzO1xyXG4gICAgICAgIGhpdEluZm8ucmF5T3JpZ2luID0gX29yaWdpbjtcclxuICAgICAgICBoaXRJbmZvLnJheUVuZCA9IGVuZHBvaW50O1xyXG4gICAgICB9IGVsc2UgeyAvL09ubHkgdGVsbCB0aGUgb3JpZ2luLCBhbmQgdGhlIGhpdCBwb2ludCBpcyB0aGUgZW5kIG9mIHRoZSByYXkuXHJcbiAgICAgICAgaGl0SW5mby5yYXlPcmlnaW4gPSBfb3JpZ2luO1xyXG4gICAgICAgIGhpdEluZm8uaGl0UG9pbnQgPSBuZXcgVmVjdG9yMyhlbmRwb2ludC54LCBlbmRwb2ludC55LCBlbmRwb2ludC56KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoX2RlYnVnRHJhdykge1xyXG4gICAgICAgIFBoeXNpY3MuZGVidWdEcmF3LmRlYnVnUmF5KGhpdEluZm8ucmF5T3JpZ2luLCBoaXRJbmZvLmhpdFBvaW50LCBuZXcgQ29sb3IoMCwgMSwgMCwgMSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBoaXRJbmZvO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZyAtIFNvbWUgcHJvcGVydGllcyBtaWdodCBiZSBtaXNzaW5nLCBlLmcuIGNvbnZleE1lc2ggKEZsb2F0MzJBcnJheSlcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy5nZXRNdXRhdG9yKCk7XHJcblxyXG4gICAgICBkZWxldGUgc2VyaWFsaXphdGlvbi5tdHhQaXZvdDtcclxuICAgICAgZGVsZXRlIHNlcmlhbGl6YXRpb24uYWN0aXZlO1xyXG5cclxuICAgICAgc2VyaWFsaXphdGlvbi50eXBlQm9keSA9IEJPRFlfVFlQRVt0aGlzLiN0eXBlQm9keV07XHJcbiAgICAgIHNlcmlhbGl6YXRpb24udHlwZUNvbGxpZGVyID0gQ09MTElERVJfVFlQRVt0aGlzLiN0eXBlQ29sbGlkZXJdO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmluaXRpYWxpemF0aW9uID0gQk9EWV9JTklUW3RoaXMuaW5pdGlhbGl6YXRpb25dO1xyXG5cclxuICAgICAgc2VyaWFsaXphdGlvbi5pZCA9IHRoaXMuI2lkO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLnBpdm90ID0gdGhpcy5tdHhQaXZvdC5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHRoaXMubXR4UGl2b3QuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24ucGl2b3QpO1xyXG4gICAgICB0aGlzLiNpZCA9IF9zZXJpYWxpemF0aW9uLmlkO1xyXG4gICAgICB0aGlzLm1hc3MgPSBpZk51bWJlcihfc2VyaWFsaXphdGlvbi5tYXNzLCB0aGlzLm1hc3MpO1xyXG4gICAgICB0aGlzLmRhbXBUcmFuc2xhdGlvbiA9IGlmTnVtYmVyKF9zZXJpYWxpemF0aW9uLmRhbXBUcmFuc2xhdGlvbiwgdGhpcy5kYW1wVHJhbnNsYXRpb24pO1xyXG4gICAgICB0aGlzLmRhbXBSb3RhdGlvbiA9IGlmTnVtYmVyKF9zZXJpYWxpemF0aW9uLmRhbXBSb3RhdGlvbiwgdGhpcy5kYW1wUm90YXRpb24pO1xyXG4gICAgICB0aGlzLmNvbGxpc2lvbkdyb3VwID0gaWZOdW1iZXIoX3NlcmlhbGl6YXRpb24uY29sbGlzaW9uR3JvdXAsIHRoaXMuY29sbGlzaW9uR3JvdXApO1xyXG4gICAgICB0aGlzLmVmZmVjdFJvdGF0aW9uID0gX3NlcmlhbGl6YXRpb24uZWZmZWN0Um90YXRpb24gfHwgdGhpcy5lZmZlY3RSb3RhdGlvbjtcclxuICAgICAgdGhpcy5lZmZlY3RHcmF2aXR5ID0gaWZOdW1iZXIoX3NlcmlhbGl6YXRpb24uZWZmZWN0R3Jhdml0eSwgdGhpcy5lZmZlY3RHcmF2aXR5KTtcclxuICAgICAgdGhpcy5mcmljdGlvbiA9IGlmTnVtYmVyKF9zZXJpYWxpemF0aW9uLmZyaWN0aW9uLCB0aGlzLmZyaWN0aW9uKTtcclxuICAgICAgdGhpcy5yZXN0aXR1dGlvbiA9IGlmTnVtYmVyKF9zZXJpYWxpemF0aW9uLnJlc3RpdHV0aW9uLCB0aGlzLnJlc3RpdHV0aW9uKTtcclxuICAgICAgdGhpcy5pc1RyaWdnZXIgPSBfc2VyaWFsaXphdGlvbi5pc1RyaWdnZXIgfHwgdGhpcy5pc1RyaWdnZXI7XHJcbiAgICAgIHRoaXMuaW5pdGlhbGl6YXRpb24gPSBfc2VyaWFsaXphdGlvbi5pbml0aWFsaXphdGlvbjtcclxuXHJcbiAgICAgIHRoaXMuaW5pdGlhbGl6YXRpb24gPSA8bnVtYmVyPjx1bmtub3duPkJPRFlfSU5JVFtfc2VyaWFsaXphdGlvbi5pbml0aWFsaXphdGlvbl07XHJcbiAgICAgIHRoaXMudHlwZUJvZHkgPSA8bnVtYmVyPjx1bmtub3duPkJPRFlfVFlQRVtfc2VyaWFsaXphdGlvbi50eXBlQm9keV07XHJcbiAgICAgIHRoaXMudHlwZUNvbGxpZGVyID0gPG51bWJlcj48dW5rbm93bj5DT0xMSURFUl9UWVBFW19zZXJpYWxpemF0aW9uLnR5cGVDb2xsaWRlcl07XHJcbiAgICAgIC8vIHRoaXMuY3JlYXRlKHRoaXMubWFzcywgdGhpcy4jdHlwZUJvZHksIHRoaXMuI3R5cGVDb2xsaWRlciwgdGhpcy5jb2xsaXNpb25Hcm91cCwgbnVsbCwgdGhpcy5jb252ZXhNZXNoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENoYW5nZSBwcm9wZXJ0aWVzIGJ5IGFuIGFzc29jaWF0aXZlIGFycmF5ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgaWYgKF9tdXRhdG9yLnR5cGVCb2R5ICE9IHVuZGVmaW5lZClcclxuICAgICAgICBfbXV0YXRvci50eXBlQm9keSA9IHBhcnNlSW50KF9tdXRhdG9yLnR5cGVCb2R5KTtcclxuICAgICAgaWYgKF9tdXRhdG9yLnR5cGVDb2xsaWRlciAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgX211dGF0b3IudHlwZUNvbGxpZGVyID0gcGFyc2VJbnQoX211dGF0b3IudHlwZUNvbGxpZGVyKTtcclxuICAgICAgaWYgKF9tdXRhdG9yLmluaXRpYWxpemF0aW9uICE9IHVuZGVmaW5lZClcclxuICAgICAgICBfbXV0YXRvci5pbml0aWFsaXphdGlvbiA9IHBhcnNlSW50KF9tdXRhdG9yLmluaXRpYWxpemF0aW9uKTtcclxuICAgICAgYXdhaXQgc3VwZXIubXV0YXRlKF9tdXRhdG9yLCBfc2VsZWN0aW9uLCBfZGlzcGF0Y2hNdXRhdGUpO1xyXG4gICAgICBpZiAoX211dGF0b3IuaW5pdGlhbGl6YXRpb24gIT0gdW5kZWZpbmVkICYmIHRoaXMuaXNBY3RpdmUpXHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgICAgIC8vIFRPRE86IHNlZSBpZiB0aGlzIGFsdGVybmF0aXZlIHNob3VsZCBiZSwgYXQgbGVhc3QgcGFydGlhbGx5LCBkb25lIHdpdGggbXV0YXRlU2VsZWN0aW9uXHJcbiAgICAgIC8vIGxldCBjYWxsSWZFeGlzdDogRnVuY3Rpb24gPSAoX2tleTogc3RyaW5nLCBfc2V0dGVyOiBGdW5jdGlvbikgPT4ge1xyXG4gICAgICAvLyAgIGlmIChfbXV0YXRvcltfa2V5XSlcclxuICAgICAgLy8gICAgIF9zZXR0ZXIoX211dGF0b3JbX2tleV0pO1xyXG4gICAgICAvLyB9O1xyXG5cclxuICAgICAgLy8gY2FsbElmRXhpc3QoXCJmcmljdGlvblwiLCAoX3ZhbHVlOiBudW1iZXIpID0+IHRoaXMuZnJpY3Rpb24gPSBfdmFsdWUpO1xyXG4gICAgICAvLyBjYWxsSWZFeGlzdChcInJlc3RpdHV0aW9uXCIsIChfdmFsdWU6IG51bWJlcikgPT4gdGhpcy5yZXN0aXR1dGlvbiA9IF92YWx1ZSk7XHJcbiAgICAgIC8vIGNhbGxJZkV4aXN0KFwibWFzc1wiLCAoX3ZhbHVlOiBudW1iZXIpID0+IHRoaXMubWFzcyA9IF92YWx1ZSk7XHJcbiAgICAgIC8vIGNhbGxJZkV4aXN0KFwiZGFtcFRyYW5zbGF0aW9uXCIsIChfdmFsdWU6IG51bWJlcikgPT4gdGhpcy5kYW1wVHJhbnNsYXRpb24gPSBfdmFsdWUpO1xyXG4gICAgICAvLyBjYWxsSWZFeGlzdChcImRhbXBSb3RhdGlvblwiLCAoX3ZhbHVlOiBudW1iZXIpID0+IHRoaXMuZGFtcFJvdGF0aW9uID0gX3ZhbHVlKTtcclxuICAgICAgLy8gY2FsbElmRXhpc3QoXCJlZmZlY3RHcmF2aXR5XCIsIChfdmFsdWU6IG51bWJlcikgPT4gdGhpcy5lZmZlY3RHcmF2aXR5ID0gX3ZhbHVlKTtcclxuICAgICAgLy8gY2FsbElmRXhpc3QoXCJjb2xsaXNpb25Hcm91cFwiLCAoX3ZhbHVlOiBDT0xMSVNJT05fR1JPVVApID0+IHRoaXMuY29sbGlzaW9uR3JvdXAgPSBfdmFsdWUpO1xyXG4gICAgICAvLyBjYWxsSWZFeGlzdChcInR5cGVCb2R5XCIsIChfdmFsdWU6IHN0cmluZykgPT4gdGhpcy50eXBlQm9keSA9IHBhcnNlSW50KF92YWx1ZSkpO1xyXG4gICAgICAvLyBjYWxsSWZFeGlzdChcInR5cGVDb2xsaWRlclwiLCAoX3ZhbHVlOiBzdHJpbmcpID0+IHRoaXMudHlwZUNvbGxpZGVyID0gcGFyc2VJbnQoX3ZhbHVlKSk7XHJcblxyXG4gICAgICAvLyB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULk1VVEFURSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IodHJ1ZSk7XHJcblxyXG4gICAgICBtdXRhdG9yLmZyaWN0aW9uID0gdGhpcy5mcmljdGlvbjtcclxuICAgICAgbXV0YXRvci5yZXN0aXR1dGlvbiA9IHRoaXMucmVzdGl0dXRpb247XHJcbiAgICAgIG11dGF0b3IubWFzcyA9IHRoaXMubWFzcztcclxuICAgICAgbXV0YXRvci5kYW1wVHJhbnNsYXRpb24gPSB0aGlzLmRhbXBUcmFuc2xhdGlvbjtcclxuICAgICAgbXV0YXRvci5kYW1wUm90YXRpb24gPSB0aGlzLmRhbXBSb3RhdGlvbjtcclxuICAgICAgbXV0YXRvci5lZmZlY3RHcmF2aXR5ID0gdGhpcy5lZmZlY3RHcmF2aXR5O1xyXG4gICAgICBtdXRhdG9yLnR5cGVCb2R5ID0gdGhpcy4jdHlwZUJvZHk7XHJcbiAgICAgIG11dGF0b3IudHlwZUNvbGxpZGVyID0gdGhpcy4jdHlwZUNvbGxpZGVyO1xyXG4gICAgICBtdXRhdG9yLmlzVHJpZ2dlciA9IHRoaXMuI2lzVHJpZ2dlcjtcclxuXHJcbiAgICAgIC8vIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhtdXRhdG9yKTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0gc3VwZXIuZ2V0TXV0YXRvckF0dHJpYnV0ZVR5cGVzKF9tdXRhdG9yKTtcclxuICAgICAgaWYgKHR5cGVzLnR5cGVCb2R5KVxyXG4gICAgICAgIHR5cGVzLnR5cGVCb2R5ID0gQk9EWV9UWVBFO1xyXG4gICAgICBpZiAodHlwZXMudHlwZUNvbGxpZGVyKVxyXG4gICAgICAgIHR5cGVzLnR5cGVDb2xsaWRlciA9IENPTExJREVSX1RZUEU7XHJcbiAgICAgIGlmICh0eXBlcy5pbml0aWFsaXphdGlvbilcclxuICAgICAgICB0eXBlcy5pbml0aWFsaXphdGlvbiA9IEJPRFlfSU5JVDtcclxuICAgICAgcmV0dXJuIHR5cGVzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZWR1Y2VNdXRhdG9yKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCB7XHJcbiAgICAgIHN1cGVyLnJlZHVjZU11dGF0b3IoX211dGF0b3IpO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuY29udmV4TWVzaDsgLy9Db252ZXggTWVzaCBjYW4ndCBiZSBzaG93biBpbiB0aGUgZWRpdG9yIGJlY2F1c2UgZmxvYXQzMkFycmF5IGlzIG5vdCBhIHZpYWJsZSBtdXRhdG9yXHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5jb2xsaXNpb25NYXNrO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IuaXNJbml0aWFsaXplZDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vIEFjdGl2YXRlIHRoZSBmdW5jdGlvbnMgb2YgdGhpcyBjb21wb25lbnQgYXMgcmVzcG9uc2UgdG8gZXZlbnRzXHJcbiAgICBwcml2YXRlIGhuZEV2ZW50ID0gKF9ldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgc3dpdGNoIChfZXZlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgRVZFTlQuQ09NUE9ORU5UX0FERDpcclxuICAgICAgICAgIC8vIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5DT01QT05FTlRfQUNUSVZBVEUsIHRoaXMuYWRkUmlnaWRib2R5VG9Xb3JsZCk7XHJcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX0RFQUNUSVZBVEUsIHRoaXMucmVtb3ZlUmlnaWRib2R5RnJvbVdvcmxkKTtcclxuICAgICAgICAgIC8vIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfQUNUSVZBVEUsIHRoaXMuYWRkUmlnaWRib2R5VG9Xb3JsZCwgdHJ1ZSk7IC8vIHVzZSBjYXB0dXJlIHRvIHJlYWN0IHRvIGJyb2FkY2FzdCFcclxuICAgICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKEVWRU5ULk5PREVfREVBQ1RJVkFURSwgdGhpcy5obmROb2RlRGVhY3RpdmF0ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICBpZiAoIXRoaXMubm9kZS5jbXBUcmFuc2Zvcm0pXHJcbiAgICAgICAgICAgIERlYnVnLndhcm4oXCJDb21wb25lbnRSaWdpZGJvZHkgYXR0YWNoZWQgdG8gbm9kZSBtaXNzaW5nIENvbXBvbmVudFRyYW5zZm9ybVwiLCB0aGlzLm5vZGUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBFVkVOVC5DT01QT05FTlRfUkVNT1ZFOlxyXG4gICAgICAgICAgLy8gdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5ULkNPTVBPTkVOVF9BREQsIHRoaXMuYWRkUmlnaWRib2R5VG9Xb3JsZCk7XHJcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuQ09NUE9ORU5UX1JFTU9WRSwgdGhpcy5yZW1vdmVSaWdpZGJvZHlGcm9tV29ybGQpO1xyXG4gICAgICAgICAgLy8gdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9BQ1RJVkFURSwgdGhpcy5hZGRSaWdpZGJvZHlUb1dvcmxkLCB0cnVlKTsgLy8gdXNlIGNhcHR1cmUgdG8gcmVhY3QgdG8gYnJvYWRjYXN0IVxyXG4gICAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuTk9ERV9ERUFDVElWQVRFLCB0aGlzLmhuZE5vZGVEZWFjdGl2YXRlLCB0cnVlKTtcclxuICAgICAgICAgIHRoaXMucmVtb3ZlUmlnaWRib2R5RnJvbVdvcmxkKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEVWRU5ULk5PREVfREVTRVJJQUxJWkVEOlxyXG4gICAgICAgICAgaWYgKCF0aGlzLm5vZGUuY21wVHJhbnNmb3JtKVxyXG4gICAgICAgICAgICBEZWJ1Zy5lcnJvcihcIkNvbXBvbmVudFJpZ2lkYm9keSBhdHRhY2hlZCB0byBub2RlIG1pc3NpbmcgQ29tcG9uZW50VHJhbnNmb3JtXCIsIHRoaXMubm9kZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyNyZWdpb24gQ3JlYXRpb25cclxuICAgIHByaXZhdGUgY3JlYXRlKF9tYXNzOiBudW1iZXIgPSAxLCBfdHlwZTogQk9EWV9UWVBFID0gQk9EWV9UWVBFLkRZTkFNSUMsIF9jb2xsaWRlclR5cGU6IENPTExJREVSX1RZUEUgPSBDT0xMSURFUl9UWVBFLkNVQkUsIF9ncm91cDogQ09MTElTSU9OX0dST1VQID0gUGh5c2ljcy5zZXR0aW5ncy5kZWZhdWx0Q29sbGlzaW9uR3JvdXAsIF9tdHhUcmFuc2Zvcm06IE1hdHJpeDR4NCA9IG51bGwsIF9jb252ZXhNZXNoOiBGbG9hdDMyQXJyYXkgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIC8vU2V0dGluZyB1cCBhbGwgaW5jb21pbmcgdmFsdWVzIHRvIGJlIGludGVybmFsIHZhbHVlc1xyXG4gICAgICB0aGlzLmNvbnZleE1lc2ggPSBfY29udmV4TWVzaDtcclxuICAgICAgdGhpcy4jdHlwZUJvZHkgPSBfdHlwZTtcclxuICAgICAgdGhpcy4jY29sbGlzaW9uR3JvdXAgPSBfZ3JvdXA7XHJcbiAgICAgIHRoaXMuI3R5cGVDb2xsaWRlciA9IF9jb2xsaWRlclR5cGU7XHJcbiAgICAgIHRoaXMubWFzcyA9IF9tYXNzO1xyXG4gICAgICB0aGlzLiNyZXN0aXR1dGlvbiA9IFBoeXNpY3Muc2V0dGluZ3MuZGVmYXVsdFJlc3RpdHV0aW9uO1xyXG4gICAgICB0aGlzLiNmcmljdGlvbiA9IFBoeXNpY3Muc2V0dGluZ3MuZGVmYXVsdEZyaWN0aW9uO1xyXG4gICAgICB0aGlzLmNvbGxpc2lvbk1hc2sgPSBQaHlzaWNzLnNldHRpbmdzLmRlZmF1bHRDb2xsaXNpb25NYXNrO1xyXG4gICAgICAvL0NyZWF0ZSB0aGUgYWN0dWFsIHJpZ2lkYm9keSBpbiB0aGUgT2ltb1BoeXNpY3MgU3BhY2VcclxuICAgICAgdGhpcy5jcmVhdGVSaWdpZGJvZHkoX21hc3MsIF90eXBlLCB0aGlzLiN0eXBlQ29sbGlkZXIsIF9tdHhUcmFuc2Zvcm0sIHRoaXMuI2NvbGxpc2lvbkdyb3VwKTtcclxuICAgICAgdGhpcy4jaWQgPSBQaHlzaWNzLmRpc3RyaWJ1dGVCb2R5SUQoKTtcclxuXHJcbiAgICAgIC8vIEV2ZW50IENhbGxiYWNrcyBkaXJlY3RseSBmcm9tIE9JTU8gUGh5c2ljc1xyXG4gICAgICB0aGlzLiNjYWxsYmFja3MgPSBuZXcgT0lNTy5Db250YWN0Q2FsbGJhY2soKTsgLy9mZWhtXHJcbiAgICAgIHRoaXMuI2NhbGxiYWNrcy5iZWdpblRyaWdnZXJDb250YWN0ID0gdGhpcy50cmlnZ2VyRW50ZXI7XHJcbiAgICAgIHRoaXMuI2NhbGxiYWNrcy5lbmRUcmlnZ2VyQ29udGFjdCA9IHRoaXMudHJpZ2dlckV4aXQ7XHJcbiAgICAgIHRoaXMuI2NhbGxiYWNrcy5wb3N0U29sdmUgPSB0aGlzLmNvbGxpc2lvbkVudGVyOyAvLyB1c2UgcG9zdFNvbHZlIGZvciBjb2xsaXNpb25FbnRlciB0byBnZXQgdGhlIGltcHVsc2VcclxuICAgICAgdGhpcy4jY2FsbGJhY2tzLmVuZENvbnRhY3QgPSB0aGlzLmNvbGxpc2lvbkV4aXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENyZWF0ZXMgdGhlIGFjdHVhbCBPaW1vUGh5c2ljcyBSaWdpZGJvZHkgb3V0IG9mIGluZm9ybWF0aW9ucyB0aGUgRlVER0UgQ29tcG9uZW50IGhhcy4gKi9cclxuICAgIHByaXZhdGUgY3JlYXRlUmlnaWRib2R5KF9tYXNzOiBudW1iZXIsIF90eXBlOiBCT0RZX1RZUEUsIF9jb2xsaWRlclR5cGU6IENPTExJREVSX1RZUEUsIF9tdHhUcmFuc2Zvcm06IE1hdHJpeDR4NCwgX2NvbGxpc2lvbkdyb3VwOiBDT0xMSVNJT05fR1JPVVAgPSBDT0xMSVNJT05fR1JPVVAuREVGQVVMVCk6IHZvaWQge1xyXG4gICAgICBsZXQgb2ltb1R5cGU6IG51bWJlcjsgLy9OZWVkIHRoZSBjb252ZXJzaW9uIGZyb20gc2ltcGxlIGVudW0gdG8gbnVtYmVyIGJlY2F1c2UgaWYgZW51bSBpcyBkZWZpbmVkIGFzIE9pbW8uUmlnaWR5Qm9keVR5cGUgeW91IGhhdmUgdG8gaW5jbHVkZSBPaW1vIHRvIHVzZSBGVURHRSBhdCBhbGxcclxuICAgICAgc3dpdGNoIChfdHlwZSkge1xyXG4gICAgICAgIGNhc2UgQk9EWV9UWVBFLkRZTkFNSUM6XHJcbiAgICAgICAgICBvaW1vVHlwZSA9IE9JTU8uUmlnaWRCb2R5VHlwZS5EWU5BTUlDO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCT0RZX1RZUEUuU1RBVElDOlxyXG4gICAgICAgICAgb2ltb1R5cGUgPSBPSU1PLlJpZ2lkQm9keVR5cGUuU1RBVElDO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBCT0RZX1RZUEUuS0lORU1BVElDOlxyXG4gICAgICAgICAgb2ltb1R5cGUgPSBPSU1PLlJpZ2lkQm9keVR5cGUuS0lORU1BVElDO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIG9pbW9UeXBlID0gT0lNTy5SaWdpZEJvZHlUeXBlLkRZTkFNSUM7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcmVtb3ZlIGFsbCBwcmV2aW91cyBzaGFwZXMgZnJvbSB3b3JsZC4gTmVjZXNzYXJ5P1xyXG4gICAgICAvLyB3aGlsZSAodGhpcy4jcmlnaWRib2R5ICYmIHRoaXMuI3JpZ2lkYm9keS5nZXRTaGFwZUxpc3QoKSAhPSBudWxsKVxyXG4gICAgICAvLyAgIHRoaXMuI3JpZ2lkYm9keS5yZW1vdmVTaGFwZSh0aGlzLiNyaWdpZGJvZHkuZ2V0U2hhcGVMaXN0KCkpO1xyXG5cclxuICAgICAgbGV0IHRtcFRyYW5zZm9ybTogTWF0cml4NHg0ID0gX210eFRyYW5zZm9ybSA9PSBudWxsID8gc3VwZXIubm9kZSAhPSBudWxsID8gc3VwZXIubm9kZS5tdHhXb3JsZCA6IE1hdHJpeDR4NC5JREVOVElUWSgpIDogX210eFRyYW5zZm9ybTsgLy9HZXQgdHJhbnNmb3JtIGluZm9ybWF0aW9ucyBmcm9tIHRoZSB3b3JsZCwgc2luY2UgcGh5c2ljcyBkb2VzIG5vdCBjYXJlIGFib3V0IGhpZXJhcmNoeVxyXG4gICAgICAvL0NvbnZlcnQgaW5mb3JtYXRpb25zIGZyb20gRlVER0UgdG8gT2ltb1BoeXNpY3MgYW5kIGNyZWF0aW5nIGEgY29sbGlkZXIgd2l0aCBpdCwgd2hpbGUgYWxzbyBhZGRpbmcgYSBwaXZvdCB0byBkZXJpdmF0ZSBmcm9tIHRoZSB0cmFuc2Zvcm0gaW5mb3JtYXRpb25zIGlmIG5lZWRlZFxyXG4gICAgICBsZXQgc2NhbGU6IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzMoKHRtcFRyYW5zZm9ybS5zY2FsaW5nLnggKiB0aGlzLm10eFBpdm90LnNjYWxpbmcueCkgLyAyLCAodG1wVHJhbnNmb3JtLnNjYWxpbmcueSAqIHRoaXMubXR4UGl2b3Quc2NhbGluZy55KSAvIDIsICh0bXBUcmFuc2Zvcm0uc2NhbGluZy56ICogdGhpcy5tdHhQaXZvdC5zY2FsaW5nLnopIC8gMik7XHJcbiAgICAgIGxldCBwb3NpdGlvbjogT0lNTy5WZWMzID0gbmV3IE9JTU8uVmVjMyh0bXBUcmFuc2Zvcm0udHJhbnNsYXRpb24ueCArIHRoaXMubXR4UGl2b3QudHJhbnNsYXRpb24ueCwgdG1wVHJhbnNmb3JtLnRyYW5zbGF0aW9uLnkgKyB0aGlzLm10eFBpdm90LnRyYW5zbGF0aW9uLnksIHRtcFRyYW5zZm9ybS50cmFuc2xhdGlvbi56ICsgdGhpcy5tdHhQaXZvdC50cmFuc2xhdGlvbi56KTtcclxuICAgICAgbGV0IHJvdGF0aW9uOiBPSU1PLlZlYzMgPSBuZXcgT0lNTy5WZWMzKHRtcFRyYW5zZm9ybS5yb3RhdGlvbi54ICsgdGhpcy5tdHhQaXZvdC5yb3RhdGlvbi54LCB0bXBUcmFuc2Zvcm0ucm90YXRpb24ueSArIHRoaXMubXR4UGl2b3Qucm90YXRpb24ueSwgdG1wVHJhbnNmb3JtLnJvdGF0aW9uLnogKyB0aGlzLm10eFBpdm90LnJvdGF0aW9uLnopO1xyXG4gICAgICB0aGlzLmNyZWF0ZUNvbGxpZGVyKHNjYWxlLCBfY29sbGlkZXJUeXBlKTtcclxuICAgICAgLy9TZXR0aW5nIGluZm9ybWF0aW9ucyBhYm91dCBtYXNzLCBwb3NpdGlvbi9yb3RhdGlvbiBhbmQgcGh5c2ljYWwgcmVhY3Rpb24gdHlwZVxyXG4gICAgICB0aGlzLiNtYXNzRGF0YS5tYXNzID0gX21hc3M7IC8vX3R5cGUgIT0gUEhZU0lDU19UWVBFLlNUQVRJQyA/IF9tYXNzIDogMDsgLy9JZiBhIG9iamVjdCBpcyBzdGF0aWMgaXQgYWN0cyBhcyBpZiBpdCBoYXMgbm8gbWFzc1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHlJbmZvLnR5cGUgPSBvaW1vVHlwZTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5SW5mby5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHlJbmZvLnJvdGF0aW9uLmZyb21FdWxlclh5eihuZXcgT0lNTy5WZWMzKHJvdGF0aW9uLngsIHJvdGF0aW9uLnksIHJvdGF0aW9uLnopKTsgLy9Db252ZXJ0IGV1bGVyQW5nbGVzIGluIGRlZ3JlZSB0byB0aGUgaW50ZXJuYWxseSB1c2VkIHF1YXRlcm5pb25zXHJcbiAgICAgIC8vQ3JlYXRpbmcgdGhlIGFjdHVhbCByaWdpZGJvZHkgYW5kIGl0J3MgY29sbGlkZXJcclxuICAgICAgdGhpcy4jcmlnaWRib2R5ID0gbmV3IE9JTU8uUmlnaWRCb2R5KHRoaXMuI3JpZ2lkYm9keUluZm8pO1xyXG4gICAgICB0aGlzLiNjb2xsaWRlciA9IG5ldyBPSU1PLlNoYXBlKHRoaXMuI2NvbGxpZGVySW5mbyk7XHJcbiAgICAgIC8vRmlsbGluZyB0aGUgYWRkaXRpb25hbCBzZXR0aW5ncyBhbmQgaW5mb3JtYXRpb25zIHRoZSByaWdpZGJvZHkgbmVlZHMuIFdobyBpcyBjb2xsaWRpbmcsIGhvdyBpcyB0aGUgY29sbGlzaW9uIGhhbmRsZWQgKGRhbXBpbmcsIGluZmx1ZW5jZSBmYWN0b3JzKVxyXG4gICAgICB0aGlzLiNjb2xsaWRlci51c2VyRGF0YSA9IHRoaXM7XHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyLnNldENvbGxpc2lvbkdyb3VwKF9jb2xsaXNpb25Hcm91cCk7XHJcbiAgICAgIHRoaXMuI2NvbGxpZGVyLnNldENvbGxpc2lvbk1hc2sodGhpcy5jb2xsaXNpb25NYXNrKTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmFkZFNoYXBlKHRoaXMuI2NvbGxpZGVyKTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldE1hc3NEYXRhKHRoaXMuI21hc3NEYXRhKTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpLnNldFJlc3RpdHV0aW9uKHRoaXMuI3Jlc3RpdHV0aW9uKTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpLnNldEZyaWN0aW9uKHRoaXMuI2ZyaWN0aW9uKTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LmdldFNoYXBlTGlzdCgpLnNldENvbnRhY3RDYWxsYmFjayh0aGlzLiNjYWxsYmFja3MpO1xyXG4gICAgICB0aGlzLiNyaWdpZGJvZHkuc2V0TGluZWFyRGFtcGluZyh0aGlzLiNkYW1waW5nTGluZWFyKTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldEFuZ3VsYXJEYW1waW5nKHRoaXMuI2RhbXBpbmdBbmd1bGFyKTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldEdyYXZpdHlTY2FsZSh0aGlzLiNlZmZlY3RHcmF2aXR5KTtcclxuICAgICAgdGhpcy4jcmlnaWRib2R5LnNldFJvdGF0aW9uRmFjdG9yKG5ldyBPSU1PLlZlYzModGhpcy4jZWZmZWN0Um90YXRpb24ueCwgdGhpcy4jZWZmZWN0Um90YXRpb24ueSwgdGhpcy4jZWZmZWN0Um90YXRpb24ueikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGVzIGEgY29sbGlkZXIgYSBzaGFwZSB0aGF0IHJlcHJlc2VudHMgdGhlIG9iamVjdCBpbiB0aGUgcGh5c2ljYWwgd29ybGQuICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVDb2xsaWRlcihfc2NhbGU6IE9JTU8uVmVjMywgX2NvbGxpZGVyVHlwZTogQ09MTElERVJfVFlQRSk6IHZvaWQge1xyXG4gICAgICBsZXQgc2hhcGVDb25mOiBPSU1PLlNoYXBlQ29uZmlnID0gbmV3IE9JTU8uU2hhcGVDb25maWcoKTsgLy9Db2xsaWRlciB3aXRoIGdlb21ldHJ5IGFuZCBpbmZvcyBsaWtlIGZyaWN0aW9uL3Jlc3RpdHV0aW9uIGFuZCBtb3JlXHJcbiAgICAgIGxldCBnZW9tZXRyeTogT0lNTy5HZW9tZXRyeTtcclxuICAgICAgaWYgKHRoaXMudHlwZUNvbGxpZGVyICE9IF9jb2xsaWRlclR5cGUpIC8vSWYgdGhlIGNvbGxpZGVyIHR5cGUgd2FzIGNoYW5nZWQgc2V0IHRoZSBpbnRlcm5hbCBvbmUgbmV3LCBlbHNlIGRvbid0IHNvIHRoZXJlIGlzIG5vdCBpbmZpbml0ZSBzZXQgY2FsbHNcclxuICAgICAgICB0aGlzLnR5cGVDb2xsaWRlciA9IF9jb2xsaWRlclR5cGU7XHJcbiAgICAgIHN3aXRjaCAoX2NvbGxpZGVyVHlwZSkgeyAgLy9DcmVhdGUgYSBkaWZmZXJlbnQgT2ltb1BoeXNpY3MgZ2VvbWV0cnkgYmFzZWQgb24gdGhlIGdpdmVuIHR5cGUuIFRoYXQgaXMgb25seSB0aGUgbWF0aGVtYXRpY2FsIHNoYXBlIG9mIHRoZSBjb2xsaWRlclxyXG4gICAgICAgIGNhc2UgQ09MTElERVJfVFlQRS5DVUJFOlxyXG4gICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgT0lNTy5Cb3hHZW9tZXRyeShfc2NhbGUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT0xMSURFUl9UWVBFLlNQSEVSRTpcclxuICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IE9JTU8uU3BoZXJlR2VvbWV0cnkoX3NjYWxlLngpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT0xMSURFUl9UWVBFLkNBUFNVTEU6XHJcbiAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBPSU1PLkNhcHN1bGVHZW9tZXRyeShfc2NhbGUueCwgX3NjYWxlLnkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBDT0xMSURFUl9UWVBFLkNZTElOREVSOlxyXG4gICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgT0lNTy5DeWxpbmRlckdlb21ldHJ5KF9zY2FsZS54LCBfc2NhbGUueSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIENPTExJREVSX1RZUEUuQ09ORTpcclxuICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IE9JTU8uQ29uZUdlb21ldHJ5KF9zY2FsZS54LCBfc2NhbGUueSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIENPTExJREVSX1RZUEUuUFlSQU1JRDpcclxuICAgICAgICAgIGdlb21ldHJ5ID0gdGhpcy5jcmVhdGVDb252ZXhHZW9tZXRyeUNvbGxpZGVyKHRoaXMuY3JlYXRlUHlyYW1pZFZlcnRpY2VzKCksIF9zY2FsZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIENPTExJREVSX1RZUEUuQ09OVkVYOlxyXG4gICAgICAgICAgZ2VvbWV0cnkgPSB0aGlzLmNyZWF0ZUNvbnZleEdlb21ldHJ5Q29sbGlkZXIodGhpcy5jb252ZXhNZXNoLCBfc2NhbGUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgc2hhcGVDb25mLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcbiAgICAgIHRoaXMuI2NvbGxpZGVySW5mbyA9IHNoYXBlQ29uZjsgLy90aGUgY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvbnMgdGhhdCBhcmUgdXNlZCB0byBhZGQgYW4gYWN0dWFsIGNvbGxpZGVyIHRvIHRoZSByaWdpZGJvZHkgaW4gY3JlYXRlUmlnaWRib2R5XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENyZWF0aW5nIGEgc2hhcGUgdGhhdCByZXByZXNlbnRzIGEgaW4gaXRzZWxmIGNsb3NlZCBmb3JtLCBvdXQgb2YgdGhlIGdpdmVuIHZlcnRpY2VzLiAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVDb252ZXhHZW9tZXRyeUNvbGxpZGVyKF92ZXJ0aWNlczogRmxvYXQzMkFycmF5LCBfc2NhbGU6IE9JTU8uVmVjMyk6IE9JTU8uQ29udmV4SHVsbEdlb21ldHJ5IHtcclxuICAgICAgbGV0IHZlcnRpY2VzQXNWZWMzOiBPSU1PLlZlYzNbXSA9IG5ldyBBcnJheSgpOyAvL0NvbnZlcnQgRlVER0UgVmVjdG9yMyB0byBPaW1vVmVjM1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgX3ZlcnRpY2VzLmxlbmd0aDsgaSArPSAzKSB7IC8vMyBWYWx1ZXMgZm9yIG9uZSBwb2ludFxyXG4gICAgICAgIHZlcnRpY2VzQXNWZWMzLnB1c2gobmV3IE9JTU8uVmVjMyhfdmVydGljZXNbaV0gKiBfc2NhbGUueCwgX3ZlcnRpY2VzW2kgKyAxXSAqIF9zY2FsZS55LCBfdmVydGljZXNbaSArIDJdICogX3NjYWxlLnopKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IE9JTU8uQ29udmV4SHVsbEdlb21ldHJ5KHZlcnRpY2VzQXNWZWMzKTsgLy9UZWxsIE9pbW9QaHlzaWNzIHRvIGNyZWF0ZSBhIGh1bGwgdGhhdCBpbnZvbHZlcyBhbGwgcG9pbnRzIGJ1dCBjbG9zZSBpdCBvZi4gQSBjb252ZXggc2hhcGUgY2FuIG5vdCBoYXZlIGEgaG9sZSBpbiBpdC5cclxuICAgIH1cclxuXHJcbiAgICAvKiogSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgdmVydGljZXMgdGhhdCBjb25zdHJ1Y3QgYSBweXJhbWlkLiBUaGUgdmVydGljZXMgb2YgdGhlIGltcGxlbWVudGVkIHB5cmFtaWQgbWVzaCBjYW4gYmUgdXNlZCB0b28uIEJ1dCB0aGV5IGFyZSBoYWxmZWQgYW5kIGRvdWJsZSBzaWRlZCwgc28gaXQncyBtb3JlIHBlcmZvcm1hbnQgdG8gdXNlIHRoaXMuICovXHJcbiAgICBwcml2YXRlIGNyZWF0ZVB5cmFtaWRWZXJ0aWNlcygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBsZXQgdmVydGljZXM6IEZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgIC8qMCovLTEsIDAsIDEsIC8qMSovIDEsIDAsIDEsICAvKjIqLyAxLCAwLCAtMSwgLyozKi8gLTEsIDAsIC0xLFxyXG4gICAgICAgIC8qNCovIDAsIDIsIDBcclxuICAgICAgXSk7XHJcbiAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgIH1cclxuXHJcbiAgICAvKiogQWRkaW5nIHRoaXMgQ29tcG9uZW50UmlnaWRib2R5IHRvIHRoZSBQaHlzaXNjcy53b3JsZCBnaXZpbmcgdGhlIG9pbW9QaHlzaWNzIHN5c3RlbSB0aGUgaW5mb3JtYXRpb24gbmVlZGVkICovXHJcbiAgICBwcml2YXRlIGFkZFJpZ2lkYm9keVRvV29ybGQgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgIGlmICghdGhpcy4jcmlnaWRib2R5Ll93b3JsZClcclxuICAgICAgICBQaHlzaWNzLmFkZFJpZ2lkYm9keSh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIENhcHR1cmUgb25seSBldmVudHMgdGhhdCBhcmUgYnJvYWRjYXN0IHRvIHRoaXMgbm9kZSBmcm9tIGFuIGFuY2VzdG9yLiBEb24ndCBjYXB0dXJlIGV2ZW50cyB0aGF0IGdldCBzZW5kIHRvIGRlc2NlbmRhbnRzLiAqL1xyXG4gICAgcHJpdmF0ZSBobmROb2RlRGVhY3RpdmF0ZSA9IChfZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgIGxldCBwYXRoOiBOb2RlW10gPSB0aGlzLm5vZGUuZ2V0UGF0aCgpO1xyXG4gICAgICBpZiAoIXBhdGguaW5jbHVkZXMoPE5vZGU+X2V2ZW50LnRhcmdldCkpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgdGhpcy5yZW1vdmVSaWdpZGJvZHlGcm9tV29ybGQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIFJlbW92aW5nIHRoaXMgQ29tcG9uZW50UmlnaWRib2R5IGZyb20gdGhlIFBoeXNpc2NzLndvcmxkIHRha2luZyB0aGUgaW5mb3JtYXRpb25zIGZyb20gdGhlIG9pbW9QaHlzaWNzIHN5c3RlbSAqL1xyXG4gICAgcHJpdmF0ZSByZW1vdmVSaWdpZGJvZHlGcm9tV29ybGQgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgIFBoeXNpY3MucmVtb3ZlUmlnaWRib2R5KHRoaXMpO1xyXG4gICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgLy8jcmVnaW9uIHByaXZhdGUgRVZFTlQgZnVuY3Rpb25zXHJcbiAgICAvL0NhbGN1bGF0aW5nIHRoZSBjZW50ZXIgb2YgYSBjb2xsaXNpb24gYXMgYSBzaW5ndWxhciBwb2ludCAtIGluIGNhc2UgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBwb2ludCAtIGJ5IGdldHRpbmcgdGhlIGdlb21ldHJpY2FsIGNlbnRlciBvZiBhbGwgY29sbGlkaW5nIHBvaW50c1xyXG4gICAgcHJpdmF0ZSBjb2xsaXNpb25DZW50ZXJQb2ludChfY29sUG9pbnRzOiBPSU1PLk1hbmlmb2xkUG9pbnRbXSwgX251bVBvaW50czogbnVtYmVyKTogVmVjdG9yMyB7XHJcbiAgICAgIGxldCB0b3RhbFBvaW50czogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHRvdGFsWDogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHRvdGFsWTogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IHRvdGFsWjogbnVtYmVyID0gMDtcclxuICAgICAgX2NvbFBvaW50cy5mb3JFYWNoKChfdmFsdWU6IE9JTU8uTWFuaWZvbGRQb2ludCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmICh0b3RhbFBvaW50cyA8IF9udW1Qb2ludHMpIHtcclxuICAgICAgICAgIHRvdGFsUG9pbnRzKys7XHJcbiAgICAgICAgICB0b3RhbFggKz0gX3ZhbHVlLmdldFBvc2l0aW9uMigpLng7XHJcbiAgICAgICAgICB0b3RhbFkgKz0gX3ZhbHVlLmdldFBvc2l0aW9uMigpLnk7XHJcbiAgICAgICAgICB0b3RhbFogKz0gX3ZhbHVlLmdldFBvc2l0aW9uMigpLno7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRvdGFsWCAvIF9udW1Qb2ludHMsIHRvdGFsWSAvIF9udW1Qb2ludHMsIHRvdGFsWiAvIF9udW1Qb2ludHMpOztcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByaXZhdGUgY29sbGlzaW9uRW50ZXIoX2NvbnRhY3Q6IE9JTU8uQ29udGFjdCk6IHZvaWQge1xyXG4gICAgICBsZXQgYm9keUE6IENvbXBvbmVudFJpZ2lkYm9keSA9IF9jb250YWN0LmdldFNoYXBlMSgpPy51c2VyRGF0YTtcclxuICAgICAgbGV0IGJvZHlCOiBDb21wb25lbnRSaWdpZGJvZHkgPSBfY29udGFjdC5nZXRTaGFwZTIoKT8udXNlckRhdGE7XHJcblxyXG4gICAgICBpZiAoIWJvZHlBIHx8ICFib2R5QiB8fCBib2R5QS5jb2xsaXNpb25zLmluY2x1ZGVzKGJvZHlCKSkgLy8gYWxyZWFkeSBlbnRlcmVkXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgYm9keUEuY29sbGlzaW9ucy5wdXNoKGJvZHlCKTtcclxuICAgICAgYm9keUIuY29sbGlzaW9ucy5wdXNoKGJvZHlBKTtcclxuXHJcbiAgICAgIC8vIFRPRE86IG1heWJlIHJhdGhlciBleHBvc2UgdGhlIG1hbmlmb2xkIHRvIHRoZSBldmVudCBvciBzb21ldGhpbmdcclxuICAgICAgbGV0IG1hbmlmb2xkOiBPSU1PLk1hbmlmb2xkID0gX2NvbnRhY3QuZ2V0TWFuaWZvbGQoKTtcclxuICAgICAgbGV0IHBvaW50czogT0lNTy5NYW5pZm9sZFBvaW50W10gPSBtYW5pZm9sZC5nZXRQb2ludHMoKTsgLy8gQWxsIHBvaW50cyBpbiB0aGUgY29sbGlzaW9uIHdoZXJlIHRoZSB0d28gYm9kaWVzIGFyZSB0b3VjaGluZywgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGZ1bGwgaW1wYWN0XHJcbiAgICAgIGxldCBub3JtYWxJbXB1bHNlOiBudW1iZXIgPSAwO1xyXG4gICAgICBsZXQgdGFuZ2VudEltcHVsc2U6IG51bWJlciA9IDA7XHJcbiAgICAgIGxldCBiaW5vcm1hbEltcHVsc2U6IG51bWJlciA9IDA7XHJcbiAgICAgIGZvciAobGV0IG1hbmlmb2xkUG9pbnQgb2YgcG9pbnRzKSB7IC8vIFRoZSBpbXBhY3Qgb2YgdGhlIGNvbGxpc2lvbiBpbnZvbHZpbmcgYWxsIHRvdWNoaW5nIHBvaW50c1xyXG4gICAgICAgIG5vcm1hbEltcHVsc2UgKz0gbWFuaWZvbGRQb2ludC5nZXROb3JtYWxJbXB1bHNlKCk7XHJcbiAgICAgICAgdGFuZ2VudEltcHVsc2UgKz0gbWFuaWZvbGRQb2ludC5nZXRUYW5nZW50SW1wdWxzZSgpO1xyXG4gICAgICAgIGJpbm9ybWFsSW1wdWxzZSArPSBtYW5pZm9sZFBvaW50LmdldEJpbm9ybWFsSW1wdWxzZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBub3JtYWw6IE9JTU8uVmVjMyA9IG1hbmlmb2xkLmdldE5vcm1hbCgpO1xyXG4gICAgICBsZXQgY29sbGlzaW9uTm9ybWFsOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7XHJcbiAgICAgIGxldCBjb2xsaXNpb25DZW50ZXJQb2ludDogVmVjdG9yMyA9IGJvZHlBLmNvbGxpc2lvbkNlbnRlclBvaW50KHBvaW50cywgbWFuaWZvbGQuZ2V0TnVtUG9pbnRzKCkpO1xyXG4gICAgICBib2R5QS5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudFBoeXNpY3MoRVZFTlRfUEhZU0lDUy5DT0xMSVNJT05fRU5URVIsIGJvZHlCLCBub3JtYWxJbXB1bHNlLCB0YW5nZW50SW1wdWxzZSwgYmlub3JtYWxJbXB1bHNlLCBjb2xsaXNpb25DZW50ZXJQb2ludCwgY29sbGlzaW9uTm9ybWFsKSk7XHJcbiAgICAgIGJvZHlCLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLkNPTExJU0lPTl9FTlRFUiwgYm9keUEsIG5vcm1hbEltcHVsc2UsIHRhbmdlbnRJbXB1bHNlLCBiaW5vcm1hbEltcHVsc2UsIGNvbGxpc2lvbkNlbnRlclBvaW50LCBjb2xsaXNpb25Ob3JtYWwpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNvbGxpc2lvbkV4aXQoX2NvbnRhY3Q6IE9JTU8uQ29udGFjdCk6IHZvaWQge1xyXG4gICAgICBsZXQgYm9keUE6IENvbXBvbmVudFJpZ2lkYm9keSA9IF9jb250YWN0LmdldFNoYXBlMSgpPy51c2VyRGF0YTtcclxuICAgICAgbGV0IGJvZHlCOiBDb21wb25lbnRSaWdpZGJvZHkgPSBfY29udGFjdC5nZXRTaGFwZTIoKT8udXNlckRhdGE7XHJcblxyXG4gICAgICBpZiAoIWJvZHlBIHx8ICFib2R5QiB8fCAhYm9keUEuY29sbGlzaW9ucy5pbmNsdWRlcyhib2R5QikpIC8vIGFscmVhZHkgZXhpdGVkXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgYm9keUEuY29sbGlzaW9ucy5zcGxpY2UoYm9keUEuY29sbGlzaW9ucy5pbmRleE9mKGJvZHlCKSwgMSk7XHJcbiAgICAgIGJvZHlCLmNvbGxpc2lvbnMuc3BsaWNlKGJvZHlCLmNvbGxpc2lvbnMuaW5kZXhPZihib2R5QSksIDEpO1xyXG5cclxuICAgICAgYm9keUEuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnRQaHlzaWNzKEVWRU5UX1BIWVNJQ1MuQ09MTElTSU9OX0VYSVQsIGJvZHlCLCAwLCAwLCAwKSk7XHJcbiAgICAgIGJvZHlCLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLkNPTExJU0lPTl9FWElULCBib2R5QSwgMCwgMCwgMCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUcmlnZ2VyIEVudGVyaW5nRXZlbnQgQ2FsbGJhY2ssIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IE9JTU8gUGh5c2ljcyB3aXRoaW4gdGhlaXIgY2FsY3VsYXRpb25zLlxyXG4gICAgKiBTaW5jZSB0aGUgZXZlbnQgZG9lcyBub3Qga25vdyB3aGljaCBib2R5IGlzIHRoZSB0cmlnZ2VyIGluaWF0b3IsIHRoZSBldmVudCBjYW4gYmUgbGlzdGVuZWQgdG9cclxuICAgICogb24gZWl0aGVyIHRoZSB0cmlnZ2VyIG9yIHRoZSB0cmlnZ2VyZWQuIChUaGlzIGlzIG9ubHkgcG9zc2libGUgd2l0aCB0aGUgRlVER0UgT0lNTyBGb3JrISlcclxuICAgICovXHJcbiAgICBwcml2YXRlIHRyaWdnZXJFbnRlcihfY29udGFjdDogT0lNTy5Db250YWN0KTogdm9pZCB7XHJcbiAgICAgIGxldCBib2R5QTogQ29tcG9uZW50UmlnaWRib2R5ID0gX2NvbnRhY3QuZ2V0U2hhcGUxKCk/LnVzZXJEYXRhO1xyXG4gICAgICBsZXQgYm9keUI6IENvbXBvbmVudFJpZ2lkYm9keSA9IF9jb250YWN0LmdldFNoYXBlMigpPy51c2VyRGF0YTtcclxuXHJcbiAgICAgIGlmICghYm9keUEgfHwgIWJvZHlCIHx8IGJvZHlBLnRyaWdnZXJpbmdzLmluY2x1ZGVzKGJvZHlCKSkgLy8gYWxyZWFkeSBlbnRlcmVkXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgYm9keUEudHJpZ2dlcmluZ3MucHVzaChib2R5Qik7XHJcbiAgICAgIGJvZHlCLnRyaWdnZXJpbmdzLnB1c2goYm9keUEpO1xyXG5cclxuICAgICAgbGV0IG1hbmlmb2xkOiBPSU1PLk1hbmlmb2xkID0gX2NvbnRhY3QuZ2V0TWFuaWZvbGQoKTtcclxuICAgICAgbGV0IHBvaW50czogT0lNTy5NYW5pZm9sZFBvaW50W10gPSBtYW5pZm9sZC5nZXRQb2ludHMoKTsgXHJcbiAgICAgIGxldCBub3JtYWw6IE9JTU8uVmVjMyA9IG1hbmlmb2xkLmdldE5vcm1hbCgpO1xyXG4gICAgICBsZXQgY29sbGlzaW9uTm9ybWFsOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7XHJcbiAgICAgIGxldCBjb2xsaXNpb25DZW50ZXJQb2ludDogVmVjdG9yMyA9IGJvZHlBLmNvbGxpc2lvbkNlbnRlclBvaW50KHBvaW50cywgbWFuaWZvbGQuZ2V0TnVtUG9pbnRzKCkpO1xyXG5cclxuICAgICAgYm9keUEuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnRQaHlzaWNzKEVWRU5UX1BIWVNJQ1MuVFJJR0dFUl9FTlRFUiwgYm9keUIsIDAsIDAsIDAsIGNvbGxpc2lvbkNlbnRlclBvaW50LCBjb2xsaXNpb25Ob3JtYWwpKTtcclxuICAgICAgYm9keUIuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnRQaHlzaWNzKEVWRU5UX1BIWVNJQ1MuVFJJR0dFUl9FTlRFUiwgYm9keUEsIDAsIDAsIDAsIGNvbGxpc2lvbkNlbnRlclBvaW50LCBjb2xsaXNpb25Ob3JtYWwpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVHJpZ2dlciBMZWF2aW5nRXZlbnQgQ2FsbGJhY2ssIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IE9JTU8gUGh5c2ljcyB3aXRoaW4gdGhlaXIgY2FsY3VsYXRpb25zLlxyXG4gICAgKiBTaW5jZSB0aGUgZXZlbnQgZG9lcyBub3Qga25vdyB3aGljaCBib2R5IGlzIHRoZSB0cmlnZ2VyIGluaWF0b3IsIHRoZSBldmVudCBjYW4gYmUgbGlzdGVuZWQgdG9cclxuICAgICogb24gZWl0aGVyIHRoZSB0cmlnZ2VyIG9yIHRoZSB0cmlnZ2VyZWQuIChUaGlzIGlzIG9ubHkgcG9zc2libGUgd2l0aCB0aGUgRlVER0UgT0lNTyBGb3JrISlcclxuICAgICovXHJcbiAgICBwcml2YXRlIHRyaWdnZXJFeGl0KF9jb250YWN0OiBPSU1PLkNvbnRhY3QpOiB2b2lkIHtcclxuICAgICAgbGV0IGJvZHlBOiBDb21wb25lbnRSaWdpZGJvZHkgPSBfY29udGFjdC5nZXRTaGFwZTEoKT8udXNlckRhdGE7XHJcbiAgICAgIGxldCBib2R5QjogQ29tcG9uZW50UmlnaWRib2R5ID0gX2NvbnRhY3QuZ2V0U2hhcGUyKCk/LnVzZXJEYXRhO1xyXG5cclxuICAgICAgaWYgKCFib2R5QSB8fCAhYm9keUIgfHwgIWJvZHlBLnRyaWdnZXJpbmdzLmluY2x1ZGVzKGJvZHlCKSkgLy8gYWxyZWFkeSBleGl0ZWRcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBib2R5QS50cmlnZ2VyaW5ncy5zcGxpY2UoYm9keUEuY29sbGlzaW9ucy5pbmRleE9mKGJvZHlCKSwgMSk7XHJcbiAgICAgIGJvZHlCLnRyaWdnZXJpbmdzLnNwbGljZShib2R5Qi5jb2xsaXNpb25zLmluZGV4T2YoYm9keUEpLCAxKTtcclxuXHJcbiAgICAgIGJvZHlBLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50UGh5c2ljcyhFVkVOVF9QSFlTSUNTLlRSSUdHRVJfRVhJVCwgYm9keUIsIDAsIDAsIDApKTtcclxuICAgICAgYm9keUIuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnRQaHlzaWNzKEVWRU5UX1BIWVNJQ1MuVFJJR0dFUl9FWElULCBib2R5QSwgMCwgMCwgMCkpO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgfVxyXG59XHJcbiIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKiBJbnRlcm5hbCBjbGFzcyBmb3IgaG9sZGluZyBkYXRhIGFib3V0IHBoeXNpY3MgZGVidWcgdmVydGljZXMuKi9cclxuICBleHBvcnQgY2xhc3MgUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyIHtcclxuICAgIHB1YmxpYyBnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcclxuICAgIHB1YmxpYyBudW1WZXJ0aWNlczogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBhdHRyaWJzOiBBcnJheTxQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGU+O1xyXG4gICAgcHVibGljIGluZGljZXM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgb2Zmc2V0czogQXJyYXk8bnVtYmVyPjtcclxuICAgIHB1YmxpYyBzdHJpZGU6IG51bWJlcjtcclxuICAgIHB1YmxpYyBidWZmZXI6IFdlYkdMQnVmZmVyO1xyXG4gICAgcHVibGljIGRhdGFMZW5ndGg6IG51bWJlcjtcclxuXHJcbiAgICAvKiogU2V0dXAgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB0aGlzIGJ1ZmZlciBhbmQgY3JlYXRlIHRoZSBhY3R1YWwgYnVmZmVyIGZvciB0aGlzIGNvbnRleHQuICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3JlbmRlcmluZ0NvbnRleHQ6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcclxuICAgICAgdGhpcy5nbCA9IF9yZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEZpbGwgdGhlIGJvdW5kIGJ1ZmZlciB3aXRoIGRhdGEuIFVzZWQgYXQgYnVmZmVyIGluaXRpYWxpemF0aW9uICovXHJcbiAgICBwdWJsaWMgc2V0RGF0YShfYXJyYXk6IEFycmF5PG51bWJlcj4pOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuYXR0cmlicyA9PSBudWxsKSB0aHJvdyBcInNldCBhdHRyaWJ1dGVzIGZpcnN0XCI7XHJcbiAgICAgIHRoaXMubnVtVmVydGljZXMgPSBfYXJyYXkubGVuZ3RoIC8gKHRoaXMuc3RyaWRlIC8gNCk7XHJcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG4gICAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoX2FycmF5KSwgdGhpcy5nbC5EWU5BTUlDX0RSQVcpO1xyXG4gICAgICAvL25vdCBuZWNlc3NhcnkgYW4gaW4gd2ViZ2wyIGFueW1vcmUgdG8gcmViaW5kIHRoZSBzYW1lIGxhc3QgYnVmZmVyICh3aGljaCBpcyBhY2hpZXZlZCBieSBnaXZpbmcgYSBudWxsIGJ1ZmZlciksIGFmdGVyIGJ1ZmZlciBpcyBjaGFuZ2VkLiBSZW1vdmVkIGl0IG9uIGFsbCBvdGhlciBvY2Nhc2lvbnNcclxuICAgICAgLy8gdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTsgXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFNldCBTaGFkZXIgQXR0cmlidXRlcyBpbmZvcm1hdGlvbnMgYnkgZ2V0dGluZyB0aGVpciBwb3NpdGlvbiBpbiB0aGUgc2hhZGVyLCBzZXR0aW5nIHRoZSBvZmZzZXQsIHN0cmlkZSBhbmQgc2l6ZS4gRm9yIGxhdGVyIHVzZSBpbiB0aGUgYmluZGluZyBwcm9jZXNzICovXHJcbiAgICBwdWJsaWMgc2V0QXR0cmlicyhfYXR0cmliczogQXJyYXk8UGh5c2ljc0RlYnVnVmVydGV4QXR0cmlidXRlPik6IHZvaWQge1xyXG4gICAgICB0aGlzLmF0dHJpYnMgPSBfYXR0cmlicztcclxuICAgICAgdGhpcy5vZmZzZXRzID0gW107XHJcbiAgICAgIHRoaXMuc3RyaWRlID0gMDtcclxuICAgICAgbGV0IG46IG51bWJlciA9IF9hdHRyaWJzLmxlbmd0aDtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHRoaXMub2Zmc2V0cy5wdXNoKHRoaXMuc3RyaWRlKTtcclxuICAgICAgICB0aGlzLnN0cmlkZSArPSBfYXR0cmlic1tpXS5mbG9hdDMyQ291bnQgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7IC8vIDMyYml0IGZsb2F0IEJ5dGVzIGFyZSBhIGNvbnN0YW50IG9mIDRcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBhdHRyaWJ1dGUgaW4gdGhlIHNoYWRlciAqL1xyXG4gICAgcHVibGljIGxvYWRBdHRyaWJJbmRpY2VzKF9wcm9ncmFtOiBQaHlzaWNzRGVidWdTaGFkZXIpOiB2b2lkIHtcclxuICAgICAgdGhpcy5pbmRpY2VzID0gX3Byb2dyYW0uZ2V0QXR0cmliSW5kaWNlcyh0aGlzLmF0dHJpYnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBFbmFibGUgYSBhdHRyaWJ1dGUgaW4gYSBzaGFkZXIgZm9yIHRoaXMgY29udGV4dCwgKi9cclxuICAgIHB1YmxpYyBiaW5kQXR0cmlicygpOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMuaW5kaWNlcyA9PSBudWxsKSB0aHJvdyBcImluZGljZXMgYXJlIG5vdCBsb2FkZWRcIjtcclxuICAgICAgbGV0IG46IG51bWJlciA9IHRoaXMuYXR0cmlicy5sZW5ndGg7XHJcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpOyAvL21ha2luZyB0aGUgYnVmZmVyIG9mIHRoaXMgY2xhc3MgdGhlIGN1cnJlbnQgYnVmZmVyXHJcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuaW5kaWNlc1tpXSk7IC8vZW5hYmxlIHRoZSBBdHRyaWJ1dGVcclxuICAgICAgICB0aGlzLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5pbmRpY2VzW2ldLCB0aGlzLmF0dHJpYnNbaV0uZmxvYXQzMkNvdW50LCB0aGlzLmdsLkZMT0FULCBmYWxzZSwgdGhpcy5zdHJpZGUsIHRoaXMub2Zmc2V0c1tpXSk7IC8vY3JlYXRlcyBhIHBvaW50ZXIgYW5kIHN0cnVjdHVyZSBmb3IgdGhpcyBhdHRyaWJ1dGVcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEludGVybmFsIGNsYXNzIGZvciBob2xkaW5nIGRhdGEgYWJvdXQgUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVycyAqL1xyXG4gIGV4cG9ydCBjbGFzcyBQaHlzaWNzRGVidWdJbmRleEJ1ZmZlciB7XHJcbiAgICBwdWJsaWMgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICBwdWJsaWMgYnVmZmVyOiBXZWJHTEJ1ZmZlcjtcclxuICAgIHB1YmxpYyBjb3VudDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBTZXR1cCB0aGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIHRoaXMgYnVmZmVyIGFuZCBjcmVhdGUgdGhlIGFjdHVhbCBidWZmZXIgZm9yIHRoaXMgY29udGV4dC4gKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfcmVuZGVyaW5nQ29udGV4dDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xyXG4gICAgICB0aGlzLmdsID0gX3JlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRmlsbCB0aGUgYm91bmQgYnVmZmVyIHdpdGggZGF0YSBhbW91bnQuIFVzZWQgYXQgYnVmZmVyIGluaXRpYWxpemF0aW9uICovXHJcbiAgICBwdWJsaWMgc2V0RGF0YShfYXJyYXk6IEFycmF5PG51bWJlcj4pOiB2b2lkIHtcclxuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuICAgICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG5ldyBJbnQxNkFycmF5KF9hcnJheSksIHRoaXMuZ2wuRFlOQU1JQ19EUkFXKTtcclxuICAgICAgdGhpcy5jb3VudCA9IF9hcnJheS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBhY3R1YWwgRHJhd0NhbGwgZm9yIHBoeXNpY3NEZWJ1Z0RyYXcgQnVmZmVycy4gVGhpcyBpcyB3aGVyZSB0aGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgZGVidWcgaXMgYWN0dWFsbHkgZHJhd24uICovXHJcbiAgICBwdWJsaWMgZHJhdyhfbW9kZTogbnVtYmVyID0gdGhpcy5nbC5UUklBTkdMRVMsIF9jb3VudDogbnVtYmVyID0gLTEpOiB2b2lkIHtcclxuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuICAgICAgdGhpcy5nbC5kcmF3RWxlbWVudHMoX21vZGUsIF9jb3VudCA+PSAwID8gX2NvdW50IDogdGhpcy5jb3VudCwgdGhpcy5nbC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogSW50ZXJuYWwgY2xhc3MgZm9yIG1hbmFnaW5nIGRhdGEgYWJvdXQgd2ViR0wgQXR0cmlidXRlcyAqL1xyXG4gIGV4cG9ydCBjbGFzcyBQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGUge1xyXG4gICAgcHVibGljIGZsb2F0MzJDb3VudDogbnVtYmVyO1xyXG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2Zsb2F0MzJDb3VudDogbnVtYmVyLCBfbmFtZTogc3RyaW5nKSB7XHJcbiAgICAgIHRoaXMubmFtZSA9IF9uYW1lO1xyXG4gICAgICB0aGlzLmZsb2F0MzJDb3VudCA9IF9mbG9hdDMyQ291bnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogSW50ZXJuYWwgY2xhc3MgZm9yIFNoYWRlcnMgdXNlZCBvbmx5IGJ5IHRoZSBwaHlzaWNzIGRlYnVnRHJhdyAqL1xyXG4gIGV4cG9ydCBjbGFzcyBQaHlzaWNzRGVidWdTaGFkZXIge1xyXG4gICAgcHVibGljIGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgcHVibGljIHByb2dyYW06IFdlYkdMUHJvZ3JhbTtcclxuICAgIHB1YmxpYyB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyO1xyXG4gICAgcHVibGljIGZyYWdtZW50U2hhZGVyOiBXZWJHTFNoYWRlcjtcclxuICAgIHB1YmxpYyB1bmlmb3JtTG9jYXRpb25NYXA6IE1hcDxzdHJpbmcsIFdlYkdMVW5pZm9ybUxvY2F0aW9uPjtcclxuXHJcbiAgICAvKiogSW50cm9kdWNlIHRoZSBGVURHRSBSZW5kZXJpbmcgQ29udGV4dCB0byB0aGlzIGNsYXNzLCBjcmVhdGluZyBhIHByb2dyYW0gYW5kIHZlcnRleC9mcmFnbWVudCBzaGFkZXIgaW4gdGhpcyBjb250ZXh0ICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX3JlbmRlcmluZ0NvbnRleHQ6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcclxuICAgICAgdGhpcy5nbCA9IF9yZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgICB0aGlzLnByb2dyYW0gPSB0aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0aGlzLmdsLlZFUlRFWF9TSEFERVIpO1xyXG4gICAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodGhpcy5nbC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUYWtlIGdsc2wgc2hhZGVycyBhcyBzdHJpbmdzIGFuZCBjb21waWxlIHRoZW0sIGF0dGFjaGluZyB0aGUgY29tcGlsZWQgc2hhZGVycyB0byBhIHByb2dyYW0gdGhhdHMgdXNlZCBieSB0aGlzIHJlbmRlcmluZyBjb250ZXh0LiAqL1xyXG4gICAgcHVibGljIGNvbXBpbGUoX3ZlcnRleFNvdXJjZTogc3RyaW5nLCBfZnJhZ21lbnRTb3VyY2U6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbk1hcCA9IG5ldyBNYXA8c3RyaW5nLCBXZWJHTFVuaWZvcm1Mb2NhdGlvbj4oKTtcclxuICAgICAgdGhpcy5jb21waWxlU2hhZGVyKHRoaXMudmVydGV4U2hhZGVyLCBfdmVydGV4U291cmNlKTtcclxuICAgICAgdGhpcy5jb21waWxlU2hhZGVyKHRoaXMuZnJhZ21lbnRTaGFkZXIsIF9mcmFnbWVudFNvdXJjZSk7XHJcbiAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHRoaXMucHJvZ3JhbSwgdGhpcy52ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcih0aGlzLnByb2dyYW0sIHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgIGlmICghdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMucHJvZ3JhbSwgdGhpcy5nbC5MSU5LX1NUQVRVUykpIHsgIC8vbWFrZSBzdXJlIHRoZSBsaW5raW5nIHdvcmtlZCwgc28gdGhlIHByb2dyYW0gaXMgdmFsaWQsIGFuZCBzaGFkZXJzIGFyZSB3b3JraW5nXHJcbiAgICAgICAgRGVidWcubG9nKHRoaXMuZ2wuZ2V0UHJvZ3JhbUluZm9Mb2codGhpcy5wcm9ncmFtKSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5nbC52YWxpZGF0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgaWYgKCF0aGlzLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5wcm9ncmFtLCB0aGlzLmdsLlZBTElEQVRFX1NUQVRVUykpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRVJST1IgdmFsaWRhdGluZyBwcm9ncmFtIVwiLCB0aGlzLmdsLmdldFByb2dyYW1JbmZvTG9nKHRoaXMucHJvZ3JhbSkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgaW5kZXggb2YgYSBhdHRyaWJ1dGUgaW4gYSBzaGFkZXIgaW4gdGhpcyBwcm9ncmFtICovXHJcbiAgICBwdWJsaWMgZ2V0QXR0cmliSW5kZXgoX25hbWU6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgX25hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGhlIGxvY2F0aW9uIG9mIGEgdW5pZm9ybSBpbiBhIHNoYWRlciBpbiB0aGlzIHByb2dyYW0gKi9cclxuICAgIHB1YmxpYyBnZXRVbmlmb3JtTG9jYXRpb24oX25hbWU6IHN0cmluZyk6IFdlYkdMVW5pZm9ybUxvY2F0aW9uIHtcclxuICAgICAgaWYgKHRoaXMudW5pZm9ybUxvY2F0aW9uTWFwLmhhcyhfbmFtZSkpIHJldHVybiB0aGlzLnVuaWZvcm1Mb2NhdGlvbk1hcC5nZXQoX25hbWUpO1xyXG4gICAgICBsZXQgbG9jYXRpb246IFdlYkdMVW5pZm9ybUxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBfbmFtZSk7XHJcbiAgICAgIHRoaXMudW5pZm9ybUxvY2F0aW9uTWFwLnNldChfbmFtZSwgbG9jYXRpb24pO1xyXG4gICAgICByZXR1cm4gbG9jYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldCBhbGwgaW5kaWNlcyBmb3IgZXZlcnkgYXR0cmlidXRlIGluIHRoZSBzaGFkZXJzIG9mIHRoaXMgcHJvZ3JhbSAqL1xyXG4gICAgcHVibGljIGdldEF0dHJpYkluZGljZXMoX2F0dHJpYnM6IEFycmF5PFBoeXNpY3NEZWJ1Z1ZlcnRleEF0dHJpYnV0ZT4pOiBBcnJheTxudW1iZXI+IHtcclxuICAgICAgbGV0IGluZGljZXM6IEFycmF5PG51bWJlcj4gPSBbXTtcclxuICAgICAgX2F0dHJpYnMuZm9yRWFjaChfdmFsdWUgPT4ge1xyXG4gICAgICAgIGluZGljZXMucHVzaCh0aGlzLmdldEF0dHJpYkluZGV4KF92YWx1ZS5uYW1lKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gaW5kaWNlcztcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGVsbCB0aGUgRlVER0UgUmVuZGVyaW5nIENvbnRleHQgdG8gdXNlIHRoaXMgcHJvZ3JhbSB0byBkcmF3LiAqL1xyXG4gICAgcHVibGljIHVzZSgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENvbXBpbGUgYSBzaGFkZXIgb3V0IG9mIGEgc3RyaW5nIGFuZCB2YWxpZGF0ZSBpdC4gKi9cclxuICAgIHB1YmxpYyBjb21waWxlU2hhZGVyKF9zaGFkZXI6IFdlYkdMU2hhZGVyLCBfc291cmNlOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgdGhpcy5nbC5zaGFkZXJTb3VyY2UoX3NoYWRlciwgX3NvdXJjZSk7XHJcbiAgICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihfc2hhZGVyKTtcclxuICAgICAgaWYgKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcihfc2hhZGVyLCB0aGlzLmdsLkNPTVBJTEVfU1RBVFVTKSkge1xyXG4gICAgICAgIERlYnVnLmxvZyh0aGlzLmdsLmdldFNoYWRlckluZm9Mb2coX3NoYWRlcikpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogSW50ZXJuYWwgQ2xhc3MgdXNlZCB0byBkcmF3IGRlYnVnSW5mb3JtYXRpb25zIGFib3V0IHRoZSBwaHlzaWNzIHNpbXVsYXRpb24gb250byB0aGUgcmVuZGVyQ29udGV4dC4gTm8gdXNlciBpbnRlcmFjdGlvbiBuZWVkZWQuIFxyXG4gICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVIDIwMjAgLy9CYXNlZCBvbiBPaW1vUGh5c2ljcyBIYXhlIERlYnVnRHJhd0RlbW8gXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFBoeXNpY3NEZWJ1Z0RyYXcgZXh0ZW5kcyBSZW5kZXJXZWJHTCB7XHJcbiAgICBwdWJsaWMgb2ltb0RlYnVnRHJhdzogT0lNTy5EZWJ1Z0RyYXc7IC8vdGhlIG9yaWdpbmFsIHBoeXNpY3MgZW5naW5lIGRlYnVnRHJhdyBjbGFzcyByZWNlaXZpbmcgY2FsbHMgZnJvbSB0aGUgb2ltb1BoeXNpY3MuV29ybGQsIGFuZCBwcm92aWRpbmcgaW5mb3JtYXRpb25zIGluIGZvcm0gb2YgcG9pbnRzL2xpbmVzL3RyaWFuZ2xlcyB3aGF0IHRoZSBwaHlzaWNzIHdvcmxkIGxvb2tzIGxpa2VcclxuICAgIHB1YmxpYyBzdHlsZTogT0lNTy5EZWJ1Z0RyYXdTdHlsZTsgLy9jb2xvcnMgb2YgdGhlIGRlYnVnIGluZm9ybWF0aW9ucywgdW5jaGFuZ2VkIGluIEZVREdFIGludGVncmF0aW9uLCBiYXNpY2FsbHkgY29sb3JpbmcgdGhpbmdzIGxpa2Ugc2xlZXBpbmcvYWN0aXZlIHJiJ3MgZGlmZmVyZW50bHksIGpvaW50cyB3aGl0ZSBhbmQgc3VjaC4gTm8gbmVlZCB0byBoYXZlIHVzZXJzIGNoYW5nZSBhbnl0aGluZy5cclxuICAgIHB1YmxpYyBnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcclxuXHJcbiAgICBwdWJsaWMgcHJvZ3JhbTogV2ViR0xQcm9ncmFtOyAvL3Byb2dyYW0gdGhhdCBpcyB1c2VkIGluIHRoZSBGVURHRSByZW5kZXJpbmcgY29udGV4dCBjb250YWluaW5nIHNoYWRlcnMgYW5kIHVzZSBpbmZvcm1hdGlvbnMgZm9yIHRoZSBjb250ZXh0IHRvIGtub3cgaG93IHRvIGRyYXdcclxuICAgIHB1YmxpYyBzaGFkZXI6IFBoeXNpY3NEZWJ1Z1NoYWRlcjtcclxuXHJcbiAgICAvL0J1ZmZlcnMgZm9yIHBvaW50cy9saW5lcy90cmlhbmdsZXMuIEluZGV4IEJ1ZmZlciBmb3IgdGhlIGFtb3VudCBvZiBkcmF3Q2FsbHMgYW5kIFZlcnRleCBCdWZmZXIgZm9yIHRoZSBpbmZvcm1hdGlvbnNcclxuICAgIHB1YmxpYyBwb2ludFZCTzogUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyO1xyXG4gICAgcHVibGljIHBvaW50SUJPOiBQaHlzaWNzRGVidWdJbmRleEJ1ZmZlcjtcclxuXHJcbiAgICBwdWJsaWMgbGluZVZCTzogUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyO1xyXG4gICAgcHVibGljIGxpbmVJQk86IFBoeXNpY3NEZWJ1Z0luZGV4QnVmZmVyO1xyXG5cclxuICAgIHB1YmxpYyB0cmlWQk86IFBoeXNpY3NEZWJ1Z1ZlcnRleEJ1ZmZlcjtcclxuICAgIHB1YmxpYyB0cmlJQk86IFBoeXNpY3NEZWJ1Z0luZGV4QnVmZmVyO1xyXG5cclxuICAgIHB1YmxpYyBwb2ludERhdGE6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgcG9pbnRJYm9EYXRhOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHVibGljIG51bVBvaW50RGF0YTogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyBsaW5lRGF0YTogQXJyYXk8bnVtYmVyPjtcclxuICAgIHB1YmxpYyBsaW5lSWJvRGF0YTogQXJyYXk8bnVtYmVyPjtcclxuICAgIHB1YmxpYyBudW1MaW5lRGF0YTogbnVtYmVyO1xyXG5cclxuICAgIHB1YmxpYyB0cmlEYXRhOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHVibGljIHRyaUlib0RhdGE6IEFycmF5PG51bWJlcj47XHJcbiAgICBwdWJsaWMgbnVtVHJpRGF0YTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBDcmVhdGluZyB0aGUgZGVidWcgZm9yIHBoeXNpY3MgaW4gRlVER0UuIFRlbGwgaXQgdG8gZHJhdyBvbmx5IHdpcmVmcmFtZSBvYmplY3RzLCBzaW5jZSBGVURHRSBpcyBoYW5kbGluZyByZW5kZXJpbmcgb2YgdGhlIG9iamVjdHMgYmVzaWRlcyBwaHlzaWNzLiBcclxuICAgICAqIE92ZXJyaWRlIE9pbW9QaHlzaWNzIEZ1bmN0aW9ucyB3aXRoIG93biByZW5kZXJpbmcuIEluaXRpYWxpemUgYnVmZmVycyBhbmQgY29ubmVjdCB0aGVtIHdpdGggdGhlIGNvbnRleHQgZm9yIGxhdGVyIHVzZS4gKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgIHRoaXMuc3R5bGUgPSBuZXcgT0lNTy5EZWJ1Z0RyYXdTdHlsZSgpO1xyXG4gICAgICB0aGlzLm9pbW9EZWJ1Z0RyYXcgPSBuZXcgT0lNTy5EZWJ1Z0RyYXcoKTtcclxuICAgICAgdGhpcy5vaW1vRGVidWdEcmF3LndpcmVmcmFtZSA9IHRydWU7IC8vVHJpYW5nbGUgUmVuZGVyaW5nIGlzIGhhbmRsZWQgYnkgRlVER0Ugc28sIG9ubHkgdGhlIHBoeXNpY3MgbGluZXMvcG9pbnRzIG5lZWQgdG8gYmUgcmVuZGVyZWQsIGFsdGhvdWdoIHRyaWFuZ2xlIGlzIHN0aWxsIGltcGxlbWVudGVkXHJcblxyXG4gICAgICB0aGlzLmdsID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICB0aGlzLmluaXRpYWxpemVPdmVycmlkZSgpO1xyXG4gICAgICB0aGlzLnNoYWRlciA9IG5ldyBQaHlzaWNzRGVidWdTaGFkZXIodGhpcy5nbCk7XHJcbiAgICAgIHRoaXMuc2hhZGVyLmNvbXBpbGUodGhpcy52ZXJ0ZXhTaGFkZXJTb3VyY2UoKSwgdGhpcy5mcmFnbWVudFNoYWRlclNvdXJjZSgpKTtcclxuXHJcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUJ1ZmZlcnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVjZWl2ZSB0aGUgY3VycmVudCBEZWJ1Z01vZGUgZnJvbSB0aGUgcGh5c2ljcyBzZXR0aW5ncyBhbmQgc2V0IHRoZSBPaW1vUGh5c2ljcy5EZWJ1Z0RyYXcgYm9vbGVhbnMgdG8gc2hvdyBvbmx5IGNlcnRhaW4gaW5mb3JtYXRpb25zLlxyXG4gICAgICogTmVlZGVkIHNpbmNlIHNvbWUgZGVidWcgaW5mb3JtYXRpb25zIGV4Y2x1ZGUgb3RoZXJzLCBhbmQgY2FuJ3QgYmUgZHJhd24gYXQgdGhlIHNhbWUgdGltZSwgYnkgT2ltb1BoeXNpY3MuIEFuZCBmb3IgdXNlcnMgaXQgcHJvdmlkZXMgbW9yZSByZWFkYWJpbGl0eVxyXG4gICAgICogdG8gZGVidWcgb25seSB3aGF0IHRoZXkgbmVlZCBhbmQgaXMgY29tbW9ubHkgZGVidWdnZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXREZWJ1Z01vZGUoX21vZGU6IFBIWVNJQ1NfREVCVUdNT0RFID0gUEhZU0lDU19ERUJVR01PREUuTk9ORSk6IHZvaWQge1xyXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgbGV0IGRyYXcgPSB7IGRyYXdBYWJiczogZmFsc2UsIGRyYXdCYXNlczogZmFsc2UsIGRyYXdCdmg6IGZhbHNlLCBkcmF3Q29udGFjdEJhc2VzOiBmYWxzZSwgZHJhd0NvbnRhY3RzOiBmYWxzZSwgZHJhd0pvaW50TGltaXRzOiBmYWxzZSwgZHJhd0pvaW50czogZmFsc2UsIGRyYXdQYWlyczogZmFsc2UsIGRyYXdTaGFwZXM6IGZhbHNlIH07XHJcblxyXG4gICAgICBzd2l0Y2ggKF9tb2RlKSB7XHJcbiAgICAgICAgY2FzZSBQSFlTSUNTX0RFQlVHTU9ERS5DT0xMSURFUlM6IC8vQ29sbGlkZXJzIGFuZCBCYXNlc1xyXG4gICAgICAgICAgZHJhdy5kcmF3QmFzZXMgPSBkcmF3LmRyYXdTaGFwZXMgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBQSFlTSUNTX0RFQlVHTU9ERS5KT0lOVFNfQU5EX0NPTExJREVSOiAvL0NvbGxpZGVycyBhbmQgam9pbnRzXHJcbiAgICAgICAgICBkcmF3LmRyYXdKb2ludHMgPSBkcmF3LmRyYXdKb2ludExpbWl0cyA9IGRyYXcuZHJhd1NoYXBlcyA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFBIWVNJQ1NfREVCVUdNT0RFLlBIWVNJQ19PQkpFQ1RTX09OTFk6IC8vUGh5c2ljcyBPYmplY3RzIG9ubHksIHNob3dzIHNhbWUgYXMgQ29sbGlkZXIgLyBKb2ludHMgYnV0IGFsc28gaGlkaW5nIGV2ZXJ5IG90aGVyIGZ1ZGdlIG9iamVjdFxyXG4gICAgICAgICAgZHJhdy5kcmF3QmFzZXMgPSBkcmF3LmRyYXdKb2ludExpbWl0cyA9IGRyYXcuZHJhd0pvaW50cyA9IGRyYXcuZHJhd1NoYXBlcyA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFBIWVNJQ1NfREVCVUdNT0RFLkNPTlRBQ1RTOiAvL0NvbnRhY3RzXHJcbiAgICAgICAgICBkcmF3LmRyYXdCYXNlcyA9IGRyYXcuZHJhd0NvbnRhY3RCYXNlcyA9IGRyYXcuZHJhd0NvbnRhY3RzID0gZHJhdy5kcmF3UGFpcnMgPSBkcmF3LmRyYXdTaGFwZXMgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBQSFlTSUNTX0RFQlVHTU9ERS5CT1VORElOR19CT1hFUzogLy9Cb3VuZGluZyBCb3ggLyBCcm9hZHBoYXNlIEJ2aCAvIEJhc2VzXHJcbiAgICAgICAgICBkcmF3LmRyYXdBYWJicyA9IGRyYXcuZHJhd0Jhc2VzID0gZHJhdy5kcmF3QnZoID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vaW1vRGVidWdEcmF3LCBkcmF3KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ3JlYXRpbmcgdGhlIGVtcHR5IHJlbmRlciBidWZmZXJzLiBEZWZpbmluZyB0aGUgYXR0cmlidXRlcyB1c2VkIGluIHNoYWRlcnMuXHJcbiAgICAgKiBOZWVkcyB0byBjcmVhdGUgZW1wdHkgYnVmZmVycyB0byBhbHJlYWR5IGhhdmUgdGhlbSByZWFkeSB0byBkcmF3IGxhdGVyIG9uLCBsaW5raW5nIGlzIG9ubHkgcG9zc2libGUgd2l0aCBleGlzdGluZyBidWZmZXJzLiAqL1xyXG4gICAgcHVibGljIGluaXRpYWxpemVCdWZmZXJzKCk6IHZvaWQge1xyXG4gICAgICBsZXQgYXR0cmliczogQXJyYXk8UGh5c2ljc0RlYnVnVmVydGV4QXR0cmlidXRlPiA9IFtcclxuICAgICAgICBuZXcgUGh5c2ljc0RlYnVnVmVydGV4QXR0cmlidXRlKDMsIFwiYVBvc2l0aW9uXCIpLFxyXG4gICAgICAgIG5ldyBQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGUoMywgXCJhTm9ybWFsXCIpLFxyXG4gICAgICAgIG5ldyBQaHlzaWNzRGVidWdWZXJ0ZXhBdHRyaWJ1dGUoMywgXCJhQ29sb3JcIilcclxuICAgICAgXTtcclxuXHJcbiAgICAgIHRoaXMucG9pbnRWQk8gPSBuZXcgUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyKHRoaXMuZ2wpO1xyXG4gICAgICB0aGlzLnBvaW50SUJPID0gbmV3IFBoeXNpY3NEZWJ1Z0luZGV4QnVmZmVyKHRoaXMuZ2wpO1xyXG4gICAgICB0aGlzLnBvaW50VkJPLnNldEF0dHJpYnMoYXR0cmlicyk7XHJcbiAgICAgIHRoaXMucG9pbnRWQk8ubG9hZEF0dHJpYkluZGljZXModGhpcy5zaGFkZXIpO1xyXG4gICAgICB0aGlzLmxpbmVWQk8gPSBuZXcgUGh5c2ljc0RlYnVnVmVydGV4QnVmZmVyKHRoaXMuZ2wpO1xyXG4gICAgICB0aGlzLmxpbmVJQk8gPSBuZXcgUGh5c2ljc0RlYnVnSW5kZXhCdWZmZXIodGhpcy5nbCk7XHJcbiAgICAgIHRoaXMubGluZVZCTy5zZXRBdHRyaWJzKGF0dHJpYnMpO1xyXG4gICAgICB0aGlzLmxpbmVWQk8ubG9hZEF0dHJpYkluZGljZXModGhpcy5zaGFkZXIpO1xyXG4gICAgICB0aGlzLnRyaVZCTyA9IG5ldyBQaHlzaWNzRGVidWdWZXJ0ZXhCdWZmZXIodGhpcy5nbCk7XHJcbiAgICAgIHRoaXMudHJpSUJPID0gbmV3IFBoeXNpY3NEZWJ1Z0luZGV4QnVmZmVyKHRoaXMuZ2wpO1xyXG4gICAgICB0aGlzLnRyaVZCTy5zZXRBdHRyaWJzKGF0dHJpYnMpO1xyXG4gICAgICB0aGlzLnRyaVZCTy5sb2FkQXR0cmliSW5kaWNlcyh0aGlzLnNoYWRlcik7XHJcblxyXG4gICAgICB0aGlzLmNsZWFyQnVmZmVycygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBCZWZvcmUgT2ltb1BoeXNpY3Mud29ybGQgaXMgZmlsbGluZyB0aGUgZGVidWcuIE1ha2Ugc3VyZSB0aGUgYnVmZmVycyBhcmUgcmVzZXQuIEFsc28gcmVjZWl2aW5nIHRoZSBkZWJ1Z01vZGUgZnJvbSBzZXR0aW5ncyBhbmQgdXBkYXRpbmcgdGhlIGN1cnJlbnQgcHJvamVjdGlvbiBmb3IgdGhlIHZlcnRleFNoYWRlci4gKi9cclxuICAgIHB1YmxpYyBjbGVhckJ1ZmZlcnMoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZ2wubGluZVdpZHRoKDIuMCk7IC8vRG9lcyBub3QgYWZmZWN0IGFueXRoaW5nIGJlY2F1c2UgbGluZVdpZHRoIGlzIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBieSBNaWNyb3NvZnQgRWRnZSBhbmQgRlVER0UgaXMgb3B0aW1pemVkIGZvciBDaHJvbWVcclxuXHJcbiAgICAgIHRoaXMucG9pbnREYXRhID0gW107IC8vUmVzZXR0aW5nIHRoZSBkYXRhIHRvIGJlIGZpbGxlZCBhZ2FpblxyXG4gICAgICB0aGlzLmxpbmVEYXRhID0gW107XHJcbiAgICAgIHRoaXMudHJpRGF0YSA9IFtdO1xyXG5cclxuICAgICAgdGhpcy5udW1Qb2ludERhdGEgPSAwOyAvL1Jlc2V0dGluZyB0aGUgYW1vdW50IG9mIGRhdGEgY2FsbHNcclxuICAgICAgdGhpcy5udW1MaW5lRGF0YSA9IDA7XHJcbiAgICAgIHRoaXMubnVtVHJpRGF0YSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEFmdGVyIE9pbW9QaHlzaWNzLndvcmxkIGZpbGxlZCB0aGUgZGVidWcuIFJlbmRlcmluZyBjYWxscy4gU2V0dGluZyB0aGlzIHByb2dyYW0gdG8gYmUgdXNlZCBieSB0aGUgRlVER0UgcmVuZGVyaW5nIGNvbnRleHQuIEFuZCBkcmF3IGVhY2ggdXBkYXRlZCBidWZmZXIgYW5kIHJlc2V0dGluZyB0aGVtLiAqL1xyXG4gICAgcHVibGljIGRyYXdCdWZmZXJzKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNoYWRlci51c2UoKTtcclxuICAgICAgdGhpcy5nbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuc2hhZGVyLmdldFVuaWZvcm1Mb2NhdGlvbihcInVfbXR4V29ybGRUb1ZpZXdcIiksIGZhbHNlLCBQaHlzaWNzLm1haW5DYW0ubXR4V29ybGRUb1ZpZXcuZ2V0QXJyYXkoKSk7XHJcblxyXG4gICAgICB0aGlzLmdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcclxuICAgICAgaWYgKHRoaXMubnVtUG9pbnREYXRhID4gMCkge1xyXG4gICAgICAgIHRoaXMucG9pbnRJYm9EYXRhID0gW107ICAvL0J1ZmZlciBzaXplIG1hdGNoaW5nIHRvIHdoYXRzIG5lZWRlZFxyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm51bVBvaW50RGF0YTsgaSsrKSB7XHJcbiAgICAgICAgICB0aGlzLnBvaW50SWJvRGF0YS5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvaW50SUJPLnNldERhdGEodGhpcy5wb2ludElib0RhdGEpOyAvL1NldCBJbmRleCBidWZmZXIgdG8gY29ycmVjdCBzaXplXHJcbiAgICAgICAgdGhpcy5wb2ludFZCTy5zZXREYXRhKHRoaXMucG9pbnREYXRhKTsgLy9TZXQgVmVydGV4IEJ1ZmZlciB0byBjdXJyZW50IERhdGFcclxuICAgICAgICB0aGlzLnBvaW50VkJPLmJpbmRBdHRyaWJzKCk7XHJcbiAgICAgICAgdGhpcy5wb2ludElCTy5kcmF3KHRoaXMuZ2wuUE9JTlRTLCB0aGlzLm51bVBvaW50RGF0YSk7IC8vVGhlIGFjdHVhbCBkcmF3IGNhbGwgZm9yIGVhY2ggaW5kZXggaW4gaWJvXHJcbiAgICAgICAgdGhpcy5udW1Qb2ludERhdGEgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLm51bUxpbmVEYXRhID4gMCkge1xyXG4gICAgICAgIHRoaXMubGluZUlib0RhdGEgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5udW1MaW5lRGF0YTsgaSsrKSB7XHJcbiAgICAgICAgICB0aGlzLmxpbmVJYm9EYXRhLnB1c2goaSAqIDIpO1xyXG4gICAgICAgICAgdGhpcy5saW5lSWJvRGF0YS5wdXNoKGkgKiAyICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGluZUlCTy5zZXREYXRhKHRoaXMubGluZUlib0RhdGEpO1xyXG4gICAgICAgIHRoaXMubGluZVZCTy5zZXREYXRhKHRoaXMubGluZURhdGEpO1xyXG4gICAgICAgIHRoaXMubGluZVZCTy5iaW5kQXR0cmlicygpO1xyXG4gICAgICAgIHRoaXMubGluZUlCTy5kcmF3KHRoaXMuZ2wuTElORVMsIHRoaXMubnVtTGluZURhdGEgKiAyKTtcclxuICAgICAgICB0aGlzLm51bUxpbmVEYXRhID0gMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5udW1UcmlEYXRhID4gMCkge1xyXG4gICAgICAgIHRoaXMudHJpSWJvRGF0YSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm51bVRyaURhdGE7IGkrKykge1xyXG4gICAgICAgICAgdGhpcy50cmlJYm9EYXRhLnB1c2goaSAqIDMpO1xyXG4gICAgICAgICAgdGhpcy50cmlJYm9EYXRhLnB1c2goaSAqIDMgKyAxKTtcclxuICAgICAgICAgIHRoaXMudHJpSWJvRGF0YS5wdXNoKGkgKiAzICsgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJpSUJPLnNldERhdGEodGhpcy50cmlJYm9EYXRhKTtcclxuICAgICAgICB0aGlzLnRyaVZCTy5zZXREYXRhKHRoaXMudHJpRGF0YSk7XHJcbiAgICAgICAgdGhpcy50cmlWQk8uYmluZEF0dHJpYnMoKTtcclxuICAgICAgICB0aGlzLnRyaUlCTy5kcmF3KHRoaXMuZ2wuVFJJQU5HTEVTLCB0aGlzLm51bVRyaURhdGEgKiAzKTtcclxuICAgICAgICB0aGlzLm51bVRyaURhdGEgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIERyYXdpbmcgdGhlIHJheSBpbnRvIHRoZSBkZWJ1Z0RyYXcgQ2FsbC4gQnkgdXNpbmcgdGhlIG92ZXJ3cml0dGVuIGxpbmUgcmVuZGVyaW5nIGZ1bmN0aW9ucyBhbmQgZHJhd2luZyBhIHBvaW50IChwb2ludFNpemUgZGVmaW5lZCBpbiB0aGUgc2hhZGVyKSBhdCB0aGUgZW5kIG9mIHRoZSByYXkuICovXHJcbiAgICBwdWJsaWMgZGVidWdSYXkoX29yaWdpbjogVmVjdG9yMywgX2VuZDogVmVjdG9yMywgX2NvbG9yOiBDb2xvcik6IHZvaWQge1xyXG4gICAgICB0aGlzLm9pbW9EZWJ1Z0RyYXcubGluZShuZXcgT0lNTy5WZWMzKF9vcmlnaW4ueCwgX29yaWdpbi55LCBfb3JpZ2luLnopLCBuZXcgT0lNTy5WZWMzKF9lbmQueCwgX2VuZC55LCBfZW5kLnopLCBuZXcgT0lNTy5WZWMzKF9jb2xvci5yLCBfY29sb3IuZywgX2NvbG9yLmIpKTtcclxuICAgICAgdGhpcy5vaW1vRGVidWdEcmF3LnBvaW50KG5ldyBPSU1PLlZlYzMoX2VuZC54LCBfZW5kLnksIF9lbmQueiksIG5ldyBPSU1PLlZlYzMoX2NvbG9yLnIsIF9jb2xvci5nLCBfY29sb3IuYikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBPdmVycmlkaW5nIHRoZSBleGlzdGluZyBmdW5jdGlvbnMgZnJvbSBPaW1vUGh5c2ljcy5EZWJ1Z0RyYXcgd2l0aG91dCBhY3R1YWxseSBpbmhlcml0IGZyb20gdGhlIGNsYXNzLCB0byBhdm9pZCBjb21waWxlciBwcm9ibGVtcy4gXHJcbiAgICAgKiBPdmVycmlkaW5nIHRoZW0gdG8gcmVjZWl2ZSBkZWJ1Z0luZm9ybWF0aW9ucyBpbiB0aGUgZm9ybWF0IHRoZSBwaHlzaWMgZW5naW5lIHByb3ZpZGVzIHRoZW0gYnV0IGhhbmRsaW5nIHRoZSByZW5kZXJpbmcgaW4gdGhlIGZ1ZGdlIGNvbnRleHQuICovXHJcbiAgICBwcml2YXRlIGluaXRpYWxpemVPdmVycmlkZSgpOiB2b2lkIHtcclxuICAgICAgLy9PdmVycmlkZSBwb2ludC9saW5lL3RyaWFuZ2xlIGZ1bmN0aW9ucyBvZiBPaW1vUGh5c2ljcyB3aGljaCBhcmUgdXNlZCB0byBkcmF3IHdpcmVmcmFtZXMgb2Ygb2JqZWN0cywgbGluZXMgb2YgcmF5Y2FzdHMgb3IgdHJpYW5nbGVzIHdoZW4gdGhlIG9iamVjdHMgYXJlIHJlbmRlcmVkIGJ5IHRoZSBwaHlzaWNzIG5vdCBGVURHRSAodW51c2VkKVxyXG5cclxuICAgICAgT0lNTy5EZWJ1Z0RyYXcucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gKF92OiBPSU1PLlZlYzMsIF9jb2xvcjogT0lNTy5WZWMzKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGRlYnVnV3JhcHBlcjogUGh5c2ljc0RlYnVnRHJhdyA9IFBoeXNpY3MuZGVidWdEcmF3OyAvL0dldCB0aGUgY3VzdG9tIHBoeXNpY3MgZGVidWcgY2xhc3MgdG8gaGF2ZSBhY2Nlc3MgdG8gdGhlIGRhdGEuXHJcbiAgICAgICAgaWYgKFBoeXNpY3MubWFpbkNhbSAhPSBudWxsKSB7IC8vb25seSBhY3Qgd2hlbiB0aGVyZSBpcyBhIGNhbWVyYSB0aGF0IGlzIHJlbmRlcmluZ1xyXG4gICAgICAgICAgbGV0IGRhdGE6IEFycmF5PE51bWJlcj4gPSBkZWJ1Z1dyYXBwZXIucG9pbnREYXRhOyAvL2dldCB0aGUgYWxyZWFkeSB3cml0dGVuIGJ1ZmZlciBpbmZvcm1hdGlvbnNcclxuICAgICAgICAgIGRhdGEucHVzaChfdi54LCBfdi55LCBfdi56KTsgLy9Db29yZGluYXRlcyBvZiB0aGUgcG9pbnRcclxuICAgICAgICAgIGRhdGEucHVzaCgwLCAwLCAwKTsgLy9Qb2ludCBOb3JtYWxzIC0gRW1wdHkgc2luY2UgaXQncyBub3QgYSBwb2x5Z29uXHJcbiAgICAgICAgICBkYXRhLnB1c2goX2NvbG9yLngsIF9jb2xvci55LCBfY29sb3Iueik7IC8vQ29sb3Igb2YgdGhlIHBvaW50XHJcbiAgICAgICAgICBkZWJ1Z1dyYXBwZXIubnVtUG9pbnREYXRhKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgT0lNTy5EZWJ1Z0RyYXcucHJvdG90eXBlLmxpbmUgPSBmdW5jdGlvbiAoX3YxOiBPSU1PLlZlYzMsIF92MjogT0lNTy5WZWMzLCBfY29sb3I6IE9JTU8uVmVjMyk6IHZvaWQge1xyXG4gICAgICAgIGxldCBkZWJ1Z1dyYXBwZXI6IFBoeXNpY3NEZWJ1Z0RyYXcgPSBQaHlzaWNzLmRlYnVnRHJhdztcclxuICAgICAgICBpZiAoUGh5c2ljcy5tYWluQ2FtICE9IG51bGwpIHtcclxuICAgICAgICAgIGxldCBkYXRhOiBBcnJheTxudW1iZXI+ID0gZGVidWdXcmFwcGVyLmxpbmVEYXRhO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF92MS54LCBfdjEueSwgX3YxLnopOyAvL1BvaW50IDEgQ29vcmRpbmF0ZXNcclxuICAgICAgICAgIGRhdGEucHVzaCgwLCAwLCAwKTsgLy9QMSBOb3JtYWxzIC0gRW1wdHkgc2luY2UgaXQncyBub3QgYSBwb2x5Z29uXHJcbiAgICAgICAgICBkYXRhLnB1c2goX2NvbG9yLngsIF9jb2xvci55LCBfY29sb3Iueik7IC8vUDEgQ29sb3JcclxuICAgICAgICAgIGRhdGEucHVzaChfdjIueCwgX3YyLnksIF92Mi56KTsgLy9Qb2ludCAyIENvb3JkaW5hdGVzXHJcbiAgICAgICAgICBkYXRhLnB1c2goMCwgMCwgMCk7XHJcbiAgICAgICAgICBkYXRhLnB1c2goX2NvbG9yLngsIF9jb2xvci55LCBfY29sb3Iueik7XHJcbiAgICAgICAgICBkZWJ1Z1dyYXBwZXIubnVtTGluZURhdGErKztcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBPSU1PLkRlYnVnRHJhdy5wcm90b3R5cGUudHJpYW5nbGUgPSBmdW5jdGlvbiAoX3YxOiBPSU1PLlZlYzMsIF92MjogT0lNTy5WZWMzLCBfdjM6IE9JTU8uVmVjMywgX24xOiBPSU1PLlZlYzMsIF9uMjogT0lNTy5WZWMzLCBfbjM6IE9JTU8uVmVjMywgX2NvbG9yOiBPSU1PLlZlYzMpOiB2b2lkIHtcclxuICAgICAgICBsZXQgZGVidWdXcmFwcGVyOiBQaHlzaWNzRGVidWdEcmF3ID0gUGh5c2ljcy5kZWJ1Z0RyYXc7XHJcbiAgICAgICAgaWYgKFBoeXNpY3MubWFpbkNhbSAhPSBudWxsKSB7XHJcbiAgICAgICAgICBsZXQgZGF0YTogQXJyYXk8bnVtYmVyPiA9IGRlYnVnV3JhcHBlci50cmlEYXRhO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF92MS54LCBfdjEueSwgX3YxLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF9uMS54LCBfbjEueSwgX24xLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF9jb2xvci54LCBfY29sb3IueSwgX2NvbG9yLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF92Mi54LCBfdjIueSwgX3YyLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF9uMi54LCBfbjIueSwgX24yLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF9jb2xvci54LCBfY29sb3IueSwgX2NvbG9yLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF92My54LCBfdjMueSwgX3YzLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF9uMy54LCBfbjMueSwgX24zLnopO1xyXG4gICAgICAgICAgZGF0YS5wdXNoKF9jb2xvci54LCBfY29sb3IueSwgX2NvbG9yLnopO1xyXG4gICAgICAgICAgZGVidWdXcmFwcGVyLm51bVRyaURhdGErKztcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSBzb3VyY2UgY29kZSAoc3RyaW5nKSBvZiB0aGUgaW4gcGh5c2ljc0RlYnVnIHVzZWQgdmVyeSBzaW1wbGUgdmVydGV4U2hhZGVyLlxyXG4gICAgICogIEhhbmRsaW5nIHRoZSBwcm9qZWN0aW9uICh3aGljaCBpbmNsdWRlcywgdmlldy93b3JsZFtpcyBhbHdheXMgaWRlbnRpdHkgaW4gdGhpcyBjYXNlXS9wcm9qZWN0aW9uIGluIEZVREdFKS4gSW5jcmVhc2luZyB0aGUgc2l6ZSBvZiBzaW5nbGUgcG9pbnRzIGRyYXduLlxyXG4gICAgICogIEFuZCB0cmFuc2ZlciBwb3NpdGlvbiBjb2xvciB0byB0aGUgZnJhZ21lbnRTaGFkZXIuICovXHJcbiAgICBwcml2YXRlIHZlcnRleFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYFxyXG5cdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHRcdFx0YXR0cmlidXRlIHZlYzMgYVBvc2l0aW9uO1xyXG5cdFx0XHRhdHRyaWJ1dGUgdmVjMyBhQ29sb3I7XHJcblx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XHJcblx0XHRcdHZhcnlpbmcgdmVjMyB2UG9zaXRpb247XHJcblx0XHRcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xyXG5cdFx0XHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xyXG5cdFx0XHR1bmlmb3JtIG1hdDQgdV9tdHhXb3JsZFRvVmlldztcclxuXHJcblx0XHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0XHR2UG9zaXRpb24gPSBhUG9zaXRpb247XHJcblx0XHRcdFx0dkNvbG9yID0gYUNvbG9yO1xyXG5cdFx0XHRcdHZOb3JtYWwgPSBhTm9ybWFsO1xyXG5cdFx0XHRcdGdsX1Bvc2l0aW9uID0gdV9tdHhXb3JsZFRvVmlldyAqIHZlYzQoYVBvc2l0aW9uLDEuMCk7XHJcblx0XHRcdFx0Z2xfUG9pbnRTaXplID0gNi4wO1xyXG5cdFx0XHR9YDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIHNvdXJjZSBjb2RlIChzdHJpbmcpIG9mIHRoZSBpbiBwaHlzaWNzRGVidWcgdXNlZCBzdXBlciBzaW1wbGUgZnJhZ21lbnRTaGFkZXIuIFVubGl0IC0gb25seSBjb2xvcml6aW5nIHRoZSBkcmF3biBwaXhlbHMsIG5vcm1hbHMvcG9zaXRpb24gYXJlIGdpdmVuIHRvIG1ha2UgaXQgZXhwYW5kYWJsZSAqL1xyXG4gICAgcHJpdmF0ZSBmcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYFxyXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XHJcblx0XHRcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XHJcblxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh2Q29sb3IsIDEuMCk7XHJcblx0XHRcdH1gO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBBIHBoeXNpY2FsIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggYSBkZWZpbmVkIGF4ZSBvZiB0cmFuc2xhdGlvbiBhbmQgcm90YXRpb24uIFR3byBEZWdyZWVzIG9mIEZyZWVkb20gaW4gdGhlIGRlZmluZWQgYXhpcy5cclxuICAgKiBUd28gUmlnaWRCb2RpZXMgbmVlZCB0byBiZSBkZWZpbmVkIHRvIHVzZSBpdC4gQSBtb3RvciBjYW4gYmUgZGVmaW5lZCBmb3Igcm90YXRpb24gYW5kIHRyYW5zbGF0aW9uLCBhbG9uZyB3aXRoIHNwcmluZyBzZXR0aW5ncy5cclxuICAgKiBcclxuICAgKiBgYGB0ZXh0XHJcbiAgICogICAgICAgICAgSm9pbnRIb2xkZXIgLSBib2R5QW5jaG9yXHJcbiAgICogICAgICAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkFxyXG4gICAqICAgICAgICAgICAgICAgICAgICDilIIgICDilIJcclxuICAgKiAgICAgICAgICAgPOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgiAgIOKUguKUgOKUgOKUgOKUgOKUgOKUgD4gdGllZCBib2R5LCBzbGlkaW5nIG9uIGF4aXMgPSAxc3QgZGVncmVlIG9mIGZyZWVkb21cclxuICAgKiAgICAgICAgICAgICAgICAgICAg4pSCICAg4pSCICAgICAgICByb3RhdGluZyBhcm91bmQgYXhpcyA9IDJuZCBkZWdyZWUgb2YgZnJlZWRvbSBcclxuICAgKiAgICAgICAgICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSYXHJcbiAgICogYGBgICBcclxuICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEpvaW50Q3lsaW5kcmljYWwgZXh0ZW5kcyBKb2ludEF4aWFsIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBKb2ludC5yZWdpc3RlclN1YmNsYXNzKEpvaW50Q3lsaW5kcmljYWwpO1xyXG5cclxuICAgIHByb3RlY3RlZCBqb2ludDogT0lNTy5DeWxpbmRyaWNhbEpvaW50O1xyXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogT0lNTy5DeWxpbmRyaWNhbEpvaW50Q29uZmlnID0gbmV3IE9JTU8uQ3lsaW5kcmljYWxKb2ludENvbmZpZygpO1xyXG4gICAgcHJvdGVjdGVkIG1vdG9yOiBPSU1PLlRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yO1xyXG5cclxuICAgICNzcHJpbmdEYW1waW5nUm90YXRpb246IG51bWJlciA9IDA7XHJcbiAgICAjc3ByaW5nRnJlcXVlbmN5Um90YXRpb246IG51bWJlciA9IDA7XHJcblxyXG4gICAgI21vdG9yRm9yY2U6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI21heFJvdG9yOiBudW1iZXIgPSAzNjA7XHJcbiAgICAjbWluUm90b3I6IG51bWJlciA9IDA7XHJcbiAgICAjcm90b3JUb3JxdWU6IG51bWJlciA9IDA7XHJcbiAgICAjcm90b3JTcGVlZDogbnVtYmVyID0gMDtcclxuXHJcbiAgICAjcm90b3I6IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3I7XHJcbiAgICAjcm90b3JTcHJpbmdEYW1wZXI6IE9JTU8uU3ByaW5nRGFtcGVyO1xyXG5cclxuICAgIC8qKiBDcmVhdGluZyBhIGN5bGluZHJpY2FsIGpvaW50IGJldHdlZW4gdHdvIENvbXBvbmVudFJpZ2lkYm9kaWVzIG1vdmluZyBvbiBvbmUgYXhpcyBhbmQgcm90YXRpbmcgYXJvdW5kIGFub3RoZXIgYm91bmQgb24gYSBsb2NhbCBhbmNob3Jwb2ludC4gKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYXhpczogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDEsIDApLCBfbG9jYWxBbmNob3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAwKSkge1xyXG4gICAgICBzdXBlcihfYm9keUFuY2hvciwgX2JvZHlUaWVkLCBfYXhpcywgX2xvY2FsQW5jaG9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBzcHJpbmdEYW1waW5nKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHN1cGVyLnNwcmluZ0RhbXBpbmcgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHJhbnNsYXRpb25hbFNwcmluZ0RhbXBlcigpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNwcmluZyBpbiBIei4gQXQgMCB0aGUgc3ByaW5nIGlzIHJpZ2lkLCBlcXVhbHMgbm8gc3ByaW5nLiBUaGUgc21hbGxlciB0aGUgdmFsdWUgdGhlIGxlc3MgcmVzdHJpY3RpdmUgaXMgdGhlIHNwcmluZy5cclxuICAgICovXHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0ZyZXF1ZW5jeShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBzdXBlci5zcHJpbmdGcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHJhbnNsYXRpb25hbFNwcmluZ0RhbXBlcigpLmZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC4gSW5mbHVlbmNpbmcgVE9SUVVFIC8gUk9UQVRJT05cclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0RhbXBpbmdSb3RhdGlvbigpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRGFtcGluZ1JvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzcHJpbmdEYW1waW5nUm90YXRpb24oX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZ1JvdGF0aW9uID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFJvdGF0aW9uYWxTcHJpbmdEYW1wZXIoKS5kYW1waW5nUmF0aW8gPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gSW5mbHVlbmNpbmcgVE9SUVVFIC8gUk9UQVRJT05cclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0ZyZXF1ZW5jeVJvdGF0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3lSb3RhdGlvbjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRnJlcXVlbmN5Um90YXRpb24oX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRnJlcXVlbmN5Um90YXRpb24gPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0Um90YXRpb25hbFNwcmluZ0RhbXBlcigpLmZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIFVwcGVyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMtQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1heFJvdG9yKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtYXhSb3RvcjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbWF4Um90b3IoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWF4Um90b3IgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0Um90YXRpb25hbExpbWl0TW90b3IoKS51cHBlckxpbWl0ID0gX3ZhbHVlICogQ2FsYy5kZWcycmFkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIExvd2VyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMgQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1pblJvdG9yKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtaW5Sb3RvcjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbWluUm90b3IoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWluUm90b3IgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0Um90YXRpb25hbExpbWl0TW90b3IoKS5sb3dlckxpbWl0ID0gX3ZhbHVlICogQ2FsYy5kZWcycmFkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIHRhcmdldCByb3RhdGlvbmFsIHNwZWVkIG9mIHRoZSBtb3RvciBpbiBtL3MuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHJvdG9yU3BlZWQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JvdG9yU3BlZWQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHJvdG9yU3BlZWQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jcm90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRSb3RhdGlvbmFsTGltaXRNb3RvcigpLm1vdG9yU3BlZWQgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgbWF4aW11bSBtb3RvciB0b3JxdWUgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcm90b3JUb3JxdWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JvdG9yVG9ycXVlO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCByb3RvclRvcnF1ZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyb3RvclRvcnF1ZSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRSb3RhdGlvbmFsTGltaXRNb3RvcigpLm1vdG9yVG9ycXVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBVcHBlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBtYXhNb3RvcihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBzdXBlci5tYXhNb3RvciA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbClcclxuICAgICAgICB0aGlzLmpvaW50LmdldFRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yKCkudXBwZXJMaW1pdCA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBMb3dlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBtaW5Nb3RvcihfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICBzdXBlci5taW5Nb3RvciA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbClcclxuICAgICAgICB0aGlzLmpvaW50LmdldFRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yKCkubG93ZXJMaW1pdCA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IG1vdG9yU3BlZWQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIubW90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbClcclxuICAgICAgICB0aGlzLmpvaW50LmdldFRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yKCkubW90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBtYXhpbXVtIG1vdG9yIGZvcmNlIGluIE5ld3Rvbi4gZm9yY2UgPD0gMCBlcXVhbHMgZGlzYWJsZWQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1vdG9yRm9yY2UoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yRm9yY2U7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1vdG9yRm9yY2UoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbW90b3JGb3JjZSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUcmFuc2xhdGlvbmFsTGltaXRNb3RvcigpLm1vdG9yRm9yY2UgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNhdmluZy9Mb2FkaW5nXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuI2dldE11dGF0b3IoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHN1cGVyLnNlcmlhbGl6ZSgpO1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmRlbGV0ZUZyb21NdXRhdG9yKF9tdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IsIF9zZWxlY3Rpb24sIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0Sm9pbnQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMuI3JvdG9yU3ByaW5nRGFtcGVyID0gbmV3IE9JTU8uU3ByaW5nRGFtcGVyKCkuc2V0U3ByaW5nKHRoaXMuc3ByaW5nRnJlcXVlbmN5Um90YXRpb24sIHRoaXMuc3ByaW5nRGFtcGluZ1JvdGF0aW9uKTtcclxuXHJcbiAgICAgIHRoaXMubW90b3IgPSBuZXcgT0lNTy5UcmFuc2xhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyhzdXBlci5taW5Nb3Rvciwgc3VwZXIubWF4TW90b3IpO1xyXG4gICAgICB0aGlzLm1vdG9yLnNldE1vdG9yKHN1cGVyLm1vdG9yU3BlZWQsIHRoaXMubW90b3JGb3JjZSk7XHJcbiAgICAgIHRoaXMuI3JvdG9yID0gbmV3IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHModGhpcy5taW5Sb3RvciAqIENhbGMuZGVnMnJhZCwgdGhpcy5tYXhSb3RvciAqIENhbGMuZGVnMnJhZCk7XHJcbiAgICAgIHRoaXMuI3JvdG9yLnNldE1vdG9yKHRoaXMucm90b3JTcGVlZCwgdGhpcy5yb3RvclRvcnF1ZSk7XHJcblxyXG4gICAgICB0aGlzLmNvbmZpZyA9IG5ldyBPSU1PLkN5bGluZHJpY2FsSm9pbnRDb25maWcoKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQoKTtcclxuXHJcbiAgICAgIHRoaXMuY29uZmlnLnRyYW5zbGF0aW9uYWxTcHJpbmdEYW1wZXIgPSB0aGlzLnNwcmluZ0RhbXBlcjtcclxuICAgICAgdGhpcy5jb25maWcudHJhbnNsYXRpb25hbExpbWl0TW90b3IgPSB0aGlzLm1vdG9yO1xyXG4gICAgICB0aGlzLmNvbmZpZy5yb3RhdGlvbmFsTGltaXRNb3RvciA9IHRoaXMuI3JvdG9yO1xyXG4gICAgICB0aGlzLmNvbmZpZy5yb3RhdGlvbmFsU3ByaW5nRGFtcGVyID0gdGhpcy4jcm90b3JTcHJpbmdEYW1wZXI7XHJcblxyXG4gICAgICB0aGlzLmpvaW50ID0gbmV3IE9JTU8uQ3lsaW5kcmljYWxKb2ludCh0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHRoaXMuY29uZmlndXJlSm9pbnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAjZ2V0TXV0YXRvciA9ICgpOiBNdXRhdG9yID0+IHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSB7XHJcbiAgICAgICAgbW90b3JGb3JjZTogdGhpcy5tb3RvckZvcmNlLFxyXG4gICAgICAgIHNwcmluZ0RhbXBpbmdSb3RhdGlvbjogdGhpcy5zcHJpbmdEYW1waW5nUm90YXRpb24sXHJcbiAgICAgICAgc3ByaW5nRnJlcXVlbmN5Um90YXRpb246IHRoaXMuc3ByaW5nRnJlcXVlbmN5Um90YXRpb24sXHJcbiAgICAgICAgbWF4Um90b3I6IHRoaXMubWF4Um90b3IsXHJcbiAgICAgICAgbWluUm90b3I6IHRoaXMubWluUm90b3IsXHJcbiAgICAgICAgcm90b3JUb3JxdWU6IHRoaXMucm90b3JUb3JxdWUsXHJcbiAgICAgICAgcm90b3JTcGVlZDogdGhpcy5yb3RvclNwZWVkXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfTtcclxuXHJcbiAgICAjbXV0YXRlID0gKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCA9PiB7XHJcbiAgICAgIHRoaXMubXV0YXRlQmFzZShfbXV0YXRvciwgW1wibW90b3JGb3JjZVwiLCBcInJvdG9yVG9ycXVlXCIsIFwicm90b3JTcGVlZFwiLCBcIm1heFJvdG9yXCIsIFwibWluUm90b3JcIiwgXCJzcHJpbmdEYW1waW5nUm90YXRpb25cIiwgXCJzcHJpbmdGcmVxdWVuY3lSb3RhdGlvblwiLCBcInNwcmluZ0ZyZXF1ZW5jeVwiXSk7XHJcbiAgICB9O1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAgICogQSBwaHlzaWNhbCBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIGEgZGVmaW5lZCBheGUgbW92ZW1lbnQuXHJcbiAgICAgKiBVc2VkIHRvIGNyZWF0ZSBhIHNsaWRpbmcgam9pbnQgYWxvbmcgb25lIGF4aXMuIFR3byBSaWdpZEJvZGllcyBuZWVkIHRvIGJlIGRlZmluZWQgdG8gdXNlIGl0LlxyXG4gICAgICogQSBtb3RvciBjYW4gYmUgZGVmaW5lZCB0byBtb3ZlIHRoZSBjb25uZWN0ZWQgYWxvbmcgdGhlIGRlZmluZWQgYXhpcy4gR3JlYXQgdG8gY29uc3RydWN0IHN0YW5kYXJkIHNwcmluZ3Mgb3IgcGh5c2ljYWwgc2xpZGVycy5cclxuICAgICAqIFxyXG4gICAgICogYGBgdGV4dFxyXG4gICAgICogICAgICAgICAgSm9pbnRIb2xkZXIgLSBib2R5QW5jaG9yXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pSQXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAg4pSCICAg4pSCXHJcbiAgICAgKiAgICAgICAgICAgPOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgiAgIOKUguKUgOKUgOKUgOKUgOKUgOKUgD4gdGllZCBib2R5LCBzbGlkaW5nIG9uIG9uZSBBeGlzLCAxIERlZ3JlZSBvZiBGcmVlZG9tXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAg4pSCICAg4pSCXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSYXHJcbiAgICAgKiBgYGBcclxuICAgICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVLCAyMDIwIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBKb2ludFByaXNtYXRpYyBleHRlbmRzIEpvaW50QXhpYWwge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IEpvaW50LnJlZ2lzdGVyU3ViY2xhc3MoSm9pbnRQcmlzbWF0aWMpO1xyXG5cclxuICAgIHByb3RlY3RlZCBqb2ludDogT0lNTy5QcmlzbWF0aWNKb2ludDtcclxuICAgIHByb3RlY3RlZCBjb25maWc6IE9JTU8uUHJpc21hdGljSm9pbnRDb25maWcgPSBuZXcgT0lNTy5QcmlzbWF0aWNKb2ludENvbmZpZygpO1xyXG4gICAgcHJvdGVjdGVkIG1vdG9yOiBPSU1PLlRyYW5zbGF0aW9uYWxMaW1pdE1vdG9yO1xyXG4gICAgLy9JbnRlcm5hbGx5IHVzZWQgdmFyaWFibGVzIC0gSm9pbnQgUHJvcGVydGllcyB0aGF0IGFyZSB1c2VkIGV2ZW4gd2hlbiBubyBhY3R1YWwgam9pbnQgaXMgY3VycmVudGx5IGV4aXN0ZW50XHJcblxyXG4gICAgI21vdG9yRm9yY2U6IG51bWJlciA9IDA7XHJcblxyXG4gICAgLyoqIENyZWF0aW5nIGEgcHJpc21hdGljIGpvaW50IGJldHdlZW4gdHdvIENvbXBvbmVudFJpZ2lkYm9kaWVzIG9ubHkgbW92aW5nIG9uIG9uZSBheGlzIGJvdW5kIG9uIGEgbG9jYWwgYW5jaG9ycG9pbnQuICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2F4aXM6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAxLCAwKSwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCwgX2F4aXMsIF9sb2NhbEFuY2hvcik7XHJcblxyXG4gICAgICB0aGlzLm1heE1vdG9yID0gMTA7XHJcbiAgICAgIHRoaXMubWluTW90b3IgPSAtMTA7XHJcbiAgICB9XHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIG1heGltdW0gbW90b3IgZm9yY2UgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gVGhpcyBpcyB0aGUgZm9yY2UgdGhhdCB0aGUgbW90b3IgaXMgdXNpbmcgdG8gaG9sZCB0aGUgcG9zaXRpb24sIG9yIHJlYWNoIGl0IGlmIGEgbW90b3JTcGVlZCBpcyBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1vdG9yRm9yY2UoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yRm9yY2U7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1vdG9yRm9yY2UoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbW90b3JGb3JjZSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yKCkubW90b3JGb3JjZSA9IF92YWx1ZTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgbW90b3JGb3JjZTogdGhpcy5tb3RvckZvcmNlLFxyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5tb3RvckZvcmNlID0gX3NlcmlhbGl6YXRpb24ubW90b3JGb3JjZTtcclxuICAgICAgc3VwZXIuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgbGV0IG11dGF0b3I6IE11dGF0b3IgPSBzdXBlci5nZXRNdXRhdG9yKCk7XHJcbiAgICAgIG11dGF0b3IubW90b3JGb3JjZSA9IHRoaXMubW90b3JGb3JjZTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG11dGF0ZShfbXV0YXRvcjogTXV0YXRvciwgX3NlbGVjdGlvbjogc3RyaW5nW10gPSBudWxsLCBfZGlzcGF0Y2hNdXRhdGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9tdXRhdG9yLm1vdG9yRm9yY2UpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMubW90b3JGb3JjZSA9IF9tdXRhdG9yLm1vdG9yRm9yY2U7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5tb3RvckZvcmNlO1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IsIF9zZWxlY3Rpb24sIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICB9XHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvKiogQWN0dWFsIGNyZWF0aW9uIG9mIGEgam9pbnQgaW4gdGhlIE9pbW9QaHlzaWNzIHN5c3RlbSAqL1xyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdEpvaW50KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLm1vdG9yID0gbmV3IE9JTU8uVHJhbnNsYXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHModGhpcy5taW5Nb3RvciwgdGhpcy5tYXhNb3Rvcik7IC8vQ3JlYXRlIG1vdG9yIHNldHRpbmdzLCB0byBob2xkIHBvc2l0aW9ucywgc2V0IGNvbnN0cmFpbnQgbWluL21heFxyXG4gICAgICB0aGlzLm1vdG9yLnNldE1vdG9yKHRoaXMubW90b3JTcGVlZCwgdGhpcy5tb3RvckZvcmNlKTtcclxuXHJcbiAgICAgIHRoaXMuY29uZmlnID0gbmV3IE9JTU8uUHJpc21hdGljSm9pbnRDb25maWcoKTsgLy9DcmVhdGUgYSBzcGVjaWZpYyBjb25maWcgZm9yIHRoaXMgam9pbnQgdHlwZSB0aGF0IGlzIGNhbGN1bGF0aW5nIHRoZSBsb2NhbCBheGlzIGZvciBib3RoIGJvZGllc1xyXG4gICAgICBzdXBlci5jb25zdHJ1Y3RKb2ludCgpO1xyXG5cclxuICAgICAgdGhpcy5jb25maWcuc3ByaW5nRGFtcGVyID0gdGhpcy5zcHJpbmdEYW1wZXI7IC8vVGVsbGluZyB0aGUgY29uZmlnIHRvIHVzZSB0aGUgbW90b3Ivc3ByaW5nIG9mIHRoZSBGVURHRSBDb21wb25lbnRcclxuICAgICAgdGhpcy5jb25maWcubGltaXRNb3RvciA9IHRoaXMubW90b3I7XHJcblxyXG4gICAgICB0aGlzLmpvaW50ID0gbmV3IE9JTU8uUHJpc21hdGljSm9pbnQodGhpcy5jb25maWcpO1xyXG4gICAgICB0aGlzLmNvbmZpZ3VyZUpvaW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAqIEEgcGh5c2ljYWwgY29ubmVjdGlvbiBiZXR3ZWVuIHR3byBib2RpZXMsIGRlc2lnbmVkIHRvIHNpbXVsYXRlIGJlaGF2aW91ciB3aXRoaW4gYSByZWFsIGJvZHkuIEl0IGhhcyB0d28gYXhpcywgYSBzd2luZyBhbmQgdHdpc3QgYXhpcywgYW5kIGFsc28gdGhlIHBlcnBlbmRpY3VsYXIgYXhpcywgXHJcbiAgICAqIHNpbWlsYXIgdG8gYSBTcGhlcmljYWwgam9pbnQsIGJ1dCBtb3JlIHJlc3RyaWN0aXZlIGluIGl0J3MgYW5nbGVzIGFuZCBvbmx5IHR3byBkZWdyZWVzIG9mIGZyZWVkb20uIFR3byBSaWdpZEJvZGllcyBuZWVkIHRvIGJlIGRlZmluZWQgdG8gdXNlIGl0LiBNb3N0bHkgdXNlZCB0byBjcmVhdGUgaHVtYW5saWtlIGpvaW50cyB0aGF0IGJlaGF2ZSBsaWtlIGEgXHJcbiAgICAqIGxpZmVsZXNzIGJvZHkuXHJcbiAgICAqIGBgYHRleHQgICAgICAgIFxyXG4gICAgKiAgICAgICAgICAgICAgICAgIFxyXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgLSBpdCBjYW4gdHdpc3Qgb24gb25lIGF4aXMgYW5kIHN3aW5nIG9uIGFub3RoZXJcclxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXHJcbiAgICAqICAgICAgICAgeiAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkCDilIIg4pSM4pSA4pSA4pSA4pSQXHJcbiAgICAqICAgICAgICAg4oaRICAgICAgICAgICAg4pSCICAg4pSCIOKGkyDilIIgICDilIIgICAgICAgIGUuZy4geiA9IFR3aXN0QXhpcywgaXQgY2FuIHJvdGF0ZSBpbi1pdHNlbGYgYXJvdW5kIHRoaXMgYXhpcyBcclxuICAgICogICAgLXgg4oaQ4pSA4pS84pSA4oaSIHggICAgICAgIOKUgiAgIOKUgiB4IOKUgiAgIOKUgiAgICAgICAgZS5nLiB4ID0gU3dpbmdBeGlzLCBpdCBjYW4gcm90YXRlIGFuY2hvcmVkIGFyb3VuZCB0aGUgYmFzZSBvbiB0aGlzIGF4aXMgICBcclxuICAgICogICAgICAgICDihpMgICAgICAgICAgICDilIIgICDilIIgICDilIIgICDilIIgICAgICAgICAgIFxyXG4gICAgKiAgICAgICAgLXogICAgICAgICAgICDilJTilIDilIDilIDilJggICDilJTilIDilIDilIDilJggICAgICAgICBlLmcuIHlvdSBjYW4gdHdpc3QgdGhlIGxlZyBpbi1pdHNlbGYgdG8gYSBjZXJ0YWluIGRlZ3JlZSxcclxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dCBhbHNvIHJvdGF0ZSBpdCBmb3J3YXJkL2JhY2t3YXJkL2xlZnQvcmlnaHQgdG8gYSBjZXJ0YWluIGRlZ3JlZVxyXG4gICAgKiAgICAgICAgICAgICAgICBib2R5QW5jaG9yICAgICAgICAgIGJvZHlUaWVkXHJcbiAgICAqICAgICAgICAgICAgICAoZS5nLiBwZWx2aXMpICAgICAgICAgKGUuZy4gdXBwZXItbGVnKVxyXG4gICAgKiBcclxuICAgICogYGBgXHJcbiAgICAqIFR3aXN0IGVxdWFscyBhIHJvdGF0aW9uIGFyb3VuZCBhIHBvaW50IHdpdGhvdXQgbW92aW5nIG9uIGFuIGF4aXMuXHJcbiAgICAqIFN3aW5nIGVxdWFscyBhIHJvdGF0aW9uIG9uIGEgcG9pbnQgd2l0aCBhIG1vdmluZyBsb2NhbCBheGlzLlxyXG4gICAgICogQGF1dGhvciBNYXJrbyBGZWhyZW5iYWNoLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAgKi9cclxuICBleHBvcnQgY2xhc3MgSm9pbnRSYWdkb2xsIGV4dGVuZHMgSm9pbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IEpvaW50LnJlZ2lzdGVyU3ViY2xhc3MoSm9pbnRSYWdkb2xsKTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgam9pbnQ6IE9JTU8uUmFnZG9sbEpvaW50O1xyXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogT0lNTy5SYWdkb2xsSm9pbnRDb25maWcgPSBuZXcgT0lNTy5SYWdkb2xsSm9pbnRDb25maWcoKTtcclxuXHJcbiAgICAjc3ByaW5nRGFtcGluZ1R3aXN0OiBudW1iZXIgPSAwO1xyXG4gICAgI3NwcmluZ0ZyZXF1ZW5jeVR3aXN0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNzcHJpbmdEYW1waW5nU3dpbmc6IG51bWJlciA9IDA7XHJcbiAgICAjc3ByaW5nRnJlcXVlbmN5U3dpbmc6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI21heE1vdG9yVHdpc3Q6IG51bWJlciA9IDM2MDtcclxuICAgICNtaW5Nb3RvclR3aXN0OiBudW1iZXIgPSAwO1xyXG4gICAgI21vdG9yVG9ycXVlVHdpc3Q6IG51bWJlciA9IDA7XHJcbiAgICAjbW90b3JTcGVlZFR3aXN0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNtb3RvclR3aXN0OiBPSU1PLlJvdGF0aW9uYWxMaW1pdE1vdG9yO1xyXG4gICAgI3NwcmluZ0RhbXBlclR3aXN0OiBPSU1PLlNwcmluZ0RhbXBlcjtcclxuICAgICNzcHJpbmdEYW1wZXJTd2luZzogT0lNTy5TcHJpbmdEYW1wZXI7XHJcbiAgICAjYXhpc0ZpcnN0OiBPSU1PLlZlYzM7XHJcbiAgICAjYXhpc1NlY29uZDogT0lNTy5WZWMzO1xyXG5cclxuICAgICNtYXhBbmdsZUZpcnN0OiBudW1iZXIgPSAwO1xyXG4gICAgI21heEFuZ2xlU2Vjb25kOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYXhpc0ZpcnN0OiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMSwgMCwgMCksIF9heGlzU2Vjb25kOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMSksIF9sb2NhbEFuY2hvcjogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKDAsIDAsIDApKSB7XHJcbiAgICAgIHN1cGVyKF9ib2R5QW5jaG9yLCBfYm9keVRpZWQpO1xyXG4gICAgICB0aGlzLmF4aXNGaXJzdCA9IF9heGlzRmlyc3Q7XHJcbiAgICAgIHRoaXMuYXhpc1NlY29uZCA9IF9heGlzU2Vjb25kO1xyXG4gICAgICB0aGlzLmFuY2hvciA9IF9sb2NhbEFuY2hvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXhpcyBjb25uZWN0aW5nIHRoZSB0aGUgdHdvIHtAbGluayBOb2RlfXMgZS5nLiBWZWN0b3IzKDAsMSwwKSB0byBoYXZlIGEgdXB3YXJkIGNvbm5lY3Rpb24uXHJcbiAgICAgKiAgV2hlbiBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIHRoZSBqb2ludCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBheGlzRmlyc3QoKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLiNheGlzRmlyc3QueCwgdGhpcy4jYXhpc0ZpcnN0LnksIHRoaXMuI2F4aXNGaXJzdC56KTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgYXhpc0ZpcnN0KF92YWx1ZTogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLiNheGlzRmlyc3QgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGUgYXhpcyBjb25uZWN0aW5nIHRoZSB0aGUgdHdvIHtAbGluayBOb2RlfXMgZS5nLiBWZWN0b3IzKDAsMSwwKSB0byBoYXZlIGEgdXB3YXJkIGNvbm5lY3Rpb24uXHJcbiAgICAqICBXaGVuIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gdGhlIGpvaW50IG5lZWRzIHRvIGJlIHJlY29ubmVjdGVkLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBnZXQgYXhpc1NlY29uZCgpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuI2F4aXNTZWNvbmQueCwgdGhpcy4jYXhpc1NlY29uZC55LCB0aGlzLiNheGlzU2Vjb25kLnopO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBheGlzU2Vjb25kKF92YWx1ZTogVmVjdG9yMykge1xyXG4gICAgICB0aGlzLiNheGlzU2Vjb25kID0gbmV3IE9JTU8uVmVjMyhfdmFsdWUueCwgX3ZhbHVlLnksIF92YWx1ZS56KTtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXhpbXVtIGFuZ2xlIG9mIHJvdGF0aW9uIGFsb25nIHRoZSBmaXJzdCBheGlzLiBWYWx1ZSBuZWVkcyB0byBiZSBwb3NpdGl2ZS4gQ2hhbmdlcyBkbyByZWJ1aWxkIHRoZSBqb2ludFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1heEFuZ2xlRmlyc3RBeGlzKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtYXhBbmdsZUZpcnN0ICogQ2FsYy5yYWQyZGVnO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBtYXhBbmdsZUZpcnN0QXhpcyhfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtYXhBbmdsZUZpcnN0ID0gX3ZhbHVlICogQ2FsYy5kZWcycmFkO1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5kaXJ0eVN0YXR1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gYW5nbGUgb2Ygcm90YXRpb24gYWxvbmcgdGhlIHNlY29uZCBheGlzLiBWYWx1ZSBuZWVkcyB0byBiZSBwb3NpdGl2ZS4gQ2hhbmdlcyBkbyByZWJ1aWxkIHRoZSBqb2ludFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1heEFuZ2xlU2Vjb25kQXhpcygpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWF4QW5nbGVTZWNvbmQgKiBDYWxjLnJhZDJkZWc7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1heEFuZ2xlU2Vjb25kQXhpcyhfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtYXhBbmdsZVNlY29uZCA9IF92YWx1ZSAqIENhbGMuZGVnMnJhZDtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuZGlydHlTdGF0dXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkYW1waW5nIG9mIHRoZSBzcHJpbmcuIDEgZXF1YWxzIGNvbXBsZXRseSBkYW1wZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc3ByaW5nRGFtcGluZ1R3aXN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdEYW1waW5nVHdpc3Q7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0RhbXBpbmdUd2lzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdEYW1waW5nVHdpc3QgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHdpc3RTcHJpbmdEYW1wZXIoKS5kYW1waW5nUmF0aW8gPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gVGhlIHNtYWxsZXIgdGhlIHZhbHVlIHRoZSBsZXNzIHJlc3RyaWN0aXZlIGlzIHRoZSBzcHJpbmcuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGdldCBzcHJpbmdGcmVxdWVuY3lUd2lzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5VHdpc3Q7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0ZyZXF1ZW5jeVR3aXN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVR3aXN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFR3aXN0U3ByaW5nRGFtcGVyKCkuZnJlcXVlbmN5ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBzcHJpbmdEYW1waW5nU3dpbmcoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmdTd2luZztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRGFtcGluZ1N3aW5nKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0RhbXBpbmdTd2luZyA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTd2luZ1NwcmluZ0RhbXBlcigpLmRhbXBpbmdSYXRpbyA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNwcmluZyBpbiBIei4gQXQgMCB0aGUgc3ByaW5nIGlzIHJpZ2lkLCBlcXVhbHMgbm8gc3ByaW5nLiBUaGUgc21hbGxlciB0aGUgdmFsdWUgdGhlIGxlc3MgcmVzdHJpY3RpdmUgaXMgdGhlIHNwcmluZy5cclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0ZyZXF1ZW5jeVN3aW5nKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3lTd2luZztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgc3ByaW5nRnJlcXVlbmN5U3dpbmcoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRnJlcXVlbmN5U3dpbmcgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0U3dpbmdTcHJpbmdEYW1wZXIoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIFVwcGVyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMtQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1heE1vdG9yVHdpc3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21heE1vdG9yVHdpc3QgKiBDYWxjLnJhZDJkZWc7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1heE1vdG9yVHdpc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgX3ZhbHVlICo9IENhbGMuZGVnMnJhZDtcclxuICAgICAgdGhpcy4jbWF4TW90b3JUd2lzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUd2lzdExpbWl0TW90b3IoKS51cHBlckxpbWl0ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIExvd2VyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMgQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1pbk1vdG9yVHdpc3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21pbk1vdG9yVHdpc3QgKiBDYWxjLnJhZDJkZWc7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1pbk1vdG9yVHdpc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgX3ZhbHVlICo9IENhbGMuZGVnMnJhZDtcclxuICAgICAgdGhpcy4jbWluTW90b3JUd2lzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUd2lzdExpbWl0TW90b3IoKS5sb3dlckxpbWl0ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSB0YXJnZXQgcm90YXRpb25hbCBzcGVlZCBvZiB0aGUgbW90b3IgaW4gbS9zLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtb3RvclNwZWVkVHdpc3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yU3BlZWRUd2lzdDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbW90b3JTcGVlZFR3aXN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21vdG9yU3BlZWRUd2lzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRUd2lzdExpbWl0TW90b3IoKS5tb3RvclNwZWVkID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBtYXhpbXVtIG1vdG9yIHRvcnF1ZSBpbiBOZXd0b24uIGZvcmNlIDw9IDAgZXF1YWxzIGRpc2FibGVkLiBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtb3RvclRvcnF1ZVR3aXN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtb3RvclRvcnF1ZVR3aXN0O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBtb3RvclRvcnF1ZVR3aXN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21vdG9yVG9ycXVlVHdpc3QgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0VHdpc3RMaW1pdE1vdG9yKCkubW90b3JUb3JxdWUgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogSWYgdGhlIHR3byBjb25uZWN0ZWQgUmlnaWRCb2RpZXMgY29sbGlkZSB3aXRoIGVhdGggb3RoZXIuIChEZWZhdWx0ID0gZmFsc2UpXHJcbiAgICAgKi9cclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gU2F2aW5nL0xvYWRpbmdcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0gdGhpcy4jZ2V0TXV0YXRvcigpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmF4aXNGaXJzdCA9IHRoaXMuYXhpc0ZpcnN0LnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uLmF4aXNTZWNvbmQgPSB0aGlzLmF4aXNTZWNvbmQuc2VyaWFsaXplKCk7XHJcbiAgICAgIHNlcmlhbGl6YXRpb25bc3VwZXIuY29uc3RydWN0b3IubmFtZV0gPSBzdXBlci5zZXJpYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgYXdhaXQgdGhpcy5heGlzRmlyc3QuZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb24uYXhpc0ZpcnN0KTtcclxuICAgICAgYXdhaXQgdGhpcy5heGlzU2Vjb25kLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmF4aXNTZWNvbmQpO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5heGlzRmlyc3QpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMuYXhpc0ZpcnN0ID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmF4aXNGaXJzdCkpKTtcclxuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IuYXhpc1NlY29uZCkgIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgdGhpcy5heGlzU2Vjb25kID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmF4aXNTZWNvbmQpKSk7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5heGlzRmlyc3Q7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5heGlzU2Vjb25kO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmRlbGV0ZUZyb21NdXRhdG9yKF9tdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IsIF9zZWxlY3Rpb24sIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIG11dGF0b3IuYXhpc0ZpcnN0ID0gdGhpcy5heGlzRmlyc3QuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBtdXRhdG9yLmF4aXNTZWNvbmQgPSB0aGlzLmF4aXNTZWNvbmQuZ2V0TXV0YXRvcigpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGVyVHdpc3QgPSBuZXcgT0lNTy5TcHJpbmdEYW1wZXIoKS5zZXRTcHJpbmcodGhpcy5zcHJpbmdGcmVxdWVuY3lUd2lzdCwgdGhpcy5zcHJpbmdEYW1waW5nVHdpc3QpO1xyXG4gICAgICB0aGlzLiNzcHJpbmdEYW1wZXJTd2luZyA9IG5ldyBPSU1PLlNwcmluZ0RhbXBlcigpLnNldFNwcmluZyh0aGlzLnNwcmluZ0ZyZXF1ZW5jeVN3aW5nLCB0aGlzLnNwcmluZ0RhbXBpbmdTd2luZyk7XHJcblxyXG4gICAgICB0aGlzLiNtb3RvclR3aXN0ID0gbmV3IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHModGhpcy5taW5Nb3RvclR3aXN0LCB0aGlzLm1heE1vdG9yVHdpc3QpO1xyXG4gICAgICB0aGlzLiNtb3RvclR3aXN0LnNldE1vdG9yKHRoaXMubW90b3JTcGVlZFR3aXN0LCB0aGlzLm1vdG9yVG9ycXVlVHdpc3QpO1xyXG5cclxuICAgICAgdGhpcy5jb25maWcgPSBuZXcgT0lNTy5SYWdkb2xsSm9pbnRDb25maWcoKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQodGhpcy5heGlzRmlyc3QsIHRoaXMuYXhpc1NlY29uZCk7XHJcbiAgICAgIHRoaXMuY29uZmlnLnN3aW5nU3ByaW5nRGFtcGVyID0gdGhpcy4jc3ByaW5nRGFtcGVyU3dpbmc7XHJcbiAgICAgIHRoaXMuY29uZmlnLnR3aXN0U3ByaW5nRGFtcGVyID0gdGhpcy4jc3ByaW5nRGFtcGVyVHdpc3Q7XHJcbiAgICAgIHRoaXMuY29uZmlnLnR3aXN0TGltaXRNb3RvciA9IHRoaXMuI21vdG9yVHdpc3Q7XHJcbiAgICAgIHRoaXMuY29uZmlnLm1heFN3aW5nQW5nbGUxID0gdGhpcy4jbWF4QW5nbGVGaXJzdDtcclxuICAgICAgdGhpcy5jb25maWcubWF4U3dpbmdBbmdsZTIgPSB0aGlzLiNtYXhBbmdsZVNlY29uZDtcclxuXHJcbiAgICAgIHRoaXMuam9pbnQgPSBuZXcgT0lNTy5SYWdkb2xsSm9pbnQodGhpcy5jb25maWcpO1xyXG4gICAgICBzdXBlci5jb25maWd1cmVKb2ludCgpO1xyXG4gICAgfVxyXG5cclxuICAgICNnZXRNdXRhdG9yID0gKCk6IE11dGF0b3IgPT4ge1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHtcclxuICAgICAgICBtYXhBbmdsZUZpcnN0OiB0aGlzLiNtYXhBbmdsZUZpcnN0LFxyXG4gICAgICAgIG1heEFuZ2xlU2Vjb25kOiB0aGlzLiNtYXhBbmdsZVNlY29uZCxcclxuICAgICAgICBzcHJpbmdEYW1waW5nVHdpc3Q6IHRoaXMuc3ByaW5nRGFtcGluZ1R3aXN0LFxyXG4gICAgICAgIHNwcmluZ0ZyZXF1ZW5jeVR3aXN0OiB0aGlzLnNwcmluZ0ZyZXF1ZW5jeVR3aXN0LFxyXG4gICAgICAgIHNwcmluZ0RhbXBpbmdTd2luZzogdGhpcy5zcHJpbmdEYW1waW5nU3dpbmcsXHJcbiAgICAgICAgc3ByaW5nRnJlcXVlbmN5U3dpbmc6IHRoaXMuc3ByaW5nRnJlcXVlbmN5U3dpbmcsXHJcbiAgICAgICAgbWF4TW90b3JUd2lzdDogdGhpcy4jbWF4TW90b3JUd2lzdCxcclxuICAgICAgICBtaW5Nb3RvclR3aXN0OiB0aGlzLiNtaW5Nb3RvclR3aXN0LFxyXG4gICAgICAgIG1vdG9yU3BlZWRUd2lzdDogdGhpcy5tb3RvclNwZWVkVHdpc3QsXHJcbiAgICAgICAgbW90b3JUb3JxdWVUd2lzdDogdGhpcy5tb3RvclRvcnF1ZVR3aXN0XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfTtcclxuXHJcbiAgICAjbXV0YXRlID0gKF9tdXRhdG9yOiBNdXRhdG9yKTogdm9pZCA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgKF9tdXRhdG9yLm1heEFuZ2xlRmlyc3QpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMuI21heEFuZ2xlRmlyc3QgPSBfbXV0YXRvci5tYXhBbmdsZUZpcnN0O1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5tYXhBbmdsZVNlY29uZCkgIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgdGhpcy4jbWF4QW5nbGVTZWNvbmQgPSBfbXV0YXRvci5tYXhBbmdsZVNlY29uZDtcclxuICAgICAgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBbXHJcbiAgICAgICAgXCJzcHJpbmdEYW1waW5nVHdpc3RcIiwgXCJzcHJpbmdGcmVxdWVuY3lUd2lzdFwiLCBcInNwcmluZ0RhbXBpbmdTd2luZ1wiLCBcInNwcmluZ0ZyZXF1ZW5jeVN3aW5nXCIsIFwibWF4TW90b3JUd2lzdFwiLCBcIm1pbk1vdG9yVHdpc3RcIiwgXCJtb3RvclNwZWVkVHdpc3RcIiwgXCJtb3RvclRvcnF1ZVR3aXN0XCJcclxuICAgICAgXSk7XHJcbiAgICB9O1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAgICogQSBwaHlzaWNhbCBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGJvZGllcyB3aXRoIGEgZGVmaW5lZCBheGUgb2Ygcm90YXRpb24uIEFsc28ga25vd24gYXMgSElOR0Ugam9pbnQuXHJcbiAgICAgKiBUd28gUmlnaWRCb2RpZXMgbmVlZCB0byBiZSBkZWZpbmVkIHRvIHVzZSBpdC4gQSBtb3RvciBjYW4gYmUgZGVmaW5lZCB0byByb3RhdGUgdGhlIGNvbm5lY3RlZCBhbG9uZyB0aGUgZGVmaW5lZCBheGlzLlxyXG4gICAgICogXHJcbiAgICAgKiBgYGB0ZXh0ICAgICAgICBcclxuICAgICAqICAgICAgICAgICAgICAgICAgcm90YXRpb24gYXhpcywgMXN0IERlZ3JlZSBvZiBmcmVlZG9tXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAg4oaRXHJcbiAgICAgKiAgICAgICAgICAgICAgIOKUjOKUgOKUgOKUgOKUkOKUguKUjOKUgOKUgOKUgOKUgOKUkCAgICAgXHJcbiAgICAgKiAgICAgICAgICAgICAgIOKUgiAgIOKUguKUguKUgiAgICDilIIgIFxyXG4gICAgICogICAgICAgICAgICAgICDilIIgICDilILilILilIIgICAg4pSCIFxyXG4gICAgICogICAgICAgICAgICAgICDilIIgICDilILilILilIIgICAg4pSCIFxyXG4gICAgICogICAgICAgICAgICAgICDilJTilIDilIDilIDilJjilILilJTilIDilIDilIDilIDilJhcclxuICAgICAqICAgICAgICAgICAgICAgICAgICDilIIgICBcclxuICAgICAqICAgICAgYm9keUFuY2hvciAgICAgICAgIGJvZHlUaWVkXHJcbiAgICAgKiAgIChlLmcuIERvb3JoaW5nZSkgICAgICAgKGUuZy4gRG9vcilcclxuICAgICAqIGBgYFxyXG4gICAgICogQGF1dGhvciBNYXJrbyBGZWhyZW5iYWNoLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEpvaW50UmV2b2x1dGUgZXh0ZW5kcyBKb2ludEF4aWFsIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBKb2ludC5yZWdpc3RlclN1YmNsYXNzKEpvaW50UmV2b2x1dGUpO1xyXG5cclxuICAgIHByb3RlY3RlZCBqb2ludDogT0lNTy5SZXZvbHV0ZUpvaW50O1xyXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogT0lNTy5SZXZvbHV0ZUpvaW50Q29uZmlnID0gbmV3IE9JTU8uUmV2b2x1dGVKb2ludENvbmZpZygpO1xyXG5cclxuICAgICNtb3RvclRvcnF1ZTogbnVtYmVyID0gMDtcclxuICAgICNyb3RvcjogT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2F4aXM6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAxLCAwKSwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCwgX2F4aXMsIF9sb2NhbEFuY2hvcik7XHJcblxyXG4gICAgICB0aGlzLm1heE1vdG9yID0gMzYwO1xyXG4gICAgICB0aGlzLm1pbk1vdG9yID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgVXBwZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcy1BbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgbWF4TW90b3IoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIubWF4TW90b3IgPSBfdmFsdWU7XHJcbiAgICAgIF92YWx1ZSAqPSBDYWxjLmRlZzJyYWQ7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50KVxyXG4gICAgICAgIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcigpLnVwcGVyTGltaXQgPSBfdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgTG93ZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcyBBbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgbWluTW90b3IoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgc3VwZXIubWluTW90b3IgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50KVxyXG4gICAgICAgIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcigpLmxvd2VyTGltaXQgPSBfdmFsdWUgKiBDYWxjLmRlZzJyYWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIG1heGltdW0gbW90b3IgZm9yY2UgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbW90b3JUb3JxdWUoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI21vdG9yVG9ycXVlO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBtb3RvclRvcnF1ZShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtb3RvclRvcnF1ZSA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yKCkubW90b3JUb3JxdWUgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogSWYgdGhlIHR3byBjb25uZWN0ZWQgUmlnaWRCb2RpZXMgY29sbGlkZSB3aXRoIGVhdGggb3RoZXIuIChEZWZhdWx0ID0gZmFsc2UpXHJcbiAgICAgKi9cclxuXHJcbiAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAvLyNyZWdpb24gU2F2aW5nL0xvYWRpbmdcclxuICAgIHB1YmxpYyBzZXJpYWxpemUoKTogU2VyaWFsaXphdGlvbiB7XHJcbiAgICAgIGxldCBzZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uID0ge1xyXG4gICAgICAgIG1vdG9yVG9ycXVlOiB0aGlzLm1vdG9yVG9ycXVlLFxyXG4gICAgICAgIFtzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXTogc3VwZXIuc2VyaWFsaXplKClcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uOiBTZXJpYWxpemF0aW9uKTogUHJvbWlzZTxTZXJpYWxpemFibGU+IHtcclxuICAgICAgdGhpcy5tb3RvclRvcnF1ZSA9IF9zZXJpYWxpemF0aW9uLm1vdG9yVG9ycXVlO1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IoKTtcclxuICAgICAgbXV0YXRvci5tb3RvclRvcnF1ZSA9IHRoaXMubW90b3JUb3JxdWU7XHJcbiAgICAgIHJldHVybiBtdXRhdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5tb3RvclRvcnF1ZSkgIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgdGhpcy5tb3RvclRvcnF1ZSA9IF9tdXRhdG9yLm1vdG9yVG9ycXVlO1xyXG4gICAgICBkZWxldGUgX211dGF0b3IubW90b3JUb3JxdWU7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcm90b3IgPSBuZXcgT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyhzdXBlci5taW5Nb3RvciAqIENhbGMuZGVnMnJhZCwgc3VwZXIubWF4TW90b3IgKiBDYWxjLmRlZzJyYWQpO1xyXG4gICAgICB0aGlzLiNyb3Rvci5zZXRNb3Rvcih0aGlzLm1vdG9yU3BlZWQsIHRoaXMubW90b3JUb3JxdWUpO1xyXG5cclxuICAgICAgdGhpcy5jb25maWcgPSBuZXcgT0lNTy5SZXZvbHV0ZUpvaW50Q29uZmlnKCk7XHJcbiAgICAgIHN1cGVyLmNvbnN0cnVjdEpvaW50KCk7XHJcblxyXG4gICAgICB0aGlzLmNvbmZpZy5zcHJpbmdEYW1wZXIgPSB0aGlzLnNwcmluZ0RhbXBlcjtcclxuICAgICAgdGhpcy5jb25maWcubGltaXRNb3RvciA9IHRoaXMuI3JvdG9yO1xyXG5cclxuICAgICAgdGhpcy5qb2ludCA9IG5ldyBPSU1PLlJldm9sdXRlSm9pbnQodGhpcy5jb25maWcpO1xyXG4gICAgICB0aGlzLmNvbmZpZ3VyZUpvaW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAgKiBBIHBoeXNpY2FsIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggdGhyZWUgRGVncmVlcyBvZiBGcmVlZG9tLCBhbHNvIGtub3duIGFzIGJhbGwgYW5kIHNvY2tldCBqb2ludC4gVHdvIGJvZGllcyBjb25uZWN0ZWQgYXQgdGhlaXIgYW5jaG9yIGJ1dCBmcmVlIHRvIHJvdGF0ZS5cclxuICAgICAqIFVzZWQgZm9yIHRoaW5ncyBsaWtlIHRoZSBjb25uZWN0aW9uIG9mIGJvbmVzIGluIHRoZSBodW1hbiBzaG91bGRlciAoaWYgc2ltcGxpZmllZCwgZWxzZSBiZXR0ZXIgdXNlIEpvaW50UmFnZG9sbCkuIFR3byBSaWdpZEJvZGllcyBuZWVkIHRvIGJlIGRlZmluZWQgdG8gdXNlIGl0LiBPbmx5IHNwcmluZyBzZXR0aW5ncyBjYW4gYmUgZGVmaW5lZC5cclxuICAgICAqIDMgRGVncmVlcyBhcmUgc3dpbmcgaG9yaXpvbnRhbCwgc3dpbmcgdmVydGljYWwgYW5kIHR3aXN0LlxyXG4gICAgICogXHJcbiAgICAgKiBgYGB0ZXh0XHJcbiAgICAgKiAgICAgICAgICAgICAgSm9pbnRIb2xkZXJcclxuICAgICAqICAgICAgICAgeiAgICAgIGJvZHlBbmNob3IgKGUuZy4gSHVtYW4tU2hvdWxkZXIpICAgICBcclxuICAgICAqICAgICAgeSAg4oaRICAgICAgICAgIFxyXG4gICAgICogICAgICAgIFxcfCAgICAgICAgICDilIDilIDilIAo4peP4pSA4pSA4pSAXHJcbiAgICAgKiAgLXggPC0tLXwtLS0+IHggICAgICAgICAgIGJvZHlUaWVkICAgICAgICBcclxuICAgICAqICAgICAgICAgfFxcICAgICAgICAgICAgICAgIChlLmcuIFVwcGVyLUFybSkgXHJcbiAgICAgKiAgICAgICAgIOKGkyAteSAgICAgICBcclxuICAgICAqICAgICAgICAteiAgICAgICAgICBcclxuICAgICAqIGBgYFxyXG4gICAgICogQGF1dGhvciBNYXJrbyBGZWhyZW5iYWNoLCBIRlUsIDIwMjAgfCBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAyMVxyXG4gICAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEpvaW50U3BoZXJpY2FsIGV4dGVuZHMgSm9pbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IEpvaW50LnJlZ2lzdGVyU3ViY2xhc3MoSm9pbnRTcGhlcmljYWwpO1xyXG5cclxuICAgIHByb3RlY3RlZCBqb2ludDogT0lNTy5TcGhlcmljYWxKb2ludDtcclxuICAgIHByb3RlY3RlZCBjb25maWc6IE9JTU8uU3BoZXJpY2FsSm9pbnRDb25maWcgPSBuZXcgT0lNTy5TcGhlcmljYWxKb2ludENvbmZpZygpO1xyXG5cclxuICAgICNzcHJpbmdEYW1waW5nOiBudW1iZXIgPSAwO1xyXG4gICAgI3NwcmluZ0ZyZXF1ZW5jeTogbnVtYmVyID0gMDtcclxuICAgICNzcHJpbmdEYW1wZXI6IE9JTU8uU3ByaW5nRGFtcGVyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYm9keUFuY2hvcjogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2JvZHlUaWVkOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfbG9jYWxBbmNob3I6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAwKSkge1xyXG4gICAgICBzdXBlcihfYm9keUFuY2hvciwgX2JvZHlUaWVkKTtcclxuICAgICAgdGhpcy5hbmNob3IgPSBuZXcgVmVjdG9yMyhfbG9jYWxBbmNob3IueCwgX2xvY2FsQW5jaG9yLnksIF9sb2NhbEFuY2hvci56KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyNyZWdpb24gR2V0L1NldCB0cmFuc2ZvciBvZiBmdWRnZSBwcm9wZXJ0aWVzIHRvIHRoZSBwaHlzaWNzIGVuZ2luZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhbXBpbmcgb2YgdGhlIHNwcmluZy4gMSBlcXVhbHMgY29tcGxldGx5IGRhbXBlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBzcHJpbmdEYW1waW5nKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdEYW1waW5nO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzcHJpbmdEYW1waW5nKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0RhbXBpbmcgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0U3ByaW5nRGFtcGVyKCkuZGFtcGluZ1JhdGlvID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyZXF1ZW5jeSBvZiB0aGUgc3ByaW5nIGluIEh6LiBBdCAwIHRoZSBzcHJpbmcgaXMgcmlnaWQsIGVxdWFscyBubyBzcHJpbmcuIFRoZSBzbWFsbGVyIHRoZSB2YWx1ZSB0aGUgbGVzcyByZXN0cmljdGl2ZSBpcyB0aGUgc3ByaW5nLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc3ByaW5nRnJlcXVlbmN5KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3k7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0ZyZXF1ZW5jeShfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdGcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0U3ByaW5nRGFtcGVyKCkuZnJlcXVlbmN5ID0gX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNhdmluZy9Mb2FkaW5nXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHtcclxuICAgICAgICBzcHJpbmdEYW1waW5nOiB0aGlzLnNwcmluZ0RhbXBpbmcsXHJcbiAgICAgICAgc3ByaW5nRnJlcXVlbmN5OiB0aGlzLnNwcmluZ0ZyZXF1ZW5jeSxcclxuICAgICAgICBbc3VwZXIuY29uc3RydWN0b3IubmFtZV06IHN1cGVyLnNlcmlhbGl6ZSgpXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuc3ByaW5nRGFtcGluZyA9IF9zZXJpYWxpemF0aW9uLnNwcmluZ0RhbXBpbmc7XHJcbiAgICAgIHRoaXMuc3ByaW5nRnJlcXVlbmN5ID0gX3NlcmlhbGl6YXRpb24uc3ByaW5nRnJlcXVlbmN5O1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRNdXRhdG9yKCk6IE11dGF0b3Ige1xyXG4gICAgICBsZXQgbXV0YXRvcjogTXV0YXRvciA9IHN1cGVyLmdldE11dGF0b3IoKTtcclxuICAgICAgbXV0YXRvci5zcHJpbmdEYW1waW5nID0gdGhpcy5zcHJpbmdEYW1waW5nO1xyXG4gICAgICBtdXRhdG9yLnNwcmluZ0ZyZXF1ZW5jeSA9IHRoaXMuc3ByaW5nRnJlcXVlbmN5O1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbXV0YXRlKF9tdXRhdG9yOiBNdXRhdG9yLCBfc2VsZWN0aW9uOiBzdHJpbmdbXSA9IG51bGwsIF9kaXNwYXRjaE11dGF0ZTogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBbXCJzcHJpbmdEYW1waW5nXCIsIFwic3ByaW5nRnJlcXVlbmN5XCJdKTtcclxuICAgICAgZGVsZXRlIF9tdXRhdG9yLnNwcmluZ0RhbXBpbmc7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5zcHJpbmdGcmVxdWVuY3k7XHJcbiAgICAgIGF3YWl0IHN1cGVyLm11dGF0ZShfbXV0YXRvciwgX3NlbGVjdGlvbiwgX2Rpc3BhdGNoTXV0YXRlKTtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGVyID0gbmV3IE9JTU8uU3ByaW5nRGFtcGVyKCkuc2V0U3ByaW5nKHRoaXMuc3ByaW5nRnJlcXVlbmN5LCB0aGlzLnNwcmluZ0RhbXBpbmcpO1xyXG4gICAgICB0aGlzLmNvbmZpZyA9IG5ldyBPSU1PLlNwaGVyaWNhbEpvaW50Q29uZmlnKCk7XHJcbiAgICAgIHN1cGVyLmNvbnN0cnVjdEpvaW50KCk7XHJcbiAgICAgIHRoaXMuY29uZmlnLnNwcmluZ0RhbXBlciA9IHRoaXMuI3NwcmluZ0RhbXBlcjtcclxuXHJcbiAgICAgIHRoaXMuam9pbnQgPSBuZXcgT0lNTy5TcGhlcmljYWxKb2ludCh0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHN1cGVyLmNvbmZpZ3VyZUpvaW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAgKiBBIHBoeXNpY2FsIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggdHdvIGRlZmluZWQgYXhpcyAobm9ybWFsbHkgZS5nLiAoMCwwLDEpIGFuZCByb3RhdGlvbigxLDAsMCkpLCB0aGV5IHNoYXJlIHRoZSBzYW1lIGFuY2hvciBhbmQgaGF2ZSBmcmVlIHJvdGF0aW9uLCBidXQgdHJhbnNmZXIgdGhlIHR3aXN0LlxyXG4gICAgICogSW4gcmVhbGl0eSB1c2VkIGluIGNhcnMgdG8gdHJhbnNmZXIgdGhlIG1vcmUgc3RhYmxlIHN0YXRpb25hcnkgZm9yY2Ugb24gdGhlIHZlbG9jaXR5IGF4aXMgdG8gdGhlIGJ1bXBpbmcsIGRhbXBlZCBtb3Zpbmcgd2hlZWwuIFR3byBSaWdpZEJvZGllcyBuZWVkIHRvIGJlIGRlZmluZWQgdG8gdXNlIGl0LlxyXG4gICAgICogVGhlIHR3byBtb3RvcnMgY2FuIGJlIGRlZmluZWQgZm9yIHRoZSB0d28gcm90YXRpb24gYXhpcywgYWxvbmcgd2l0aCBzcHJpbmdzLiBcclxuICAgICAqIGBgYHRleHQgICAgICAgIFxyXG4gICAgICogICAgICAgICAgICAgICAgICBcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciAtIHR3aXN0IGlzIHRyYW5zZmVyZWQgYmV0d2VlbiBib2RpZXNcclxuICAgICAqICAgICAgICAgeiAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgKiAgICAgICAgIOKGkSAgICAgICAgICAgIC0tLS0tICB8ICAtLS0tLS0tLS0tLS1cclxuICAgICAqICAgICAgICAgfCAgICAgICAgICAgfCAgICAgfCDihpMgfCAgICAgICAgICAgIHwgXHJcbiAgICAgKiAgLXggPC0tLXwtLS0+IHggICAgIHwgICAgIHwgeCB8ICAgICAgICAgICAgfCAgICAgICAgICAgZS5nLiB3aGVlbCBjYW4gc3RpbGwgdHVybiB1cC9kb3duLCBcclxuICAgICAqICAgICAgICAgfCAgICAgICAgICAgfCAgICAgfCAgIHwgICAgICAgICAgICB8ICAgICAgICAgICBsZWZ0IHJpZ2h0IGJ1dCB0cmFuc2ZlcmluZyBpdCdzIHJvdGF0aW9uIG9uIHRvIHRoZSB3aGVlbC1heGlzLlxyXG4gICAgICogICAgICAgICDihpMgICAgICAgICAgICAtLS0tLSAgICAgLS0tLS0tLS0tLS0tXHJcbiAgICAgKiAgICAgICAgLXogICAgXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgYXR0YWNoZWRSQiAgICAgICAgICBjb25uZWN0ZWRSQlxyXG4gICAgICogICAgICAgICAgICAgICAgKGUuZy4gd2hlZWwpICAgICAgIChlLmcuIHdoZWVsLWF4aXMpXHJcbiAgICAgKiBgYGBcclxuICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICAgKi9cclxuICBleHBvcnQgY2xhc3MgSm9pbnRVbml2ZXJzYWwgZXh0ZW5kcyBKb2ludCB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gSm9pbnQucmVnaXN0ZXJTdWJjbGFzcyhKb2ludFVuaXZlcnNhbCk7XHJcblxyXG4gICAgcHJvdGVjdGVkIGpvaW50OiBPSU1PLlVuaXZlcnNhbEpvaW50O1xyXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogT0lNTy5Vbml2ZXJzYWxKb2ludENvbmZpZyA9IG5ldyBPSU1PLlVuaXZlcnNhbEpvaW50Q29uZmlnKCk7XHJcblxyXG4gICAgI3NwcmluZ0RhbXBpbmdGaXJzdDogbnVtYmVyID0gMDtcclxuICAgICNzcHJpbmdGcmVxdWVuY3lGaXJzdDogbnVtYmVyID0gMDtcclxuXHJcbiAgICAjc3ByaW5nRGFtcGluZ1NlY29uZDogbnVtYmVyID0gMDtcclxuICAgICNzcHJpbmdGcmVxdWVuY3lTZWNvbmQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI21heFJvdG9yRmlyc3Q6IG51bWJlciA9IDM2MDtcclxuICAgICNtaW5Sb3RvckZpcnN0OiBudW1iZXIgPSAwO1xyXG4gICAgI3JvdG9yVG9ycXVlRmlyc3Q6IG51bWJlciA9IDA7XHJcbiAgICAjcm90b3JTcGVlZEZpcnN0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgICNtYXhSb3RvclNlY29uZDogbnVtYmVyID0gMzYwO1xyXG4gICAgI21pblJvdG9yU2Vjb25kOiBudW1iZXIgPSAwO1xyXG4gICAgI3JvdG9yVG9ycXVlU2Vjb25kOiBudW1iZXIgPSAwO1xyXG4gICAgI3JvdG9yU3BlZWRTZWNvbmQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgI21vdG9yRmlyc3Q6IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3I7XHJcbiAgICAjbW90b3JTZWNvbmQ6IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3I7XHJcbiAgICAjYXhpc1NwcmluZ0RhbXBlckZpcnN0OiBPSU1PLlNwcmluZ0RhbXBlcjtcclxuICAgICNheGlzU3ByaW5nRGFtcGVyU2Vjb25kOiBPSU1PLlNwcmluZ0RhbXBlcjtcclxuICAgICNheGlzRmlyc3Q6IE9JTU8uVmVjMztcclxuICAgICNheGlzU2Vjb25kOiBPSU1PLlZlYzM7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9ib2R5QW5jaG9yOiBDb21wb25lbnRSaWdpZGJvZHkgPSBudWxsLCBfYm9keVRpZWQ6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9heGlzRmlyc3Q6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygxLCAwLCAwKSwgX2F4aXNTZWNvbmQ6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygwLCAwLCAxKSwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCk7XHJcbiAgICAgIHRoaXMuYXhpc0ZpcnN0ID0gX2F4aXNGaXJzdDtcclxuICAgICAgdGhpcy5heGlzU2Vjb25kID0gX2F4aXNTZWNvbmQ7XHJcbiAgICAgIHRoaXMuYW5jaG9yID0gX2xvY2FsQW5jaG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8vI3JlZ2lvbiBHZXQvU2V0IHRyYW5zZm9yIG9mIGZ1ZGdlIHByb3BlcnRpZXMgdG8gdGhlIHBoeXNpY3MgZW5naW5lXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBheGlzIGNvbm5lY3RpbmcgdGhlIHRoZSB0d28ge0BsaW5rIE5vZGV9cyBlLmcuIFZlY3RvcjMoMCwxLDApIHRvIGhhdmUgYSB1cHdhcmQgY29ubmVjdGlvbi5cclxuICAgICAqICBXaGVuIGNoYW5nZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gdGhlIGpvaW50IG5lZWRzIHRvIGJlIHJlY29ubmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGF4aXNGaXJzdCgpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuI2F4aXNGaXJzdC54LCB0aGlzLiNheGlzRmlyc3QueSwgdGhpcy4jYXhpc0ZpcnN0LnopO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBheGlzRmlyc3QoX3ZhbHVlOiBWZWN0b3IzKSB7XHJcbiAgICAgIHRoaXMuI2F4aXNGaXJzdCA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XHJcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICogVGhlIGF4aXMgY29ubmVjdGluZyB0aGUgdGhlIHR3byB7QGxpbmsgTm9kZX1zIGUuZy4gVmVjdG9yMygwLDEsMCkgdG8gaGF2ZSBhIHVwd2FyZCBjb25uZWN0aW9uLlxyXG4gICAgKiAgV2hlbiBjaGFuZ2VkIGFmdGVyIGluaXRpYWxpemF0aW9uIHRoZSBqb2ludCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cclxuICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGF4aXNTZWNvbmQoKTogVmVjdG9yMyB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLiNheGlzU2Vjb25kLngsIHRoaXMuI2F4aXNTZWNvbmQueSwgdGhpcy4jYXhpc1NlY29uZC56KTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgYXhpc1NlY29uZChfdmFsdWU6IFZlY3RvcjMpIHtcclxuICAgICAgdGhpcy4jYXhpc1NlY29uZCA9IG5ldyBPSU1PLlZlYzMoX3ZhbHVlLngsIF92YWx1ZS55LCBfdmFsdWUueik7XHJcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLmRpcnR5U3RhdHVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGFtcGluZyBvZiB0aGUgc3ByaW5nLiAxIGVxdWFscyBjb21wbGV0bHkgZGFtcGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0RhbXBpbmdGaXJzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRGFtcGluZ0ZpcnN0O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBzcHJpbmdEYW1waW5nRmlyc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZ0ZpcnN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFNwcmluZ0RhbXBlcjEoKS5kYW1waW5nUmF0aW8gPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzcHJpbmcgaW4gSHouIEF0IDAgdGhlIHNwcmluZyBpcyByaWdpZCwgZXF1YWxzIG5vIHNwcmluZy4gVGhlIHNtYWxsZXIgdGhlIHZhbHVlIHRoZSBsZXNzIHJlc3RyaWN0aXZlIGlzIHRoZSBzcHJpbmcuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIGdldCBzcHJpbmdGcmVxdWVuY3lGaXJzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jc3ByaW5nRnJlcXVlbmN5Rmlyc3Q7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0ZyZXF1ZW5jeUZpcnN0KF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeUZpcnN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldFNwcmluZ0RhbXBlcjEoKS5mcmVxdWVuY3kgPSBfdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGFtcGluZyBvZiB0aGUgc3ByaW5nLiAxIGVxdWFscyBjb21wbGV0bHkgZGFtcGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHNwcmluZ0RhbXBpbmdTZWNvbmQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3NwcmluZ0RhbXBpbmdTZWNvbmQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0RhbXBpbmdTZWNvbmQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jc3ByaW5nRGFtcGluZ1NlY29uZCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRTcHJpbmdEYW1wZXIyKCkuZGFtcGluZ1JhdGlvID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyZXF1ZW5jeSBvZiB0aGUgc3ByaW5nIGluIEh6LiBBdCAwIHRoZSBzcHJpbmcgaXMgcmlnaWQsIGVxdWFscyBubyBzcHJpbmcuIFRoZSBzbWFsbGVyIHRoZSB2YWx1ZSB0aGUgbGVzcyByZXN0cmljdGl2ZSBpcyB0aGUgc3ByaW5nLlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc3ByaW5nRnJlcXVlbmN5U2Vjb25kKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNzcHJpbmdGcmVxdWVuY3lTZWNvbmQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNwcmluZ0ZyZXF1ZW5jeVNlY29uZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNzcHJpbmdGcmVxdWVuY3lTZWNvbmQgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0U3ByaW5nRGFtcGVyMigpLmZyZXF1ZW5jeSA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgVXBwZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcy1BbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWF4Um90b3JGaXJzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWF4Um90b3JGaXJzdDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbWF4Um90b3JGaXJzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtYXhSb3RvckZpcnN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IxKCkudXBwZXJMaW1pdCA9IF92YWx1ZSAqIENhbGMuZGVnMnJhZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgTG93ZXIgTGltaXQgb2YgbW92ZW1lbnQgYWxvbmcgdGhlIGF4aXMgb2YgdGhpcyBqb2ludC4gVGhlIGxpbWl0ZXIgaXMgZGlzYWJsZSBpZiBsb3dlckxpbWl0ID4gdXBwZXJMaW1pdC4gQXhpcyBBbmdsZSBtZWFzdXJlZCBpbiBEZWdyZWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbWluUm90b3JGaXJzdCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWluUm90b3JGaXJzdDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbWluUm90b3JGaXJzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNtaW5Sb3RvckZpcnN0ID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IxKCkubG93ZXJMaW1pdCA9IF92YWx1ZSAqIENhbGMuZGVnMnJhZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgdGFyZ2V0IHJvdGF0aW9uYWwgc3BlZWQgb2YgdGhlIG1vdG9yIGluIG0vcy4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcm90b3JTcGVlZEZpcnN0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyb3RvclNwZWVkRmlyc3Q7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHJvdG9yU3BlZWRGaXJzdChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyb3RvclNwZWVkRmlyc3QgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcjEoKS5tb3RvclNwZWVkID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gbW90b3IgdG9ycXVlIGluIE5ld3Rvbi4gZm9yY2UgPD0gMCBlcXVhbHMgZGlzYWJsZWQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHJvdG9yVG9ycXVlRmlyc3QoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JvdG9yVG9ycXVlRmlyc3Q7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHJvdG9yVG9ycXVlRmlyc3QoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jcm90b3JUb3JxdWVGaXJzdCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMSgpLm1vdG9yVG9ycXVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIFVwcGVyIExpbWl0IG9mIG1vdmVtZW50IGFsb25nIHRoZSBheGlzIG9mIHRoaXMgam9pbnQuIFRoZSBsaW1pdGVyIGlzIGRpc2FibGUgaWYgbG93ZXJMaW1pdCA+IHVwcGVyTGltaXQuIEF4aXMtQW5nbGUgbWVhc3VyZWQgaW4gRGVncmVlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG1heFJvdG9yU2Vjb25kKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtYXhSb3RvclNlY29uZDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbWF4Um90b3JTZWNvbmQoX3ZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgdGhpcy4jbWF4Um90b3JTZWNvbmQgPSBfdmFsdWU7XHJcbiAgICAgIGlmICh0aGlzLmpvaW50ICE9IG51bGwpIHRoaXMuam9pbnQuZ2V0TGltaXRNb3RvcjIoKS51cHBlckxpbWl0ID0gX3ZhbHVlICogQ2FsYy5kZWcycmFkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFRoZSBMb3dlciBMaW1pdCBvZiBtb3ZlbWVudCBhbG9uZyB0aGUgYXhpcyBvZiB0aGlzIGpvaW50LiBUaGUgbGltaXRlciBpcyBkaXNhYmxlIGlmIGxvd2VyTGltaXQgPiB1cHBlckxpbWl0LiBBeGlzIEFuZ2xlIG1lYXN1cmVkIGluIERlZ3JlZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBtaW5Sb3RvclNlY29uZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jbWluUm90b3JTZWNvbmQ7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IG1pblJvdG9yU2Vjb25kKF92YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuI21pblJvdG9yU2Vjb25kID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IyKCkubG93ZXJMaW1pdCA9IF92YWx1ZSAqIENhbGMuZGVnMnJhZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgdGFyZ2V0IHJvdGF0aW9uYWwgc3BlZWQgb2YgdGhlIG1vdG9yIGluIG0vcy4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcm90b3JTcGVlZFNlY29uZCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcm90b3JTcGVlZFNlY29uZDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgcm90b3JTcGVlZFNlY29uZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyb3RvclNwZWVkU2Vjb25kID0gX3ZhbHVlO1xyXG4gICAgICBpZiAodGhpcy5qb2ludCAhPSBudWxsKSB0aGlzLmpvaW50LmdldExpbWl0TW90b3IyKCkubW90b3JTcGVlZCA9IF92YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBUaGUgbWF4aW11bSBtb3RvciB0b3JxdWUgaW4gTmV3dG9uLiBmb3JjZSA8PSAwIGVxdWFscyBkaXNhYmxlZC4gXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcm90b3JUb3JxdWVTZWNvbmQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3JvdG9yVG9ycXVlU2Vjb25kO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCByb3RvclRvcnF1ZVNlY29uZChfdmFsdWU6IG51bWJlcikge1xyXG4gICAgICB0aGlzLiNyb3RvclRvcnF1ZVNlY29uZCA9IF92YWx1ZTtcclxuICAgICAgaWYgKHRoaXMuam9pbnQgIT0gbnVsbCkgdGhpcy5qb2ludC5nZXRMaW1pdE1vdG9yMigpLm1vdG9yVG9ycXVlID0gX3ZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIElmIHRoZSB0d28gY29ubmVjdGVkIFJpZ2lkQm9kaWVzIGNvbGxpZGUgd2l0aCBlYXRoIG90aGVyLiAoRGVmYXVsdCA9IGZhbHNlKVxyXG4gICAgICovXHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8jcmVnaW9uIFNhdmluZy9Mb2FkaW5nXHJcbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IFNlcmlhbGl6YXRpb24ge1xyXG4gICAgICBsZXQgc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbiA9IHRoaXMuI2dldE11dGF0b3IoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5maXJzdEF4aXMgPSB0aGlzLmF4aXNGaXJzdC5zZXJpYWxpemUoKTtcclxuICAgICAgc2VyaWFsaXphdGlvbi5zZWNvbmRBeGlzID0gdGhpcy5heGlzU2Vjb25kLnNlcmlhbGl6ZSgpO1xyXG4gICAgICBzZXJpYWxpemF0aW9uW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdID0gc3VwZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgIHJldHVybiBzZXJpYWxpemF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBkZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbjogU2VyaWFsaXphdGlvbik6IFByb21pc2U8U2VyaWFsaXphYmxlPiB7XHJcbiAgICAgIHRoaXMuYXhpc0ZpcnN0ID0gYXdhaXQgbmV3IFZlY3RvcjMoKS5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbi5heGlzRmlyc3QpO1xyXG4gICAgICB0aGlzLmF4aXNTZWNvbmQgPSBhd2FpdCBuZXcgVmVjdG9yMygpLmRlc2VyaWFsaXplKF9zZXJpYWxpemF0aW9uLmF4aXNTZWNvbmQpO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX3NlcmlhbGl6YXRpb24pO1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IsIF9zZWxlY3Rpb246IHN0cmluZ1tdID0gbnVsbCwgX2Rpc3BhdGNoTXV0YXRlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBpZiAodHlwZW9mIChfbXV0YXRvci5heGlzRmlyc3QpICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIHRoaXMuYXhpc0ZpcnN0ID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmF4aXNGaXJzdCkpKTtcclxuICAgICAgaWYgKHR5cGVvZiAoX211dGF0b3IuYXhpc1NlY29uZCkgIT09IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgdGhpcy5heGlzU2Vjb25kID0gbmV3IFZlY3RvcjMoLi4uPG51bWJlcltdPihPYmplY3QudmFsdWVzKF9tdXRhdG9yLmF4aXNTZWNvbmQpKSk7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5heGlzRmlyc3Q7XHJcbiAgICAgIGRlbGV0ZSBfbXV0YXRvci5heGlzU2Vjb25kO1xyXG4gICAgICB0aGlzLiNtdXRhdGUoX211dGF0b3IpO1xyXG4gICAgICB0aGlzLmRlbGV0ZUZyb21NdXRhdG9yKF9tdXRhdG9yLCB0aGlzLiNnZXRNdXRhdG9yKCkpO1xyXG4gICAgICBhd2FpdCBzdXBlci5tdXRhdGUoX211dGF0b3IsIF9zZWxlY3Rpb24sIF9kaXNwYXRjaE11dGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE11dGF0b3IoKTogTXV0YXRvciB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0gc3VwZXIuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBPYmplY3QuYXNzaWduKG11dGF0b3IsIHRoaXMuI2dldE11dGF0b3IoKSk7XHJcbiAgICAgIG11dGF0b3IuYXhpc0ZpcnN0ID0gdGhpcy5heGlzRmlyc3QuZ2V0TXV0YXRvcigpO1xyXG4gICAgICBtdXRhdG9yLmF4aXNTZWNvbmQgPSB0aGlzLmF4aXNTZWNvbmQuZ2V0TXV0YXRvcigpO1xyXG4gICAgICByZXR1cm4gbXV0YXRvcjtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jYXhpc1NwcmluZ0RhbXBlckZpcnN0ID0gbmV3IE9JTU8uU3ByaW5nRGFtcGVyKCkuc2V0U3ByaW5nKHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeUZpcnN0LCB0aGlzLiNzcHJpbmdEYW1waW5nRmlyc3QpO1xyXG4gICAgICB0aGlzLiNheGlzU3ByaW5nRGFtcGVyU2Vjb25kID0gbmV3IE9JTU8uU3ByaW5nRGFtcGVyKCkuc2V0U3ByaW5nKHRoaXMuI3NwcmluZ0ZyZXF1ZW5jeVNlY29uZCwgdGhpcy4jc3ByaW5nRGFtcGluZ1NlY29uZCk7XHJcblxyXG4gICAgICB0aGlzLiNtb3RvckZpcnN0ID0gbmV3IE9JTU8uUm90YXRpb25hbExpbWl0TW90b3IoKS5zZXRMaW1pdHModGhpcy4jbWluUm90b3JGaXJzdCAqIENhbGMuZGVnMnJhZCwgdGhpcy4jbWF4Um90b3JGaXJzdCAqIENhbGMuZGVnMnJhZCk7XHJcbiAgICAgIHRoaXMuI21vdG9yRmlyc3Quc2V0TW90b3IodGhpcy4jcm90b3JTcGVlZEZpcnN0LCB0aGlzLiNyb3RvclRvcnF1ZUZpcnN0KTtcclxuICAgICAgdGhpcy4jbW90b3JTZWNvbmQgPSBuZXcgT0lNTy5Sb3RhdGlvbmFsTGltaXRNb3RvcigpLnNldExpbWl0cyh0aGlzLiNtaW5Sb3RvckZpcnN0ICogQ2FsYy5kZWcycmFkLCB0aGlzLiNtYXhSb3RvckZpcnN0ICogQ2FsYy5kZWcycmFkKTtcclxuICAgICAgdGhpcy4jbW90b3JTZWNvbmQuc2V0TW90b3IodGhpcy4jcm90b3JTcGVlZEZpcnN0LCB0aGlzLiNyb3RvclRvcnF1ZUZpcnN0KTtcclxuXHJcbiAgICAgIHRoaXMuY29uZmlnID0gbmV3IE9JTU8uVW5pdmVyc2FsSm9pbnRDb25maWcoKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQodGhpcy4jYXhpc0ZpcnN0LCB0aGlzLiNheGlzU2Vjb25kKTtcclxuICAgICAgdGhpcy5jb25maWcubGltaXRNb3RvcjEgPSB0aGlzLiNtb3RvckZpcnN0O1xyXG4gICAgICB0aGlzLmNvbmZpZy5saW1pdE1vdG9yMiA9IHRoaXMuI21vdG9yU2Vjb25kO1xyXG4gICAgICB0aGlzLmNvbmZpZy5zcHJpbmdEYW1wZXIxID0gdGhpcy4jYXhpc1NwcmluZ0RhbXBlckZpcnN0O1xyXG4gICAgICB0aGlzLmNvbmZpZy5zcHJpbmdEYW1wZXIyID0gdGhpcy4jYXhpc1NwcmluZ0RhbXBlclNlY29uZDtcclxuXHJcbiAgICAgIHRoaXMuam9pbnQgPSBuZXcgT0lNTy5Vbml2ZXJzYWxKb2ludCh0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHN1cGVyLmNvbmZpZ3VyZUpvaW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgI2dldE11dGF0b3IgPSAoKTogTXV0YXRvciA9PiB7XHJcbiAgICAgIGxldCBtdXRhdG9yOiBNdXRhdG9yID0ge1xyXG4gICAgICAgIHNwcmluZ0RhbXBpbmdGaXJzdDogdGhpcy4jc3ByaW5nRGFtcGluZ0ZpcnN0LFxyXG4gICAgICAgIHNwcmluZ0ZyZXF1ZW5jeUZpcnN0OiB0aGlzLiNzcHJpbmdGcmVxdWVuY3lGaXJzdCxcclxuICAgICAgICBzcHJpbmdEYW1waW5nU2Vjb25kOiB0aGlzLiNzcHJpbmdEYW1waW5nU2Vjb25kLFxyXG4gICAgICAgIHNwcmluZ0ZyZXF1ZW5jeVNlY29uZDogdGhpcy4jc3ByaW5nRnJlcXVlbmN5U2Vjb25kLFxyXG4gICAgICAgIG1heFJvdG9yRmlyc3Q6IHRoaXMuI21heFJvdG9yRmlyc3QsXHJcbiAgICAgICAgbWluUm90b3JGaXJzdDogdGhpcy4jbWluUm90b3JGaXJzdCxcclxuICAgICAgICByb3RvclNwZWVkRmlyc3Q6IHRoaXMuI3JvdG9yU3BlZWRGaXJzdCxcclxuICAgICAgICByb3RvclRvcnF1ZUZpcnN0OiB0aGlzLiNyb3RvclRvcnF1ZUZpcnN0LFxyXG4gICAgICAgIG1heFJvdG9yU2Vjb25kOiB0aGlzLiNtYXhSb3RvclNlY29uZCxcclxuICAgICAgICBtaW5Sb3RvclNlY29uZDogdGhpcy4jbWluUm90b3JTZWNvbmQsXHJcbiAgICAgICAgcm90b3JTcGVlZFNlY29uZDogdGhpcy4jcm90b3JTcGVlZFNlY29uZCxcclxuICAgICAgICByb3RvclRvcnF1ZVNlY29uZDogdGhpcy4jcm90b3JUb3JxdWVTZWNvbmRcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG11dGF0b3I7XHJcbiAgICB9O1xyXG5cclxuICAgICNtdXRhdGUgPSAoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkID0+IHtcclxuICAgICAgdGhpcy5tdXRhdGVCYXNlKF9tdXRhdG9yLCBbXHJcbiAgICAgICAgXCJzcHJpbmdEYW1waW5nRmlyc3RcIiwgXCJzcHJpbmdGcmVxdWVuY3lGaXJzdFwiLCBcInNwcmluZ0RhbXBpbmdTZWNvbmRcIiwgXCJzcHJpbmdGcmVxdWVuY3lTZWNvbmRcIixcclxuICAgICAgICBcIm1heFJvdG9yRmlyc3RcIiwgXCJtaW5Sb3RvckZpcnN0XCIsIFwicm90b3JTcGVlZEZpcnN0XCIsIFwicm90b3JUb3JxdWVGaXJzdFwiLFxyXG4gICAgICAgIFwibWF4Um90b3JTZWNvbmRcIiwgXCJtaW5Sb3RvclNlY29uZFwiLCBcInJvdG9yU3BlZWRTZWNvbmRcIiwgXCIucm90b3JUb3JxdWVTZWNvbmRcIl1cclxuICAgICAgKTtcclxuICAgIH07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAgKiBBIHBoeXNpY2FsIGNvbm5lY3Rpb24gYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggbm8gbW92ZW1lbnQuIFxyXG4gICAgICogQmVzdCB3YXkgdG8gc2ltdWxhdGUgY29udmV4IG9iamVjdHMgbGlrZSBhIGNoYWlyIHNlYXQgY29ubmVjdGVkIHRvIGNoYWlyIGxlZ3MuXHJcbiAgICAgKiBUaGUgYWN0dWFsIGFuY2hvciBwb2ludCBkb2VzIG5vdCBtYXR0ZXIgdGhhdCBtdWNoLCBvbmx5IGluIHZlcnkgc3BlY2lmaWMgZWRnZSBjYXNlcy5cclxuICAgICAqIEJlY2F1c2Ugd2VsZGluZyBtZWFucyB0aGV5IHNpbXBseSBkbyBub3QgZGlzY29ubmVjdC4gKHVubGVzcyB5b3UgYWRkIEJyZWFrYWJpbGl0eSlcclxuICAgKiBAYXV0aG9yIE1hcmtvIEZlaHJlbmJhY2gsIEhGVSwgMjAyMCB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICAgKi9cclxuICBleHBvcnQgY2xhc3MgSm9pbnRXZWxkaW5nIGV4dGVuZHMgSm9pbnQge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IEpvaW50LnJlZ2lzdGVyU3ViY2xhc3MoSm9pbnRXZWxkaW5nKTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgam9pbnQ6IE9JTU8uR2VuZXJpY0pvaW50O1xyXG4gICAgcHJvdGVjdGVkIGNvbmZpZzogT0lNTy5HZW5lcmljSm9pbnRDb25maWcgPSBuZXcgT0lNTy5HZW5lcmljSm9pbnRDb25maWcoKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2JvZHlBbmNob3I6IENvbXBvbmVudFJpZ2lkYm9keSA9IG51bGwsIF9ib2R5VGllZDogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbCwgX2xvY2FsQW5jaG9yOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCkpIHtcclxuICAgICAgc3VwZXIoX2JvZHlBbmNob3IsIF9ib2R5VGllZCk7XHJcblxyXG4gICAgICB0aGlzLmFuY2hvciA9IG5ldyBWZWN0b3IzKF9sb2NhbEFuY2hvci54LCBfbG9jYWxBbmNob3IueSwgX2xvY2FsQW5jaG9yLnopO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIC8vI3JlZ2lvbiBTYXZpbmcvTG9hZGluZ1xyXG4gICAgcHVibGljIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemF0aW9uIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24gPSB7XHJcbiAgICAgICAgW3N1cGVyLmNvbnN0cnVjdG9yLm5hbWVdOiBzdXBlci5zZXJpYWxpemUoKVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc2VyaWFsaXphdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZGVzZXJpYWxpemUoX3NlcmlhbGl6YXRpb246IFNlcmlhbGl6YXRpb24pOiBQcm9taXNlPFNlcmlhbGl6YWJsZT4ge1xyXG4gICAgICBzdXBlci5kZXNlcmlhbGl6ZShfc2VyaWFsaXphdGlvbltzdXBlci5jb25zdHJ1Y3Rvci5uYW1lXSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RKb2ludCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5jb25maWcgPSBuZXcgT0lNTy5HZW5lcmljSm9pbnRDb25maWcoKTtcclxuICAgICAgc3VwZXIuY29uc3RydWN0Sm9pbnQobmV3IE9JTU8uTWF0MygpLCBuZXcgT0lNTy5NYXQzKCkpO1xyXG5cclxuICAgICAgdGhpcy5qb2ludCA9IG5ldyBPSU1PLkdlbmVyaWNKb2ludCh0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHRoaXMuam9pbnQuc2V0QWxsb3dDb2xsaXNpb24odGhpcy5pbnRlcm5hbENvbGxpc2lvbik7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uL0Rpc3RyaWJ1dGlvbi9PaW1vUGh5c2ljcy5kLnRzXCIvPlxyXG5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICAqIE1hbmFnZXMgdGhlIE9JTU8gcGh5c2ljcyBlbmdpbmUgZm9yIEZVREdFLiBNdWx0aXBsZSBpbnN0YW5jZXMgbWF5IGJlIGNyZWF0ZWQsIG9uZSBpcyBhY3RpdmUgYXQgYSB0aW1lLlxyXG4gICAgKiBBbGwgbWV0aG9kcyBhcmUgc3RhdGljIGFuZCB1c2UgdGhlIGN1cnJlbnRseSBhY3RpdmUgaW5zdGFuY2UuIEF0IHN0YXJ0dXAsIGEgZGVmYXVsdCBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCBiZWNvbWUgdGhlIGFjdGl2ZSBpbnN0YW5jZVxyXG4gICAgKiBBdHRhY2hpbmcgYSB7QGxpbmsgQ29tcG9uZW50UmlnaWRib2R5fSB0byBhIHtAbGluayBOb2RlfSBwbGFjZXMgYSBwaHlzaWNzIGNvbGxpZGVyIGluIHRoZSBwaHlzaWNzIGluc3RhbmNlIGFjdGl2ZSBhdCB0aGF0IHRpbWUuXHJcbiAgICAqIEBhdXRob3IgTWFya28gRmVocmVuYmFjaCwgSEZVIDIwMjBcclxuICAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFBoeXNpY3Mge1xyXG4gICAgLyoqIFRoZSBTRVRUSU5HUyB0aGF0IGFwcGx5IHRvIHRoZSBwaHlzaWNhbCB3b3JsZC4gUmFuZ2luZyBmcm9tIHRoaW5ncyBsaWtlIHNsZWVwaW5nLCBjb2xsaXNpb25TaGFwZVRoaWNrbmVzcyBhbmQgb3RoZXJzICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHNldHRpbmdzOiBQaHlzaWNzU2V0dGluZ3MgPSBuZXcgUGh5c2ljc1NldHRpbmdzKENPTExJU0lPTl9HUk9VUC5ERUZBVUxULCAoQ09MTElTSU9OX0dST1VQLkRFRkFVTFQgfCBDT0xMSVNJT05fR1JPVVAuR1JPVVBfMSB8IENPTExJU0lPTl9HUk9VUC5HUk9VUF8yIHwgQ09MTElTSU9OX0dST1VQLkdST1VQXzMgfCBDT0xMSVNJT05fR1JPVVAuR1JPVVBfNCkpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJhY3RpdmU6IFBoeXNpY3MgPSBuZXcgUGh5c2ljcygpO1xyXG5cclxuICAgIHByaXZhdGUgb2ltb1dvcmxkOiBPSU1PLldvcmxkO1xyXG4gICAgcHJpdmF0ZSBib2R5TGlzdDogQ29tcG9uZW50UmlnaWRib2R5W10gPSBuZXcgQXJyYXkoKTtcclxuICAgIHByaXZhdGUgam9pbnRMaXN0OiBKb2ludFtdID0gbmV3IEFycmF5KCk7XHJcblxyXG4gICAgLyoqIFRoZSByZW5kZXJpbmcgb2YgcGh5c2ljYWwgZGVidWcgaW5mb3JtYXRpb25zLiBVc2VkIGludGVybmFsbHkgbm8gaW50ZXJhY3Rpb24gbmVlZGVkLiovXHJcbiAgICAjZGVidWdEcmF3OiBQaHlzaWNzRGVidWdEcmF3O1xyXG4gICAgLyoqIFRoZSBjYW1lcmEvdmlld3BvcnQgdGhlIHBoeXNpY3MgYXJlIGRlYnVnZ2VkIHRvLiBVc2VkIGludGVybmFsbHkgbm8gaW50ZXJhY3Rpb24gbmVlZGVkLiAqL1xyXG4gICAgI21haW5DYW06IENvbXBvbmVudENhbWVyYTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgT0lNTyA9PSBcInVuZGVmaW5lZFwiKSB7Ly8gQ2hlY2sgaWYgT0lNTyBOYW1lc3BhY2Ugd2FzIGxvYWRlZCwgZWxzZSBkbyBub3QgdXNlIGFueSBwaHlzaWNzLiBDaGVjayBpcyBuZWVkZWQgdG8gZW5zdXJlIEZVREdFIGNhbiBiZSB1c2VkIHdpdGhvdXQgUGh5c2ljc1xyXG4gICAgICAgIERlYnVnLmVycm9yKFwiT0lNTyBwaHlzaWNzIGVuZ2luZSBub3QgY29ubmVjdGVkIVwiKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm9pbW9Xb3JsZCA9IG5ldyBPSU1PLldvcmxkKCk7XHJcbiAgICAgIHRoaXMuI2RlYnVnRHJhdyA9IG5ldyBQaHlzaWNzRGVidWdEcmF3KCk7ICAvL0NyZWF0ZSBhIEZVREdFIFBoeXNpY3MgZGVidWdnaW5nIGhhbmRsaW5nIG9iamVjdFxyXG4gICAgICB0aGlzLm9pbW9Xb3JsZC5zZXREZWJ1Z0RyYXcodGhpcy4jZGVidWdEcmF3Lm9pbW9EZWJ1Z0RyYXcpOyAvL1RlbGwgT2ltb1BoeXNpY3Mgd2hlcmUgdG8gZGVidWcgdG8gYW5kIGhvdyBpdCB3aWxsIGJlIGhhbmRsZWRcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIHRoZSBjdXJyZW50bHkgYWN0aXZlIFBoeXNpY3MgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXQgYWN0aXZlSW5zdGFuY2UoX3BoeXNpY3M6IFBoeXNpY3MpIHtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZSA9IF9waHlzaWNzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgUGh5c2ljcyBpbnN0YW5jZSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgYWN0aXZlSW5zdGFuY2UoKTogUGh5c2ljcyB7XHJcbiAgICAgIHJldHVybiBQaHlzaWNzLsaSYWN0aXZlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGRlYnVnRHJhdygpOiBQaHlzaWNzRGVidWdEcmF3IHtcclxuICAgICAgcmV0dXJuIFBoeXNpY3MuxpJhY3RpdmUuI2RlYnVnRHJhdztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IG1haW5DYW0oKTogQ29tcG9uZW50Q2FtZXJhIHtcclxuICAgICAgcmV0dXJuIFBoeXNpY3MuxpJhY3RpdmUuI21haW5DYW07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENhc3QgYSBSQVkgaW50byB0aGUgcGh5c2ljYWwgd29ybGQgZnJvbSBhIG9yaWdpbiBwb2ludCBpbiBhIGNlcnRhaW4gZGlyZWN0aW9uLiBSZWNlaXZpbmcgaW5mb3JtYXRpb25zIGFib3V0IHRoZSBoaXQgb2JqZWN0IGFuZCB0aGVcclxuICAgICogaGl0IHBvaW50LiBEbyBub3Qgc3BlY2lmeSBhIF9ncm91cCB0byByYXljYXN0IHRoZSB3aG9sZSB3b3JsZCwgZWxzZSBvbmx5IGJvZGllcyB3aXRoaW4gdGhlIHNwZWNpZmljIGdyb3VwIGNhbiBiZSBoaXQuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByYXljYXN0KF9vcmlnaW46IFZlY3RvcjMsIF9kaXJlY3Rpb246IFZlY3RvcjMsIF9sZW5ndGg6IG51bWJlciA9IDEsIF9kZWJ1Z0RyYXc6IGJvb2xlYW4gPSBmYWxzZSwgX2dyb3VwOiBDT0xMSVNJT05fR1JPVVAgPSBDT0xMSVNJT05fR1JPVVAuREVGQVVMVCk6IFJheUhpdEluZm8ge1xyXG4gICAgICBsZXQgaGl0SW5mbzogUmF5SGl0SW5mbyA9IG5ldyBSYXlIaXRJbmZvKCk7XHJcbiAgICAgIGxldCByYXk6IE9JTU8uUmF5Q2FzdENsb3Nlc3QgPSBuZXcgT0lNTy5SYXlDYXN0Q2xvc2VzdCgpO1xyXG4gICAgICBsZXQgYmVnaW46IE9JTU8uVmVjMyA9IG5ldyBPSU1PLlZlYzMoX29yaWdpbi54LCBfb3JpZ2luLnksIF9vcmlnaW4ueik7XHJcbiAgICAgIGxldCBlbmQ6IE9JTU8uVmVjMyA9IHRoaXMuZ2V0UmF5RW5kUG9pbnQoYmVnaW4sIG5ldyBWZWN0b3IzKF9kaXJlY3Rpb24ueCwgX2RpcmVjdGlvbi55LCBfZGlyZWN0aW9uLnopLCBfbGVuZ3RoKTtcclxuICAgICAgcmF5LmNsZWFyKCk7XHJcbiAgICAgIGlmIChfZ3JvdXAgPT0gQ09MTElTSU9OX0dST1VQLkRFRkFVTFQpIHsgLy9DYXNlIDE6IFJheWNhc3RpbmcgdGhlIHdob2xlIHdvcmxkLCBub3JtYWwgbW9kZVxyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLnJheUNhc3QoYmVnaW4sIGVuZCwgcmF5KTtcclxuICAgICAgfSBlbHNlIHsgLy9DYXNlMjogUmF5Y2FzdGluZyBvbiBlYWNoIGJvZHkgaW4gYSBzcGVjaWZpYyBncm91cFxyXG4gICAgICAgIGxldCBhbGxIaXRzOiBSYXlIaXRJbmZvW10gPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICBQaHlzaWNzLsaSYWN0aXZlLmJvZHlMaXN0LmZvckVhY2goZnVuY3Rpb24gKF92YWx1ZTogQ29tcG9uZW50UmlnaWRib2R5KTogdm9pZCB7XHJcbiAgICAgICAgICBpZiAoX3ZhbHVlLmNvbGxpc2lvbkdyb3VwID09IF9ncm91cCkge1xyXG4gICAgICAgICAgICBoaXRJbmZvID0gX3ZhbHVlLnJheWNhc3RUaGlzQm9keShfb3JpZ2luLCBfZGlyZWN0aW9uLCBfbGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKGhpdEluZm8uaGl0ID09IHRydWUpIHsgLy9FdmVyeSBoaXQgaXMgY291bGQgcG90ZW50aWFsbHkgYmUgdGhlIGNsb3Nlc3RcclxuICAgICAgICAgICAgICBhbGxIaXRzLnB1c2goaGl0SW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhbGxIaXRzLmZvckVhY2goZnVuY3Rpb24gKF92YWx1ZTogUmF5SGl0SW5mbyk6IHZvaWQgeyAvL2dldCB0aGUgY2xvc2VzdCBoaXRJbmZvXHJcbiAgICAgICAgICBpZiAoX3ZhbHVlLmhpdERpc3RhbmNlIDwgaGl0SW5mby5oaXREaXN0YW5jZSB8fCBoaXRJbmZvLmhpdCA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBoaXRJbmZvID0gX3ZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyYXkuaGl0KSB7IC8vRmlsbCBpbiBpbmZvcm1hdGlvbnMgb24gdGhlIGhpdFxyXG4gICAgICAgIGhpdEluZm8uaGl0ID0gdHJ1ZTtcclxuICAgICAgICBoaXRJbmZvLmhpdFBvaW50ID0gbmV3IFZlY3RvcjMocmF5LnBvc2l0aW9uLngsIHJheS5wb3NpdGlvbi55LCByYXkucG9zaXRpb24ueik7XHJcbiAgICAgICAgaGl0SW5mby5oaXROb3JtYWwgPSBuZXcgVmVjdG9yMyhyYXkubm9ybWFsLngsIHJheS5ub3JtYWwueSwgcmF5Lm5vcm1hbC56KTtcclxuICAgICAgICBoaXRJbmZvLmhpdERpc3RhbmNlID0gdGhpcy5nZXRSYXlEaXN0YW5jZShfb3JpZ2luLCBoaXRJbmZvLmhpdFBvaW50KTtcclxuICAgICAgICBoaXRJbmZvLnJpZ2lkYm9keUNvbXBvbmVudCA9IHJheS5zaGFwZS51c2VyRGF0YTtcclxuICAgICAgICBoaXRJbmZvLnJheUVuZCA9IG5ldyBWZWN0b3IzKGVuZC54LCBlbmQueSwgZW5kLnopO1xyXG4gICAgICAgIGhpdEluZm8ucmF5T3JpZ2luID0gX29yaWdpbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBoaXRJbmZvLnJheU9yaWdpbiA9IF9vcmlnaW47XHJcbiAgICAgICAgaGl0SW5mby5oaXRQb2ludCA9IG5ldyBWZWN0b3IzKGVuZC54LCBlbmQueSwgZW5kLnopO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfZGVidWdEcmF3KSB7IC8vSGFuZGxlIGRlYnVnZ2luZ1xyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUuI2RlYnVnRHJhdy5kZWJ1Z1JheShoaXRJbmZvLnJheU9yaWdpbiwgaGl0SW5mby5oaXRQb2ludCwgbmV3IENvbG9yKDAsIDEsIDAsIDEpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaGl0SW5mbztcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNpbXVsYXRlcyB0aGUgcGh5c2ljYWwgd29ybGQuIF9kZWx0YVRpbWUgaXMgdGhlIGFtb3VudCBvZiB0aW1lIGJldHdlZW4gcGh5c2ljYWwgc3RlcHMgaW4gc2Vjb25kcy4gRGVmYXVsdCBpcyB7QGxpbmsgTG9vcC50aW1lRnJhbWVHYW1lfSAvIDEwMDAgdG8gcnVuIGluIHN5bmMgd2l0aCB0aGUge0BsaW5rIExvb3B9LlxyXG4gICAgKiBUaGUgbWF4aW11bSB2YWx1ZSBpcyAxLzMwIG9mIGEgc2Vjb25kLCB0byBoYXZlIG1vcmUgY29uc2lzdGVudCBmcmFtZSBjYWxjdWxhdGlvbnMuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzaW11bGF0ZShfZGVsdGFUaW1lOiBudW1iZXIgPSBMb29wLnRpbWVGcmFtZUdhbWUgLyAxMDAwKTogdm9pZCB7XHJcbiAgICAgIGlmIChQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdC5sZW5ndGggPiAwKVxyXG4gICAgICAgIFBoeXNpY3MuY29ubmVjdEpvaW50cygpOyAvLyBDb25uZWN0IGpvaW50cyBpZiBhbnl0aGluZyBoYXMgaGFwcGVuZWQgYmV0d2VlbiB0aGUgbGFzdCBjYWxsIHRvIGFueSBvZiB0aGUgdHdvIHBhaXJlZCByaWdpZGJvZGllc1xyXG4gICAgICBpZiAoX2RlbHRhVGltZSA9PSAwKSAvLyBObyB0aW1lIHBhc3NlZCwgbm8gbmVlZCB0byB1cGRhdGUgdGhlIHBoeXNpY3Mgd29ybGRcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBfZGVsdGFUaW1lID0gX2RlbHRhVGltZSA+IDEgLyAzMCA/IDEgLyAzMCA6IF9kZWx0YVRpbWU7IC8vIElmIGluc3RlYWQgb2YgYSBmaXhlZCByYXRlIHRoZSBnYW1lIGZyYW1lcmF0ZSBpcyB1c2VkLCBtYWtlIHN1cmUgaXJyZWd1bGFyIHRpbWluZ3MgYXJlIGZpeGVkIHRvIDMwZnBzXHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkLnN0ZXAoX2RlbHRhVGltZSk7ICAvLyBVcGRhdGUgdGhlIHNpbXVsYXRpb24gYnkgdGhlIGdpdmVuIGRlbHRhVGltZVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgaW5zdGFuY2UgdXNpbmcgdGhlIHtAbGluayBDb21wb25lbnRDYW1lcmF9IGdpdmVuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhdyhfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEsIF9tb2RlPzogUEhZU0lDU19ERUJVR01PREUpOiB2b2lkIHtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS4jZGVidWdEcmF3LnNldERlYnVnTW9kZShfbW9kZSk7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUuI21haW5DYW0gPSBfY21wQ2FtZXJhO1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5kZWJ1Z0RyYXcoKTsgLy9GaWxsaW5nIHRoZSBwaHlzaWNzIHdvcmxkIGRlYnVnIGluZm9ybWF0aW9ucyBpbnRvIHRoZSBkZWJ1ZyByZW5kZXJpbmcgaGFuZGxlclxyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLiNkZWJ1Z0RyYXcuZHJhd0J1ZmZlcnMoKTtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS4jZGVidWdEcmF3LmNsZWFyQnVmZmVycygpOyAgLy9VcGRhdGVzIGluZm8gYWJvdXQgdGhlIGN1cnJlbnQgcHJvamVjdGlvbiwgcmVzZXR0aW5nIHRoZSBwb2ludHMvbGluZXMvdHJpYW5nbGVzIHRoYXQgbmVlZCB0byBiZSBkcmF3biBmcm9tIGRlYnVnXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogQWRqdXN0cyB0aGUgdHJhbnNmb3JtcyBvZiB0aGUge0BsaW5rIENvbXBvbmVudFJpZ2lkYm9keX1zIGluIHRoZSBnaXZlbiBicmFuY2ggdG8gbWF0Y2ggdGhlaXIgbm9kZXMgb3IgbWVzaGVzXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGFkanVzdFRyYW5zZm9ybXMoX2JyYW5jaDogTm9kZSwgX3RvTWVzaDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlci5wcmVwYXJlKF9icmFuY2gsIHsgaWdub3JlUGh5c2ljczogdHJ1ZSB9KTtcclxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBSZW5kZXIubm9kZXNQaHlzaWNzKVxyXG4gICAgICAgIG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudFJpZ2lkYm9keSkuaW5pdGlhbGl6ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBHZXQgdGhlIGFwcGxpZWQgZ3Jhdml0YXRpb25hbCBmb3JjZSBvZiB0aGUgYWN0aXZlIGluc3RhbmNlLiBEZWZhdWx0IGVhcnRoIGdyYXZpdHkgPSA5LjgxIG0vc1xyXG4gICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0R3Jhdml0eSgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IHRtcFZlYzogT0lNTy5WZWMzID0gUGh5c2ljcy7GkmFjdGl2ZS5vaW1vV29ybGQuZ2V0R3Jhdml0eSgpO1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3RvcjModG1wVmVjLngsIHRtcFZlYy55LCB0bXBWZWMueik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNldCB0aGUgYXBwbGllZCBncmF2aXRhdGlvbmFsIGZvcmNlIG9mIHRoZSBhY3RpdmUgaW5zdGFuY2UuIERlZmF1bHQgZWFydGggZ3Jhdml0eSA9IDkuODEgbS9zXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzZXRHcmF2aXR5KF92YWx1ZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICBsZXQgdG1wVmVjOiBPSU1PLlZlYzMgPSBuZXcgT0lNTy5WZWMzKF92YWx1ZS54LCBfdmFsdWUueSwgX3ZhbHVlLnopO1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5zZXRHcmF2aXR5KHRtcFZlYyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEFkZCBhIG5ldyBPSU1PIFJpZ2lkYm9keSB0byB0aGUgYWN0aXZlIGluc3RhbmNlLCBoYXBwZW5zIGF1dG9tYXRpY2FsbHkgd2hlbiBhZGRpbmcgYSBGVURHRSBSaWdpZGJvZHkgQ29tcG9uZW50LlxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYWRkUmlnaWRib2R5KF9jbXBSQjogQ29tcG9uZW50UmlnaWRib2R5KTogdm9pZCB7XHJcbiAgICAgIFBoeXNpY3MuxpJhY3RpdmUuYm9keUxpc3QucHVzaChfY21wUkIpO1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5hZGRSaWdpZEJvZHkoX2NtcFJCLmdldE9pbW9SaWdpZGJvZHkoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJlbW92ZSB0aGUgT0lNTyBSaWdpZGJvZHkgdG8gdGhlIGFjdGl2ZSBpbnN0YW5jZSwgaGFwcGVucyBhdXRvbWF0aWNhbGx5IHdoZW4gcmVtb3ZpbmcgYSBGVURHRSBSaWdpZGJvZHkgQ29tcG9uZW50XHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVSaWdpZGJvZHkoX2NtcFJCOiBDb21wb25lbnRSaWdpZGJvZHkpOiB2b2lkIHtcclxuICAgICAgLy8gVE9ETzogdHdvIGxpc3RzIGFyZSBiZWluZyBtYW5hZ2VkLCBpbmZvIG1pZ2h0IGRldmlhdGUuIENsZWFudXAhXHJcbiAgICAgIGxldCBvaW1vUmlnaWRCb2R5OiBPSU1PLlJpZ2lkQm9keSA9IF9jbXBSQi5nZXRPaW1vUmlnaWRib2R5KCk7XHJcbiAgICAgIGlmIChvaW1vUmlnaWRCb2R5Ll93b3JsZClcclxuICAgICAgICBvaW1vUmlnaWRCb2R5Ll93b3JsZC5yZW1vdmVSaWdpZEJvZHkob2ltb1JpZ2lkQm9keSk7XHJcbiAgICAgIC8vIHdoYXQgaWYgdGhlIHJpZ2lkYm9keXMgb2ltby13b3JsZCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhlIGFjdGl2ZSBpbnN0YW5jZT9cclxuICAgICAgbGV0IGlkOiBudW1iZXIgPSBQaHlzaWNzLsaSYWN0aXZlLmJvZHlMaXN0LmluZGV4T2YoX2NtcFJCKTtcclxuICAgICAgaWYgKGlkID4gLTEpXHJcbiAgICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5ib2R5TGlzdC5zcGxpY2UoaWQsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBZGQgYSBuZXcgT0lNTyBKb2ludC9Db25zdHJhaW50IHRvIHRoZSBhY3RpdmUgaW5zdGFuY2UsIGhhcHBlbnMgYXV0b21hdGljYWxseSB3aGVuIGFkZGluZyBhIEZVREdFIEpvaW50IENvbXBvbmVudFxyXG4gICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYWRkSm9pbnQoX2NtcEpvaW50OiBKb2ludCk6IHZvaWQge1xyXG4gICAgICBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZC5hZGRKb2ludChfY21wSm9pbnQuZ2V0T2ltb0pvaW50KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDYWxsZWQgaW50ZXJuYWxseSB0byBpbmZvcm0gdGhlIHBoeXNpY3Mgc3lzdGVtIHRoYXQgYSBqb2ludCBoYXMgYSBjaGFuZ2Ugb2YgY29yZSBwcm9wZXJ0aWVzIGFuZCBuZWVkcyB0byBiZSByZWNyZWF0ZWQuXHJcbiAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBjaGFuZ2VKb2ludFN0YXR1cyhfY21wSm9pbnQ6IEpvaW50KTogdm9pZCB7XHJcbiAgICAgIGlmIChQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdC5pbmRleE9mKF9jbXBKb2ludCkgPCAwKVxyXG4gICAgICAgIFBoeXNpY3MuxpJhY3RpdmUuam9pbnRMaXN0LnB1c2goX2NtcEpvaW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBSZW1vdmUgdGhlIE9JTU8gSm9pbnQvQ29uc3RyYWludCB0byB0aGUgYWN0aXZlIGluc3RhbmNlLCBoYXBwZW5zIGF1dG9tYXRpY2FsbHkgd2hlbiByZW1vdmluZyBhIEZVREdFIEpvaW50IENvbXBvbmVudFxyXG4gICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVKb2ludChfY21wSm9pbnQ6IEpvaW50KTogdm9pZCB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5vaW1vV29ybGQucmVtb3ZlSm9pbnQoX2NtcEpvaW50LmdldE9pbW9Kb2ludCgpKTtcclxuICAgICAgfSBjYXRjaCAoX2Vycm9yOiB1bmtub3duKSB7XHJcbiAgICAgICAgRGVidWcuZnVkZ2UoX2Vycm9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGFsbCB0aGUgQ29tcG9uZW50UmlnaWRib2RpZXMgdGhhdCBhcmUga25vd24gdG8gdGhlIGFjdGl2ZSBpbnN0YW5jZS4gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Qm9keUxpc3QoKTogQ29tcG9uZW50UmlnaWRib2R5W10ge1xyXG4gICAgICByZXR1cm4gUGh5c2ljcy7GkmFjdGl2ZS5ib2R5TGlzdDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2l2aW5nIGEgQ29tcG9uZW50UmlnaWRib2R5IGEgc3BlY2lmaWMgaWRlbnRpZmljYXRpb24gbnVtYmVyIHNvIGl0IGNhbiBiZSByZWZlcmVuY2VkIGluIHRoZSBsb2FkaW5nIHByb2Nlc3MuIEFuZCByZW1vdmVkIHJiJ3MgY2FuIHJlY2VpdmUgYSBuZXcgaWQuICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRpc3RyaWJ1dGVCb2R5SUQoKTogbnVtYmVyIHtcclxuICAgICAgbGV0IGZyZWVJZDogbnVtYmVyID0gMDtcclxuICAgICAgbGV0IGZyZWU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5ib2R5TGlzdC5mb3JFYWNoKChfdmFsdWU6IENvbXBvbmVudFJpZ2lkYm9keSk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmIChfdmFsdWUuaWQgIT0gZnJlZUlkKSB7XHJcbiAgICAgICAgICBmcmVlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZnJlZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWZyZWUpIHtcclxuICAgICAgICAgIGZyZWVJZCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gZnJlZUlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIENvbm5lY3QgYWxsIGpvaW50cyB0aGF0IGFyZSBub3QgY29ubmVjdGVkIHlldC4gVXNlZCBpbnRlcm5hbGx5IG5vIHVzZXIgaW50ZXJhY3Rpb24gbmVlZGVkLiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgY2FsbGVkIGFuZCBuZWVkZWQgdG8gbWFrZSBzdXJlIGpvaW50cyBjb25uZWN0L2Rpc2Nvbm5lY3RcclxuICAgICAqIGlmIGFueSBvZiB0aGUgdHdvIHBhaXJlZCBDb21wb25lbnRSaWdpZGJvZGllcyBjaGFuZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY29ubmVjdEpvaW50cygpOiB2b2lkIHsgLy9UcnkgdG8gY29ubmVjdCBkaXJ0eSBqb2ludHMgdW50aWwgdGhleSBhcmUgY29ubmVjdGVkXHJcbiAgICAgIGxldCBqb2ludHNUb0Nvbm5lY3Q6IEpvaW50W10gPSBQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdDtcclxuICAgICAgUGh5c2ljcy7GkmFjdGl2ZS5qb2ludExpc3QgPSBbXTtcclxuICAgICAgam9pbnRzVG9Db25uZWN0LmZvckVhY2goKF9qb2ludDogSm9pbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBpZiAoX2pvaW50LmlzQ29ubmVjdGVkKCkgPT0gZmFsc2UpXHJcbiAgICAgICAgICBpZiAoX2pvaW50LmlzQWN0aXZlKVxyXG4gICAgICAgICAgICBfam9pbnQuY29ubmVjdCgpO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdC5wdXNoKF9qb2ludCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZW1vdmUgYWxsIG9pbW8gam9pbnRzIGFuZCByaWdpZGJvZGllcywgc28gdGhhdCB0aGV5IGNhbiBiZSByZXVzZWQgaW4gYW5vdGhlciB3b3JsZCAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xlYW51cCgpOiB2b2lkIHtcclxuICAgICAgbGV0IG9pbW9Xb3JsZDogT0lNTy5Xb3JsZCA9IFBoeXNpY3MuxpJhY3RpdmUub2ltb1dvcmxkO1xyXG4gICAgICBpZiAob2ltb1dvcmxkICE9IG51bGwpIHtcclxuICAgICAgICAvL1Jlc2V0dGluZyB0aGUgd29ybGQgc28gYSBuZXcgd29ybGQgY2FuIGJlIGNyZWF0ZWQsIGZpeCBmb3IgcmUtb3BlbmluZyBhIHByb2plY3QgaW4gZWRpdG9yLCBtYWtpbmcgc3VyZSB0aGVyZSBhcmUgbm8gb2xkIHRoaW5ncyBjYWxjdWxhdGVkXHJcbiAgICAgICAgbGV0IGpvaW50c1dvcmxkOiBudW1iZXIgPSBvaW1vV29ybGQuZ2V0TnVtSm9pbnRzKCk7XHJcbiAgICAgICAgbGV0IGJvZGllc1dvcmxkOiBudW1iZXIgPSBvaW1vV29ybGQuZ2V0TnVtUmlnaWRCb2RpZXMoKTtcclxuICAgICAgICBmb3IgKGxldCBib2R5IG9mIFBoeXNpY3MuxpJhY3RpdmUuYm9keUxpc3QpXHJcbiAgICAgICAgICBib2R5LmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICBQaHlzaWNzLsaSYWN0aXZlLmpvaW50TGlzdCA9IG5ldyBBcnJheSgpOyAvLyBUT0RPOiBzZWUgaWYgaXQgd291bGQgYmUgc21hcnRlciwgZG8gdXNlIHRoZXNlIGFycmF5cy4gRGVmaW5pdGVseSBtb3JlIGludHVpdGl2ZS4uLlxyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBqb2ludHNXb3JsZDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgb2ltb0pvaW50OiBPSU1PLkpvaW50ID0gUGh5c2ljcy7GkmFjdGl2ZS5vaW1vV29ybGQuZ2V0Sm9pbnRMaXN0KCk7XHJcbiAgICAgICAgICBvaW1vV29ybGQucmVtb3ZlSm9pbnQob2ltb0pvaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IGJvZGllc1dvcmxkOyBpKyspIHtcclxuICAgICAgICAgIGxldCBvaW1vQm9keTogT0lNTy5SaWdpZEJvZHkgPSBvaW1vV29ybGQuZ2V0UmlnaWRCb2R5TGlzdCgpO1xyXG4gICAgICAgICAgb2ltb1dvcmxkLnJlbW92ZVJpZ2lkQm9keShvaW1vQm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gLyoqIFJldHVybnMgdGhlIENvbXBvbmVudFJpZ2lkYm9keSB3aXRoIHRoZSBnaXZlbiBpZC4gVXNlZCBpbnRlcm5hbGx5IHRvIHJlY29ubmVjdCBqb2ludHMgb24gbG9hZGluZyBpbiB0aGUgZWRpdG9yLiAqL1xyXG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgZ2V0Qm9keUJ5SUQoX2lkOiBudW1iZXIpOiBDb21wb25lbnRSaWdpZGJvZHkge1xyXG4gICAgLy8gICBsZXQgYm9keTogQ29tcG9uZW50UmlnaWRib2R5ID0gbnVsbDtcclxuICAgIC8vICAgUGh5c2ljcy4jYWN0aXZlUGh5c2ljcy5ib2R5TGlzdC5mb3JFYWNoKCh2YWx1ZTogQ29tcG9uZW50UmlnaWRib2R5KTogdm9pZCA9PiB7XHJcbiAgICAvLyAgICAgaWYgKHZhbHVlLmlkID09IF9pZCkge1xyXG4gICAgLy8gICAgICAgYm9keSA9IHZhbHVlO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgfSk7XHJcbiAgICAvLyAgIHJldHVybiBib2R5O1xyXG4gICAgLy8gfVxyXG5cclxuICAgIC8qKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIGVuZHBvaW50IG9mIG1hdGhlbWF0aWNhbCByYXkuIEJ5IGFkZGluZyB0aGUgbXVsdGlwbGllZCBkaXJlY3Rpb24gdG8gdGhlIG9yaWdpbi4gXHJcbiAgICAgICAqIFVzZWQgYmVjYXVzZSBPaW1vUGh5c2ljcyBkZWZpbmVzIHJheSBieSBzdGFydC9lbmQuIEJ1dCBHYW1lRW5naW5lcyBjb21tb25seSB1c2Ugb3JpZ2luL2RpcmVjdGlvbi5cclxuICAgICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRSYXlFbmRQb2ludChfc3RhcnQ6IE9JTU8uVmVjMywgX2RpcmVjdGlvbjogVmVjdG9yMywgX2xlbmd0aDogbnVtYmVyKTogT0lNTy5WZWMzIHtcclxuICAgICAgbGV0IG9yaWdpbjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgb3JpZ2luLnNldChfc3RhcnQueCwgX3N0YXJ0LnksIF9zdGFydC56KTtcclxuICAgICAgbGV0IHNjYWxlZERpcmVjdGlvbjogVmVjdG9yMyA9IF9kaXJlY3Rpb24uY2xvbmU7XHJcbiAgICAgIHNjYWxlZERpcmVjdGlvbi5zY2FsZShfbGVuZ3RoKTtcclxuICAgICAgbGV0IGVuZHBvaW50OiBWZWN0b3IzID0gVmVjdG9yMy5TVU0oc2NhbGVkRGlyZWN0aW9uLCBvcmlnaW4pO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShzY2FsZWREaXJlY3Rpb24pO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShlbmRwb2ludCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG9yaWdpbik7XHJcbiAgICAgIHJldHVybiBuZXcgT0lNTy5WZWMzKGVuZHBvaW50LngsIGVuZHBvaW50LnksIGVuZHBvaW50LnopO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBnZXQgdGhlIGRpc3RhbmNlIGluIHdoaWNoIGEgcmF5IGhpdCBieSBzdWJ0cmFjdGluZyBwb2ludHMgZnJvbSBlYWNoIG90aGVyIGFuZCBnZXQgdGhlIHNxdWFyZSByb290IG9mIHRoZSBzcXVhcmVkIHByb2R1Y3Qgb2YgZWFjaCBjb21wb25lbnQuICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRSYXlEaXN0YW5jZShfb3JpZ2luOiBWZWN0b3IzLCBfaGl0UG9pbnQ6IFZlY3RvcjMpOiBudW1iZXIge1xyXG4gICAgICBsZXQgZHg6IG51bWJlciA9IF9vcmlnaW4ueCAtIF9oaXRQb2ludC54O1xyXG4gICAgICBsZXQgZHk6IG51bWJlciA9IF9vcmlnaW4ueSAtIF9oaXRQb2ludC55O1xyXG4gICAgICBsZXQgZHo6IG51bWJlciA9IF9vcmlnaW4ueiAtIF9oaXRQb2ludC56O1xyXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJldHVybnMgdGhlIGFjdHVhbCB1c2VkIHdvcmxkIG9mIHRoZSBPSU1PIHBoeXNpY3MgZW5naW5lLiBObyB1c2VyIGludGVyYWN0aW9uIG5lZWRlZCAtIE9ubHkgZm9yIGFkdmFuY2VkIHVzZXJzIHRoYXQgbmVlZCB0byBhY2Nlc3MgaXQgZGlyZWN0bHkgKi9cclxuICAgIHB1YmxpYyBnZXRPaW1vV29ybGQoKTogT0lNTy5Xb3JsZCB7XHJcbiAgICAgIHJldHVybiBQaHlzaWNzLsaSYWN0aXZlLm9pbW9Xb3JsZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAvKiogVXBkYXRlcyBhbGwge0BsaW5rIFJpZ2lkYm9kaWVzfSBrbm93biB0byB0aGUgUGh5c2ljcy53b3JsZCB0byBtYXRjaCB0aGVpciBjb250YWluZXJzIG9yIG1lc2hlcyB0cmFuc2Zvcm1hdGlvbnMgKi9cclxuICAgIC8vIHByaXZhdGUgdXBkYXRlV29ybGRGcm9tV29ybGRNYXRyaXgoX3RvTWVzaDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XHJcbiAgICAvLyAgIGZvciAobGV0IGJvZHkgb2YgdGhpcy5ib2R5TGlzdClcclxuICAgIC8vICAgICBib2R5LnVwZGF0ZUZyb21Xb3JsZChfdG9NZXNoKTtcclxuICAgIC8vIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBEZWZpbmVzIGEgdGhyZWVkaW1lbnNpb25hbCBib3ggYnkgdHdvIGNvcm5lci1wb2ludHMsIG9uZSB3aXRoIG1pbmltYWwgdmFsdWVzIGFuZCBvbmUgd2l0aCBtYXhpbXVtIHZhbHVlc1xyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBCb3ggaW1wbGVtZW50cyBSZWN5Y2FibGUge1xyXG4gICAgcHVibGljIG1pbjogVmVjdG9yMztcclxuICAgIHB1YmxpYyBtYXg6IFZlY3RvcjM7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9taW46IFZlY3RvcjMgPSBWZWN0b3IzLk9ORShJbmZpbml0eSksIF9tYXg6IFZlY3RvcjMgPSBWZWN0b3IzLk9ORSgtSW5maW5pdHkpKSB7XHJcbiAgICAgIHRoaXMuc2V0KF9taW4sIF9tYXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIHRoZSBjb3JuZXJzIG9mIHRoaXMgYm94LCBzdGFuZGFyZCB2YWx1ZXMgYXJlIEluZmluaXR5IGZvciBtaW4sIGFuZCAtSW5maW5pdHkgZm9yIG1heCwgXHJcbiAgICAgKiBjcmVhdGluZyBhbiBpbXBvc3NpYmxlIGludmVydGVkIGJveCB0aGF0IGNhbiBub3QgY29udGFpbiBhbnkgcG9pbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX21pbjogVmVjdG9yMyA9IFZlY3RvcjMuT05FKEluZmluaXR5KSwgX21heDogVmVjdG9yMyA9IFZlY3RvcjMuT05FKC1JbmZpbml0eSkpOiB2b2lkIHtcclxuICAgICAgdGhpcy5taW4gPSBfbWluO1xyXG4gICAgICB0aGlzLm1heCA9IF9tYXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBhbmQgdGhlIGJveCBpZiBuZWNlc3NhcnkgdG8gaW5jbHVkZSB0aGUgZ2l2ZW4gcG9pbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGV4cGFuZChfaW5jbHVkZTogVmVjdG9yMyk6IHZvaWQge1xyXG4gICAgICB0aGlzLm1pbi5taW4oX2luY2x1ZGUpO1xyXG4gICAgICB0aGlzLm1heC5tYXgoX2luY2x1ZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWN5Y2xlKCk6IHZvaWQge1xyXG4gICAgICB0aGlzLm1pbi5zZXQoSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSk7XHJcbiAgICAgIHRoaXMubWF4LnNldCgtSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5KTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBTdG9yZXMgaW5mb3JtYXRpb24gcHJvdmlkZWQgYnkge0BsaW5rIFJlbmRlcn0tcGlja2luZyBlLmcuIHVzaW5nIHtAbGluayBQaWNrZXJ9IGFuZCBwcm92aWRlcyBtZXRob2RzIGZvciBmdXJ0aGVyIGNhbGN1bGF0aW9uIG9mIHBvc2l0aW9ucyBhbmQgbm9ybWFscyBldGMuXHJcbiAgICogXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUGljayB7XHJcbiAgICBwdWJsaWMgbm9kZTogTm9kZTtcclxuICAgIHB1YmxpYyB6QnVmZmVyOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgY29sb3I6IENvbG9yO1xyXG4gICAgcHVibGljIHRleHR1cmVVVjogVmVjdG9yMjtcclxuICAgIHB1YmxpYyBnaXptbz86IEdpem1vO1xyXG4gICAgI210eFZpZXdUb1dvcmxkOiBNYXRyaXg0eDQ7XHJcbiAgICAjcG9zV29ybGQ6IFZlY3RvcjM7XHJcbiAgICAjcG9zTWVzaDogVmVjdG9yMztcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX25vZGU6IE5vZGUpIHtcclxuICAgICAgdGhpcy5ub2RlID0gX25vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY2Nlc3NvciB0byBjYWxjdWxhdGUgYW5kIHN0b3JlIHdvcmxkIHBvc2l0aW9uIG9mIGludGVyc2VjdGlvbiBvZiB7QGxpbmsgUmF5fSBhbmQge0BsaW5rIE1lc2h9IG9ubHkgd2hlbiB1c2VkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHBvc1dvcmxkKCk6IFZlY3RvcjMge1xyXG4gICAgICBpZiAodGhpcy4jcG9zV29ybGQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Bvc1dvcmxkO1xyXG4gICAgICBsZXQgcG9pbnRJbkNsaXBTcGFjZTogVmVjdG9yMyA9IFZlY3RvcjMuWih0aGlzLnpCdWZmZXIpO1xyXG4gICAgICBsZXQgbTogQXJyYXlMaWtlPG51bWJlcj4gPSB0aGlzLiNtdHhWaWV3VG9Xb3JsZC5nZXRBcnJheSgpO1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IzID0gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihwb2ludEluQ2xpcFNwYWNlLCB0aGlzLiNtdHhWaWV3VG9Xb3JsZCwgdHJ1ZSk7XHJcbiAgICAgIGxldCB3OiBudW1iZXIgPSBtWzNdICogcG9pbnRJbkNsaXBTcGFjZS54ICsgbVs3XSAqIHBvaW50SW5DbGlwU3BhY2UueSArIG1bMTFdICogcG9pbnRJbkNsaXBTcGFjZS56ICsgbVsxNV07XHJcbiAgICAgIHJlc3VsdC5zY2FsZSgxIC8gdyk7XHJcblxyXG4gICAgICB0aGlzLiNwb3NXb3JsZCA9IHJlc3VsdDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFjY2Vzc29yIHRvIGNhbGN1bGF0ZSBhbmQgc3RvcmUgcG9zaXRpb24gaW4gbWVzaC1zcGFjZSBvZiBpbnRlcnNlY3Rpb24gb2Yge0BsaW5rIFJheX0gYW5kIHtAbGluayBNZXNofSBvbmx5IHdoZW4gdXNlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBwb3NNZXNoKCk6IFZlY3RvcjMge1xyXG4gICAgICBpZiAodGhpcy4jcG9zTWVzaClcclxuICAgICAgICByZXR1cm4gdGhpcy4jcG9zTWVzaDtcclxuICAgICAgbGV0IG10eFdvcmxkVG9NZXNoOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSU5WRVJTRSh0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpLm10eFdvcmxkKTtcclxuICAgICAgbGV0IHBvc01lc2g6IFZlY3RvcjMgPSBWZWN0b3IzLlRSQU5TRk9STUFUSU9OKHRoaXMucG9zV29ybGQsIG10eFdvcmxkVG9NZXNoKTtcclxuICAgICAgdGhpcy4jcG9zTWVzaCA9IHBvc01lc2g7XHJcbiAgICAgIHJldHVybiBwb3NNZXNoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWNjZXNzb3IgdG8gY2FsY3VsYXRlIGFuZCBzdG9yZSB0aGUgZmFjZSBub3JtYWwgaW4gd29ybGQtc3BhY2UgYXQgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbiBvZiB7QGxpbmsgUmF5fSBhbmQge0BsaW5rIE1lc2h9IG9ubHkgd2hlbiB1c2VkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IG5vcm1hbCgpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IGNtcE1lc2g6IENvbXBvbmVudE1lc2ggPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpO1xyXG4gICAgICBsZXQgcmVzdWx0OiBWZWN0b3IzO1xyXG5cclxuICAgICAgZm9yIChsZXQgZmFjZSBvZiBjbXBNZXNoLm1lc2guZmFjZXMpIHtcclxuICAgICAgICBpZiAoZmFjZS5pc0luc2lkZSh0aGlzLnBvc01lc2gpKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBmYWNlLm5vcm1hbC5jbG9uZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmVzdWx0LnRyYW5zZm9ybShjbXBNZXNoLm10eFdvcmxkLCBmYWxzZSk7XHJcbiAgICAgIHJlc3VsdC5ub3JtYWxpemUoKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBzb2xlbHkgYnkgdGhlIHJlbmRlcmVyIHRvIGVuYWJsZSBjYWxjdWxhdGlvbiBvZiB0aGUgd29ybGQgY29vcmRpbmF0ZXMgb2YgdGhpcyB7QGxpbmsgUGlja31cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBtdHhWaWV3VG9Xb3JsZChfbXR4Vmlld1RvV29ybGQ6IE1hdHJpeDR4NCkge1xyXG4gICAgICB0aGlzLiNtdHhWaWV3VG9Xb3JsZCA9IF9tdHhWaWV3VG9Xb3JsZDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBQcm92aWRlcyBzdGF0aWMgbWV0aG9kcyBmb3IgcGlja2luZyB1c2luZyB7QGxpbmsgUmVuZGVyfVxyXG4gICAqIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFBpY2tlciB7XHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGEgcmF5IHBsdXMgbWluIGFuZCBtYXggdmFsdWVzIGZvciB0aGUgbmVhciBhbmQgZmFyIHBsYW5lcyB0byBjb25zdHJ1Y3QgdGhlIHBpY2tlci1jYW1lcmEsXHJcbiAgICAgKiB0aGVuIHJlbmRlcnMgdGhlIHBpY2stdGV4dHVyZSBhbmQgcmV0dXJucyBhbiB1bnNvcnRlZCB7QGxpbmsgUGlja30tYXJyYXkgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaGl0cyBvZiB0aGUgcmF5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHBpY2tSYXkoX25vZGVzOiByZWFkb25seSBOb2RlW10sIF9yYXk6IFJheSwgX21pbjogbnVtYmVyLCBfbWF4OiBudW1iZXIpOiBQaWNrW107XHJcbiAgICBwdWJsaWMgc3RhdGljIHBpY2tSYXkoX2dpem1vczogcmVhZG9ubHkgR2l6bW9bXSwgX3JheTogUmF5LCBfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlcik6IFBpY2tbXTtcclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja1JheShfZnJvbTogcmVhZG9ubHkgTm9kZVtdIHwgcmVhZG9ubHkgR2l6bW9bXSwgX3JheTogUmF5LCBfbWluOiBudW1iZXIsIF9tYXg6IG51bWJlcik6IFBpY2tbXSB7XHJcbiAgICAgIGlmIChfZnJvbS5sZW5ndGggPT0gMClcclxuICAgICAgICByZXR1cm4gW107XHJcblxyXG4gICAgICBsZXQgY21wQ2FtZXJhUGljazogQ29tcG9uZW50Q2FtZXJhID0gUmVjeWNsZXIucmV1c2UoQ29tcG9uZW50Q2FtZXJhKTtcclxuICAgICAgY21wQ2FtZXJhUGljay5tdHhXb3JsZC50cmFuc2xhdGlvbiA9IF9yYXkub3JpZ2luO1xyXG4gICAgICBjbXBDYW1lcmFQaWNrLm10eFdvcmxkLmxvb2tBdChWZWN0b3IzLlNVTShfcmF5Lm9yaWdpbiwgX3JheS5kaXJlY3Rpb24pKTtcclxuICAgICAgY21wQ2FtZXJhUGljay5wcm9qZWN0Q2VudHJhbCgxLCAwLjAwMSwgRklFTERfT0ZfVklFVy5ESUFHT05BTCwgX21pbiwgX21heCk7XHJcblxyXG4gICAgICBsZXQgcGlja3M6IFBpY2tbXTtcclxuICAgICAgaWYgKF9mcm9tWzBdIGluc3RhbmNlb2YgTm9kZSlcclxuICAgICAgICBwaWNrcyA9IFJlbmRlci5waWNrKDxyZWFkb25seSBOb2RlW10+X2Zyb20sIGNtcENhbWVyYVBpY2spO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcGlja3MgPSBHaXptb3MucGljayg8cmVhZG9ubHkgR2l6bW9bXT5fZnJvbSwgY21wQ2FtZXJhUGljayk7XHJcblxyXG4gICAgICBSZWN5Y2xlci5zdG9yZShjbXBDYW1lcmFQaWNrKTtcclxuICAgICAgcmV0dXJuIHBpY2tzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSBjYW1lcmEgYW5kIGEgcG9pbnQgb24gaXRzIHZpcnR1YWwgbm9ybWVkIHByb2plY3Rpb24gcGxhbmUgKGRpc3RhbmNlIDEpIHRvIGNvbnN0cnVjdCB0aGUgcGlja2VyLWNhbWVyYSxcclxuICAgICAqIHRoZW4gcmVuZGVycyB0aGUgcGljay10ZXh0dXJlIGFuZCByZXR1cm5zIGFuIHVuc29ydGVkIHtAbGluayBQaWNrfS1hcnJheSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBoaXRzIG9mIHRoZSByYXkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja0NhbWVyYShfbm9kZXM6IHJlYWRvbmx5IE5vZGVbXSwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhLCBfcG9zUHJvamVjdGlvbjogVmVjdG9yMik6IFBpY2tbXTtcclxuICAgIHB1YmxpYyBzdGF0aWMgcGlja0NhbWVyYShfbm9kZXM6IHJlYWRvbmx5IEdpem1vW10sIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX3Bvc1Byb2plY3Rpb246IFZlY3RvcjIpOiBQaWNrW107XHJcbiAgICBwdWJsaWMgc3RhdGljIHBpY2tDYW1lcmEoX2Zyb206IHJlYWRvbmx5IE5vZGVbXSB8IHJlYWRvbmx5IEdpem1vW10sIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX3Bvc1Byb2plY3Rpb246IFZlY3RvcjIpOiBQaWNrW10ge1xyXG4gICAgICBsZXQgcmF5OiBSYXkgPSBuZXcgUmF5KG5ldyBWZWN0b3IzKC1fcG9zUHJvamVjdGlvbi54LCBfcG9zUHJvamVjdGlvbi55LCAxKSk7XHJcbiAgICAgIGxldCBsZW5ndGg6IG51bWJlciA9IHJheS5kaXJlY3Rpb24ubWFnbml0dWRlO1xyXG5cclxuICAgICAgaWYgKF9jbXBDYW1lcmEubm9kZSkge1xyXG4gICAgICAgIGxldCBtdHhDYW1lcmE6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5QUk9EVUNUKF9jbXBDYW1lcmEubm9kZS5tdHhXb3JsZCwgX2NtcENhbWVyYS5tdHhQaXZvdCk7XHJcbiAgICAgICAgcmF5LnRyYW5zZm9ybShtdHhDYW1lcmEpO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eENhbWVyYSk7XHJcbiAgICAgIH0gZWxzZVxyXG4gICAgICAgIHJheS50cmFuc2Zvcm0oX2NtcENhbWVyYS5tdHhQaXZvdCk7XHJcblxyXG4gICAgICBsZXQgcGlja3M6IFBpY2tbXSA9IFBpY2tlci5waWNrUmF5KDxHZW5lcmFsPl9mcm9tLCByYXksIGxlbmd0aCAqIF9jbXBDYW1lcmEubmVhciwgbGVuZ3RoICogX2NtcENhbWVyYS5mYXIpO1xyXG4gICAgICByZXR1cm4gcGlja3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyB0aGUgY2FtZXJhIG9mIHRoZSBnaXZlbiB2aWV3cG9ydCBhbmQgYSBwb2ludCB0aGUgY2xpZW50IHN1cmZhY2UgdG8gY29uc3RydWN0IHRoZSBwaWNrZXItY2FtZXJhLFxyXG4gICAgICogdGhlbiByZW5kZXJzIHRoZSBwaWNrLXRleHR1cmUgYW5kIHJldHVybnMgYW4gdW5zb3J0ZWQge0BsaW5rIFBpY2t9LWFycmF5IHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdHMgb2YgdGhlIHJheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBwaWNrVmlld3BvcnQoX3ZpZXdwb3J0OiBWaWV3cG9ydCwgX3Bvc0NsaWVudDogVmVjdG9yMik6IFBpY2tbXSB7XHJcbiAgICAgIGxldCBwb3NQcm9qZWN0aW9uOiBWZWN0b3IyID0gX3ZpZXdwb3J0LnBvaW50Q2xpZW50VG9Qcm9qZWN0aW9uKF9wb3NDbGllbnQpO1xyXG4gICAgICBsZXQgbm9kZXM6IE5vZGVbXSA9IEFycmF5LmZyb20oX3ZpZXdwb3J0LmdldEJyYW5jaCgpLmdldEl0ZXJhdG9yKHRydWUpKTtcclxuICAgICAgbGV0IHBpY2tzOiBQaWNrW10gPSBQaWNrZXIucGlja0NhbWVyYShub2RlcywgX3ZpZXdwb3J0LmNhbWVyYSwgcG9zUHJvamVjdGlvbik7XHJcbiAgICAgIGlmIChfdmlld3BvcnQuZ2l6bW9zRW5hYmxlZClcclxuICAgICAgICBwaWNrcyA9IHBpY2tzLmNvbmNhdChQaWNrZXIucGlja0NhbWVyYShfdmlld3BvcnQuZ2V0R2l6bW9zKG5vZGVzKSwgX3ZpZXdwb3J0LmNhbWVyYSwgcG9zUHJvamVjdGlvbikpOyAvLyB0aGlzIGlzIGtpbmQgb2Ygd2FzdGVmdWwgYmVjYXVzZSB3ZSBkbyB0aGUgc2FtZSBjYWxjdWxhdGlvbnMgdHdpY2VcclxuXHJcbiAgICAgIHJldHVybiBwaWNrcztcclxuICAgIH1cclxuXHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGVmaW5lZCBieSBhbiBvcmlnaW4gYW5kIGEgZGlyZWN0aW9uIG9mIHR5cGUge0BsaW5rIFBpY2t9LCByYXlzIGFyZSB1c2VkIHRvIGNhbGN1bGF0ZSBwaWNraW5nIGFuZCBpbnRlcnNlY3Rpb25zXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjFcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUmF5IHtcclxuICAgIHB1YmxpYyBvcmlnaW46IFZlY3RvcjM7XHJcbiAgICBwdWJsaWMgZGlyZWN0aW9uOiBWZWN0b3IzO1xyXG4gICAgLyoqIFRPRE86IHN1cHBvcnQgbGVuZ3RoICovXHJcbiAgICBwdWJsaWMgbGVuZ3RoOiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF9kaXJlY3Rpb246IFZlY3RvcjMgPSBWZWN0b3IzLlooMSksIF9vcmlnaW46IFZlY3RvcjMgPSBWZWN0b3IzLlpFUk8oKSwgX2xlbmd0aDogbnVtYmVyID0gMSkge1xyXG4gICAgICB0aGlzLm9yaWdpbiA9IF9vcmlnaW47XHJcbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gX2RpcmVjdGlvbjtcclxuICAgICAgdGhpcy5sZW5ndGggPSBfbGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIG9mIHRoaXMgcmF5IHdpdGggYSBwbGFuZSBkZWZpbmVkIGJ5IFxyXG4gICAgICogdGhlIGdpdmVuIHBvaW50IG9mIG9yaWdpbiBhbmQgdGhlIHBsYW5lcyBub3JtYWwuIEFsbCB2YWx1ZXMgYW5kIGNhbGN1bGF0aW9uc1xyXG4gICAgICogbXVzdCBiZSByZWxhdGl2ZSB0byB0aGUgc2FtZSBjb29yZGluYXRlIHN5c3RlbSwgcHJlZmVyYWJseSB0aGUgd29ybGRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGludGVyc2VjdFBsYW5lKF9vcmlnaW46IFZlY3RvcjMsIF9ub3JtYWw6IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgbGV0IGRpZmZlcmVuY2U6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX29yaWdpbiwgdGhpcy5vcmlnaW4pO1xyXG4gICAgICBsZXQgZmFjdG9yOiBudW1iZXIgPSBWZWN0b3IzLkRPVChkaWZmZXJlbmNlLCBfbm9ybWFsKSAvIFZlY3RvcjMuRE9UKHRoaXMuZGlyZWN0aW9uLCBfbm9ybWFsKTtcclxuICAgICAgbGV0IGludGVyc2VjdDogVmVjdG9yMyA9IFZlY3RvcjMuU1VNKHRoaXMub3JpZ2luLCBWZWN0b3IzLlNDQUxFKHRoaXMuZGlyZWN0aW9uLCBmYWN0b3IpKTtcclxuICAgICAgcmV0dXJuIGludGVyc2VjdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbiBvZiB0aGlzIHJheSB3aXRoIGEgcGxhbmUgZGVmaW5lZCBieSB0aGUgZmFjZS4gXHJcbiAgICAgKiBBbGwgdmFsdWVzIGFuZCBjYWxjdWxhdGlvbnMgbXVzdCBiZSByZWxhdGl2ZSB0byB0aGUgc2FtZSBjb29yZGluYXRlIHN5c3RlbSwgcHJlZmVyYWJseSB0aGUgd29ybGRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGludGVyc2VjdEZhY2VQbGFuZShfZmFjZTogRmFjZSk6IFZlY3RvcjMge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RQbGFuZShfZmFjZS5nZXRQb3NpdGlvbigwKSwgX2ZhY2Uubm9ybWFsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNob3J0ZXN0IGRpc3RhbmNlIGZyb20gdGhlIHJheSB0byB0aGUgZ2l2ZW4gdGFyZ2V0IHBvaW50LlxyXG4gICAgICogQWxsIHZhbHVlcyBhbmQgY2FsY3VsYXRpb25zIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhlIHNhbWUgY29vcmRpbmF0ZSBzeXN0ZW0sIHByZWZlcmFibHkgdGhlIHdvcmxkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RGlzdGFuY2UoX3RhcmdldDogVmVjdG9yMyk6IFZlY3RvcjMge1xyXG4gICAgICBsZXQgb3JpZ2luVG9UYXJnZXQ6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UoX3RhcmdldCwgdGhpcy5vcmlnaW4pO1xyXG4gICAgICBsZXQgcmF5U2VjdGlvbjogVmVjdG9yMyA9IFZlY3RvcjMuTk9STUFMSVpBVElPTih0aGlzLmRpcmVjdGlvbiwgMSk7XHJcbiAgICAgIGxldCBwcm9qZWN0ZWRMZW5ndGg6IG51bWJlciA9IFZlY3RvcjMuRE9UKG9yaWdpblRvVGFyZ2V0LCByYXlTZWN0aW9uKTtcclxuICAgICAgcmF5U2VjdGlvbi5zY2FsZShwcm9qZWN0ZWRMZW5ndGgpO1xyXG4gICAgICByYXlTZWN0aW9uLmFkZCh0aGlzLm9yaWdpbik7XHJcbiAgICAgIGxldCBkaXN0YW5jZTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRShfdGFyZ2V0LCByYXlTZWN0aW9uKTtcclxuICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIHRoZSByYXkgYnkgdGhlIGdpdmVuIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdHJhbnNmb3JtKF9tdHhUcmFuc2Zvcm06IE1hdHJpeDR4NCk6IHZvaWQge1xyXG4gICAgICB0aGlzLm9yaWdpbi50cmFuc2Zvcm0oX210eFRyYW5zZm9ybSk7XHJcbiAgICAgIHRoaXMuZGlyZWN0aW9uLnRyYW5zZm9ybShfbXR4VHJhbnNmb3JtLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmVhZGFibGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcmF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gYG9yaWdpbjogJHt0aGlzLm9yaWdpbi50b1N0cmluZygpfSwgZGlyZWN0aW9uOiAke3RoaXMuZGlyZWN0aW9uLnRvU3RyaW5nKCl9LCBsZW5ndGg6ICR7dGhpcy5sZW5ndGgudG9QcmVjaXNpb24oNSl9YDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGludGVyZmFjZSB0byByZW5kZXIgdmlzdWFsIGFpZHMgaW4gdGhlIGVkaXRvci4gSW1wbGVtZW50ZWQgYnkge0BsaW5rIENvbXBvbmVudH1zLiBDYW4gYmUgdXNlZCBvbiBpdHMgb3duIHRvIGRyYXcgYW5kIHBpY2sgdmlzdWFsIGFpZHMgaW5kZXBlbmRlbnQgb2YgYSBzY2VuZSBncmFwaC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEdpem1vIHtcclxuICAgIG5vZGU/OiBOb2RlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbXBsZW1lbnQgdGhpcyB0byBkcmF3IHZpc3VhbCBhaWRzIGluc2lkZSB0aGUgZWRpdG9ycyByZW5kZXIgdmlldy4gVXNlIHtAbGluayBHaXptb3N9IGluc2lkZSB0aGUgb3ZlcnJpZGUgdG8gZHJhdyBzdHVmZi5cclxuICAgICAqL1xyXG4gICAgZHJhd0dpem1vcz8oX2NtcENhbWVyYT86IENvbXBvbmVudENhbWVyYSwgX3BpY2tpbmc/OiBib29sZWFuKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlZSB7QGxpbmsgZHJhd0dpem1vc30uIE9ubHkgZGlzcGxheWVkIHdoaWxlIHRoZSBjb3JyZXNwb25kaW5nIG5vZGUgaXMgc2VsZWN0ZWQuXHJcbiAgICAgKi9cclxuICAgIGRyYXdHaXptb3NTZWxlY3RlZD8oX2NtcENhbWVyYT86IENvbXBvbmVudENhbWVyYSk6IHZvaWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZ2l6bW9zIGRyYXdpbmcgaW50ZXJmYWNlLiB7QGxpbmsgQ29tcG9uZW50fXMgY2FuIHVzZSB0aGlzIHRvIGRyYXcgdmlzdWFsIGFpZHMgaW5zaWRlIHtAbGluayBDb21wb25lbnQuZHJhd0dpem1vc30gYW5kIHtAbGluayBDb21wb25lbnQuZHJhd0dpem1vc1NlbGVjdGVkfS5cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgR2l6bW9zIHtcclxuICAgIC8qKiBcclxuICAgICAqIFRoZSBkZWZhdWx0IG9wYWNpdHkgb2Ygb2NjbHVkZWQgZ2l6bW8gcGFydHMuIFVzZSB0aGlzIHRvIGNvbnRyb2wgdGhlIHZpc2liaWxpdHkgb2YgZ2l6bW9zIGJlaGluZCBvYmplY3RzLlxyXG4gICAgICogU2V0IHRvIDAgdG8gbWFrZSBvY2NsdWRlZCBnaXptbyBwYXJ0cyBkaXNhcHBlYXIuIFNldCB0byAxIHRvIG1ha2Ugb2NjbHVkZWQgZ2l6bW8gcGFydHMgZnVsbHkgdmlzaWJsZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgYWxwaGFPY2NsdWRlZDogbnVtYmVyID0gMC4zOyAvLyBjdXJyZW50bHkgZ2l6bW9zIGNhbiBhbHdheXMgYmUgcGlja2VkIGV2ZW4gaWYgdGhpcyBpcyBzZXQgdG8gMC4uLlxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGFycmF5QnVmZmVyOiBXZWJHTEJ1ZmZlciA9IFJlbmRlcldlYkdMLmFzc2VydChSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCkuY3JlYXRlQnVmZmVyKCkpO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHBpY2tJZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgcG9zSWNvbnM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpOyAvLyBjYWNoZSB0aGUgcG9zaXRpb25zIG9mIGljb25zIHRvIGF2b2lkIGRyYXdpbmcgdGhlbSB3aXRoaW4gZWFjaCBvdGhlclxyXG5cclxuICAgIHN0YXRpYyAjY2FtZXJhOiBDb21wb25lbnRDYW1lcmE7XHJcblxyXG4gICAgc3RhdGljICNtZXNoZXM6IHsgW2tleTogc3RyaW5nXTogTWVzaCB9ID0ge307XHJcbiAgICBzdGF0aWMgI21hcE1lc2hUb1dpcmVCdWZmZXJzOiBXZWFrTWFwPE1lc2gsIFJlbmRlckJ1ZmZlcnM+ID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbiAgICAvLyBUT0RPOiB0aGluayBhYm91dCBkcmF3aW5nIHRoZXNlIG9uIHRoZSBmbHkgaW5zdGVhZCBvZiBjYWNoaW5nIHRoZW0uIFRoZW4gd2UgY291bGQgYWNjZXB0IGEgcG9zaXRpb24sIHJhZGl1cyBldGMuIHBhcmFtZXRlciBhbmQgZHJhdyB0aGVtIGluZGVwZW5kZW50IGZyb20gdGhlIG10eFdvcmxkXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXQgd2lyZUNpcmNsZSgpOiBWZWN0b3IzW10ge1xyXG4gICAgICBjb25zdCByYWRpdXM6IG51bWJlciA9IDAuNTtcclxuICAgICAgY29uc3Qgc2VnbWVudHM6IG51bWJlciA9IDQ1O1xyXG4gICAgICBjb25zdCBjaXJjbGU6IFZlY3RvcjNbXSA9IG5ldyBBcnJheShzZWdtZW50cykuZmlsbChudWxsKS5tYXAoKCkgPT4gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpKTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspIHtcclxuICAgICAgICBjb25zdCBhbmdsZTogbnVtYmVyID0gKGkgLyBzZWdtZW50cykgKiAyICogTWF0aC5QSTtcclxuICAgICAgICBjb25zdCB4OiBudW1iZXIgPSByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgY29uc3QgeTogbnVtYmVyID0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgIGNpcmNsZVtpXS5zZXQoeCwgeSwgMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGxpbmVzOiBWZWN0b3IzW10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspXHJcbiAgICAgICAgbGluZXMucHVzaChjaXJjbGVbaV0sIGNpcmNsZVsoaSArIDEpICUgc2VnbWVudHNdKTtcclxuXHJcbiAgICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoR2l6bW9zLCBcIndpcmVDaXJjbGVcIiwgeyB2YWx1ZTogbGluZXMgfSk7XHJcbiAgICAgIHJldHVybiBHaXptb3Mud2lyZUNpcmNsZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXQgd2lyZVNwaGVyZSgpOiBWZWN0b3IzW10ge1xyXG4gICAgICBsZXQgbGluZXM6IFZlY3RvcjNbXSA9IEdpem1vcy53aXJlQ2lyY2xlLmNvbmNhdCgpO1xyXG4gICAgICBsZXQgbXR4Um90YXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTl9YKDkwKTtcclxuICAgICAgbGluZXMucHVzaCguLi5HaXptb3Mud2lyZUNpcmNsZS5tYXAoKF9wb2ludDogVmVjdG9yMykgPT4gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfcG9pbnQsIG10eFJvdGF0aW9uKSkpO1xyXG4gICAgICBtdHhSb3RhdGlvbi5yb3RhdGVZKDkwKTtcclxuICAgICAgbGluZXMucHVzaCguLi5HaXptb3Mud2lyZUNpcmNsZS5tYXAoKF9wb2ludDogVmVjdG9yMykgPT4gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfcG9pbnQsIG10eFJvdGF0aW9uKSkpO1xyXG5cclxuICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShHaXptb3MsIFwid2lyZVNwaGVyZVwiLCB7IHZhbHVlOiBsaW5lcyB9KTtcclxuICAgICAgcmV0dXJuIEdpem1vcy53aXJlU3BoZXJlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldCB3aXJlQ29uZSgpOiBWZWN0b3IzW10ge1xyXG4gICAgICBjb25zdCByYWRpdXM6IG51bWJlciA9IDAuNTtcclxuICAgICAgY29uc3QgaGVpZ2h0OiBudW1iZXIgPSAxO1xyXG4gICAgICBjb25zdCBhcGV4OiBWZWN0b3IzID0gVmVjdG9yMy5aRVJPKCk7XHJcbiAgICAgIGNvbnN0IHF1YWQ6IFZlY3RvcjNbXSA9IFtcclxuICAgICAgICBuZXcgVmVjdG9yMyhyYWRpdXMsIDAsIGhlaWdodCksXHJcbiAgICAgICAgbmV3IFZlY3RvcjMoLXJhZGl1cywgMCwgaGVpZ2h0KSxcclxuICAgICAgICBuZXcgVmVjdG9yMygwLCByYWRpdXMsIGhlaWdodCksXHJcbiAgICAgICAgbmV3IFZlY3RvcjMoMCwgLXJhZGl1cywgaGVpZ2h0KVxyXG4gICAgICBdO1xyXG5cclxuICAgICAgbGV0IGxpbmVzOiBWZWN0b3IzW10gPSBHaXptb3Mud2lyZUNpcmNsZS5tYXAoKF9wb2ludDogVmVjdG9yMykgPT4gVmVjdG9yMy5UUkFOU0ZPUk1BVElPTihfcG9pbnQsIE1hdHJpeDR4NC5UUkFOU0xBVElPTihWZWN0b3IzLlooMSkpKSk7XHJcblxyXG4gICAgICBsaW5lcy5wdXNoKC4uLlthcGV4LCBxdWFkWzBdLCBhcGV4LCBxdWFkWzFdLCBhcGV4LCBxdWFkWzJdLCBhcGV4LCBxdWFkWzNdXSk7XHJcblxyXG4gICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KEdpem1vcywgXCJ3aXJlQ29uZVwiLCB7IHZhbHVlOiBsaW5lcyB9KTtcclxuICAgICAgcmV0dXJuIEdpem1vcy53aXJlQ29uZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXQgd2lyZUN1YmUoKTogVmVjdG9yM1tdIHtcclxuICAgICAgY29uc3QgaGFsZlNpemU6IG51bWJlciA9IDAuNTtcclxuICAgICAgY29uc3QgY3ViZTogVmVjdG9yM1tdID0gW1xyXG4gICAgICAgIG5ldyBWZWN0b3IzKGhhbGZTaXplLCBoYWxmU2l6ZSwgaGFsZlNpemUpLCBuZXcgVmVjdG9yMygtaGFsZlNpemUsIGhhbGZTaXplLCBoYWxmU2l6ZSksXHJcbiAgICAgICAgbmV3IFZlY3RvcjMoLWhhbGZTaXplLCAtaGFsZlNpemUsIGhhbGZTaXplKSwgbmV3IFZlY3RvcjMoaGFsZlNpemUsIC1oYWxmU2l6ZSwgaGFsZlNpemUpLFxyXG4gICAgICAgIG5ldyBWZWN0b3IzKGhhbGZTaXplLCBoYWxmU2l6ZSwgLWhhbGZTaXplKSwgbmV3IFZlY3RvcjMoLWhhbGZTaXplLCBoYWxmU2l6ZSwgLWhhbGZTaXplKSxcclxuICAgICAgICBuZXcgVmVjdG9yMygtaGFsZlNpemUsIC1oYWxmU2l6ZSwgLWhhbGZTaXplKSwgbmV3IFZlY3RvcjMoaGFsZlNpemUsIC1oYWxmU2l6ZSwgLWhhbGZTaXplKVxyXG4gICAgICBdO1xyXG5cclxuICAgICAgY29uc3QgbGluZXM6IFZlY3RvcjNbXSA9IFtcclxuICAgICAgICBjdWJlWzBdLCBjdWJlWzFdLCBjdWJlWzFdLCBjdWJlWzJdLCBjdWJlWzJdLCBjdWJlWzNdLCBjdWJlWzNdLCBjdWJlWzBdLFxyXG4gICAgICAgIGN1YmVbNF0sIGN1YmVbNV0sIGN1YmVbNV0sIGN1YmVbNl0sIGN1YmVbNl0sIGN1YmVbN10sIGN1YmVbN10sIGN1YmVbNF0sXHJcbiAgICAgICAgY3ViZVswXSwgY3ViZVs0XSwgY3ViZVsxXSwgY3ViZVs1XSwgY3ViZVsyXSwgY3ViZVs2XSwgY3ViZVszXSwgY3ViZVs3XVxyXG4gICAgICBdO1xyXG5cclxuICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShHaXptb3MsIFwid2lyZUN1YmVcIiwgeyB2YWx1ZTogbGluZXMgfSk7XHJcbiAgICAgIHJldHVybiBHaXptb3Mud2lyZUN1YmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcmUgd2UgY3VycmVudGx5IHJlbmRlcmluZyBmb3IgcGlja2luZz9cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCAjcGlja2luZygpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGlja0lkICE9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgZ2l2ZW4gZ2l6bW9zIGZyb20gdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhlIGdpdmVuIGNhbWVyYS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3KF9naXptb3M6IEdpem1vW10sIF9jbXBDYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX3NlbGVjdGVkPzogTm9kZVtdKTogdm9pZCB7XHJcbiAgICAgIGZvciAoY29uc3QgZ2l6bW8gb2YgX2dpem1vcylcclxuICAgICAgICBpZiAoZ2l6bW8ubm9kZSlcclxuICAgICAgICAgIFJlZmxlY3Quc2V0KGdpem1vLm5vZGUsIFwiekNhbWVyYVwiLCBfY21wQ2FtZXJhLnBvaW50V29ybGRUb0NsaXAoZ2l6bW8ubm9kZS5tdHhXb3JsZC50cmFuc2xhdGlvbikueik7XHJcblxyXG4gICAgICBfZ2l6bW9zID0gX2dpem1vcy5zb3J0KChfYSwgX2IpID0+XHJcbiAgICAgICAgKF9iLm5vZGUgPyBSZWZsZWN0LmdldChfYi5ub2RlLCBcInpDYW1lcmFcIikgOiAyKSAtXHJcbiAgICAgICAgKF9hLm5vZGUgPyBSZWZsZWN0LmdldChfYS5ub2RlLCBcInpDYW1lcmFcIikgOiAyKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgR2l6bW9zLiNjYW1lcmEgPSBfY21wQ2FtZXJhO1xyXG4gICAgICBHaXptb3MucG9zSWNvbnMuY2xlYXIoKTtcclxuXHJcbiAgICAgIFJlbmRlcldlYkdMQ29tcG9uZW50Q2FtZXJhLnVzZVJlbmRlcmJ1ZmZlcihfY21wQ2FtZXJhKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgZ2l6bW8gb2YgX2dpem1vcykge1xyXG4gICAgICAgIGdpem1vLmRyYXdHaXptb3M/LihfY21wQ2FtZXJhLCBHaXptb3MuI3BpY2tpbmcpO1xyXG4gICAgICAgIGlmIChfc2VsZWN0ZWQ/LmluY2x1ZGVzKGdpem1vLm5vZGUpKVxyXG4gICAgICAgICAgZ2l6bW8uZHJhd0dpem1vc1NlbGVjdGVkPy4oX2NtcENhbWVyYSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpY2tzIGFsbCBnaXptb3MgaW4gdGhlIGxpbmUgb2Ygc2lnaHQgYW5kIHJldHVybnMgYW4gdW5zb3J0ZWQgYXJyYXkgb2Yge0BsaW5rIFBpY2t9cyBlYWNoIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l6bW8gdGhlIHBpY2sgcmF5IGhpdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBwaWNrKF9naXptb3M6IHJlYWRvbmx5IEdpem1vc1tdLCBfY21wQ2FtZXJhOiBDb21wb25lbnRDYW1lcmEpOiBQaWNrW10ge1xyXG4gICAgICByZXR1cm4gUmVuZGVyV2ViR0xQaWNraW5nLnBpY2tGcm9tKF9naXptb3MsIF9jbXBDYW1lcmEsIEdpem1vcy5waWNrR2l6bW9zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgY2FtZXJhIGZydXN0dW0gZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLiBUaGUgZnJ1c3R1bSBpcyBvcmllbnRlZCBhbG9uZyB0aGUgei1heGlzLCB3aXRoIHRoZSB0aXAgb2YgdGhlIHRydW5jYXRlZCBweXJhbWlkIGF0IHRoZSBvcmlnaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhd1dpcmVGcnVzdHVtKF9hc3BlY3Q6IG51bWJlciwgX2ZvdjogbnVtYmVyLCBfbmVhcjogbnVtYmVyLCBfZmFyOiBudW1iZXIsIF9kaXJlY3Rpb246IEZJRUxEX09GX1ZJRVcsIF9tdHhXb3JsZDogTWF0cml4NHg0LCBfY29sb3I6IENvbG9yLCBfYWxwaGFPY2NsdWRlZDogbnVtYmVyID0gR2l6bW9zLmFscGhhT2NjbHVkZWQpOiB2b2lkIHtcclxuICAgICAgY29uc3QgZjogbnVtYmVyID0gTWF0aC50YW4oQ2FsYy5kZWcycmFkICogX2ZvdiAvIDIpO1xyXG5cclxuICAgICAgbGV0IHNjYWxlWDogbnVtYmVyID0gZjtcclxuICAgICAgbGV0IHNjYWxlWTogbnVtYmVyID0gZjtcclxuXHJcbiAgICAgIHN3aXRjaCAoX2RpcmVjdGlvbikge1xyXG4gICAgICAgIGNhc2UgRklFTERfT0ZfVklFVy5IT1JJWk9OVEFMOlxyXG4gICAgICAgICAgc2NhbGVZID0gZiAvIF9hc3BlY3Q7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEZJRUxEX09GX1ZJRVcuVkVSVElDQUw6XHJcbiAgICAgICAgICBzY2FsZVggPSBmICogX2FzcGVjdDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRklFTERfT0ZfVklFVy5ESUFHT05BTDpcclxuICAgICAgICAgIGNvbnN0IGRpYWdvbmFsQXNwZWN0OiBudW1iZXIgPSBNYXRoLnNxcnQoX2FzcGVjdCk7XHJcbiAgICAgICAgICBzY2FsZVggPSBmICogZGlhZ29uYWxBc3BlY3Q7XHJcbiAgICAgICAgICBzY2FsZVkgPSBmIC8gZGlhZ29uYWxBc3BlY3Q7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbmVhclg6IG51bWJlciA9IF9uZWFyICogc2NhbGVYO1xyXG4gICAgICBjb25zdCBuZWFyWTogbnVtYmVyID0gX25lYXIgKiBzY2FsZVk7XHJcbiAgICAgIGNvbnN0IGZhclg6IG51bWJlciA9IF9mYXIgKiBzY2FsZVg7XHJcbiAgICAgIGNvbnN0IGZhclk6IG51bWJlciA9IF9mYXIgKiBzY2FsZVk7XHJcblxyXG4gICAgICBjb25zdCBmcnVzdHVtOiBWZWN0b3IzW10gPSBuZXcgQXJyYXkoOCkuZmlsbChudWxsKS5tYXAoKCkgPT4gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpKTtcclxuXHJcbiAgICAgIGZydXN0dW1bMF0uc2V0KC1uZWFyWCwgbmVhclksIF9uZWFyKTtcclxuICAgICAgZnJ1c3R1bVsxXS5zZXQobmVhclgsIG5lYXJZLCBfbmVhcik7XHJcbiAgICAgIGZydXN0dW1bMl0uc2V0KG5lYXJYLCAtbmVhclksIF9uZWFyKTtcclxuICAgICAgZnJ1c3R1bVszXS5zZXQoLW5lYXJYLCAtbmVhclksIF9uZWFyKTtcclxuXHJcbiAgICAgIGZydXN0dW1bNF0uc2V0KC1mYXJYLCBmYXJZLCBfZmFyKTtcclxuICAgICAgZnJ1c3R1bVs1XS5zZXQoZmFyWCwgZmFyWSwgX2Zhcik7XHJcbiAgICAgIGZydXN0dW1bNl0uc2V0KGZhclgsIC1mYXJZLCBfZmFyKTtcclxuICAgICAgZnJ1c3R1bVs3XS5zZXQoLWZhclgsIC1mYXJZLCBfZmFyKTtcclxuXHJcbiAgICAgIEdpem1vcy5kcmF3TGluZXMoW1xyXG4gICAgICAgIGZydXN0dW1bMF0sIGZydXN0dW1bMV0sIGZydXN0dW1bMV0sIGZydXN0dW1bMl0sIGZydXN0dW1bMl0sIGZydXN0dW1bM10sIGZydXN0dW1bM10sIGZydXN0dW1bMF0sIC8vIG5lYXIgcGxhbmVcclxuICAgICAgICBmcnVzdHVtWzRdLCBmcnVzdHVtWzVdLCBmcnVzdHVtWzVdLCBmcnVzdHVtWzZdLCBmcnVzdHVtWzZdLCBmcnVzdHVtWzddLCBmcnVzdHVtWzddLCBmcnVzdHVtWzRdLCAvLyBmYXIgcGxhbmVcclxuICAgICAgICBmcnVzdHVtWzBdLCBmcnVzdHVtWzRdLCBmcnVzdHVtWzFdLCBmcnVzdHVtWzVdLCBmcnVzdHVtWzJdLCBmcnVzdHVtWzZdLCBmcnVzdHVtWzNdLCBmcnVzdHVtWzddICAvLyBzaWRlc1xyXG4gICAgICBdLCBfbXR4V29ybGQsIF9jb2xvciwgX2FscGhhT2NjbHVkZWQpO1xyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmUoZnJ1c3R1bSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIHdpcmVmcmFtZSBjdWJlLiBUaGUgY3ViZSBoYXMgYSBzaWRlLWxlbmd0aCBvZiAxIGFuZCBpcyBjZW50ZXJlZCBhcm91bmQgdGhlIG9yaWdpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3V2lyZUN1YmUoX210eFdvcmxkOiBNYXRyaXg0eDQsIF9jb2xvcjogQ29sb3IsIF9hbHBoYU9jY2x1ZGVkOiBudW1iZXIgPSBHaXptb3MuYWxwaGFPY2NsdWRlZCk6IHZvaWQge1xyXG4gICAgICBHaXptb3MuZHJhd0xpbmVzKEdpem1vcy53aXJlQ3ViZSwgX210eFdvcmxkLCBfY29sb3IsIF9hbHBoYU9jY2x1ZGVkKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIHdpcmVmcmFtZSBzcGhlcmUuIFRoZSBzcGhlcmUgaGFzIGEgZGlhbWV0ZXIgb2YgMSBhbmQgaXMgY2VudGVyZWQgYXJvdW5kIHRoZSBvcmlnaW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhd1dpcmVTcGhlcmUoX210eFdvcmxkOiBNYXRyaXg0eDQsIF9jb2xvcjogQ29sb3IsIF9hbHBoYU9jY2x1ZGVkOiBudW1iZXIgPSBHaXptb3MuYWxwaGFPY2NsdWRlZCk6IHZvaWQge1xyXG4gICAgICBsZXQgbXR4V29ybGQ6IE1hdHJpeDR4NCA9IF9tdHhXb3JsZC5jbG9uZTtcclxuXHJcbiAgICAgIEdpem1vcy5kcmF3TGluZXMoR2l6bW9zLndpcmVTcGhlcmUsIG10eFdvcmxkLCBfY29sb3IsIF9hbHBoYU9jY2x1ZGVkKTtcclxuICAgICAgbXR4V29ybGQubG9va0F0KEdpem1vcy4jY2FtZXJhLm10eFdvcmxkLnRyYW5zbGF0aW9uKTtcclxuICAgICAgR2l6bW9zLmRyYXdXaXJlQ2lyY2xlKG10eFdvcmxkLCBfY29sb3IsIF9hbHBoYU9jY2x1ZGVkKTtcclxuXHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFdvcmxkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgY29uZSB3aXRoIGEgaGVpZ2h0IGFuZCBkaWFtZXRlciBvZiAxLiBUaGUgY29uZSBpcyBvcmllbnRlZCBhbG9uZyB0aGUgei1heGlzIHdpdGggdGhlIHRpcCBhdCB0aGUgb3JpZ2luLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXdXaXJlQ29uZShfbXR4V29ybGQ6IE1hdHJpeDR4NCwgX2NvbG9yOiBDb2xvciwgX2FscGhhT2NjbHVkZWQ6IG51bWJlciA9IEdpem1vcy5hbHBoYU9jY2x1ZGVkKTogdm9pZCB7XHJcbiAgICAgIEdpem1vcy5kcmF3TGluZXMoR2l6bW9zLndpcmVDb25lLCBfbXR4V29ybGQsIF9jb2xvciwgX2FscGhhT2NjbHVkZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYSBjaXJjbGUgd2l0aCBhIGRpYW1ldGVyIG9mIDEuIFRoZSBjaXJjbGUgbGllcyBpbiB0aGUgeC15IHBsYW5lLCB3aXRoIGl0cyBjZW50ZXIgYXQgdGhlIG9yaWdpbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3V2lyZUNpcmNsZShfbXR4V29ybGQ6IE1hdHJpeDR4NCwgX2NvbG9yOiBDb2xvciwgX2FscGhhT2NjbHVkZWQ6IG51bWJlciA9IEdpem1vcy5hbHBoYU9jY2x1ZGVkKTogdm9pZCB7XHJcbiAgICAgIEdpem1vcy5kcmF3TGluZXMoR2l6bW9zLndpcmVDaXJjbGUsIF9tdHhXb3JsZCwgX2NvbG9yLCBfYWxwaGFPY2NsdWRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBsaW5lcyBiZXR3ZWVuIGVhY2ggcGFpciBvZiB0aGUgZ2l2ZW4gdmVydGljZXMuIFxyXG4gICAgICogVmVydGljZXMgYXJlIHBhaXJlZCBzZXF1ZW50aWFsbHksIHNvIGZvciBleGFtcGxlLCBsaW5lcyB3aWxsIGJlIGRyYXduIGJldHdlZW4gdmVydGljZXMgMCBhbmQgMSwgMiBhbmQgMywgNCBhbmQgNSwgZXRjLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXdMaW5lcyhfdmVydGljZXM6IFZlY3RvcjNbXSwgX210eFdvcmxkOiBNYXRyaXg0eDQsIF9jb2xvcjogQ29sb3IsIF9hbHBoYU9jY2x1ZGVkOiBudW1iZXIgPSBHaXptb3MuYWxwaGFPY2NsdWRlZCk6IHZvaWQge1xyXG4gICAgICBjb25zdCBjcmMzOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ID0gUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpO1xyXG4gICAgICBjb25zdCBzaGFkZXI6IFNoYWRlckludGVyZmFjZSA9IEdpem1vcy4jcGlja2luZyA/IFNoYWRlclBpY2sgOiBTaGFkZXJHaXptbztcclxuICAgICAgc2hhZGVyLnVzZVByb2dyYW0oKTtcclxuXHJcbiAgICAgIGNvbnN0IGxpbmVEYXRhOiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KF92ZXJ0aWNlcy5sZW5ndGggKiAzKTtcclxuICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IF92ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHBvaW50OiBWZWN0b3IzID0gX3ZlcnRpY2VzW2ldO1xyXG4gICAgICAgIGxpbmVEYXRhLnNldChwb2ludC5nZXQoKSwgaSAqIDMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjcmMzLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcclxuICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCBHaXptb3MuYXJyYXlCdWZmZXIpO1xyXG4gICAgICBjcmMzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KFNIQURFUl9BVFRSSUJVVEUuUE9TSVRJT04pO1xyXG4gICAgICBjcmMzLnZlcnRleEF0dHJpYlBvaW50ZXIoU0hBREVSX0FUVFJJQlVURS5QT1NJVElPTiwgMywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG5cclxuICAgICAgR2l6bW9zLmJ1ZmZlck1hdHJpeChzaGFkZXIsIF9tdHhXb3JsZCk7XHJcbiAgICAgIGNyYzMuYnVmZmVyRGF0YShXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkFSUkFZX0JVRkZFUiwgbGluZURhdGEsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRFlOQU1JQ19EUkFXKTtcclxuXHJcbiAgICAgIEdpem1vcy5kcmF3R2l6bW9zKHNoYWRlciwgR2l6bW9zLmRyYXdBcnJheXMsIF92ZXJ0aWNlcy5sZW5ndGgsIF9jb2xvciwgX2FscGhhT2NjbHVkZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYSB3aXJlZnJhbWUgbWVzaC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3V2lyZU1lc2goX21lc2g6IE1lc2gsIF9tdHhXb3JsZDogTWF0cml4NHg0LCBfY29sb3I6IENvbG9yLCBfYWxwaGFPY2NsdWRlZDogbnVtYmVyID0gR2l6bW9zLmFscGhhT2NjbHVkZWQpOiB2b2lkIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgY29uc3Qgc2hhZGVyOiBTaGFkZXJJbnRlcmZhY2UgPSBHaXptb3MuI3BpY2tpbmcgPyBTaGFkZXJQaWNrIDogU2hhZGVyR2l6bW87XHJcbiAgICAgIHNoYWRlci51c2VQcm9ncmFtKCk7XHJcblxyXG4gICAgICBjb25zdCB3aXJlQnVmZmVyczogUmVuZGVyQnVmZmVycyA9IEdpem1vcy4jbWFwTWVzaFRvV2lyZUJ1ZmZlcnMuZ2V0KF9tZXNoKSA/PyB7fTtcclxuXHJcbiAgICAgIGlmICghR2l6bW9zLiNtYXBNZXNoVG9XaXJlQnVmZmVycy5oYXMoX21lc2gpKSB7XHJcbiAgICAgICAgY29uc3QgaW5kaWNlczogbnVtYmVyW10gPSBbXTtcclxuICAgICAgICBjb25zdCByZW5kZXJCdWZmZXJzOiBSZW5kZXJCdWZmZXJzID0gX21lc2guZ2V0UmVuZGVyQnVmZmVycygpO1xyXG4gICAgICAgIGNvbnN0IHJlbmRlck1lc2g6IFJlbmRlck1lc2ggPSBfbWVzaC5yZW5kZXJNZXNoO1xyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCByZW5kZXJNZXNoLmluZGljZXMubGVuZ3RoOyBpICs9IDMpIHsgLy8gVE9ETzogdGhpbmsgYWJvdXQgY2FjaGluZyB0aGlzIGluIHRoZSBtZXNoXHJcbiAgICAgICAgICBjb25zdCBhOiBudW1iZXIgPSByZW5kZXJNZXNoLmluZGljZXNbaV07XHJcbiAgICAgICAgICBjb25zdCBiOiBudW1iZXIgPSByZW5kZXJNZXNoLmluZGljZXNbaSArIDFdO1xyXG4gICAgICAgICAgY29uc3QgYzogbnVtYmVyID0gcmVuZGVyTWVzaC5pbmRpY2VzW2kgKyAyXTtcclxuICBcclxuICAgICAgICAgIC8vIEFkZCB0aGUgbGluZSBzZWdtZW50cyBmb3IgdGhlIHRyaWFuZ2xlIHRvIHRoZSBsaW5lIGluZGljZXNcclxuICAgICAgICAgIGluZGljZXMucHVzaChhLCBiLCBiLCBjLCBjLCBhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNldCB1cCB2ZXJ0ZXggYXR0cmlidXRlIG9iamVjdFxyXG4gICAgICAgIHdpcmVCdWZmZXJzLnZhbyA9IFJlbmRlcldlYkdMLmFzc2VydDxXZWJHTFZlcnRleEFycmF5T2JqZWN0PihjcmMzLmNyZWF0ZVZlcnRleEFycmF5KCkpO1xyXG4gICAgICAgIHdpcmVCdWZmZXJzLmluZGljZXMgPSBSZW5kZXJXZWJHTC5hc3NlcnQoUmVuZGVyV2ViR0wuZ2V0UmVuZGVyaW5nQ29udGV4dCgpLmNyZWF0ZUJ1ZmZlcigpKTtcclxuICAgICAgICB3aXJlQnVmZmVycy5wb3NpdGlvbnMgPSByZW5kZXJCdWZmZXJzLnBvc2l0aW9ucztcclxuICAgICAgICB3aXJlQnVmZmVycy5uSW5kaWNlcyA9IGluZGljZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICBjcmMzLmJpbmRWZXJ0ZXhBcnJheSh3aXJlQnVmZmVycy52YW8pO1xyXG4gICAgICAgIGNyYzMuYmluZEJ1ZmZlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB3aXJlQnVmZmVycy5pbmRpY2VzKTtcclxuICAgICAgICBjcmMzLmJ1ZmZlckRhdGEoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbmV3IFVpbnQxNkFycmF5KGluZGljZXMpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgICAgY3JjMy5iaW5kQnVmZmVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQVJSQVlfQlVGRkVSLCByZW5kZXJCdWZmZXJzLnBvc2l0aW9ucyk7XHJcbiAgICAgICAgY3JjMy5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShTSEFERVJfQVRUUklCVVRFLlBPU0lUSU9OKTtcclxuICAgICAgICBjcmMzLnZlcnRleEF0dHJpYlBvaW50ZXIoU0hBREVSX0FUVFJJQlVURS5QT1NJVElPTiwgMywgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBHaXptb3MuYnVmZmVyTWF0cml4KHNoYWRlciwgX210eFdvcmxkKTtcclxuICAgICAgY3JjMy5iaW5kVmVydGV4QXJyYXkod2lyZUJ1ZmZlcnMudmFvKTtcclxuICAgICAgR2l6bW9zLmRyYXdHaXptb3Moc2hhZGVyLCBHaXptb3MuZHJhd0VsZW1lbnRzTGluZXMsIHdpcmVCdWZmZXJzLm5JbmRpY2VzLCBfY29sb3IsIF9hbHBoYU9jY2x1ZGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGFuIGFycm93IGF0IHRoZSBnaXZlbiB3b3JsZCBwb3NpdGlvbiwgZmFjaW5nIGluIHRoZSBnaXZlbiBmb3J3YXJkLWRpcmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBsZW5ndGggYW5kIHdpZHRoLiBcclxuICAgICAqIFNpemUgcmVmZXJzIHRvIHRoZSBzaXplIG9mIHRoZSBhcnJvdyBoZWFkOiB0aGUgaGVpZ2h0IG9mIHRoZSBweXJhbWlkOyB0aGUgc2l6ZSBvZiB0aGUgY3ViZTsgdGhlIGRpYW1ldGVyIG9mIHRoZSBzcGhlcmUuXHJcbiAgICAgKiBAcGFyYW0gX2ZvcndhcmQgQSB1bml0IHZlY3RvciBpbmRpY2F0aW5nIHRoZSBkZXNpcmVkIGZvcndhcmQtZGlyZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIF91cCBBIHVuaXQgdmVjdG9yIGluZGljYXRpbmcgdGhlIHVwLWRpcmVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3QXJyb3coX3Bvc2l0aW9uOiBWZWN0b3IzLCBfY29sb3I6IENvbG9yLCBfZm9yd2FyZDogVmVjdG9yMywgX3VwOiBWZWN0b3IzLCBfbGVuZ3RoOiBudW1iZXIsIF93aWR0aDogbnVtYmVyLCBfc2l6ZTogbnVtYmVyLCBfaGVhZDogdHlwZW9mIE1lc2hDdWJlIHwgdHlwZW9mIE1lc2hQeXJhbWlkIHwgdHlwZW9mIE1lc2hTcGhlcmUgfCBudWxsID0gTWVzaFB5cmFtaWQsIF9hbHBoYU9jY2x1ZGVkOiBudW1iZXIgPSBHaXptb3MuYWxwaGFPY2NsdWRlZCk6IHZvaWQge1xyXG4gICAgICBjb25zdCBzY2FsaW5nOiBWZWN0b3IzID0gUmVjeWNsZXIucmV1c2UoVmVjdG9yMykuc2V0KF93aWR0aCwgX3dpZHRoLCBfbGVuZ3RoIC0gX3NpemUpO1xyXG4gICAgICBjb25zdCBtdHhXb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LkNPTVBPU0lUSU9OKF9wb3NpdGlvbik7XHJcbiAgICAgIG10eFdvcmxkLnNjYWxpbmcgPSBzY2FsaW5nO1xyXG4gICAgICBtdHhXb3JsZC5sb29rSW4oX2ZvcndhcmQsIF91cCk7XHJcbiAgICAgIG10eFdvcmxkLnRyYW5zbGF0ZVooMC41KTtcclxuICAgICAgR2l6bW9zLmRyYXdDdWJlKG10eFdvcmxkLCBfY29sb3IsIF9hbHBoYU9jY2x1ZGVkKTtcclxuICAgICAgbXR4V29ybGQudHJhbnNsYXRlWigwLjUpO1xyXG5cclxuICAgICAgaWYgKF9oZWFkID09IE1lc2hQeXJhbWlkKSB7XHJcbiAgICAgICAgY29uc3Qgd2lkdGhIZWFkOiBudW1iZXIgPSBfc2l6ZSAvIDI7XHJcbiAgICAgICAgbXR4V29ybGQuc2NhbGluZyA9IHNjYWxpbmcuc2V0KHdpZHRoSGVhZCwgd2lkdGhIZWFkLCBfc2l6ZSk7XHJcbiAgICAgICAgbXR4V29ybGQucm90YXRlWCg5MCk7IC8vIHJvdGF0ZSB0aGUgcHlyYW1pZCBzbyBpdCBwb2ludHMgaW4gdGhlIHJpZ2h0IGRpcmVjdGlvblxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG10eFdvcmxkLnNjYWxpbmcgPSBzY2FsaW5nLnNldChfc2l6ZSwgX3NpemUsIF9zaXplKTtcclxuICAgICAgICBtdHhXb3JsZC50cmFuc2xhdGVaKDAuNSk7IC8vIHRyYW5zbGF0ZSBjdWJlL3NwaGVyZSBzbyBpdCBzaXRzIG9uIHRvcCBvZiB0aGUgYXJyb3dcclxuICAgICAgfVxyXG5cclxuICAgICAgR2l6bW9zLmRyYXdNZXNoKEdpem1vcy5nZXRNZXNoKF9oZWFkKSwgbXR4V29ybGQsIF9jb2xvciwgX2FscGhhT2NjbHVkZWQpO1xyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmUobXR4V29ybGQpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShzY2FsaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgc29saWQgY3ViZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3Q3ViZShfbXR4V29ybGQ6IE1hdHJpeDR4NCwgX2NvbG9yOiBDb2xvciwgX2FscGhhT2NjbHVkZWQ6IG51bWJlciA9IEdpem1vcy5hbHBoYU9jY2x1ZGVkKTogdm9pZCB7XHJcbiAgICAgIEdpem1vcy5kcmF3TWVzaChHaXptb3MuZ2V0TWVzaChNZXNoQ3ViZSksIF9tdHhXb3JsZCwgX2NvbG9yLCBfYWxwaGFPY2NsdWRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIHNvbGlkIHNwaGVyZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3U3BoZXJlKF9tdHhXb3JsZDogTWF0cml4NHg0LCBfY29sb3I6IENvbG9yLCBfYWxwaGFPY2NsdWRlZDogbnVtYmVyID0gR2l6bW9zLmFscGhhT2NjbHVkZWQpOiB2b2lkIHtcclxuICAgICAgR2l6bW9zLmRyYXdNZXNoKEdpem1vcy5nZXRNZXNoKE1lc2hTcGhlcmUpLCBfbXR4V29ybGQsIF9jb2xvciwgX2FscGhhT2NjbHVkZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYSBzb2xpZCBxdWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXdRdWFkKF9tdHhXb3JsZDogTWF0cml4NHg0LCBfY29sb3I6IENvbG9yLCBfYWxwaGFPY2NsdWRlZDogbnVtYmVyID0gR2l6bW9zLmFscGhhT2NjbHVkZWQpOiB2b2lkIHtcclxuICAgICAgR2l6bW9zLmRyYXdNZXNoKEdpem1vcy5nZXRNZXNoKE1lc2hRdWFkKSwgX210eFdvcmxkLCBfY29sb3IsIF9hbHBoYU9jY2x1ZGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgc29saWQgZG91YmxlIHNpZGVkIHF1YWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhd1Nwcml0ZShfbXR4V29ybGQ6IE1hdHJpeDR4NCwgX2NvbG9yOiBDb2xvciwgX2FscGhhT2NjbHVkZWQ6IG51bWJlciA9IEdpem1vcy5hbHBoYU9jY2x1ZGVkKTogdm9pZCB7XHJcbiAgICAgIEdpem1vcy5kcmF3TWVzaChHaXptb3MuZ2V0TWVzaChNZXNoU3ByaXRlKSwgX210eFdvcmxkLCBfY29sb3IsIF9hbHBoYU9jY2x1ZGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgc29saWQgcHlyYW1pZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkcmF3UHlyYW1pZChfbXR4V29ybGQ6IE1hdHJpeDR4NCwgX2NvbG9yOiBDb2xvciwgX2FscGhhT2NjbHVkZWQ6IG51bWJlciA9IEdpem1vcy5hbHBoYU9jY2x1ZGVkKTogdm9pZCB7XHJcbiAgICAgIEdpem1vcy5kcmF3TWVzaChHaXptb3MuZ2V0TWVzaChNZXNoUHlyYW1pZCksIF9tdHhXb3JsZCwgX2NvbG9yLCBfYWxwaGFPY2NsdWRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIHNvbGlkIG1lc2guXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZHJhd01lc2goX21lc2g6IE1lc2gsIF9tdHhXb3JsZDogTWF0cml4NHg0LCBfY29sb3I6IENvbG9yLCBfYWxwaGFPY2NsdWRlZDogbnVtYmVyID0gR2l6bW9zLmFscGhhT2NjbHVkZWQpOiB2b2lkIHtcclxuICAgICAgY29uc3Qgc2hhZGVyOiBTaGFkZXJJbnRlcmZhY2UgPSBHaXptb3MuI3BpY2tpbmcgPyBTaGFkZXJQaWNrIDogU2hhZGVyR2l6bW87XHJcbiAgICAgIHNoYWRlci51c2VQcm9ncmFtKCk7XHJcbiAgICAgIFxyXG4gICAgICBSZW5kZXJXZWJHTC51c2VOb2RlVW5pZm9ybXMoc2hhZGVyLCBfbXR4V29ybGQsIG51bGwsIG51bGwsIEdpem1vcy5waWNrSWQpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVycyA9IF9tZXNoLnVzZVJlbmRlckJ1ZmZlcnMoKTtcclxuICAgICAgR2l6bW9zLmRyYXdHaXptb3Moc2hhZGVyLCBHaXptb3MuZHJhd0VsZW1lbnRzVHJpYW5sZ2VzLCByZW5kZXJCdWZmZXJzLm5JbmRpY2VzLCBfY29sb3IsIF9hbHBoYU9jY2x1ZGVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGFuIGljb24gZnJvbSBhIHtAbGluayBUZXh0dXJlfSBvbiBhIHtAbGluayBNZXNoUXVhZH0uIFRoZSBpY29uIGlzIGFmZmVjdGVkIGJ5IHRoZSBnaXZlbiB0cmFuc2Zvcm0gYW5kIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXdJY29uKF90ZXh0dXJlOiBUZXh0dXJlLCBfbXR4V29ybGQ6IE1hdHJpeDR4NCwgX2NvbG9yOiBDb2xvciwgX2FscGhhT2NjbHVkZWQ6IG51bWJlciA9IEdpem1vcy5hbHBoYU9jY2x1ZGVkKTogdm9pZCB7XHJcbiAgICAgIGxldCBwb3NpdGlvbjogc3RyaW5nID0gX210eFdvcmxkLnRyYW5zbGF0aW9uLnRvU3RyaW5nKCk7XHJcbiAgICAgIGlmIChHaXptb3MucG9zSWNvbnMuaGFzKHBvc2l0aW9uKSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIEdpem1vcy5wb3NJY29ucy5hZGQocG9zaXRpb24pO1xyXG5cclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuXHJcbiAgICAgIGNvbnN0IHNoYWRlcjogU2hhZGVySW50ZXJmYWNlID0gR2l6bW9zLiNwaWNraW5nID8gU2hhZGVyUGlja1RleHR1cmVkIDogU2hhZGVyR2l6bW9UZXh0dXJlZDtcclxuICAgICAgc2hhZGVyLnVzZVByb2dyYW0oKTtcclxuXHJcbiAgICAgIGxldCBtdHhXb3JsZDogTWF0cml4NHg0ID0gX210eFdvcmxkLmNsb25lO1xyXG4gICAgICBsZXQgY29sb3I6IENvbG9yID0gX2NvbG9yLmNsb25lO1xyXG5cclxuICAgICAgbGV0IGJhY2s6IFZlY3RvcjMgPSBHaXptb3MuI2NhbWVyYS5tdHhXb3JsZC5nZXRGb3J3YXJkKCkubmVnYXRlKCk7XHJcbiAgICAgIGxldCB1cDogVmVjdG9yMyA9IEdpem1vcy4jY2FtZXJhLm10eFdvcmxkLmdldFVwKCk7XHJcbiAgICAgIG10eFdvcmxkLmxvb2tJbihiYWNrLCB1cCk7XHJcblxyXG4gICAgICBsZXQgZGlzdGFuY2U6IG51bWJlciA9IFZlY3RvcjMuRElGRkVSRU5DRShHaXptb3MuI2NhbWVyYS5tdHhXb3JsZC50cmFuc2xhdGlvbiwgbXR4V29ybGQudHJhbnNsYXRpb24pLm1hZ25pdHVkZTtcclxuICAgICAgbGV0IGZhZGVGYXI6IG51bWJlciA9IDQ7XHJcbiAgICAgIGxldCBmYWRlTmVhcjogbnVtYmVyID0gMS41O1xyXG4gICAgICBpZiAoZGlzdGFuY2UgPiAwICYmIGRpc3RhbmNlIDwgZmFkZUZhcikge1xyXG4gICAgICAgIGRpc3RhbmNlID0gKGRpc3RhbmNlIC0gZmFkZU5lYXIpIC8gKGZhZGVGYXIgLSBmYWRlTmVhcik7XHJcbiAgICAgICAgY29sb3IuYSA9IENhbGMubGVycCgwLCBjb2xvci5hLCBkaXN0YW5jZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF90ZXh0dXJlLnVzZVJlbmRlckRhdGEoVEVYVFVSRV9MT0NBVElPTi5DT0xPUi5VTklUKTtcclxuICAgICAgY3JjMy51bmlmb3JtMWkoc2hhZGVyLnVuaWZvcm1zW1RFWFRVUkVfTE9DQVRJT04uQ09MT1IuVU5JRk9STV0sIFRFWFRVUkVfTE9DQVRJT04uQ09MT1IuSU5ERVgpO1xyXG5cclxuICAgICAgUmVuZGVyV2ViR0wudXNlTm9kZVVuaWZvcm1zKHNoYWRlciwgbXR4V29ybGQsIG51bGwsIG51bGwsIEdpem1vcy5waWNrSWQpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVuZGVyQnVmZmVyczogUmVuZGVyQnVmZmVycyA9IEdpem1vcy5nZXRNZXNoKE1lc2hRdWFkKS51c2VSZW5kZXJCdWZmZXJzKCk7XHJcbiAgICAgIEdpem1vcy5kcmF3R2l6bW9zKHNoYWRlciwgR2l6bW9zLmRyYXdFbGVtZW50c1RyaWFubGdlcywgcmVuZGVyQnVmZmVycy5uSW5kaWNlcywgY29sb3IsIF9hbHBoYU9jY2x1ZGVkKTtcclxuXHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFdvcmxkKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoYmFjayk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHVwKTtcclxuICAgICAgUmVjeWNsZXIuc3RvcmUoY29sb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGJ1ZmZlckNvbG9yKF9zaGFkZXI6IFNoYWRlckludGVyZmFjZSwgX2NvbG9yOiBDb2xvcik6IHZvaWQge1xyXG4gICAgICBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCkudW5pZm9ybTRmdihfc2hhZGVyLnVuaWZvcm1zW1widV92Y3RDb2xvclwiXSwgX2NvbG9yLmdldCgpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBidWZmZXJNYXRyaXgoX3NoYWRlcjogU2hhZGVySW50ZXJmYWNlLCBfbXR4V29ybGQ6IE1hdHJpeDR4NCk6IHZvaWQge1xyXG4gICAgICBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCkudW5pZm9ybU1hdHJpeDRmdihfc2hhZGVyLnVuaWZvcm1zW1widV9tdHhNZXNoVG9Xb3JsZFwiXSwgZmFsc2UsIF9tdHhXb3JsZC5nZXRBcnJheSgpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBkcmF3R2l6bW9zKF9zaGFkZXI6IFNoYWRlckludGVyZmFjZSwgX2RyYXc6IEZ1bmN0aW9uLCBfY291bnQ6IG51bWJlciwgX2NvbG9yOiBDb2xvciwgX2FscGhhT2NjbHVkZWQ6IG51bWJlciA9IEdpem1vcy5hbHBoYU9jY2x1ZGVkKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IGNyYzM6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgPSBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCk7XHJcblxyXG4gICAgICBpZiAoX2FscGhhT2NjbHVkZWQgPiAwKSB7XHJcbiAgICAgICAgbGV0IGNvbG9yOiBDb2xvciA9IF9jb2xvci5jbG9uZTtcclxuICAgICAgICBjb2xvci5hICo9IF9hbHBoYU9jY2x1ZGVkO1xyXG5cclxuICAgICAgICAvLyBkcmF3IG9jY2x1ZGVkIHBhcnRzIHdoZXJlIHRoZSBkZXB0aCB0ZXN0IGZhaWxlZCAoYnkgaW52ZXJ0aW5nIHRoZSBkZXB0aCB0ZXN0ICsgbm8gZGVwdGggd3JpdGUpXHJcbiAgICAgICAgY3JjMy5kZXB0aEZ1bmMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5HRVFVQUwpO1xyXG4gICAgICAgIGNyYzMuZGVwdGhNYXNrKGZhbHNlKTtcclxuICAgICAgICBHaXptb3MuYnVmZmVyQ29sb3IoX3NoYWRlciwgY29sb3IpO1xyXG4gICAgICAgIF9kcmF3KF9jb3VudCk7XHJcbiAgICAgICAgY3JjMy5kZXB0aEZ1bmMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5MRVNTKTtcclxuICAgICAgICBjcmMzLmRlcHRoTWFzayh0cnVlKTtcclxuICAgICAgICBSZWN5Y2xlci5zdG9yZShjb2xvcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIEdpem1vcy5idWZmZXJDb2xvcihfc2hhZGVyLCBfY29sb3IpO1xyXG4gICAgICBfZHJhdyhfY291bnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGRyYXdFbGVtZW50c1RyaWFubGdlcyhfY291bnQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBSZW5kZXJXZWJHTC5nZXRSZW5kZXJpbmdDb250ZXh0KCkuZHJhd0VsZW1lbnRzKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLCBfY291bnQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGRyYXdFbGVtZW50c0xpbmVzKF9jb3VudDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKS5kcmF3RWxlbWVudHMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5MSU5FUywgX2NvdW50LCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX1NIT1JULCAwKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBkcmF3QXJyYXlzKF9jb3VudDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgIFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKS5kcmF3QXJyYXlzKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTElORVMsIDAsIF9jb3VudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0TWVzaChfY29uc3RydWN0b3I6IG5ldyAoX25hbWU6IHN0cmluZykgPT4gTWVzaCk6IE1lc2gge1xyXG4gICAgICBsZXQga2V5OiBzdHJpbmcgPSBfY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgbGV0IG1lc2g6IE1lc2ggPSBHaXptb3MuI21lc2hlc1trZXldO1xyXG4gICAgICBpZiAobWVzaClcclxuICAgICAgICByZXR1cm4gbWVzaDtcclxuXHJcbiAgICAgIG1lc2ggPSBuZXcgX2NvbnN0cnVjdG9yKGtleSk7XHJcbiAgICAgIFByb2plY3QuZGVyZWdpc3RlcihtZXNoKTtcclxuICAgICAgR2l6bW9zLiNtZXNoZXNba2V5XSA9IG1lc2g7XHJcbiAgICAgIHJldHVybiBtZXNoO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHBpY2tHaXptb3MoX2dpem1vczogcmVhZG9ubHkgR2l6bW9bXSwgX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogUGlja1tdIHtcclxuICAgICAgY29uc3QgY3JjMzogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCA9IFJlbmRlcldlYkdMLmdldFJlbmRlcmluZ0NvbnRleHQoKTtcclxuICAgICAgY3JjMy51bmlmb3JtTWF0cml4M2Z2KFNoYWRlclBpY2tUZXh0dXJlZC51bmlmb3Jtc1tcInVfbXR4UGl2b3RcIl0sIGZhbHNlLCBNYXRyaXgzeDMuSURFTlRJVFkoKS5nZXRBcnJheSgpKTsgLy8gb25seSBuZWVkZWQgZm9yIHRleHR1cmVkIHBpY2sgc2hhZGVyLCBidXQgZ2l6bW9zIGhhdmUgbm8gcGl2b3RcclxuXHJcbiAgICAgIEdpem1vcy4jY2FtZXJhID0gX2NtcENhbWVyYTtcclxuICAgICAgR2l6bW9zLnBvc0ljb25zLmNsZWFyKCk7XHJcblxyXG4gICAgICBsZXQgcGlja3M6IFBpY2tbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBnaXptbyBvZiBfZ2l6bW9zKSB7XHJcbiAgICAgICAgaWYgKCFnaXptby5kcmF3R2l6bW9zKVxyXG4gICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgIEdpem1vcy5waWNrSWQgPSBwaWNrcy5sZW5ndGg7XHJcbiAgICAgICAgZ2l6bW8uZHJhd0dpem1vcyhfY21wQ2FtZXJhLCBHaXptb3MuI3BpY2tpbmcpO1xyXG4gICAgICAgIGxldCBwaWNrOiBQaWNrID0gbmV3IFBpY2soZ2l6bW8ubm9kZSk7XHJcbiAgICAgICAgcGljay5naXptbyA9IGdpem1vO1xyXG4gICAgICAgIHBpY2tzLnB1c2gocGljayk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIEdpem1vcy5waWNrSWQgPSBudWxsO1xyXG5cclxuICAgICAgcmV0dXJuIHBpY2tzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCB0eXBlIE1hcExpZ2h0VHlwZVRvTGlnaHRMaXN0ID0gTWFwPExJR0hUX1RZUEUsIFJlY3ljYWJsZUFycmF5PENvbXBvbmVudExpZ2h0Pj47XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyUHJlcGFyZU9wdGlvbnMge1xyXG4gICAgaWdub3JlUGh5c2ljcz86IGJvb2xlYW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgbWFpbiBpbnRlcmZhY2UgdG8gdGhlIHJlbmRlciBlbmdpbmUsIGhlcmUgV2ViR0wgKHNlZSBzdXBlcmNsYXNzIHtAbGluayBSZW5kZXJXZWJHTH0gYW5kIHRoZSBSZW5kZXJJbmplY3RvcnNcclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyIGV4dGVuZHMgUmVuZGVyV2ViR0wge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWN0Q2xpcDogUmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZSgtMSwgMSwgMiwgLTIpO1xyXG4gICAgcHVibGljIHN0YXRpYyBwaWNrQnVmZmVyOiBJbnQzMkFycmF5OyAgIC8vIFRPRE86IHJlc2VhcmNoIGlmIHBpY2tpbmcgc2hvdWxkIGJlIG9wdGltaXplZCB1c2luZyByYWRpdXMgcGlja2luZyB0byBmaWx0ZXJcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgbm9kZXNQaHlzaWNzOiBSZWN5Y2FibGVBcnJheTxOb2RlPiA9IG5ldyBSZWN5Y2FibGVBcnJheSgpO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRzUGljazogUmVjeWNhYmxlQXJyYXk8Q29tcG9uZW50UGljaz4gPSBuZXcgUmVjeWNhYmxlQXJyYXkoKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgbGlnaHRzOiBNYXBMaWdodFR5cGVUb0xpZ2h0TGlzdCA9IG5ldyBNYXAoKTtcclxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IG5vZGVzU2ltcGxlOiBSZWN5Y2FibGVBcnJheTxOb2RlPiA9IG5ldyBSZWN5Y2FibGVBcnJheSgpO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgbm9kZXNBbHBoYTogUmVjeWNhYmxlQXJyYXk8Tm9kZT4gPSBuZXcgUmVjeWNhYmxlQXJyYXkoKTtcclxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudHNTa2VsZXRvbjogUmVjeWNhYmxlQXJyYXk8Q29tcG9uZW50U2tlbGV0b24+ID0gbmV3IFJlY3ljYWJsZUFycmF5KCk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyB0aW1lc3RhbXBVcGRhdGU6IG51bWJlcjtcclxuXHJcbiAgICAvLyBjYWNoZSBldmVudHMgdG8gYXZvaWQgZnJlcXVlbnQgcmVjeWNsaW5nXHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgI2V2ZW50UHJlcGFyZTogUmVjeWNsYWJsZUV2ZW50ID0gUmVjeWNsYWJsZUV2ZW50LmdldChFVkVOVC5SRU5ERVJfUFJFUEFSRSk7XHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgI2V2ZW50UHJlcGFyZVN0YXJ0OiBSZWN5Y2xhYmxlRXZlbnQgPSBSZWN5Y2xhYmxlRXZlbnQuZ2V0KEVWRU5ULlJFTkRFUl9QUkVQQVJFX1NUQVJUKTtcclxuICAgIHN0YXRpYyByZWFkb25seSAjZXZlbnRQcmVwYXJlRW5kOiBSZWN5Y2xhYmxlRXZlbnQgPSBSZWN5Y2xhYmxlRXZlbnQuZ2V0KEVWRU5ULlJFTkRFUl9QUkVQQVJFX0VORCk7XHJcblxyXG4gICAgc3RhdGljIHJlYWRvbmx5ICNkZWZhdWx0Um9vdE5vZGU6IE5vZGUgPSBuZXcgTm9kZShcIlJvb3RcIik7XHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgI2RlZmF1bHRPcHRpb25zOiBSZW5kZXJQcmVwYXJlT3B0aW9ucyA9IHt9O1xyXG5cclxuICAgIHN0YXRpYyByZWFkb25seSAjbWFwTm9kZVRvUGFyZW50OiBXZWFrTWFwPE5vZGUsIE5vZGU+ID0gbmV3IFdlYWtNYXA8Tm9kZSwgTm9kZT4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3Vyc2l2ZWx5IGl0ZXJhdGVzIG92ZXIgdGhlIGJyYW5jaCBzdGFydGluZyB3aXRoIHRoZSBub2RlIGdpdmVuLCByZWNhbGN1bGF0ZXMgYWxsIHdvcmxkIHRyYW5zZm9ybXMsIFxyXG4gICAgICogY29sbGVjdHMgYWxsIGxpZ2h0cyBhbmQgZmVlZHMgdGhlIHJlbmRlcmJ1ZmZlcnMgd2l0aCB0aGUgbmVjY2Vzc2FyeSBub2RlIGFuZCBjb21wb25lbnQgZGF0YSB0byBkcmF3IGEgZnJhbWUuIFNvcnRzIG5vZGVzIGZvciBkaWZmZXJlbnRcclxuICAgICAqIHJlbmRlciBwYXNzZXMuXHJcbiAgICAgKiBAcGFyYW0gX3JlY2FsY3VsYXRlIC0gc2V0IHRydWUgdG8gZm9yY2UgcmVjYWxjdWxhdGlvbiBvZiBhbGwgd29ybGQgdHJhbnNmb3JtcyBpbiB0aGUgZ2l2ZW4gYnJhbmNoLCBldmVuIGlmIHRoZWlyIGxvY2FsIHRyYW5zZm9ybXMgaGF2ZW4ndCBjaGFuZ2VkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcHJlcGFyZShfYnJhbmNoOiBOb2RlLCBfb3B0aW9uczogUmVuZGVyUHJlcGFyZU9wdGlvbnMgPSBSZW5kZXIuI2RlZmF1bHRPcHRpb25zLCBfcmVjYWxjdWxhdGU6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG4gICAgICBSZW5kZXIudGltZXN0YW1wVXBkYXRlID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIFJlbmRlci5ub2Rlc1NpbXBsZS5yZXNldCgpO1xyXG4gICAgICBSZW5kZXIubm9kZXNBbHBoYS5yZXNldCgpO1xyXG4gICAgICBSZW5kZXIubm9kZXNQaHlzaWNzLnJlc2V0KCk7XHJcbiAgICAgIFJlbmRlci5jb21wb25lbnRzUGljay5yZXNldCgpO1xyXG4gICAgICBSZW5kZXIuY29tcG9uZW50c1NrZWxldG9uLnJlc2V0KCk7XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGNtcExpZ2h0cyBvZiBSZW5kZXIubGlnaHRzLnZhbHVlcygpKSBcclxuICAgICAgICBjbXBMaWdodHMucmVzZXQoKTtcclxuICAgICAgXHJcbiAgICAgIE5vZGUucmVzZXRSZW5kZXJEYXRhKCk7XHJcbiAgICAgIENvYXQucmVzZXRSZW5kZXJEYXRhKCk7XHJcblxyXG4gICAgICBfYnJhbmNoLmRpc3BhdGNoRXZlbnQoUmVuZGVyLiNldmVudFByZXBhcmVTdGFydCk7XHJcbiAgICAgIHRoaXMucHJlcGFyZUJyYW5jaChfYnJhbmNoLCBfb3B0aW9ucywgX2JyYW5jaC5nZXRQYXJlbnQoKSA/PyBSZW5kZXIuI2RlZmF1bHRSb290Tm9kZSwgX3JlY2FsY3VsYXRlKTtcclxuICAgICAgX2JyYW5jaC5kaXNwYXRjaEV2ZW50KFJlbmRlci4jZXZlbnRQcmVwYXJlRW5kKTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgY21wU2tlbGV0b24gb2YgUmVuZGVyLmNvbXBvbmVudHNTa2VsZXRvbilcclxuICAgICAgICBjbXBTa2VsZXRvbi51cGRhdGVSZW5kZXJCdWZmZXIoKTtcclxuICAgICAgTm9kZS51cGRhdGVSZW5kZXJidWZmZXIoKTtcclxuICAgICAgQ29hdC51cGRhdGVSZW5kZXJidWZmZXIoKTtcclxuICAgICAgQ29tcG9uZW50TGlnaHQudXBkYXRlUmVuZGVyYnVmZmVyKFJlbmRlci5saWdodHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYWRkTGlnaHRzKF9jbXBMaWdodHM6IHJlYWRvbmx5IENvbXBvbmVudExpZ2h0W10pOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgY21wTGlnaHQgb2YgX2NtcExpZ2h0cykge1xyXG4gICAgICAgIGlmICghY21wTGlnaHQuaXNBY3RpdmUpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgbGV0IHR5cGU6IExJR0hUX1RZUEUgPSBjbXBMaWdodC5saWdodFR5cGU7XHJcbiAgICAgICAgbGV0IGxpZ2h0c09mVHlwZTogUmVjeWNhYmxlQXJyYXk8Q29tcG9uZW50TGlnaHQ+ID0gUmVuZGVyLmxpZ2h0cy5nZXQodHlwZSk7XHJcbiAgICAgICAgaWYgKCFsaWdodHNPZlR5cGUpIHtcclxuICAgICAgICAgIGxpZ2h0c09mVHlwZSA9IG5ldyBSZWN5Y2FibGVBcnJheTxDb21wb25lbnRMaWdodD4oKTtcclxuICAgICAgICAgIFJlbmRlci5saWdodHMuc2V0KHR5cGUsIGxpZ2h0c09mVHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpZ2h0c09mVHlwZS5wdXNoKGNtcExpZ2h0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIHNjZW5lIGZyb20gdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhlIGdpdmVuIGNhbWVyYVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGRyYXcoX2NtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhKTogdm9pZCB7XHJcbiAgICAgIGxldCBub2Rlc0FscGhhOiBOb2RlW107XHJcbiAgICAgIGlmIChSZW5kZXIubm9kZXNBbHBoYS5sZW5ndGggPiAwKSB7IC8vIFRPRE86IGF2b2lkIG9iamVjdCBhbmQgZnVuY3Rpb24gY3JlYXRpb24gaW4gbG9vcFxyXG4gICAgICAgIGZvciAobGV0IG5vZGUgb2YgUmVuZGVyLm5vZGVzQWxwaGEpXHJcbiAgICAgICAgICBSZWZsZWN0LnNldChub2RlLCBcInpDYW1lcmFcIiwgX2NtcENhbWVyYS5wb2ludFdvcmxkVG9DbGlwKG5vZGUuZ2V0Q29tcG9uZW50KENvbXBvbmVudE1lc2gpLm10eFdvcmxkLnRyYW5zbGF0aW9uKS56KTtcclxuICBcclxuICAgICAgICBub2Rlc0FscGhhID0gUmVuZGVyLm5vZGVzQWxwaGEuZ2V0U29ydGVkKChfYTogTm9kZSwgX2I6IE5vZGUpID0+IFJlZmxlY3QuZ2V0KF9iLCBcInpDYW1lcmFcIikgLSBSZWZsZWN0LmdldChfYSwgXCJ6Q2FtZXJhXCIpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgUmVuZGVyLmRyYXdOb2RlcyhSZW5kZXIubm9kZXNTaW1wbGUsIG5vZGVzQWxwaGEgPz8gUmVuZGVyLm5vZGVzQWxwaGEsIF9jbXBDYW1lcmEpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHByZXBhcmVCcmFuY2goX2JyYW5jaDogTm9kZSwgX29wdGlvbnM6IFJlbmRlclByZXBhcmVPcHRpb25zLCBfcGFyZW50OiBOb2RlLCBfcmVjYWxjdWxhdGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgaWYgKCFfYnJhbmNoLmlzQWN0aXZlKVxyXG4gICAgICAgIHJldHVybjsgLy8gZG9uJ3QgYWRkIGJyYW5jaCB0byByZW5kZXIgbGlzdCBpZiBub3QgYWN0aXZlXHJcblxyXG4gICAgICBfYnJhbmNoLm5Ob2Rlc0luQnJhbmNoID0gMTtcclxuICAgICAgX2JyYW5jaC5yYWRpdXMgPSAwO1xyXG5cclxuICAgICAgLy8gUGVyZm9ybWFuY2VNb25pdG9yLnN0YXJ0TWVhc3VyZShcIlJlbmRlci5wcmVwYXJlQnJhbmNoIGRpc3BhdGNoIHByZXBhcmVcIik7XHJcbiAgICAgIF9icmFuY2guZGlzcGF0Y2hFdmVudFRvVGFyZ2V0T25seShSZW5kZXIuI2V2ZW50UHJlcGFyZSk7XHJcbiAgICAgIC8vIFBlcmZvcm1hbmNlTW9uaXRvci5lbmRNZWFzdXJlKFwiUmVuZGVyLnByZXBhcmVCcmFuY2ggZGlzcGF0Y2ggcHJlcGFyZVwiKTtcclxuXHJcbiAgICAgIF9icmFuY2gudGltZXN0YW1wVXBkYXRlID0gUmVuZGVyLnRpbWVzdGFtcFVwZGF0ZTtcclxuXHJcbiAgICAgIGNvbnN0IG10eFdvcmxkUGFyZW50OiBNYXRyaXg0eDQgPSBfcGFyZW50Lm10eFdvcmxkO1xyXG4gICAgICBjb25zdCBtdHhXb3JsZEJyYW5jaDogTWF0cml4NHg0ID0gX2JyYW5jaC5tdHhXb3JsZDtcclxuXHJcbiAgICAgIGxldCBwcmV2aW91c1BhcmVudDogTm9kZSA9IFJlbmRlci4jbWFwTm9kZVRvUGFyZW50LmdldChfYnJhbmNoKTtcclxuICAgICAgaWYgKF9wYXJlbnQgIT0gcHJldmlvdXNQYXJlbnQpIHtcclxuICAgICAgICBSZW5kZXIuI21hcE5vZGVUb1BhcmVudC5zZXQoX2JyYW5jaCwgX3BhcmVudCk7XHJcbiAgICAgICAgX3JlY2FsY3VsYXRlID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUGVyZm9ybWFuY2VNb25pdG9yLnN0YXJ0TWVhc3VyZShcIlJlbmRlci5wcmVwYXJlQnJhbmNoIGNtcFRyYW5zZm9ybVwiKTtcclxuICAgICAgY29uc3QgY21wVHJhbnNmb3JtOiBDb21wb25lbnRUcmFuc2Zvcm0gPSBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRUcmFuc2Zvcm0pO1xyXG4gICAgICBpZiAoY21wVHJhbnNmb3JtPy5pc0FjdGl2ZSkge1xyXG4gICAgICAgIGlmICgoX3JlY2FsY3VsYXRlIHx8PSBjbXBUcmFuc2Zvcm0ubXR4TG9jYWwubW9kaWZpZWQpKSB7XHJcbiAgICAgICAgICBNYXRyaXg0eDQuUFJPRFVDVChtdHhXb3JsZFBhcmVudCwgY21wVHJhbnNmb3JtLm10eExvY2FsLCBtdHhXb3JsZEJyYW5jaCk7XHJcbiAgICAgICAgICBjbXBUcmFuc2Zvcm0ubXR4TG9jYWwubW9kaWZpZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZVxyXG4gICAgICAgIG10eFdvcmxkQnJhbmNoLmNvcHkobXR4V29ybGRQYXJlbnQpOyAvLyBvdmVyd3JpdGUgcmVhZG9ubHkgbXR4V29ybGQgb2YgdGhlIGN1cnJlbnQgbm9kZVxyXG4gICAgICAvLyBQZXJmb3JtYW5jZU1vbml0b3IuZW5kTWVhc3VyZShcIlJlbmRlci5wcmVwYXJlQnJhbmNoIGNtcFRyYW5zZm9ybVwiKTtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE1lYXN1cmUoXCJSZW5kZXIucHJlcGFyZUJyYW5jaCBjbXBSaWdpZGJvZHlcIik7XHJcbiAgICAgIGNvbnN0IGNtcFJpZ2lkYm9keTogQ29tcG9uZW50UmlnaWRib2R5ID0gX2JyYW5jaC5nZXRDb21wb25lbnQoQ29tcG9uZW50UmlnaWRib2R5KTtcclxuICAgICAgaWYgKGNtcFJpZ2lkYm9keT8uaXNBY3RpdmUpIHsgLy9UT0RPOiBzdXBwb3J0IGRlLS9hY3RpdmF0aW9uIHRocm91Z2hvdXRcclxuICAgICAgICBSZW5kZXIubm9kZXNQaHlzaWNzLnB1c2goX2JyYW5jaCk7IC8vIGFkZCB0aGlzIG5vZGUgdG8gcGh5c2ljcyBsaXN0XHJcbiAgICAgICAgaWYgKCFfb3B0aW9ucz8uaWdub3JlUGh5c2ljcylcclxuICAgICAgICAgIHRoaXMudHJhbnNmb3JtQnlQaHlzaWNzKF9icmFuY2gsIGNtcFJpZ2lkYm9keSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gUGVyZm9ybWFuY2VNb25pdG9yLmVuZE1lYXN1cmUoXCJSZW5kZXIucHJlcGFyZUJyYW5jaCBjbXBSaWdpZGJvZHlcIik7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNZWFzdXJlKFwiUmVuZGVyLnByZXBhcmVCcmFuY2ggY21wUGlja1wiKTtcclxuICAgICAgY29uc3QgY21wUGljazogQ29tcG9uZW50UGljayA9IF9icmFuY2guZ2V0Q29tcG9uZW50KENvbXBvbmVudFBpY2spO1xyXG4gICAgICBpZiAoY21wUGljaz8uaXNBY3RpdmUpIHtcclxuICAgICAgICBSZW5kZXIuY29tcG9uZW50c1BpY2sucHVzaChjbXBQaWNrKTsgLy8gYWRkIHRoaXMgY29tcG9uZW50IHRvIHBpY2sgbGlzdFxyXG4gICAgICB9XHJcbiAgICAgIC8vIFBlcmZvcm1hbmNlTW9uaXRvci5lbmRNZWFzdXJlKFwiUmVuZGVyLnByZXBhcmVCcmFuY2ggY21wUGlja1wiKTtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE1lYXN1cmUoXCJSZW5kZXIucHJlcGFyZUJyYW5jaCBjbXBMaWdodFwiKTtcclxuICAgICAgY29uc3QgY21wTGlnaHRzOiByZWFkb25seSBDb21wb25lbnRMaWdodFtdID0gX2JyYW5jaC5nZXRDb21wb25lbnRzKENvbXBvbmVudExpZ2h0KTtcclxuICAgICAgUmVuZGVyLmFkZExpZ2h0cyhjbXBMaWdodHMpO1xyXG4gICAgICAvLyBQZXJmb3JtYW5jZU1vbml0b3IuZW5kTWVhc3VyZShcIlJlbmRlci5wcmVwYXJlQnJhbmNoIGNtcExpZ2h0XCIpO1xyXG5cclxuICAgICAgLy8gUGVyZm9ybWFuY2VNb25pdG9yLnN0YXJ0TWVhc3VyZShcIlJlbmRlci5wcmVwYXJlQnJhbmNoIGNtcE1lc2ggY21wTWF0ZXJpYWxcIik7XHJcbiAgICAgIGNvbnN0IGNtcE1lc2g6IENvbXBvbmVudE1lc2ggPSBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKTtcclxuICAgICAgY29uc3QgY21wTWF0ZXJpYWw6IENvbXBvbmVudE1hdGVyaWFsID0gX2JyYW5jaC5nZXRDb21wb25lbnQoQ29tcG9uZW50TWF0ZXJpYWwpO1xyXG4gICAgICBpZiAoY21wTWVzaD8uaXNBY3RpdmUgJiYgY21wTWF0ZXJpYWw/LmlzQWN0aXZlKSB7XHJcbiAgICAgICAgaWYgKGNtcE1lc2gubXR4UGl2b3QubW9kaWZpZWQgfHwgX3JlY2FsY3VsYXRlKSB7XHJcbiAgICAgICAgICBNYXRyaXg0eDQuUFJPRFVDVChtdHhXb3JsZEJyYW5jaCwgY21wTWVzaC5tdHhQaXZvdCwgY21wTWVzaC5tdHhXb3JsZCk7XHJcbiAgICAgICAgICBjbXBNZXNoLm10eFBpdm90Lm1vZGlmaWVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY21wRmFjZUNhbWVyYTogQ29tcG9uZW50RmFjZUNhbWVyYSA9IF9icmFuY2guZ2V0Q29tcG9uZW50KENvbXBvbmVudEZhY2VDYW1lcmEpO1xyXG4gICAgICAgIGxldCBjbXBQYXJ0aWNsZVN5c3RlbTogQ29tcG9uZW50UGFydGljbGVTeXN0ZW0gPSBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRQYXJ0aWNsZVN5c3RlbSk7XHJcbiAgICAgICAgX2JyYW5jaC51cGRhdGVSZW5kZXJEYXRhKGNtcE1lc2gsIGNtcE1hdGVyaWFsLCBjbXBGYWNlQ2FtZXJhLCBjbXBQYXJ0aWNsZVN5c3RlbSk7XHJcblxyXG4gICAgICAgIF9icmFuY2gucmFkaXVzID0gY21wTWVzaC5yYWRpdXM7XHJcbiAgICAgICAgaWYgKGNtcE1hdGVyaWFsLnNvcnRGb3JBbHBoYSB8fCBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRUZXh0KSkgLy8gYWx3YXlzIHNvcnQgdGV4dCBmb3IgYWxwaGFcclxuICAgICAgICAgIFJlbmRlci5ub2Rlc0FscGhhLnB1c2goX2JyYW5jaCk7IC8vIGFkZCB0aGlzIG5vZGUgdG8gcmVuZGVyIGxpc3RcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBSZW5kZXIubm9kZXNTaW1wbGUucHVzaChfYnJhbmNoKTsgLy8gYWRkIHRoaXMgbm9kZSB0byByZW5kZXIgbGlzdFxyXG5cclxuICAgICAgICBsZXQgbWF0ZXJpYWw6IE1hdGVyaWFsID0gY21wTWF0ZXJpYWwubWF0ZXJpYWw7XHJcbiAgICAgICAgaWYgKG1hdGVyaWFsPy50aW1lc3RhbXBVcGRhdGUgPCBSZW5kZXIudGltZXN0YW1wVXBkYXRlKSB7XHJcbiAgICAgICAgICBtYXRlcmlhbC50aW1lc3RhbXBVcGRhdGUgPSBSZW5kZXIudGltZXN0YW1wVXBkYXRlO1xyXG4gICAgICAgICAgbWF0ZXJpYWwuY29hdC51cGRhdGVSZW5kZXJEYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIFBlcmZvcm1hbmNlTW9uaXRvci5lbmRNZWFzdXJlKFwiUmVuZGVyLnByZXBhcmVCcmFuY2ggY21wTWVzaCBjbXBNYXRlcmlhbFwiKTtcclxuXHJcbiAgICAgIGNvbnN0IGNtcENhbWVyYTogQ29tcG9uZW50Q2FtZXJhID0gX2JyYW5jaC5nZXRDb21wb25lbnQoQ29tcG9uZW50Q2FtZXJhKSA/PyBfYnJhbmNoLmdldENvbXBvbmVudChDb21wb25lbnRWUkRldmljZSk7IC8vIGNoZWNraW5nIGZvciBib3RoIG9mIHRoZXNlIGlzIHJhdGhlciBzbG93LCBtYXliZSBvbmx5IHVwZGF0ZSB1c2VkIGNhbWVyYXMgYWZ0ZXIgYWxsP1xyXG4gICAgICBpZiAoY21wQ2FtZXJhICYmIGNtcENhbWVyYS5pc0FjdGl2ZSAmJiAoY21wQ2FtZXJhLm10eFBpdm90Lm1vZGlmaWVkIHx8IF9yZWNhbGN1bGF0ZSkpIHtcclxuICAgICAgICBNYXRyaXg0eDQuUFJPRFVDVChtdHhXb3JsZEJyYW5jaCwgY21wQ2FtZXJhLm10eFBpdm90LCBjbXBDYW1lcmEubXR4V29ybGQpO1xyXG4gICAgICAgIGNtcENhbWVyYS5tdHhQaXZvdC5tb2RpZmllZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNZWFzdXJlKFwiUmVuZGVyLnByZXBhcmVCcmFuY2ggY21wU2tlbGV0b25cIik7XHJcbiAgICAgIGNvbnN0IGNtcFNrZWxldG9uczogcmVhZG9ubHkgQ29tcG9uZW50U2tlbGV0b25bXSA9IF9icmFuY2guZ2V0Q29tcG9uZW50cyhDb21wb25lbnRTa2VsZXRvbik7XHJcbiAgICAgIGZvciAobGV0IGNtcFNrZWxldG9uIG9mIGNtcFNrZWxldG9ucylcclxuICAgICAgICBpZiAoY21wU2tlbGV0b24/LmlzQWN0aXZlKVxyXG4gICAgICAgICAgUmVuZGVyLmNvbXBvbmVudHNTa2VsZXRvbi5wdXNoKGNtcFNrZWxldG9uKTtcclxuICAgICAgLy8gUGVyZm9ybWFuY2VNb25pdG9yLmVuZE1lYXN1cmUoXCJSZW5kZXIucHJlcGFyZUJyYW5jaCBjbXBTa2VsZXRvblwiKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGNoaWxkIG9mIF9icmFuY2guZ2V0Q2hpbGRyZW4oKSkge1xyXG4gICAgICAgIFJlbmRlci5wcmVwYXJlQnJhbmNoKGNoaWxkLCBfb3B0aW9ucywgX2JyYW5jaCwgX3JlY2FsY3VsYXRlKTtcclxuXHJcbiAgICAgICAgX2JyYW5jaC5uTm9kZXNJbkJyYW5jaCArPSBjaGlsZC5uTm9kZXNJbkJyYW5jaDtcclxuICAgICAgICBfYnJhbmNoLnJhZGl1cyA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgX2JyYW5jaC5yYWRpdXMsIFxyXG4gICAgICAgICAgKGNoaWxkLmdldENvbXBvbmVudChDb21wb25lbnRNZXNoKT8ubXR4V29ybGQudHJhbnNsYXRpb24gPz8gY2hpbGQubXR4V29ybGQudHJhbnNsYXRpb24pLmdldERpc3RhbmNlKG10eFdvcmxkQnJhbmNoLnRyYW5zbGF0aW9uKSArIGNoaWxkLnJhZGl1c1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyB0cmFuc2Zvcm1CeVBoeXNpY3MoX25vZGU6IE5vZGUsIF9jbXBSaWdpZGJvZHk6IENvbXBvbmVudFJpZ2lkYm9keSk6IHZvaWQge1xyXG4gICAgICBpZiAoIV9jbXBSaWdpZGJvZHkuaXNJbml0aWFsaXplZCkgLy8gfHwgUHJvamVjdC5tb2RlID09IE1PREUuRURJVE9SKVxyXG4gICAgICAgIF9jbXBSaWdpZGJvZHkuaW5pdGlhbGl6ZSgpO1xyXG5cclxuICAgICAgaWYgKCFQaHlzaWNzLmdldEJvZHlMaXN0KCkubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGlmICghX25vZGUubXR4TG9jYWwpIHtcclxuICAgICAgICB0aHJvdyAobmV3IEVycm9yKFwiQ29tcG9uZW50UmlnaWRib2R5IHJlcXVpcmVzIENvbXBvbmVudFRyYW5zZm9ybSBhdCB0aGUgc2FtZSBOb2RlXCIpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gX2NtcFJpZ2lkYm9keS5jaGVja0NvbGxpc2lvbkV2ZW50cygpO1xyXG5cclxuICAgICAgaWYgKF9jbXBSaWdpZGJvZHkudHlwZUJvZHkgPT0gQk9EWV9UWVBFLktJTkVNQVRJQyB8fCBQcm9qZWN0Lm1vZGUgPT0gTU9ERS5FRElUT1IpIHsgLy9DYXNlIG9mIEtpbmVtYXRpYyBSaWdpZGJvZHlcclxuICAgICAgICBsZXQgbXR4UGl2b3RXb3JsZDogTWF0cml4NHg0ID0gTWF0cml4NHg0LlBST0RVQ1QoX25vZGUubXR4V29ybGQsIF9jbXBSaWdpZGJvZHkubXR4UGl2b3RVbnNjYWxlZCk7XHJcbiAgICAgICAgX2NtcFJpZ2lkYm9keS5zZXRQb3NpdGlvbihtdHhQaXZvdFdvcmxkLnRyYW5zbGF0aW9uKTtcclxuICAgICAgICBfY21wUmlnaWRib2R5LnNldFJvdGF0aW9uKG10eFBpdm90V29ybGQucm90YXRpb24pO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKG10eFBpdm90V29ybGQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IG10eFdvcmxkOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuQ09NUE9TSVRJT04oX2NtcFJpZ2lkYm9keS5nZXRQb3NpdGlvbigpLCBfY21wUmlnaWRib2R5LmdldFJvdGF0aW9uKCkpO1xyXG4gICAgICBtdHhXb3JsZC5tdWx0aXBseShfY21wUmlnaWRib2R5Lm10eFBpdm90SW52ZXJzZSk7XHJcbiAgICAgIF9ub2RlLm10eFdvcmxkLnRyYW5zbGF0aW9uID0gbXR4V29ybGQudHJhbnNsYXRpb247XHJcbiAgICAgIF9ub2RlLm10eFdvcmxkLnJvdGF0aW9uID0gbXR4V29ybGQucm90YXRpb247XHJcbiAgICAgIGxldCBwYXJlbnQ6IE5vZGUgPSBfbm9kZS5nZXRQYXJlbnQoKTtcclxuICAgICAgbGV0IG10eExvY2FsOiBNYXRyaXg0eDQgPSBwYXJlbnQgP1xyXG4gICAgICAgIE1hdHJpeDR4NC5SRUxBVElWRShfbm9kZS5tdHhXb3JsZCwgcGFyZW50Lm10eFdvcmxkLCBwYXJlbnQubXR4V29ybGRJbnZlcnNlKSA6XHJcbiAgICAgICAgX25vZGUubXR4V29ybGQuY2xvbmU7XHJcbiAgICAgIF9ub2RlLm10eExvY2FsLmNvcHkobXR4TG9jYWwpO1xyXG4gICAgICBSZWN5Y2xlci5zdG9yZShtdHhXb3JsZCk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKG10eExvY2FsKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyQnVmZmVycyB7XHJcbiAgICB2YW8/OiBXZWJHTFZlcnRleEFycmF5T2JqZWN0O1xyXG4gICAgaW5kaWNlcz86IFdlYkdMQnVmZmVyO1xyXG4gICAgcG9zaXRpb25zPzogV2ViR0xCdWZmZXI7XHJcbiAgICBub3JtYWxzPzogV2ViR0xCdWZmZXI7XHJcbiAgICB0ZXh0dXJlVVZzPzogV2ViR0xCdWZmZXI7XHJcbiAgICBjb2xvcnM/OiBXZWJHTEJ1ZmZlcjtcclxuICAgIHRhbmdlbnRzPzogV2ViR0xCdWZmZXI7XHJcbiAgICBib25lcz86IFdlYkdMQnVmZmVyO1xyXG4gICAgd2VpZ2h0cz86IFdlYkdMQnVmZmVyO1xyXG4gICAgbkluZGljZXM/OiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnNlcnRlZCBpbnRvIGEge0BsaW5rIE1lc2h9LCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGNhbGN1bGF0ZXMgYW5kIHJlcHJlc2VudHMgdGhlIG1lc2ggZGF0YSBpbiB0aGUgZm9ybSBuZWVkZWQgYnkgdGhlIHJlbmRlciBlbmdpbmVcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgUmVuZGVyTWVzaCB7XHJcbiAgICBwdWJsaWMgYnVmZmVyczogUmVuZGVyQnVmZmVycztcclxuICAgIHB1YmxpYyBtZXNoOiBNZXNoO1xyXG5cclxuICAgIC8qKiBpbmRpY2VzIHRvIGNyZWF0ZSBmYWNlcyBmcm9tIHRoZSB2ZXJ0aWNlcywgcm90YXRpb24gZGV0ZXJtaW5lcyBkaXJlY3Rpb24gb2YgZmFjZS1ub3JtYWwgKi9cclxuICAgICNpbmRpY2VzOiBVaW50MTZBcnJheTtcclxuICAgIC8qKiB2ZXJ0aWNlcyBvZiB0aGUgYWN0dWFsIHBvaW50IGNsb3VkLCBzb21lIHBvaW50cyBtaWdodCBiZSBpbiB0aGUgc2FtZSBsb2NhdGlvbiBpbiBvcmRlciB0byByZWZlciB0byBkaWZmZXJlbnQgdGV4ZWxzICovXHJcbiAgICAjcG9zaXRpb25zOiBGbG9hdDMyQXJyYXk7XHJcbiAgICAvKiogdmVydGV4IG5vcm1hbHMgZm9yIHNtb290aCBzaGFkaW5nLCBpbnRlcnBvbGF0ZWQgYmV0d2VlbiB2ZXJ0aWNlcyBkdXJpbmcgcmVuZGVyaW5nICovXHJcbiAgICAjbm9ybWFsczogRmxvYXQzMkFycmF5O1xyXG4gICAgLyoqIHRleHR1cmUgY29vcmRpbmF0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSB2ZXJ0aWNlcyBieSB0aGUgcG9zaXRpb24gaW4gdGhlIGFycmF5ICovXHJcbiAgICAjdGV4dHVyZVVWczogRmxvYXQzMkFycmF5O1xyXG4gICAgLyogY29sb3JzICovXHJcbiAgICAjY29sb3JzOiBGbG9hdDMyQXJyYXk7XHJcbiAgICAvKiogdmVydGV4IHRhbmdlbnRzIGZvciBub3JtYWwgbWFwcGluZywgYmFzZWQgb24gdGhlIHZlcnRleCBub3JtYWxzIGFuZCB0aGUgVVYgY29vcmRpbmF0ZXMgKi9cclxuICAgICN0YW5nZW50czogRmxvYXQzMkFycmF5O1xyXG4gICAgXHJcbiAgICAjYm9uZXM6IFVpbnQ4QXJyYXk7XHJcbiAgICAjd2VpZ2h0czogRmxvYXQzMkFycmF5O1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbWVzaDogTWVzaCkge1xyXG4gICAgICB0aGlzLm1lc2ggPSBfbWVzaDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHBvc2l0aW9ucygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcG9zaXRpb25zIHx8ICggLy8gcmV0dXJuIGNhY2hlIG9yIC4uLlxyXG4gICAgICAgIC8vIC4uLiBmbGF0dGVuIGFsbCB2ZXJ0ZXggcG9zaXRpb25zIGZyb20gY2xvdWQgaW50byBhIHR5cGVkIGFycmF5XHJcbiAgICAgICAgdGhpcy4jcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1lc2gudmVydGljZXMuZmxhdE1hcCgoX3ZlcnRleDogVmVydGV4LCBfaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIFsuLi50aGlzLm1lc2gudmVydGljZXMucG9zaXRpb24oX2luZGV4KS5nZXQoKV07XHJcbiAgICAgICAgfSkpKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgcG9zaXRpb25zKF92ZXJ0aWNlczogRmxvYXQzMkFycmF5KSB7XHJcbiAgICAgIHRoaXMuI3Bvc2l0aW9ucyA9IF92ZXJ0aWNlcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGluZGljZXMoKTogVWludDE2QXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy4jaW5kaWNlcyB8fCAoIC8vIHJldHVybiBjYWNoZSBvciAuLi5cclxuICAgICAgICAvLyAuLi4gZmxhdHRlbiBhbGwgaW5kaWNlcyBmcm9tIHRoZSBmYWNlcyBpbnRvIGEgdHlwZWQgYXJyYXlcclxuICAgICAgICB0aGlzLiNpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KHRoaXMubWVzaC5mYWNlcy5mbGF0TWFwKChfZmFjZTogRmFjZSkgPT4gX2ZhY2UuaW5kaWNlcylcclxuICAgICAgICApKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgaW5kaWNlcyhfaW5kaWNlczogVWludDE2QXJyYXkpIHtcclxuICAgICAgdGhpcy4jaW5kaWNlcyA9IF9pbmRpY2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgbm9ybWFscygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICBpZiAodGhpcy4jbm9ybWFscyA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBhIGNoZWNrIHNpbWlsaWFyIHRvIHRoZSBvbmUgZm9yIHRhbmdlbnRzIGJlbG93LCB0byBzZWUgaWYgbm9ybWFscyBhcmUgYWxyZWFkeSBwcmVzZW50IGluIHRoZSB2ZXJ0aWNlc1xyXG5cclxuICAgICAgICAvLyBzdW0gdXAgYWxsIHVuc2NhbGVkIG5vcm1hbHMgb2YgZmFjZXMgY29ubmVjdGVkIHRvIG9uZSB2ZXJ0ZXgsIHdlaWdodGVkIGJ5IHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSB0d28gbmVpZ2hib3VyIHZlcnRpY2VzLi4uXHJcbiAgICAgICAgdGhpcy5tZXNoLnZlcnRpY2VzLmZvckVhY2goX3ZlcnRleCA9PiBfdmVydGV4Lm5vcm1hbC5zZXQoMCwgMCwgMCkpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBmYWNlIG9mIHRoaXMubWVzaC5mYWNlcylcclxuICAgICAgICAgIGZhY2UuaW5kaWNlcy5mb3JFYWNoKChfaVZlcnRleCwgX2lGYWNlVmVydGV4KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubWVzaC52ZXJ0aWNlcy5ub3JtYWwoX2lWZXJ0ZXgpLmFkZChWZWN0b3IzLlNDQUxFKGZhY2Uubm9ybWFsVW5zY2FsZWQsIGZhY2UuYW5nbGVzW19pRmFjZVZlcnRleF0pKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIC8vIC4uLiBhbmQgbm9ybWFsaXplIHRoZW1cclxuICAgICAgICB0aGlzLm1lc2gudmVydGljZXMuZm9yRWFjaChfdmVydGV4ID0+IHtcclxuICAgICAgICAgIC8vIHNvbWUgdmVydGljZXMgbWlnaHQgYmUgdW51c2VkIGFuZCB5aWVsZCBhIHplcm8tbm9ybWFsLi4uXHJcbiAgICAgICAgICBpZiAoX3ZlcnRleC5ub3JtYWwubWFnbml0dWRlU3F1YXJlZCA+IDApXHJcbiAgICAgICAgICAgIF92ZXJ0ZXgubm9ybWFsLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyB0aGlzLsaSbm9ybWFsc1ZlcnRleCA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFsc1ZlcnRleC5mbGF0TWFwKChfbm9ybWFsOiBWZWN0b3IzKSA9PiBbLi4uX25vcm1hbC5nZXQoKV0pKTtcclxuXHJcbiAgICAgICAgdGhpcy4jbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoXHJcbiAgICAgICAgICB0aGlzLm1lc2gudmVydGljZXMuZmxhdE1hcCgoX3ZlcnRleCwgX2luZGV4KSA9PiBbLi4udGhpcy5tZXNoLnZlcnRpY2VzLm5vcm1hbChfaW5kZXgpLmdldCgpXSlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy4jbm9ybWFscztcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbm9ybWFscyhfbm9ybWFsczogRmxvYXQzMkFycmF5KSB7XHJcbiAgICAgIHRoaXMuI25vcm1hbHMgPSBfbm9ybWFscztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHRhbmdlbnRzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIGlmICh0aGlzLiN0YW5nZW50cyA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm1lc2gudmVydGljZXMuc29tZShfdmVydGV4ID0+ICFfdmVydGV4LnV2KSkgeyAvLyBhc3N1bWUgYWxsIHZlcnRpY2VzIGhhdmUgdGV4dHVyZSBjb29yZGluYXRlcyBvciBub25lXHJcbiAgICAgICAgICB0aGlzLiN0YW5nZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoKTsgLy8gbm8gdGV4dHVyZSBjb29yZGluYXRlcywgbm8gdGFuZ2VudHNcclxuICAgICAgICAgIHJldHVybiB0aGlzLiN0YW5nZW50cztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm1lc2gudmVydGljZXMuc29tZShfdmVydGV4ID0+ICFfdmVydGV4LnRhbmdlbnQpKSB7IC8vIGFzc3VtZSBhbGwgdmVydGljZXMgaGF2ZSB0YW5nZW50cyBvciBub25lXHJcbiAgICAgICAgICBjb25zdCB0YW5nZW50czogVmVjdG9yM1tdID0gbmV3IEFycmF5KHRoaXMubWVzaC52ZXJ0aWNlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgY29uc3QgYml0YW5nZW50czogVmVjdG9yM1tdID0gbmV3IEFycmF5KHRoaXMubWVzaC52ZXJ0aWNlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRhbmdlbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRhbmdlbnRzW2ldID0gVmVjdG9yMy5aRVJPKCk7XHJcbiAgICAgICAgICAgIGJpdGFuZ2VudHNbaV0gPSBWZWN0b3IzLlpFUk8oKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyB0aGlzLm1lc2gudmVydGljZXMuZm9yRWFjaChfdmVydGV4ID0+IF92ZXJ0ZXgudGFuZ2VudC5zZXQoMCwgMCwgMCkpO1xyXG5cclxuICAgICAgICAgIGZvciAobGV0IGZhY2Ugb2YgdGhpcy5tZXNoLmZhY2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBpMDogbnVtYmVyID0gZmFjZS5pbmRpY2VzWzBdO1xyXG4gICAgICAgICAgICBsZXQgaTE6IG51bWJlciA9IGZhY2UuaW5kaWNlc1sxXTtcclxuICAgICAgICAgICAgbGV0IGkyOiBudW1iZXIgPSBmYWNlLmluZGljZXNbMl07XHJcblxyXG4gICAgICAgICAgICAvL3ZlcnRpY2VzIHN1cnJvdW5kaW5nIG9uZSB0cmlhbmdsZVxyXG4gICAgICAgICAgICBsZXQgdjA6IFZlY3RvcjMgPSB0aGlzLm1lc2gudmVydGljZXMucG9zaXRpb24oaTApO1xyXG4gICAgICAgICAgICBsZXQgdjE6IFZlY3RvcjMgPSB0aGlzLm1lc2gudmVydGljZXMucG9zaXRpb24oaTEpO1xyXG4gICAgICAgICAgICBsZXQgdjI6IFZlY3RvcjMgPSB0aGlzLm1lc2gudmVydGljZXMucG9zaXRpb24oaTIpO1xyXG5cclxuICAgICAgICAgICAgLy90aGVpciBVVnNcclxuICAgICAgICAgICAgbGV0IHV2MDogVmVjdG9yMiA9IHRoaXMubWVzaC52ZXJ0aWNlcy51dihpMCk7XHJcbiAgICAgICAgICAgIGxldCB1djE6IFZlY3RvcjIgPSB0aGlzLm1lc2gudmVydGljZXMudXYoaTEpO1xyXG4gICAgICAgICAgICBsZXQgdXYyOiBWZWN0b3IyID0gdGhpcy5tZXNoLnZlcnRpY2VzLnV2KGkyKTtcclxuXHJcbiAgICAgICAgICAgIC8vV2UgY29tcHV0ZSB0aGUgZWRnZXMgb2YgdGhlIHRyaWFuZ2xlLi4uXHJcbiAgICAgICAgICAgIGxldCBkZWx0YVBvczA6IFZlY3RvcjMgPSBWZWN0b3IzLkRJRkZFUkVOQ0UodjEsIHYwKTtcclxuICAgICAgICAgICAgbGV0IGRlbHRhUG9zMTogVmVjdG9yMyA9IFZlY3RvcjMuRElGRkVSRU5DRSh2MiwgdjApO1xyXG5cclxuICAgICAgICAgICAgLy8uLi5hbmQgdGhlIGVkZ2VzIG9mIHRoZSB0cmlhbmdsZXMgaW4gVVYgc3BhY2UuLi5cclxuICAgICAgICAgICAgbGV0IGRlbHRhVVYwOiBWZWN0b3IyID0gVmVjdG9yMi5ESUZGRVJFTkNFKHV2MSwgdXYwKTtcclxuICAgICAgICAgICAgbGV0IGRlbHRhVVYxOiBWZWN0b3IyID0gVmVjdG9yMi5ESUZGRVJFTkNFKHV2MiwgdXYwKTtcclxuXHJcbiAgICAgICAgICAgIC8vLi4uYW5kIGNvbXB1dGUgdGhlIHRhbmdlbnRcclxuICAgICAgICAgICAgbGV0IHI6IG51bWJlciA9IDEgLyBWZWN0b3IyLkNST1NTKGRlbHRhVVYwLCBkZWx0YVVWMSk7XHJcbiAgICAgICAgICAgIGxldCBmYWNlVGFuZ2VudDogVmVjdG9yMyA9IFZlY3RvcjMuU0NBTEUoVmVjdG9yMy5ESUZGRVJFTkNFKFZlY3RvcjMuU0NBTEUoZGVsdGFQb3MwLCBkZWx0YVVWMS55KSwgVmVjdG9yMy5TQ0FMRShkZWx0YVBvczEsIGRlbHRhVVYwLnkpKSwgcik7XHJcbiAgICAgICAgICAgIGxldCBmYWNlQml0YW5nZW50OiBWZWN0b3IzID0gVmVjdG9yMy5TQ0FMRShWZWN0b3IzLkRJRkZFUkVOQ0UoVmVjdG9yMy5TQ0FMRShkZWx0YVBvczEsIC1kZWx0YVVWMC54KSwgVmVjdG9yMy5TQ0FMRShkZWx0YVBvczAsIC1kZWx0YVVWMS54KSksIHIpOyAvLyBmb3Igd2luZGluZyBvcmRlciBjb3VudGVyIGNsb2Nrd2lzZVxyXG5cclxuICAgICAgICAgICAgdGFuZ2VudHNbaTBdLmFkZChWZWN0b3IzLlNDQUxFKGZhY2VUYW5nZW50LCBmYWNlLmFuZ2xlc1swXSkpO1xyXG4gICAgICAgICAgICB0YW5nZW50c1tpMV0uYWRkKFZlY3RvcjMuU0NBTEUoZmFjZVRhbmdlbnQsIGZhY2UuYW5nbGVzWzFdKSk7XHJcbiAgICAgICAgICAgIHRhbmdlbnRzW2kyXS5hZGQoVmVjdG9yMy5TQ0FMRShmYWNlVGFuZ2VudCwgZmFjZS5hbmdsZXNbMl0pKTtcclxuXHJcbiAgICAgICAgICAgIGJpdGFuZ2VudHNbaTBdLmFkZChWZWN0b3IzLlNDQUxFKGZhY2VCaXRhbmdlbnQsIGZhY2UuYW5nbGVzWzBdKSk7XHJcbiAgICAgICAgICAgIGJpdGFuZ2VudHNbaTFdLmFkZChWZWN0b3IzLlNDQUxFKGZhY2VCaXRhbmdlbnQsIGZhY2UuYW5nbGVzWzFdKSk7XHJcbiAgICAgICAgICAgIGJpdGFuZ2VudHNbaTJdLmFkZChWZWN0b3IzLlNDQUxFKGZhY2VCaXRhbmdlbnQsIGZhY2UuYW5nbGVzWzJdKSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy5tZXNoLnZlcnRpY2VzLmZvckVhY2goKF92ZXJ0ZXgsIF9pbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbm9ybWFsOiBWZWN0b3IzID0gdGhpcy5tZXNoLnZlcnRpY2VzLm5vcm1hbChfaW5kZXgpO1xyXG4gICAgICAgICAgICBsZXQgdGFuZ2VudDogVmVjdG9yMyA9IHRhbmdlbnRzW19pbmRleF07XHJcbiAgICAgICAgICAgIGxldCBiaXRhbmdlbnQ6IFZlY3RvcjMgPSBiaXRhbmdlbnRzW19pbmRleF07XHJcblxyXG4gICAgICAgICAgICAvLyByZW9ydGhvZ29uYWxpemVcclxuICAgICAgICAgICAgdGFuZ2VudC5hZGQoVmVjdG9yMy5TQ0FMRShub3JtYWwsIC0gVmVjdG9yMy5ET1Qobm9ybWFsLCB0YW5nZW50KSkpO1xyXG4gICAgICAgICAgICBpZiAodGFuZ2VudC5tYWduaXR1ZGVTcXVhcmVkID4gMCkgLy8gc29tZSB2ZXJ0aWNlcyBtaWdodCBiZSB1bnVzZWQgYW5kIHlpZWxkIGEgemVyby10YW5nZW50Li4uXHJcbiAgICAgICAgICAgICAgdGFuZ2VudC5ub3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBoYW5kZWRuZXNzOiBudW1iZXIgPSAoVmVjdG9yMy5ET1QoVmVjdG9yMy5DUk9TUyhub3JtYWwsIHRhbmdlbnQpLCBiaXRhbmdlbnQpIDwgMCkgPyAtMSA6IDE7XHJcblxyXG4gICAgICAgICAgICBfdmVydGV4LnRhbmdlbnQgPSBuZXcgVmVjdG9yNCh0YW5nZW50LngsIHRhbmdlbnQueSwgdGFuZ2VudC56LCBoYW5kZWRuZXNzKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy4jdGFuZ2VudHMgPSBuZXcgRmxvYXQzMkFycmF5KFxyXG4gICAgICAgICAgdGhpcy5tZXNoLnZlcnRpY2VzLmZsYXRNYXAoX3ZlcnRleCA9PiBfdmVydGV4LnRhbmdlbnQuZ2V0KCkpXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuI3RhbmdlbnRzO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCB0YW5nZW50cyhfdGFuZ2VudHM6IEZsb2F0MzJBcnJheSkge1xyXG4gICAgICB0aGlzLiN0YW5nZW50cyA9IF90YW5nZW50cztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHRleHR1cmVVVnMoKTogRmxvYXQzMkFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI3RleHR1cmVVVnMgfHwgKCAvLyByZXR1cm4gY2FjaGUgb3IgLi4uXHJcbiAgICAgICAgLy8gLi4uIGZsYXR0ZW4gYWxsIHV2cyBmcm9tIHRoZSBjbG91cyBpbnRvIGEgdHlwZWQgYXJyYXlcclxuICAgICAgICB0aGlzLiN0ZXh0dXJlVVZzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1lc2gudmVydGljZXNcclxuICAgICAgICAgIC5maWx0ZXIoX3ZlcnRleCA9PiBfdmVydGV4LnV2KVxyXG4gICAgICAgICAgLmZsYXRNYXAoKF92ZXJ0ZXg6IFZlcnRleCkgPT4gWy4uLl92ZXJ0ZXgudXYuZ2V0KCldKVxyXG4gICAgICAgICkpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCB0ZXh0dXJlVVZzKF90ZXh0dXJlVVZzOiBGbG9hdDMyQXJyYXkpIHtcclxuICAgICAgdGhpcy4jdGV4dHVyZVVWcyA9IF90ZXh0dXJlVVZzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgY29sb3JzKCk6IEZsb2F0MzJBcnJheSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNjb2xvcnMgfHwgKFxyXG4gICAgICAgIHRoaXMuI2NvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5tZXNoLnZlcnRpY2VzXHJcbiAgICAgICAgICAuZmlsdGVyKF92ZXJ0ZXggPT4gX3ZlcnRleC5jb2xvcilcclxuICAgICAgICAgIC5mbGF0TWFwKF92ZXJ0ZXggPT4gWy4uLl92ZXJ0ZXguY29sb3IuZ2V0KCldKVxyXG4gICAgICAgICkpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBjb2xvcnMoX2NvbG9yczogRmxvYXQzMkFycmF5KSB7XHJcbiAgICAgIHRoaXMuI2NvbG9ycyA9IF9jb2xvcnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBib25lcygpOiBVaW50OEFycmF5IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2JvbmVzIHx8ICggLy8gcmV0dXJuIGNhY2hlIG9yIC4uLlxyXG4gICAgICAgIHRoaXMuI2JvbmVzID0gdGhpcy5tZXNoLnZlcnRpY2VzLnNvbWUoX3ZlcnRleCA9PiBfdmVydGV4LmJvbmVzKSA/XHJcbiAgICAgICAgICBuZXcgVWludDhBcnJheSh0aGlzLm1lc2gudmVydGljZXMuZmxhdE1hcCgoX3ZlcnRleDogVmVydGV4LCBfaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBib25lczogQm9uZVtdID0gdGhpcy5tZXNoLnZlcnRpY2VzLmJvbmVzKF9pbmRleCk7XHJcbiAgICAgICAgICAgIHJldHVybiBbYm9uZXM/LlswXT8uaW5kZXggfHwgMCwgYm9uZXM/LlsxXT8uaW5kZXggfHwgMCwgYm9uZXM/LlsyXT8uaW5kZXggfHwgMCwgYm9uZXM/LlszXT8uaW5kZXggfHwgMF07XHJcbiAgICAgICAgICB9KSkgOlxyXG4gICAgICAgICAgdW5kZWZpbmVkXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGJvbmVzKF9pQm9uZXM6IFVpbnQ4QXJyYXkpIHtcclxuICAgICAgdGhpcy4jYm9uZXMgPSBfaUJvbmVzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgd2VpZ2h0cygpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgICByZXR1cm4gdGhpcy4jd2VpZ2h0cyB8fCAoIC8vIHJldHVybiBjYWNoZSBvciAuLi5cclxuICAgICAgICB0aGlzLiN3ZWlnaHRzID0gdGhpcy5tZXNoLnZlcnRpY2VzLnNvbWUoX3ZlcnRleCA9PiBfdmVydGV4LmJvbmVzKSA/XHJcbiAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KHRoaXMubWVzaC52ZXJ0aWNlcy5mbGF0TWFwKChfdmVydGV4OiBWZXJ0ZXgsIF9pbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvbmVzOiBCb25lW10gPSB0aGlzLm1lc2gudmVydGljZXMuYm9uZXMoX2luZGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuIFtib25lcz8uWzBdPy53ZWlnaHQgfHwgMCwgYm9uZXM/LlsxXT8ud2VpZ2h0IHx8IDAsIGJvbmVzPy5bMl0/LndlaWdodCB8fCAwLCBib25lcz8uWzNdPy53ZWlnaHQgfHwgMF07XHJcbiAgICAgICAgICB9KSkgOlxyXG4gICAgICAgICAgdW5kZWZpbmVkXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHdlaWdodHMoX3dlaWdodHM6IEZsb2F0MzJBcnJheSkge1xyXG4gICAgICB0aGlzLiN3ZWlnaHRzID0gX3dlaWdodHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhpcyByZW5kZXIgbWVzaCBhbmQgYWxsIGl0cyBidWZmZXJzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcclxuICAgICAgdGhpcy4jcG9zaXRpb25zID0gbnVsbDtcclxuICAgICAgdGhpcy4jaW5kaWNlcyA9IG51bGw7XHJcbiAgICAgIHRoaXMuI3RleHR1cmVVVnMgPSBudWxsO1xyXG4gICAgICB0aGlzLiNub3JtYWxzID0gbnVsbDtcclxuICAgICAgdGhpcy4jY29sb3JzID0gbnVsbDtcclxuICAgICAgdGhpcy4jdGFuZ2VudHMgPSBudWxsO1xyXG5cclxuICAgICAgdGhpcy4jYm9uZXMgPSBudWxsO1xyXG4gICAgICB0aGlzLiN3ZWlnaHRzID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICAvKipcclxuICAgKiBDb250cm9scyB0aGUgcmVuZGVyaW5nIG9mIGEgYnJhbmNoLCB1c2luZyB0aGUgZ2l2ZW4ge0BsaW5rIENvbXBvbmVudENhbWVyYX0sXHJcbiAgICogYW5kIHRoZSBwcm9wYWdhdGlvbiBvZiB0aGUgcmVuZGVyZWQgaW1hZ2UgZnJvbSB0aGUgb2Zmc2NyZWVuIHJlbmRlcmJ1ZmZlciB0byB0aGUgdGFyZ2V0IGNhbnZhc1xyXG4gICAqIHRocm91Z2ggYSBzZXJpZXMgb2Yge0BsaW5rIEZyYW1pbmd9IG9iamVjdHMuIFRoZSBzdGFnZXMgaW52b2x2ZWQgYXJlIGluIG9yZGVyIG9mIHJlbmRlcmluZ1xyXG4gICAqIHtAbGluayBSZW5kZXJ9LnZpZXdwb3J0IC0+IHtAbGluayBWaWV3cG9ydH0uc291cmNlIC0+IHtAbGluayBWaWV3cG9ydH0uZGVzdGluYXRpb24gLT4gRE9NLUNhbnZhcyAtPiBDbGllbnQoQ1NTKVxyXG4gICAqIEBhdXRob3JzIEphc2NoYSBLYXJhZ8O2bCwgSEZVLCAyMDE5IHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTktMjAyMiB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xyXG4gICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ocy1mdXJ0d2FuZ2VuL0ZVREdFL3dpa2kvVmlld3BvcnRcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVmlld3BvcnQgZXh0ZW5kcyBFdmVudFRhcmdldFVuaWZpZWQge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZm9jdXM6IFZpZXdwb3J0O1xyXG5cclxuICAgIHB1YmxpYyBuYW1lOiBzdHJpbmcgPSBcIlZpZXdwb3J0XCI7IC8vIFRoZSBuYW1lIHRvIGNhbGwgdGhpcyB2aWV3cG9ydCBieS5cclxuICAgIHB1YmxpYyBjYW1lcmE6IENvbXBvbmVudENhbWVyYSA9IG51bGw7IC8vIFRoZSBjYW1lcmEgcmVwcmVzZW50aW5nIHRoZSB2aWV3IHBhcmFtZXRlcnMgdG8gcmVuZGVyIHRoZSBicmFuY2guXHJcbiAgICBwdWJsaWMgcmVjdFNvdXJjZTogUmVjdGFuZ2xlO1xyXG4gICAgcHVibGljIHJlY3REZXN0aW5hdGlvbjogUmVjdGFuZ2xlO1xyXG5cclxuICAgIC8vIFRPRE86IHZlcmlmeSBpZiBjbGllbnQgdG8gY2FudmFzIHNob3VsZCBiZSBpbiBWaWV3cG9ydCBvciBzb21ld2hlcmUgZWxzZSAoV2luZG93LCBDb250YWluZXI/KVxyXG4gICAgLy8gTXVsdGlwbGUgdmlld3BvcnRzIHVzaW5nIHRoZSBzYW1lIGNhbnZhcyBzaG91bGRuJ3QgZGlmZmVyIGhlcmUuLi5cclxuICAgIC8vIGRpZmZlcmVudCBmcmFtaW5nIG1ldGhvZHMgY2FuIGJlIHVzZWQsIHRoaXMgaXMgdGhlIGRlZmF1bHRcclxuICAgIHB1YmxpYyBmcmFtZUNsaWVudFRvQ2FudmFzOiBGcmFtaW5nU2NhbGVkID0gbmV3IEZyYW1pbmdTY2FsZWQoKTtcclxuICAgIHB1YmxpYyBmcmFtZUNhbnZhc1RvRGVzdGluYXRpb246IEZyYW1pbmdDb21wbGV4ID0gbmV3IEZyYW1pbmdDb21wbGV4KCk7XHJcbiAgICBwdWJsaWMgZnJhbWVEZXN0aW5hdGlvblRvU291cmNlOiBGcmFtaW5nU2NhbGVkID0gbmV3IEZyYW1pbmdTY2FsZWQoKTtcclxuICAgIHB1YmxpYyBmcmFtZVNvdXJjZVRvUmVuZGVyOiBGcmFtaW5nU2NhbGVkID0gbmV3IEZyYW1pbmdTY2FsZWQoKTtcclxuXHJcbiAgICBwdWJsaWMgYWRqdXN0aW5nRnJhbWVzOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHB1YmxpYyBhZGp1c3RpbmdDYW1lcmE6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgcHVibGljIHBoeXNpY3NEZWJ1Z01vZGU6IFBIWVNJQ1NfREVCVUdNT0RFID0gUEhZU0lDU19ERUJVR01PREUuTk9ORTtcclxuXHJcbiAgICBwdWJsaWMgZ2l6bW9zRW5hYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHVibGljIGdpem1vc1NlbGVjdGVkOiBOb2RlW107XHJcbiAgICBwdWJsaWMgZ2l6bW9zRmlsdGVyOiB7IFtfZ2l6bW86IHN0cmluZ106IGJvb2xlYW4gfSA9IE9iamVjdC5mcm9tRW50cmllcyhDb21wb25lbnQuc3ViY2xhc3NlcyAvLyBUT0RPOiBtYXliZSBtYWtlIHRoaXMgbGF6eVxyXG4gICAgICAuZmlsdGVyKChfY2xhc3M6IHR5cGVvZiBDb21wb25lbnQpID0+IChfY2xhc3MucHJvdG90eXBlKS5kcmF3R2l6bW9zIHx8IChfY2xhc3MucHJvdG90eXBlKS5kcmF3R2l6bW9zU2VsZWN0ZWQpXHJcbiAgICAgIC5tYXAoKF9jbGFzczogdHlwZW9mIENvbXBvbmVudCkgPT4gW19jbGFzcy5uYW1lLCB0cnVlXSlcclxuICAgICk7XHJcblxyXG4gICAgcHVibGljIGNvbXBvbmVudHNQaWNrOiBSZWN5Y2FibGVBcnJheTxDb21wb25lbnRQaWNrPiA9IG5ldyBSZWN5Y2FibGVBcnJheSgpO1xyXG5cclxuICAgICNicmFuY2g6IE5vZGUgPSBudWxsOyAvLyBUaGUgdG8gcmVuZGVyIHdpdGggYWxsIGl0cyBkZXNjZW5kYW50cy5cclxuICAgICNjcmMyOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBudWxsO1xyXG4gICAgI2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIHJlYWRvbmx5ICNyZWN0Q2FudmFzOiBSZWN0YW5nbGUgPSBSZWN0YW5nbGUuR0VUKDAsIDAsIDAsIDApO1xyXG4gICAgcmVhZG9ubHkgI3JlY3RDbGllbnQ6IFJlY3RhbmdsZSA9IFJlY3RhbmdsZS5HRVQoMCwgMCwgMCwgMCk7XHJcbiAgICByZWFkb25seSAjY2FudmFzUmVzaXplT2JzZXJ2ZXI6IFJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcclxuICAgICAgdGhpcy4jcmVjdENsaWVudC53aWR0aCA9IHRoaXMuI2NhbnZhcy5jbGllbnRXaWR0aDtcclxuICAgICAgdGhpcy4jcmVjdENsaWVudC5oZWlnaHQgPSB0aGlzLiNjYW52YXMuY2xpZW50SGVpZ2h0O1xyXG4gICAgfSk7XHJcbiAgICAvLyByZWFkb25seSAjY2FudmFzTXV0YXRpb25PYnNlcnZlcjogTXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHsgLy8gVE9ETzogdGhpbmsgYWJvdXQgdXNpbmcgYSBtdXRhdGlvbiBvYnNlcnZlciB0byBrZWVwIHRyYWNrIG9mIHRoZSBjYW52YXMgc2l6ZS5cclxuICAgIC8vICAgdGhpcy4jcmVjdENhbnZhcy53aWR0aCA9IHRoaXMuI2NhbnZhcy53aWR0aDtcclxuICAgIC8vICAgdGhpcy4jcmVjdENhbnZhcy5oZWlnaHQgPSB0aGlzLiNjYW52YXMuaGVpZ2h0O1xyXG4gICAgLy8gfSk7XHJcblxyXG4gICAgLy8jZW5kcmVnaW9uXHJcblxyXG4gICAgLy8gI3JlZ2lvbiBFdmVudHMgKHBhc3NpbmcgZnJvbSBjYW52YXMgdG8gdmlld3BvcnQgYW5kIGZyb20gdGhlcmUgaW50byBicmFuY2gpXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHZpZXdwb3J0IGN1cnJlbnRseSBoYXMgZm9jdXMgYW5kIHRodXMgcmVjZWl2ZXMga2V5Ym9hcmQgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgaGFzRm9jdXMoKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAoVmlld3BvcnQuZm9jdXMgPT0gdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgZGVzdGluYXRpb24gY2FudmFzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY2FudmFzKCk6IEhUTUxDYW52YXNFbGVtZW50IHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2NhbnZhcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSAyRC1jb250ZXh0IGF0dGFjaGVkIHRvIHRoZSBkZXN0aW5hdGlvbiBjYW52YXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBjb250ZXh0KCk6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNjcmMyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlY3RhbmdsZSBvZiB0aGUgY2FudmFzIGFyZWEgaW4gQ1NTIHBpeGVscy4gVXNlIHRoaXMgdG8gYWNjZXNzIHRoZSBjYW52YXMgd2lkdGggYW5kIGhlaWdodCwgXHJcbiAgICAgKiBidXQgd2l0aG91dCBpbmN1cmluZyBicm93c2VyIGludGVybmFsIGdhcmJhZ2UgY29sbGVjdGlvbi5cclxuICAgICAqIFxyXG4gICAgICogQWRqdXN0ZWQgaW50ZXJuYWxseSBieSB7QGxpbmsgYWRqdXN0RnJhbWVzfSwgZG8gbm90IG1vZGlmeS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCByZWN0Q2FudmFzKCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyZWN0Q2FudmFzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIFRoZSByZWN0YW5nbGUgb2YgdGhlIGNhbnZhcyBhcmVhIGFzIGRpc3BsYXllZCAoY29uc2lkZXJpbmcgY3NzKS4gVXNlIHRoaXMgdG8gYWNjZXNzIGNhbnZhcyBjbGllbnRXaWR0aCBhbmQgY2xpZW50SGVpZ2h0LCBcclxuICAgICAqIGJ1dCB3aXRob3V0IGluY3VyaW5nIGJyb3dzZXIgaW50ZXJuYWwgZ2FyYmFnZSBjb2xsZWN0aW9uLiBcclxuICAgICAqICBcclxuICAgICAqIEFkanVzdGVkIGF1dG9tYXRpY2FsbHkgb24gY2FudmFzIHJlc2l6ZSwgZG8gbm90IG1vZGlmeS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCByZWN0Q2xpZW50KCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiNyZWN0Q2xpZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdHMgdGhlIHZpZXdwb3J0IHRvIHRoZSBnaXZlbiBjYW52YXMgdG8gcmVuZGVyIHRoZSBnaXZlbiBicmFuY2ggdG8gdXNpbmcgdGhlIGdpdmVuIGNhbWVyYS1jb21wb25lbnQsIGFuZCBuYW1lcyB0aGUgdmlld3BvcnQgYXMgZ2l2ZW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbml0aWFsaXplKF9uYW1lOiBzdHJpbmcsIF9icmFuY2g6IE5vZGUsIF9jYW1lcmE6IENvbXBvbmVudENhbWVyYSwgX2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMuY2FtZXJhID0gX2NhbWVyYTtcclxuICAgICAgdGhpcy4jY2FudmFzID0gX2NhbnZhcztcclxuICAgICAgdGhpcy4jY3JjMiA9IF9jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICB0aGlzLiNjcmMyLmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLiNjYW52YXMudGFiSW5kZXggPSAwOyAvLyBjYW4gZ2V0IGZvY3VzIGFuZCByZWNlaXZlIGtleWJvYXJkIGV2ZW50c1xyXG5cclxuICAgICAgdGhpcy4jcmVjdENhbnZhcy53aWR0aCA9IF9jYW52YXMud2lkdGg7XHJcbiAgICAgIHRoaXMuI3JlY3RDYW52YXMuaGVpZ2h0ID0gX2NhbnZhcy5oZWlnaHQ7XHJcbiAgICAgIHRoaXMuI3JlY3RDbGllbnQud2lkdGggPSBfY2FudmFzLmNsaWVudFdpZHRoO1xyXG4gICAgICB0aGlzLiNyZWN0Q2xpZW50LmhlaWdodCA9IF9jYW52YXMuY2xpZW50SGVpZ2h0O1xyXG4gICAgICB0aGlzLnJlY3RTb3VyY2UgPSBSZW5kZXIuZ2V0Q2FudmFzUmVjdGFuZ2xlKCkuY2xvbmU7XHJcbiAgICAgIHRoaXMucmVjdERlc3RpbmF0aW9uID0gUmVjdGFuZ2xlLkdFVCgwLCAwLCB0aGlzLiNjYW52YXMuY2xpZW50V2lkdGgsIHRoaXMuI2NhbnZhcy5jbGllbnRIZWlnaHQpO1xyXG5cclxuICAgICAgLy8gdGhpcy4jY2FudmFzTXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgIC8vIHRoaXMuI2NhbnZhc011dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLiNjYW52YXMsIHsgYXR0cmlidXRlczogdHJ1ZSwgYXR0cmlidXRlRmlsdGVyOiBbXCJ3aWR0aFwiLCBcImhlaWdodFwiXSB9KTtcclxuXHJcbiAgICAgIHRoaXMuI2NhbnZhc1Jlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy4jY2FudmFzUmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLiNjYW52YXMpOyAvLyBUT0RPOiBpZiB2aWV3cG9ydCBpcyBnYXJiYWdlIGNvbGxlY3RlZCwgdGhpcyBvYnNlcnZlciBzaG91bGQgYmUgZGlzY29ubmVjdGVkIGFzIHdlbGwuLi5cclxuXHJcbiAgICAgIHRoaXMuc2V0QnJhbmNoKF9icmFuY2gpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzY29ubmVjdCB0aGUgcmVzaXplIG9ic2VydmVyIGZyb20gdGhlIGNhbnZhcyB0byBhbGxvdyBnYXJiYWdlIGNvbGxlY3Rpb24gb2YgdGhlIHZpZXdwb3J0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGlzY29ubmVjdCgpOiB2b2lkIHtcclxuICAgICAgLy8gdGhpcy4jY2FudmFzTXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHRoaXMuI2NhbnZhc1Jlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIHRoZSBzaXplIG9mIHRoZSBkZXN0aW5hdGlvbiBjYW52YXMgYXMgYSByZWN0YW5nbGUsIHggYW5kIHkgYXJlIGFsd2F5cyAwLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayByZWN0Q2FudmFzfSBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2FudmFzUmVjdGFuZ2xlKCk6IFJlY3RhbmdsZSB7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIHRoaXMuI2NhbnZhcy53aWR0aCwgdGhpcy4jY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY2xpZW50IHJlY3RhbmdsZSB0aGUgY2FudmFzIGlzIGRpc3BsYXllZCBhbmQgZml0IGluLCB4IGFuZCB5IGFyZSBhbHdheXMgMC5cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgcmVjdENsaWVudH0gaW5zdGVhZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENsaWVudFJlY3RhbmdsZSgpOiBSZWN0YW5nbGUge1xyXG4gICAgICAvLyBGVURHRSBkb2Vzbid0IGNhcmUgYWJvdXQgd2hlcmUgdGhlIGNsaWVudCByZWN0IGlzLCBvbmx5IGFib3V0IHRoZSBzaXplIG1hdHRlcnMuXHJcbiAgICAgIC8vIHJldHVybiBSZWN0YW5nbGUuR0VUKHRoaXMuY2FudmFzLm9mZnNldExlZnQsIHRoaXMuY2FudmFzLm9mZnNldFRvcCwgdGhpcy5jYW52YXMuY2xpZW50V2lkdGgsIHRoaXMuY2FudmFzLmNsaWVudEhlaWdodCk7XHJcbiAgICAgIHJldHVybiBSZWN0YW5nbGUuR0VUKDAsIDAsIHRoaXMuI2NhbnZhcy5jbGllbnRXaWR0aCwgdGhpcy4jY2FudmFzLmNsaWVudEhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGJyYW5jaCB0byBiZSBkcmF3biBpbiB0aGUgdmlld3BvcnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRCcmFuY2goX2JyYW5jaDogTm9kZSk6IHZvaWQge1xyXG4gICAgICBpZiAoX2JyYW5jaCkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50OiBSZWN5Y2xhYmxlRXZlbnQgPSBSZWN5Y2xhYmxlRXZlbnQuZ2V0KEVWRU5ULkFUVEFDSF9CUkFOQ0gpO1xyXG4gICAgICAgIF9icmFuY2guYnJvYWRjYXN0RXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIFJlY3ljbGVyLnN0b3JlKGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLiNicmFuY2ggPSBfYnJhbmNoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgdGhlIGJyYW5jaCB0aGlzIHZpZXdwb3J0IHJlbmRlcnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEJyYW5jaCgpOiBOb2RlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuI2JyYW5jaDtcclxuICAgIH1cclxuXHJcbiAgICAvLyAjcmVnaW9uIERyYXdpbmdcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHZpZXdwb3J0IGRpc3BsYXlpbmcgaXRzIGJyYW5jaC4gQnkgZGVmYXVsdCwgdGhlIHRyYW5zZm9ybXMgaW4gdGhlIGJyYW5jaCBhcmUgcmVjYWxjdWxhdGVkIGZpcnN0LlxyXG4gICAgICogUGFzcyBgZmFsc2VgIGlmIGNhbGN1bGF0aW9uIHdhcyBhbHJlYWR5IGRvbmUgZm9yIHRoaXMgZnJhbWUgXHJcbiAgICAgKi9cclxuICAgIC8vIEBQZXJmb3JtYW5jZU1vbml0b3IubWVhc3VyZShcIlZpZXdwb3J0LmRyYXdcIilcclxuICAgIHB1YmxpYyBkcmF3KF9wcmVwYXJlQnJhbmNoOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICB0aGlzLnByZXBhcmUoX3ByZXBhcmVCcmFuY2gpO1xyXG5cclxuICAgICAgUmVuZGVyLnJlc2V0RnJhbWVidWZmZXIoKTtcclxuICAgICAgUmVuZGVyLmNsZWFyKHRoaXMuY2FtZXJhLmNsckJhY2tncm91bmQpO1xyXG5cclxuICAgICAgaWYgKHRoaXMucGh5c2ljc0RlYnVnTW9kZSAhPSBQSFlTSUNTX0RFQlVHTU9ERS5QSFlTSUNfT0JKRUNUU19PTkxZKSB7XHJcbiAgICAgICAgUmVuZGVyLmRyYXcodGhpcy5jYW1lcmEpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5naXptb3NFbmFibGVkKVxyXG4gICAgICAgICAgR2l6bW9zLmRyYXcodGhpcy5nZXRHaXptb3MoKSwgdGhpcy5jYW1lcmEsIHRoaXMuZ2l6bW9zU2VsZWN0ZWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5waHlzaWNzRGVidWdNb2RlICE9IFBIWVNJQ1NfREVCVUdNT0RFLk5PTkUpIHtcclxuICAgICAgICBQaHlzaWNzLmRyYXcodGhpcy5jYW1lcmEsIHRoaXMucGh5c2ljc0RlYnVnTW9kZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGV2ZW50UmVuZGVyRW5kOiBSZWN5Y2xhYmxlRXZlbnQgPSBSZWN5Y2xhYmxlRXZlbnQuZ2V0KEVWRU5ULlJFTkRFUl9FTkQpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnRSZW5kZXJFbmQpO1xyXG4gICAgICBSZWN5Y2xhYmxlRXZlbnQuc3RvcmUoZXZlbnRSZW5kZXJFbmQpO1xyXG5cclxuICAgICAgLy8gdGhpcy4jY3JjMi5jbGVhclJlY3QoMCwgMCwgdGhpcy4jcmVjdENhbnZhcy53aWR0aCwgdGhpcy4jcmVjdENhbnZhcy5oZWlnaHQpOyAvLyBmb3Igbm93IGRvbid0IGNsZWFyIHRvIGFsbG93IG11bGx0aXBsZSB2aWV3cG9ydCBkcmF3IG9uIHNhbWUgY2FudmFzXHJcbiAgICAgIHRoaXMuI2NyYzIuZHJhd0ltYWdlKCAvLyA8LSBjb3N0cyBhIGxvdCBvZiBwZXJmb3JtYW5jZSBpbiBmaXJlZm94XHJcbiAgICAgICAgUmVuZGVyLmdldENhbnZhcygpLFxyXG4gICAgICAgIHRoaXMucmVjdFNvdXJjZS54LCB0aGlzLnJlY3RTb3VyY2UueSwgdGhpcy5yZWN0U291cmNlLndpZHRoLCB0aGlzLnJlY3RTb3VyY2UuaGVpZ2h0LFxyXG4gICAgICAgIHRoaXMucmVjdERlc3RpbmF0aW9uLngsIHRoaXMucmVjdERlc3RpbmF0aW9uLnksIHRoaXMucmVjdERlc3RpbmF0aW9uLndpZHRoLCB0aGlzLnJlY3REZXN0aW5hdGlvbi5oZWlnaHRcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQWRqdXN0cyBhbGwgZnJhbWVzIGFuZCB0aGUgY2FtZXJhIHRvIGZpdCB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBjYW52YXMuIFByZXBhcmVzIHRoZSBicmFuY2ggZm9yIHJlbmRlcmluZy5cclxuICAgICovXHJcbiAgICAvLyBAUGVyZm9ybWFuY2VNb25pdG9yLm1lYXN1cmUoXCJWaWV3cG9ydC5wcmVwYXJlXCIpXHJcbiAgICBwdWJsaWMgcHJlcGFyZShfcHJlcGFyZUJyYW5jaDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgaWYgKCF0aGlzLiNicmFuY2gpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBpZiAoIXRoaXMuY2FtZXJhLmlzQWN0aXZlKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE1lYXN1cmUoXCJWaWV3cG9ydC5wcmVwYXJlIGNtcENhbWVyYS5tdHhXb3JsZCAqIGNtcENhbWVyYS5tdHhQaXZvdFwiKTtcclxuICAgICAgaWYgKCF0aGlzLmNhbWVyYS5ub2RlKSAvL1RPRE86IGZpbmQgYW4gZWxlZ2FudCB3YXkgdG8gaGFuZGxlIGNhbWVyYXMgdGhhdCBhcmUgZWl0aGVyIGF0dGFjaGVkIHRvIGEgbm9kZSBvciBub3QuLi5cclxuICAgICAgICB0aGlzLmNhbWVyYS5tdHhXb3JsZC5jb3B5KHRoaXMuY2FtZXJhLm10eFBpdm90KTtcclxuICAgICAgLy8gUGVyZm9ybWFuY2VNb25pdG9yLmVuZE1lYXN1cmUoXCJWaWV3cG9ydC5wcmVwYXJlIGNtcENhbWVyYS5tdHhXb3JsZCAqIGNtcENhbWVyYS5tdHhQaXZvdFwiKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmFkanVzdGluZ0ZyYW1lcylcclxuICAgICAgICB0aGlzLmFkanVzdEZyYW1lcygpO1xyXG4gICAgICBpZiAodGhpcy5hZGp1c3RpbmdDYW1lcmEpXHJcbiAgICAgICAgdGhpcy5hZGp1c3RDYW1lcmEoKTtcclxuICAgICAgaWYgKF9wcmVwYXJlQnJhbmNoKVxyXG4gICAgICAgIHRoaXMucHJlcGFyZUJyYW5jaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJlcGFyZXMgYWxsIG5vZGVzIGluIHRoZSBicmFuY2ggZm9yIHJlbmRlcmluZyBieSB1cGRhdGluZyB0aGVpciB3b3JsZCB0cmFuc2Zvcm1zIGFuZCBzdXBwbHlpbmcgdGhlIGdwdSByZW5kZXJidWZmZXJzIHdpdGggdGhlIG5lY2Nlc3Nhcnkgbm9kZSBhbmQgY29tcG9uZW50IGRhdGEgdG8gZHJhdyBhIGZyYW1lLlxyXG4gICAgICovXHJcbiAgICAvLyBAUGVyZm9ybWFuY2VNb25pdG9yLm1lYXN1cmUoXCJWaWV3cG9ydC5wcmVwYXJlQnJhbmNoXCIpXHJcbiAgICBwdWJsaWMgcHJlcGFyZUJyYW5jaCgpOiB2b2lkIHtcclxuICAgICAgY29uc3QgZXZlbnRQcmVwYXJlU3RhcnQ6IFJlY3ljbGFibGVFdmVudCA9IFJlY3ljbGFibGVFdmVudC5nZXQoRVZFTlQuUkVOREVSX1BSRVBBUkVfU1RBUlQpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnRQcmVwYXJlU3RhcnQpO1xyXG4gICAgICBSZWN5Y2xhYmxlRXZlbnQuc3RvcmUoZXZlbnRQcmVwYXJlU3RhcnQpO1xyXG4gICAgICBSZW5kZXIucHJlcGFyZSh0aGlzLiNicmFuY2gpO1xyXG4gICAgICBjb25zdCBldmVudFByZXBhcmVFbmQ6IFJlY3ljbGFibGVFdmVudCA9IFJlY3ljbGFibGVFdmVudC5nZXQoRVZFTlQuUkVOREVSX1BSRVBBUkVfRU5EKTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50UHJlcGFyZUVuZCk7XHJcbiAgICAgIFJlY3ljbGFibGVFdmVudC5zdG9yZShldmVudFByZXBhcmVFbmQpO1xyXG4gICAgICB0aGlzLmNvbXBvbmVudHNQaWNrID0gUmVuZGVyLmNvbXBvbmVudHNQaWNrO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSBwaWNrIG9uIGFsbCB7QGxpbmsgQ29tcG9uZW50UGlja31zIGluIHRoZSBicmFuY2ggb2YgdGhpcyB2aWV3cG9ydFxyXG4gICAgICogdXNpbmcgYSByYXkgZnJvbSBpdHMgY2FtZXJhIHRocm91Z2ggdGhlIGNsaWVudCBjb29yZGluYXRlcyBnaXZlbiBpbiB0aGUgZXZlbnQuXHJcbiAgICAgKiBEaXNwYXRjaGVzIHRoZSBldmVudCB0byBhbGwgbm9kZXMgaGl0LiAgXHJcbiAgICAgKiBJZiB7QGxpbmsgUElDSy5DQU1FUkF9IHdhcyBjaG9zZW4gYXMgdGhlIG1ldGhvZCB0byBwaWNrLCBhIHBpY2sgcHJvcGVydHkgZ2V0cyBhZGRlZCB0byB0aGUgZXZlbnQsIFxyXG4gICAgICogd2hpY2ggaG9sZHMgdGhlIGRldGFpbGVkIGluZm9ybWF0aW9uLCBidXQgaXMgb3ZlcndyaXR0ZW4gZm9yIGVhY2ggbm9kZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRpc3BhdGNoUG9pbnRlckV2ZW50KF9ldmVudDogUG9pbnRlckV2ZW50KTogdm9pZCB7XHJcbiAgICAgIGxldCBwb3NDbGllbnQ6IFZlY3RvcjIgPSBuZXcgVmVjdG9yMihfZXZlbnQuY2xpZW50WCwgX2V2ZW50LmNsaWVudFkpO1xyXG4gICAgICBsZXQgcmF5OiBSYXkgPSB0aGlzLmdldFJheUZyb21DbGllbnQocG9zQ2xpZW50KTtcclxuICAgICAgLy8gbGV0IGNhbWVyYVBpY2tzOiBSZWN5Y2FibGVBcnJheTxOb2RlPiA9IFJlY3ljbGVyLmdldChSZWN5Y2FibGVBcnJheSk7IC8vVE9ETzogdGhpbmsgYWJvdXQgb3B0aW1pemF0aW9uIGxhdGVyXHJcbiAgICAgIGxldCBjYW1lcmFQaWNrczogTm9kZVtdID0gW107XHJcbiAgICAgIGxldCBvdGhlclBpY2tzOiBDb21wb25lbnRQaWNrW10gPSBbXTtcclxuICAgICAgZm9yIChsZXQgY21wUGljayBvZiB0aGlzLmNvbXBvbmVudHNQaWNrKVxyXG4gICAgICAgIGlmIChjbXBQaWNrLnBpY2sgPT0gUElDSy5DQU1FUkEpXHJcbiAgICAgICAgICBjYW1lcmFQaWNrcy5wdXNoKGNtcFBpY2subm9kZSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgb3RoZXJQaWNrcy5wdXNoKGNtcFBpY2spO1xyXG5cclxuXHJcbiAgICAgIGlmIChjYW1lcmFQaWNrcy5sZW5ndGgpIHtcclxuICAgICAgICBsZXQgcGlja3M6IFBpY2tbXSA9IFBpY2tlci5waWNrQ2FtZXJhKGNhbWVyYVBpY2tzLCB0aGlzLmNhbWVyYSwgdGhpcy5wb2ludENsaWVudFRvUHJvamVjdGlvbihwb3NDbGllbnQpKTtcclxuICAgICAgICBmb3IgKGxldCBwaWNrIG9mIHBpY2tzKSB7XHJcbiAgICAgICAgICBSZWZsZWN0LnNldChfZXZlbnQsIFwicGlja1wiLCBwaWNrKTtcclxuICAgICAgICAgIHBpY2subm9kZS5kaXNwYXRjaEV2ZW50KF9ldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGxldCBjbXBQaWNrIG9mIG90aGVyUGlja3MpIHtcclxuICAgICAgICBjbXBQaWNrLnBpY2tBbmREaXNwYXRjaChyYXksIF9ldmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdCBhbGwgZnJhbWVzIGludm9sdmVkIGluIHRoZSByZW5kZXJpbmcgcHJvY2VzcyBmcm9tIHRoZSBkaXNwbGF5IGFyZWEgaW4gdGhlIGNsaWVudCB1cCB0byB0aGUgcmVuZGVyZXIgY2FudmFzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRqdXN0RnJhbWVzKCk6IHZvaWQge1xyXG4gICAgICAvLyBhZGp1c3QgdGhlIGNhbnZhcyBzaXplIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZnJhbWluZyBhcHBsaWVkIHRvIGNsaWVudFxyXG4gICAgICBjb25zdCByZWN0Q2FudmFzOiBSZWN0YW5nbGUgPSB0aGlzLmZyYW1lQ2xpZW50VG9DYW52YXMuZ2V0UmVjdCh0aGlzLiNyZWN0Q2xpZW50KTtcclxuICAgICAgaWYgKHRoaXMuI3JlY3RDbGllbnQud2lkdGggIT0gdGhpcy4jcmVjdENhbnZhcy53aWR0aCkge1xyXG4gICAgICAgIHRoaXMuI3JlY3RDYW52YXMud2lkdGggPSByZWN0Q2FudmFzLndpZHRoO1xyXG4gICAgICAgIHRoaXMuI2NhbnZhcy53aWR0aCA9IHJlY3RDYW52YXMud2lkdGg7IC8vIHNldHRpbmcgd2lkdGggb3IgaGVpZ2h0IG9mIGNhbnZhcyBjYXVzZXMgc2lkZSBlZmZlY3RzLCBzbyBvbmx5IGRvIGl0IGlmIG5lY2Nlc3NhcnksIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvd2lkdGhcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy4jcmVjdENsaWVudC5oZWlnaHQgIT0gdGhpcy4jcmVjdENhbnZhcy5oZWlnaHQpIHtcclxuICAgICAgICB0aGlzLiNyZWN0Q2FudmFzLmhlaWdodCA9IHJlY3RDYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuI2NhbnZhcy5oZWlnaHQgPSByZWN0Q2FudmFzLmhlaWdodDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYWRqdXN0IHRoZSBkZXN0aW5hdGlvbiBhcmVhIG9uIHRoZSB0YXJnZXQtY2FudmFzIHRvIHJlbmRlciB0byBieSBhcHBseWluZyB0aGUgZnJhbWluZyB0byBjYW52YXNcclxuICAgICAgdGhpcy5mcmFtZUNhbnZhc1RvRGVzdGluYXRpb24uZ2V0UmVjdChyZWN0Q2FudmFzLCB0aGlzLnJlY3REZXN0aW5hdGlvbik7XHJcblxyXG4gICAgICAvLyBhZGp1c3QgdGhlIGFyZWEgb24gdGhlIHNvdXJjZS1jYW52YXMgdG8gcmVuZGVyIGZyb20gYnkgYXBwbHlpbmcgdGhlIGZyYW1pbmcgdG8gZGVzdGluYXRpb24gYXJlYVxyXG4gICAgICB0aGlzLmZyYW1lRGVzdGluYXRpb25Ub1NvdXJjZS5nZXRSZWN0KHRoaXMucmVjdERlc3RpbmF0aW9uLCB0aGlzLnJlY3RTb3VyY2UpO1xyXG5cclxuICAgICAgLy8gaGF2aW5nIGFuIG9mZnNldCBzb3VyY2UgZG9lcyBtYWtlIHNlbnNlIG9ubHkgd2hlbiBtdWx0aXBsZSB2aWV3cG9ydHMgZGlzcGxheSBwYXJ0cyBvZiB0aGUgc2FtZSByZW5kZXJpbmcuIEZvciBub3c6IHNoaWZ0IGl0IHRvIDAsMFxyXG4gICAgICB0aGlzLnJlY3RTb3VyY2UueCA9IHRoaXMucmVjdFNvdXJjZS55ID0gMDtcclxuXHJcbiAgICAgIC8vIHN0aWxsLCBhIHBhcnRpYWwgaW1hZ2Ugb2YgdGhlIHJlbmRlcmluZyBtYXkgYmUgcmV0cmlldmVkIGJ5IG1vdmluZyBhbmQgcmVzaXppbmcgdGhlIHJlbmRlciB2aWV3cG9ydC4gRm9yIG5vdywgaXQncyBhbHdheXMgYWRqdXN0ZWQgdG8gdGhlIGN1cnJlbnQgdmlld3BvcnRcclxuICAgICAgY29uc3QgcmVjdFJlbmRlcjogUmVjdGFuZ2xlID0gdGhpcy5mcmFtZVNvdXJjZVRvUmVuZGVyLmdldFJlY3QodGhpcy5yZWN0U291cmNlKTtcclxuICAgICAgUmVuZGVyLnNldFJlbmRlclJlY3RhbmdsZShyZWN0UmVuZGVyKTtcclxuICAgICAgLy8gbm8gbW9yZSB0cmFuc2Zvcm1hdGlvbiBhZnRlciB0aGlzIGZvciBub3csIG9mZnNjcmVlbiBjYW52YXMgYW5kIHJlbmRlci12aWV3cG9ydCBoYXZlIHRoZSBzYW1lIHNpemVcclxuICAgICAgUmVuZGVyLnNldENhbnZhc1NpemUocmVjdFJlbmRlci53aWR0aCwgcmVjdFJlbmRlci5oZWlnaHQpO1xyXG5cclxuICAgICAgUmVjeWNsZXIuc3RvcmUocmVjdENhbnZhcyk7XHJcbiAgICAgIFJlY3ljbGVyLnN0b3JlKHJlY3RSZW5kZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0IHRoZSBjYW1lcmEgcGFyYW1ldGVycyB0byBmaXQgdGhlIHJlbmRlcmluZyBpbnRvIHRoZSByZW5kZXIgdmlld3BvcnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGp1c3RDYW1lcmEoKTogdm9pZCB7XHJcbiAgICAgIGNvbnN0IHJlY3RSZW5kZXI6IFJlY3RhbmdsZSA9IFJlbmRlci5nZXRSZW5kZXJSZWN0YW5nbGUoKTtcclxuICAgICAgdGhpcy5jYW1lcmEucHJvamVjdENlbnRyYWwocmVjdFJlbmRlci53aWR0aCAvIHJlY3RSZW5kZXIuaGVpZ2h0LCB0aGlzLmNhbWVyYS5maWVsZE9mVmlldywgdGhpcy5jYW1lcmEuZGlyZWN0aW9uLCB0aGlzLmNhbWVyYS5uZWFyLCB0aGlzLmNhbWVyYS5mYXIpO1xyXG5cclxuICAgICAgLy8gY29uc3QgcHJvamVjdGlvbjogUFJPSkVDVElPTiA9IHRoaXMuY2FtZXJhLnByb2plY3Rpb247XHJcbiAgICAgIC8vIHN3aXRjaCAocHJvamVjdGlvbikge1xyXG4gICAgICAvLyBjYXNlIFBST0pFQ1RJT04uQ0VOVFJBTDpcclxuICAgICAgLy8gdGhpcy5jYW1lcmEucHJvamVjdENlbnRyYWwocmVjdFJlbmRlci53aWR0aCAvIHJlY3RSZW5kZXIuaGVpZ2h0LCB0aGlzLmNhbWVyYS5maWVsZE9mVmlldywgdGhpcy5jYW1lcmEuZGlyZWN0aW9uLCB0aGlzLmNhbWVyYS5uZWFyLCB0aGlzLmNhbWVyYS5mYXIpO1xyXG4gICAgICAvLyBicmVhaztcclxuICAgICAgLy8gY2FzZSBQUk9KRUNUSU9OLk9SVEhPR1JBUEhJQzpcclxuICAgICAgLy8gICB0aGlzLmNhbWVyYS5wcm9qZWN0T3J0aG9ncmFwaGljKCk7XHJcbiAgICAgIC8vICAgLy8gdGhpcy5jYW1lcmEucHJvamVjdE9ydGhvZ3JhcGhpYygtcmVjdFJlbmRlci53aWR0aCAvIDIwLCByZWN0UmVuZGVyLndpZHRoIC8gMjAsIHJlY3RSZW5kZXIuaGVpZ2h0IC8gMjAsIC1yZWN0UmVuZGVyLmhlaWdodCAvIDIwKTtcclxuICAgICAgLy8gICBicmVhaztcclxuICAgICAgLy8gfVxyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAgIC8vI3JlZ2lvbiBQb2ludHNcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHtAbGluayBSYXl9IGluIHdvcmxkIGNvb3JkaW5hdGVzIGZyb20gdGhpcyBjYW1lcmEgdGhyb3VnaCB0aGUgcG9pbnQgZ2l2ZW4gaW4gY2xpZW50IHNwYWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRSYXlGcm9tQ2xpZW50KF9wb2ludDogVmVjdG9yMik6IFJheSB7XHJcbiAgICAgIGxldCBwb3NQcm9qZWN0aW9uOiBWZWN0b3IyID0gdGhpcy5wb2ludENsaWVudFRvUHJvamVjdGlvbihfcG9pbnQpO1xyXG4gICAgICBsZXQgcmF5OiBSYXkgPSBuZXcgUmF5KG5ldyBWZWN0b3IzKC1wb3NQcm9qZWN0aW9uLngsIHBvc1Byb2plY3Rpb24ueSwgMSkpO1xyXG5cclxuICAgICAgLy8gcmF5LmRpcmVjdGlvbi5zY2FsZShjYW1lcmEuZGlzdGFuY2UpO1xyXG4gICAgICByYXkudHJhbnNmb3JtKHRoaXMuY2FtZXJhLm10eFBpdm90KTtcclxuICAgICAgbGV0IGNhbWVyYU5vZGU6IE5vZGUgPSB0aGlzLmNhbWVyYS5ub2RlO1xyXG4gICAgICBpZiAoY2FtZXJhTm9kZSlcclxuICAgICAgICByYXkudHJhbnNmb3JtKGNhbWVyYU5vZGUubXR4V29ybGQpO1xyXG5cclxuICAgICAgcmV0dXJuIHJheTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwb2ludCBvbiB0aGUgY2xpZW50IHJlY3RhbmdsZSBtYXRjaGluZyB0aGUgcHJvamVjdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQgaW4gd29ybGQgc3BhY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvaW50V29ybGRUb0NsaWVudChfcG9zaXRpb246IFZlY3RvcjMpOiBWZWN0b3IyIHtcclxuICAgICAgbGV0IHByb2plY3Rpb246IFZlY3RvcjMgPSB0aGlzLmNhbWVyYS5wb2ludFdvcmxkVG9DbGlwKF9wb3NpdGlvbik7XHJcbiAgICAgIGxldCBwb3NDbGllbnQ6IFZlY3RvcjIgPSB0aGlzLnBvaW50Q2xpcFRvQ2xpZW50KHByb2plY3Rpb24udG9WZWN0b3IyKCkpO1xyXG4gICAgICByZXR1cm4gcG9zQ2xpZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IG9uIHRoZSBzb3VyY2UtcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBnaXZlbiBwb2ludCBvbiB0aGUgY2xpZW50IHJlY3RhbmdsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGllbnRUb1NvdXJjZShfY2xpZW50OiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCByZXN1bHQ6IFZlY3RvcjIgPSB0aGlzLmZyYW1lQ2xpZW50VG9DYW52YXMuZ2V0UG9pbnQoX2NsaWVudCwgdGhpcy4jcmVjdENsaWVudCk7XHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuZnJhbWVDYW52YXNUb0Rlc3RpbmF0aW9uLmdldFBvaW50KHJlc3VsdCwgdGhpcy4jcmVjdENhbnZhcyk7XHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuZnJhbWVEZXN0aW5hdGlvblRvU291cmNlLmdldFBvaW50KHJlc3VsdCwgdGhpcy5yZWN0U291cmNlKTtcclxuICAgICAgLy9UT0RPOiB3aGVuIFNvdXJjZSwgUmVuZGVyIGFuZCBSZW5kZXJWaWV3cG9ydCBkZXZpYXRlLCBjb250aW51ZSB0cmFuc2Zvcm1hdGlvbiBcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwb2ludCBvbiB0aGUgcmVuZGVyLXJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIHNvdXJjZSByZWN0YW5nbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvaW50U291cmNlVG9SZW5kZXIoX3NvdXJjZTogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcHJvamVjdGlvblJlY3RhbmdsZTogUmVjdGFuZ2xlID0gdGhpcy5jYW1lcmEuZ2V0UHJvamVjdGlvblJlY3RhbmdsZSgpO1xyXG4gICAgICBsZXQgcG9pbnQ6IFZlY3RvcjIgPSB0aGlzLmZyYW1lU291cmNlVG9SZW5kZXIuZ2V0UG9pbnQoX3NvdXJjZSwgcHJvamVjdGlvblJlY3RhbmdsZSk7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHByb2plY3Rpb25SZWN0YW5nbGUudG9TdHJpbmcoKSk7XHJcbiAgICAgIHJldHVybiBwb2ludDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwb2ludCBvbiB0aGUgcmVuZGVyLXJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBvaW50Q2xpZW50VG9SZW5kZXIoX2NsaWVudDogVmVjdG9yMik6IFZlY3RvcjIge1xyXG4gICAgICBsZXQgcG9pbnQ6IFZlY3RvcjIgPSB0aGlzLnBvaW50Q2xpZW50VG9Tb3VyY2UoX2NsaWVudCk7XHJcbiAgICAgIHBvaW50ID0gdGhpcy5wb2ludFNvdXJjZVRvUmVuZGVyKHBvaW50KTtcclxuICAgICAgLy9UT0RPOiB3aGVuIFJlbmRlciBhbmQgUmVuZGVyVmlld3BvcnQgZGV2aWF0ZSwgY29udGludWUgdHJhbnNmb3JtYXRpb24gXHJcbiAgICAgIHJldHVybiBwb2ludDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwb2ludCBvbiBhIHByb2plY3Rpb24gc3VyZmFjZSBpbiB0aGUgaHlwb3RoZXRpY2FsIGRpc3RhbmNlIG9mIDEgdG8gdGhlIGNhbWVyYSAgXHJcbiAgICAgKiBtYXRjaGluZyB0aGUgZ2l2ZW4gcG9pbnQgb24gdGhlIGNsaWVudCByZWN0YW5nbGVcclxuICAgICAqIFRPRE86IGV4YW1pbmUsIGlmIHRoaXMgc2hvdWxkIGJlIGEgY2FtZXJhLW1ldGhvZC4gQ3VycmVudCBpbXBsZW1lbnRhdGlvbiBpcyBmb3IgY2VudHJhbC1wcm9qZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludENsaWVudFRvUHJvamVjdGlvbihfY2xpZW50OiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBwb3NSZW5kZXI6IFZlY3RvcjIgPSB0aGlzLnBvaW50Q2xpZW50VG9SZW5kZXIoX2NsaWVudCk7XHJcbiAgICAgIGxldCByZWN0UmVuZGVyOiBSZWN0YW5nbGUgPSB0aGlzLmZyYW1lU291cmNlVG9SZW5kZXIuZ2V0UmVjdCh0aGlzLnJlY3RTb3VyY2UpO1xyXG4gICAgICBsZXQgcmVjdFByb2plY3Rpb246IFJlY3RhbmdsZSA9IHRoaXMuY2FtZXJhLmdldFByb2plY3Rpb25SZWN0YW5nbGUoKTtcclxuXHJcbiAgICAgIGxldCBwb3NQcm9qZWN0aW9uOiBWZWN0b3IyID0gbmV3IFZlY3RvcjIoXHJcbiAgICAgICAgcmVjdFByb2plY3Rpb24ud2lkdGggKiBwb3NSZW5kZXIueCAvIHJlY3RSZW5kZXIud2lkdGgsXHJcbiAgICAgICAgcmVjdFByb2plY3Rpb24uaGVpZ2h0ICogcG9zUmVuZGVyLnkgLyByZWN0UmVuZGVyLmhlaWdodFxyXG4gICAgICApO1xyXG5cclxuICAgICAgcG9zUHJvamVjdGlvbi5zdWJ0cmFjdChuZXcgVmVjdG9yMihyZWN0UHJvamVjdGlvbi53aWR0aCAvIDIsIHJlY3RQcm9qZWN0aW9uLmhlaWdodCAvIDIpKTtcclxuICAgICAgcG9zUHJvamVjdGlvbi55ICo9IC0xO1xyXG5cclxuICAgICAgcmV0dXJuIHBvc1Byb2plY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgaW4gdGhlIGNsaWVudCByZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IGluIG5vcm1lZCBjbGlwc3BhY2UgcmVjdGFuZ2xlLCBcclxuICAgICAqIHdoaWNoIHN0cmV0Y2hlcyBmcm9tIC0xIHRvIDEgaW4gYm90aCBkaW1lbnNpb25zLCB5IHBvaW50aW5nIHVwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludENsaXBUb0NsaWVudChfbm9ybWVkOiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIC8vIGxldCByZWN0Q2xpZW50OiBSZWN0YW5nbGUgPSB0aGlzLmdldENsaWVudFJlY3RhbmdsZSgpO1xyXG4gICAgICAvLyBsZXQgcmVzdWx0OiBWZWN0b3IyID0gVmVjdG9yMi5PTkUoMC41KTtcclxuICAgICAgLy8gcmVzdWx0LnggKj0gKF9ub3JtZWQueCArIDEpICogcmVjdENsaWVudC53aWR0aDtcclxuICAgICAgLy8gcmVzdWx0LnkgKj0gKDEgLSBfbm9ybWVkLnkpICogcmVjdENsaWVudC5oZWlnaHQ7XHJcbiAgICAgIC8vIHJlc3VsdC5hZGQocmVjdENsaWVudC5wb3NpdGlvbik7XHJcbiAgICAgIC8vVE9ETzogY2hlY2sgaWYgcmVjdERlc3RpbmF0aW9uIGNhbiBzYWZlbHkgKGFuZCBtb3JlIHBlcmZvbWFudCkgYmUgdXNlZCBpbnN0ZWFkIGdldENsaWVudFJlY3RhbmdsZVxyXG4gICAgICBsZXQgcG9pbnRDbGllbnQ6IFZlY3RvcjIgPSBSZW5kZXIucmVjdENsaXAucG9pbnRUb1JlY3QoX25vcm1lZCwgdGhpcy5yZWN0RGVzdGluYXRpb24pO1xyXG4gICAgICByZXR1cm4gcG9pbnRDbGllbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcG9pbnQgaW4gdGhlIGNsaWVudCByZWN0YW5nbGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IGluIG5vcm1lZCBjbGlwc3BhY2UgcmVjdGFuZ2xlLCBcclxuICAgICAqIHdoaWNoIHN0cmV0Y2hlcyBmcm9tIC0xIHRvIDEgaW4gYm90aCBkaW1lbnNpb25zLCB5IHBvaW50aW5nIHVwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwb2ludENsaXBUb0NhbnZhcyhfbm9ybWVkOiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBwb2ludENhbnZhczogVmVjdG9yMiA9IFJlbmRlci5yZWN0Q2xpcC5wb2ludFRvUmVjdChfbm9ybWVkLCB0aGlzLiNyZWN0Q2FudmFzKTtcclxuICAgICAgcmV0dXJuIHBvaW50Q2FudmFzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHBvaW50IGluIHRoZSBicm93c2VyIHBhZ2UgbWF0Y2hpbmcgdGhlIGdpdmVuIHBvaW50IG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9pbnRDbGllbnRUb1NjcmVlbihfY2xpZW50OiBWZWN0b3IyKTogVmVjdG9yMiB7XHJcbiAgICAgIGxldCBzY3JlZW46IFZlY3RvcjIgPSBuZXcgVmVjdG9yMih0aGlzLiNjYW52YXMub2Zmc2V0TGVmdCArIF9jbGllbnQueCwgdGhpcy4jY2FudmFzLm9mZnNldFRvcCArIF9jbGllbnQueSk7XHJcbiAgICAgIHJldHVybiBzY3JlZW47XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgZ2l6bW9zIGluIHRoZSBicmFuY2ggb2YgdGhpcyB2aWV3cG9ydCB0aGF0IGFyZSBhY3RpdmUsIGZpbHRlcmVkIGJ5IHtAbGluayBnaXptb3NGaWx0ZXJ9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRHaXptb3MoX25vZGVzOiBOb2RlW10gPSBBcnJheS5mcm9tKHRoaXMuI2JyYW5jaC5nZXRJdGVyYXRvcih0cnVlKSkpOiBHaXptb1tdIHtcclxuICAgICAgcmV0dXJuIF9ub2Rlc1xyXG4gICAgICAgIC5mbGF0TWFwKF9ub2RlID0+IF9ub2RlLmdldEFsbENvbXBvbmVudHMoKSlcclxuICAgICAgICAuZmlsdGVyKF9jb21wb25lbnQgPT4gX2NvbXBvbmVudC5pc0FjdGl2ZSAmJiAoX2NvbXBvbmVudC5kcmF3R2l6bW9zIHx8IF9jb21wb25lbnQuZHJhd0dpem1vc1NlbGVjdGVkKSAmJiB0aGlzLmdpem1vc0ZpbHRlcltfY29tcG9uZW50LnR5cGVdKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgLyoqXHJcbiAgICogRGlmZmVyZW50IHhyIHNlc3Npb24gbW9kZXMgYXZhaWxhYmxlLiBDb3VsZCBiZSBleHBhbmQgd2l0aCBtb3JlIG1vZGVzIGluIHRoZSBmdXR1cmUuXHJcbiAgICogQGF1dGhvcnMgVmFsZW50aW4gU2NobWlkYmVyZ2VyLCBIRlUsIDIwMjIgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBYUl9TRVNTSU9OX01PREUge1xyXG4gICAgSU1NRVJTSVZFX1ZSID0gXCJpbW1lcnNpdmUtdnJcIlxyXG4gICAgLy9JTU1FUlNJVkVfQVIgPSBcImltbWVyc2l2ZS1hclwiLFxyXG4gICAgLy9JTkxJTkUgPSBcImlubGluZVwiXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaWZmZXJlbnQgcmVmZXJlbmNlIHZyLXNwYWNlcyBhdmFpbGFibGUsIGNyZWF0b3IgaGFzIHRvIGNoZWNrIGlmIHRoZSBzcGFjZSBpcyBzdXBwb3J0ZWQgd2l0aCBpdHMgZGV2aWNlLlxyXG4gICAqIENvdWxkIGJlIGV4cGFuZCB3aXRoIG1vcmUgYXZhaWxhYmxlIHNwYWNlIHR5cGVzIGluIHRoZSBmdXR1cmUuXHJcbiAgICovXHJcbiAgZXhwb3J0IGVudW0gWFJfUkVGRVJFTkNFX1NQQUNFIHtcclxuICAgIFZJRVdFUiA9IFwidmlld2VyXCIsXHJcbiAgICBMT0NBTCA9IFwibG9jYWxcIlxyXG4gICAgLy8gTE9DQUxfRkxPT1IgPSBcImxvY2FsLWZsb29yXCIsXHJcbiAgICAvLyBCT1VOREVEX0ZMT09SID0gXCJib3VuZGVkLWZsb29yXCIsXHJcbiAgICAvLyBVTkJPVU5ERUQgPSBcInVuYm91bmRlZFwiXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBYUlZpZXdwb3J0ICh3ZWJYUiktZXh0ZW5zaW9uIG9mIFZpZXdwb3J0LCB0byBkaXNwbGF5aW5nIGl0cyBicmFuY2ggb24gSGVhZCBNb3VudGVkIGFuZCBBUiAobm90IGltcGxlbXRlZCB5ZXQpIERldmljZXMgXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIFhSVmlld3BvcnQgZXh0ZW5kcyBWaWV3cG9ydCB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyB4clZpZXdwb3J0SW5zdGFuY2U6IFhSVmlld3BvcnQgPSBudWxsO1xyXG4gICAgcHVibGljIHZyRGV2aWNlOiBDb21wb25lbnRWUkRldmljZSA9IG51bGw7XHJcbiAgICBwdWJsaWMgc2Vzc2lvbjogWFJTZXNzaW9uID0gbnVsbDtcclxuICAgIHB1YmxpYyByZWZlcmVuY2VTcGFjZTogWFJSZWZlcmVuY2VTcGFjZSA9IG51bGw7XHJcbiAgICBwcml2YXRlIHVzZVZSQ29udHJvbGxlcjogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIC8vIHByaXZhdGUgcG9zZU10eDogTWF0cml4NHg0ID0gbmV3IE1hdHJpeDR4NCgpO1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICBYUlZpZXdwb3J0LnhyVmlld3BvcnRJbnN0YW5jZSA9IHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUbyByZXRyaWV2ZSBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZSBvZiB4ciB2aWV3cG9ydCwgcmVhZG9ubHkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGRlZmF1bHQoKTogWFJWaWV3cG9ydCB7XHJcbiAgICAgIHJldHVybiB0aGlzLnhyVmlld3BvcnRJbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBDb25uZWN0cyB0aGUgdmlld3BvcnQgdG8gdGhlIGdpdmVuIGNhbnZhcyB0byByZW5kZXIgdGhlIGdpdmVuIGJyYW5jaCB0byB1c2luZyB0aGUgZ2l2ZW4gY2FtZXJhLWNvbXBvbmVudCwgYW5kIG5hbWVzIHRoZSB2aWV3cG9ydCBhcyBnaXZlbi5cclxuICAgICAgKi9cclxuICAgIHB1YmxpYyBpbml0aWFsaXplKF9uYW1lOiBzdHJpbmcsIF9icmFuY2g6IE5vZGUsIF9jYW1lcmFYUjogQ29tcG9uZW50VlJEZXZpY2UgLyogfCBDb21wb25lbnRDYW1lcmFBUiovLCBfY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICBzdXBlci5pbml0aWFsaXplKF9uYW1lLCBfYnJhbmNoLCBfY2FtZXJhWFIsIF9jYW52YXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIFZSIFNlc3Npb24gaXMgaW5pdGlhbGl6ZWQgaGVyZSwgYWxzbyBWUiAtIENvbnRyb2xsZXIgYXJlIGluaXRpYWxpemVkLCBpZiBib29sZWFuIGlzIHRydWUuXHJcbiAgICAgKiBDcmVhdG9yIGhhcyB0byBjYWxsIEZyYW1lUmVxdWVzdFhSIGFmdGVyIHRoaXMgTWV0aG9kIHRvIHJ1biB0aGUgdmlld3BvcnQgaW4gdmlydHVhbCByZWFsaXR5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgaW5pdGlhbGl6ZVZSKF92clNlc3Npb25Nb2RlOiBYUl9TRVNTSU9OX01PREUgPSBYUl9TRVNTSU9OX01PREUuSU1NRVJTSVZFX1ZSLCBfdnJSZWZlcmVuY2VTcGFjZVR5cGU6IFhSX1JFRkVSRU5DRV9TUEFDRSA9IFhSX1JFRkVSRU5DRV9TUEFDRS5MT0NBTCwgX3ZyQ29udHJvbGxlcjogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGxldCBzZXNzaW9uOiBYUlNlc3Npb24gPSBhd2FpdCBuYXZpZ2F0b3IueHIucmVxdWVzdFNlc3Npb24oX3ZyU2Vzc2lvbk1vZGUpO1xyXG4gICAgICB0aGlzLnJlZmVyZW5jZVNwYWNlID0gYXdhaXQgc2Vzc2lvbi5yZXF1ZXN0UmVmZXJlbmNlU3BhY2UoX3ZyUmVmZXJlbmNlU3BhY2VUeXBlKTtcclxuICAgICAgYXdhaXQgUmVuZGVyLmdldFJlbmRlcmluZ0NvbnRleHQoKS5tYWtlWFJDb21wYXRpYmxlKCk7XHJcbiAgICAgIGxldCBuYXRpdmVTY2FsZUZhY3RvcjogbnVtYmVyID0gWFJXZWJHTExheWVyLmdldE5hdGl2ZUZyYW1lYnVmZmVyU2NhbGVGYWN0b3Ioc2Vzc2lvbik7XHJcbiAgICAgIC8vVE9ETzogIEZpZWxkIG9mIHZpZXcga8O2bm50ZSBhbiBkZXIgU3RlbGxlIG5vY2ggdmVyw6RuZGVydCB3ZXJkZW4uXHJcbiAgICAgIGxldCBiYXNlTGF5ZXI6IFhSV2ViR0xMYXllciA9IG5ldyBYUldlYkdMTGF5ZXIoc2Vzc2lvbiwgUmVuZGVyLmdldFJlbmRlcmluZ0NvbnRleHQoKSwgeyBmcmFtZWJ1ZmZlclNjYWxlRmFjdG9yOiBuYXRpdmVTY2FsZUZhY3RvciB9KTtcclxuICAgICAgYXdhaXQgc2Vzc2lvbi51cGRhdGVSZW5kZXJTdGF0ZSh7IGJhc2VMYXllcjogYmFzZUxheWVyIH0pO1xyXG4gICAgICBSZW5kZXIuc2V0RnJhbWVidWZmZXJUYXJnZXQoYmFzZUxheWVyLmZyYW1lYnVmZmVyKTtcclxuICAgICAgUmVuZGVyLnNldENhbnZhc1NpemUoYmFzZUxheWVyLmZyYW1lYnVmZmVyV2lkdGgsIGJhc2VMYXllci5mcmFtZWJ1ZmZlckhlaWdodCk7XHJcbiAgICAgIFJlbmRlci5zZXRSZW5kZXJSZWN0YW5nbGUoUmVjdGFuZ2xlLkdFVCgwLCAwLCBiYXNlTGF5ZXIuZnJhbWVidWZmZXJXaWR0aCwgYmFzZUxheWVyLmZyYW1lYnVmZmVySGVpZ2h0KSk7XHJcbiAgICAgIFJlbmRlci5hZGp1c3RBdHRhY2htZW50cygpO1xyXG4gICAgICB0aGlzLmFkanVzdGluZ0ZyYW1lcyA9IGZhbHNlOyAvLyB3ZWIgeHIgaGFuZGxlcyB0aGlzIG5vd1xyXG4gICAgICB0aGlzLnZyRGV2aWNlID0gPENvbXBvbmVudFZSRGV2aWNlPnRoaXMuY2FtZXJhO1xyXG4gICAgICB0aGlzLmluaXRpYWxpemVSZWZlcmVuY2VTcGFjZSgpO1xyXG5cclxuICAgICAgdGhpcy51c2VWUkNvbnRyb2xsZXIgPSBfdnJDb250cm9sbGVyO1xyXG4gICAgICBpZiAoX3ZyQ29udHJvbGxlcikge1xyXG4gICAgICAgIHRoaXMudnJEZXZpY2UucmlnaHRDbnRybC5jbXBUcmFuc2Zvcm0gPSBuZXcgQ29tcG9uZW50VHJhbnNmb3JtKCk7XHJcbiAgICAgICAgdGhpcy52ckRldmljZS5sZWZ0Q250cmwuY21wVHJhbnNmb3JtID0gbmV3IENvbXBvbmVudFRyYW5zZm9ybSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xyXG5cclxuICAgICAgdGhpcy5wcmVwYXJlQnJhbmNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgQVIgc2Vzc2lvbiBjb3VsZCBiZSBpbml0aWFsaXplZCBoZXJlLiBVcCB0aWxsIG5vdyBub3QgaW1wbGVtZW50ZWQuIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgaW5pdGlhbGl6ZUFSKF9hclNlc3Npb25Nb2RlOiBYUl9TRVNTSU9OX01PREUgPSBudWxsLCBfYXJSZWZlcmVuY2VTcGFjZVR5cGU6IFhSX1JFRkVSRU5DRV9TUEFDRSA9IG51bGwpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgRGVidWcuZXJyb3IoXCJOT1QgSU1QTEVNRU5URUQgWUVUISBDaGVjayBvdXQgaW5pdGlhbGl6ZVZSIVwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhlIHhyIHZpZXdwb3J0IGRpc3BsYXlpbmcgaXRzIGJyYW5jaC4gQnkgZGVmYXVsdCwgdGhlIHRyYW5zZm9ybXMgaW4gdGhlIGJyYW5jaCBhcmUgcmVjYWxjdWxhdGVkIGZpcnN0LlxyXG4gICAgICogUGFzcyBgZmFsc2VgIGlmIGNhbGN1bGF0aW9uIHdhcyBhbHJlYWR5IGRvbmUgZm9yIHRoaXMgZnJhbWUgXHJcbiAgICAgKiBDYWxsZWQgZnJvbSBsb29wIG1ldGhvZCB7QGxpbmsgTG9vcH0gYWdhaW4gd2l0aCB0aGUgeHJGcmFtZSBwYXJhbWV0ZXIgaGFuZG92ZXIsIGFzIHNvb24gYXMgRlJBTUVfUkVRVUVTVF9YUiBpcyBjYWxsZWQgZnJvbSBjcmVhdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZHJhdyhfcHJlcGFyZUJyYW5jaDogYm9vbGVhbiA9IHRydWUsIF94ckZyYW1lOiBYUkZyYW1lID0gbnVsbCk6IHZvaWQge1xyXG4gICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xyXG4gICAgICAgIHN1cGVyLmRyYXcoX3ByZXBhcmVCcmFuY2gpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHBvc2U6IFhSVmlld2VyUG9zZSA9IF94ckZyYW1lPy5nZXRWaWV3ZXJQb3NlKHRoaXMucmVmZXJlbmNlU3BhY2UpO1xyXG4gICAgICBpZiAoIXBvc2UpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgdGhpcy52ckRldmljZS5tdHhMb2NhbC5zZXRBcnJheShwb3NlLnRyYW5zZm9ybS5tYXRyaXgpO1xyXG4gICAgICB0aGlzLnZyRGV2aWNlLm10eExvY2FsLnJvdGF0ZVkoMTgwKTsgLy8gcm90YXRlIGJhY2sgYmVjYXVzZSB0aGUgWFIgUmlnIGlzIGxvb2tpbmcgaW4gdGhlIGRpcmVjdGlvbiBvZiBuZWdhdGl2ZSB6XHJcbiAgICAgIHN1cGVyLnByZXBhcmUoX3ByZXBhcmVCcmFuY2gpO1xyXG5cclxuICAgICAgUmVuZGVyLnJlc2V0RnJhbWVidWZmZXIoKTtcclxuICAgICAgUmVuZGVyLmNsZWFyKHRoaXMuY2FtZXJhLmNsckJhY2tncm91bmQpO1xyXG5cclxuICAgICAgbGV0IGdsTGF5ZXI6IFhSV2ViR0xMYXllciA9IHRoaXMuc2Vzc2lvbi5yZW5kZXJTdGF0ZS5iYXNlTGF5ZXI7XHJcbiAgICAgIGZvciAobGV0IHZpZXcgb2YgcG9zZS52aWV3cykge1xyXG4gICAgICAgIGxldCB2aWV3cG9ydDogZ2xvYmFsVGhpcy5YUlZpZXdwb3J0ID0gZ2xMYXllci5nZXRWaWV3cG9ydCh2aWV3KTtcclxuICAgICAgICBSZW5kZXIuc2V0Vmlld3BvcnQodmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodCk7XHJcbiAgICAgICAgUmVuZGVyLnNldFNjaXNzb3JUZXN0KHRydWUsIHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy51c2VWUkNvbnRyb2xsZXIpXHJcbiAgICAgICAgICB0aGlzLnNldENvbnRyb2xsZXJDb25maWdzKF94ckZyYW1lKTtcclxuXHJcbiAgICAgICAgdGhpcy5jYW1lcmEubXR4UHJvamVjdGlvbi5zZXRBcnJheSh2aWV3LnByb2plY3Rpb25NYXRyaXgpO1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLm10eENhbWVyYUludmVyc2Uuc2V0QXJyYXkodmlldy50cmFuc2Zvcm0uaW52ZXJzZS5tYXRyaXgpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5waHlzaWNzRGVidWdNb2RlICE9IFBIWVNJQ1NfREVCVUdNT0RFLlBIWVNJQ19PQkpFQ1RTX09OTFkpIFxyXG4gICAgICAgICAgUmVuZGVyLmRyYXcodGhpcy5jYW1lcmEpO1xyXG4gICAgICAgIGlmICh0aGlzLnBoeXNpY3NEZWJ1Z01vZGUgIT0gUEhZU0lDU19ERUJVR01PREUuTk9ORSkgXHJcbiAgICAgICAgICBQaHlzaWNzLmRyYXcodGhpcy5jYW1lcmEsIHRoaXMucGh5c2ljc0RlYnVnTW9kZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHJlc2V0IGZvciBvdGhlciByZW5kZXIgb3BlcmF0aW9ucyBlLmcuIHBpY2tpbmdcclxuICAgICAgUmVuZGVyLnNldFNjaXNzb3JUZXN0KGZhbHNlKTtcclxuICAgICAgUmVuZGVyLnNldFJlbmRlclJlY3RhbmdsZShSZW5kZXIuZ2V0UmVuZGVyUmVjdGFuZ2xlKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZSB0aGUgcmVmZXJlbmNlIHNwYWNlIHRvIHNldCB0aGUgaW5pdGlhbCBwb3NpdGlvbi9vcmllbnRhdGlvbiBvZiB0aGUgdnIgZGV2aWNlIGluIGFjY29yZGFuY2UgdG8gdGhlIG5vZGUgdGhlIHZyIGRldmljZSBpcyBhdHRhY2hlZCB0by5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplUmVmZXJlbmNlU3BhY2UoKTogdm9pZCB7XHJcbiAgICAgIGxldCBtdHhXb3JsZDogTWF0cml4NHg0ID0gdGhpcy52ckRldmljZS5ub2RlPy5nZXRDb21wb25lbnQoQ29tcG9uZW50VlJEZXZpY2UpPy5tdHhXb3JsZDtcclxuICAgICAgaWYgKCFtdHhXb3JsZClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBtdHhXb3JsZCA9IG10eFdvcmxkLmNsb25lO1xyXG4gICAgICBtdHhXb3JsZC5yb3RhdGVZKDE4MCk7IC8vIHJvdGF0ZSBiZWNhdXNlIHRoZSBYUiBSaWcgaXMgbG9va2luZyBpbiB0aGUgZGlyZWN0aW9uIG9mIG5lZ2F0aXZlIHpcclxuICAgICAgbGV0IGludk10eFRyYW5zZm9tOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuSU5WRVJTRShtdHhXb3JsZCk7IC8vIGludmVyc2UgYmVjYXVzZSB3ZSBhcmUgbW92aW5nIHRoZSByZWZlcmVuY2Ugc3BhY2VcclxuICAgICAgWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlID0gWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlLmdldE9mZnNldFJlZmVyZW5jZVNwYWNlKG5ldyBYUlJpZ2lkVHJhbnNmb3JtKGludk10eFRyYW5zZm9tLnRyYW5zbGF0aW9uLCBpbnZNdHhUcmFuc2ZvbS5xdWF0ZXJuaW9uKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9TZXRzIGNvbnRyb2xsZXIgbWF0cmljZXMgYW5kIHRodW1ic3RpY2tzIG1vdmVtZW50cy5cclxuICAgIHByaXZhdGUgc2V0Q29udHJvbGxlckNvbmZpZ3MoX3hyRnJhbWU6IFhSRnJhbWUpOiB2b2lkIHtcclxuICAgICAgaWYgKF94ckZyYW1lKSB7XHJcbiAgICAgICAgaWYgKFhSVmlld3BvcnQuZGVmYXVsdC5zZXNzaW9uLmlucHV0U291cmNlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBYUlZpZXdwb3J0LmRlZmF1bHQuc2Vzc2lvbi5pbnB1dFNvdXJjZXMuZm9yRWFjaChfY29udHJvbGxlciA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgc3dpdGNoIChfY29udHJvbGxlci5oYW5kZWRuZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIChcInJpZ2h0XCIpOlxyXG4gICAgICAgICAgICAgICAgICB0aGlzLnZyRGV2aWNlLnJpZ2h0Q250cmwuY21wVHJhbnNmb3JtLm10eExvY2FsLnNldEFycmF5KF94ckZyYW1lLmdldFBvc2UoX2NvbnRyb2xsZXIudGFyZ2V0UmF5U3BhY2UsIFhSVmlld3BvcnQuZGVmYXVsdC5yZWZlcmVuY2VTcGFjZSkudHJhbnNmb3JtLm1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICAgIGlmICghdGhpcy52ckRldmljZS5yaWdodENudHJsLmdhbWVQYWQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ckRldmljZS5yaWdodENudHJsLmdhbWVQYWQgPSBfY29udHJvbGxlci5nYW1lcGFkO1xyXG4gICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZyRGV2aWNlLnJpZ2h0Q250cmwudGh1bWJzdGlja1ggPSBfY29udHJvbGxlci5nYW1lcGFkLmF4ZXNbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ckRldmljZS5yaWdodENudHJsLnRodW1ic3RpY2tZID0gX2NvbnRyb2xsZXIuZ2FtZXBhZC5heGVzWzNdO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAoXCJsZWZ0XCIpOlxyXG4gICAgICAgICAgICAgICAgICB0aGlzLnZyRGV2aWNlLmxlZnRDbnRybC5jbXBUcmFuc2Zvcm0ubXR4TG9jYWwuc2V0QXJyYXkoX3hyRnJhbWUuZ2V0UG9zZShfY29udHJvbGxlci50YXJnZXRSYXlTcGFjZSwgWFJWaWV3cG9ydC5kZWZhdWx0LnJlZmVyZW5jZVNwYWNlKS50cmFuc2Zvcm0ubWF0cml4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmICghdGhpcy52ckRldmljZS5sZWZ0Q250cmwuZ2FtZVBhZClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZyRGV2aWNlLmxlZnRDbnRybC5nYW1lUGFkID0gX2NvbnRyb2xsZXIuZ2FtZXBhZDtcclxuICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ckRldmljZS5sZWZ0Q250cmwudGh1bWJzdGlja1ggPSBfY29udHJvbGxlci5nYW1lcGFkLmF4ZXNbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ckRldmljZS5sZWZ0Q250cmwudGh1bWJzdGlja1kgPSBfY29udHJvbGxlci5nYW1lcGFkLmF4ZXNbM107XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlOiB1bmtub3duKSB7XHJcbiAgICAgICAgICAgICAgRGVidWcuZXJyb3IoXCJJbnB1dCBTb3VyY2VzIEVycm9yOiBcIiArIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIE1hcEZpbGVuYW1lVG9Db250ZW50IHtcclxuICAgIFtmaWxlbmFtZTogc3RyaW5nXTogc3RyaW5nO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBIYW5kbGVzIGZpbGUgdHJhbnNmZXIgZnJvbSBhIEZVREdFLUJyb3dzZXJhcHAgdG8gdGhlIGxvY2FsIGZpbGVzeXN0ZW0gd2l0aG91dCBhIGxvY2FsIHNlcnZlci4gIFxyXG4gICAqIFNhdmVzIHRvIHRoZSBkb3dubG9hZC1wYXRoIGdpdmVuIGJ5IHRoZSBicm93c2VyLCBsb2FkcyBmcm9tIHRoZSBwbGF5ZXIncyBjaG9pY2UuXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEZpbGVJb0Jyb3dzZXJMb2NhbCBleHRlbmRzIEV2ZW50VGFyZ2V0U3RhdGljIHtcclxuICAgIHByaXZhdGUgc3RhdGljIHNlbGVjdG9yOiBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgLy8gVE9ETzogcmVmYWN0b3IgdG8gYXN5bmMgZnVuY3Rpb24gdG8gYmUgaGFuZGxlZCB1c2luZyBwcm9taXNlLCBpbnN0ZWFkIG9mIHVzaW5nIGV2ZW50IHRhcmdldFxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVuIGZpbGUgc2VsZWN0IGRpYWxvZyB0byBsb2FkIGZpbGVzIGZyb20gbG9jYWwgZmlsZXN5c3RlbSBpbnRvIGJyb3dzZXIgYXBwbGljYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZChfbXVsdGlwbGU6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8TWFwRmlsZW5hbWVUb0NvbnRlbnQ+IHtcclxuICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IudHlwZSA9IFwiZmlsZVwiO1xyXG4gICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IubXVsdGlwbGUgPSBfbXVsdGlwbGU7XHJcbiAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC5zZWxlY3Rvci5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICBGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBGaWxlSW9Ccm93c2VyTG9jYWwuaGFuZGxlRmlsZVNlbGVjdCk7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yKTtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxNYXBGaWxlbmFtZVRvQ29udGVudD4oX3Jlc29sdmUgPT4ge1xyXG4gICAgICAgIGZ1bmN0aW9uIGhuZExvYWRlZChfZXZlbnQ6IEV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgICBGaWxlSW9Ccm93c2VyTG9jYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVC5GSUxFX0xPQURFRCwgaG5kTG9hZGVkKTtcclxuICAgICAgICAgIF9yZXNvbHZlKCg8Q3VzdG9tRXZlbnQ+X2V2ZW50KS5kZXRhaWwubWFwRmlsZW5hbWVUb0NvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlQuRklMRV9MT0FERUQsIGhuZExvYWRlZCk7XHJcbiAgICAgICAgRmlsZUlvQnJvd3NlckxvY2FsLnNlbGVjdG9yLmNsaWNrKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIGFzeW5jIGZ1bmN0aW9uIHRvIGJlIGhhbmRsZWQgdXNpbmcgcHJvbWlzZSwgaW5zdGVhZCBvZiB1c2luZyBldmVudCB0YXJnZXRcclxuICAgIC8qKlxyXG4gICAgICogT3BlbiBhIGZpbGUgZG93bmxvYWQgZGlhbG9nIHRvIHNhdmUgZmlsZXMgdG8gbG9jYWwgZmlsZXN5c3RlbS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzYXZlKF90b1NhdmU6IE1hcEZpbGVuYW1lVG9Db250ZW50LCBfdHlwZTogc3RyaW5nID0gXCJ0ZXh0L3BsYWluXCIpOiBQcm9taXNlPE1hcEZpbGVuYW1lVG9Db250ZW50PiB7XHJcbiAgICAgIGZvciAobGV0IGZpbGVuYW1lIGluIF90b1NhdmUpIHtcclxuICAgICAgICBsZXQgY29udGVudDogc3RyaW5nID0gX3RvU2F2ZVtmaWxlbmFtZV07XHJcbiAgICAgICAgbGV0IGJsb2I6IEJsb2IgPSBuZXcgQmxvYihbY29udGVudF0sIHsgdHlwZTogX3R5cGUgfSk7XHJcbiAgICAgICAgbGV0IHVybDogc3RyaW5nID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICAgICAgLy8qLyB1c2luZyBhbmNob3IgZWxlbWVudCBmb3IgZG93bmxvYWRcclxuICAgICAgICBsZXQgZG93bmxvYWRlcjogSFRNTEFuY2hvckVsZW1lbnQ7XHJcbiAgICAgICAgZG93bmxvYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG4gICAgICAgIGRvd25sb2FkZXIuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCB1cmwpO1xyXG4gICAgICAgIGRvd25sb2FkZXIuc2V0QXR0cmlidXRlKFwiZG93bmxvYWRcIiwgZmlsZW5hbWUpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRlcik7XHJcbiAgICAgICAgZG93bmxvYWRlci5jbGljaygpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZG93bmxvYWRlcik7XHJcbiAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPE1hcEZpbGVuYW1lVG9Db250ZW50PihfcmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgX3Jlc29sdmUoX3RvU2F2ZSk7XHJcbiAgICAgICAgLy8gZnVuY3Rpb24gaG5kU2F2ZWQoX2V2ZW50OiBFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIC8vICAgRmlsZUlvQnJvd3NlckxvY2FsLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlQuRklMRV9TQVZFRCwgaG5kU2F2ZWQpO1xyXG4gICAgICAgIC8vICAgX3Jlc29sdmUoKDxDdXN0b21FdmVudD5fZXZlbnQpLmRldGFpbCk7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAvLyBGaWxlSW9Ccm93c2VyTG9jYWwuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVC5GSUxFX1NBVkVELCBobmRTYXZlZCk7XHJcbiAgICAgICAgLy8gbGV0IGV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudChFVkVOVC5GSUxFX1NBVkVELCB7IGRldGFpbDogeyBtYXBGaWxlbmFtZVRvQ29udGVudDogX3RvU2F2ZSB9IH0pO1xyXG4gICAgICAgIC8vIEZpbGVJb0Jyb3dzZXJMb2NhbC50YXJnZXRTdGF0aWMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCB0aGUgdGhlIGZpbGVzIHJlZmVyZW5jZWQgaW4ge0BsaW5rIEZpbGVMaXN0fSBpbnRvIHRoZSBwcm92aWRlZCB7QGxpbmsgTWFwRmlsZW5hbWVUb0NvbnRlbnR9XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZEZpbGVzKF9maWxlTGlzdDogRmlsZUxpc3QsIF9sb2FkZWQ6IE1hcEZpbGVuYW1lVG9Db250ZW50KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIGZvciAobGV0IGZpbGUgb2YgX2ZpbGVMaXN0KSB7XHJcbiAgICAgICAgY29uc3QgY29udGVudDogc3RyaW5nID0gYXdhaXQgbmV3IFJlc3BvbnNlKGZpbGUpLnRleHQoKTtcclxuICAgICAgICBfbG9hZGVkW2ZpbGUubmFtZV0gPSBjb250ZW50O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgaGFuZGxlRmlsZVNlbGVjdChfZXZlbnQ6IEV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIERlYnVnLmZ1ZGdlKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaGFuZGxlRmlsZVNlbGVjdFwiKTtcclxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChGaWxlSW9Ccm93c2VyTG9jYWwuc2VsZWN0b3IpO1xyXG4gICAgICBsZXQgZmlsZUxpc3Q6IEZpbGVMaXN0ID0gKDxIVE1MSW5wdXRFbGVtZW50Pl9ldmVudC50YXJnZXQpLmZpbGVzO1xyXG4gICAgICBEZWJ1Zy5mdWRnZShmaWxlTGlzdCwgZmlsZUxpc3QubGVuZ3RoKTtcclxuICAgICAgaWYgKGZpbGVMaXN0Lmxlbmd0aCA9PSAwKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBsb2FkZWQ6IE1hcEZpbGVuYW1lVG9Db250ZW50ID0ge307XHJcbiAgICAgIGF3YWl0IEZpbGVJb0Jyb3dzZXJMb2NhbC5sb2FkRmlsZXMoZmlsZUxpc3QsIGxvYWRlZCk7XHJcblxyXG4gICAgICBsZXQgZXZlbnQ6IEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KEVWRU5ULkZJTEVfTE9BREVELCB7IGRldGFpbDogeyBtYXBGaWxlbmFtZVRvQ29udGVudDogbG9hZGVkIH0gfSk7XHJcbiAgICAgIEZpbGVJb0Jyb3dzZXJMb2NhbC50YXJnZXRTdGF0aWMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG59ICIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIE11dGFibGUgYXJyYXkgb2Yge0BsaW5rIE11dGFibGV9cy4gVGhlIHtAbGluayBNdXRhdG9yfXMgb2YgdGhlIGVudHJpZXMgYXJlIGluY2x1ZGVkIGFzIGFycmF5IGluIHRoZSB7QGxpbmsgTXV0YXRvcn1cclxuICAgKiBAYXV0aG9yIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIE11dGFibGVBcnJheTxUIGV4dGVuZHMgTXV0YWJsZT4gZXh0ZW5kcyBBcnJheTxUPiB7XHJcbiAgICAjdHlwZTogbmV3ICgpID0+IFQ7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKF90eXBlOiBuZXcgKCkgPT4gVCwgLi4uX2FyZ3M6IFRbXSkge1xyXG4gICAgICBzdXBlciguLi5fYXJncyk7XHJcbiAgICAgIHRoaXMuI3R5cGUgPSBfdHlwZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHR5cGUoKTogbmV3ICgpID0+IFQge1xyXG4gICAgICByZXR1cm4gdGhpcy4jdHlwZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYXJyYW5nZSB0aGUgZW50cmllcyBvZiB0aGUgYXJyYXkgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBzZXF1ZW5jZSBvZiBpbmRpY2VzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWFycmFuZ2UoX3NlcXVlbmNlOiBudW1iZXJbXSk6IHZvaWQge1xyXG4gICAgICBsZXQgbGVuZ3RoOiBudW1iZXIgPSB0aGlzLmxlbmd0aDtcclxuICAgICAgZm9yIChsZXQgaW5kZXggb2YgX3NlcXVlbmNlKSB7XHJcbiAgICAgICAgbGV0IG9yaWdpbmFsOiBUID0gdGhpc1tpbmRleF07XHJcbiAgICAgICAgLy8gVE9ETzogb3B0aW1pemUsIGNvcHkgb25seSBkb3VibGUgZW50cmllc1xyXG4gICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgIGxldCBjb3B5OiBUID0gbmV3IG9yaWdpbmFsLmNvbnN0cnVjdG9yKCk7XHJcbiAgICAgICAgY29weS5tdXRhdGUob3JpZ2luYWwuZ2V0TXV0YXRvcigpKTtcclxuICAgICAgICB0aGlzLnB1c2goY29weSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zcGxpY2UoMCwgbGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgd2l0aCB0aGlzIGFycmF5cyBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHR5cGVzIGFzIHN0cmluZy12YWx1ZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE11dGF0b3JBdHRyaWJ1dGVUeXBlcyhfbXV0YXRvcjogTXV0YXRvcik6IE11dGF0b3JBdHRyaWJ1dGVUeXBlcyB7XHJcbiAgICAgIGxldCB0eXBlczogTXV0YXRvckF0dHJpYnV0ZVR5cGVzID0ge307XHJcbiAgICAgIGZvciAobGV0IGVudHJ5IGluIHRoaXMpXHJcbiAgICAgICAgdHlwZXNbZW50cnldID0gdGhpc1tlbnRyeV0uY29uc3RydWN0b3IubmFtZTtcclxuXHJcbiAgICAgIHJldHVybiB0eXBlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCBlYWNoIGVsZW1lbnRzIG11dGF0b3IgYnkgaW52b2tpbmcge0BsaW5rIE11dGFibGUuZ2V0TXV0YXRvcn0gb24gdGhlbVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvcigpOiBNdXRhdG9yIHtcclxuICAgICAgcmV0dXJuIHRoaXMubWFwKChfdmFsdWUpID0+IF92YWx1ZS5nZXRNdXRhdG9yKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VlIHtAbGluayBNdXRhYmxlLmdldE11dGF0b3JGb3JVc2VySW50ZXJmYWNlfVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0TXV0YXRvckZvclVzZXJJbnRlcmZhY2UoKTogTXV0YXRvciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldE11dGF0b3IoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE11dGF0ZSB0aGUgZWxlbWVudHMgb2YgdGhpcyBhcnJheSBkZWZpbmVkIGJ5IHRoZSBfbXV0YXRvciBieSBpbnZva2luZyB7QGxpbmsgTXV0YWJsZS5tdXRhdGV9IG9uIGl0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiB2b2lkIHwgUHJvbWlzZTx2b2lkPjsgLy8gYWxsb3cgc3luYyBvciBhc3luYyBvdmVycmlkZXNcclxuICAgIHB1YmxpYyBhc3luYyBtdXRhdGUoX211dGF0b3I6IE11dGF0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgZm9yIChsZXQgZW50cnkgaW4gX211dGF0b3IpXHJcbiAgICAgICAgYXdhaXQgdGhpc1s8R2VuZXJhbD5lbnRyeV0ubXV0YXRlKF9tdXRhdG9yW2VudHJ5XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG11dGF0b3IgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlTXV0YXRvcihfbXV0YXRvcjogTXV0YXRvcik6IHZvaWQge1xyXG4gICAgICBmb3IgKGxldCBlbnRyeSBpbiB0aGlzKSB7XHJcbiAgICAgICAgbGV0IG11dGF0b3JWYWx1ZTogT2JqZWN0ID0gX211dGF0b3JbZW50cnldO1xyXG4gICAgICAgIGlmICghbXV0YXRvclZhbHVlKVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKHRoaXNbZW50cnldIGluc3RhbmNlb2YgTXV0YWJsZSlcclxuICAgICAgICAgIF9tdXRhdG9yW2VudHJ5XSA9IHRoaXNbZW50cnldLmdldE11dGF0b3IoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBfbXV0YXRvcltlbnRyeV0gPSB0aGlzW2VudHJ5XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGQlgge1xyXG4gIC8qKlxyXG4gICAqIFJlYWRlciB0byByZWFkIGRhdGEgZnJvbSBhbiBhcnJheSBidWZmZXIgbW9yZSBjb252ZW5pZW50bHkuXHJcbiAgICogSXQgc2F2ZXMgYSBjdXJyZW50IG9mZnNldCB3aGljaCBpcyB1cGRhdGVkIHdoZW4gZGF0YSBpcyByZWFkIGR1ZSB0byBpdHMgYnl0ZWxlbmd0aC5cclxuICAgKiBkZXNwaXRlIGdldFNlcXVlbmNlIGl0IGlzIG1vc3RseSBhIGNvcHkgb2YgdGhlIHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL3BpY29kZTcvYmluYXJ5LXJlYWRlclxyXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgQnVmZmVyUmVhZGVyIHtcclxuICAgIHB1YmxpYyBvZmZzZXQ6IG51bWJlcjtcclxuICAgIHB1YmxpYyByZWFkb25seSB2aWV3OiBEYXRhVmlldztcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoX2J1ZmZlcjogQXJyYXlCdWZmZXJMaWtlKSB7XHJcbiAgICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyhfYnVmZmVyKTtcclxuICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRDaGFyKF9vZmZzZXQ6IG51bWJlciA9IHRoaXMub2Zmc2V0KTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5nZXRVaW50OChfb2Zmc2V0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEJvb2woX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VWludDgoX29mZnNldCkgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0VWludDgoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLm9mZnNldCA9IF9vZmZzZXQgKyAxO1xyXG4gICAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQ4KF9vZmZzZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRVaW50MzIoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLm9mZnNldCA9IF9vZmZzZXQgKyA0O1xyXG4gICAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQzMihfb2Zmc2V0LCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0VWludDY0KF9vZmZzZXQ6IG51bWJlciA9IHRoaXMub2Zmc2V0KTogYmlnaW50IHtcclxuICAgICAgdGhpcy5vZmZzZXQgPSBfb2Zmc2V0ICsgODtcclxuICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRCaWdVaW50NjQoX29mZnNldCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEludDE2KF9vZmZzZXQ6IG51bWJlciA9IHRoaXMub2Zmc2V0KTogbnVtYmVyIHtcclxuICAgICAgdGhpcy5vZmZzZXQgPSBfb2Zmc2V0ICsgMjtcclxuICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRJbnQxNihfb2Zmc2V0LCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0SW50MzIoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLm9mZnNldCA9IF9vZmZzZXQgKyA0O1xyXG4gICAgICByZXR1cm4gdGhpcy52aWV3LmdldEludDMyKF9vZmZzZXQsIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRJbnQ2NChfb2Zmc2V0OiBudW1iZXIgPSB0aGlzLm9mZnNldCk6IGJpZ2ludCB7XHJcbiAgICAgIHRoaXMub2Zmc2V0ID0gX29mZnNldCArIDg7XHJcbiAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0QmlnSW50NjQoX29mZnNldCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEZsb2F0MzIoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLm9mZnNldCA9IF9vZmZzZXQgKyA0O1xyXG4gICAgICByZXR1cm4gdGhpcy52aWV3LmdldEZsb2F0MzIoX29mZnNldCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEZsb2F0NjQoX29mZnNldDogbnVtYmVyID0gdGhpcy5vZmZzZXQpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLm9mZnNldCA9IF9vZmZzZXQgKyA4O1xyXG4gICAgICByZXR1cm4gdGhpcy52aWV3LmdldEZsb2F0NjQoX29mZnNldCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldFN0cmluZyhfbGVuZ3RoOiBudW1iZXIsIF9vZmZzZXQ6IG51bWJlciA9IHRoaXMub2Zmc2V0KTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoLi4udGhpcy5nZXRTZXF1ZW5jZSh0aGlzLmdldFVpbnQ4LCBfbGVuZ3RoLCBfb2Zmc2V0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljICpnZXRTZXF1ZW5jZTxUIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihfZ2V0dGVyOiAoKSA9PiBULCBfbGVuZ3RoOiBudW1iZXIsIF9vZmZzZXQ6IG51bWJlciA9IHRoaXMub2Zmc2V0KTogR2VuZXJhdG9yPFQ+IHtcclxuICAgICAgdGhpcy5vZmZzZXQgPSBfb2Zmc2V0O1xyXG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgX2xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgeWllbGQgX2dldHRlci5jYWxsKHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZCWCB7XHJcbiAgLyoqXHJcbiAgICogSW50ZXJmYWNlIHRvIHJlcHJlc2VudCBmYnggZmlsZXMgY29udGFpbmluZyBpdHMgZG9jdW1lbnRzLCBkZWZpbml0aW9ucywgb2JqZWN0cyBhbmQgY29ubmVjdGlvbnMuXHJcbiAgICogSXRzIG9iamVjdHMgYXJlIGRldmlkZWQgaW4gYWxsIGFuZCB0aGUgZGlmZmVyZW50IG9iamVjdCB0eXBlcy5cclxuICAgKiBAYXV0aG9yIE1hdHRoaWFzIFJvbWluZywgSEZVLCAyMDIzXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBGQlgge1xyXG4gICAgZG9jdW1lbnRzOiBEb2N1bWVudFtdO1xyXG4gICAgZGVmaW5pdGlvbnM/OiBEZWZpbml0aW9ucztcclxuICAgIG9iamVjdHM6IHtcclxuICAgICAgYWxsOiBPYmplY3RbXTtcclxuICAgICAgbW9kZWxzOiBNb2RlbFtdO1xyXG4gICAgICBnZW9tZXRyaWVzOiBHZW9tZXRyeVtdO1xyXG4gICAgICBwb3NlczogT2JqZWN0W107XHJcbiAgICAgIG1hdGVyaWFsczogTWF0ZXJpYWxbXTtcclxuICAgICAgdGV4dHVyZXM6IFRleHR1cmVbXTtcclxuICAgICAgYW5pbVN0YWNrczogT2JqZWN0W107XHJcbiAgICB9O1xyXG4gICAgY29ubmVjdGlvbnM6IENvbm5lY3Rpb25bXTtcclxuICB9XHJcblxyXG4gIGludGVyZmFjZSBPYmplY3RCYXNlIHtcclxuICAgIHVpZDogbnVtYmVyO1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgdHlwZT86IHN0cmluZztcclxuICAgIHN1YnR5cGU/OiBzdHJpbmc7XHJcbiAgICBjaGlsZHJlbj86IE9iamVjdFtdO1xyXG4gICAgcGFyZW50cz86IE9iamVjdFtdO1xyXG5cclxuICAgIGxvYWRlZDogYm9vbGVhbjtcclxuICAgIGxvYWQ6ICgpID0+IE9iamVjdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVyZmFjZSB0byByZXByZXNlbnQgZmJ4LW9iamVjdHMuXHJcbiAgICogQWxsIGZpZWxkcyBvdGhlciB0aGFuIHVpZCwgbmFtZSwgdHlwZSwgc3VidHlwZSwgY2hpbGRyZW4gYW5kIHBhcmVudHMgYXJlIGxvYWRlZCB3aXRoIHRoZSBsb2FkLW1ldGhvZC5cclxuICAgKiBFYWNoIG9iamVjdCBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgYW4gZXhwbGljaXQgZmJ4IG9iamVjdCB0eXBlIGRlZmluZWQgaW4gRnVkZ2VDb3JlLkZCWC4gRXhwbGljaXQgdHlwZXMgaGF2ZSBiZWVuIGRlZmluZWRcclxuICAgKiB3aXRoIHRoZSBoZWxwIG9mIGZvbGxvd2luZyByZWZlcmVuY2U6XHJcbiAgICogaHR0cHM6Ly9hcmNoaXZlLmJsZW5kZXIub3JnL3dpa2kvaW5kZXgucGhwL1VzZXI6TW9udDI5L0ZvdW5kYXRpb24vRkJYX0ZpbGVfU3RydWN0dXJlLyNTb21lX1NwZWNpZmljX1Byb3BlcnR5X1R5cGVzXHJcbiAgICogQGF1dGhvciBNYXR0aGlhcyBSb21pbmcsIEhGVSwgMjAyM1xyXG4gICAqIEBpZ25vcmVcclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE9iamVjdCBleHRlbmRzIE9iamVjdEJhc2Uge1xyXG4gICAgW25hbWU6IHN0cmluZ106IE5vZGVQcm9wZXJ0eSB8IHsgW25hbWU6IHN0cmluZ106IE5vZGVQcm9wZXJ0eSB9IHwgUHJvcGVydHk3MCB8IE9iamVjdCB8IE9iamVjdFtdIHwgKCgpID0+IE9iamVjdCk7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIERvY3VtZW50IGV4dGVuZHMgT2JqZWN0QmFzZSB7XHJcbiAgICBTb3VyY2VPYmplY3Q/OiB1bmRlZmluZWQ7XHJcbiAgICBBY3RpdmVBbmltU3RhY2tOYW1lPzogc3RyaW5nO1xyXG4gICAgUm9vdE5vZGU/OiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIE5vZGVBdHRyaWJ1dGUgZXh0ZW5kcyBPYmplY3RCYXNlIHtcclxuICAgIFR5cGVGbGFncz86IHN0cmluZztcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgR2VvbWV0cnkgZXh0ZW5kcyBPYmplY3RCYXNlIHtcclxuICAgIEdlb21ldHJ5VmVyc2lvbj86IG51bWJlcjtcclxuICAgIFZlcnRpY2VzPzogRmxvYXQzMkFycmF5O1xyXG4gICAgUG9seWdvblZlcnRleEluZGV4PzogSW50MzJBcnJheTtcclxuICAgIExheWVyRWxlbWVudE5vcm1hbD86IExheWVyRWxlbWVudE5vcm1hbDtcclxuICAgIExheWVyRWxlbWVudFVWPzogTGF5ZXJFbGVtZW50VVY7IC8vIHwgTGF5ZXJFbGVtZW50VVZbXTsgLy8gVE9ETzogbWlnaHQgbmVlZCB0byByZWFkZCB0aGlzXHJcbiAgICBMYXllckVsZW1lbnRNYXRlcmlhbD86IExheWVyRWxlbWVudE1hdGVyaWFsO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNb2RlbCBleHRlbmRzIE9iamVjdEJhc2Uge1xyXG4gICAgVmVyc2lvbj86IG51bWJlcjtcclxuICAgIExjbFRyYW5zbGF0aW9uPzogRnVkZ2VDb3JlLlZlY3RvcjMgfCBBbmltQ3VydmVOb2RlO1xyXG4gICAgTGNsUm90YXRpb24/OiBGdWRnZUNvcmUuVmVjdG9yMyB8IEFuaW1DdXJ2ZU5vZGU7XHJcbiAgICBMY2xTY2FsaW5nPzogRnVkZ2VDb3JlLlZlY3RvcjMgfCBBbmltQ3VydmVOb2RlO1xyXG4gICAgUHJlUm90YXRpb24/OiBGdWRnZUNvcmUuVmVjdG9yMztcclxuICAgIFBvc3RSb3RhdGlvbj86IEZ1ZGdlQ29yZS5WZWN0b3IzO1xyXG4gICAgU2NhbGluZ09mZnNldD86IEZ1ZGdlQ29yZS5WZWN0b3IzO1xyXG4gICAgU2NhbGluZ1Bpdm90PzogRnVkZ2VDb3JlLlZlY3RvcjM7XHJcbiAgICBSb3RhdGlvbk9mZnNldD86IEZ1ZGdlQ29yZS5WZWN0b3IzO1xyXG4gICAgUm90YXRpb25QaXZvdD86IEZ1ZGdlQ29yZS5WZWN0b3IzO1xyXG4gICAgSW5oZXJpdFR5cGU/OiBudW1iZXI7XHJcbiAgICBFdWxlck9yZGVyPzogc3RyaW5nO1xyXG4gICAgY3VycmVudFVWU2V0Pzogc3RyaW5nO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNYXRlcmlhbCBleHRlbmRzIE9iamVjdEJhc2Uge1xyXG4gICAgVmVyc2lvbj86IG51bWJlcjtcclxuICAgIFNoYWRpbmdNb2RlbD86IHN0cmluZztcclxuXHJcbiAgICBEaWZmdXNlPzogRnVkZ2VDb3JlLlZlY3RvcjM7XHJcbiAgICBEaWZmdXNlQ29sb3I/OiBGdWRnZUNvcmUuVmVjdG9yMyB8IFRleHR1cmU7XHJcbiAgICBEaWZmdXNlRmFjdG9yPzogbnVtYmVyO1xyXG5cclxuICAgIEFtYmllbnQ/OiBGdWRnZUNvcmUuVmVjdG9yMztcclxuICAgIEFtYmllbnRDb2xvcj86IEZ1ZGdlQ29yZS5WZWN0b3IzIHwgVGV4dHVyZTtcclxuXHJcbiAgICBTaGluaW5lc3M/OiBudW1iZXI7XHJcbiAgICBTaGluaW5lc3NFeHBvbmVudD86IEZ1ZGdlQ29yZS5WZWN0b3IzIHwgVGV4dHVyZTtcclxuXHJcbiAgICBTcGVjdWxhcj86IEZ1ZGdlQ29yZS5WZWN0b3IzO1xyXG4gICAgU3BlY3VsYXJDb2xvcj86IEZ1ZGdlQ29yZS5WZWN0b3IzIHwgVGV4dHVyZTtcclxuICAgIFNwZWN1bGFyRmFjdG9yPzogbnVtYmVyO1xyXG5cclxuICAgIFJlZmxlY3Rpdml0eT86IG51bWJlcjtcclxuICAgIFJlZmxlY3Rpb25GYWN0b3I/OiBudW1iZXI7XHJcblxyXG4gICAgT3BhY2l0eT86IG51bWJlcjtcclxuICAgIFRyYW5zcGFyZW5jeUZhY3Rvcj86IG51bWJlcjtcclxuXHJcbiAgICBFbWlzc2l2ZT86IEZ1ZGdlQ29yZS5WZWN0b3IzO1xyXG4gICAgTm9ybWFsTWFwPzogVGV4dHVyZTtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgRGVmb3JtZXIgZXh0ZW5kcyBPYmplY3RCYXNlIHtcclxuICAgIFZlcnNpb24/OiBudW1iZXI7XHJcbiAgICBTa2lubmluZ1R5cGU/OiBzdHJpbmc7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFN1YkRlZm9ybWVyIGV4dGVuZHMgT2JqZWN0QmFzZSB7XHJcbiAgICBWZXJzaW9uPzogbnVtYmVyO1xyXG4gICAgVHJhbnNmb3JtPzogRmxvYXQzMkFycmF5O1xyXG4gICAgVHJhbnNmb3JtTGluaz86IEZsb2F0MzJBcnJheTtcclxuICAgIEluZGV4ZXM/OiBVaW50MTZBcnJheTtcclxuICAgIFdlaWdodHM/OiBGbG9hdDMyQXJyYXk7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFRleHR1cmUgZXh0ZW5kcyBPYmplY3RCYXNlIHtcclxuICAgIEZpbGVOYW1lPzogc3RyaW5nO1xyXG4gICAgUmVsYXRpdmVGaWxlbmFtZT86IHN0cmluZztcclxuICAgIE1vZGVsVVZTY2FsaW5nPzogbnVtYmVyO1xyXG4gICAgTW9kZWxVVlRyYW5zbGF0aW9uPzogbnVtYmVyO1xyXG4gICAgVVZTZXQ/OiBzdHJpbmc7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFZpZGVvIGV4dGVuZHMgT2JqZWN0QmFzZSB7XHJcbiAgICBGaWxlTmFtZT86IHN0cmluZztcclxuICAgIFJlbGF0aXZlRmlsZW5hbWU/OiBzdHJpbmc7XHJcbiAgICBVc2VNaXBNYXA/OiBudW1iZXI7XHJcbiAgICBDb250ZW50PzogVWludDhBcnJheTtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbUN1cnZlTm9kZSBleHRlbmRzIE9iamVjdEJhc2Uge1xyXG4gICAgZFg/OiBudW1iZXIgfCBBbmltQ3VydmU7XHJcbiAgICBkWT86IG51bWJlciB8IEFuaW1DdXJ2ZTtcclxuICAgIGRaPzogbnVtYmVyIHwgQW5pbUN1cnZlO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBbmltQ3VydmUgZXh0ZW5kcyBPYmplY3RCYXNlIHtcclxuICAgIEtleVZlcj86IG51bWJlcjtcclxuICAgIERlZmF1bHQ/OiBudW1iZXI7XHJcbiAgICBLZXlUaW1lPzogQmlnSW50NjRBcnJheTtcclxuICAgIEtleVZhbHVlRmxvYXQ/OiBGbG9hdDMyQXJyYXk7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIExheWVyRWxlbWVudCB7XHJcbiAgICBOYW1lOiBzdHJpbmc7XHJcbiAgICBWZXJzaW9uOiBudW1iZXI7XHJcbiAgICBNYXBwaW5nSW5mb3JtYXRpb25UeXBlOiBzdHJpbmc7XHJcbiAgICBSZWZlcmVuY2VJbmZvcm1hdGlvblR5cGU6IHN0cmluZztcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTGF5ZXJFbGVtZW50Tm9ybWFsIGV4dGVuZHMgTGF5ZXJFbGVtZW50IHtcclxuICAgIE5vcm1hbHM6IEZsb2F0MzJBcnJheTtcclxuICAgIE5vcm1hbHNXOiBGbG9hdDMyQXJyYXk7XHJcbiAgICBOb3JtYWxzSW5kZXg/OiBVaW50MTZBcnJheTsgLy8gVE9ETzogZmluZCBhbiBGQlggZmlsZSB3aGljaCB1c2VzIG5vcm1hbHMgaW5kZXhcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTGF5ZXJFbGVtZW50VVYgZXh0ZW5kcyBMYXllckVsZW1lbnQge1xyXG4gICAgVVY/OiBGbG9hdDMyQXJyYXk7XHJcbiAgICBVVkluZGV4PzogVWludDE2QXJyYXk7XHJcbiAgfVxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIExheWVyRWxlbWVudE1hdGVyaWFsIGV4dGVuZHMgTGF5ZXJFbGVtZW50IHtcclxuICAgIE1hdGVyaWFscz86IG51bWJlcjtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIE1BUFBJTkdfSU5GT1JNQVRJT05fVFlQRSB7XHJcbiAgICBCWV9WRVJURVgsIEJZX1BPTFlHT04sIEJZX1BPTFlHT05fVkVSVEVYLCBCWV9FREdFLCBBTExfU0FNRVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gUkVGRVJFTkNFX0lORk9STUFUSU9OX1RZUEUge1xyXG4gICAgRElSRUNULCBJTkRFWF9UT19ESVJFQ1RcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29ubmVjdGlvbiB7XHJcbiAgICBwYXJlbnRVSUQ6IG51bWJlcjtcclxuICAgIGNoaWxkVUlEOiBudW1iZXI7XHJcbiAgICBwcm9wZXJ0eU5hbWU6IHN0cmluZztcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgRGVmaW5pdGlvbnMge1xyXG4gICAgdmVyc2lvbjogbnVtYmVyO1xyXG4gICAgb2JqZWN0VHlwZXM6IE9iamVjdFR5cGVbXTtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgT2JqZWN0VHlwZSB7XHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICBjb3VudDogbnVtYmVyO1xyXG4gICAgcHJvcGVydHlUZW1wbGF0ZTogUHJvcGVydHlUZW1wbGF0ZTtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUHJvcGVydHlUZW1wbGF0ZSB7XHJcbiAgICBbcHJvcGVydHlOYW1lOiBzdHJpbmddOiBQcm9wZXJ0eTcwO1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8vIFRPRE86IHJlbW92ZSB0aGlzIGFuZCByZXBsYWNlIGl0IHdpdGggYSBtb3JlIGdlbmVyaWMgYXBwcm9hY2hcclxuICBpbnRlcmZhY2UgQW5pbWF0aW9uU2VxdWVuY2VWZWN0b3IzIGV4dGVuZHMgQW5pbWF0aW9uU3RydWN0dXJlIHtcclxuICAgIHg/OiBBbmltYXRpb25TZXF1ZW5jZTxudW1iZXI+O1xyXG4gICAgeT86IEFuaW1hdGlvblNlcXVlbmNlPG51bWJlcj47XHJcbiAgICB6PzogQW5pbWF0aW9uU2VxdWVuY2U8bnVtYmVyPjtcclxuICB9XHJcblxyXG4gIGludGVyZmFjZSBBbmltYXRpb25TZXF1ZW5jZVZlY3RvcjQgZXh0ZW5kcyBBbmltYXRpb25TdHJ1Y3R1cmUge1xyXG4gICAgeD86IEFuaW1hdGlvblNlcXVlbmNlPG51bWJlcj47XHJcbiAgICB5PzogQW5pbWF0aW9uU2VxdWVuY2U8bnVtYmVyPjtcclxuICAgIHo/OiBBbmltYXRpb25TZXF1ZW5jZTxudW1iZXI+O1xyXG4gICAgdz86IEFuaW1hdGlvblNlcXVlbmNlPG51bWJlcj47XHJcbiAgfVxyXG5cclxuICBpbnRlcmZhY2UgQW5pbWF0aW9uU2VxdWVuY2VNYXRyaXg0eDQgZXh0ZW5kcyBBbmltYXRpb25TdHJ1Y3R1cmUge1xyXG4gICAgcm90YXRpb24/OiBBbmltYXRpb25TZXF1ZW5jZVZlY3RvcjMgfCBBbmltYXRpb25TZXF1ZW5jZVZlY3RvcjQ7XHJcbiAgICBzY2FsZT86IEFuaW1hdGlvblNlcXVlbmNlVmVjdG9yMztcclxuICAgIHRyYW5zbGF0aW9uPzogQW5pbWF0aW9uU2VxdWVuY2VWZWN0b3IzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXNzZXQgbG9hZGVyIGZvciBGaWxtYm94IGZpbGVzLlxyXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgRkJYTG9hZGVyIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGxvYWRlcnM6IHsgW3VyaTogc3RyaW5nXTogRkJYTG9hZGVyIH07XHJcblxyXG4gICAgc3RhdGljICNkZWZhdWx0TWF0ZXJpYWw6IE1hdGVyaWFsO1xyXG4gICAgc3RhdGljICNkZWZhdWx0U2tpbk1hdGVyaWFsOiBNYXRlcmlhbDtcclxuXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgZmJ4OiBGQlguRkJYO1xyXG4gICAgcHVibGljIHJlYWRvbmx5IG5vZGVzOiBGQlguTm9kZVtdO1xyXG4gICAgcHVibGljIHJlYWRvbmx5IHVyaTogc3RyaW5nO1xyXG5cclxuICAgICNzY2VuZXM6IEdyYXBoW107XHJcbiAgICAjbm9kZXM6IE5vZGVbXTtcclxuICAgICNtZXNoZXM6IE1lc2hGQlhbXTtcclxuICAgICNtYXRlcmlhbHM6IE1hdGVyaWFsW107XHJcbiAgICAjc2tpbk1hdGVyaWFsczogTWF0ZXJpYWxbXSA9IFtdO1xyXG4gICAgI3RleHR1cmVzOiBUZXh0dXJlW107XHJcbiAgICAjc2tlbGV0b25zOiBDb21wb25lbnRTa2VsZXRvbltdO1xyXG4gICAgI2FuaW1hdGlvbnM6IEFuaW1hdGlvbltdO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfYnVmZmVyOiBBcnJheUJ1ZmZlciwgX3VyaTogc3RyaW5nKSB7XHJcbiAgICAgIHRoaXMudXJpID0gX3VyaTtcclxuICAgICAgdGhpcy5ub2RlcyA9IEZCWC5wYXJzZU5vZGVzRnJvbUJpbmFyeShfYnVmZmVyKTtcclxuICAgICAgRGVidWcubG9nKHRoaXMubm9kZXMpO1xyXG4gICAgICB0aGlzLmZieCA9IEZCWC5sb2FkRnJvbU5vZGVzKHRoaXMubm9kZXMpO1xyXG4gICAgICBEZWJ1Zy5sb2codGhpcy5mYngpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldCBkZWZhdWx0TWF0ZXJpYWwoKTogTWF0ZXJpYWwge1xyXG4gICAgICByZXR1cm4gdGhpcy4jZGVmYXVsdE1hdGVyaWFsIHx8ICh0aGlzLiNkZWZhdWx0TWF0ZXJpYWwgPVxyXG4gICAgICAgIG5ldyBNYXRlcmlhbChcIkZCWERlZmF1bHRNYXRlcmlhbFwiLCBTaGFkZXJHb3VyYXVkLCBuZXcgQ29hdFJlbWlzc2l2ZShDb2xvci5DU1MoXCJ3aGl0ZVwiKSkpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0IGRlZmF1bHRTa2luTWF0ZXJpYWwoKTogTWF0ZXJpYWwge1xyXG4gICAgICByZXR1cm4gdGhpcy4jZGVmYXVsdFNraW5NYXRlcmlhbCB8fCAodGhpcy4jZGVmYXVsdFNraW5NYXRlcmlhbCA9XHJcbiAgICAgICAgbmV3IE1hdGVyaWFsKFwiRkJYRGVmYXVsdFNraW5NYXRlcmlhbFwiLCBTaGFkZXJHb3VyYXVkU2tpbiwgbmV3IENvYXRSZW1pc3NpdmUoQ29sb3IuQ1NTKFwid2hpdGVcIikpKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgTE9BRChfdXJpOiBzdHJpbmcpOiBQcm9taXNlPEZCWExvYWRlcj4ge1xyXG4gICAgICBpZiAoIXRoaXMubG9hZGVycylcclxuICAgICAgICB0aGlzLmxvYWRlcnMgPSB7fTtcclxuICAgICAgaWYgKCF0aGlzLmxvYWRlcnNbX3VyaV0pIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZTogUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChfdXJpKTtcclxuICAgICAgICBjb25zdCBiaW5hcnk6IEFycmF5QnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcclxuICAgICAgICB0aGlzLmxvYWRlcnNbX3VyaV0gPSBuZXcgRkJYTG9hZGVyKGJpbmFyeSwgX3VyaSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMubG9hZGVyc1tfdXJpXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0U2NlbmUoX2luZGV4OiBudW1iZXIgPSAwKTogUHJvbWlzZTxHcmFwaD4ge1xyXG4gICAgICBpZiAoIXRoaXMuI3NjZW5lcylcclxuICAgICAgICB0aGlzLiNzY2VuZXMgPSBbXTtcclxuICAgICAgaWYgKCF0aGlzLiNzY2VuZXNbX2luZGV4XSkge1xyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50RkJYOiBGQlguRG9jdW1lbnQgPSB0aGlzLmZieC5kb2N1bWVudHNbX2luZGV4XS5sb2FkKCk7XHJcbiAgICAgICAgY29uc3Qgc2NlbmU6IEdyYXBoID0gbmV3IEdyYXBoKGRvY3VtZW50RkJYLm5hbWUpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRGQlggb2YgZG9jdW1lbnRGQlguY2hpbGRyZW4pIHtcclxuICAgICAgICAgIGlmIChjaGlsZEZCWC50eXBlID09IFwiTW9kZWxcIikge1xyXG4gICAgICAgICAgICBzY2VuZS5hZGRDaGlsZChhd2FpdCB0aGlzLmdldE5vZGUodGhpcy5mYngub2JqZWN0cy5tb2RlbHMuaW5kZXhPZihjaGlsZEZCWCkpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmZieC5vYmplY3RzLmFuaW1TdGFja3MgJiYgdGhpcy5mYngub2JqZWN0cy5hbmltU3RhY2tzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbjogQW5pbWF0aW9uID0gYXdhaXQgdGhpcy5nZXRBbmltYXRpb24oZG9jdW1lbnRGQlguQWN0aXZlQW5pbVN0YWNrTmFtZS5sZW5ndGggPiAwID9cclxuICAgICAgICAgICAgdGhpcy5mYngub2JqZWN0cy5hbmltU3RhY2tzLmZpbmRJbmRleChfYW5pbVN0YWNrID0+IF9hbmltU3RhY2submFtZSA9PSBkb2N1bWVudEZCWC5BY3RpdmVBbmltU3RhY2tOYW1lKSA6IDApO1xyXG4gICAgICAgICAgaWYgKGFuaW1hdGlvbilcclxuICAgICAgICAgICAgc2NlbmUuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnRBbmltYXRpb24oYW5pbWF0aW9uKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IHNrZWxldG9uIG9mIHRoaXMuI3NrZWxldG9ucylcclxuICAgICAgICAgIHNjZW5lLmFkZENvbXBvbmVudChza2VsZXRvbik7XHJcblxyXG4gICAgICAgIFByb2plY3QucmVnaXN0ZXIoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMuI3NjZW5lc1tfaW5kZXhdID0gc2NlbmU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuI3NjZW5lc1tfaW5kZXhdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXROb2RlKF9pbmRleDogbnVtYmVyKTogUHJvbWlzZTxOb2RlPiB7XHJcbiAgICAgIGlmICghdGhpcy4jbm9kZXMpXHJcbiAgICAgICAgdGhpcy4jbm9kZXMgPSBbXTtcclxuICAgICAgaWYgKCF0aGlzLiNub2Rlc1tfaW5kZXhdKSB7XHJcbiAgICAgICAgLy8gY3JlYXRlIG5vZGUgd2l0aCB0cmFuc2Zvcm1cclxuICAgICAgICBjb25zdCBtb2RlbEZCWDogRkJYLk1vZGVsID0gdGhpcy5mYngub2JqZWN0cy5tb2RlbHNbX2luZGV4XS5sb2FkKCk7XHJcbiAgICAgICAgY29uc3Qgbm9kZTogTm9kZSA9IG5ldyBOb2RlKG1vZGVsRkJYLm5hbWUpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZ2VuZXJhdGVUcmFuc2Zvcm0obW9kZWxGQlgsIG5vZGUpO1xyXG4gICAgICAgIHRoaXMuI25vZGVzW19pbmRleF0gPSBub2RlO1xyXG5cclxuICAgICAgICAvLyBhdHRhY2ggY2hpbGRyZW4gYW5kIGNvbXBvbmVudHNcclxuICAgICAgICBpZiAobW9kZWxGQlguY2hpbGRyZW4pIGZvciAoY29uc3QgY2hpbGRGQlggb2YgbW9kZWxGQlguY2hpbGRyZW4pIHtcclxuICAgICAgICAgIGlmIChjaGlsZEZCWC50eXBlID09IFwiTW9kZWxcIikge1xyXG4gICAgICAgICAgICBub2RlLmFkZENoaWxkKGF3YWl0IHRoaXMuZ2V0Tm9kZSh0aGlzLmZieC5vYmplY3RzLm1vZGVscy5pbmRleE9mKGNoaWxkRkJYKSkpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChjaGlsZEZCWC50eXBlID09IFwiR2VvbWV0cnlcIikge1xyXG4gICAgICAgICAgICBjb25zdCBtZXNoOiBNZXNoRkJYID0gYXdhaXQgdGhpcy5nZXRNZXNoKHRoaXMuZmJ4Lm9iamVjdHMuZ2VvbWV0cmllcy5pbmRleE9mKGNoaWxkRkJYKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNtcE1lc2g6IENvbXBvbmVudE1lc2ggPSBuZXcgQ29tcG9uZW50TWVzaChtZXNoKTtcclxuICAgICAgICAgICAgbm9kZS5hZGRDb21wb25lbnQobmV3IENvbXBvbmVudE1hdGVyaWFsKEZCWExvYWRlci5kZWZhdWx0TWF0ZXJpYWwpKTtcclxuICAgICAgICAgICAgaWYgKG1lc2gucmVuZGVyTWVzaC5ib25lcykge1xyXG4gICAgICAgICAgICAgIGNtcE1lc2guc2tlbGV0b24gPSBhd2FpdCB0aGlzLmdldFNrZWxldG9uKGNoaWxkRkJYLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdKTtcclxuICAgICAgICAgICAgICAvLyBmb3IgKGNvbnN0IHN1YkRlZm9ybWVyRkJYIG9mIGNoaWxkRkJYLmNoaWxkcmVuWzBdLmNoaWxkcmVuIGFzIEZCWC5TdWJEZWZvcm1lcltdKSB7XHJcbiAgICAgICAgICAgICAgLy8gICBjb25zdCBib25lOiBOb2RlID0gY21wTWVzaC5za2VsZXRvbi5ib25lc1tzdWJEZWZvcm1lckZCWC5jaGlsZHJlblswXS5uYW1lXTtcclxuICAgICAgICAgICAgICAvLyAgIGJvbmUubXR4TG9jYWwuc2V0KHN1YkRlZm9ybWVyRkJYLlRyYW5zZm9ybUxpbmspO1xyXG4gICAgICAgICAgICAgIC8vICAgaWYgKGJvbmUuZ2V0UGFyZW50KCkpXHJcbiAgICAgICAgICAgICAgLy8gICAgIGJvbmUubXR4TG9jYWwubXVsdGlwbHkoYm9uZS5nZXRQYXJlbnQoKS5tdHhXb3JsZEludmVyc2UpO1xyXG4gICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICBub2RlLmdldENvbXBvbmVudChDb21wb25lbnRNYXRlcmlhbCkubWF0ZXJpYWwgPSBGQlhMb2FkZXIuZGVmYXVsdFNraW5NYXRlcmlhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlLmFkZENvbXBvbmVudChjbXBNZXNoKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRGQlgudHlwZSA9PSBcIk1hdGVyaWFsXCIpIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogYWRkaXRpb25hbCBza2luIG1hdGVyaWFscyBnZXQgY3JlYXRlZCBoZXJlLCBjaGVjayBpZiB0aGUgb3JpZ2luYWwgbWF0ZXJpYWwgaXMgc3RpbGwgbmVlZGVkXHJcbiAgICAgICAgICAgIGNvbnN0IGlNYXRlcmlhbDogbnVtYmVyID0gdGhpcy5mYngub2JqZWN0cy5tYXRlcmlhbHMuaW5kZXhPZihjaGlsZEZCWCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsOiBNYXRlcmlhbCA9IGF3YWl0IHRoaXMuZ2V0TWF0ZXJpYWwoaU1hdGVyaWFsKTtcclxuICAgICAgICAgICAgbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWF0ZXJpYWwpLm1hdGVyaWFsID0gbm9kZS5nZXRDb21wb25lbnQoQ29tcG9uZW50TWVzaCkubWVzaC5yZW5kZXJNZXNoLmJvbmVzID9cclxuICAgICAgICAgICAgICB0aGlzLiNza2luTWF0ZXJpYWxzW2lNYXRlcmlhbF0gfHwgKHRoaXMuI3NraW5NYXRlcmlhbHNbaU1hdGVyaWFsXSA9IG5ldyBNYXRlcmlhbChcclxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBtYXRlcmlhbC5nZXRTaGFkZXIoKSA9PSBTaGFkZXJQaG9uZyA/XHJcbiAgICAgICAgICAgICAgICAgIFNoYWRlclBob25nU2tpbiA6XHJcbiAgICAgICAgICAgICAgICAgIFNoYWRlclBob25nVGV4dHVyZWRTa2luLFxyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWwuY29hdFxyXG4gICAgICAgICAgICAgICkpIDpcclxuICAgICAgICAgICAgICBtYXRlcmlhbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuI25vZGVzW19pbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldE1lc2goX2luZGV4OiBudW1iZXIpOiBQcm9taXNlPE1lc2hGQlg+IHtcclxuICAgICAgaWYgKCF0aGlzLiNtZXNoZXMpXHJcbiAgICAgICAgdGhpcy4jbWVzaGVzID0gW107XHJcbiAgICAgIGlmICghdGhpcy4jbWVzaGVzW19pbmRleF0pXHJcbiAgICAgICAgdGhpcy4jbWVzaGVzW19pbmRleF0gPSBhd2FpdCBuZXcgTWVzaEZCWCgpLmxvYWQodGhpcy51cmksIF9pbmRleCk7XHJcbiAgICAgIHJldHVybiB0aGlzLiNtZXNoZXNbX2luZGV4XTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWF0ZXJpYWwoX2luZGV4OiBudW1iZXIpOiBQcm9taXNlPE1hdGVyaWFsPiB7XHJcbiAgICAgIGlmICghdGhpcy4jbWF0ZXJpYWxzKVxyXG4gICAgICAgIHRoaXMuI21hdGVyaWFscyA9IFtdO1xyXG4gICAgICBpZiAoIXRoaXMuI21hdGVyaWFsc1tfaW5kZXhdKSB7XHJcbiAgICAgICAgY29uc3QgbWF0ZXJpYWxGQlg6IEZCWC5NYXRlcmlhbCA9IHRoaXMuZmJ4Lm9iamVjdHMubWF0ZXJpYWxzW19pbmRleF0ubG9hZCgpO1xyXG4gICAgICAgIGlmICghKG1hdGVyaWFsRkJYLkRpZmZ1c2VDb2xvciBpbnN0YW5jZW9mIFZlY3RvcjMpKVxyXG4gICAgICAgICAgbWF0ZXJpYWxGQlguRGlmZnVzZUNvbG9yPy5jaGlsZHJlblswXS5sb2FkKCk7XHJcbiAgICAgICAgLy8gRkJYIHN1cHBvcnRzIGxhbWJlcnQgYW5kIHBob25nIHNoYWRpbmcsIGVpdGhlciB3YXkgZnVkZ2UgaGFzIG5vIGxhbWJlcnQgc2hhZGVyIHNvIHdlIGFsd2F5cyB1c2UgcGhvbmcuXHJcbiAgICAgICAgLy8gSW4gRGlmZnVzZUNvbG9yIHRoZSB0ZXh0dXJlIG9mIHRoZSBtYXRlcmlhbCBjb2xvciBpcyBzdG9yZWQsIGlmIGl0J3MgZGVmaW5lZCB3ZSB1c2UgYSB0ZXh0dXJlIHNoYWRlci5cclxuICAgICAgICAvLyBUT0RPOiBtYXRlcmlhbEZCWCBhbHNvIGNvbnRhaW5zIGFkZGl0aW9uYWwgdmFsdWVzIGxpa2Ugc2hpbmluZXNzIGFuZCByZWZsZWN0aXZpdHkgKGFuZCBvdGhlcnMpIHdoaWNoIGFyZSBub3Qgc3VwcHBvcnRlZC5cclxuICAgICAgICB0aGlzLiNtYXRlcmlhbHNbX2luZGV4XSA9IG5ldyBNYXRlcmlhbChcclxuICAgICAgICAgIG1hdGVyaWFsRkJYLm5hbWUsXHJcbiAgICAgICAgICBtYXRlcmlhbEZCWC5EaWZmdXNlQ29sb3IgJiYgIShtYXRlcmlhbEZCWC5EaWZmdXNlQ29sb3IgaW5zdGFuY2VvZiBWZWN0b3IzKSA/XHJcbiAgICAgICAgICAgIFNoYWRlclBob25nVGV4dHVyZWQgOlxyXG4gICAgICAgICAgICBTaGFkZXJQaG9uZyxcclxuICAgICAgICAgIG1hdGVyaWFsRkJYLkRpZmZ1c2VDb2xvciAmJiAhKG1hdGVyaWFsRkJYLkRpZmZ1c2VDb2xvciBpbnN0YW5jZW9mIFZlY3RvcjMpID9cclxuICAgICAgICAgICAgbmV3IENvYXRSZW1pc3NpdmVUZXh0dXJlZChcclxuICAgICAgICAgICAgICBuZXcgQ29sb3IoLi4ubWF0ZXJpYWxGQlguRGlmZnVzZS5nZXQoKSksXHJcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRUZXh0dXJlKHRoaXMuZmJ4Lm9iamVjdHMudGV4dHVyZXMuaW5kZXhPZihtYXRlcmlhbEZCWC5EaWZmdXNlQ29sb3IpKSxcclxuICAgICAgICAgICAgICBtYXRlcmlhbEZCWC5EaWZmdXNlRmFjdG9yID8/IDEsXHJcbiAgICAgICAgICAgICAgbWF0ZXJpYWxGQlguU3BlY3VsYXJGYWN0b3IgPz8gYXZlcmFnZShtYXRlcmlhbEZCWC5TcGVjdWxhcj8uZ2V0KCkpID8/IDBcclxuICAgICAgICAgICAgKSA6XHJcbiAgICAgICAgICAgIG5ldyBDb2F0UmVtaXNzaXZlKFxyXG4gICAgICAgICAgICAgIG5ldyBDb2xvciguLi4obWF0ZXJpYWxGQlguRGlmZnVzZUNvbG9yIGFzIFZlY3RvcjMgPz8gbWF0ZXJpYWxGQlguRGlmZnVzZSkuZ2V0KCkpLFxyXG4gICAgICAgICAgICAgIG1hdGVyaWFsRkJYLkRpZmZ1c2VGYWN0b3IgPz8gMSxcclxuICAgICAgICAgICAgICBtYXRlcmlhbEZCWC5TcGVjdWxhckZhY3RvciA/PyBhdmVyYWdlKG1hdGVyaWFsRkJYLlNwZWN1bGFyPy5nZXQoKSkgPz8gMFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy4jbWF0ZXJpYWxzW19pbmRleF07XHJcblxyXG4gICAgICBmdW5jdGlvbiBhdmVyYWdlKF9hcnJheTogRmxvYXQzMkFycmF5KTogbnVtYmVyIHsgLy8gVE9ETzogc3BlY3VsYXIgZmFjdG9yIHZlY3RvciAodG9nZXRoZXIgd2l0aCBzcGVjdWxhciBjb2xvciB0ZXh0dXJlKSBpcyBub3Qgc3VwcG9ydGVkIHNvIHdlIHVzZSB0aGUgYXZlcmFnZSBvZiB0aGUgdmVjdG9yIHRvIGFwcHJveGltYXRlIGEgc2luZ3VsYXIgc3BlY3VsYXIgZmFjdG9yLlxyXG4gICAgICAgIGlmIChfYXJyYXkpXHJcbiAgICAgICAgICByZXR1cm4gX2FycmF5LnJlZHVjZSgoX2EsIF9iKSA9PiBfYSArIF9iKSAvIF9hcnJheS5sZW5ndGg7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRUZXh0dXJlKF9pbmRleDogbnVtYmVyKTogUHJvbWlzZTxUZXh0dXJlPiB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcclxuICAgICAgICBpZiAoIXRoaXMuI3RleHR1cmVzKVxyXG4gICAgICAgICAgdGhpcy4jdGV4dHVyZXMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy4jdGV4dHVyZXNbX2luZGV4XSlcclxuICAgICAgICAgIHJldHVybiBfcmVzb2x2ZSh0aGlzLiN0ZXh0dXJlc1tfaW5kZXhdKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmlkZW9GQlg6IEZCWC5WaWRlbyA9IHRoaXMuZmJ4Lm9iamVjdHMudGV4dHVyZXNbX2luZGV4XS5jaGlsZHJlblswXTtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlOiBUZXh0dXJlSW1hZ2UgPSBuZXcgVGV4dHVyZUltYWdlKCk7XHJcbiAgICAgICAgdGV4dHVyZS5pbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIHRleHR1cmUuaW1hZ2Uub25sb2FkID0gKCkgPT4gX3Jlc29sdmUodGV4dHVyZSk7XHJcbiAgICAgICAgdGV4dHVyZS5pbWFnZS5vbmVycm9yID0gX3JlamVjdDtcclxuICAgICAgICB0ZXh0dXJlLmltYWdlLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3ZpZGVvRkJYLkNvbnRlbnRdLCB7IHR5cGU6IFwiaW1hZ2UvcG5nXCIgfSkpO1xyXG4gICAgICAgIHRoaXMuI3RleHR1cmVzW19pbmRleF0gPSB0ZXh0dXJlO1xyXG4gICAgICAgIC8vIFRPRE86IGdldCBhbmQgc2V0IG1pcG1hcCBpbmZvcm1hdGlvbiA/Pz9cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJvYmxlbTogbWVocmVyZSBEZWZvcm1lciB2ZXJ3ZWlzZW4gYXVmIGRhcyBzZWxiZSBTa2VsZXR0IGFiZXIgbnV0emVuIGRhYmVpIG5pY2h0IGltbWVyIGFsbGUgS25vY2hlblxyXG4gICAgLy8gPT4gUHJvYmxlbSBiZXN0ZWh0IGF1Y2ggaW0gR0xURkxvYWRlclxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWVmcyB0aGUgc2tlbGV0b24gY29udGFpbmluZyB0aGUgZ2l2ZW4gbGltYiBub2RlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0U2tlbGV0b24oX2ZieExpbWJOb2RlOiBGQlguTW9kZWwpOiBQcm9taXNlPENvbXBvbmVudFNrZWxldG9uPiB7XHJcbiAgICAgIGlmICghdGhpcy4jc2tlbGV0b25zKVxyXG4gICAgICAgIHRoaXMuI3NrZWxldG9ucyA9IFtdO1xyXG4gICAgICByZXR1cm4gdGhpcy4jc2tlbGV0b25zLmZpbmQoX3NrZWxldG9uID0+IF9mYnhMaW1iTm9kZS5uYW1lIGluIF9za2VsZXRvbi5ib25lcykgfHwgYXdhaXQgKGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBza2VsZXRvbjogQ29tcG9uZW50U2tlbGV0b24gPSBuZXcgQ29tcG9uZW50U2tlbGV0b24oKTsgLy8gbmV3IFNrZWxldG9uKGBTa2VsZXRvbiR7dGhpcy4jc2tlbGV0b25zLmxlbmd0aH1gKTtcclxuICAgICAgICBsZXQgcm9vdE5vZGU6IEZCWC5Nb2RlbCA9IF9mYnhMaW1iTm9kZTtcclxuICAgICAgICB3aGlsZSAocm9vdE5vZGUucGFyZW50cyAmJiByb290Tm9kZS5wYXJlbnRzLnNvbWUoX3BhcmVudCA9PiBfcGFyZW50LnN1YnR5cGUgPT0gXCJMaW1iTm9kZVwiKSlcclxuICAgICAgICAgIHJvb3ROb2RlID0gcm9vdE5vZGUucGFyZW50cy5maW5kKF9wYXJlbnQgPT4gX3BhcmVudC5zdWJ0eXBlID09IFwiTGltYk5vZGVcIik7XHJcbiAgICAgICAgY29uc3QgaVJvb3ROb2RlOiBudW1iZXIgPSB0aGlzLmZieC5vYmplY3RzLm1vZGVscy5maW5kSW5kZXgoX21vZGVsID0+IF9tb2RlbC5uYW1lID09IHJvb3ROb2RlLm5hbWUpO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgYXdhaXQgdGhpcy5nZXROb2RlKGlSb290Tm9kZSkpIHtcclxuICAgICAgICAgIC8vIFRPRE86IG1heWJlIG1vdmUgdGhpcyBpbnRvIHRoZSBjb21wb25lbnQsIGFzIHRoaXMgaXMgcHJvYmFibHkgbmVlZGVkIGluIGdsdGYgaW1wb3J0IGFzd2VsbFxyXG4gICAgICAgICAgaWYgKHRoaXMuZmJ4Lm9iamVjdHMubW9kZWxzW3RoaXMuI25vZGVzLmluZGV4T2Yobm9kZSldLnN1YnR5cGUgPT0gXCJMaW1iTm9kZVwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudDogTm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQpXHJcbiAgICAgICAgICAgICAgbm9kZS5tdHhXb3JsZC5jb3B5KFxyXG4gICAgICAgICAgICAgICAgbm9kZS5jbXBUcmFuc2Zvcm0gP1xyXG4gICAgICAgICAgICAgICAgICBNYXRyaXg0eDQuUFJPRFVDVChwYXJlbnQubXR4V29ybGQsIG5vZGUubXR4TG9jYWwpIDpcclxuICAgICAgICAgICAgICAgICAgcGFyZW50Lm10eFdvcmxkXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgbm9kZS5tdHhXb3JsZEludmVyc2UuY29weShNYXRyaXg0eDQuSU5WRVJTRShub2RlLm10eFdvcmxkKSk7XHJcbiAgICAgICAgICAgIHNrZWxldG9uLmFkZEJvbmUobm9kZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLiNza2VsZXRvbnMucHVzaChza2VsZXRvbik7XHJcbiAgICAgICAgcmV0dXJuIHNrZWxldG9uO1xyXG4gICAgICB9KSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRBbmltYXRpb24oX2luZGV4OiBudW1iZXIpOiBQcm9taXNlPEFuaW1hdGlvbj4ge1xyXG4gICAgICBpZiAoIXRoaXMuI2FuaW1hdGlvbnMpXHJcbiAgICAgICAgdGhpcy4jYW5pbWF0aW9ucyA9IFtdO1xyXG4gICAgICBpZiAoIXRoaXMuI2FuaW1hdGlvbnNbX2luZGV4XSkge1xyXG4gICAgICAgIGNvbnN0IGFuaW1TdGFjazogRkJYLk9iamVjdCA9IHRoaXMuZmJ4Lm9iamVjdHMuYW5pbVN0YWNrc1tfaW5kZXhdO1xyXG4gICAgICAgIGNvbnN0IGFuaW1Ob2Rlc0ZCWDogRkJYLkFuaW1DdXJ2ZU5vZGVbXSA9IGFuaW1TdGFjay5jaGlsZHJlblswXS5jaGlsZHJlbjtcclxuXHJcbiAgICAgICAgbGV0IGZieEFuaW1Ob2RlR3JvdXBlZDogTWFwPEZCWC5Nb2RlbCwgRkJYLkFuaW1DdXJ2ZU5vZGVbXT4gPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBmYnhBbmltTm9kZSBvZiBhbmltTm9kZXNGQlgpIHtcclxuICAgICAgICAgIGNvbnN0IGtleTogRkJYLk1vZGVsID0gZmJ4QW5pbU5vZGUucGFyZW50cy5maW5kKF9wYXJlbnQgPT4gX3BhcmVudC50eXBlID09IFwiTW9kZWxcIik7XHJcbiAgICAgICAgICBpZiAoa2V5ID09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICBpZiAoIWZieEFuaW1Ob2RlR3JvdXBlZC5oYXMoa2V5KSlcclxuICAgICAgICAgICAgZmJ4QW5pbU5vZGVHcm91cGVkLnNldChrZXksIFtdKTtcclxuICAgICAgICAgIGZieEFuaW1Ob2RlR3JvdXBlZC5nZXQoa2V5KS5wdXNoKGZieEFuaW1Ob2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvblN0cnVjdHVyZTogQW5pbWF0aW9uU3RydWN0dXJlID0ge307XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgW2ZieE1vZGVsLCBmYnhBbmltTm9kZXNdIG9mIGZieEFuaW1Ob2RlR3JvdXBlZCkge1xyXG4gICAgICAgICAgbGV0IGN1cnJlbnRTdHJ1Y3R1cmU6IEFuaW1hdGlvblN0cnVjdHVyZSA9IGFuaW1hdGlvblN0cnVjdHVyZTtcclxuXHJcbiAgICAgICAgICBsZXQgcGFyZW50OiBGQlguTW9kZWwgPSBmYnhNb2RlbC5wYXJlbnRzLmZpbmQoX3BhcmVudCA9PiBfcGFyZW50LnR5cGUgPT0gXCJNb2RlbFwiKTtcclxuICAgICAgICAgIGxldCBwYXRoOiBGQlguTW9kZWxbXSA9IFtdO1xyXG4gICAgICAgICAgcGF0aC5wdXNoKGZieE1vZGVsKTtcclxuICAgICAgICAgIHdoaWxlIChwYXJlbnQgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHBhdGgucHVzaChwYXJlbnQpO1xyXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50cy5maW5kKF9wYXJlbnQgPT4gX3BhcmVudC50eXBlID09IFwiTW9kZWxcIik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZm9yIChjb25zdCBmYnhQYXRoTW9kZWwgb2YgcGF0aC5yZXZlcnNlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdHJ1Y3R1cmUuY2hpbGRyZW4gPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmUuY2hpbGRyZW4gPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGlmICgoY3VycmVudFN0cnVjdHVyZS5jaGlsZHJlbiBhcyBBbmltYXRpb25TdHJ1Y3R1cmUpW2ZieFBhdGhNb2RlbC5uYW1lXSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgKGN1cnJlbnRTdHJ1Y3R1cmUuY2hpbGRyZW4gYXMgQW5pbWF0aW9uU3RydWN0dXJlKVtmYnhQYXRoTW9kZWwubmFtZV0gPSB7fTtcclxuICAgICAgICAgICAgY3VycmVudFN0cnVjdHVyZSA9IChjdXJyZW50U3RydWN0dXJlLmNoaWxkcmVuIGFzIEFuaW1hdGlvblN0cnVjdHVyZSlbZmJ4UGF0aE1vZGVsLm5hbWVdIGFzIEFuaW1hdGlvblN0cnVjdHVyZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmYnhQYXRoTW9kZWwgPT0gZmJ4TW9kZWwpIHtcclxuICAgICAgICAgICAgICBjb25zdCBtdHhMb2NhbDogQW5pbWF0aW9uU2VxdWVuY2VNYXRyaXg0eDQgPSB7fTtcclxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZieEFuaW1Ob2RlIG9mIGZieEFuaW1Ob2RlcylcclxuICAgICAgICAgICAgICAgIG10eExvY2FsW3tcclxuICAgICAgICAgICAgICAgICAgVDogXCJ0cmFuc2xhdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgICBSOiBcInJvdGF0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICAgIFM6IFwic2NhbGVcIlxyXG4gICAgICAgICAgICAgICAgfVtmYnhBbmltTm9kZS5uYW1lXV0gPSB0aGlzLmdldEFuaW1hdGlvblZlY3RvcjMoZmJ4QW5pbU5vZGUsIGZieFBhdGhNb2RlbCk7XHJcbiAgICAgICAgICAgICAgY3VycmVudFN0cnVjdHVyZS5jb21wb25lbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50VHJhbnNmb3JtOiBbXHJcbiAgICAgICAgICAgICAgICAgIHsgbXR4TG9jYWw6IG10eExvY2FsIH1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLiNhbmltYXRpb25zW19pbmRleF0gPSBuZXcgQW5pbWF0aW9uKGFuaW1TdGFjay5uYW1lLCBhbmltYXRpb25TdHJ1Y3R1cmUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLiNhbmltYXRpb25zW19pbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmZXRjaGVkIGZyb20gdGhyZWUuanMsIGFkYXB0ZWQgdG8gRlVER0UgYW5kIG9wdGltaXplZFxyXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iL2Rldi9leGFtcGxlcy9qc20vbG9hZGVycy9GQlhMb2FkZXIuanNcclxuICAgICAqIGxpbmUgMzk1MFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlVHJhbnNmb3JtKF9tb2RlbEZCWDogRkJYLk1vZGVsLCBfbm9kZTogTm9kZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICBjb25zdCBwYXJlbnRJbmRleDogbnVtYmVyID0gdGhpcy5mYngub2JqZWN0cy5tb2RlbHMuaW5kZXhPZihfbW9kZWxGQlgucGFyZW50cy5maW5kKF9wYXJlbnQgPT4gX3BhcmVudC50eXBlID09IFwiTW9kZWxcIikpO1xyXG4gICAgICBjb25zdCBwYXJlbnQ6IE5vZGUgPSBwYXJlbnRJbmRleCA+PSAwID8gYXdhaXQgdGhpcy5nZXROb2RlKHBhcmVudEluZGV4KSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIGNvbnN0IG10eExvY2FsUm90YXRpb246IE1hdHJpeDR4NCA9IF9tb2RlbEZCWC5QcmVSb3RhdGlvbiB8fCBfbW9kZWxGQlguTGNsUm90YXRpb24gfHwgX21vZGVsRkJYLlBvc3RSb3RhdGlvbiA/XHJcbiAgICAgICAgTWF0cml4NHg0LklERU5USVRZKCkgOlxyXG4gICAgICAgIHVuZGVmaW5lZDtcclxuICAgICAgaWYgKF9tb2RlbEZCWC5QcmVSb3RhdGlvbikge1xyXG4gICAgICAgIG10eExvY2FsUm90YXRpb24ucm90YXRlKHRoaXMuZ2V0T3JkZXJlZChfbW9kZWxGQlguUHJlUm90YXRpb24sIF9tb2RlbEZCWCkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfbW9kZWxGQlguTGNsUm90YXRpb24pIHtcclxuICAgICAgICBtdHhMb2NhbFJvdGF0aW9uLnJvdGF0ZSh0aGlzLmdldE9yZGVyZWQodGhpcy5nZXRUcmFuc2Zvcm1WZWN0b3IoX21vZGVsRkJYLkxjbFJvdGF0aW9uLCBWZWN0b3IzLlpFUk8pLCBfbW9kZWxGQlgpKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoX21vZGVsRkJYLlBvc3RSb3RhdGlvbikge1xyXG4gICAgICAgIGxldCBtdHhQb3N0Um90YXRpb25JbnZlcnNlOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuUk9UQVRJT04odGhpcy5nZXRPcmRlcmVkKF9tb2RlbEZCWC5Qb3N0Um90YXRpb24sIF9tb2RlbEZCWCkpO1xyXG4gICAgICAgIG10eFBvc3RSb3RhdGlvbkludmVyc2UgPSBNYXRyaXg0eDQuSU5WRVJTRShtdHhQb3N0Um90YXRpb25JbnZlcnNlKTtcclxuICAgICAgICBtdHhMb2NhbFJvdGF0aW9uLm11bHRpcGx5KG10eFBvc3RSb3RhdGlvbkludmVyc2UpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBtdHhMb2NhbFNjYWxpbmc6IE1hdHJpeDR4NCA9IF9tb2RlbEZCWC5MY2xTY2FsaW5nID9cclxuICAgICAgICBNYXRyaXg0eDQuU0NBTElORyh0aGlzLmdldFRyYW5zZm9ybVZlY3RvcihfbW9kZWxGQlguTGNsU2NhbGluZywgVmVjdG9yMy5PTkUpKSA6XHJcbiAgICAgICAgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgY29uc3QgbXR4UGFyZW50V29ybGRSb3RhdGlvbjogTWF0cml4NHg0ID0gcGFyZW50ID8gTWF0cml4NHg0LlJPVEFUSU9OKHBhcmVudC5tdHhXb3JsZC5yb3RhdGlvbikgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICBjb25zdCBtdHhQYXJlbnRXb3JsZFNjYWxlOiBNYXRyaXg0eDQgPSBwYXJlbnQgPyAoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG10eFBhcmVudFdvcmxkU2NhbGU6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5JTlZFUlNFKG10eFBhcmVudFdvcmxkUm90YXRpb24pO1xyXG4gICAgICAgIG10eFBhcmVudFdvcmxkU2NhbGUudHJhbnNsYXRlKFZlY3RvcjMuU0NBTEUocGFyZW50Lm10eFdvcmxkLnRyYW5zbGF0aW9uLCAtMSkpO1xyXG4gICAgICAgIG10eFBhcmVudFdvcmxkU2NhbGUubXVsdGlwbHkocGFyZW50Lm10eFdvcmxkKTtcclxuICAgICAgICByZXR1cm4gbXR4UGFyZW50V29ybGRTY2FsZTtcclxuICAgICAgfSkoKSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIGNvbnN0IG10eFdvcmxkUm90YXRpb25TY2FsZTogTWF0cml4NHg0ID0gcGFyZW50IHx8IG10eExvY2FsUm90YXRpb24gfHwgbXR4TG9jYWxTY2FsaW5nID8gTWF0cml4NHg0LklERU5USVRZKCkgOiB1bmRlZmluZWQ7XHJcbiAgICAgIGlmIChwYXJlbnQgfHwgbXR4TG9jYWxSb3RhdGlvbiB8fCBtdHhMb2NhbFNjYWxpbmcpIHtcclxuICAgICAgICBjb25zdCBpbmhlcml0VHlwZTogbnVtYmVyID0gX21vZGVsRkJYLkluaGVyaXRUeXBlIHx8IDA7XHJcbiAgICAgICAgaWYgKGluaGVyaXRUeXBlID09IDApIHtcclxuICAgICAgICAgIGlmIChwYXJlbnQpXHJcbiAgICAgICAgICAgIG10eFdvcmxkUm90YXRpb25TY2FsZS5tdWx0aXBseShtdHhQYXJlbnRXb3JsZFJvdGF0aW9uKTtcclxuICAgICAgICAgIGlmIChtdHhMb2NhbFJvdGF0aW9uKVxyXG4gICAgICAgICAgICBtdHhXb3JsZFJvdGF0aW9uU2NhbGUubXVsdGlwbHkobXR4TG9jYWxSb3RhdGlvbik7XHJcbiAgICAgICAgICBpZiAocGFyZW50KVxyXG4gICAgICAgICAgICBtdHhXb3JsZFJvdGF0aW9uU2NhbGUubXVsdGlwbHkobXR4UGFyZW50V29ybGRTY2FsZSk7XHJcbiAgICAgICAgICBpZiAobXR4TG9jYWxTY2FsaW5nKVxyXG4gICAgICAgICAgICBtdHhXb3JsZFJvdGF0aW9uU2NhbGUubXVsdGlwbHkobXR4TG9jYWxTY2FsaW5nKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGluaGVyaXRUeXBlID09IDEpIHtcclxuICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgbXR4V29ybGRSb3RhdGlvblNjYWxlLm11bHRpcGx5KG10eFBhcmVudFdvcmxkUm90YXRpb24pO1xyXG4gICAgICAgICAgICBtdHhXb3JsZFJvdGF0aW9uU2NhbGUubXVsdGlwbHkobXR4UGFyZW50V29ybGRTY2FsZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAobXR4TG9jYWxSb3RhdGlvbilcclxuICAgICAgICAgICAgbXR4V29ybGRSb3RhdGlvblNjYWxlLm11bHRpcGx5KG10eExvY2FsUm90YXRpb24pO1xyXG4gICAgICAgICAgaWYgKG10eExvY2FsU2NhbGluZylcclxuICAgICAgICAgICAgbXR4V29ybGRSb3RhdGlvblNjYWxlLm11bHRpcGx5KG10eExvY2FsU2NhbGluZyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChwYXJlbnQpXHJcbiAgICAgICAgICAgIG10eFdvcmxkUm90YXRpb25TY2FsZS5tdWx0aXBseShtdHhQYXJlbnRXb3JsZFJvdGF0aW9uKTtcclxuICAgICAgICAgIGlmIChtdHhMb2NhbFJvdGF0aW9uKVxyXG4gICAgICAgICAgICBtdHhXb3JsZFJvdGF0aW9uU2NhbGUubXVsdGlwbHkobXR4TG9jYWxSb3RhdGlvbik7XHJcbiAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIG10eFdvcmxkUm90YXRpb25TY2FsZS5tdWx0aXBseShtdHhQYXJlbnRXb3JsZFNjYWxlKTtcclxuICAgICAgICAgICAgbGV0IG10eFBhcmVudExvY2FsU2NhbGluZ0ludmVyc2U6IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5TQ0FMSU5HKHBhcmVudC5tdHhMb2NhbC5zY2FsaW5nKTtcclxuICAgICAgICAgICAgbXR4UGFyZW50TG9jYWxTY2FsaW5nSW52ZXJzZSA9IE1hdHJpeDR4NC5JTlZFUlNFKG10eFBhcmVudExvY2FsU2NhbGluZ0ludmVyc2UpO1xyXG4gICAgICAgICAgICBtdHhXb3JsZFJvdGF0aW9uU2NhbGUubXVsdGlwbHkobXR4UGFyZW50TG9jYWxTY2FsaW5nSW52ZXJzZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAobXR4TG9jYWxTY2FsaW5nKVxyXG4gICAgICAgICAgICBtdHhXb3JsZFJvdGF0aW9uU2NhbGUubXVsdGlwbHkobXR4TG9jYWxTY2FsaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbG9jYWwgdHJhbnNmb3JtIG1hdHJpeFxyXG4gICAgICBsZXQgdHJhbnNsYXRpb246IFZlY3RvcjM7XHJcbiAgICAgIHRyYW5zbGF0aW9uID0gVmVjdG9yMy5aRVJPKCk7XHJcbiAgICAgIGlmIChfbW9kZWxGQlguTGNsVHJhbnNsYXRpb24pXHJcbiAgICAgICAgdHJhbnNsYXRpb24uYWRkKHRoaXMuZ2V0VHJhbnNmb3JtVmVjdG9yKF9tb2RlbEZCWC5MY2xUcmFuc2xhdGlvbiwgVmVjdG9yMy5aRVJPKSk7XHJcbiAgICAgIGlmIChfbW9kZWxGQlguUm90YXRpb25PZmZzZXQpXHJcbiAgICAgICAgdHJhbnNsYXRpb24uYWRkKF9tb2RlbEZCWC5Sb3RhdGlvbk9mZnNldCk7XHJcbiAgICAgIGlmIChfbW9kZWxGQlguUm90YXRpb25QaXZvdClcclxuICAgICAgICB0cmFuc2xhdGlvbi5hZGQoX21vZGVsRkJYLlJvdGF0aW9uUGl2b3QpO1xyXG5cclxuICAgICAgY29uc3QgbXR4VHJhbnNmb3JtOiBNYXRyaXg0eDQgPSBNYXRyaXg0eDQuVFJBTlNMQVRJT04odHJhbnNsYXRpb24pO1xyXG4gICAgICBpZiAobXR4TG9jYWxSb3RhdGlvbilcclxuICAgICAgICBtdHhUcmFuc2Zvcm0ubXVsdGlwbHkobXR4TG9jYWxSb3RhdGlvbik7XHJcblxyXG4gICAgICB0cmFuc2xhdGlvbiA9IFZlY3RvcjMuWkVSTygpO1xyXG4gICAgICBpZiAoX21vZGVsRkJYLlJvdGF0aW9uUGl2b3QpXHJcbiAgICAgICAgdHJhbnNsYXRpb24uc3VidHJhY3QoX21vZGVsRkJYLlJvdGF0aW9uUGl2b3QpO1xyXG4gICAgICBpZiAoX21vZGVsRkJYLlNjYWxpbmdPZmZzZXQpXHJcbiAgICAgICAgdHJhbnNsYXRpb24uYWRkKF9tb2RlbEZCWC5TY2FsaW5nT2Zmc2V0KTtcclxuICAgICAgaWYgKF9tb2RlbEZCWC5TY2FsaW5nUGl2b3QpXHJcbiAgICAgICAgdHJhbnNsYXRpb24uYWRkKF9tb2RlbEZCWC5TY2FsaW5nUGl2b3QpO1xyXG4gICAgICBtdHhUcmFuc2Zvcm0udHJhbnNsYXRlKHRyYW5zbGF0aW9uKTtcclxuXHJcbiAgICAgIGlmIChtdHhMb2NhbFNjYWxpbmcpXHJcbiAgICAgICAgbXR4VHJhbnNmb3JtLm11bHRpcGx5KG10eExvY2FsU2NhbGluZyk7XHJcbiAgICAgIGlmIChfbW9kZWxGQlguU2NhbGluZ1Bpdm90KVxyXG4gICAgICAgIG10eFRyYW5zZm9ybS50cmFuc2xhdGUoVmVjdG9yMy5TQ0FMRShfbW9kZWxGQlguU2NhbGluZ1Bpdm90LCAtMSkpO1xyXG5cclxuICAgICAgY29uc3QgbXR4V29ybGRUcmFuc2xhdGlvbjogTWF0cml4NHg0ID0gcGFyZW50ID9cclxuICAgICAgICBNYXRyaXg0eDQuVFJBTlNMQVRJT04oTWF0cml4NHg0LlBST0RVQ1QoXHJcbiAgICAgICAgICBwYXJlbnQubXR4V29ybGQsXHJcbiAgICAgICAgICBNYXRyaXg0eDQuVFJBTlNMQVRJT04obXR4VHJhbnNmb3JtLnRyYW5zbGF0aW9uKVxyXG4gICAgICAgICkudHJhbnNsYXRpb24pIDpcclxuICAgICAgICBNYXRyaXg0eDQuVFJBTlNMQVRJT04obXR4VHJhbnNmb3JtLnRyYW5zbGF0aW9uKTtcclxuXHJcbiAgICAgIG10eFRyYW5zZm9ybS5jb3B5KG10eFdvcmxkVHJhbnNsYXRpb24pO1xyXG4gICAgICBtdHhUcmFuc2Zvcm0ubXVsdGlwbHkobXR4V29ybGRSb3RhdGlvblNjYWxlKTtcclxuICAgICAgX25vZGUubXR4V29ybGQuY29weShtdHhUcmFuc2Zvcm0pO1xyXG5cclxuICAgICAgaWYgKHBhcmVudClcclxuICAgICAgICBtdHhUcmFuc2Zvcm0ubXVsdGlwbHkoTWF0cml4NHg0LklOVkVSU0UocGFyZW50Lm10eFdvcmxkKSwgdHJ1ZSk7XHJcbiAgICAgIF9ub2RlLmFkZENvbXBvbmVudChuZXcgQ29tcG9uZW50VHJhbnNmb3JtKG10eFRyYW5zZm9ybSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0VHJhbnNmb3JtVmVjdG9yKF92ZWN0b3I6IFZlY3RvcjMgfCBGQlguQW5pbUN1cnZlTm9kZSwgX2RlZmF1bHQ6ICgpID0+IFZlY3RvcjMpOiBWZWN0b3IzIHtcclxuICAgICAgcmV0dXJuIChcclxuICAgICAgICBfdmVjdG9yID09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICBfZGVmYXVsdCgpIDpcclxuICAgICAgICAgIF92ZWN0b3IgaW5zdGFuY2VvZiBWZWN0b3IzID9cclxuICAgICAgICAgICAgX3ZlY3RvciA6XHJcbiAgICAgICAgICAgIG5ldyBWZWN0b3IzKFxyXG4gICAgICAgICAgICAgIHR5cGVvZiAoX3ZlY3RvciA9IF92ZWN0b3IubG9hZCgpKS5kWCA9PSBcIm51bWJlclwiID9cclxuICAgICAgICAgICAgICAgIF92ZWN0b3IuZFggOlxyXG4gICAgICAgICAgICAgICAgKF92ZWN0b3IuZFgubG9hZCgpIGFzIEZCWC5BbmltQ3VydmUpLkRlZmF1bHQsXHJcbiAgICAgICAgICAgICAgdHlwZW9mIF92ZWN0b3IuZFkgPT0gXCJudW1iZXJcIiA/XHJcbiAgICAgICAgICAgICAgICBfdmVjdG9yLmRZIDpcclxuICAgICAgICAgICAgICAgIChfdmVjdG9yLmRZLmxvYWQoKSBhcyBGQlguQW5pbUN1cnZlKS5EZWZhdWx0LFxyXG4gICAgICAgICAgICAgIHR5cGVvZiBfdmVjdG9yLmRaID09IFwibnVtYmVyXCIgP1xyXG4gICAgICAgICAgICAgICAgX3ZlY3Rvci5kWiA6XHJcbiAgICAgICAgICAgICAgICAoX3ZlY3Rvci5kWi5sb2FkKCkgYXMgRkJYLkFuaW1DdXJ2ZSkuRGVmYXVsdFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRBbmltYXRpb25WZWN0b3IzKF9hbmltTm9kZTogRkJYLkFuaW1DdXJ2ZU5vZGUsIF90YXJnZXQ6IEZCWC5Nb2RlbCk6IEFuaW1hdGlvblNlcXVlbmNlVmVjdG9yMyB7XHJcbiAgICAgIGNvbnN0IHZlY3RvclNlcXVlbmNlOiBBbmltYXRpb25TZXF1ZW5jZVZlY3RvcjMgPSB7fTtcclxuICAgICAgZm9yIChjb25zdCB2YWx1ZU5hbWUgaW4gX2FuaW1Ob2RlKSBpZiAodmFsdWVOYW1lID09IFwiZFhcIiB8fCB2YWx1ZU5hbWUgPT0gXCJkWVwiIHx8IHZhbHVlTmFtZSA9PSBcImRaXCIpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZTogRkJYLkFuaW1DdXJ2ZSB8IG51bWJlciA9IF9hbmltTm9kZVt2YWx1ZU5hbWVdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgY29uc3Qgc2VxdWVuY2U6IEFuaW1hdGlvblNlcXVlbmNlID0gbmV3IEFuaW1hdGlvblNlcXVlbmNlPG51bWJlcj4oW10sIE51bWJlcik7XHJcbiAgICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdmFsdWUuS2V5VGltZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIHJlZmVyZW5jZSB0aW1lIGlzIGRlZmluZWQgYXMgYSBzaWduZWQgaW50NjQsIHVuaXQgYmVpbmcgMS80NjE4NjE1ODAwMCBzZWNvbmRzXHJcbiAgICAgICAgICAgIC8vIHJlZjogaHR0cHM6Ly9hcmNoaXZlLmJsZW5kZXIub3JnL3dpa2kvaW5kZXgucGhwL1VzZXI6TW9udDI5L0ZvdW5kYXRpb24vRkJYX0ZpbGVfU3RydWN0dXJlLyNTb21lX1NwZWNpZmljX1Byb3BlcnR5X1R5cGVzXHJcbiAgICAgICAgICAgIHNlcXVlbmNlLmFkZEtleShuZXcgQW5pbWF0aW9uS2V5KFxyXG4gICAgICAgICAgICAgIE51bWJlcigodmFsdWUuS2V5VGltZVtpXSAtIHZhbHVlLktleVRpbWUucmVkdWNlKChfbWluLCBfdikgPT4gX3YgPCBfbWluID8gX3YgOiBfbWluKSkgLyBCaWdJbnQoXCI0NjE4NjE1OFwiKSksXHJcbiAgICAgICAgICAgICAgdmFsdWUuS2V5VmFsdWVGbG9hdFtpXVxyXG4gICAgICAgICAgICApKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZlY3RvclNlcXVlbmNlW3ZhbHVlTmFtZVsxXS50b0xvd2VyQ2FzZSgpXSA9IHNlcXVlbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKF9hbmltTm9kZS5uYW1lID09IFwiUlwiICYmIChfdGFyZ2V0LlByZVJvdGF0aW9uIHx8IF90YXJnZXQuUG9zdFJvdGF0aW9uKSkge1xyXG4gICAgICAgIGxldCBwcmVSb3RvdGF0aW9uOiBNYXRyaXg0eDQ7XHJcbiAgICAgICAgaWYgKF90YXJnZXQuUHJlUm90YXRpb24pXHJcbiAgICAgICAgICBwcmVSb3RvdGF0aW9uID0gTWF0cml4NHg0LlJPVEFUSU9OKF90YXJnZXQuUHJlUm90YXRpb24pO1xyXG4gICAgICAgIGxldCBwb3N0Um90YXRpb246IE1hdHJpeDR4NDtcclxuICAgICAgICBpZiAoX3RhcmdldC5Qb3N0Um90YXRpb24pXHJcbiAgICAgICAgICBwb3N0Um90YXRpb24gPSBNYXRyaXg0eDQuUk9UQVRJT04oX3RhcmdldC5Qb3N0Um90YXRpb24pO1xyXG5cclxuICAgICAgICBbdmVjdG9yU2VxdWVuY2UueCwgdmVjdG9yU2VxdWVuY2UueSwgdmVjdG9yU2VxdWVuY2Uuel1cclxuICAgICAgICAgIC5mbGF0TWFwKF9zZXEgPT4gX3NlcT8uZ2V0S2V5cygpKVxyXG4gICAgICAgICAgLm1hcChfa2V5ID0+IF9rZXk/LnRpbWUpXHJcbiAgICAgICAgICAuc29ydCgoX3RpbWVBLCBfdGltZUIpID0+IF90aW1lQSAtIF90aW1lQikgLy8gc29ydCB0aW1lc1xyXG4gICAgICAgICAgLmZpbHRlcigoX3RpbWUsIF9pbmRleCwgX3RpbWVzKSA9PiBfdGltZSAhPSBfdGltZXNbX2luZGV4ICsgMV0pIC8vIHJlbW92ZSBkdXBsaWNhdGVzXHJcbiAgICAgICAgICAubWFwKF90aW1lID0+IHsgLy8gZmluZCBrZXlzIGZvciBhbGwgYXhlcyBhdCB0aW1lXHJcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZpbmRLZXkodmVjdG9yU2VxdWVuY2UueCksIHk6IGZpbmRLZXkodmVjdG9yU2VxdWVuY2UueSksIHo6IGZpbmRLZXkodmVjdG9yU2VxdWVuY2UueikgfTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZmluZEtleShfc2VxdWVuY2U6IEFuaW1hdGlvblNlcXVlbmNlPG51bWJlcj4pOiBBbmltYXRpb25LZXk8bnVtYmVyPiB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIF9zZXF1ZW5jZT8uZ2V0S2V5cygpLmZpbmQoX2tleSA9PiBfa2V5LnRpbWUgPT0gX3RpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLmZvckVhY2goX2ZyYW1lID0+IHtcclxuICAgICAgICAgICAgbGV0IHZjdEV1bGVyQW5nbGVzOiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICAgICAgICB2Y3RFdWxlckFuZ2xlcy5zZXQoXHJcbiAgICAgICAgICAgICAgX2ZyYW1lLng/LnZhbHVlID8/IDAsXHJcbiAgICAgICAgICAgICAgX2ZyYW1lLnk/LnZhbHVlID8/IDAsXHJcbiAgICAgICAgICAgICAgX2ZyYW1lLno/LnZhbHVlID8/IDBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgY29uc3QgbXR4Um90YXRpb246IE1hdHJpeDR4NCA9IE1hdHJpeDR4NC5ST1RBVElPTih2Y3RFdWxlckFuZ2xlcyk7XHJcbiAgICAgICAgICAgIGlmIChwcmVSb3RvdGF0aW9uKVxyXG4gICAgICAgICAgICAgIG10eFJvdGF0aW9uLm11bHRpcGx5KHByZVJvdG90YXRpb24sIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAocG9zdFJvdGF0aW9uKVxyXG4gICAgICAgICAgICAgIG10eFJvdGF0aW9uLm11bHRpcGx5KHBvc3RSb3RhdGlvbik7XHJcbiAgICAgICAgICAgIHZjdEV1bGVyQW5nbGVzID0gbXR4Um90YXRpb24ucm90YXRpb247XHJcbiAgICAgICAgICAgIGlmIChfZnJhbWUueClcclxuICAgICAgICAgICAgICBfZnJhbWUueC52YWx1ZSA9IHZjdEV1bGVyQW5nbGVzLng7XHJcbiAgICAgICAgICAgIGlmIChfZnJhbWUueSlcclxuICAgICAgICAgICAgICBfZnJhbWUueS52YWx1ZSA9IHZjdEV1bGVyQW5nbGVzLnk7XHJcbiAgICAgICAgICAgIGlmIChfZnJhbWUueilcclxuICAgICAgICAgICAgICBfZnJhbWUuei52YWx1ZSA9IHZjdEV1bGVyQW5nbGVzLno7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHZlY3RvclNlcXVlbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0T3JkZXJlZChfcm90YXRpb246IFZlY3RvcjMsIF9tb2RlbEZCWDogRkJYLk1vZGVsKTogVmVjdG9yMyB7XHJcbiAgICAgIGlmICghX21vZGVsRkJYLkV1bGVyT3JkZXIpXHJcbiAgICAgICAgcmV0dXJuIF9yb3RhdGlvbjtcclxuXHJcbiAgICAgIGNvbnN0IGRhdGE6IEZsb2F0MzJBcnJheSA9IF9yb3RhdGlvbi5nZXQoKTtcclxuICAgICAgY29uc3QgcmVzdWx0OiBWZWN0b3IzID0gUmVjeWNsZXIuZ2V0KFZlY3RvcjMpO1xyXG4gICAgICByZXN1bHQuc2V0KFxyXG4gICAgICAgIGRhdGFbX21vZGVsRkJYLkV1bGVyT3JkZXIuaW5kZXhPZihcIlpcIildLFxyXG4gICAgICAgIGRhdGFbX21vZGVsRkJYLkV1bGVyT3JkZXIuaW5kZXhPZihcIllcIildLFxyXG4gICAgICAgIGRhdGFbX21vZGVsRkJYLkV1bGVyT3JkZXIuaW5kZXhPZihcIlhcIildXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGQlgge1xyXG4gIC8qKlxyXG4gICAqIEludGVyZmFjZSB0byByZXByZXNlbnQgZmJ4LW5vZGVzIGNvbnRhaW5pbmcgaXRzIG5hbWUsIGNoaWxkcmVuIGFuZCBwcm9wZXJ0aWVzLlxyXG4gICAqIENoaWxkcmVuIGFuZCBwcm9wZXJpdGVzIGFyZSBsYXp5LlxyXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTm9kZSB7XHJcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xyXG4gICAgXHJcbiAgICBwcml2YXRlIGxvYWRQcm9wZXJ0aWVzOiAoKSA9PiBOb2RlUHJvcGVydHlbXTtcclxuICAgIHByaXZhdGUgbG9hZENoaWxkcmVuOiAoKSA9PiBOb2RlW107XHJcbiAgICBcclxuICAgICNjaGlsZHJlbjogTm9kZVtdO1xyXG4gICAgI3Byb3BlcnRpZXM6IE5vZGVQcm9wZXJ0eVtdO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfbmFtZTogc3RyaW5nLCBfbG9hZFByb3BlcnRpZXM6ICgpID0+IE5vZGVQcm9wZXJ0eVtdLCBfbG9hZENoaWxkcmVuOiAoKSA9PiBOb2RlW10pIHtcclxuICAgICAgdGhpcy5uYW1lID0gX25hbWU7XHJcbiAgICAgIHRoaXMubG9hZFByb3BlcnRpZXMgPSBfbG9hZFByb3BlcnRpZXM7XHJcbiAgICAgIHRoaXMubG9hZENoaWxkcmVuID0gX2xvYWRDaGlsZHJlbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHByb3BlcnRpZXMoKTogTm9kZVByb3BlcnR5W10ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jcHJvcGVydGllcyB8fCAodGhpcy4jcHJvcGVydGllcyA9IHRoaXMubG9hZFByb3BlcnRpZXMoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBjaGlsZHJlbigpOiBOb2RlW10ge1xyXG4gICAgICByZXR1cm4gdGhpcy4jY2hpbGRyZW4gfHwgKHRoaXMuI2NoaWxkcmVuID0gdGhpcy5sb2FkQ2hpbGRyZW4oKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgdHlwZSBQcm9wZXJ0eTcwID0gYm9vbGVhbiB8IG51bWJlciB8IHN0cmluZyB8IEZ1ZGdlQ29yZS5WZWN0b3IzO1xyXG5cclxuICBleHBvcnQgdHlwZSBOb2RlUHJvcGVydHkgPSBib29sZWFuIHwgbnVtYmVyIHwgc3RyaW5nIHwgVWludDhBcnJheSB8IFVpbnQxNkFycmF5IHwgRmxvYXQzMkFycmF5O1xyXG5cclxuICBleHBvcnQgZW51bSBBUlJBWV9FTkNPRElORyB7XHJcbiAgICBVTkNPTVBSRVNTRUQsIENPTVBSRVNTRURcclxuICB9XHJcbiAgXHJcbn0iLCJuYW1lc3BhY2UgRkJYIHtcclxuICAvKipcclxuICAgKiBMb2FkcyBhbiBmYnggZmlsZSBmcm9tIGl0cyBmYngtbm9kZSBhcnJheSB3aGljaCBtYXkgYmUgcmV0cmlldmVkIGJ5IHBhcnNlTm9kZXNGcm9tQmluYXJ5LlxyXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgZnVuY3Rpb24gbG9hZEZyb21Ob2Rlcyhfbm9kZXM6IE5vZGVbXSk6IEZCWCB7XHJcbiAgICBjb25zdCBmYng6IEZCWCA9IHtcclxuICAgICAgZG9jdW1lbnRzOiB1bmRlZmluZWQsXHJcbiAgICAgIG9iamVjdHM6IHtcclxuICAgICAgICBhbGw6IHVuZGVmaW5lZCxcclxuICAgICAgICBtb2RlbHM6IFtdLFxyXG4gICAgICAgIGdlb21ldHJpZXM6IFtdLFxyXG4gICAgICAgIG1hdGVyaWFsczogW10sXHJcbiAgICAgICAgcG9zZXM6IFtdLFxyXG4gICAgICAgIHRleHR1cmVzOiBbXSxcclxuICAgICAgICBhbmltU3RhY2tzOiBbXVxyXG4gICAgICB9LFxyXG4gICAgICBjb25uZWN0aW9uczogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBfbm9kZXMpIHtcclxuICAgICAgaWYgKG5vZGUubmFtZSA9PSBcIkRvY3VtZW50c1wiKVxyXG4gICAgICAgIGZieC5kb2N1bWVudHMgPSBub2RlLmNoaWxkcmVuXHJcbiAgICAgICAgICAuZmlsdGVyKF9kb2N1bWVudE5vZGUgPT4gX2RvY3VtZW50Tm9kZS5uYW1lID09IFwiRG9jdW1lbnRcIilcclxuICAgICAgICAgIC5tYXAoX2RvY3VtZW50Tm9kZSA9PiBnZXREb2N1bWVudChfZG9jdW1lbnROb2RlKSk7XHJcbiAgICAgIGVsc2UgaWYgKG5vZGUubmFtZSA9PSBcIk9iamVjdHNcIilcclxuICAgICAgICBmYngub2JqZWN0cy5hbGwgPSBub2RlLmNoaWxkcmVuLm1hcChfb2JqZWN0Tm9kZSA9PiBnZXRPYmplY3QoX29iamVjdE5vZGUsIGZieCkpO1xyXG4gICAgICBlbHNlIGlmIChub2RlLm5hbWUgPT0gXCJDb25uZWN0aW9uc1wiKVxyXG4gICAgICAgIGZieC5jb25uZWN0aW9ucyA9IG5vZGUuY2hpbGRyZW4ubWFwKF9jb25uZWN0aW9uTm9kZSA9PiBnZXRDb25uZWN0aW9uKF9jb25uZWN0aW9uTm9kZSkpO1xyXG4gICAgICBpZiAoZmJ4LmRvY3VtZW50cyAmJiBmYngub2JqZWN0cy5hbGwgJiYgZmJ4LmNvbm5lY3Rpb25zKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIGdyb3VwT2JqZWN0cyhmYngpO1xyXG4gICAgYXBwbHlDb25uZWN0aW9ucyhmYnguY29ubmVjdGlvbnMsIGZieC5kb2N1bWVudHMsIGZieC5vYmplY3RzLmFsbCk7XHJcblxyXG4gICAgcmV0dXJuIGZieDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldERvY3VtZW50KF9ub2RlOiBOb2RlKTogRG9jdW1lbnQge1xyXG4gICAgY29uc3QgZG9jdW1lbnQ6IE9iamVjdCA9IHtcclxuICAgICAgdWlkOiBfbm9kZS5wcm9wZXJ0aWVzWzBdIGFzIG51bWJlcixcclxuICAgICAgbmFtZTogX25vZGUucHJvcGVydGllc1syXSBhcyBzdHJpbmcsXHJcbiAgICAgIGxvYWRlZDogZmFsc2UsXHJcbiAgICAgIGxvYWQ6ICgpID0+IGxvYWRPYmplY3RQcm9wZXJ0aWVzKF9ub2RlLCBkb2N1bWVudClcclxuICAgIH07XHJcbiAgICByZXR1cm4gZG9jdW1lbnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRPYmplY3QoX25vZGU6IE5vZGUsIF9mYng6IEZCWCk6IE9iamVjdCB7XHJcbiAgICBjb25zdCBuYW1lQW5kVHlwZTogc3RyaW5nW10gPSAoX25vZGUucHJvcGVydGllc1sxXSBhcyBzdHJpbmcpLnNwbGl0KFwiOjpcIik7XHJcbiAgICBjb25zdCBvYmplY3Q6IE9iamVjdCA9IHtcclxuICAgICAgdWlkOiBfbm9kZS5wcm9wZXJ0aWVzWzBdIGFzIG51bWJlcixcclxuICAgICAgbmFtZTogbmFtZUFuZFR5cGVbMF0sXHJcbiAgICAgIHR5cGU6IG5hbWVBbmRUeXBlWzFdLFxyXG4gICAgICBzdWJ0eXBlOiBfbm9kZS5wcm9wZXJ0aWVzWzJdIGFzIHN0cmluZyxcclxuICAgICAgbG9hZGVkOiBmYWxzZSxcclxuICAgICAgbG9hZDogKCkgPT4gbG9hZE9iamVjdFByb3BlcnRpZXMoX25vZGUsIG9iamVjdClcclxuICAgIH07XHJcbiAgICByZXR1cm4gb2JqZWN0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ3JvdXBPYmplY3RzKF9mYng6IEZCWCk6IHZvaWQge1xyXG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YgX2ZieC5vYmplY3RzLmFsbCkge1xyXG4gICAgICBpZiAob2JqZWN0LnR5cGUgPT0gXCJNb2RlbFwiKVxyXG4gICAgICAgIF9mYngub2JqZWN0cy5tb2RlbHMucHVzaChvYmplY3QpO1xyXG4gICAgICBlbHNlIGlmIChvYmplY3QudHlwZSA9PSBcIkdlb21ldHJ5XCIpXHJcbiAgICAgICAgX2ZieC5vYmplY3RzLmdlb21ldHJpZXMucHVzaChvYmplY3QpO1xyXG4gICAgICBlbHNlIGlmIChvYmplY3QudHlwZSA9PSBcIk1hdGVyaWFsXCIpXHJcbiAgICAgICAgX2ZieC5vYmplY3RzLm1hdGVyaWFscy5wdXNoKG9iamVjdCk7XHJcbiAgICAgIGVsc2UgaWYgKG9iamVjdC50eXBlID09IFwiUG9zZVwiKVxyXG4gICAgICAgIF9mYngub2JqZWN0cy5wb3Nlcy5wdXNoKG9iamVjdCk7XHJcbiAgICAgIGVsc2UgaWYgKG9iamVjdC50eXBlID09IFwiVGV4dHVyZVwiKVxyXG4gICAgICAgIF9mYngub2JqZWN0cy50ZXh0dXJlcy5wdXNoKG9iamVjdCk7XHJcbiAgICAgIGVsc2UgaWYgKG9iamVjdC50eXBlID09IFwiQW5pbVN0YWNrXCIpXHJcbiAgICAgICAgX2ZieC5vYmplY3RzLmFuaW1TdGFja3MucHVzaChvYmplY3QpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbihfbm9kZTogTm9kZSk6IENvbm5lY3Rpb24ge1xyXG4gICAgaWYgKCEoX25vZGUucHJvcGVydGllc1swXSA9PSBcIk9PXCIgfHwgX25vZGUucHJvcGVydGllc1swXSA9PSBcIk9QXCIpKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgQ29ubmVjdGlvbiB0eXBlICR7X25vZGUucHJvcGVydGllc1swXX0gaXMgbm90IHN1cHBvcnRlZGApO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNoaWxkVUlEOiBfbm9kZS5wcm9wZXJ0aWVzWzFdIGFzIG51bWJlcixcclxuICAgICAgcGFyZW50VUlEOiBfbm9kZS5wcm9wZXJ0aWVzWzJdIGFzIG51bWJlcixcclxuICAgICAgcHJvcGVydHlOYW1lOiBfbm9kZS5wcm9wZXJ0aWVzWzBdID09IFwiT1BcIiA/IF9ub2RlLnByb3BlcnRpZXNbM10gYXMgc3RyaW5nIDogbnVsbFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGx5Q29ubmVjdGlvbnMoX2Nvbm5lY3Rpb25zOiBDb25uZWN0aW9uW10sIF9kb2N1bWVudHM6IERvY3VtZW50W10sIF9vYmplY3RzOiBPYmplY3RbXSk6IHZvaWQge1xyXG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIF9jb25uZWN0aW9ucykge1xyXG4gICAgICBsZXQgcGFyZW50OiBPYmplY3QgPSBfZG9jdW1lbnRzLmZpbmQoX2RvY3VtZW50ID0+IF9kb2N1bWVudC5sb2FkKCkuUm9vdE5vZGUgPT0gY29ubmVjdGlvbi5wYXJlbnRVSUQpIGFzIE9iamVjdDtcclxuICAgICAgbGV0IGNoaWxkOiBPYmplY3Q7XHJcbiAgICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIF9vYmplY3RzKSB7XHJcbiAgICAgICAgaWYgKHBhcmVudCA9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnVpZCA9PSBjb25uZWN0aW9uLnBhcmVudFVJRClcclxuICAgICAgICAgIHBhcmVudCA9IG9iamVjdDtcclxuICAgICAgICBpZiAoY2hpbGQgPT0gdW5kZWZpbmVkICYmIG9iamVjdC51aWQgPT0gY29ubmVjdGlvbi5jaGlsZFVJRClcclxuICAgICAgICAgIGNoaWxkID0gb2JqZWN0O1xyXG4gICAgICAgIGlmIChwYXJlbnQgIT0gdW5kZWZpbmVkICYmIGNoaWxkICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjaGlsZClcclxuICAgICAgICAoY2hpbGQucGFyZW50cyB8fCAoY2hpbGQucGFyZW50cyA9IFtdKSkucHVzaChwYXJlbnQpO1xyXG4gICAgICBpZiAoY29ubmVjdGlvbi5wcm9wZXJ0eU5hbWUgPT0gbnVsbClcclxuICAgICAgICAocGFyZW50LmNoaWxkcmVuIHx8IChwYXJlbnQuY2hpbGRyZW4gPSBbXSkpLnB1c2goY2hpbGQpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgKHBhcmVudCBhcyBPYmplY3QpW2Zvcm1hdFByb3BlcnR5TmFtZShjb25uZWN0aW9uLnByb3BlcnR5TmFtZSldID0gY2hpbGQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb2FkT2JqZWN0UHJvcGVydGllcyhfbm9kZTogTm9kZSwgX29iamVjdDogT2JqZWN0KTogT2JqZWN0IHtcclxuICAgIGlmIChfb2JqZWN0LmxvYWRlZClcclxuICAgICAgcmV0dXJuIF9vYmplY3Q7XHJcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIF9ub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgIGlmIChjaGlsZC5uYW1lID09IFwiUHJvcGVydGllczcwXCIpXHJcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eTcwIG9mIGNoaWxkLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICBjb25zdCBuYW1lOiBzdHJpbmcgPSBmb3JtYXRQcm9wZXJ0eU5hbWUocHJvcGVydHk3MC5wcm9wZXJ0aWVzWzBdIGFzIHN0cmluZyk7XHJcbiAgICAgICAgICBpZiAoIV9vYmplY3RbbmFtZV0pXHJcbiAgICAgICAgICAgIF9vYmplY3RbbmFtZV0gPSBnZXRQcm9wZXJ0eTcwVmFsdWUocHJvcGVydHk3MCk7XHJcbiAgICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBuYW1lOiBzdHJpbmcgPSBmb3JtYXRQcm9wZXJ0eU5hbWUoY2hpbGQubmFtZSk7XHJcbiAgICAgICAgaWYgKCFfb2JqZWN0W25hbWVdKVxyXG4gICAgICAgICAgX29iamVjdFtuYW1lXSA9IGdldFByb3BlcnR5VmFsdWUoY2hpbGQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfb2JqZWN0LmxvYWRlZCA9IHRydWU7XHJcbiAgICByZXR1cm4gX29iamVjdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFByb3BlcnR5VmFsdWUoX25vZGU6IE5vZGUpOiBOb2RlUHJvcGVydHkgfCBPYmplY3Qge1xyXG4gICAgcmV0dXJuIF9ub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDBcclxuICAgICAgPyBfbm9kZS5jaGlsZHJlbi5yZWR1Y2UoXHJcbiAgICAgICAgKF9zdWJQcm9wZXJ0aWVzLCBfc3ViUHJvcGVydHkpID0+IHtcclxuICAgICAgICAgIGNvbnN0IG5hbWU6IHN0cmluZyA9IGZvcm1hdFByb3BlcnR5TmFtZShfc3ViUHJvcGVydHkubmFtZSk7XHJcbiAgICAgICAgICBpZiAoX3N1YlByb3BlcnRpZXNbbmFtZV0gPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBfc3ViUHJvcGVydGllc1tuYW1lXSA9IGdldFByb3BlcnR5VmFsdWUoX3N1YlByb3BlcnR5KTtcclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIShfc3ViUHJvcGVydGllc1tuYW1lXSBpbnN0YW5jZW9mIEFycmF5KSlcclxuICAgICAgICAgICAgICBfc3ViUHJvcGVydGllc1tuYW1lXSA9IFtfc3ViUHJvcGVydGllc1tuYW1lXSBhcyBPYmplY3RdO1xyXG4gICAgICAgICAgICAoX3N1YlByb3BlcnRpZXNbbmFtZV0gYXMgT2JqZWN0W10pLnB1c2goZ2V0UHJvcGVydHlWYWx1ZShfc3ViUHJvcGVydHkpIGFzIE9iamVjdCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gX3N1YlByb3BlcnRpZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7fSBhcyBPYmplY3RcclxuICAgICAgKVxyXG4gICAgICA6IF9ub2RlLnByb3BlcnRpZXNbMF07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRQcm9wZXJ0eTcwVmFsdWUoX25vZGU6IE5vZGUpOiBQcm9wZXJ0eTcwIHtcclxuICAgIHN3aXRjaCAoX25vZGUucHJvcGVydGllc1sxXSBhcyBzdHJpbmcpIHtcclxuICAgICAgY2FzZSBcImJvb2xcIjpcclxuICAgICAgICByZXR1cm4gX25vZGUucHJvcGVydGllc1s0XSBhcyBib29sZWFuO1xyXG5cclxuICAgICAgY2FzZSBcImludFwiOlxyXG4gICAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICBjYXNlIFwiVUxvbmdMb25nXCI6XHJcbiAgICAgIGNhc2UgXCJkb3VibGVcIjpcclxuICAgICAgY2FzZSBcIk51bWJlclwiOlxyXG4gICAgICBjYXNlIFwiRmllbGRPZlZpZXdcIjpcclxuICAgICAgICByZXR1cm4gX25vZGUucHJvcGVydGllc1s0XSBhcyBudW1iZXI7XHJcblxyXG4gICAgICBjYXNlIFwiQ29sb3JcIjpcclxuICAgICAgY2FzZSBcIkNvbG9yUkdCXCI6XHJcbiAgICAgIGNhc2UgXCJWZWN0b3IzRFwiOlxyXG4gICAgICBjYXNlIFwiTGNsIFRyYW5zbGF0aW9uXCI6XHJcbiAgICAgIGNhc2UgXCJMY2wgUm90YXRpb25cIjpcclxuICAgICAgY2FzZSBcIkxjbCBTY2FsaW5nXCI6XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGdWRnZUNvcmUuVmVjdG9yMyguLi5fbm9kZS5wcm9wZXJ0aWVzLnNsaWNlKDQsIDcpIGFzIG51bWJlcltdKTtcclxuXHJcbiAgICAgIGNhc2UgXCJLU3RyaW5nXCI6XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIF9ub2RlLnByb3BlcnRpZXNbNF0gYXMgc3RyaW5nO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZm9ybWF0UHJvcGVydHlOYW1lKF9uYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIF9uYW1lLnJlcGxhY2UoL1teYS16QS1aXS8sIFwiXCIpO1xyXG4gIH1cclxuXHJcbn0iLCJuYW1lc3BhY2UgRkJYIHtcclxuICAvKipcclxuICAgKiBQYXJzZXMgZmJ4LW5vZGVzIGFycmF5IGZyb20gYSBiaW5hcnkgZmJ4LWZpbGUuXHJcbiAgICogZGVzcGl0ZSB0aGUgbGF6eSBub2RlIGltcGxlbWVudGF0aW9uIGl0IGlzIG1vc3RseSBhIGNvcHkgb2YgdGhlIHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL3BpY29kZTcvZmJ4LXBhcnNlclxyXG4gICAqIEBhdXRob3IgTWF0dGhpYXMgUm9taW5nLCBIRlUsIDIwMjNcclxuICAgKi9cclxuICBleHBvcnQgZnVuY3Rpb24gcGFyc2VOb2Rlc0Zyb21CaW5hcnkoX2J1ZmZlcjogQXJyYXlCdWZmZXIpOiBOb2RlW10ge1xyXG4gICAgaWYgKF9idWZmZXIuYnl0ZUxlbmd0aCA8IGJpbmFyeVN0YXJ0Q2hhcnMubGVuZ3RoKVxyXG4gICAgICB0aHJvdyBcIk5vdCBhIGJpbmFyeSBGQlggZmlsZVwiO1xyXG5cclxuICAgIGNvbnN0IGRhdGE6IEJ1ZmZlclJlYWRlciA9IG5ldyBCdWZmZXJSZWFkZXIoX2J1ZmZlcik7XHJcbiAgICBjb25zdCBmaXJzdENoYXJzOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5nZXRTZXF1ZW5jZShkYXRhLmdldFVpbnQ4LCBiaW5hcnlTdGFydENoYXJzLmxlbmd0aCkpO1xyXG4gICAgY29uc3QgbWF0Y2hlc0ZCWEJpbmFyeUZpcnN0Q2hhcnM6IGJvb2xlYW5cclxuICAgICAgPSBmaXJzdENoYXJzLmV2ZXJ5KChfdmFsdWUsIF9pbmRleCkgPT4gX3ZhbHVlID09IGJpbmFyeVN0YXJ0Q2hhcnNbX2luZGV4XSk7XHJcbiAgICBpZiAoIW1hdGNoZXNGQlhCaW5hcnlGaXJzdENoYXJzKVxyXG4gICAgICB0aHJvdyBcIk5vdCBhIGJpbmFyeSBGQlggZmlsZVwiO1xyXG5cclxuICAgIGNvbnN0IHZlcnNpb246IG51bWJlciA9IGRhdGEuZ2V0VWludDMyKCk7XHJcbiAgICBjb25zdCBub2RlQXR0cmlidXRlc0FzVUludDY0OiBib29sZWFuID0gdmVyc2lvbiA+PSA3NTAwOyAvLyBXYXJ1bSA+PSA3NTAwP1xyXG4gICAgY29uc3Qgbm9kZXM6IE5vZGVbXSA9IFtdO1xyXG5cclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgIGNvbnN0IG5vZGU6IE5vZGUgPSByZWFkTm9kZShkYXRhLCBub2RlQXR0cmlidXRlc0FzVUludDY0KTtcclxuICAgICAgaWYgKG5vZGUgPT0gbnVsbCkgYnJlYWs7XHJcbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5vZGVzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZE5vZGUoX2RhdGE6IEJ1ZmZlclJlYWRlciwgX2F0dHJpYnV0ZXNBc1VpbnQ2NDogYm9vbGVhbik6IE5vZGUge1xyXG4gICAgY29uc3QgZW5kT2Zmc2V0OiBudW1iZXIgPSBfYXR0cmlidXRlc0FzVWludDY0ID8gTnVtYmVyKF9kYXRhLmdldFVpbnQ2NCgpKSA6IF9kYXRhLmdldFVpbnQzMigpO1xyXG4gICAgaWYgKGVuZE9mZnNldCA9PSAwKVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBjb25zdCBwcm9wZXJ0aWVzTGVuZ3RoOiBudW1iZXIgPSBfYXR0cmlidXRlc0FzVWludDY0ID8gTnVtYmVyKF9kYXRhLmdldFVpbnQ2NCgpKSA6IF9kYXRhLmdldFVpbnQzMigpO1xyXG4gICAgY29uc3QgcHJvcGVydGllc0J5dGVMZW5ndGg6IG51bWJlciA9IF9hdHRyaWJ1dGVzQXNVaW50NjQgPyBOdW1iZXIoX2RhdGEuZ2V0VWludDY0KCkpIDogX2RhdGEuZ2V0VWludDMyKCk7XHJcbiAgICBjb25zdCBuYW1lTGVuZ3RoOiBudW1iZXIgPSBfZGF0YS5nZXRVaW50OCgpO1xyXG4gICAgY29uc3QgbmFtZTogc3RyaW5nID0gX2RhdGEuZ2V0U3RyaW5nKG5hbWVMZW5ndGgpO1xyXG4gICAgY29uc3QgcHJvcGVydGllc09mZnNldDogbnVtYmVyID0gX2RhdGEub2Zmc2V0O1xyXG4gICAgY29uc3QgY2hpbGRyZW5PZmZzZXQ6IG51bWJlciA9IHByb3BlcnRpZXNPZmZzZXQgKyBwcm9wZXJ0aWVzQnl0ZUxlbmd0aDtcclxuXHJcbiAgICBjb25zdCBub2RlOiBOb2RlID0gbmV3IE5vZGUoXHJcbiAgICAgIG5hbWUsXHJcbiAgICAgICgpID0+IHtcclxuICAgICAgICBfZGF0YS5vZmZzZXQgPSBwcm9wZXJ0aWVzT2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXM6IE5vZGVQcm9wZXJ0eVtdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaVByb3BlcnR5OiBudW1iZXIgPSAwOyBpUHJvcGVydHkgPCBwcm9wZXJ0aWVzTGVuZ3RoOyBpUHJvcGVydHkrKykge1xyXG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKHJlYWRQcm9wZXJ0eShfZGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcclxuICAgICAgfSxcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIF9kYXRhLm9mZnNldCA9IGNoaWxkcmVuT2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuOiBOb2RlW10gPSBbXTtcclxuICAgICAgICB3aGlsZSAoZW5kT2Zmc2V0IC0gX2RhdGEub2Zmc2V0ID4gbnVsbENvdW50QXROb2RlRW5kKSB7XHJcbiAgICAgICAgICBjb25zdCBjaGlsZDogRkJYLk5vZGUgPSByZWFkTm9kZShfZGF0YSwgX2F0dHJpYnV0ZXNBc1VpbnQ2NCk7XHJcbiAgICAgICAgICBpZiAoY2hpbGQpIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgX2RhdGEub2Zmc2V0ID0gZW5kT2Zmc2V0O1xyXG5cclxuICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZFByb3BlcnR5KF9kYXRhOiBCdWZmZXJSZWFkZXIpOiBGQlguTm9kZVByb3BlcnR5IHtcclxuICAgIGNvbnN0IHR5cGVDb2RlOiBzdHJpbmcgPSBfZGF0YS5nZXRDaGFyKCk7XHJcblxyXG4gICAgY29uc3QgdmFsdWU6IEZCWC5Ob2RlUHJvcGVydHkgPSB7XHJcbiAgICAgIEM6IF9kYXRhLmdldEJvb2wsXHJcbiAgICAgIFk6IF9kYXRhLmdldEludDE2LFxyXG4gICAgICBJOiBfZGF0YS5nZXRJbnQzMixcclxuICAgICAgTDogX2RhdGEuZ2V0SW50NjQsXHJcbiAgICAgIEY6IF9kYXRhLmdldEZsb2F0MzIsXHJcbiAgICAgIEQ6IF9kYXRhLmdldEZsb2F0NjQsXHJcbiAgICAgIFM6ICgpID0+IF9kYXRhLmdldFN0cmluZyhfZGF0YS5nZXRVaW50MzIoKSkucmVwbGFjZShcIlxceDAwXFx4MDFcIiwgXCI6OlwiKSxcclxuICAgICAgczogKCkgPT4gX2RhdGEuZ2V0U3RyaW5nKF9kYXRhLmdldFVpbnQzMigpKS5yZXBsYWNlKFwiXFx4MDBcXHgwMVwiLCBcIjo6XCIpLFxyXG4gICAgICBSOiAoKSA9PiBuZXcgVWludDhBcnJheShyZWFkUmF3KF9kYXRhLCBfZGF0YS5nZXRVaW50OCkpLFxyXG4gICAgICByOiAoKSA9PiBuZXcgVWludDhBcnJheShyZWFkQXJyYXkoX2RhdGEsIF9kYXRhLmdldFVpbnQ4KSksXHJcbiAgICAgIGI6ICgpID0+IG5ldyBVaW50OEFycmF5KHJlYWRBcnJheShfZGF0YSwgX2RhdGEuZ2V0VWludDgpKSxcclxuICAgICAgaTogKCkgPT4gbmV3IEludDMyQXJyYXkocmVhZEFycmF5KF9kYXRhLCBfZGF0YS5nZXRJbnQzMikpLFxyXG4gICAgICBsOiAoKSA9PiBuZXcgQmlnSW50NjRBcnJheShyZWFkQXJyYXkoX2RhdGEsIF9kYXRhLmdldEludDY0KSksXHJcbiAgICAgIGY6ICgpID0+IG5ldyBGbG9hdDMyQXJyYXkocmVhZEFycmF5KF9kYXRhLCBfZGF0YS5nZXRGbG9hdDMyKSksXHJcbiAgICAgIGQ6ICgpID0+IG5ldyBGbG9hdDMyQXJyYXkocmVhZEFycmF5KF9kYXRhLCBfZGF0YS5nZXRGbG9hdDY0KSlcclxuICAgIH1bdHlwZUNvZGVdPy5jYWxsKF9kYXRhKTtcclxuXHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcclxuICAgICAgRnVkZ2VDb3JlLkRlYnVnLndhcm4oYFVua25vd24gcHJvcGVydHkgdHlwZSAke3R5cGVDb2RlLmNoYXJDb2RlQXQoMCl9YCk7XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZEFycmF5PFQgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KF9kYXRhOiBCdWZmZXJSZWFkZXIsIF9nZXR0ZXI6ICgpID0+IFQpOiBHZW5lcmF0b3I8VD4ge1xyXG4gICAgY29uc3QgbGVuZ3RoOiBudW1iZXIgPSBfZGF0YS5nZXRVaW50MzIoKTtcclxuICAgIGNvbnN0IGVuY29kaW5nOiBGQlguQVJSQVlfRU5DT0RJTkcgPSBfZGF0YS5nZXRVaW50MzIoKTtcclxuICAgIGNvbnN0IGJ5dGVMZW5ndGg6IG51bWJlciA9IF9kYXRhLmdldFVpbnQzMigpO1xyXG4gICAgY29uc3QgZW5kT2Zmc2V0OiBudW1iZXIgPSBfZGF0YS5vZmZzZXQgKyBieXRlTGVuZ3RoO1xyXG5cclxuICAgIGNvbnN0IGl0ZXJhYmxlOiBHZW5lcmF0b3I8VD4gPSBlbmNvZGluZyA9PSBGQlguQVJSQVlfRU5DT0RJTkcuQ09NUFJFU1NFRCA/XHJcbiAgICAgICgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYXJyYXlEYXRhOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoX2RhdGEudmlldy5idWZmZXIsIF9kYXRhLm9mZnNldCwgYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgaW5mbGF0ZWREYXRhOiBVaW50OEFycmF5ID0gKFJlZmxlY3QuZ2V0KGdsb2JhbFRoaXMsIFwicGFrb1wiKSA/IHBha28uaW5mbGF0ZSA6IGZmbGF0ZS5pbmZsYXRlU3luYykoYXJyYXlEYXRhKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlclJlYWRlcihpbmZsYXRlZERhdGEuYnVmZmVyKS5nZXRTZXF1ZW5jZShfZ2V0dGVyLCBsZW5ndGgpO1xyXG4gICAgICB9KSgpIDpcclxuICAgICAgX2RhdGEuZ2V0U2VxdWVuY2UoX2dldHRlciwgbGVuZ3RoKTtcclxuXHJcbiAgICBfZGF0YS5vZmZzZXQgPSBlbmRPZmZzZXQ7XHJcblxyXG4gICAgcmV0dXJuIGl0ZXJhYmxlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZFJhdzxUIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihfZGF0YTogQnVmZmVyUmVhZGVyLCBfZ2V0dGVyOiAoKSA9PiBUKTogR2VuZXJhdG9yPFQ+IHtcclxuICAgIC8vIHJhdyBiaW5hcnkgZGF0YSBuZWVkcyB0byBiZSBpbnRlcnByZXRlZCBpbiBhIHNwZWNpYWwgd2F5IHNlZTpcclxuICAgIC8vIGh0dHBzOi8vY29kZS5ibGVuZGVyLm9yZy8yMDEzLzA4L2ZieC1iaW5hcnktZmlsZS1mb3JtYXQtc3BlY2lmaWNhdGlvbi9cclxuICAgIGNvbnN0IGxlbmd0aDogbnVtYmVyID0gX2RhdGEuZ2V0VWludDMyKCk7XHJcbiAgICByZXR1cm4gX2RhdGEuZ2V0U2VxdWVuY2UoX2dldHRlciwgbGVuZ3RoKTs7XHJcbiAgfVxyXG5cclxuICBjb25zdCBiaW5hcnlTdGFydENoYXJzOiBVaW50OEFycmF5XHJcbiAgICA9IFVpbnQ4QXJyYXkuZnJvbShcIktheWRhcmEgRkJYIEJpbmFyeVxceDIwXFx4MjBcXHgwMFxceDFhXFx4MDBcIi5zcGxpdChcIlwiKSwgX3YgPT4gX3YuY2hhckNvZGVBdCgwKSk7XHJcblxyXG4gIGNvbnN0IG51bGxDb3VudEF0Tm9kZUVuZDogbnVtYmVyID0gMTM7XHJcblxyXG59IiwibmFtZXNwYWNlIEdMVEYge1xyXG4gIGV4cG9ydCB0eXBlIEdsVGZJZCA9IG51bWJlcjtcclxuICAvKipcclxuICAgKiBBbiBvYmplY3QgcG9pbnRpbmcgdG8gYSBidWZmZXIgdmlldyBjb250YWluaW5nIHRoZSBpbmRpY2VzIG9mIGRldmlhdGluZyBhY2Nlc3NvciB2YWx1ZXMuIFRoZSBudW1iZXIgb2YgaW5kaWNlcyBpcyBlcXVhbCB0byBgYWNjZXNzb3Iuc3BhcnNlLmNvdW50YC4gSW5kaWNlcyAqKk1VU1QqKiBzdHJpY3RseSBpbmNyZWFzZS5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFjY2Vzc29yU3BhcnNlSW5kaWNlcyB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIHZpZXcgd2l0aCBzcGFyc2UgaW5kaWNlcy4gVGhlIHJlZmVyZW5jZWQgYnVmZmVyIHZpZXcgKipNVVNUIE5PVCoqIGhhdmUgaXRzIGB0YXJnZXRgIG9yIGBieXRlU3RyaWRlYCBwcm9wZXJ0aWVzIGRlZmluZWQuIFRoZSBidWZmZXIgdmlldyBhbmQgdGhlIG9wdGlvbmFsIGBieXRlT2Zmc2V0YCAqKk1VU1QqKiBiZSBhbGlnbmVkIHRvIHRoZSBgY29tcG9uZW50VHlwZWAgYnl0ZSBsZW5ndGguXHJcbiAgICAgKi9cclxuICAgIFwiYnVmZmVyVmlld1wiOiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBidWZmZXIgdmlldyBpbiBieXRlcy5cclxuICAgICAqL1xyXG4gICAgXCJieXRlT2Zmc2V0XCI/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRpY2VzIGRhdGEgdHlwZS5cclxuICAgICAqL1xyXG4gICAgXCJjb21wb25lbnRUeXBlXCI6IENPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX0JZVEUgfCBDT01QT05FTlRfVFlQRS5VTlNJR05FRF9TSE9SVCB8IENPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX0lOVDtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEFuIG9iamVjdCBwb2ludGluZyB0byBhIGJ1ZmZlciB2aWV3IGNvbnRhaW5pbmcgdGhlIGRldmlhdGluZyBhY2Nlc3NvciB2YWx1ZXMuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaXMgZXF1YWwgdG8gYGFjY2Vzc29yLnNwYXJzZS5jb3VudGAgdGltZXMgbnVtYmVyIG9mIGNvbXBvbmVudHMuIFRoZSBlbGVtZW50cyBoYXZlIHRoZSBzYW1lIGNvbXBvbmVudCB0eXBlIGFzIHRoZSBiYXNlIGFjY2Vzc29yLiBUaGUgZWxlbWVudHMgYXJlIHRpZ2h0bHkgcGFja2VkLiBEYXRhICoqTVVTVCoqIGJlIGFsaWduZWQgZm9sbG93aW5nIHRoZSBzYW1lIHJ1bGVzIGFzIHRoZSBiYXNlIGFjY2Vzc29yLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQWNjZXNzb3JTcGFyc2VWYWx1ZXMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGJ1ZmZlclZpZXcgd2l0aCBzcGFyc2UgdmFsdWVzLiBUaGUgcmVmZXJlbmNlZCBidWZmZXIgdmlldyAqKk1VU1QgTk9UKiogaGF2ZSBpdHMgYHRhcmdldGAgb3IgYGJ5dGVTdHJpZGVgIHByb3BlcnRpZXMgZGVmaW5lZC5cclxuICAgICAqL1xyXG4gICAgXCJidWZmZXJWaWV3XCI6IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGJ1ZmZlclZpZXcgaW4gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIFwiYnl0ZU9mZnNldFwiPzogbnVtYmVyO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU3BhcnNlIHN0b3JhZ2Ugb2YgYWNjZXNzb3IgdmFsdWVzIHRoYXQgZGV2aWF0ZSBmcm9tIHRoZWlyIGluaXRpYWxpemF0aW9uIHZhbHVlLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQWNjZXNzb3JTcGFyc2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBOdW1iZXIgb2YgZGV2aWF0aW5nIGFjY2Vzc29yIHZhbHVlcyBzdG9yZWQgaW4gdGhlIHNwYXJzZSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgXCJjb3VudFwiOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCBwb2ludGluZyB0byBhIGJ1ZmZlciB2aWV3IGNvbnRhaW5pbmcgdGhlIGluZGljZXMgb2YgZGV2aWF0aW5nIGFjY2Vzc29yIHZhbHVlcy4gVGhlIG51bWJlciBvZiBpbmRpY2VzIGlzIGVxdWFsIHRvIGBjb3VudGAuIEluZGljZXMgKipNVVNUKiogc3RyaWN0bHkgaW5jcmVhc2UuXHJcbiAgICAgKi9cclxuICAgIFwiaW5kaWNlc1wiOiBBY2Nlc3NvclNwYXJzZUluZGljZXM7XHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCBwb2ludGluZyB0byBhIGJ1ZmZlciB2aWV3IGNvbnRhaW5pbmcgdGhlIGRldmlhdGluZyBhY2Nlc3NvciB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIFwidmFsdWVzXCI6IEFjY2Vzc29yU3BhcnNlVmFsdWVzO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQSB0eXBlZCB2aWV3IGludG8gYSBidWZmZXIgdmlldyB0aGF0IGNvbnRhaW5zIHJhdyBiaW5hcnkgZGF0YS5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFjY2Vzc29yIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBidWZmZXJWaWV3LlxyXG4gICAgICovXHJcbiAgICBcImJ1ZmZlclZpZXdcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGJ1ZmZlciB2aWV3IGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBcImJ5dGVPZmZzZXRcIj86IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRhdGF0eXBlIG9mIHRoZSBhY2Nlc3NvcidzIGNvbXBvbmVudHMuXHJcbiAgICAgKi9cclxuICAgIFwiY29tcG9uZW50VHlwZVwiOiBDT01QT05FTlRfVFlQRTtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHdoZXRoZXIgaW50ZWdlciBkYXRhIHZhbHVlcyBhcmUgbm9ybWFsaXplZCBiZWZvcmUgdXNhZ2UuXHJcbiAgICAgKi9cclxuICAgIFwibm9ybWFsaXplZFwiPzogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBlbGVtZW50cyByZWZlcmVuY2VkIGJ5IHRoaXMgYWNjZXNzb3IuXHJcbiAgICAgKi9cclxuICAgIFwiY291bnRcIjogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgaWYgdGhlIGFjY2Vzc29yJ3MgZWxlbWVudHMgYXJlIHNjYWxhcnMsIHZlY3RvcnMsIG9yIG1hdHJpY2VzLlxyXG4gICAgICovXHJcbiAgICBcInR5cGVcIjogQUNDRVNTT1JfVFlQRTtcclxuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSB2YWx1ZSBvZiBlYWNoIGNvbXBvbmVudCBpbiB0aGlzIGFjY2Vzc29yLlxyXG4gICAgICovXHJcbiAgICBcIm1heFwiPzogbnVtYmVyW107XHJcbiAgICAvKipcclxuICAgICAqIE1pbmltdW0gdmFsdWUgb2YgZWFjaCBjb21wb25lbnQgaW4gdGhpcyBhY2Nlc3Nvci5cclxuICAgICAqL1xyXG4gICAgXCJtaW5cIj86IG51bWJlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGFyc2Ugc3RvcmFnZSBvZiBlbGVtZW50cyB0aGF0IGRldmlhdGUgZnJvbSB0aGVpciBpbml0aWFsaXphdGlvbiB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgXCJzcGFyc2VcIj86IEFjY2Vzc29yU3BhcnNlO1xyXG4gICAgXCJuYW1lXCI/OiBhbnk7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogaHR0cHM6Ly9yZWdpc3RyeS5raHJvbm9zLm9yZy9nbFRGL3NwZWNzLzIuMC9nbFRGLTIuMC5odG1sI2FjY2Vzc29yLWRhdGEtdHlwZXNcclxuICAgKi9cclxuICBleHBvcnQgZW51bSBDT01QT05FTlRfVFlQRSB7XHJcbiAgICBCWVRFID0gNTEyMCxcclxuICAgIFVOU0lHTkVEX0JZVEUgPSA1MTIxLFxyXG4gICAgU0hPUlQgPSA1MTIyLFxyXG4gICAgVU5TSUdORURfU0hPUlQgPSA1MTIzLFxyXG4gICAgVU5TSUdORURfSU5UID0gNTEyNSxcclxuICAgIEZMT0FUID0gNTEyNlxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gQUNDRVNTT1JfVFlQRSB7XHJcbiAgICBTQ0FMQVIgPSBcIlNDQUxBUlwiLFxyXG4gICAgVkVDMiA9IFwiVkVDMlwiLFxyXG4gICAgVkVDMyA9IFwiVkVDM1wiLFxyXG4gICAgVkVDNCA9IFwiVkVDNFwiLFxyXG4gICAgTUFUMiA9IFwiTUFUMlwiLFxyXG4gICAgTUFUMyA9IFwiTUFUM1wiLFxyXG4gICAgTUFUNCA9IFwiTUFUNFwiXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZGVzY3JpcHRvciBvZiB0aGUgYW5pbWF0ZWQgcHJvcGVydHkuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBbmltYXRpb25DaGFubmVsVGFyZ2V0IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGFuaW1hdGUuIFdoZW4gdW5kZWZpbmVkLCB0aGUgYW5pbWF0ZWQgb2JqZWN0ICoqTUFZKiogYmUgZGVmaW5lZCBieSBhbiBleHRlbnNpb24uXHJcbiAgICAgKi9cclxuICAgIFwibm9kZVwiPzogR2xUZklkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgbm9kZSdzIFRSUyBwcm9wZXJ0eSB0byBhbmltYXRlLCBvciB0aGUgYFwid2VpZ2h0c1wiYCBvZiB0aGUgTW9ycGggVGFyZ2V0cyBpdCBpbnN0YW50aWF0ZXMuIEZvciB0aGUgYFwidHJhbnNsYXRpb25cImAgcHJvcGVydHksIHRoZSB2YWx1ZXMgdGhhdCBhcmUgcHJvdmlkZWQgYnkgdGhlIHNhbXBsZXIgYXJlIHRoZSB0cmFuc2xhdGlvbiBhbG9uZyB0aGUgWCwgWSwgYW5kIFogYXhlcy4gRm9yIHRoZSBgXCJyb3RhdGlvblwiYCBwcm9wZXJ0eSwgdGhlIHZhbHVlcyBhcmUgYSBxdWF0ZXJuaW9uIGluIHRoZSBvcmRlciAoeCwgeSwgeiwgdyksIHdoZXJlIHcgaXMgdGhlIHNjYWxhci4gRm9yIHRoZSBgXCJzY2FsZVwiYCBwcm9wZXJ0eSwgdGhlIHZhbHVlcyBhcmUgdGhlIHNjYWxpbmcgZmFjdG9ycyBhbG9uZyB0aGUgWCwgWSwgYW5kIFogYXhlcy5cclxuICAgICAqL1xyXG4gICAgXCJwYXRoXCI6IFwidHJhbnNsYXRpb25cIiB8IFwicm90YXRpb25cIiB8IFwic2NhbGVcIiB8IFwid2VpZ2h0c1wiOyAvLyBodHRwczovL3JlZ2lzdHJ5Lmtocm9ub3Mub3JnL2dsVEYvc3BlY3MvMi4wL2dsVEYtMi4wLmh0bWwjYW5pbWF0aW9uc1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQW4gYW5pbWF0aW9uIGNoYW5uZWwgY29tYmluZXMgYW4gYW5pbWF0aW9uIHNhbXBsZXIgd2l0aCBhIHRhcmdldCBwcm9wZXJ0eSBiZWluZyBhbmltYXRlZC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFuaW1hdGlvbkNoYW5uZWwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgYSBzYW1wbGVyIGluIHRoaXMgYW5pbWF0aW9uIHVzZWQgdG8gY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIFwic2FtcGxlclwiOiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZXNjcmlwdG9yIG9mIHRoZSBhbmltYXRlZCBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgXCJ0YXJnZXRcIjogQW5pbWF0aW9uQ2hhbm5lbFRhcmdldDtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEFuIGFuaW1hdGlvbiBzYW1wbGVyIGNvbWJpbmVzIHRpbWVzdGFtcHMgd2l0aCBhIHNlcXVlbmNlIG9mIG91dHB1dCB2YWx1ZXMgYW5kIGRlZmluZXMgYW4gaW50ZXJwb2xhdGlvbiBhbGdvcml0aG0uXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBBbmltYXRpb25TYW1wbGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIGFuIGFjY2Vzc29yIGNvbnRhaW5pbmcga2V5ZnJhbWUgdGltZXN0YW1wcy5cclxuICAgICAqL1xyXG4gICAgXCJpbnB1dFwiOiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIEludGVycG9sYXRpb24gYWxnb3JpdGhtLlxyXG4gICAgICovXHJcbiAgICBcImludGVycG9sYXRpb25cIj86IFwiTElORUFSXCIgfCBcIlNURVBcIiB8IFwiQ1VCSUNTUExJTkVcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIGFuIGFjY2Vzc29yLCBjb250YWluaW5nIGtleWZyYW1lIG91dHB1dCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIFwib3V0cHV0XCI6IEdsVGZJZDtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEEga2V5ZnJhbWUgYW5pbWF0aW9uLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQW5pbWF0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgYW5pbWF0aW9uIGNoYW5uZWxzLiBBbiBhbmltYXRpb24gY2hhbm5lbCBjb21iaW5lcyBhbiBhbmltYXRpb24gc2FtcGxlciB3aXRoIGEgdGFyZ2V0IHByb3BlcnR5IGJlaW5nIGFuaW1hdGVkLiBEaWZmZXJlbnQgY2hhbm5lbHMgb2YgdGhlIHNhbWUgYW5pbWF0aW9uICoqTVVTVCBOT1QqKiBoYXZlIHRoZSBzYW1lIHRhcmdldHMuXHJcbiAgICAgKi9cclxuICAgIFwiY2hhbm5lbHNcIjogQW5pbWF0aW9uQ2hhbm5lbFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBhbmltYXRpb24gc2FtcGxlcnMuIEFuIGFuaW1hdGlvbiBzYW1wbGVyIGNvbWJpbmVzIHRpbWVzdGFtcHMgd2l0aCBhIHNlcXVlbmNlIG9mIG91dHB1dCB2YWx1ZXMgYW5kIGRlZmluZXMgYW4gaW50ZXJwb2xhdGlvbiBhbGdvcml0aG0uXHJcbiAgICAgKi9cclxuICAgIFwic2FtcGxlcnNcIjogQW5pbWF0aW9uU2FtcGxlcltdO1xyXG4gICAgXCJuYW1lXCI/OiBhbnk7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBNZXRhZGF0YSBhYm91dCB0aGUgZ2xURiBhc3NldC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEFzc2V0IHtcclxuICAgIC8qKlxyXG4gICAgICogQSBjb3B5cmlnaHQgbWVzc2FnZSBzdWl0YWJsZSBmb3IgZGlzcGxheSB0byBjcmVkaXQgdGhlIGNvbnRlbnQgY3JlYXRvci5cclxuICAgICAqL1xyXG4gICAgXCJjb3B5cmlnaHRcIj86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogVG9vbCB0aGF0IGdlbmVyYXRlZCB0aGlzIGdsVEYgbW9kZWwuICBVc2VmdWwgZm9yIGRlYnVnZ2luZy5cclxuICAgICAqL1xyXG4gICAgXCJnZW5lcmF0b3JcIj86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGdsVEYgdmVyc2lvbiBpbiB0aGUgZm9ybSBvZiBgPG1ham9yPi48bWlub3I+YCB0aGF0IHRoaXMgYXNzZXQgdGFyZ2V0cy5cclxuICAgICAqL1xyXG4gICAgXCJ2ZXJzaW9uXCI6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1pbmltdW0gZ2xURiB2ZXJzaW9uIGluIHRoZSBmb3JtIG9mIGA8bWFqb3I+LjxtaW5vcj5gIHRoYXQgdGhpcyBhc3NldCB0YXJnZXRzLiBUaGlzIHByb3BlcnR5ICoqTVVTVCBOT1QqKiBiZSBncmVhdGVyIHRoYW4gdGhlIGFzc2V0IHZlcnNpb24uXHJcbiAgICAgKi9cclxuICAgIFwibWluVmVyc2lvblwiPzogc3RyaW5nO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQSBidWZmZXIgcG9pbnRzIHRvIGJpbmFyeSBnZW9tZXRyeSwgYW5pbWF0aW9uLCBvciBza2lucy5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIEJ1ZmZlciB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBVUkkgKG9yIElSSSkgb2YgdGhlIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgXCJ1cmlcIj86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBcImJ5dGVMZW5ndGhcIjogbnVtYmVyO1xyXG4gICAgXCJuYW1lXCI/OiBhbnk7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBIHZpZXcgaW50byBhIGJ1ZmZlciBnZW5lcmFsbHkgcmVwcmVzZW50aW5nIGEgc3Vic2V0IG9mIHRoZSBidWZmZXIuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBCdWZmZXJWaWV3IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIFwiYnVmZmVyXCI6IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9mZnNldCBpbnRvIHRoZSBidWZmZXIgaW4gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIFwiYnl0ZU9mZnNldFwiPzogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXJWaWV3IGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBcImJ5dGVMZW5ndGhcIjogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3RyaWRlLCBpbiBieXRlcy5cclxuICAgICAqL1xyXG4gICAgXCJieXRlU3RyaWRlXCI/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoaW50IHJlcHJlc2VudGluZyB0aGUgaW50ZW5kZWQgR1BVIGJ1ZmZlciB0eXBlIHRvIHVzZSB3aXRoIHRoaXMgYnVmZmVyIHZpZXcuXHJcbiAgICAgKi9cclxuICAgIFwidGFyZ2V0XCI/OiBudW1iZXIgfCBudW1iZXIgfCBudW1iZXI7XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEFuIG9ydGhvZ3JhcGhpYyBjYW1lcmEgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNyZWF0ZSBhbiBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXguXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBDYW1lcmFPcnRob2dyYXBoaWMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgaG9yaXpvbnRhbCBtYWduaWZpY2F0aW9uIG9mIHRoZSB2aWV3LiBUaGlzIHZhbHVlICoqTVVTVCBOT1QqKiBiZSBlcXVhbCB0byB6ZXJvLiBUaGlzIHZhbHVlICoqU0hPVUxEIE5PVCoqIGJlIG5lZ2F0aXZlLlxyXG4gICAgICovXHJcbiAgICBcInhtYWdcIjogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgdmVydGljYWwgbWFnbmlmaWNhdGlvbiBvZiB0aGUgdmlldy4gVGhpcyB2YWx1ZSAqKk1VU1QgTk9UKiogYmUgZXF1YWwgdG8gemVyby4gVGhpcyB2YWx1ZSAqKlNIT1VMRCBOT1QqKiBiZSBuZWdhdGl2ZS5cclxuICAgICAqL1xyXG4gICAgXCJ5bWFnXCI6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZsb2F0aW5nLXBvaW50IGRpc3RhbmNlIHRvIHRoZSBmYXIgY2xpcHBpbmcgcGxhbmUuIFRoaXMgdmFsdWUgKipNVVNUIE5PVCoqIGJlIGVxdWFsIHRvIHplcm8uIGB6ZmFyYCAqKk1VU1QqKiBiZSBncmVhdGVyIHRoYW4gYHpuZWFyYC5cclxuICAgICAqL1xyXG4gICAgXCJ6ZmFyXCI6IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZsb2F0aW5nLXBvaW50IGRpc3RhbmNlIHRvIHRoZSBuZWFyIGNsaXBwaW5nIHBsYW5lLlxyXG4gICAgICovXHJcbiAgICBcInpuZWFyXCI6IG51bWJlcjtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEEgcGVyc3BlY3RpdmUgY2FtZXJhIGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjcmVhdGUgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIENhbWVyYVBlcnNwZWN0aXZlIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZsb2F0aW5nLXBvaW50IGFzcGVjdCByYXRpbyBvZiB0aGUgZmllbGQgb2Ygdmlldy5cclxuICAgICAqL1xyXG4gICAgXCJhc3BlY3RSYXRpb1wiPzogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgdmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zLiBUaGlzIHZhbHVlICoqU0hPVUxEKiogYmUgbGVzcyB0aGFuIM+ALlxyXG4gICAgICovXHJcbiAgICBcInlmb3ZcIjogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmxvYXRpbmctcG9pbnQgZGlzdGFuY2UgdG8gdGhlIGZhciBjbGlwcGluZyBwbGFuZS5cclxuICAgICAqL1xyXG4gICAgXCJ6ZmFyXCI/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmbG9hdGluZy1wb2ludCBkaXN0YW5jZSB0byB0aGUgbmVhciBjbGlwcGluZyBwbGFuZS5cclxuICAgICAqL1xyXG4gICAgXCJ6bmVhclwiOiBudW1iZXI7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBIGNhbWVyYSdzIHByb2plY3Rpb24uICBBIG5vZGUgKipNQVkqKiByZWZlcmVuY2UgYSBjYW1lcmEgdG8gYXBwbHkgYSB0cmFuc2Zvcm0gdG8gcGxhY2UgdGhlIGNhbWVyYSBpbiB0aGUgc2NlbmUuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBDYW1lcmEge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvcnRob2dyYXBoaWMgY2FtZXJhIGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjcmVhdGUgYW4gb3J0aG9ncmFwaGljIHByb2plY3Rpb24gbWF0cml4LiBUaGlzIHByb3BlcnR5ICoqTVVTVCBOT1QqKiBiZSBkZWZpbmVkIHdoZW4gYHBlcnNwZWN0aXZlYCBpcyBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBcIm9ydGhvZ3JhcGhpY1wiPzogQ2FtZXJhT3J0aG9ncmFwaGljO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHBlcnNwZWN0aXZlIGNhbWVyYSBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY3JlYXRlIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXguIFRoaXMgcHJvcGVydHkgKipNVVNUIE5PVCoqIGJlIGRlZmluZWQgd2hlbiBgb3J0aG9ncmFwaGljYCBpcyBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBcInBlcnNwZWN0aXZlXCI/OiBDYW1lcmFQZXJzcGVjdGl2ZTtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIGlmIHRoZSBjYW1lcmEgdXNlcyBhIHBlcnNwZWN0aXZlIG9yIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBcInR5cGVcIjogYW55IHwgYW55IHwgc3RyaW5nO1xyXG4gICAgXCJuYW1lXCI/OiBhbnk7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBJbWFnZSBkYXRhIHVzZWQgdG8gY3JlYXRlIGEgdGV4dHVyZS4gSW1hZ2UgKipNQVkqKiBiZSByZWZlcmVuY2VkIGJ5IGFuIFVSSSAob3IgSVJJKSBvciBhIGJ1ZmZlciB2aWV3IGluZGV4LlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW1hZ2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgVVJJIChvciBJUkkpIG9mIHRoZSBpbWFnZS5cclxuICAgICAqL1xyXG4gICAgXCJ1cmlcIj86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGltYWdlJ3MgbWVkaWEgdHlwZS4gVGhpcyBmaWVsZCAqKk1VU1QqKiBiZSBkZWZpbmVkIHdoZW4gYGJ1ZmZlclZpZXdgIGlzIGRlZmluZWQuXHJcbiAgICAgKi9cclxuICAgIFwibWltZVR5cGVcIj86IGFueSB8IGFueSB8IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBidWZmZXJWaWV3IHRoYXQgY29udGFpbnMgdGhlIGltYWdlLiBUaGlzIGZpZWxkICoqTVVTVCBOT1QqKiBiZSBkZWZpbmVkIHdoZW4gYHVyaWAgaXMgZGVmaW5lZC5cclxuICAgICAqL1xyXG4gICAgXCJidWZmZXJWaWV3XCI/OiBHbFRmSWQ7XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlZmVyZW5jZSB0byBhIHRleHR1cmUuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBUZXh0dXJlSW5mbyB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgdGV4dHVyZS5cclxuICAgICAqL1xyXG4gICAgXCJpbmRleFwiOiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZXQgaW5kZXggb2YgdGV4dHVyZSdzIFRFWENPT1JEIGF0dHJpYnV0ZSB1c2VkIGZvciB0ZXh0dXJlIGNvb3JkaW5hdGUgbWFwcGluZy5cclxuICAgICAqL1xyXG4gICAgXCJ0ZXhDb29yZFwiPzogbnVtYmVyO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQSBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlcyB0aGF0IGFyZSB1c2VkIHRvIGRlZmluZSB0aGUgbWV0YWxsaWMtcm91Z2huZXNzIG1hdGVyaWFsIG1vZGVsIGZyb20gUGh5c2ljYWxseS1CYXNlZCBSZW5kZXJpbmcgKFBCUikgbWV0aG9kb2xvZ3kuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNYXRlcmlhbFBick1ldGFsbGljUm91Z2huZXNzIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZhY3RvcnMgZm9yIHRoZSBiYXNlIGNvbG9yIG9mIHRoZSBtYXRlcmlhbC5cclxuICAgICAqL1xyXG4gICAgXCJiYXNlQ29sb3JGYWN0b3JcIj86IG51bWJlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZSBjb2xvciB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBcImJhc2VDb2xvclRleHR1cmVcIj86IFRleHR1cmVJbmZvO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmFjdG9yIGZvciB0aGUgbWV0YWxuZXNzIG9mIHRoZSBtYXRlcmlhbC5cclxuICAgICAqL1xyXG4gICAgXCJtZXRhbGxpY0ZhY3RvclwiPzogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmFjdG9yIGZvciB0aGUgcm91Z2huZXNzIG9mIHRoZSBtYXRlcmlhbC5cclxuICAgICAqL1xyXG4gICAgXCJyb3VnaG5lc3NGYWN0b3JcIj86IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1ldGFsbGljLXJvdWdobmVzcyB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBcIm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZVwiPzogVGV4dHVyZUluZm87XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIE1hdGVyaWFsTm9ybWFsVGV4dHVyZUluZm8ge1xyXG4gICAgXCJpbmRleFwiPzogYW55O1xyXG4gICAgXCJ0ZXhDb29yZFwiPzogYW55O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2NhbGFyIHBhcmFtZXRlciBhcHBsaWVkIHRvIGVhY2ggbm9ybWFsIHZlY3RvciBvZiB0aGUgbm9ybWFsIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIFwic2NhbGVcIj86IG51bWJlcjtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgTWF0ZXJpYWxPY2NsdXNpb25UZXh0dXJlSW5mbyB7XHJcbiAgICBcImluZGV4XCI/OiBhbnk7XHJcbiAgICBcInRleENvb3JkXCI/OiBhbnk7XHJcbiAgICAvKipcclxuICAgICAqIEEgc2NhbGFyIG11bHRpcGxpZXIgY29udHJvbGxpbmcgdGhlIGFtb3VudCBvZiBvY2NsdXNpb24gYXBwbGllZC5cclxuICAgICAqL1xyXG4gICAgXCJzdHJlbmd0aFwiPzogbnVtYmVyO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVGhlIG1hdGVyaWFsIGFwcGVhcmFuY2Ugb2YgYSBwcmltaXRpdmUuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBNYXRlcmlhbCB7XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIC8qKlxyXG4gICAgICogQSBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlcyB0aGF0IGFyZSB1c2VkIHRvIGRlZmluZSB0aGUgbWV0YWxsaWMtcm91Z2huZXNzIG1hdGVyaWFsIG1vZGVsIGZyb20gUGh5c2ljYWxseSBCYXNlZCBSZW5kZXJpbmcgKFBCUikgbWV0aG9kb2xvZ3kuIFdoZW4gdW5kZWZpbmVkLCBhbGwgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIGBwYnJNZXRhbGxpY1JvdWdobmVzc2AgKipNVVNUKiogYXBwbHkuXHJcbiAgICAgKi9cclxuICAgIFwicGJyTWV0YWxsaWNSb3VnaG5lc3NcIj86IE1hdGVyaWFsUGJyTWV0YWxsaWNSb3VnaG5lc3M7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0YW5nZW50IHNwYWNlIG5vcm1hbCB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBcIm5vcm1hbFRleHR1cmVcIj86IE1hdGVyaWFsTm9ybWFsVGV4dHVyZUluZm87XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvY2NsdXNpb24gdGV4dHVyZS5cclxuICAgICAqL1xyXG4gICAgXCJvY2NsdXNpb25UZXh0dXJlXCI/OiBNYXRlcmlhbE9jY2x1c2lvblRleHR1cmVJbmZvO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZW1pc3NpdmUgdGV4dHVyZS5cclxuICAgICAqL1xyXG4gICAgXCJlbWlzc2l2ZVRleHR1cmVcIj86IFRleHR1cmVJbmZvO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmFjdG9ycyBmb3IgdGhlIGVtaXNzaXZlIGNvbG9yIG9mIHRoZSBtYXRlcmlhbC5cclxuICAgICAqL1xyXG4gICAgXCJlbWlzc2l2ZUZhY3RvclwiPzogbnVtYmVyW107XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbHBoYSByZW5kZXJpbmcgbW9kZSBvZiB0aGUgbWF0ZXJpYWwuXHJcbiAgICAgKi9cclxuICAgIFwiYWxwaGFNb2RlXCI/OiBcIk9QQVFVRVwiIHwgXCJNQVNLXCIgfCBcIkJMRU5EXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbHBoYSBjdXRvZmYgdmFsdWUgb2YgdGhlIG1hdGVyaWFsLlxyXG4gICAgICovXHJcbiAgICBcImFscGhhQ3V0b2ZmXCI/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBtYXRlcmlhbCBpcyBkb3VibGUgc2lkZWQuXHJcbiAgICAgKi9cclxuICAgIFwiZG91YmxlU2lkZWRcIj86IGJvb2xlYW47XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBHZW9tZXRyeSB0byBiZSByZW5kZXJlZCB3aXRoIHRoZSBnaXZlbiBtYXRlcmlhbC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE1lc2hQcmltaXRpdmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHBsYWluIEpTT04gb2JqZWN0LCB3aGVyZSBlYWNoIGtleSBjb3JyZXNwb25kcyB0byBhIG1lc2ggYXR0cmlidXRlIHNlbWFudGljIGFuZCBlYWNoIHZhbHVlIGlzIHRoZSBpbmRleCBvZiB0aGUgYWNjZXNzb3IgY29udGFpbmluZyBhdHRyaWJ1dGUncyBkYXRhLlxyXG4gICAgICovXHJcbiAgICBcImF0dHJpYnV0ZXNcIjoge1xyXG4gICAgICBbazogc3RyaW5nXTogR2xUZklkO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBhY2Nlc3NvciB0aGF0IGNvbnRhaW5zIHRoZSB2ZXJ0ZXggaW5kaWNlcy5cclxuICAgICAqL1xyXG4gICAgXCJpbmRpY2VzXCI/OiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgbWF0ZXJpYWwgdG8gYXBwbHkgdG8gdGhpcyBwcmltaXRpdmUgd2hlbiByZW5kZXJpbmcuXHJcbiAgICAgKi9cclxuICAgIFwibWF0ZXJpYWxcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRvcG9sb2d5IHR5cGUgb2YgcHJpbWl0aXZlcyB0byByZW5kZXIuXHJcbiAgICAgKi9cclxuICAgIFwibW9kZVwiPzogTUVTSF9QUklNSVRJVkVfTU9ERTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgbW9ycGggdGFyZ2V0cy5cclxuICAgICAqL1xyXG4gICAgXCJ0YXJnZXRzXCI/OiB7XHJcbiAgICAgIFtrOiBzdHJpbmddOiBHbFRmSWQ7XHJcbiAgICB9W107XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGVudW0gTUVTSF9QUklNSVRJVkVfTU9ERSB7XHJcbiAgICBQT0lOVFMsXHJcbiAgICBMSU5FUyxcclxuICAgIExJTkVfTE9PUCxcclxuICAgIExJTkVfU1RSSVAsXHJcbiAgICBUUklBTkdMRVMsXHJcbiAgICBUUklBTkdMRV9TVFJJUCxcclxuICAgIFRSSUFOR0xFX0ZBTlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBzZXQgb2YgcHJpbWl0aXZlcyB0byBiZSByZW5kZXJlZC4gIEl0cyBnbG9iYWwgdHJhbnNmb3JtIGlzIGRlZmluZWQgYnkgYSBub2RlIHRoYXQgcmVmZXJlbmNlcyBpdC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE1lc2gge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBwcmltaXRpdmVzLCBlYWNoIGRlZmluaW5nIGdlb21ldHJ5IHRvIGJlIHJlbmRlcmVkLlxyXG4gICAgICovXHJcbiAgICBcInByaW1pdGl2ZXNcIjogTWVzaFByaW1pdGl2ZVtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiB3ZWlnaHRzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIG1vcnBoIHRhcmdldHMuIFRoZSBudW1iZXIgb2YgYXJyYXkgZWxlbWVudHMgKipNVVNUKiogbWF0Y2ggdGhlIG51bWJlciBvZiBtb3JwaCB0YXJnZXRzLlxyXG4gICAgICovXHJcbiAgICBcIndlaWdodHNcIj86IG51bWJlcltdO1xyXG4gICAgXCJuYW1lXCI/OiBhbnk7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBIG5vZGUgaW4gdGhlIG5vZGUgaGllcmFyY2h5LiAgV2hlbiB0aGUgbm9kZSBjb250YWlucyBgc2tpbmAsIGFsbCBgbWVzaC5wcmltaXRpdmVzYCAqKk1VU1QqKiBjb250YWluIGBKT0lOVFNfMGAgYW5kIGBXRUlHSFRTXzBgIGF0dHJpYnV0ZXMuICBBIG5vZGUgKipNQVkqKiBoYXZlIGVpdGhlciBhIGBtYXRyaXhgIG9yIGFueSBjb21iaW5hdGlvbiBvZiBgdHJhbnNsYXRpb25gL2Byb3RhdGlvbmAvYHNjYWxlYCAoVFJTKSBwcm9wZXJ0aWVzLiBUUlMgcHJvcGVydGllcyBhcmUgY29udmVydGVkIHRvIG1hdHJpY2VzIGFuZCBwb3N0bXVsdGlwbGllZCBpbiB0aGUgYFQgKiBSICogU2Agb3JkZXIgdG8gY29tcG9zZSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4OyBmaXJzdCB0aGUgc2NhbGUgaXMgYXBwbGllZCB0byB0aGUgdmVydGljZXMsIHRoZW4gdGhlIHJvdGF0aW9uLCBhbmQgdGhlbiB0aGUgdHJhbnNsYXRpb24uIElmIG5vbmUgYXJlIHByb3ZpZGVkLCB0aGUgdHJhbnNmb3JtIGlzIHRoZSBpZGVudGl0eS4gV2hlbiBhIG5vZGUgaXMgdGFyZ2V0ZWQgZm9yIGFuaW1hdGlvbiAocmVmZXJlbmNlZCBieSBhbiBhbmltYXRpb24uY2hhbm5lbC50YXJnZXQpLCBgbWF0cml4YCAqKk1VU1QgTk9UKiogYmUgcHJlc2VudC5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGNhbWVyYSByZWZlcmVuY2VkIGJ5IHRoaXMgbm9kZS5cclxuICAgICAqL1xyXG4gICAgXCJjYW1lcmFcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGljZXMgb2YgdGhpcyBub2RlJ3MgY2hpbGRyZW4uXHJcbiAgICAgKi9cclxuICAgIFwiY2hpbGRyZW5cIj86IEdsVGZJZFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHNraW4gcmVmZXJlbmNlZCBieSB0aGlzIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIFwic2tpblwiPzogR2xUZklkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZsb2F0aW5nLXBvaW50IDR4NCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggc3RvcmVkIGluIGNvbHVtbi1tYWpvciBvcmRlci5cclxuICAgICAqL1xyXG4gICAgXCJtYXRyaXhcIj86IG51bWJlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIG1lc2ggaW4gdGhpcyBub2RlLlxyXG4gICAgICovXHJcbiAgICBcIm1lc2hcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5vZGUncyB1bml0IHF1YXRlcm5pb24gcm90YXRpb24gaW4gdGhlIG9yZGVyICh4LCB5LCB6LCB3KSwgd2hlcmUgdyBpcyB0aGUgc2NhbGFyLlxyXG4gICAgICovXHJcbiAgICBcInJvdGF0aW9uXCI/OiBudW1iZXJbXTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5vZGUncyBub24tdW5pZm9ybSBzY2FsZSwgZ2l2ZW4gYXMgdGhlIHNjYWxpbmcgZmFjdG9ycyBhbG9uZyB0aGUgeCwgeSwgYW5kIHogYXhlcy5cclxuICAgICAqL1xyXG4gICAgXCJzY2FsZVwiPzogbnVtYmVyW107XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBub2RlJ3MgdHJhbnNsYXRpb24gYWxvbmcgdGhlIHgsIHksIGFuZCB6IGF4ZXMuXHJcbiAgICAgKi9cclxuICAgIFwidHJhbnNsYXRpb25cIj86IG51bWJlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2VpZ2h0cyBvZiB0aGUgaW5zdGFudGlhdGVkIG1vcnBoIHRhcmdldC4gVGhlIG51bWJlciBvZiBhcnJheSBlbGVtZW50cyAqKk1VU1QqKiBtYXRjaCB0aGUgbnVtYmVyIG9mIG1vcnBoIHRhcmdldHMgb2YgdGhlIHJlZmVyZW5jZWQgbWVzaC4gV2hlbiBkZWZpbmVkLCBgbWVzaGAgKipNVVNUKiogYWxzbyBiZSBkZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICBcIndlaWdodHNcIj86IG51bWJlcltdO1xyXG4gICAgXCJuYW1lXCI/OiBzdHJpbmc7XHJcbiAgICBcImV4dGVuc2lvbnNcIj86IGFueTtcclxuICAgIFwiZXh0cmFzXCI/OiBhbnk7XHJcbiAgICBbazogc3RyaW5nXTogYW55O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VzdG9tIHByb3BlcnR5IHNldCBieSBGVURHRSBsb2FkZXIuIE5vdCBwYXJ0IG9mIGdsVEYgc3RhbmRhcmQgMi4wLlxyXG4gICAgICovXHJcbiAgICBpc0FuaW1hdGVkPzogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogQ3VzdG9tIHByb3BlcnR5IHNldCBieSBGVURHRSBsb2FkZXIuIE5vdCBwYXJ0IG9mIGdsVEYgc3RhbmRhcmQgMi4wLlxyXG4gICAgICovXHJcbiAgICBwYXJlbnQ/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIFBhdGggZnJvbSB0aGUgcm9vdCBub2RlIHRvIHRoaXMgbm9kZS5cclxuICAgICAqIEN1c3RvbSBwcm9wZXJ0eSBzZXQgYnkgRlVER0UgbG9hZGVyLiBOb3QgcGFydCBvZiBnbFRGIHN0YW5kYXJkIDIuMC5cclxuICAgICAqL1xyXG4gICAgcGF0aD86IG51bWJlcltdO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBUZXh0dXJlIHNhbXBsZXIgcHJvcGVydGllcyBmb3IgZmlsdGVyaW5nIGFuZCB3cmFwcGluZyBtb2Rlcy5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIFNhbXBsZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWduaWZpY2F0aW9uIGZpbHRlci5cclxuICAgICAqL1xyXG4gICAgXCJtYWdGaWx0ZXJcIj86IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJORUFSRVNUXCJdIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFtcIkxJTkVBUlwiXTtcclxuICAgIC8qKlxyXG4gICAgICogTWluaWZpY2F0aW9uIGZpbHRlci5cclxuICAgICAqL1xyXG4gICAgXCJtaW5GaWx0ZXJcIj86IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJORUFSRVNUXCJdIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFtcIkxJTkVBUlwiXSB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJORUFSRVNUX01JUE1BUF9ORUFSRVNUXCJdIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFtcIkxJTkVBUl9NSVBNQVBfTkVBUkVTVFwiXSB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJORUFSRVNUX01JUE1BUF9MSU5FQVJcIl0gfCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0W1wiTElORUFSX01JUE1BUF9MSU5FQVJcIl07XHJcbiAgICAvKipcclxuICAgICAqIFMgKFUpIHdyYXBwaW5nIG1vZGUuXHJcbiAgICAgKi9cclxuICAgIFwid3JhcFNcIj86IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJDTEFNUF9UT19FREdFXCJdIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFtcIk1JUlJPUkVEX1JFUEVBVFwiXSB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJSRVBFQVRcIl07XHJcbiAgICAvKipcclxuICAgICAqIFQgKFYpIHdyYXBwaW5nIG1vZGUuXHJcbiAgICAgKi9cclxuICAgIFwid3JhcFRcIj86IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJDTEFNUF9UT19FREdFXCJdIHwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dFtcIk1JUlJPUkVEX1JFUEVBVFwiXSB8IFdlYkdMMlJlbmRlcmluZ0NvbnRleHRbXCJSRVBFQVRcIl07XHJcbiAgICBcIm5hbWVcIj86IHN0cmluZztcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRoZSByb290IG5vZGVzIG9mIGEgc2NlbmUuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBTY2VuZSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRpY2VzIG9mIGVhY2ggcm9vdCBub2RlLlxyXG4gICAgICovXHJcbiAgICBcIm5vZGVzXCI/OiBHbFRmSWRbXTtcclxuICAgIFwibmFtZVwiPzogYW55O1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogSm9pbnRzIGFuZCBtYXRyaWNlcyBkZWZpbmluZyBhIHNraW4uXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBTa2luIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBhY2Nlc3NvciBjb250YWluaW5nIHRoZSBmbG9hdGluZy1wb2ludCA0eDQgaW52ZXJzZS1iaW5kIG1hdHJpY2VzLlxyXG4gICAgICovXHJcbiAgICBcImludmVyc2VCaW5kTWF0cmljZXNcIj86IEdsVGZJZDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBub2RlIHVzZWQgYXMgYSBza2VsZXRvbiByb290LlxyXG4gICAgICovXHJcbiAgICBcInNrZWxldG9uXCI/OiBHbFRmSWQ7XHJcbiAgICAvKipcclxuICAgICAqIEluZGljZXMgb2Ygc2tlbGV0b24gbm9kZXMsIHVzZWQgYXMgam9pbnRzIGluIHRoaXMgc2tpbi5cclxuICAgICAqL1xyXG4gICAgXCJqb2ludHNcIjogR2xUZklkW107XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEEgdGV4dHVyZSBhbmQgaXRzIHNhbXBsZXIuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBUZXh0dXJlIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBzYW1wbGVyIHVzZWQgYnkgdGhpcyB0ZXh0dXJlLiBXaGVuIHVuZGVmaW5lZCwgYSBzYW1wbGVyIHdpdGggcmVwZWF0IHdyYXBwaW5nIGFuZCBhdXRvIGZpbHRlcmluZyAqKlNIT1VMRCoqIGJlIHVzZWQuXHJcbiAgICAgKi9cclxuICAgIFwic2FtcGxlclwiPzogR2xUZklkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGltYWdlIHVzZWQgYnkgdGhpcyB0ZXh0dXJlLiBXaGVuIHVuZGVmaW5lZCwgYW4gZXh0ZW5zaW9uIG9yIG90aGVyIG1lY2hhbmlzbSAqKlNIT1VMRCoqIHN1cHBseSBhbiBhbHRlcm5hdGUgdGV4dHVyZSBzb3VyY2UsIG90aGVyd2lzZSBiZWhhdmlvciBpcyB1bmRlZmluZWQuXHJcbiAgICAgKi9cclxuICAgIFwic291cmNlXCI/OiBHbFRmSWQ7XHJcbiAgICBcIm5hbWVcIj86IGFueTtcclxuICAgIFwiZXh0ZW5zaW9uc1wiPzogYW55O1xyXG4gICAgXCJleHRyYXNcIj86IGFueTtcclxuICAgIFtrOiBzdHJpbmddOiBhbnk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFRoZSByb290IG9iamVjdCBmb3IgYSBnbFRGIGFzc2V0LlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgR2xUZiB7XHJcbiAgICAvKipcclxuICAgICAqIE5hbWVzIG9mIGdsVEYgZXh0ZW5zaW9ucyB1c2VkIGluIHRoaXMgYXNzZXQuXHJcbiAgICAgKi9cclxuICAgIFwiZXh0ZW5zaW9uc1VzZWRcIj86IHN0cmluZ1tdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBOYW1lcyBvZiBnbFRGIGV4dGVuc2lvbnMgcmVxdWlyZWQgdG8gcHJvcGVybHkgbG9hZCB0aGlzIGFzc2V0LlxyXG4gICAgICovXHJcbiAgICBcImV4dGVuc2lvbnNSZXF1aXJlZFwiPzogc3RyaW5nW107XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIGFjY2Vzc29ycy5cclxuICAgICAqL1xyXG4gICAgXCJhY2Nlc3NvcnNcIj86IEFjY2Vzc29yW107XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIGtleWZyYW1lIGFuaW1hdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIFwiYW5pbWF0aW9uc1wiPzogQW5pbWF0aW9uW107XHJcbiAgICAvKipcclxuICAgICAqIE1ldGFkYXRhIGFib3V0IHRoZSBnbFRGIGFzc2V0LlxyXG4gICAgICovXHJcbiAgICBcImFzc2V0XCI6IEFzc2V0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBidWZmZXJzLlxyXG4gICAgICovXHJcbiAgICBcImJ1ZmZlcnNcIj86IEJ1ZmZlcltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBidWZmZXJWaWV3cy5cclxuICAgICAqL1xyXG4gICAgXCJidWZmZXJWaWV3c1wiPzogQnVmZmVyVmlld1tdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBjYW1lcmFzLlxyXG4gICAgICovXHJcbiAgICBcImNhbWVyYXNcIj86IENhbWVyYVtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBpbWFnZXMuXHJcbiAgICAgKi9cclxuICAgIFwiaW1hZ2VzXCI/OiBJbWFnZVtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBtYXRlcmlhbHMuXHJcbiAgICAgKi9cclxuICAgIFwibWF0ZXJpYWxzXCI/OiBNYXRlcmlhbFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBtZXNoZXMuXHJcbiAgICAgKi9cclxuICAgIFwibWVzaGVzXCI/OiBNZXNoW107XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIG5vZGVzLlxyXG4gICAgICovXHJcbiAgICBcIm5vZGVzXCI/OiBOb2RlW107XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIHNhbXBsZXJzLlxyXG4gICAgICovXHJcbiAgICBcInNhbXBsZXJzXCI/OiBTYW1wbGVyW107XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgZGVmYXVsdCBzY2VuZS5cclxuICAgICAqL1xyXG4gICAgXCJzY2VuZVwiPzogR2xUZklkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBzY2VuZXMuXHJcbiAgICAgKi9cclxuICAgIFwic2NlbmVzXCI/OiBTY2VuZVtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBza2lucy5cclxuICAgICAqL1xyXG4gICAgXCJza2luc1wiPzogU2tpbltdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiB0ZXh0dXJlcy5cclxuICAgICAqL1xyXG4gICAgXCJ0ZXh0dXJlc1wiPzogVGV4dHVyZVtdO1xyXG4gICAgXCJleHRlbnNpb25zXCI/OiBhbnk7XHJcbiAgICBcImV4dHJhc1wiPzogYW55O1xyXG4gICAgW2s6IHN0cmluZ106IGFueTtcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcmVzIG5vZGVzIGFuZCBza2VsZXRvbnMgdXNlZCB3aXRoaW4gYSBnbFRGIHNjZW5lLlxyXG4gICAqL1xyXG4gIGludGVyZmFjZSBHTFRGTG9hZGluZ0NhY2hlIHtcclxuICAgIG5vZGVzOiBOb2RlW107XHJcbiAgICBza2VsZXRvbnM6IENvbXBvbmVudFNrZWxldG9uW107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBc3NldCBsb2FkZXIgZm9yIGdsIFRyYW5zZmVyIEZvcm1hdCBmaWxlcy5cclxuICAgKiBAYXV0aG9ycyBNYXR0aGlhcyBSb21pbmcsIEhGVSwgMjAyMiB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyMy0yMDI1XHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIEdMVEZMb2FkZXIge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9hZGVyczogeyBbdXJsOiBzdHJpbmddOiBHTFRGTG9hZGVyIH07XHJcblxyXG4gICAgc3RhdGljICNkZWZhdWx0TWF0ZXJpYWw6IE1hdGVyaWFsO1xyXG4gICAgc3RhdGljICNkZWZhdWx0U2tpbk1hdGVyaWFsOiBNYXRlcmlhbDtcclxuXHJcbiAgICByZWFkb25seSAjdXJsOiBzdHJpbmc7XHJcbiAgICByZWFkb25seSAjZ2x0ZjogR0xURi5HbFRmO1xyXG5cclxuICAgICNyZXNvdXJjZXM6IFJlc291cmNlcyA9IHt9O1xyXG5cclxuICAgICNidWZmZXJzOiBBcnJheUJ1ZmZlcltdO1xyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoX2dsdGY6IEdMVEYuR2xUZiwgX3VybDogc3RyaW5nLCBfYnVmZmVyQ2h1bms/OiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICB0aGlzLiNnbHRmID0gX2dsdGY7XHJcbiAgICAgIHRoaXMuI3VybCA9IF91cmw7XHJcbiAgICAgIGlmIChfYnVmZmVyQ2h1bmspXHJcbiAgICAgICAgdGhpcy4jYnVmZmVycyA9IFtfYnVmZmVyQ2h1bmtdO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldCBkZWZhdWx0TWF0ZXJpYWwoKTogTWF0ZXJpYWwge1xyXG4gICAgICBpZiAoIXRoaXMuI2RlZmF1bHRNYXRlcmlhbCkge1xyXG4gICAgICAgIHRoaXMuI2RlZmF1bHRNYXRlcmlhbCA9IG5ldyBNYXRlcmlhbChcIkdMVEZEZWZhdWx0TWF0ZXJpYWxcIiwgU2hhZGVyUGhvbmcsIG5ldyBDb2F0UmVtaXNzaXZlKENvbG9yLkNTUyhcIndoaXRlXCIpLCAxLCAwLjUpKTtcclxuICAgICAgICBQcm9qZWN0LmRlcmVnaXN0ZXIodGhpcy4jZGVmYXVsdE1hdGVyaWFsKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy4jZGVmYXVsdE1hdGVyaWFsO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldCBkZWZhdWx0U2tpbk1hdGVyaWFsKCk6IE1hdGVyaWFsIHtcclxuICAgICAgaWYgKCF0aGlzLiNkZWZhdWx0U2tpbk1hdGVyaWFsKSB7XHJcbiAgICAgICAgdGhpcy4jZGVmYXVsdFNraW5NYXRlcmlhbCA9IG5ldyBNYXRlcmlhbChcIkdMVEZEZWZhdWx0U2tpbk1hdGVyaWFsXCIsIFNoYWRlclBob25nU2tpbiwgbmV3IENvYXRSZW1pc3NpdmUoQ29sb3IuQ1NTKFwid2hpdGVcIiksIDEsIDAuNSkpO1xyXG4gICAgICAgIFByb2plY3QuZGVyZWdpc3Rlcih0aGlzLiNkZWZhdWx0U2tpbk1hdGVyaWFsKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy4jZGVmYXVsdFNraW5NYXRlcmlhbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgdGhlIGxvYWRpbmcgb2YgYW4gZXh0ZXJuYWwgcmVzb3VyY2UgZnJvbSBhIGdsVEYgZmlsZS4gVXNlZCBieSB0aGUge0BsaW5rIFNlcmlhbGl6YWJsZVJlc291cmNlRXh0ZXJuYWx9R0xURiBzcGVjaWFsaXphdGlvbnMgdG8gbG9hZCB0aGVtc2VsdmVzLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZFJlc291cmNlPFQgZXh0ZW5kcyBHcmFwaEdMVEYgfCBNZXNoR0xURiB8IE1hdGVyaWFsR0xURiB8IEFuaW1hdGlvbkdMVEYgfCBHcmFwaEluc3RhbmNlPihfcmVzb3VyY2U6IFQsIF91cmw/OiBSZXF1ZXN0SW5mbyk6IFByb21pc2U8VD4ge1xyXG4gICAgICBjb25zdCBsb2FkZXI6IEdMVEZMb2FkZXIgPSBhd2FpdCBHTFRGTG9hZGVyLkxPQUQoKCg8U2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbD5fcmVzb3VyY2UpLnVybCA/PyBfdXJsKS50b1N0cmluZygpKTtcclxuXHJcbiAgICAgIGlmICghbG9hZGVyKSB7XHJcbiAgICAgICAgaWYgKCEoX3Jlc291cmNlIGluc3RhbmNlb2YgR3JhcGhJbnN0YW5jZSkpXHJcbiAgICAgICAgICBfcmVzb3VyY2Uuc3RhdHVzID0gUkVTT1VSQ0VfU1RBVFVTLkVSUk9SO1xyXG4gICAgICAgIHJldHVybiBfcmVzb3VyY2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBsb2FkZWQ6IFQ7XHJcblxyXG4gICAgICBpZiAoX3Jlc291cmNlIGluc3RhbmNlb2YgR3JhcGhJbnN0YW5jZSlcclxuICAgICAgICBsb2FkZWQgPSBhd2FpdCBsb2FkZXIuZ2V0R3JhcGgoX3Jlc291cmNlLmdldCgpLm5hbWUsIF9yZXNvdXJjZSk7XHJcbiAgICAgIGVsc2UgaWYgKF9yZXNvdXJjZSBpbnN0YW5jZW9mIEdyYXBoR0xURilcclxuICAgICAgICBsb2FkZWQgPSBhd2FpdCBsb2FkZXIuZ2V0R3JhcGgoX3Jlc291cmNlLm5hbWUsIF9yZXNvdXJjZSk7XHJcbiAgICAgIGVsc2UgaWYgKF9yZXNvdXJjZSBpbnN0YW5jZW9mIE1lc2hHTFRGKVxyXG4gICAgICAgIGxvYWRlZCA9IGF3YWl0IGxvYWRlci5nZXRNZXNoKF9yZXNvdXJjZS5uYW1lLCBfcmVzb3VyY2UuaVByaW1pdGl2ZSwgX3Jlc291cmNlKTtcclxuICAgICAgZWxzZSBpZiAoX3Jlc291cmNlIGluc3RhbmNlb2YgTWF0ZXJpYWxHTFRGKVxyXG4gICAgICAgIGxvYWRlZCA9IGF3YWl0IGxvYWRlci5nZXRNYXRlcmlhbChfcmVzb3VyY2UubmFtZSwgX3Jlc291cmNlKTtcclxuICAgICAgZWxzZSBpZiAoX3Jlc291cmNlIGluc3RhbmNlb2YgQW5pbWF0aW9uR0xURilcclxuICAgICAgICBsb2FkZWQgPSBhd2FpdCBsb2FkZXIuZ2V0QW5pbWF0aW9uKF9yZXNvdXJjZS5uYW1lLCBfcmVzb3VyY2UpO1xyXG5cclxuICAgICAgaWYgKCFsb2FkZWQpIHtcclxuICAgICAgICBEZWJ1Zy5lcnJvcihgJHtfcmVzb3VyY2UuY29uc3RydWN0b3IubmFtZX0gfCAke19yZXNvdXJjZSBpbnN0YW5jZW9mIEdyYXBoSW5zdGFuY2UgPyBfcmVzb3VyY2UuaWRTb3VyY2UgOiBfcmVzb3VyY2UuaWRSZXNvdXJjZX06IEZhaWxlZCB0byBsb2FkIHJlc291cmNlLmApO1xyXG4gICAgICAgIGlmICghKF9yZXNvdXJjZSBpbnN0YW5jZW9mIEdyYXBoSW5zdGFuY2UpKVxyXG4gICAgICAgICAgX3Jlc291cmNlLnN0YXR1cyA9IFJFU09VUkNFX1NUQVRVUy5FUlJPUjtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9yZXNvdXJjZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEobG9hZGVkIGluc3RhbmNlb2YgR3JhcGhJbnN0YW5jZSkpIHtcclxuICAgICAgICBsb2FkZWQuc3RhdHVzID0gUkVTT1VSQ0VfU1RBVFVTLlJFQURZO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBpZiAoY2FjaGVkICYmICEoX3Jlc291cmNlIGluc3RhbmNlb2YgR3JhcGhJbnN0YW5jZSkpIHtcclxuXHJcbiAgICAgIC8vICAgaWYgKCFQcm9qZWN0LnJlc291cmNlc1tjYWNoZWQuaWRSZXNvdXJjZV0pXHJcbiAgICAgIC8vICAgICBjYWNoZWQuaWRSZXNvdXJjZSA9IF9yZXNvdXJjZS5pZFJlc291cmNlOyAvLyBjaGFuZ2UgdGhlIGlkIG9mIHRoZSBjYWNoZWQgcmVzb3VyY2UgdG8gdGhlIGlkIG9mIHRoZSByZXNvdXJjZSB0aGF0IHJlcXVlc3RlZCBpdFxyXG5cclxuICAgICAgLy8gICBpZiAoY2FjaGVkLmlkUmVzb3VyY2UgIT0gX3Jlc291cmNlLmlkUmVzb3VyY2UpIHtcclxuICAgICAgLy8gICAgIC8vIHR3byBkaWZmZXJlbnQgcmVzb3VyY2VzIGhhdmUgcmVxdWVzdGVkIHRoZSBzYW1lIGNhY2hlZCByZXNvdXJjZVxyXG4gICAgICAvLyAgICAgRGVidWcuZXJyb3IoYCR7X3Jlc291cmNlLmlkUmVzb3VyY2V9OiBGYWlsZWQgdG8gbG9hZCByZXNvdXJjZS4gJHtfcmVzb3VyY2UudHlwZX0gd2l0aCBuYW1lICcke19yZXNvdXJjZS5uYW1lfScgZnJvbSAnJHtsb2FkZXIubmFtZX0nIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkIGJ5ICcke2NhY2hlZC5pZFJlc291cmNlfScuIFBsZWFzZSBkZWxldGUgdGhlIGR1cGxpY2F0ZSAnJHtfcmVzb3VyY2UuaWRSZXNvdXJjZX0nIGZyb20gdGhlIHByb2plY3QuYCk7XHJcbiAgICAgIC8vICAgICByZXR1cm4gX3Jlc291cmNlO1xyXG4gICAgICAvLyAgIH1cclxuXHJcbiAgICAgIC8vIH1cclxuXHJcbiAgICAgIHJldHVybiBsb2FkZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIEdMVEZMb2FkZXJ9IGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gdXJsIG9yIG51bGwgaWYgdGhlIHVybCBjYW4ndCBiZSByZXNvbHZlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBMT0FEKF91cmw6IHN0cmluZywgX3JlZ2lzdGVyUmVzb3VyY2VzOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPEdMVEZMb2FkZXI+IHtcclxuICAgICAgaWYgKCF0aGlzLmxvYWRlcnMpXHJcbiAgICAgICAgR0xURkxvYWRlci5sb2FkZXJzID0ge307XHJcblxyXG4gICAgICBpZiAoIXRoaXMubG9hZGVyc1tfdXJsXSkge1xyXG4gICAgICAgIGxldCBnbHRmOiBHTFRGLkdsVGY7XHJcbiAgICAgICAgbGV0IGJ1ZmZlcjogQXJyYXlCdWZmZXI7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlOiBSZXNwb25zZSA9IGF3YWl0IGZldGNoKG5ldyBVUkwoX3VybCwgUHJvamVjdC5iYXNlVVJMKSk7XHJcbiAgICAgICAgICBjb25zdCBmaWxlRXh0ZW5zaW9uOiBzdHJpbmcgPSBfdXJsLnNwbGl0KCcuJykucG9wKCk/LnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgaWYgKGZpbGVFeHRlbnNpb24gPT0gXCJnbHRmXCIpXHJcbiAgICAgICAgICAgIGdsdGYgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICAgICAgaWYgKGZpbGVFeHRlbnNpb24gPT0gXCJnbGJcIikge1xyXG4gICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlcjogQXJyYXlCdWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhVmlldzogRGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbWFnaWM6IG51bWJlciA9IGRhdGFWaWV3LmdldFVpbnQzMigwLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKG1hZ2ljICE9PSAweDQ2NTQ2QzY3KVxyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtHTFRGTG9hZGVyLm5hbWV9IHwgJHtfdXJsfTogSW52YWxpZCBtYWdpYyBudW1iZXIgaW4gR0xCIGZpbGUuYCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uOiBudW1iZXIgPSBkYXRhVmlldy5nZXRVaW50MzIoNCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uICE9IDIpXHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0dMVEZMb2FkZXIubmFtZX0gfCAke191cmx9OiBVbnN1cHBvcnRlZCB2ZXJzaW9uIGluIEdMQiBmaWxlLmApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QganNvbkxlbmd0aDogbnVtYmVyID0gZGF0YVZpZXcuZ2V0VWludDMyKDEyLCB0cnVlKTtcclxuICAgICAgICAgICAgY29uc3QganNvbkZvcm1hdDogbnVtYmVyID0gZGF0YVZpZXcuZ2V0VWludDMyKDE2LCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChqc29uRm9ybWF0ICE9PSAweDRFNEY1MzRBKVxyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmb3JtYXQuIFRoZSBmaXJzdCBjaHVuayBvZiB0aGUgZmlsZSBpcyBub3QgaW4gSlNPTiBmb3JtYXQuJyk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyOiBUZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBqc29uQ2h1bms6IHN0cmluZyA9IGRlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCAyMCwganNvbkxlbmd0aCkpO1xyXG4gICAgICAgICAgICBnbHRmID0gSlNPTi5wYXJzZShqc29uQ2h1bmspO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGggPj0gMjAgKyBqc29uTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgYmluYXJ5TGVuZ3RoOiBudW1iZXIgPSBkYXRhVmlldy5nZXRVaW50MzIoMjAgKyBqc29uTGVuZ3RoLCB0cnVlKTtcclxuICAgICAgICAgICAgICBjb25zdCBiaW5hcnlGb3JtYXQ6IG51bWJlciA9IGRhdGFWaWV3LmdldFVpbnQzMigyNCArIGpzb25MZW5ndGgsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoYmluYXJ5Rm9ybWF0ICE9PSAweDAwNEU0OTQyKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZvcm1hdC4gVGhlIHNlY29uZCBjaHVuayBvZiB0aGUgZmlsZSBpcyBub3QgaW4gYmluYXJ5IGZvcm1hdC4nKTtcclxuXHJcbiAgICAgICAgICAgICAgYnVmZmVyID0gYXJyYXlCdWZmZXIuc2xpY2UoMjggKyBqc29uTGVuZ3RoLCAyOCArIGpzb25MZW5ndGggKyBiaW5hcnlMZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuICAgICAgICAgIERlYnVnLmVycm9yKGAke0dMVEZMb2FkZXIubmFtZX0gfCAke191cmx9OiBGYWlsZWQgdG8gbG9hZCBmaWxlLiAke2Vycm9yfWApO1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBHTFRGTG9hZGVyLmNoZWNrQ29tcGF0aWJpbGl0eShnbHRmLCBfdXJsKTtcclxuICAgICAgICBHTFRGTG9hZGVyLnByZVByb2Nlc3MoZ2x0ZiwgX3VybCk7XHJcblxyXG4gICAgICAgIEdMVEZMb2FkZXIubG9hZGVyc1tfdXJsXSA9IG5ldyBHTFRGTG9hZGVyKGdsdGYsIF91cmwsIGJ1ZmZlcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBHTFRGTG9hZGVyLmxvYWRlcnNbX3VybF07XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY2hlY2tDb21wYXRpYmlsaXR5KF9nbHRmOiBHTFRGLkdsVGYsIF91cmw6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICBpZiAoX2dsdGYuYXNzZXQudmVyc2lvbiAhPSBcIjIuMFwiKVxyXG4gICAgICAgIERlYnVnLndhcm4oYCR7R0xURkxvYWRlci5uYW1lfSB8ICR7X3VybH06IFRoaXMgbG9hZGVyIHdhcyBkZXZlbG9wZWQgZm9yIGdsVEYgMi4wLiBJdCBtYXkgbm90IHdvcmsgYXMgaW50ZW5kZWQgd2l0aCB2ZXJzaW9uICR7X2dsdGYuYXNzZXQudmVyc2lvbn0uYCk7XHJcbiAgICAgIGlmIChfZ2x0Zi5hc3NldC5taW5WZXJzaW9uICE9IHVuZGVmaW5lZCAmJiBfZ2x0Zi5hc3NldC5taW5WZXJzaW9uICE9IFwiMi4wXCIpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0dMVEZMb2FkZXIubmFtZX0gfCAke191cmx9OiBUaGlzIGxvYWRlciB3YXMgZGV2ZWxvcGVkIGZvciBnbFRGIDIuMC4gSXQgZG9lcyBub3Qgd29yayB3aXRoIHJlcXVpcmVkIG1pbiB2ZXJzaW9uICR7X2dsdGYuYXNzZXQubWluVmVyc2lvbn0uYCk7XHJcbiAgICAgIGlmIChfZ2x0Zi5leHRlbnNpb25zVXNlZD8ubGVuZ3RoID4gMClcclxuICAgICAgICBEZWJ1Zy53YXJuKGAke0dMVEZMb2FkZXIubmFtZX0gfCAke191cmx9OiBUaGlzIGxvYWRlciBkb2VzIG5vdCBzdXBwb3J0IGdsVEYgZXh0ZW5zaW9ucy4gSXQgbWF5IG5vdCB3b3JrIGFzIGludGVuZGVkIHdpdGggZXh0ZW5zaW9ucyAke19nbHRmLmV4dGVuc2lvbnNVc2VkLnRvU3RyaW5nKCl9LmApO1xyXG4gICAgICBpZiAoX2dsdGYuZXh0ZW5zaW9uc1JlcXVpcmVkPy5sZW5ndGggPiAwKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtHTFRGTG9hZGVyLm5hbWV9IHwgJHtfdXJsfTogVGhpcyBsb2FkZXIgZG9lcyBub3Qgc3VwcG9ydCBnbFRGIGV4dGVuc2lvbnMuIEl0IGRvZXMgbm90IHdvcmsgd2l0aCByZXF1aXJlZCBleHRlbnNpb25zICR7X2dsdGYuZXh0ZW5zaW9uc1JlcXVpcmVkLnRvU3RyaW5nKCl9LmApO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHByZVByb2Nlc3MoX2dsdGY6IEdMVEYuR2xUZiwgX3VybDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIC8vIGFkZCBhIG5hbWUgdG8gZWFjaCBzY2VuZVxyXG4gICAgICBpZiAoX2dsdGYuc2NlbmVzKSB7XHJcbiAgICAgICAgX2dsdGYuc2NlbmUgPSBfZ2x0Zi5zY2VuZSA/PyAwO1xyXG4gICAgICAgIGFkZE5hbWVzKFwiU2NlbmVcIiwgX2dsdGYuc2NlbmVzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKF9nbHRmLm5vZGVzKSB7XHJcbiAgICAgICAgLy8gbWFyayBhbGwgbm9kZXMgdGhhdCBhcmUgYW5pbWF0ZWRcclxuICAgICAgICBfZ2x0Zi5hbmltYXRpb25zPy5mb3JFYWNoKF9hbmltYXRpb24gPT4ge1xyXG4gICAgICAgICAgX2FuaW1hdGlvbi5jaGFubmVscy5mb3JFYWNoKF9jaGFubmVsID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaU5vZGU6IG51bWJlciA9IF9jaGFubmVsLnRhcmdldC5ub2RlO1xyXG4gICAgICAgICAgICBpZiAoaU5vZGUgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgIF9nbHRmLm5vZGVzW2lOb2RlXS5pc0FuaW1hdGVkID0gdHJ1ZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBtYXJrIHBhcmVudCBvZiBlYWNoIG5vZGVcclxuICAgICAgICBfZ2x0Zi5ub2Rlcy5mb3JFYWNoKChfbm9kZSwgX2lOb2RlKSA9PiBfbm9kZS5jaGlsZHJlbj8uZm9yRWFjaChfaUNoaWxkID0+IF9nbHRmLm5vZGVzW19pQ2hpbGRdLnBhcmVudCA9IF9pTm9kZSkpO1xyXG5cclxuICAgICAgICBfZ2x0Zi5ub2Rlcy5mb3JFYWNoKChfbm9kZSwgX2lOb2RlKSA9PiB7XHJcbiAgICAgICAgICAvLyBhZGQgbmFtZXMgdG8gbm9kZXMgdGhhdCBkb24ndCBoYXZlIG9uZVxyXG4gICAgICAgICAgaWYgKF9ub2RlLm5hbWUgPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBfbm9kZS5uYW1lID0gYE5vZGUke19pTm9kZX1gO1xyXG5cclxuICAgICAgICAgIGlmIChfbm9kZS5pc0FuaW1hdGVkKSB7XHJcbiAgICAgICAgICAgIC8vIGFkZCBwYXRoIHRvIGVhY2ggYW5pbWF0ZWQgbm9kZVxyXG4gICAgICAgICAgICBsZXQgaVBhcmVudDogbnVtYmVyID0gX25vZGUucGFyZW50O1xyXG4gICAgICAgICAgICBsZXQgcGF0aDogbnVtYmVyW10gPSBbXTtcclxuICAgICAgICAgICAgcGF0aC5wdXNoKF9pTm9kZSk7XHJcbiAgICAgICAgICAgIHdoaWxlIChpUGFyZW50ICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgIHBhdGgucHVzaChpUGFyZW50KTtcclxuICAgICAgICAgICAgICBpUGFyZW50ID0gX2dsdGYubm9kZXNbaVBhcmVudF0ucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9ub2RlLnBhdGggPSBwYXRoLnJldmVyc2UoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChfZ2x0Zi5tYXRlcmlhbHMpXHJcbiAgICAgICAgYWRkTmFtZXMoXCJNYXRlcmlhbFwiLCBfZ2x0Zi5tYXRlcmlhbHMpO1xyXG5cclxuICAgICAgaWYgKF9nbHRmLm1lc2hlcylcclxuICAgICAgICBhZGROYW1lcyhcIk1lc2hcIiwgX2dsdGYubWVzaGVzKTtcclxuXHJcbiAgICAgIGlmIChfZ2x0Zi5hbmltYXRpb25zKVxyXG4gICAgICAgIGFkZE5hbWVzKFwiQW5pbWF0aW9uXCIsIF9nbHRmLmFuaW1hdGlvbnMpO1xyXG5cclxuICAgICAgZnVuY3Rpb24gYWRkTmFtZXMoX3RlbXBsYXRlOiBzdHJpbmcsIF90YXJnZXQ6IHsgbmFtZT86IHN0cmluZyB9W10pOiB2b2lkIHtcclxuICAgICAgICBfdGFyZ2V0LmZvckVhY2goKF9pdGVtLCBfaW5kZXgpID0+IHtcclxuICAgICAgICAgIGlmIChfaXRlbS5uYW1lID09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgX2l0ZW0ubmFtZSA9IGAke190ZW1wbGF0ZX0ke19pbmRleH1gO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBnbFRGIGZpbGUgbmFtZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBuYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLiN1cmwuc3BsaXQoXCJcXFxcXCIpLnBvcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBuZXcgaW5zdGFuY2VzIG9mIGFsbCByZXNvdXJjZXMgb2YgdGhlIGdpdmVuIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkUmVzb3VyY2VzPFQgZXh0ZW5kcyBTZXJpYWxpemFibGVSZXNvdXJjZUV4dGVybmFsPihfY2xhc3M6IG5ldyAoKSA9PiBUKTogUHJvbWlzZTxUW10+IHtcclxuICAgICAgbGV0IHJlc291cmNlczogU2VyaWFsaXphYmxlUmVzb3VyY2VFeHRlcm5hbFtdID0gW107XHJcbiAgICAgIHN3aXRjaCAoX2NsYXNzLm5hbWUpIHtcclxuICAgICAgICBjYXNlIEdyYXBoLm5hbWU6XHJcbiAgICAgICAgICBmb3IgKGxldCBpU2NlbmU6IG51bWJlciA9IDA7IGlTY2VuZSA8IHRoaXMuI2dsdGYuc2NlbmVzPy5sZW5ndGg7IGlTY2VuZSsrKVxyXG4gICAgICAgICAgICByZXNvdXJjZXMucHVzaChhd2FpdCB0aGlzLmdldEdyYXBoKGlTY2VuZSwgbmV3IEdyYXBoR0xURigpKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIE1lc2gubmFtZTpcclxuICAgICAgICAgIGZvciAobGV0IGlNZXNoOiBudW1iZXIgPSAwOyBpTWVzaCA8IHRoaXMuI2dsdGYubWVzaGVzPy5sZW5ndGg7IGlNZXNoKyspXHJcbiAgICAgICAgICAgIGZvciAobGV0IGlQcmltaXRpdmU6IG51bWJlciA9IDA7IGlQcmltaXRpdmUgPCB0aGlzLiNnbHRmLm1lc2hlc1tpTWVzaF0ucHJpbWl0aXZlcy5sZW5ndGg7IGlQcmltaXRpdmUrKylcclxuICAgICAgICAgICAgICByZXNvdXJjZXMucHVzaChhd2FpdCB0aGlzLmdldE1lc2goaU1lc2gsIGlQcmltaXRpdmUsIG5ldyBNZXNoR0xURigpKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIE1hdGVyaWFsLm5hbWU6XHJcbiAgICAgICAgICBmb3IgKGxldCBpTWF0ZXJpYWw6IG51bWJlciA9IDA7IGlNYXRlcmlhbCA8IHRoaXMuI2dsdGYubWF0ZXJpYWxzPy5sZW5ndGg7IGlNYXRlcmlhbCsrKVxyXG4gICAgICAgICAgICByZXNvdXJjZXMucHVzaChhd2FpdCB0aGlzLmdldE1hdGVyaWFsKGlNYXRlcmlhbCwgbmV3IE1hdGVyaWFsR0xURihcIkhpIDopXCIpKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIEFuaW1hdGlvbi5uYW1lOlxyXG4gICAgICAgICAgZm9yIChsZXQgaUFuaW1hdGlvbjogbnVtYmVyID0gMDsgaUFuaW1hdGlvbiA8IHRoaXMuI2dsdGYuYW5pbWF0aW9ucz8ubGVuZ3RoOyBpQW5pbWF0aW9uKyspXHJcbiAgICAgICAgICAgIHJlc291cmNlcy5wdXNoKGF3YWl0IHRoaXMuZ2V0QW5pbWF0aW9uKGlBbmltYXRpb24sIG5ldyBBbmltYXRpb25HTFRGKCkpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIHJlc291cmNlcykge1xyXG4gICAgICAgIGlmICghUHJvamVjdC5yZXNvdXJjZXNbcmVzb3VyY2UuaWRSZXNvdXJjZV0pXHJcbiAgICAgICAgICBQcm9qZWN0LnJlZ2lzdGVyKHJlc291cmNlKTtcclxuXHJcbiAgICAgICAgcmVzb3VyY2Uuc3RhdHVzID0gUkVTT1VSQ0VfU1RBVFVTLlJFQURZO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gPFRbXT5yZXNvdXJjZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIEdyYXBofSBmb3IgdGhlIGdpdmVuIHNjZW5lIG5hbWUgb3IgdGhlIGRlZmF1bHQgc2NlbmUgaWYgbm8gbmFtZSBpcyBnaXZlbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldEdyYXBoKF9uYW1lPzogc3RyaW5nKTogUHJvbWlzZTxHcmFwaD47XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgR3JhcGh9IGZvciB0aGUgZ2l2ZW4gc2NlbmUgaW5kZXggb3IgdGhlIGRlZmF1bHQgc2NlbmUgaWYgbm8gaW5kZXggaXMgZ2l2ZW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRHcmFwaChfaVNjZW5lPzogbnVtYmVyKTogUHJvbWlzZTxHcmFwaD47XHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgc2NlbmUgZnJvbSB0aGUgZ2xURiBmaWxlIGludG8gdGhlIGdpdmVuIHtAbGluayBHcmFwaH0uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldEdyYXBoPFQgZXh0ZW5kcyBOb2RlPihfaVNjZW5lOiBudW1iZXIgfCBzdHJpbmcsIF9ncmFwaE91dDogVCk6IFByb21pc2U8VD47XHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0R3JhcGgoX2lTY2VuZTogbnVtYmVyIHwgc3RyaW5nID0gdGhpcy4jZ2x0Zi5zY2VuZSwgX2dyYXBoT3V0PzogTm9kZSk6IFByb21pc2U8Tm9kZT4ge1xyXG4gICAgICBfaVNjZW5lID0gdGhpcy5nZXRJbmRleChfaVNjZW5lLCB0aGlzLiNnbHRmLnNjZW5lcyk7XHJcblxyXG4gICAgICBpZiAoX2lTY2VuZSA9PSAtMSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIGNvbnN0IGlkOiBzdHJpbmcgPSBgJHtHcmFwaEdMVEYubmFtZX18JHtfaVNjZW5lfWA7XHJcblxyXG4gICAgICBpZiAoIV9ncmFwaE91dCAmJiB0aGlzLiNyZXNvdXJjZXNbaWRdKVxyXG4gICAgICAgIHJldHVybiA8Tm9kZT48dW5rbm93bj50aGlzLiNyZXNvdXJjZXNbaWRdO1xyXG5cclxuICAgICAgbGV0IGNhY2hlOiBHTFRGTG9hZGluZ0NhY2hlID0ge1xyXG4gICAgICAgIG5vZGVzOiBbXSxcclxuICAgICAgICBza2VsZXRvbnM6IFtdXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBnbHRmU2NlbmU6IEdMVEYuU2NlbmUgPSB0aGlzLiNnbHRmLnNjZW5lc1tfaVNjZW5lXTtcclxuICAgICAgY29uc3QgZ3JhcGg6IE5vZGUgPSBfZ3JhcGhPdXQgPz8gbmV3IEdyYXBoR0xURigpO1xyXG4gICAgICBncmFwaC5uYW1lID0gZ2x0ZlNjZW5lLm5hbWU7XHJcbiAgICAgIGlmIChncmFwaCBpbnN0YW5jZW9mIEdyYXBoR0xURilcclxuICAgICAgICBncmFwaC51cmwgPSB0aGlzLiN1cmw7XHJcbiAgICAgIGlmIChfZ3JhcGhPdXQpIHtcclxuICAgICAgICBfZ3JhcGhPdXQucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcclxuICAgICAgICBfZ3JhcGhPdXQucmVtb3ZlQ29tcG9uZW50cyhDb21wb25lbnRTa2VsZXRvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoY29uc3QgaU5vZGUgb2YgZ2x0ZlNjZW5lLm5vZGVzKVxyXG4gICAgICAgIGdyYXBoLmFkZENoaWxkKGF3YWl0IHRoaXMuZ2V0Tm9kZUJ5SW5kZXgoaU5vZGUsIGNhY2hlKSk7XHJcblxyXG4gICAgICAvLyBpZiAodGhpcy4jZ2x0Zi5hbmltYXRpb25zPy5sZW5ndGggPiAwICYmICFncmFwaC5nZXRDb21wb25lbnQoQ29tcG9uZW50QW5pbWF0aW9uKSkge1xyXG4gICAgICAvLyAgIGxldCBhbmltYXRpb246IEFuaW1hdGlvbiA9IGF3YWl0IHRoaXMuZ2V0QW5pbWF0aW9uKDApO1xyXG4gICAgICAvLyAgIFByb2plY3QucmVnaXN0ZXIoYW5pbWF0aW9uKTtcclxuICAgICAgLy8gICBncmFwaC5hZGRDb21wb25lbnQobmV3IENvbXBvbmVudEFuaW1hdGlvbihhbmltYXRpb24pKTtcclxuICAgICAgLy8gfVxyXG5cclxuICAgICAgZm9yIChjb25zdCBza2VsZXRvbiBvZiBjYWNoZS5za2VsZXRvbnMpXHJcbiAgICAgICAgZ3JhcGguYWRkQ29tcG9uZW50KHNrZWxldG9uKTtcclxuXHJcbiAgICAgIGlmICghX2dyYXBoT3V0KVxyXG4gICAgICAgIHRoaXMuI3Jlc291cmNlc1tpZF0gPSA8R3JhcGhHTFRGPmdyYXBoO1xyXG5cclxuICAgICAgcmV0dXJuIGdyYXBoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3Qge0BsaW5rIEFuaW1hdGlvbn0gd2l0aCB0aGUgZ2l2ZW4gYW5pbWF0aW9uIG5hbWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRBbmltYXRpb24oX25hbWU6IHN0cmluZyk6IFByb21pc2U8QW5pbWF0aW9uPjtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIEFuaW1hdGlvbn0gZm9yIHRoZSBnaXZlbiBhbmltYXRpb24gaW5kZXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRBbmltYXRpb24oX2lBbmltYXRpb246IG51bWJlcik6IFByb21pc2U8QW5pbWF0aW9uPjtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYW4gYW5pbWF0aW9uIGZyb20gdGhlIGdsVEYgZmlsZSBpbnRvIHRoZSBnaXZlbiB7QGxpbmsgQW5pbWF0aW9ufS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0QW5pbWF0aW9uPFQgZXh0ZW5kcyBBbmltYXRpb24+KF9pQW5pbWF0aW9uOiBudW1iZXIgfCBzdHJpbmcsIF9hbmltYXRpb25PdXQ6IFQpOiBQcm9taXNlPFQ+O1xyXG4gICAgcHVibGljIGFzeW5jIGdldEFuaW1hdGlvbihfaUFuaW1hdGlvbjogbnVtYmVyIHwgc3RyaW5nLCBfYW5pbWF0aW9uT3V0PzogQW5pbWF0aW9uKTogUHJvbWlzZTxBbmltYXRpb24+IHtcclxuICAgICAgX2lBbmltYXRpb24gPSB0aGlzLmdldEluZGV4KF9pQW5pbWF0aW9uLCB0aGlzLiNnbHRmLmFuaW1hdGlvbnMpO1xyXG5cclxuICAgICAgaWYgKF9pQW5pbWF0aW9uID09IC0xKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgY29uc3QgaWQ6IHN0cmluZyA9IGAke0FuaW1hdGlvbi5uYW1lfXwke19pQW5pbWF0aW9ufWA7XHJcblxyXG4gICAgICBpZiAoIV9hbmltYXRpb25PdXQgJiYgdGhpcy4jcmVzb3VyY2VzW2lkXSlcclxuICAgICAgICByZXR1cm4gPEFuaW1hdGlvbj50aGlzLiNyZXNvdXJjZXNbaWRdO1xyXG5cclxuICAgICAgY29uc3QgZ2x0ZkFuaW1hdGlvbjogR0xURi5BbmltYXRpb24gPSB0aGlzLiNnbHRmLmFuaW1hdGlvbnM/LltfaUFuaW1hdGlvbl07XHJcblxyXG4gICAgICBpZiAoIWdsdGZBbmltYXRpb24pXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXN9OiBDb3VsZG4ndCBmaW5kIGFuaW1hdGlvbiB3aXRoIGluZGV4ICR7X2lBbmltYXRpb259LmApO1xyXG5cclxuICAgICAgY29uc3QgYW5pbWF0aW9uU3RydWN0dXJlOiBBbmltYXRpb25TdHJ1Y3R1cmUgPSB7fTtcclxuICAgICAgZm9yIChjb25zdCBnbHRmQ2hhbm5lbCBvZiBnbHRmQW5pbWF0aW9uLmNoYW5uZWxzKSB7XHJcbiAgICAgICAgaWYgKGdsdGZDaGFubmVsLnRhcmdldC5wYXRoID09IFwid2VpZ2h0c1wiKSB7XHJcbiAgICAgICAgICBEZWJ1Zy53YXJuKGAke3RoaXN9OiBBbmltYXRpb24gd2l0aCBpbmRleCAke19pQW5pbWF0aW9ufSBoYXMgYSB0YXJnZXQgcGF0aCBvZiAnd2VpZ2h0cycuIEZVREdFIGRvZXMgbm90IHN1cHBvcnQgbW9ycGggdGFyZ2V0cy5gKTtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZ2x0Zk5vZGU6IEdMVEYuTm9kZSA9IHRoaXMuI2dsdGYubm9kZXNbZ2x0ZkNoYW5uZWwudGFyZ2V0Lm5vZGVdO1xyXG4gICAgICAgIGlmICghZ2x0Zk5vZGUpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgbGV0IG5vZGU6IEdlbmVyYWwgPSBhbmltYXRpb25TdHJ1Y3R1cmU7XHJcbiAgICAgICAgZm9yIChjb25zdCBpTm9kZSBvZiBnbHRmTm9kZS5wYXRoKSB7XHJcbiAgICAgICAgICBjb25zdCBjaGlsZE5hbWU6IHN0cmluZyA9IHRoaXMuI2dsdGYubm9kZXNbaU5vZGVdLm5hbWU7XHJcbiAgICAgICAgICAvLyBub2RlLmNoaWxkcmVuW2NoaWxkTmFtZV1cclxuICAgICAgICAgIG5vZGUgPSAobm9kZS5jaGlsZHJlbiA/Pz0ge30pW2NoaWxkTmFtZV0gPz89IHt9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbm9kZS5jb21wb25lbnRzLkNvbXBvbmVudFRyYW5zZm9ybVswXS5tdHhMb2NhbFxyXG4gICAgICAgIHR5cGUgQW5pbWF0aW9uU2VxdWVuY2VNYXRyaXg0eDQgPSB7IHRyYW5zbGF0aW9uPzogQW5pbWF0aW9uU2VxdWVuY2U8VmVjdG9yMz47IHJvdGF0aW9uPzogQW5pbWF0aW9uU2VxdWVuY2U8UXVhdGVybmlvbj47IHNjYWxpbmc/OiBBbmltYXRpb25TZXF1ZW5jZTxWZWN0b3IzPiB9O1xyXG4gICAgICAgIGxldCBtdHhMb2NhbDogQW5pbWF0aW9uU2VxdWVuY2VNYXRyaXg0eDQgPSAoKCgobm9kZS5jb21wb25lbnRzID8/PSB7fSkuQ29tcG9uZW50VHJhbnNmb3JtID8/PSBbXSlbMF0gPz89IHt9KS5tdHhMb2NhbCA/Pz0ge30pO1xyXG4gICAgICAgIG10eExvY2FsW3RvSW50ZXJuVHJhbnNmb3JtYXRpb25bZ2x0ZkNoYW5uZWwudGFyZ2V0LnBhdGhdXSA9XHJcbiAgICAgICAgICA8R2VuZXJhbD5hd2FpdCB0aGlzLmdldEFuaW1hdGlvblNlcXVlbmNlKGdsdGZBbmltYXRpb24uc2FtcGxlcnNbZ2x0ZkNoYW5uZWwuc2FtcGxlcl0sIGdsdGZDaGFubmVsLnRhcmdldC5wYXRoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYW5pbWF0aW9uOiBBbmltYXRpb24gPSBfYW5pbWF0aW9uT3V0ID8/IG5ldyBBbmltYXRpb25HTFRGKCk7XHJcbiAgICAgIGFuaW1hdGlvbi5hbmltYXRpb25TdHJ1Y3R1cmUgPSBhbmltYXRpb25TdHJ1Y3R1cmU7XHJcbiAgICAgIGFuaW1hdGlvbi5jbGVhckNhY2hlKCk7XHJcbiAgICAgIGFuaW1hdGlvbi5uYW1lID0gZ2x0ZkFuaW1hdGlvbi5uYW1lO1xyXG4gICAgICBhbmltYXRpb24uY2FsY3VsYXRlVG90YWxUaW1lKCk7XHJcbiAgICAgIGlmIChhbmltYXRpb24gaW5zdGFuY2VvZiBBbmltYXRpb25HTFRGKVxyXG4gICAgICAgIGFuaW1hdGlvbi51cmwgPSB0aGlzLiN1cmw7XHJcbiAgICAgIGlmICghX2FuaW1hdGlvbk91dCkge1xyXG4gICAgICAgIFByb2plY3QuZGVyZWdpc3RlcihhbmltYXRpb24pO1xyXG4gICAgICAgIHRoaXMuI3Jlc291cmNlc1tpZF0gPSBhbmltYXRpb247XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhbmltYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB7QGxpbmsgTWVzaEdMVEZ9IHdpdGggdGhlIGdpdmVuIG5hbWUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRNZXNoKF9uYW1lOiBzdHJpbmcsIF9pUHJpbWl0aXZlPzogbnVtYmVyKTogUHJvbWlzZTxNZXNoPjtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIE1lc2hHTFRGfSBmb3IgdGhlIGdpdmVuIG1lc2ggaW5kZXggYW5kIHByaW1pdGl2ZSBpbmRleC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldE1lc2goX2lNZXNoOiBudW1iZXIsIF9pUHJpbWl0aXZlPzogbnVtYmVyKTogUHJvbWlzZTxNZXNoPjtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSBtZXNoIGZyb20gdGhlIGdsVEYgZmlsZSBpbnRvIHRoZSBnaXZlbiB7QGxpbmsgTWVzaH0uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWVzaDxUIGV4dGVuZHMgTWVzaD4oX2lNZXNoOiBudW1iZXIgfCBzdHJpbmcsIF9pUHJpbWl0aXZlOiBudW1iZXIsIF9tZXNoT3V0OiBUKTogUHJvbWlzZTxUPjtcclxuICAgIHB1YmxpYyBhc3luYyBnZXRNZXNoKF9pTWVzaDogbnVtYmVyIHwgc3RyaW5nLCBfaVByaW1pdGl2ZTogbnVtYmVyID0gMCwgX21lc2hPdXQ/OiBNZXNoKTogUHJvbWlzZTxNZXNoPiB7XHJcbiAgICAgIF9pTWVzaCA9IHRoaXMuZ2V0SW5kZXgoX2lNZXNoLCB0aGlzLiNnbHRmLm1lc2hlcyk7XHJcblxyXG4gICAgICBpZiAoX2lNZXNoID09IC0xKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgY29uc3QgaWQ6IHN0cmluZyA9IGAke01lc2hHTFRGLm5hbWV9fCR7X2lNZXNofXwke19pUHJpbWl0aXZlfWA7XHJcblxyXG4gICAgICBpZiAoIV9tZXNoT3V0ICYmIHRoaXMuI3Jlc291cmNlc1tpZF0pXHJcbiAgICAgICAgcmV0dXJuIDxNZXNoR0xURj50aGlzLiNyZXNvdXJjZXNbaWRdO1xyXG5cclxuICAgICAgY29uc3QgZ2x0Zk1lc2g6IEdMVEYuTWVzaCA9IHRoaXMuI2dsdGYubWVzaGVzW19pTWVzaF07XHJcbiAgICAgIGNvbnN0IGdsdGZQcmltaXRpdmU6IEdMVEYuTWVzaFByaW1pdGl2ZSA9IGdsdGZNZXNoLnByaW1pdGl2ZXNbX2lQcmltaXRpdmVdO1xyXG5cclxuICAgICAgaWYgKGdsdGZQcmltaXRpdmUuaW5kaWNlcyA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgRGVidWcud2FybihgJHt0aGlzfTogTWVzaCB3aXRoIGluZGV4ICR7X2lNZXNofSBwcmltaXRpdmUgJHtfaVByaW1pdGl2ZX0gaGFzIG5vIGluZGljZXMuIEZVREdFIGRvZXMgbm90IHN1cHBvcnQgbm9uLWluZGV4ZWQgbWVzaGVzLmApO1xyXG5cclxuICAgICAgaWYgKGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcy5QT1NJVElPTiA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgRGVidWcud2FybihgJHt0aGlzfTogTWVzaCB3aXRoIGluZGV4ICR7X2lNZXNofSBwcmltaXRpdmUgJHtfaVByaW1pdGl2ZX0gaGFzIG5vIHBvc2l0aW9uIGF0dHJpYnV0ZS4gUHJpbWl0aXZlIHdpbGwgYmUgaWdub3JlZC5gKTtcclxuXHJcbiAgICAgIGlmIChnbHRmUHJpbWl0aXZlLm1vZGUgIT0gdW5kZWZpbmVkICYmIGdsdGZQcmltaXRpdmUubW9kZSAhPSBHTFRGLk1FU0hfUFJJTUlUSVZFX01PREUuVFJJQU5HTEVTKVxyXG4gICAgICAgIERlYnVnLndhcm4oYCR7dGhpc306IE1lc2ggd2l0aCBpbmRleCAke19pTWVzaH0gcHJpbWl0aXZlICR7X2lQcmltaXRpdmV9IGhhcyB0b3BvbG9neSB0eXBlIG1vZGUgJHtHTFRGLk1FU0hfUFJJTUlUSVZFX01PREVbZ2x0ZlByaW1pdGl2ZS5tb2RlXX0uIEZVREdFIG9ubHkgc3VwcG9ydHMgJHtHTFRGLk1FU0hfUFJJTUlUSVZFX01PREVbNF19LmApO1xyXG5cclxuICAgICAgY2hlY2tNYXhTdXBwb3J0KHRoaXMsIFwiVEVYQ09PUkRcIiwgMik7XHJcbiAgICAgIGNoZWNrTWF4U3VwcG9ydCh0aGlzLCBcIkNPTE9SXCIsIDEpO1xyXG4gICAgICBjaGVja01heFN1cHBvcnQodGhpcywgXCJKT0lOVFNcIiwgMSk7XHJcbiAgICAgIGNoZWNrTWF4U3VwcG9ydCh0aGlzLCBcIldFSUdIVFNcIiwgMSk7XHJcblxyXG4gICAgICBsZXQgcG9zaXRpb25zOiBGbG9hdDMyQXJyYXksIGluZGljZXM6IFVpbnQxNkFycmF5O1xyXG4gICAgICBsZXQgbm9ybWFsczogRmxvYXQzMkFycmF5LCB0YW5nZW50czogRmxvYXQzMkFycmF5O1xyXG4gICAgICBsZXQgY29sb3JzOiBGbG9hdDMyQXJyYXksIHRleHR1cmVVVnM6IEZsb2F0MzJBcnJheTtcclxuICAgICAgbGV0IGJvbmVzOiBVaW50OEFycmF5LCB3ZWlnaHRzOiBGbG9hdDMyQXJyYXk7XHJcblxyXG4gICAgICBpZiAoZ2x0ZlByaW1pdGl2ZS5pbmRpY2VzICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGluZGljZXMgPSBhd2FpdCB0aGlzLmdldFZlcnRleEluZGljZXMoZ2x0ZlByaW1pdGl2ZS5pbmRpY2VzKTtcclxuICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICAgICAgY29uc3QgdGVtcDogbnVtYmVyID0gaW5kaWNlc1tpICsgMl07XHJcbiAgICAgICAgICBpbmRpY2VzW2kgKyAyXSA9IGluZGljZXNbaSArIDBdO1xyXG4gICAgICAgICAgaW5kaWNlc1tpICsgMF0gPSBpbmRpY2VzW2kgKyAxXTtcclxuICAgICAgICAgIGluZGljZXNbaSArIDFdID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgRGVidWcud2FybihgJHt0aGlzfTogTWVzaCB3aXRoIGluZGV4ICR7X2lNZXNofSBwcmltaXRpdmUgJHtfaVByaW1pdGl2ZX0gaGFzIG5vIGluZGljZXMuIEZVREdFIGRvZXMgbm90IHN1cHBvcnQgbm9uLWluZGV4ZWQgbWVzaGVzLmApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLlBPU0lUSU9OICE9IHVuZGVmaW5lZClcclxuICAgICAgICBwb3NpdGlvbnMgPSBhd2FpdCB0aGlzLmdldEZsb2F0MzJBcnJheShnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuUE9TSVRJT04pO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgRGVidWcud2FybihgJHt0aGlzfTogTWVzaCB3aXRoIGluZGV4ICR7X2lNZXNofSBwcmltaXRpdmUgJHtfaVByaW1pdGl2ZX0gaGFzIG5vIHBvc2l0aW9uIGF0dHJpYnV0ZS4gUHJpbWl0aXZlIHdpbGwgYmUgaWdub3JlZC5gKTtcclxuXHJcbiAgICAgIGlmIChnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuTk9STUFMICE9IHVuZGVmaW5lZClcclxuICAgICAgICBub3JtYWxzID0gYXdhaXQgdGhpcy5nZXRGbG9hdDMyQXJyYXkoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLk5PUk1BTCk7XHJcbiAgICAgIC8vIFRPRE86IGNhbGN1bGF0ZSBmbGF0IG5vcm1hbHMgaWYgbm90IHByb3ZpZGVkLCBmdWRnZSB3aWxsIGNhbGN1bGF0ZSBzbW9vdGggbm9ybWFscyBpZiBub3QgcHJvdmlkZWRcclxuXHJcbiAgICAgIGlmIChnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuVEFOR0VOVCAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGFuZ2VudHMgPSBhd2FpdCB0aGlzLmdldEZsb2F0MzJBcnJheShnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuVEFOR0VOVCk7XHJcblxyXG4gICAgICBpZiAoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLlRFWENPT1JEXzEgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRleHR1cmVVVnMgPSBhd2FpdCB0aGlzLmdldEZsb2F0MzJBcnJheShnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuVEVYQ09PUkRfMSk7XHJcbiAgICAgIGVsc2UgaWYgKGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcy5URVhDT09SRF8wICE9IHVuZGVmaW5lZClcclxuICAgICAgICB0ZXh0dXJlVVZzID0gYXdhaXQgdGhpcy5nZXRGbG9hdDMyQXJyYXkoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLlRFWENPT1JEXzApO1xyXG5cclxuICAgICAgaWYgKGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcy5DT0xPUl8wICE9IHVuZGVmaW5lZClcclxuICAgICAgICBjb2xvcnMgPSBhd2FpdCB0aGlzLmdldFZlcnRleENvbG9ycyhnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuQ09MT1JfMCk7XHJcblxyXG4gICAgICBpZiAoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzLkpPSU5UU18wICE9IHVuZGVmaW5lZCAmJiBnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuV0VJR0hUU18wICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGJvbmVzID0gYXdhaXQgdGhpcy5nZXRCb25lSW5kaWNlcyhnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuSk9JTlRTXzApO1xyXG4gICAgICAgIHdlaWdodHMgPSBhd2FpdCB0aGlzLmdldEZsb2F0MzJBcnJheShnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMuV0VJR0hUU18wKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbWVzaDogTWVzaCA9IF9tZXNoT3V0ID8/IG5ldyBNZXNoR0xURigpO1xyXG4gICAgICBtZXNoLm5hbWUgPSBnbHRmTWVzaC5uYW1lO1xyXG4gICAgICBpZiAobWVzaCBpbnN0YW5jZW9mIE1lc2hHTFRGKSB7XHJcbiAgICAgICAgbWVzaC5pUHJpbWl0aXZlID0gX2lQcmltaXRpdmU7XHJcbiAgICAgICAgbWVzaC51cmwgPSB0aGlzLiN1cmw7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF9tZXNoT3V0KSB7XHJcbiAgICAgICAgX21lc2hPdXQuY2xlYXIoKTtcclxuICAgICAgICBfbWVzaE91dC5mYWNlcyA9IFtdO1xyXG4gICAgICAgIF9tZXNoT3V0LnZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghbm9ybWFscyB8fCAhdGFuZ2VudHMpIHtcclxuICAgICAgICAvLyBDcmVhdGUgbWVzaCB2ZXJ0aWNlcyBhbmQgZmFjZXMgc28gdGhhdCBub3JtYWxzIGFuZCB0YW5nZW50cyBjYW4gYmUgY2FsY3VsYXRlZCBpZiBlaXRoZXIgaXMgbWlzc2luZy5cclxuICAgICAgICBmb3IgKGxldCBpVmVjdG9yMjogbnVtYmVyID0gMCwgaVZlY3RvcjM6IG51bWJlciA9IDAsIGlWZWN0b3I0OiBudW1iZXIgPSAwOyBpVmVjdG9yMyA8IHBvc2l0aW9ucz8ubGVuZ3RoOyBpVmVjdG9yMiArPSAyLCBpVmVjdG9yMyArPSAzLCBpVmVjdG9yNCArPSA0KSB7XHJcbiAgICAgICAgICBtZXNoLnZlcnRpY2VzLnB1c2goXHJcbiAgICAgICAgICAgIG5ldyBWZXJ0ZXgoXHJcbiAgICAgICAgICAgICAgbmV3IFZlY3RvcjMocG9zaXRpb25zW2lWZWN0b3IzICsgMF0sIHBvc2l0aW9uc1tpVmVjdG9yMyArIDFdLCBwb3NpdGlvbnNbaVZlY3RvcjMgKyAyXSksXHJcbiAgICAgICAgICAgICAgdGV4dHVyZVVWcyA/XHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMih0ZXh0dXJlVVZzW2lWZWN0b3IyICsgMF0sIHRleHR1cmVVVnNbaVZlY3RvcjIgKyAxXSkgOlxyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIG5vcm1hbHMgP1xyXG4gICAgICAgICAgICAgICAgbmV3IFZlY3RvcjMobm9ybWFsc1tpVmVjdG9yMyArIDBdLCBub3JtYWxzW2lWZWN0b3IzICsgMV0sIG5vcm1hbHNbaVZlY3RvcjMgKyAyXSkgOlxyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIHRhbmdlbnRzID9cclxuICAgICAgICAgICAgICAgIG5ldyBWZWN0b3I0KHRhbmdlbnRzW2lWZWN0b3I0ICsgMF0sIHRhbmdlbnRzW2lWZWN0b3I0ICsgMV0sIHRhbmdlbnRzW2lWZWN0b3I0ICsgMl0sIHRhbmdlbnRzW2lWZWN0b3I0ICsgM10pIDpcclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICBjb2xvcnMgP1xyXG4gICAgICAgICAgICAgICAgbmV3IENvbG9yKGNvbG9yc1tpVmVjdG9yNCArIDBdLCBjb2xvcnNbaVZlY3RvcjQgKyAxXSwgY29sb3JzW2lWZWN0b3I0ICsgMl0sIGNvbG9yc1tpVmVjdG9yNCArIDNdKSA6XHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgYm9uZXMgJiYgd2VpZ2h0cyA/XHJcbiAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgIHsgaW5kZXg6IGJvbmVzW2lWZWN0b3I0ICsgMF0sIHdlaWdodDogd2VpZ2h0c1tpVmVjdG9yNCArIDBdIH0sXHJcbiAgICAgICAgICAgICAgICAgIHsgaW5kZXg6IGJvbmVzW2lWZWN0b3I0ICsgMV0sIHdlaWdodDogd2VpZ2h0c1tpVmVjdG9yNCArIDFdIH0sXHJcbiAgICAgICAgICAgICAgICAgIHsgaW5kZXg6IGJvbmVzW2lWZWN0b3I0ICsgMl0sIHdlaWdodDogd2VpZ2h0c1tpVmVjdG9yNCArIDJdIH0sXHJcbiAgICAgICAgICAgICAgICAgIHsgaW5kZXg6IGJvbmVzW2lWZWN0b3I0ICsgM10sIHdlaWdodDogd2VpZ2h0c1tpVmVjdG9yNCArIDNdIH1cclxuICAgICAgICAgICAgICAgIF0gOlxyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpRmFjZVZlcnRleEluZGV4OiBudW1iZXIgPSAwOyBpRmFjZVZlcnRleEluZGV4IDwgaW5kaWNlcz8ubGVuZ3RoOyBpRmFjZVZlcnRleEluZGV4ICs9IDMpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIG1lc2guZmFjZXMucHVzaChuZXcgRmFjZShcclxuICAgICAgICAgICAgICBtZXNoLnZlcnRpY2VzLFxyXG4gICAgICAgICAgICAgIGluZGljZXNbaUZhY2VWZXJ0ZXhJbmRleCArIDBdLFxyXG4gICAgICAgICAgICAgIGluZGljZXNbaUZhY2VWZXJ0ZXhJbmRleCArIDFdLFxyXG4gICAgICAgICAgICAgIGluZGljZXNbaUZhY2VWZXJ0ZXhJbmRleCArIDJdXHJcbiAgICAgICAgICAgICkpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoX2U6IHVua25vd24pIHtcclxuICAgICAgICAgICAgRGVidWcuZnVkZ2UoXCJGYWNlIGV4Y2x1ZGVkXCIsICg8RXJyb3I+X2UpLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcmVuZGVyTWVzaDogUmVuZGVyTWVzaCA9IG1lc2gucmVuZGVyTWVzaDtcclxuICAgICAgcmVuZGVyTWVzaC5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XHJcbiAgICAgIHJlbmRlck1lc2guaW5kaWNlcyA9IGluZGljZXM7XHJcbiAgICAgIHJlbmRlck1lc2gubm9ybWFscyA9IG5vcm1hbHM7XHJcbiAgICAgIHJlbmRlck1lc2gudGFuZ2VudHMgPSB0YW5nZW50cztcclxuICAgICAgcmVuZGVyTWVzaC50ZXh0dXJlVVZzID0gdGV4dHVyZVVWcztcclxuICAgICAgcmVuZGVyTWVzaC5jb2xvcnMgPSBjb2xvcnM7XHJcbiAgICAgIHJlbmRlck1lc2guYm9uZXMgPSBib25lcztcclxuICAgICAgcmVuZGVyTWVzaC53ZWlnaHRzID0gd2VpZ2h0cztcclxuXHJcbiAgICAgIGlmICghX21lc2hPdXQpIHtcclxuICAgICAgICBQcm9qZWN0LmRlcmVnaXN0ZXIobWVzaCk7XHJcbiAgICAgICAgLy8gbWVzaC5pZFJlc291cmNlID0gaWQ7XHJcbiAgICAgICAgdGhpcy4jcmVzb3VyY2VzW2lkXSA9IG1lc2g7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtZXNoO1xyXG5cclxuICAgICAgZnVuY3Rpb24gY2hlY2tNYXhTdXBwb3J0KF9sb2FkZXI6IEdMVEZMb2FkZXIsIF9jaGVjazogc3RyaW5nLCBfbWF4OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZ2x0ZlByaW1pdGl2ZS5hdHRyaWJ1dGVzKS5maWx0ZXIoKF9rZXk6IHN0cmluZykgPT4gX2tleS5zdGFydHNXaXRoKF9jaGVjaykpLmxlbmd0aCA+IF9tYXgpXHJcbiAgICAgICAgICBEZWJ1Zy53YXJuKGAke19sb2FkZXJ9OiBNZXNoIHdpdGggaW5kZXggJHtfaU1lc2h9IHByaW1pdGl2ZSAke19pUHJpbWl0aXZlfSBoYXMgbW9yZSB0aGFuICR7X21heH0gc2V0cyBvZiAnJHtfY2hlY2t9JyBhc3NvY2lhdGVkIHdpdGggaXQuIEZVR0RFIG9ubHkgc3VwcG9ydHMgdXAgdG8gJHtfbWF4fSAke19jaGVja30gc2V0cyBwZXIgcHJpbWl0aXZlLmApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB7QGxpbmsgTWF0ZXJpYWxHTFRGfSB3aXRoIHRoZSBnaXZlbiBtYXRlcmlhbCBuYW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWF0ZXJpYWwoX25hbWU6IHN0cmluZyk6IFByb21pc2U8TWF0ZXJpYWw+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgTWF0ZXJpYWx9IGZvciB0aGUgZ2l2ZW4gbWF0ZXJpYWwgaW5kZXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRNYXRlcmlhbChfaU1hdGVyaWFsOiBudW1iZXIpOiBQcm9taXNlPE1hdGVyaWFsPjtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSBtYXRlcmlhbCBmcm9tIHRoZSBnbFRGIGZpbGUgaW50byB0aGUgZ2l2ZW4ge0BsaW5rIE1hdGVyaWFsfS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWF0ZXJpYWw8VCBleHRlbmRzIE1hdGVyaWFsPihfaU1hdGVyaWFsOiBudW1iZXIgfCBzdHJpbmcsIF9tYXRlcmlhbE91dD86IFQsIF9za2luPzogYm9vbGVhbik6IFByb21pc2U8VD47XHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0TWF0ZXJpYWwoX2lNYXRlcmlhbDogbnVtYmVyIHwgc3RyaW5nLCBfbWF0ZXJpYWxPdXQ/OiBNYXRlcmlhbCwgX3NraW46IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8TWF0ZXJpYWw+IHtcclxuICAgICAgX2lNYXRlcmlhbCA9IHRoaXMuZ2V0SW5kZXgoX2lNYXRlcmlhbCwgdGhpcy4jZ2x0Zi5tYXRlcmlhbHMpO1xyXG5cclxuICAgICAgaWYgKF9pTWF0ZXJpYWwgPT0gLTEpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICBjb25zdCBpZDogc3RyaW5nID0gYCR7TWF0ZXJpYWwubmFtZX18JHtfaU1hdGVyaWFsfWA7XHJcblxyXG4gICAgICBpZiAodGhpcy4jcmVzb3VyY2VzW2lkXSAmJiAhX21hdGVyaWFsT3V0KVxyXG4gICAgICAgIHJldHVybiA8TWF0ZXJpYWw+dGhpcy4jcmVzb3VyY2VzW2lkXTtcclxuXHJcbiAgICAgIC8vIFRPRE86IGluIHRoZSBmdXR1cmUgY3JlYXRlIGFuIGFwcHJvcHJpYXRlIHNoYWRlciBiYXNlZCBvbiB0aGUgZ2xURiBtYXRlcmlhbCBwcm9wZXJ0aWVzXHJcbiAgICAgIGNvbnN0IGdsdGZNYXRlcmlhbDogR0xURi5NYXRlcmlhbCA9IHRoaXMuI2dsdGYubWF0ZXJpYWxzW19pTWF0ZXJpYWxdO1xyXG5cclxuICAgICAgaWYgKCFnbHRmTWF0ZXJpYWwpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXN9OiBDb3VsZG4ndCBmaW5kIG1hdGVyaWFsIHdpdGggaW5kZXggJHtfaU1hdGVyaWFsfS5gKTtcclxuXHJcbiAgICAgIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBvdGhlciBnbFRGIG1hdGVyaWFsIHByb3BlcnRpZXM6IGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvZ2xURi9zcGVjcy8yLjAvZ2xURi0yLjAuaHRtbCNyZWZlcmVuY2UtbWF0ZXJpYWxcclxuICAgICAgLy8gZS5nLiBvY2NsdXNpb24gYW5kIGVtaXNzaXZlIHRleHR1cmVzOyBkb3VibGVTaWRlZFxyXG4gICAgICBjb25zdCBnbHRmQmFzZUNvbG9yRmFjdG9yOiBudW1iZXJbXSA9IGdsdGZNYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcz8uYmFzZUNvbG9yRmFjdG9yID8/IFsxLCAxLCAxLCAxXTtcclxuICAgICAgY29uc3QgZ2x0Zk1ldGFsbGljRmFjdG9yOiBudW1iZXIgPSBnbHRmTWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3M/Lm1ldGFsbGljRmFjdG9yID8/IDE7XHJcbiAgICAgIGNvbnN0IGdsdGZSb3VnaG5lc3NGYWN0b3I6IG51bWJlciA9IGdsdGZNYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcz8ucm91Z2huZXNzRmFjdG9yID8/IDE7XHJcbiAgICAgIGNvbnN0IGdsdGZFbWlzc2l2ZUZhY3RvcjogbnVtYmVyW10gPSBnbHRmTWF0ZXJpYWwuZW1pc3NpdmVGYWN0b3IgPz8gWzAsIDAsIDBdO1xyXG5cclxuICAgICAgY29uc3QgZ2x0ZkJhc2VDb2xvclRleHR1cmU6IEdMVEYuVGV4dHVyZUluZm8gPSBnbHRmTWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3M/LmJhc2VDb2xvclRleHR1cmU7XHJcbiAgICAgIGNvbnN0IGdsdGZOb3JtYWxUZXh0dXJlOiBHTFRGLk1hdGVyaWFsTm9ybWFsVGV4dHVyZUluZm8gPSBnbHRmTWF0ZXJpYWwubm9ybWFsVGV4dHVyZTtcclxuXHJcbiAgICAgIC8vIFRoZSBkaWZmdXNlIGNvbnRyaWJ1dGlvbiBpbiB0aGUgUGhvbmcgc2hhZGluZyBtb2RlbC4gUmVwcmVzZW50cyBob3cgbXVjaCBsaWdodCBpcyBzY2F0dGVyZWQgaW4gZGlmZmVyZW50IGRpcmVjdGlvbnMgZHVlIHRvIHRoZSBtYXRlcmlhbCdzIHN1cmZhY2UgcHJvcGVydGllcy5cclxuICAgICAgY29uc3QgZGlmZnVzZTogbnVtYmVyID0gMTtcclxuICAgICAgLy8gVGhlIHNoaW5pbmVzcyBvZiB0aGUgbWF0ZXJpYWwuIEluZmx1ZW5jZXMgdGhlIHNoYXJwbmVzcyBvciBicm9hZG5lc3Mgb2YgdGhlIHNwZWN1bGFyIGhpZ2hsaWdodC4gSGlnaGVyIHNwZWN1bGFyIHZhbHVlcyByZXN1bHQgaW4gYSBzaGFycGVyIGFuZCBtb3JlIGNvbmNlbnRyYXRlZCBzcGVjdWxhciBoaWdobGlnaHQuXHJcbiAgICAgIGNvbnN0IHNwZWN1bGFyOiBudW1iZXIgPSAxLjggKiAoMSAtIGdsdGZSb3VnaG5lc3NGYWN0b3IpICsgMC42ICogZ2x0Zk1ldGFsbGljRmFjdG9yO1xyXG4gICAgICAvLyBUaGUgc3RyZW5ndGgvaW50ZW5zaXR5IG9mIHRoZSBzcGVjdWxhciByZWZsZWN0aW9uXHJcbiAgICAgIGNvbnN0IGludGVuc2l0eTogbnVtYmVyID0gMC43ICogKDEgLSBnbHRmUm91Z2huZXNzRmFjdG9yKSArIGdsdGZNZXRhbGxpY0ZhY3RvcjtcclxuICAgICAgLy8gSW5mbHVlbmNlcyBob3cgbXVjaCB0aGUgbWF0ZXJpYWwncyBjb2xvciBhZmZlY3RzIHRoZSBzcGVjdWxhciByZWZsZWN0aW9uLiBXaGVuIG1ldGFsbGljIGlzIGhpZ2hlciwgdGhlIHNwZWN1bGFyIHJlZmxlY3Rpb24gdGFrZXMgb24gdGhlIGNvbG9yIG9mIHRoZSBtYXRlcmlhbCwgY3JlYXRpbmcgYSBtZXRhbGxpYyBhcHBlYXJhbmNlLiBSYW5nZSBmcm9tIDAuMCB0byAxLjAuXHJcbiAgICAgIGNvbnN0IG1ldGFsbGljOiBudW1iZXIgPSBnbHRmTWV0YWxsaWNGYWN0b3I7XHJcblxyXG4gICAgICBjb25zdCBpc0xpdDogYm9vbGVhbiA9IGdsdGZFbWlzc2l2ZUZhY3RvclswXSA+IDAgfHwgZ2x0ZkVtaXNzaXZlRmFjdG9yWzFdID4gMCB8fCBnbHRmRW1pc3NpdmVGYWN0b3JbMl0gPiAwO1xyXG4gICAgICBjb25zdCBjb2xvcjogQ29sb3IgPSBuZXcgQ29sb3IoLi4uZ2x0ZkJhc2VDb2xvckZhY3Rvcik7XHJcbiAgICAgIGlmIChpc0xpdClcclxuICAgICAgICBjb2xvci5hZGQobmV3IENvbG9yKC4uLmdsdGZFbWlzc2l2ZUZhY3RvciwgMCkpO1xyXG4gICAgICBjb25zdCBjb2F0OiBDb2F0ID0gZ2x0ZkJhc2VDb2xvclRleHR1cmUgP1xyXG4gICAgICAgIGlzTGl0ID8gbmV3IENvYXRUZXh0dXJlZChjb2xvciwgYXdhaXQgdGhpcy5nZXRUZXh0dXJlKGdsdGZCYXNlQ29sb3JUZXh0dXJlLmluZGV4KSkgOlxyXG4gICAgICAgICAgZ2x0Zk5vcm1hbFRleHR1cmUgP1xyXG4gICAgICAgICAgICBuZXcgQ29hdFJlbWlzc2l2ZVRleHR1cmVkTm9ybWFscyhjb2xvciwgYXdhaXQgdGhpcy5nZXRUZXh0dXJlKGdsdGZCYXNlQ29sb3JUZXh0dXJlLmluZGV4KSwgYXdhaXQgdGhpcy5nZXRUZXh0dXJlKGdsdGZOb3JtYWxUZXh0dXJlLmluZGV4KSwgZGlmZnVzZSwgc3BlY3VsYXIsIGludGVuc2l0eSwgbWV0YWxsaWMpIDpcclxuICAgICAgICAgICAgbmV3IENvYXRSZW1pc3NpdmVUZXh0dXJlZChjb2xvciwgYXdhaXQgdGhpcy5nZXRUZXh0dXJlKGdsdGZCYXNlQ29sb3JUZXh0dXJlLmluZGV4KSwgZGlmZnVzZSwgc3BlY3VsYXIsIGludGVuc2l0eSwgbWV0YWxsaWMpIDpcclxuICAgICAgICBpc0xpdCA/IG5ldyBDb2F0Q29sb3JlZChjb2xvcikgOiBuZXcgQ29hdFJlbWlzc2l2ZShjb2xvciwgZGlmZnVzZSwgc3BlY3VsYXIsIGludGVuc2l0eSwgbWV0YWxsaWMpO1xyXG5cclxuICAgICAgaWYgKGdsdGZNYXRlcmlhbC5hbHBoYUN1dG9mZiAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgY29hdC5hbHBoYUNsaXAgPSBnbHRmTWF0ZXJpYWwuYWxwaGFDdXRvZmY7XHJcblxyXG4gICAgICBsZXQgc2hhZGVyOiB0eXBlb2YgU2hhZGVyO1xyXG4gICAgICBpZiAoaXNMaXQpIHtcclxuICAgICAgICBzaGFkZXIgPSBnbHRmQmFzZUNvbG9yVGV4dHVyZSA/XHJcbiAgICAgICAgICAoX3NraW4gPyBTaGFkZXJMaXRUZXh0dXJlZFNraW4gOiBTaGFkZXJMaXRUZXh0dXJlZCkgOlxyXG4gICAgICAgICAgKF9za2luID8gU2hhZGVyTGl0U2tpbiA6IFNoYWRlckxpdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2hhZGVyID0gZ2x0ZkJhc2VDb2xvclRleHR1cmUgP1xyXG4gICAgICAgICAgZ2x0Zk5vcm1hbFRleHR1cmUgP1xyXG4gICAgICAgICAgICAoX3NraW4gPyBTaGFkZXJQaG9uZ1RleHR1cmVkTm9ybWFsc1NraW4gOiBTaGFkZXJQaG9uZ1RleHR1cmVkTm9ybWFscykgOlxyXG4gICAgICAgICAgICAoX3NraW4gPyBTaGFkZXJQaG9uZ1RleHR1cmVkU2tpbiA6IFNoYWRlclBob25nVGV4dHVyZWQpIDpcclxuICAgICAgICAgIChfc2tpbiA/IFNoYWRlclBob25nU2tpbiA6IFNoYWRlclBob25nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbWF0ZXJpYWw6IE1hdGVyaWFsID0gX21hdGVyaWFsT3V0ID8/IG5ldyBNYXRlcmlhbEdMVEYoZ2x0Zk1hdGVyaWFsLm5hbWUpO1xyXG4gICAgICBtYXRlcmlhbC5uYW1lID0gZ2x0Zk1hdGVyaWFsLm5hbWU7XHJcbiAgICAgIG1hdGVyaWFsLmNvYXQgPSBjb2F0O1xyXG5cclxuICAgICAgUmVmbGVjdC5zZXQobWF0ZXJpYWwsIFwic2hhZGVyVHlwZVwiLCBzaGFkZXIpO1xyXG4gICAgICAvLyBtYXRlcmlhbC5zZXRTaGFkZXIoc2hhZGVyKTtcclxuICAgICAgaWYgKG1hdGVyaWFsIGluc3RhbmNlb2YgTWF0ZXJpYWxHTFRGKVxyXG4gICAgICAgIG1hdGVyaWFsLnVybCA9IHRoaXMuI3VybDtcclxuXHJcbiAgICAgIGlmICghX21hdGVyaWFsT3V0KSB7XHJcbiAgICAgICAgUHJvamVjdC5kZXJlZ2lzdGVyKG1hdGVyaWFsKTtcclxuICAgICAgICB0aGlzLiNyZXNvdXJjZXNbaWRdID0gbWF0ZXJpYWw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtYXRlcmlhbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBUZXh0dXJlfSBmb3IgdGhlIGdpdmVuIHRleHR1cmUgaW5kZXguXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRUZXh0dXJlKF9pVGV4dHVyZTogbnVtYmVyKTogUHJvbWlzZTxUZXh0dXJlPiB7XHJcbiAgICAgIGNvbnN0IGlkOiBzdHJpbmcgPSBgJHtUZXh0dXJlLm5hbWV9fCR7X2lUZXh0dXJlfWA7XHJcblxyXG4gICAgICBpZiAodGhpcy4jcmVzb3VyY2VzW2lkXSlcclxuICAgICAgICByZXR1cm4gPFRleHR1cmU+dGhpcy4jcmVzb3VyY2VzW2lkXTtcclxuXHJcbiAgICAgIGNvbnN0IGdsdGZUZXh0dXJlOiBHTFRGLlRleHR1cmUgPSB0aGlzLiNnbHRmLnRleHR1cmVzW19pVGV4dHVyZV07XHJcbiAgICAgIGNvbnN0IGdsdGZTYW1wbGVyOiBHTFRGLlNhbXBsZXIgPSB0aGlzLiNnbHRmLnNhbXBsZXJzPy5bZ2x0ZlRleHR1cmUuc2FtcGxlcl07XHJcbiAgICAgIGNvbnN0IGdsdGZJbWFnZTogR0xURi5JbWFnZSA9IHRoaXMuI2dsdGYuaW1hZ2VzPy5bZ2x0ZlRleHR1cmUuc291cmNlXTtcclxuXHJcbiAgICAgIGlmIChnbHRmSW1hZ2UgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgRGVidWcud2FybihgJHt0aGlzfTogVGV4dHVyZSB3aXRoIGluZGV4ICR7X2lUZXh0dXJlfSBoYXMgbm8gaW1hZ2UuYCk7XHJcbiAgICAgICAgcmV0dXJuIFRleHR1cmVEZWZhdWx0LmNvbG9yO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgdXJsOiBzdHJpbmcgPSBuZXcgVVJMKGdsdGZJbWFnZS51cmksIG5ldyBVUkwodGhpcy4jdXJsLCBQcm9qZWN0LmJhc2VVUkwpKS50b1N0cmluZygpO1xyXG5cclxuICAgICAgaWYgKCFnbHRmSW1hZ2UudXJpICYmIGdsdGZJbWFnZS5idWZmZXJWaWV3KSB7XHJcbiAgICAgICAgLy8gVE9ETzogdGhpcyBpcyBkdXBsaWNhdGUgY29kZSBmcm9tIGdldEJ1ZmZlckRhdGEsIG1heWJlIHJlZmFjdG9yIGdldEJ1ZmZlckRhdGEgdG8gaGFuZGxlIGJ1ZmZlclZpZXdJbmRleCBpbnB1dFxyXG4gICAgICAgIGNvbnN0IGdsdGZCdWZmZXJWaWV3OiBHTFRGLkJ1ZmZlclZpZXcgPSB0aGlzLiNnbHRmLmJ1ZmZlclZpZXdzW2dsdGZJbWFnZS5idWZmZXJWaWV3XTtcclxuXHJcbiAgICAgICAgY29uc3QgYnVmZmVyOiBBcnJheUJ1ZmZlciA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyKGdsdGZCdWZmZXJWaWV3LmJ1ZmZlcik7XHJcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldDogbnVtYmVyID0gZ2x0ZkJ1ZmZlclZpZXcuYnl0ZU9mZnNldCB8fCAwO1xyXG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGg6IG51bWJlciA9IGdsdGZCdWZmZXJWaWV3LmJ5dGVMZW5ndGggfHwgMDtcclxuXHJcbiAgICAgICAgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihcclxuICAgICAgICAgIFtuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggLyBVaW50OEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKV0sXHJcbiAgICAgICAgICB7IHR5cGU6IGdsdGZJbWFnZS5taW1lVHlwZSB9XHJcbiAgICAgICAgKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHRleHR1cmU6IFRleHR1cmVJbWFnZSA9IG5ldyBUZXh0dXJlSW1hZ2UoKTtcclxuICAgICAgYXdhaXQgdGV4dHVyZS5sb2FkKHVybCk7XHJcblxyXG4gICAgICBpZiAoZ2x0ZlNhbXBsZXIpIHtcclxuICAgICAgICBnbHRmU2FtcGxlci5tYWdGaWx0ZXIgPSBnbHRmU2FtcGxlci5tYWdGaWx0ZXIgPz8gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUOyAvLyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgZ2x0ZlNhbXBsZXIubWluRmlsdGVyID0gZ2x0ZlNhbXBsZXIubWluRmlsdGVyID8/IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVDsgLy8gZGVmYXVsdCB2YWx1ZVxyXG5cclxuICAgICAgICBpZiAoZ2x0ZlNhbXBsZXIubWFnRmlsdGVyID09IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCAmJiBnbHRmU2FtcGxlci5taW5GaWx0ZXIgPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUKVxyXG4gICAgICAgICAgdGV4dHVyZS5taXBtYXAgPSBNSVBNQVAuQ1JJU1A7XHJcbiAgICAgICAgZWxzZSBpZiAoZ2x0ZlNhbXBsZXIubWFnRmlsdGVyID09IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCAmJiBnbHRmU2FtcGxlci5taW5GaWx0ZXIgPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUX01JUE1BUF9MSU5FQVIpXHJcbiAgICAgICAgICB0ZXh0dXJlLm1pcG1hcCA9IE1JUE1BUC5NRURJVU07XHJcbiAgICAgICAgZWxzZSBpZiAoZ2x0ZlNhbXBsZXIubWFnRmlsdGVyID09IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTElORUFSICYmIGdsdGZTYW1wbGVyLm1pbkZpbHRlciA9PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkxJTkVBUl9NSVBNQVBfTElORUFSKVxyXG4gICAgICAgICAgdGV4dHVyZS5taXBtYXAgPSBNSVBNQVAuQkxVUlJZO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIERlYnVnLndhcm4oYCR7dGhpc306IFRleHR1cmUgd2l0aCBpbmRleCAke19pVGV4dHVyZX0gaGFzIGEgbWFnRmlsdGVyIGFuZCBtaW5GaWx0ZXIgb2YgJyR7Z2V0V2ViR0xQYXJhbWV0ZXJOYW1lKGdsdGZTYW1wbGVyLm1hZ0ZpbHRlcil9JyBhbmQgJyR7Z2V0V2ViR0xQYXJhbWV0ZXJOYW1lKGdsdGZTYW1wbGVyLm1pbkZpbHRlcil9JyByZXNwZWN0aXZlbHkuIEZVREdFIG9ubHkgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBjb21iaW5hdGlvbnM6IE5FQVJFU1QgYW5kIE5FQVJFU1QgfCBORUFSRVNUIGFuZCBORUFSRVNUX01JUE1BUF9MSU5FQVIgfCBMSU5FQVIgYW5kIExJTkVBUl9NSVBNQVBfTElORUFSLmApO1xyXG5cclxuICAgICAgICBnbHRmU2FtcGxlci53cmFwUyA9IGdsdGZTYW1wbGVyLndyYXBTID8/IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuUkVQRUFUOyAvLyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgZ2x0ZlNhbXBsZXIud3JhcFQgPSBnbHRmU2FtcGxlci53cmFwVCA/PyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlJFUEVBVDsgLy8gZGVmYXVsdCB2YWx1ZVxyXG5cclxuICAgICAgICBpZiAoZ2x0ZlNhbXBsZXIud3JhcFMgPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SRVBFQVQgJiYgZ2x0ZlNhbXBsZXIud3JhcFQgPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5SRVBFQVQpXHJcbiAgICAgICAgICB0ZXh0dXJlLndyYXAgPSBXUkFQLlJFUEVBVDtcclxuICAgICAgICBlbHNlIGlmIChnbHRmU2FtcGxlci53cmFwUyA9PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LkNMQU1QX1RPX0VER0UgJiYgZ2x0ZlNhbXBsZXIud3JhcFQgPT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFKVxyXG4gICAgICAgICAgdGV4dHVyZS53cmFwID0gV1JBUC5DTEFNUDtcclxuICAgICAgICBlbHNlIGlmIChnbHRmU2FtcGxlci53cmFwUyA9PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1JUlJPUkVEX1JFUEVBVCAmJiBnbHRmU2FtcGxlci53cmFwVCA9PSBXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1JUlJPUkVEX1JFUEVBVClcclxuICAgICAgICAgIHRleHR1cmUud3JhcCA9IFdSQVAuTUlSUk9SO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIERlYnVnLndhcm4oYCR7dGhpc306IFRleHR1cmUgd2l0aCBpbmRleCAke19pVGV4dHVyZX0gaGFzIGEgd3JhcFMgYW5kIHdyYXBUIG9mICcke2dldFdlYkdMUGFyYW1ldGVyTmFtZShnbHRmU2FtcGxlci53cmFwUyl9JyBhbmQgJyR7Z2V0V2ViR0xQYXJhbWV0ZXJOYW1lKGdsdGZTYW1wbGVyLndyYXBUKX0nIHJlc3BlY3RpdmVseS4gRlVER0Ugb25seSBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIGNvbWJpbmF0aW9uczogUkVQRUFUIGFuZCBSRVBFQVQgfCBDTEFNUF9UT19FREdFIGFuZCBDTEFNUF9UT19FREdFIHwgTUlSUk9SRURfUkVQRUFUIGFuZCBNSVJST1JFRF9SRVBFQVQuYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFByb2plY3QuZGVyZWdpc3Rlcih0ZXh0dXJlKTtcclxuICAgICAgdGhpcy4jcmVzb3VyY2VzW2lkXSA9IHRleHR1cmU7XHJcblxyXG4gICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIGAke0dMVEZMb2FkZXIubmFtZX0gfCAke3RoaXMuI3VybH1gO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIE5vZGV9IGZvciB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0Tm9kZUJ5SW5kZXgoX2lOb2RlOiBudW1iZXIsIF9jYWNoZTogR0xURkxvYWRpbmdDYWNoZSk6IFByb21pc2U8Tm9kZT4ge1xyXG4gICAgICBpZiAoIV9jYWNoZS5ub2Rlc1tfaU5vZGVdKSB7XHJcbiAgICAgICAgY29uc3QgZ2x0Zk5vZGU6IEdMVEYuTm9kZSA9IHRoaXMuI2dsdGYubm9kZXNbX2lOb2RlXTtcclxuICAgICAgICBjb25zdCBub2RlOiBOb2RlID0gbmV3IE5vZGUoZ2x0Zk5vZGUubmFtZSk7XHJcblxyXG4gICAgICAgIF9jYWNoZS5ub2Rlc1tfaU5vZGVdID0gbm9kZTtcclxuXHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKGdsdGZOb2RlLmNoaWxkcmVuKVxyXG4gICAgICAgICAgZm9yIChjb25zdCBpTm9kZSBvZiBnbHRmTm9kZS5jaGlsZHJlbilcclxuICAgICAgICAgICAgbm9kZS5hZGRDaGlsZChhd2FpdCB0aGlzLmdldE5vZGVCeUluZGV4KGlOb2RlLCBfY2FjaGUpKTtcclxuXHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIHRyYW5zZm9ybWF0aW9uXHJcbiAgICAgICAgaWYgKGdsdGZOb2RlLm1hdHJpeCB8fCBnbHRmTm9kZS5yb3RhdGlvbiB8fCBnbHRmTm9kZS5zY2FsZSB8fCBnbHRmTm9kZS50cmFuc2xhdGlvbiB8fCBnbHRmTm9kZS5pc0FuaW1hdGVkKSB7XHJcbiAgICAgICAgICBub2RlLmFkZENvbXBvbmVudChuZXcgQ29tcG9uZW50VHJhbnNmb3JtKCkpO1xyXG4gICAgICAgICAgaWYgKGdsdGZOb2RlLm1hdHJpeCkge1xyXG4gICAgICAgICAgICBub2RlLm10eExvY2FsLnNldEFycmF5KGdsdGZOb2RlLm1hdHJpeCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZ2x0Zk5vZGUudHJhbnNsYXRpb24pIHtcclxuICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGlvbjogVmVjdG9yMyA9IFJlY3ljbGVyLmdldChWZWN0b3IzKTtcclxuICAgICAgICAgICAgICB0cmFuc2xhdGlvbi5zZXQoZ2x0Zk5vZGUudHJhbnNsYXRpb25bMF0sIGdsdGZOb2RlLnRyYW5zbGF0aW9uWzFdLCBnbHRmTm9kZS50cmFuc2xhdGlvblsyXSk7XHJcbiAgICAgICAgICAgICAgbm9kZS5tdHhMb2NhbC50cmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKHRyYW5zbGF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ2x0Zk5vZGUucm90YXRpb24pIHtcclxuICAgICAgICAgICAgICBjb25zdCByb3RhdGlvbjogUXVhdGVybmlvbiA9IFJlY3ljbGVyLmdldChRdWF0ZXJuaW9uKTtcclxuICAgICAgICAgICAgICByb3RhdGlvbi5zZXQoZ2x0Zk5vZGUucm90YXRpb25bMF0sIGdsdGZOb2RlLnJvdGF0aW9uWzFdLCBnbHRmTm9kZS5yb3RhdGlvblsyXSwgZ2x0Zk5vZGUucm90YXRpb25bM10pO1xyXG4gICAgICAgICAgICAgIG5vZGUubXR4TG9jYWwucm90YXRpb24gPSByb3RhdGlvbjtcclxuICAgICAgICAgICAgICBSZWN5Y2xlci5zdG9yZShyb3RhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdsdGZOb2RlLnNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgc2NhbGU6IFZlY3RvcjMgPSBSZWN5Y2xlci5nZXQoVmVjdG9yMyk7XHJcbiAgICAgICAgICAgICAgc2NhbGUuc2V0KGdsdGZOb2RlLnNjYWxlWzBdLCBnbHRmTm9kZS5zY2FsZVsxXSwgZ2x0Zk5vZGUuc2NhbGVbMl0pO1xyXG4gICAgICAgICAgICAgIG5vZGUubXR4TG9jYWwuc2NhbGluZyA9IHNjYWxlO1xyXG4gICAgICAgICAgICAgIFJlY3ljbGVyLnN0b3JlKHNjYWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIGNhbWVyYVxyXG4gICAgICAgIGlmIChnbHRmTm9kZS5jYW1lcmEgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBub2RlLmFkZENvbXBvbmVudChhd2FpdCB0aGlzLmdldENhbWVyYUJ5SW5kZXgoZ2x0Zk5vZGUuY2FtZXJhKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjaGVjayBmb3IgbWVzaCBhbmQgbWF0ZXJpYWxcclxuICAgICAgICBpZiAoZ2x0Zk5vZGUubWVzaCAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGdsdGZNZXNoOiBHTFRGLk1lc2ggPSB0aGlzLiNnbHRmLm1lc2hlcz8uW2dsdGZOb2RlLm1lc2hdO1xyXG4gICAgICAgICAgLy8gVE9ETzogcmV2aWV3IHRoaXNcclxuICAgICAgICAgIGNvbnN0IHN1YkNvbXBvbmVudHM6IFtDb21wb25lbnRNZXNoLCBDb21wb25lbnRNYXRlcmlhbF1bXSA9IFtdO1xyXG4gICAgICAgICAgZm9yIChsZXQgaVByaW1pdGl2ZTogbnVtYmVyID0gMDsgaVByaW1pdGl2ZSA8IGdsdGZNZXNoLnByaW1pdGl2ZXMubGVuZ3RoOyBpUHJpbWl0aXZlKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY21wTWVzaDogQ29tcG9uZW50TWVzaCA9IG5ldyBDb21wb25lbnRNZXNoKGF3YWl0IHRoaXMuZ2V0TWVzaChnbHRmTm9kZS5tZXNoLCBpUHJpbWl0aXZlKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzU2tpbjogYm9vbGVhbiA9IGdsdGZOb2RlLnNraW4gIT0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzU2tpbilcclxuICAgICAgICAgICAgICBjbXBNZXNoLnNrZWxldG9uID0gYXdhaXQgdGhpcy5nZXRTa2VsZXRvbkJ5SW5kZXgoZ2x0Zk5vZGUuc2tpbiwgX2NhY2hlKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBjbXBNYXRlcmlhbDogQ29tcG9uZW50TWF0ZXJpYWw7XHJcbiAgICAgICAgICAgIGNvbnN0IGlNYXRlcmlhbDogbnVtYmVyID0gZ2x0Zk1lc2gucHJpbWl0aXZlcz8uW2lQcmltaXRpdmVdPy5tYXRlcmlhbDtcclxuICAgICAgICAgICAgaWYgKGlNYXRlcmlhbCA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICBjbXBNYXRlcmlhbCA9IG5ldyBDb21wb25lbnRNYXRlcmlhbChpc1NraW4gP1xyXG4gICAgICAgICAgICAgICAgR0xURkxvYWRlci5kZWZhdWx0U2tpbk1hdGVyaWFsIDpcclxuICAgICAgICAgICAgICAgIEdMVEZMb2FkZXIuZGVmYXVsdE1hdGVyaWFsKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjbXBNYXRlcmlhbCA9IG5ldyBDb21wb25lbnRNYXRlcmlhbChhd2FpdCB0aGlzLmdldE1hdGVyaWFsKGlNYXRlcmlhbCwgbnVsbCwgaXNTa2luKSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIHRoaXMgc2hvdWxkIGJlIGEgZnVkZ2UgbWF0ZXJpYWwgcHJvcGVydHlcclxuICAgICAgICAgICAgICBjb25zdCBnbHRmTWF0ZXJpYWw6IEdMVEYuTWF0ZXJpYWwgPSB0aGlzLiNnbHRmLm1hdGVyaWFsc1tpTWF0ZXJpYWxdO1xyXG4gICAgICAgICAgICAgIGlmIChnbHRmTWF0ZXJpYWwpXHJcbiAgICAgICAgICAgICAgICBjbXBNYXRlcmlhbC5zb3J0Rm9yQWxwaGEgPSBnbHRmTWF0ZXJpYWwuYWxwaGFNb2RlID09IFwiQkxFTkRcIjtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN1YkNvbXBvbmVudHMucHVzaChbY21wTWVzaCwgY21wTWF0ZXJpYWxdKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoc3ViQ29tcG9uZW50cy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICBub2RlLmFkZENvbXBvbmVudChzdWJDb21wb25lbnRzWzBdWzBdKTtcclxuICAgICAgICAgICAgbm9kZS5hZGRDb21wb25lbnQoc3ViQ29tcG9uZW50c1swXVsxXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdWJDb21wb25lbnRzLmZvckVhY2goKFtfY21wTWVzaCwgX2NtcE1hdGVyaWFsXSwgX2kpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBub2RlUGFydDogTm9kZSA9IG5ldyBOb2RlKGAke25vZGUubmFtZX1fUHJpbWl0aXZlJHtfaX1gKTtcclxuICAgICAgICAgICAgICBub2RlUGFydC5hZGRDb21wb25lbnQoX2NtcE1lc2gpO1xyXG4gICAgICAgICAgICAgIG5vZGVQYXJ0LmFkZENvbXBvbmVudChfY21wTWF0ZXJpYWwpO1xyXG4gICAgICAgICAgICAgIG5vZGUuYWRkQ2hpbGQobm9kZVBhcnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBfY2FjaGUubm9kZXNbX2lOb2RlXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJucyB0aGUge0BsaW5rIENvbXBvbmVudFNrZWxldG9ufSBmb3IgdGhlIGdpdmVuIHNrZWxldG9uIGluZGV4LlxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0U2tlbGV0b25CeUluZGV4KF9pU2tlbGV0b246IG51bWJlciwgX2NhY2hlOiBHTFRGTG9hZGluZ0NhY2hlKTogUHJvbWlzZTxDb21wb25lbnRTa2VsZXRvbj4ge1xyXG4gICAgICBpZiAoIV9jYWNoZS5za2VsZXRvbnNbX2lTa2VsZXRvbl0pIHtcclxuICAgICAgICBjb25zdCBnbHRmU2tpbjogR0xURi5Ta2luID0gdGhpcy4jZ2x0Zi5za2luc1tfaVNrZWxldG9uXTtcclxuICAgICAgICBjb25zdCBib25lczogTm9kZVtdID0gW107XHJcblxyXG4gICAgICAgIC8vIGNvbnZlcnQgZmxvYXQgYXJyYXkgdG8gYXJyYXkgb2YgbWF0cmljZXMgYW5kIHJlZ2lzdGVyIGJvbmVzXHJcbiAgICAgICAgbGV0IG10eERhdGE6IEZsb2F0MzJBcnJheTtcclxuICAgICAgICBpZiAoZ2x0ZlNraW4uaW52ZXJzZUJpbmRNYXRyaWNlcyAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICBtdHhEYXRhID0gYXdhaXQgdGhpcy5nZXRGbG9hdDMyQXJyYXkoZ2x0ZlNraW4uaW52ZXJzZUJpbmRNYXRyaWNlcyk7XHJcbiAgICAgICAgY29uc3QgbXR4RGF0YVNwYW46IG51bWJlciA9IDE2OyAvLyBzaXplIG9mIG1hdHJpeFxyXG5cclxuICAgICAgICBjb25zdCBtdHhCaW5kSW52ZXJzZXM6IE1hdHJpeDR4NFtdID0gW107XHJcbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGpvaW50cyBhbmQgZ2V0IGNvcnJlc3BvbmRpbmcgbWF0cml4IGZyb20gZmxvYXQgYXJyYXlcclxuICAgICAgICBmb3IgKGxldCBpQm9uZTogbnVtYmVyID0gMDsgaUJvbmUgPCBnbHRmU2tpbi5qb2ludHMubGVuZ3RoOyBpQm9uZSsrKSB7XHJcbiAgICAgICAgICBsZXQgbXR4QmluZEludmVyc2U6IE1hdHJpeDR4NDtcclxuICAgICAgICAgIGlmIChtdHhEYXRhKVxyXG4gICAgICAgICAgICBtdHhCaW5kSW52ZXJzZSA9IG5ldyBNYXRyaXg0eDQobXR4RGF0YS5zbGljZShpQm9uZSAqIG10eERhdGFTcGFuLCAoaUJvbmUgKyAxKSAqIG10eERhdGFTcGFuKSk7XHJcblxyXG4gICAgICAgICAgYm9uZXMucHVzaChhd2FpdCB0aGlzLmdldE5vZGVCeUluZGV4KGdsdGZTa2luLmpvaW50c1tpQm9uZV0sIF9jYWNoZSkpO1xyXG4gICAgICAgICAgbXR4QmluZEludmVyc2VzLnB1c2gobXR4QmluZEludmVyc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2NhY2hlLnNrZWxldG9uc1tfaVNrZWxldG9uXSA9IG5ldyBDb21wb25lbnRTa2VsZXRvbihib25lcywgbXR4QmluZEludmVyc2VzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIF9jYWNoZS5za2VsZXRvbnNbX2lTa2VsZXRvbl07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgQ29tcG9uZW50Q2FtZXJhfSBmb3IgdGhlIGdpdmVuIGNhbWVyYSBpbmRleC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRDYW1lcmFCeUluZGV4KF9pQ2FtZXJhOiBudW1iZXIpOiBQcm9taXNlPENvbXBvbmVudENhbWVyYT4ge1xyXG4gICAgICBjb25zdCBnbHRmQ2FtZXJhOiBHTFRGLkNhbWVyYSA9IHRoaXMuI2dsdGYuY2FtZXJhc1tfaUNhbWVyYV07XHJcbiAgICAgIGNvbnN0IGNhbWVyYTogQ29tcG9uZW50Q2FtZXJhID0gbmV3IENvbXBvbmVudENhbWVyYSgpO1xyXG5cclxuICAgICAgaWYgKGdsdGZDYW1lcmEucGVyc3BlY3RpdmUpXHJcbiAgICAgICAgY2FtZXJhLnByb2plY3RDZW50cmFsKFxyXG4gICAgICAgICAgZ2x0ZkNhbWVyYS5wZXJzcGVjdGl2ZS5hc3BlY3RSYXRpbyxcclxuICAgICAgICAgIGdsdGZDYW1lcmEucGVyc3BlY3RpdmUueWZvdiAqIENhbGMucmFkMmRlZyxcclxuICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICBnbHRmQ2FtZXJhLnBlcnNwZWN0aXZlLnpuZWFyLFxyXG4gICAgICAgICAgZ2x0ZkNhbWVyYS5wZXJzcGVjdGl2ZS56ZmFyXHJcbiAgICAgICAgKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGNhbWVyYS5wcm9qZWN0T3J0aG9ncmFwaGljKFxyXG4gICAgICAgICAgLWdsdGZDYW1lcmEub3J0aG9ncmFwaGljLnhtYWcsXHJcbiAgICAgICAgICBnbHRmQ2FtZXJhLm9ydGhvZ3JhcGhpYy54bWFnLFxyXG4gICAgICAgICAgLWdsdGZDYW1lcmEub3J0aG9ncmFwaGljLnltYWcsXHJcbiAgICAgICAgICBnbHRmQ2FtZXJhLm9ydGhvZ3JhcGhpYy55bWFnXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiBjYW1lcmE7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRJbmRleChfbmFtZU9ySW5kZXg6IHN0cmluZyB8IG51bWJlciwgX2FycmF5OiB7IG5hbWU/OiBzdHJpbmcgfVtdKTogbnVtYmVyIHtcclxuICAgICAgbGV0IGluZGV4OiBudW1iZXIgPVxyXG4gICAgICAgIHR5cGVvZiBfbmFtZU9ySW5kZXggPT0gXCJudW1iZXJcIiA/XHJcbiAgICAgICAgICBfbmFtZU9ySW5kZXggOlxyXG4gICAgICAgICAgX2FycmF5LmZpbmRJbmRleChfb2JqZWN0ID0+IF9vYmplY3QubmFtZSA9PSBfbmFtZU9ySW5kZXgpO1xyXG4gICAgICBpZiAoaW5kZXggPT0gLTEpIHtcclxuICAgICAgICBsZXQgYXJyYXlOYW1lOiBzdHJpbmcgPSBPYmplY3QuZW50cmllcyh0aGlzLiNnbHRmKS5maW5kKChbX2tleSwgX3ZhbHVlXSkgPT4gX3ZhbHVlID09IF9hcnJheSk/LlswXTtcclxuICAgICAgICBEZWJ1Zy5lcnJvcihgJHt0aGlzfTogQ291bGRuJ3QgZmluZCBuYW1lICcke19uYW1lT3JJbmRleH0nIGluIGdsVEYgJHthcnJheU5hbWV9LmApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpbmRleDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgVWludDhBcnJheX0gZm9yIHRoZSBnaXZlbiBhY2Nlc3NvciBpbmRleC5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIGdldEJvbmVJbmRpY2VzKF9pQWNjZXNzb3I6IG51bWJlcik6IFByb21pc2U8VWludDhBcnJheT4ge1xyXG4gICAgICBjb25zdCBhcnJheTogVHlwZWRBcnJheSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyRGF0YShfaUFjY2Vzc29yKTtcclxuICAgICAgY29uc3QgY29tcG9uZW50VHlwZTogR0xURi5DT01QT05FTlRfVFlQRSA9IHRoaXMuI2dsdGYuYWNjZXNzb3JzW19pQWNjZXNzb3JdPy5jb21wb25lbnRUeXBlO1xyXG5cclxuICAgICAgaWYgKGNvbXBvbmVudFR5cGUgPT0gR0xURi5DT01QT05FTlRfVFlQRS5VTlNJR05FRF9CWVRFKVxyXG4gICAgICAgIHJldHVybiBhcnJheSBhcyBVaW50OEFycmF5O1xyXG5cclxuICAgICAgaWYgKGNvbXBvbmVudFR5cGUgPT0gR0xURi5DT01QT05FTlRfVFlQRS5VTlNJR05FRF9TSE9SVCkge1xyXG4gICAgICAgIERlYnVnLmxvZyhgJHt0aGlzfTogQm9uZSBpbmRpY2VzIGFyZSBzdG9yZWQgYXMgJyR7R0xURi5DT01QT05FTlRfVFlQRVtHTFRGLkNPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX1NIT1JUXX0nLiBGVURHRSB3aWxsIGNvbnZlcnQgdGhlbSB0byAnJHtHTFRGLkNPTVBPTkVOVF9UWVBFW0dMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfQllURV19Jy4gRlVER0Ugb25seSBzdXBwb3J0cyBza2VsZXRvbnMgd2l0aCB1cCB0byAyNTYgYm9uZXMsIHNvIG1ha2Ugc3VyZSB5b3VyIHNrZWxldG9uIGhhcyBubyBtb3JlIHRoYW4gMjU2IGJvbmVzLmApO1xyXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYXJyYXkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc306IEludmFsaWQgY29tcG9uZW50IHR5cGUgJyR7R0xURi5DT01QT05FTlRfVFlQRVtjb21wb25lbnRUeXBlXX0nIGZvciBib25lIGluZGljZXMuIEV4cGVjdGVkICcke0dMVEYuQ09NUE9ORU5UX1RZUEVbR0xURi5DT01QT05FTlRfVFlQRS5VTlNJR05FRF9CWVRFXX0nIG9yICcke0dMVEYuQ09NUE9ORU5UX1RZUEVbR0xURi5DT01QT05FTlRfVFlQRS5VTlNJR05FRF9TSE9SVF19Jy5gKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgRmxvYXQzMkFycmF5fSBmb3IgdGhlIGdpdmVuIGFjY2Vzc29yIGluZGV4LlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0RmxvYXQzMkFycmF5KF9pQWNjZXNzb3I6IG51bWJlcik6IFByb21pc2U8RmxvYXQzMkFycmF5PiB7XHJcbiAgICAgIGNvbnN0IGFycmF5OiBUeXBlZEFycmF5ID0gYXdhaXQgdGhpcy5nZXRCdWZmZXJEYXRhKF9pQWNjZXNzb3IpO1xyXG4gICAgICBjb25zdCBnbHRmQWNjZXNzb3I6IEdMVEYuQWNjZXNzb3IgPSB0aGlzLiNnbHRmLmFjY2Vzc29yc1tfaUFjY2Vzc29yXTtcclxuXHJcbiAgICAgIGlmIChnbHRmQWNjZXNzb3IuY29tcG9uZW50VHlwZSA9PSBHTFRGLkNPTVBPTkVOVF9UWVBFLkZMT0FUKVxyXG4gICAgICAgIHJldHVybiBhcnJheSBhcyBGbG9hdDMyQXJyYXk7XHJcblxyXG4gICAgICBpZiAoZ2x0ZkFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcclxuICAgICAgICBzd2l0Y2ggKGdsdGZBY2Nlc3Nvci5jb21wb25lbnRUeXBlKSB7XHJcbiAgICAgICAgICBjYXNlIEdMVEYuQ09NUE9ORU5UX1RZUEUuQllURTpcclxuICAgICAgICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKGFycmF5LCBfdmFsdWUgPT4gTWF0aC5tYXgoX3ZhbHVlIC8gMTI3LCAtMSkpO1xyXG4gICAgICAgICAgY2FzZSBHTFRGLkNPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX0JZVEU6XHJcbiAgICAgICAgICAgIHJldHVybiBGbG9hdDMyQXJyYXkuZnJvbShhcnJheSwgX3ZhbHVlID0+IF92YWx1ZSAvIDI1NSk7XHJcbiAgICAgICAgICBjYXNlIEdMVEYuQ09NUE9ORU5UX1RZUEUuU0hPUlQ6XHJcbiAgICAgICAgICAgIHJldHVybiBGbG9hdDMyQXJyYXkuZnJvbShhcnJheSwgX3ZhbHVlID0+IE1hdGgubWF4KF92YWx1ZSAvIDMyNzY3LCAtMSkpO1xyXG4gICAgICAgICAgY2FzZSBHTFRGLkNPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX1NIT1JUOlxyXG4gICAgICAgICAgICByZXR1cm4gRmxvYXQzMkFycmF5LmZyb20oYXJyYXksIF92YWx1ZSA9PiBfdmFsdWUgLyA2NTUzNSk7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc306IEludmFsaWQgY29tcG9uZW50IHR5cGUgJyR7R0xURi5DT01QT05FTlRfVFlQRVtnbHRmQWNjZXNzb3IuY29tcG9uZW50VHlwZV19JyBmb3Igbm9ybWFsaXplZCBhY2Nlc3Nvci5gKTtcclxuICAgICAgICAgIC8vIGh0dHBzOi8vcmVnaXN0cnkua2hyb25vcy5vcmcvZ2xURi9zcGVjcy8yLjAvZ2xURi0yLjAuaHRtbCNfYWNjZXNzb3Jfbm9ybWFsaXplZFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgRGVidWcud2FybihgJHt0aGlzfTogRXhwZWN0ZWQgY29tcG9uZW50IHR5cGUgJyR7R0xURi5DT01QT05FTlRfVFlQRVtHTFRGLkNPTVBPTkVOVF9UWVBFLkZMT0FUXX0nIGJ1dCB3YXMgJyR7R0xURi5DT01QT05FTlRfVFlQRVtnbHRmQWNjZXNzb3I/LmNvbXBvbmVudFR5cGVdfScuYCk7XHJcbiAgICAgIHJldHVybiBGbG9hdDMyQXJyYXkuZnJvbShhcnJheSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIFVpbnQxNkFycmF5fSBmb3IgdGhlIGdpdmVuIGFjY2Vzc29yIGluZGV4LiBPbmx5IHVzZWQgdG8gZ2V0IHRoZSB2ZXJ0ZXggaW5kaWNlcy5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIGdldFZlcnRleEluZGljZXMoX2lBY2Nlc3NvcjogbnVtYmVyKTogUHJvbWlzZTxVaW50MTZBcnJheT4ge1xyXG4gICAgICBjb25zdCBhcnJheTogVHlwZWRBcnJheSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyRGF0YShfaUFjY2Vzc29yKTtcclxuICAgICAgY29uc3QgZ2x0ZkFjY2Vzc29yOiBHTFRGLkFjY2Vzc29yID0gdGhpcy4jZ2x0Zi5hY2Nlc3NvcnNbX2lBY2Nlc3Nvcl07XHJcblxyXG4gICAgICBpZiAoZ2x0ZkFjY2Vzc29yLmNvbXBvbmVudFR5cGUgPT0gR0xURi5DT01QT05FTlRfVFlQRS5VTlNJR05FRF9TSE9SVClcclxuICAgICAgICByZXR1cm4gYXJyYXkgYXMgVWludDE2QXJyYXk7XHJcblxyXG4gICAgICBpZiAoZ2x0ZkFjY2Vzc29yLmNvdW50ID4gNjU1MzUgJiYgZ2x0ZkFjY2Vzc29yLnR5cGUgPT0gXCJTQ0FMQVJcIilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc306IEZpbGUgaW5jbHVkZXMgYSBtZXNoIHdpdGggbW9yZSB0aGFuIDY1NTM1IHZlcnRpY2VzLiBGVURHRSBkb2VzIG5vdCBzdXBwb3J0IG1lc2hlcyB3aXRoIG1vcmUgdGhhbiA2NTUzNSB2ZXJ0aWNlcy5gKTtcclxuXHJcbiAgICAgIGlmIChnbHRmQWNjZXNzb3IuY29tcG9uZW50VHlwZSA9PSBHTFRGLkNPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX0JZVEUgfHwgZ2x0ZkFjY2Vzc29yLmNvbXBvbmVudFR5cGUgPT0gR0xURi5DT01QT05FTlRfVFlQRS5VTlNJR05FRF9JTlQpXHJcbiAgICAgICAgcmV0dXJuIFVpbnQxNkFycmF5LmZyb20oYXJyYXkpO1xyXG5cclxuICAgICAgRGVidWcud2FybihgJHt0aGlzfTogRXhwZWN0ZWQgYW4gdW5zaWduZWQgaW50ZWdlciBjb21wb25lbnQgdHlwZSBidXQgd2FzICcke0dMVEYuQ09NUE9ORU5UX1RZUEVbdGhpcy4jZ2x0Zi5hY2Nlc3NvcnNbX2lBY2Nlc3Nvcl0/LmNvbXBvbmVudFR5cGVdfScuYCk7XHJcbiAgICAgIHJldHVybiBVaW50MTZBcnJheS5mcm9tKGFycmF5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHtAbGluayBGbG9hdDMyQXJyYXl9IGZvciB0aGUgZ2l2ZW4gYWNjZXNzb3IgaW5kZXguIFRoZSBhcnJheSBjb250YWlucyB0aGUgdmVydGV4IGNvbG9ycyBpbiBSR0JBIGZvcm1hdC5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIGdldFZlcnRleENvbG9ycyhfaUFjY2Vzc29yOiBudW1iZXIpOiBQcm9taXNlPEZsb2F0MzJBcnJheT4ge1xyXG4gICAgICBjb25zdCBhcnJheTogRmxvYXQzMkFycmF5ID0gYXdhaXQgdGhpcy5nZXRGbG9hdDMyQXJyYXkoX2lBY2Nlc3Nvcik7XHJcbiAgICAgIGNvbnN0IGdsdGZBY2Nlc3NvcjogR0xURi5BY2Nlc3NvciA9IHRoaXMuI2dsdGYuYWNjZXNzb3JzW19pQWNjZXNzb3JdO1xyXG5cclxuICAgICAgaWYgKGdsdGZBY2Nlc3Nvci50eXBlID09IEdMVEYuQUNDRVNTT1JfVFlQRS5WRUMzKSB7XHJcbiAgICAgICAgY29uc3QgcmdiYUFycmF5OiBGbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5Lmxlbmd0aCAqIDQgLyAzKTtcclxuICAgICAgICBmb3IgKGxldCBpVmVjMzogbnVtYmVyID0gMCwgaVZlYzQ6IG51bWJlciA9IDA7IGlWZWMzIDwgYXJyYXkubGVuZ3RoOyBpVmVjMyArPSAzLCBpVmVjNCArPSA0KSB7XHJcbiAgICAgICAgICByZ2JhQXJyYXlbaVZlYzRdID0gYXJyYXlbaVZlYzNdO1xyXG4gICAgICAgICAgcmdiYUFycmF5W2lWZWM0ICsgMV0gPSBhcnJheVtpVmVjMyArIDFdO1xyXG4gICAgICAgICAgcmdiYUFycmF5W2lWZWM0ICsgMl0gPSBhcnJheVtpVmVjMyArIDJdO1xyXG4gICAgICAgICAgcmdiYUFycmF5W2lWZWM0ICsgM10gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmdiYUFycmF5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRCdWZmZXJEYXRhKF9pQWNjZXNzb3I6IG51bWJlcik6IFByb21pc2U8VHlwZWRBcnJheT4ge1xyXG4gICAgICBjb25zdCBnbHRmQWNjZXNzb3I6IEdMVEYuQWNjZXNzb3IgPSB0aGlzLiNnbHRmLmFjY2Vzc29yc1tfaUFjY2Vzc29yXTtcclxuICAgICAgaWYgKCFnbHRmQWNjZXNzb3IpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXN9OiBDb3VsZG4ndCBmaW5kIGFjY2Vzc29yIHdpdGggaW5kZXggJHtfaUFjY2Vzc29yfS5gKTtcclxuXHJcbiAgICAgIGxldCBhcnJheTogVHlwZWRBcnJheTtcclxuICAgICAgY29uc3QgY29tcG9uZW50VHlwZTogR0xURi5DT01QT05FTlRfVFlQRSA9IGdsdGZBY2Nlc3Nvci5jb21wb25lbnRUeXBlO1xyXG4gICAgICBjb25zdCBhY2Nlc3NvclR5cGU6IEdMVEYuQUNDRVNTT1JfVFlQRSA9IGdsdGZBY2Nlc3Nvci50eXBlO1xyXG5cclxuICAgICAgaWYgKGdsdGZBY2Nlc3Nvci5idWZmZXJWaWV3ICE9IHVuZGVmaW5lZClcclxuICAgICAgICBhcnJheSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyVmlld0RhdGEodGhpcy4jZ2x0Zi5idWZmZXJWaWV3c1tnbHRmQWNjZXNzb3IuYnVmZmVyVmlld10sIGdsdGZBY2Nlc3Nvci5ieXRlT2Zmc2V0LCBjb21wb25lbnRUeXBlLCBhY2Nlc3NvclR5cGUpO1xyXG5cclxuICAgICAgaWYgKGdsdGZBY2Nlc3Nvci5zcGFyc2UpIHtcclxuICAgICAgICBjb25zdCBnbHRmQnVmZmVyVmlld0luZGljZXM6IEdMVEYuQnVmZmVyVmlldyA9IHRoaXMuI2dsdGYuYnVmZmVyVmlld3NbZ2x0ZkFjY2Vzc29yLnNwYXJzZS5pbmRpY2VzLmJ1ZmZlclZpZXddO1xyXG4gICAgICAgIGNvbnN0IGdsdGZCdWZmZXJWaWV3VmFsdWVzOiBHTFRGLkJ1ZmZlclZpZXcgPSB0aGlzLiNnbHRmLmJ1ZmZlclZpZXdzW2dsdGZBY2Nlc3Nvci5zcGFyc2UudmFsdWVzLmJ1ZmZlclZpZXddO1xyXG5cclxuICAgICAgICBpZiAoIWdsdGZCdWZmZXJWaWV3SW5kaWNlcyB8fCAhZ2x0ZkJ1ZmZlclZpZXdWYWx1ZXMpXHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc306IENvdWxkbid0IGZpbmQgYnVmZmVyIHZpZXdzIGZvciBzcGFyc2UgaW5kaWNlcyBvciB2YWx1ZXMgb2YgYWNjZXNzb3Igd2l0aCBpbmRleCAke19pQWNjZXNzb3J9LmApO1xyXG5cclxuICAgICAgICBjb25zdCBhcnJheUluZGljZXM6IFR5cGVkQXJyYXkgPSBhd2FpdCB0aGlzLmdldEJ1ZmZlclZpZXdEYXRhKGdsdGZCdWZmZXJWaWV3SW5kaWNlcywgZ2x0ZkFjY2Vzc29yLnNwYXJzZS5pbmRpY2VzLmJ5dGVPZmZzZXQsIGdsdGZBY2Nlc3Nvci5zcGFyc2UuaW5kaWNlcy5jb21wb25lbnRUeXBlLCBHTFRGLkFDQ0VTU09SX1RZUEUuU0NBTEFSKTtcclxuICAgICAgICBjb25zdCBhcnJheVZhbHVlczogVHlwZWRBcnJheSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyVmlld0RhdGEoZ2x0ZkJ1ZmZlclZpZXdWYWx1ZXMsIGdsdGZBY2Nlc3Nvci5zcGFyc2UudmFsdWVzLmJ5dGVPZmZzZXQsIGNvbXBvbmVudFR5cGUsIGFjY2Vzc29yVHlwZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGFjY2Vzc29yVHlwZUxlbmd0aDogbnVtYmVyID0gdG9BY2Nlc3NvclR5cGVMZW5ndGhbZ2x0ZkFjY2Vzc29yLnR5cGVdO1xyXG4gICAgICAgIGlmIChnbHRmQWNjZXNzb3IuYnVmZmVyVmlldyA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICBhcnJheSA9IG5ldyB0b0FycmF5Q29uc3RydWN0b3JbZ2x0ZkFjY2Vzc29yLmNvbXBvbmVudFR5cGVdKGdsdGZBY2Nlc3Nvci5jb3VudCAqIGFjY2Vzc29yVHlwZUxlbmd0aCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBnbHRmQWNjZXNzb3Iuc3BhcnNlLmNvdW50OyBpKyspIHtcclxuICAgICAgICAgIGFycmF5LnNldChhcnJheVZhbHVlcy5zbGljZShpICogYWNjZXNzb3JUeXBlTGVuZ3RoLCAoaSArIDEpICogYWNjZXNzb3JUeXBlTGVuZ3RoKSwgYXJyYXlJbmRpY2VzW2ldICogYWNjZXNzb3JUeXBlTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGdldEJ1ZmZlclZpZXdEYXRhKF9idWZmZXJWaWV3OiBHTFRGLkJ1ZmZlclZpZXcsIF9ieXRlT2Zmc2V0OiBudW1iZXIsIF9jb21wb25lbnRUeXBlOiBHTFRGLkNPTVBPTkVOVF9UWVBFLCBfYWNjZXNzb3JUeXBlOiBHTFRGLkFDQ0VTU09SX1RZUEUpOiBQcm9taXNlPFR5cGVkQXJyYXk+IHtcclxuICAgICAgY29uc3QgYnVmZmVyOiBBcnJheUJ1ZmZlciA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyKF9idWZmZXJWaWV3LmJ1ZmZlcik7XHJcbiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQ6IG51bWJlciA9IChfYnVmZmVyVmlldy5ieXRlT2Zmc2V0ID8/IDApICsgKF9ieXRlT2Zmc2V0ID8/IDApO1xyXG4gICAgICBjb25zdCBieXRlTGVuZ3RoOiBudW1iZXIgPSBfYnVmZmVyVmlldy5ieXRlTGVuZ3RoID8/IDA7XHJcbiAgICAgIGNvbnN0IGJ5dGVTdHJpZGU6IG51bWJlciA9IF9idWZmZXJWaWV3LmJ5dGVTdHJpZGU7XHJcblxyXG4gICAgICBjb25zdCBhcnJheUNvbnN0cnVjdG9yOiBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB0b0FycmF5Q29uc3RydWN0b3JbX2NvbXBvbmVudFR5cGVdO1xyXG4gICAgICAvL0B0cy1pZ25vcmUgYmVjYXVzZSB0aGUgVHlwZWRBcnJheUNvbnN0cnVjdG9yIHR5cGUgaXMgbm90IGFzc2lnbmFibGUgdG8gdGhlIFR5cGVkQXJyYXkgdHlwZVxyXG4gICAgICBjb25zdCBhcnJheTogVHlwZWRBcnJheSA9IG5ldyBhcnJheUNvbnN0cnVjdG9yKGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCAvIGFycmF5Q29uc3RydWN0b3IuQllURVNfUEVSX0VMRU1FTlQpO1xyXG5cclxuICAgICAgaWYgKGJ5dGVTdHJpZGUgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gVE9ETzogaW5zdGVhZCBvZiBjcmVhdGluZyBuZXcgYnVmZmVycyBtYXliZSByYXRoZXIgcGFzcyBzdHJpZGUgaW50byB0aGUgcmVuZGVyIG1lc2g/IGFuZCBzZXQgaXQgd2hlbiBkYXRhIGlzIHBhc3NlZCB0byB0aGUgZ3B1P1xyXG4gICAgICAgIGNvbnN0IG5Db21wb25lbnRzUGVyRWxlbWVudDogbnVtYmVyID0gdG9BY2Nlc3NvclR5cGVMZW5ndGhbX2FjY2Vzc29yVHlwZV07IC8vIGFtb3VudCBvZiBjb21wb25lbnRzIHBlciBlbGVtZW50IG9mIHRoZSBhY2Nlc3NvciB0eXBlLCBlLmcuIDMgZm9yIFZFQzNcclxuICAgICAgICBjb25zdCBuRWxlbWVudHM6IG51bWJlciA9IGJ5dGVMZW5ndGggLyBieXRlU3RyaWRlOyAvLyBhbW91bnQgb2YgZWxlbWVudHMsIGUuZy4gbipWRUMzIFxyXG4gICAgICAgIGNvbnN0IHN0cmlkZTogbnVtYmVyID0gYnl0ZVN0cmlkZSAvIGFycmF5Q29uc3RydWN0b3IuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgY29uc3QgbmV3QXJyYXk6IFR5cGVkQXJyYXkgPSBuZXcgYXJyYXlDb25zdHJ1Y3RvcihuRWxlbWVudHMgKiBuQ29tcG9uZW50c1BlckVsZW1lbnQpO1xyXG4gICAgICAgIGZvciAobGV0IGlOZXdFbGVtZW50OiBudW1iZXIgPSAwOyBpTmV3RWxlbWVudCA8IG5FbGVtZW50czsgaU5ld0VsZW1lbnQrKykge1xyXG4gICAgICAgICAgY29uc3QgaUVsZW1lbnQ6IG51bWJlciA9IGlOZXdFbGVtZW50ICogc3RyaWRlO1xyXG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgaWYgbG9vcCBpcyBmYXN0ZXIgdGhhbiBzZXQgKyBzbGljZVxyXG4gICAgICAgICAgZm9yIChsZXQgaUNvbXBvbmVudDogbnVtYmVyID0gMDsgaUNvbXBvbmVudCA8IG5Db21wb25lbnRzUGVyRWxlbWVudDsgaUNvbXBvbmVudCsrKVxyXG4gICAgICAgICAgICBuZXdBcnJheVtpTmV3RWxlbWVudCAqIG5Db21wb25lbnRzUGVyRWxlbWVudCArIGlDb21wb25lbnRdID0gYXJyYXlbaUVsZW1lbnQgKyBpQ29tcG9uZW50XTtcclxuICAgICAgICAgIC8vIG5ld0FycmF5LnNldChhcnJheS5zbGljZShpRWxlbWVudCwgaUVsZW1lbnQgKyBuQ29tcG9uZW50c1BlckVsZW1lbnQpLCBpTmV3RWxlbWVudCAqIG5Db21wb25lbnRzUGVyRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3QXJyYXk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGdldEJ1ZmZlcihfaUJ1ZmZlcjogbnVtYmVyKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4ge1xyXG4gICAgICBjb25zdCBnbHRmQnVmZmVyOiBHTFRGLkJ1ZmZlciA9IHRoaXMuI2dsdGYuYnVmZmVyc1tfaUJ1ZmZlcl07XHJcbiAgICAgIGlmICghZ2x0ZkJ1ZmZlcilcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc306IENvdWxkbid0IGZpbmQgYnVmZmVyIHdpdGggaW5kZXggJHtfaUJ1ZmZlcn0uYCk7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuI2J1ZmZlcnMpXHJcbiAgICAgICAgdGhpcy4jYnVmZmVycyA9IFtdO1xyXG4gICAgICBpZiAoIXRoaXMuI2J1ZmZlcnNbX2lCdWZmZXJdKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2U6IFJlc3BvbnNlID0gYXdhaXQgZmV0Y2gobmV3IFVSTChnbHRmQnVmZmVyLnVyaSwgbmV3IFVSTCh0aGlzLiN1cmwsIFByb2plY3QuYmFzZVVSTCkpKTtcclxuICAgICAgICB0aGlzLiNidWZmZXJzW19pQnVmZmVyXSA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLiNidWZmZXJzW19pQnVmZmVyXTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGdldEFuaW1hdGlvblNlcXVlbmNlKF9zYW1wbGVyOiBHTFRGLkFuaW1hdGlvblNhbXBsZXIsIF90cmFuc2Zvcm1hdGlvblR5cGU6IEdMVEYuQW5pbWF0aW9uQ2hhbm5lbFRhcmdldFtcInBhdGhcIl0pOiBQcm9taXNlPEFuaW1hdGlvblNlcXVlbmNlPFF1YXRlcm5pb24gfCBWZWN0b3IzPj4ge1xyXG4gICAgICBjb25zdCBpbnB1dDogRmxvYXQzMkFycmF5ID0gYXdhaXQgdGhpcy5nZXRGbG9hdDMyQXJyYXkoX3NhbXBsZXIuaW5wdXQpO1xyXG4gICAgICBjb25zdCBvdXRwdXQ6IEZsb2F0MzJBcnJheSA9IGF3YWl0IHRoaXMuZ2V0RmxvYXQzMkFycmF5KF9zYW1wbGVyLm91dHB1dCk7XHJcblxyXG4gICAgICBjb25zdCBtaWxsaXNQZXJTZWNvbmQ6IG51bWJlciA9IDEwMDA7XHJcbiAgICAgIGNvbnN0IGlzUm90YXRpb246IGJvb2xlYW4gPSBfdHJhbnNmb3JtYXRpb25UeXBlID09IFwicm90YXRpb25cIjtcclxuICAgICAgY29uc3QgdmVjdG9yTGVuZ3RoOiBudW1iZXIgPSBpc1JvdGF0aW9uID8gNCA6IDM7IC8vIHJvdGF0aW9uIGlzIHN0b3JlZCBhcyBxdWF0ZXJuaW9uXHJcbiAgICAgIGNvbnN0IGludGVycG9sYXRpb246IEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OID0gdGhpcy50b0ludGVybkludGVycG9sYXRpb24oX3NhbXBsZXIuaW50ZXJwb2xhdGlvbik7XHJcbiAgICAgIGNvbnN0IGlzQ3ViaWM6IGJvb2xlYW4gPSBpbnRlcnBvbGF0aW9uID09IEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkNVQklDO1xyXG4gICAgICBjb25zdCB2ZWN0b3JzUGVySW5wdXQ6IG51bWJlciA9IGlzQ3ViaWMgPyAzIDogMTsgLy8gY3ViaWMgaW50ZXJwb2xhdGlvbiB1c2VzIDMgdmFsdWVzIHBlciBpbnB1dDogaW4tdGFuZ2VudCwgcHJvcGVydHkgdmFsdWUgYW5kIG91dC10YW5nZW50LiBodHRwczovL3JlZ2lzdHJ5Lmtocm9ub3Mub3JnL2dsVEYvc3BlY3MvMi4wL2dsVEYtMi4wLmh0bWwjaW50ZXJwb2xhdGlvbi1jdWJpY1xyXG5cclxuICAgICAgLy8gdXNlZCBvbmx5IGZvciByb3RhdGlvbiBpbnRlcnBvbGF0aW9uXHJcbiAgICAgIGxldCBsYXN0Um90YXRpb246IFF1YXRlcm5pb247XHJcbiAgICAgIGxldCBuZXh0Um90YXRpb246IFF1YXRlcm5pb247XHJcblxyXG4gICAgICBjb25zdCBzZXF1ZW5jZTogQW5pbWF0aW9uS2V5PFF1YXRlcm5pb24gfCBWZWN0b3IzPltdID0gW107XHJcblxyXG4gICAgICBpZiAoaXNSb3RhdGlvbikge1xyXG4gICAgICAgIGxhc3RSb3RhdGlvbiA9IFJlY3ljbGVyLmdldChRdWF0ZXJuaW9uKTtcclxuICAgICAgICBuZXh0Um90YXRpb24gPSBSZWN5Y2xlci5nZXQoUXVhdGVybmlvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IGlJbnB1dDogbnVtYmVyID0gMDsgaUlucHV0IDwgaW5wdXQubGVuZ3RoOyBpSW5wdXQrKykge1xyXG4gICAgICAgIGNvbnN0IGlPdXRwdXQ6IG51bWJlciA9IGlJbnB1dCAqIHZlY3RvcnNQZXJJbnB1dCAqIHZlY3Rvckxlbmd0aCArIChpc0N1YmljID8gdmVjdG9yTGVuZ3RoIDogMCk7XHJcbiAgICAgICAgY29uc3QgaU91dHB1dFNsb3BlSW46IG51bWJlciA9IGlPdXRwdXQgLSB2ZWN0b3JMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgaU91dHB1dFNsb3BlT3V0OiBudW1iZXIgPSBpT3V0cHV0ICsgdmVjdG9yTGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHRpbWU6IG51bWJlciA9IG1pbGxpc1BlclNlY29uZCAqIGlucHV0W2lJbnB1dF07XHJcblxyXG4gICAgICAgIGxldCB2YWx1ZTogVmVjdG9yMyB8IFF1YXRlcm5pb247XHJcbiAgICAgICAgbGV0IHNsb3BlSW46IFZlY3RvcjMgfCBRdWF0ZXJuaW9uO1xyXG4gICAgICAgIGxldCBzbG9wZU91dDogVmVjdG9yMyB8IFF1YXRlcm5pb247XHJcblxyXG4gICAgICAgIGlmIChpc1JvdGF0aW9uKSB7XHJcbiAgICAgICAgICAvLyBUYWtlIHRoZSBzaG9ydGVzdCBwYXRoIGJldHdlZW4gdHdvIHJvdGF0aW9ucywgaS5lLiBpZiB0aGUgZG90IHByb2R1Y3QgaXMgbmVnYXRpdmUgdGhlbiB0aGUgbmV4dCBxdWF0ZXJuaW9uIG5lZWRzIHRvIGJlIG5lZ2F0ZWQuXHJcbiAgICAgICAgICAvLyBxIGFuZCAtcSByZXByZXNlbnQgdGhlIHNhbWUgcm90YXRpb24gYnV0IGludGVycG9sYXRpb24gd2lsbCB0YWtlIGVpdGhlciB0aGUgbG9uZyB3YXkgb3IgdGhlIHNob3J0IHdheSBhcm91bmQgdGhlIHNwaGVyZSBkZXBlbmRpbmcgb24gd2hpY2ggd2UgdXNlLlxyXG4gICAgICAgICAgbmV4dFJvdGF0aW9uLnNldChvdXRwdXRbaU91dHB1dCArIDBdLCBvdXRwdXRbaU91dHB1dCArIDFdLCBvdXRwdXRbaU91dHB1dCArIDJdLCBvdXRwdXRbaU91dHB1dCArIDNdKTtcclxuICAgICAgICAgIGlmIChRdWF0ZXJuaW9uLkRPVChsYXN0Um90YXRpb24sIG5leHRSb3RhdGlvbikgPCAwKVxyXG4gICAgICAgICAgICBuZXh0Um90YXRpb24ubmVnYXRlKCk7XHJcblxyXG4gICAgICAgICAgbGFzdFJvdGF0aW9uLnNldChuZXh0Um90YXRpb24ueCwgbmV4dFJvdGF0aW9uLnksIG5leHRSb3RhdGlvbi56LCBuZXh0Um90YXRpb24udyk7XHJcbiAgICAgICAgICB2YWx1ZSA9IG5leHRSb3RhdGlvbi5jbG9uZTtcclxuICAgICAgICAgIGlmIChpc0N1YmljKSB7XHJcbiAgICAgICAgICAgIHNsb3BlSW4gPSBuZXcgUXVhdGVybmlvbihvdXRwdXRbaU91dHB1dFNsb3BlSW4gKyAwXSwgb3V0cHV0W2lPdXRwdXRTbG9wZUluICsgMV0sIG91dHB1dFtpT3V0cHV0U2xvcGVJbiArIDJdLCBvdXRwdXRbaU91dHB1dFNsb3BlSW4gKyAzXSk7XHJcbiAgICAgICAgICAgIHNsb3BlT3V0ID0gbmV3IFF1YXRlcm5pb24ob3V0cHV0W2lPdXRwdXRTbG9wZU91dCArIDBdLCBvdXRwdXRbaU91dHB1dFNsb3BlT3V0ICsgMV0sIG91dHB1dFtpT3V0cHV0U2xvcGVPdXQgKyAyXSwgb3V0cHV0W2lPdXRwdXRTbG9wZU91dCArIDNdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFsdWUgPSBuZXcgVmVjdG9yMyhvdXRwdXRbaU91dHB1dCArIDBdLCBvdXRwdXRbaU91dHB1dCArIDFdLCBvdXRwdXRbaU91dHB1dCArIDJdKTtcclxuXHJcbiAgICAgICAgICBpZiAoaXNDdWJpYykge1xyXG4gICAgICAgICAgICBzbG9wZUluID0gbmV3IFZlY3RvcjMob3V0cHV0W2lPdXRwdXRTbG9wZUluICsgMF0sIG91dHB1dFtpT3V0cHV0U2xvcGVJbiArIDFdLCBvdXRwdXRbaU91dHB1dFNsb3BlSW4gKyAyXSk7XHJcbiAgICAgICAgICAgIHNsb3BlT3V0ID0gbmV3IFZlY3RvcjMob3V0cHV0W2lPdXRwdXRTbG9wZU91dCArIDBdLCBvdXRwdXRbaU91dHB1dFNsb3BlT3V0ICsgMV0sIG91dHB1dFtpT3V0cHV0U2xvcGVPdXQgKyAyXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXF1ZW5jZS5wdXNoKG5ldyBBbmltYXRpb25LZXkodGltZSwgdmFsdWUsIGludGVycG9sYXRpb24sIHNsb3BlSW4sIHNsb3BlT3V0KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc1JvdGF0aW9uKSB7XHJcbiAgICAgICAgUmVjeWNsZXIuc3RvcmUobGFzdFJvdGF0aW9uKTtcclxuICAgICAgICBSZWN5Y2xlci5zdG9yZShuZXh0Um90YXRpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbmV3IEFuaW1hdGlvblNlcXVlbmNlKHNlcXVlbmNlLCBpc1JvdGF0aW9uID8gUXVhdGVybmlvbiA6IFZlY3RvcjMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdG9JbnRlcm5JbnRlcnBvbGF0aW9uKF9pbnRlcnBvbGF0aW9uOiBHTFRGLkFuaW1hdGlvblNhbXBsZXJbXCJpbnRlcnBvbGF0aW9uXCJdKTogQU5JTUFUSU9OX0lOVEVSUE9MQVRJT04ge1xyXG4gICAgICBzd2l0Y2ggKF9pbnRlcnBvbGF0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBcIkxJTkVBUlwiOlxyXG4gICAgICAgICAgcmV0dXJuIEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkxJTkVBUjtcclxuICAgICAgICBjYXNlIFwiU1RFUFwiOlxyXG4gICAgICAgICAgcmV0dXJuIEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkNPTlNUQU5UO1xyXG4gICAgICAgIGNhc2UgXCJDVUJJQ1NQTElORVwiOlxyXG4gICAgICAgICAgcmV0dXJuIEFOSU1BVElPTl9JTlRFUlBPTEFUSU9OLkNVQklDO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBpZiAoX2ludGVycG9sYXRpb24gIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBEZWJ1Zy53YXJuKGAke3RoaXN9OiBVbmtub3duIGludGVycG9sYXRpb24gdHlwZSAke19pbnRlcnBvbGF0aW9ufS5gKTtcclxuICAgICAgICAgIHJldHVybiBBTklNQVRJT05fSU5URVJQT0xBVElPTi5MSU5FQVI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFdlYkdMUGFyYW1ldGVyTmFtZShfdmFsdWU6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkuZmluZChfa2V5ID0+IFJlZmxlY3QuZ2V0KFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsIF9rZXkpID09IF92YWx1ZSk7XHJcbiAgfVxyXG5cclxuICB0eXBlIFR5cGVkQXJyYXkgPSBVaW50OEFycmF5IHwgVWludDE2QXJyYXkgfCBVaW50MzJBcnJheSB8IEludDhBcnJheSB8IEludDE2QXJyYXkgfCBGbG9hdDMyQXJyYXk7XHJcbiAgdHlwZSBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBVaW50OEFycmF5Q29uc3RydWN0b3IgfCBVaW50MTZBcnJheUNvbnN0cnVjdG9yIHwgVWludDMyQXJyYXlDb25zdHJ1Y3RvciB8IEludDhBcnJheUNvbnN0cnVjdG9yIHwgSW50MTZBcnJheUNvbnN0cnVjdG9yIHwgRmxvYXQzMkFycmF5Q29uc3RydWN0b3I7XHJcblxyXG4gIGNvbnN0IHRvSW50ZXJuVHJhbnNmb3JtYXRpb246IFJlY29yZDxFeGNsdWRlPEdMVEYuQW5pbWF0aW9uQ2hhbm5lbFRhcmdldFtcInBhdGhcIl0sIFwid2VpZ2h0c1wiPiwgXCJ0cmFuc2xhdGlvblwiIHwgXCJyb3RhdGlvblwiIHwgXCJzY2FsaW5nXCI+ID0ge1xyXG4gICAgXCJ0cmFuc2xhdGlvblwiOiBcInRyYW5zbGF0aW9uXCIsXHJcbiAgICBcInJvdGF0aW9uXCI6IFwicm90YXRpb25cIixcclxuICAgIFwic2NhbGVcIjogXCJzY2FsaW5nXCJcclxuICB9O1xyXG5cclxuICAvLyBudW1iZXIgb2YgY29tcG9uZW50cyBkZWZpbmVkIGJ5ICd0eXBlJ1xyXG4gIGNvbnN0IHRvQWNjZXNzb3JUeXBlTGVuZ3RoOiBSZWNvcmQ8R0xURi5BQ0NFU1NPUl9UWVBFLCBudW1iZXI+ID0ge1xyXG4gICAgXCJTQ0FMQVJcIjogMSxcclxuICAgIFwiVkVDMlwiOiAyLFxyXG4gICAgXCJWRUMzXCI6IDMsXHJcbiAgICBcIlZFQzRcIjogNCxcclxuICAgIFwiTUFUMlwiOiA0LFxyXG4gICAgXCJNQVQzXCI6IDksXHJcbiAgICBcIk1BVDRcIjogMTZcclxuICB9O1xyXG5cclxuICBjb25zdCB0b0FycmF5Q29uc3RydWN0b3I6IFJlY29yZDxHTFRGLkNPTVBPTkVOVF9UWVBFLCBUeXBlZEFycmF5Q29uc3RydWN0b3I+ID0ge1xyXG4gICAgW0dMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfQllURV06IFVpbnQ4QXJyYXksXHJcbiAgICBbR0xURi5DT01QT05FTlRfVFlQRS5CWVRFXTogSW50OEFycmF5LFxyXG4gICAgW0dMVEYuQ09NUE9ORU5UX1RZUEUuVU5TSUdORURfU0hPUlRdOiBVaW50MTZBcnJheSxcclxuICAgIFtHTFRGLkNPTVBPTkVOVF9UWVBFLlNIT1JUXTogSW50MTZBcnJheSxcclxuICAgIFtHTFRGLkNPTVBPTkVOVF9UWVBFLlVOU0lHTkVEX0lOVF06IFVpbnQzMkFycmF5LFxyXG4gICAgW0dMVEYuQ09NUE9ORU5UX1RZUEUuRkxPQVRdOiBGbG9hdDMyQXJyYXlcclxuICB9O1xyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XG4gIGV4cG9ydCBsZXQgc2hhZGVyU291cmNlczoge1tzb3VyY2U6IHN0cmluZ106IHN0cmluZ30gPSB7fTtcbiAgc2hhZGVyU291cmNlc1tcIlNoYWRlckFtYmllbnRPY2NsdXNpb24uZnJhZ1wiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYW1iaWVudCBvY2NsdXNpb24gZm9yIGEgZ2l2ZW4gZnJhZ21lbnRcclxuICogQGF1dGhvcnMgUm9sYW5kIEhlZXIsIEhGVSwgMjAyMyB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xyXG4gKiBhZGFwdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vdHNoZXJpZi93ZWJnbDJleGFtcGxlcy9ibG9iL2RhMTE1M2ExNWViYzA5YmIxMzQ5OGU1ZjczMmVmMjAzNjUwNzc0MGMvc3Nhby5odG1sXHJcbiAqIHNlZSBoZXJlIGZvciBhbiBpbiBkZXB0aCBleHBsYW5hdGlvbjogXHJcbiovXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5wcmVjaXNpb24gaGlnaHAgaW50O1xyXG5cclxuY29uc3QgZmxvYXQgc2luNDUgPSAwLjcwNzEwNzsgLy8gNDUgZGVncmVlcyBpbiByYWRpYW5zXHJcbmNvbnN0IHZlYzIga2VybmVsWzRdID0gdmVjMls0XSh2ZWMyKDAuMCwgMS4wKSwgdmVjMigxLjAsIDAuMCksIHZlYzIoMC4wLCAtMS4wKSwgdmVjMigtMS4wLCAwLjApKTtcclxuXHJcbnVuaWZvcm0gZmxvYXQgdV9mTmVhcjtcclxudW5pZm9ybSBmbG9hdCB1X2ZGYXI7XHJcbnVuaWZvcm0gZmxvYXQgdV9mU2FtcGxlUmFkaXVzO1xyXG51bmlmb3JtIGZsb2F0IHVfZkJpYXM7XHJcbnVuaWZvcm0gZmxvYXQgdV9mQXR0ZW51YXRpb25Db25zdGFudDtcclxudW5pZm9ybSBmbG9hdCB1X2ZBdHRlbnVhdGlvbkxpbmVhcjtcclxudW5pZm9ybSBmbG9hdCB1X2ZBdHRlbnVhdGlvblF1YWRyYXRpYztcclxudW5pZm9ybSB2ZWMyIHVfdmN0UmVzb2x1dGlvbjtcclxudW5pZm9ybSB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG4vLyB1bmlmb3JtIG1hdDQgdV9tdHhWaWV3UHJvamVjdGlvbkludmVyc2U7XHJcblxyXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleFBvc2l0aW9uO1xyXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleE5vcm1hbDtcclxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhOb2lzZTtcclxuLy8gdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhEZXB0aDtcclxuXHJcbmluIHZlYzIgdl92Y3RUZXh0dXJlO1xyXG5vdXQgdmVjNCB2Y3RGcmFnO1xyXG5cclxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBGb2cge1xyXG4gIGJvb2wgdV9iRm9nQWN0aXZlO1xyXG4gIGZsb2F0IHVfZkZvZ05lYXI7XHJcbiAgZmxvYXQgdV9mRm9nRmFyO1xyXG4gIGZsb2F0IHBhZGluZztcclxuICB2ZWM0IHVfdmN0Rm9nQ29sb3I7XHJcbn07XHJcblxyXG4vLyBUaGlzIGZ1bmN0aW9uIGNvdWxkIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBmcm9tIHRoZSBkZXB0aCB0ZXh0dXJlLCBidXQgbW9iaWxlIGRldmljZXMgc2VlbXMgdG8gbGFjayBpbiBwcmVjaXNpb24gdG8gZG8gdGhpc1xyXG4vLyB2ZWMzIGdldFBvc2l0aW9uKHZlYzIgX3ZjdFRleHR1cmUpIHtcclxuLy8gICBmbG9hdCBmRGVwdGggPSB0ZXh0dXJlKHVfdGV4RGVwdGgsIF92Y3RUZXh0dXJlKS5yO1xyXG4vLyAgIHZlYzQgY2xpcFNwYWNlUG9zaXRpb24gPSB2ZWM0KF92Y3RUZXh0dXJlICogMi4wIC0gMS4wLCBmRGVwdGggKiAyLjAgLSAxLjAsIDEuMCk7XHJcbi8vICAgdmVjNCB3b3JsZFNwYWNlUG9zaXRpb24gPSB1X210eFZpZXdQcm9qZWN0aW9uSW52ZXJzZSAqIGNsaXBTcGFjZVBvc2l0aW9uO1xyXG4vLyAgIHJldHVybiB3b3JsZFNwYWNlUG9zaXRpb24ueHl6IC8gd29ybGRTcGFjZVBvc2l0aW9uLnc7XHJcbi8vIH1cclxuXHJcbmZsb2F0IGdldE9jY2x1c2lvbih2ZWMzIF92Y3RQb3NpdGlvbiwgdmVjMyBfdmN0Tm9ybWFsLCB2ZWMyIF92Y3RUZXh0dXJlKSB7XHJcbiAgdmVjMyB2Y3RPY2NsdWRlciA9IHRleHR1cmUodV90ZXhQb3NpdGlvbiwgX3ZjdFRleHR1cmUpLnh5ejtcclxuXHJcbiAgaWYgKHZjdE9jY2x1ZGVyLnggPT0gMC4wICYmIHZjdE9jY2x1ZGVyLnkgPT0gMC4wICYmIHZjdE9jY2x1ZGVyLnogPT0gMC4wKSAvLyBubyBvY2NsdWRlciBhdCB0aGlzIHBvc2l0aW9uXHJcbiAgICByZXR1cm4gMC4wO1xyXG5cclxuICB2ZWMzIHZjdERpc3RhbmNlID0gdmN0T2NjbHVkZXIgLSBfdmN0UG9zaXRpb247XHJcbiAgZmxvYXQgZkludGVuc2l0eSA9IG1heChkb3QoX3ZjdE5vcm1hbCwgbm9ybWFsaXplKHZjdERpc3RhbmNlKSkgLSB1X2ZCaWFzLCAwLjApO1xyXG5cclxuICBmbG9hdCBmRGlzdGFuY2UgPSBsZW5ndGgodmN0RGlzdGFuY2UpO1xyXG4gIGZsb2F0IGZBdHRlbnVhdGlvbiA9IDEuMCAvICh1X2ZBdHRlbnVhdGlvbkNvbnN0YW50ICsgdV9mQXR0ZW51YXRpb25MaW5lYXIgKiBmRGlzdGFuY2UgKyB1X2ZBdHRlbnVhdGlvblF1YWRyYXRpYyAqIGZEaXN0YW5jZSAqIGZEaXN0YW5jZSk7XHJcblxyXG4gIHJldHVybiBmSW50ZW5zaXR5ICogZkF0dGVudWF0aW9uO1xyXG59XHJcblxyXG5mbG9hdCBnZXRGb2codmVjMyBfdmN0UG9zaXRpb24pIHtcclxuICBmbG9hdCBmRGlzdGFuY2UgPSBsZW5ndGgoX3ZjdFBvc2l0aW9uIC0gdV92Y3RDYW1lcmEpOyAvLyBtYXliZSB1c2Ugei1kZXB0aCBpbnN0ZWFkIG9mIGV1Y2xpZGVhbiBkZXB0aFxyXG4gIGZsb2F0IGZGb2cgPSBjbGFtcCgoZkRpc3RhbmNlIC0gdV9mRm9nTmVhcikgLyAodV9mRm9nRmFyIC0gdV9mRm9nTmVhciksIDAuMCwgMS4wKTtcclxuICBmRm9nID0gLXBvdyhmRm9nLCAyLjApICsgKDIuMCAqIGZGb2cpOyAvLyBsZXRzIGZvZyBhcHBlYXIgcXVpY2tlciBhbmQgZmFsbCBvZmYgc2xvd2VyIHJlc3VsdHMgaW4gYSBtb3JlIGdyYWR1YWwgZmFsbG9mZlxyXG4gIHJldHVybiBmRm9nICogdV92Y3RGb2dDb2xvci5hO1xyXG59XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgdmVjMyB2Y3RQb3NpdGlvbiA9IHRleHR1cmUodV90ZXhQb3NpdGlvbiwgdl92Y3RUZXh0dXJlKS54eXo7XHJcbiAgdmVjMyB2Y3ROb3JtYWwgPSB0ZXh0dXJlKHVfdGV4Tm9ybWFsLCB2X3ZjdFRleHR1cmUpLnh5ejtcclxuICB2ZWMyIHZjdFJhbmRvbSA9IG5vcm1hbGl6ZSh0ZXh0dXJlKHVfdGV4Tm9pc2UsIHZfdmN0VGV4dHVyZSkueHkgKiAyLjAgLSAxLjApO1xyXG4gIGZsb2F0IGZEZXB0aCA9IChsZW5ndGgodmN0UG9zaXRpb24gLSB1X3ZjdENhbWVyYSkgLSB1X2ZOZWFyKSAvICh1X2ZGYXIgLSB1X2ZOZWFyKTsgLy8gbGluZWFyIGV1Y2xpZGVhbiBkZXB0aCBpbiByYW5nZSBbMCwxXSwgd2hlbiBjaGFuZ2luZyB0byB2aWV3IHNwYWNlLCBkb24ndCBzdWJ0cmFjdCBjYW1lcmEgcG9zaXRpb25cclxuICBmbG9hdCBmS2VybmVsUmFkaXVzID0gdV9mU2FtcGxlUmFkaXVzICogKDEuMCAtIGZEZXB0aCk7XHJcblxyXG4gIGZsb2F0IGZPY2NsdXNpb24gPSAwLjA7XHJcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCA0OyArK2kpIHtcclxuICAgIHZlYzIgdmN0SzEgPSByZWZsZWN0KGtlcm5lbFtpXSwgdmN0UmFuZG9tKTtcclxuICAgIHZlYzIgdmN0SzIgPSB2ZWMyKHZjdEsxLnggKiBzaW40NSAtIHZjdEsxLnkgKiBzaW40NSwgdmN0SzEueCAqIHNpbjQ1ICsgdmN0SzEueSAqIHNpbjQ1KTtcclxuXHJcbiAgICB2Y3RLMSAvPSB1X3ZjdFJlc29sdXRpb247XHJcbiAgICB2Y3RLMiAvPSB1X3ZjdFJlc29sdXRpb247XHJcblxyXG4gICAgdmN0SzEgKj0gZktlcm5lbFJhZGl1cztcclxuICAgIHZjdEsyICo9IGZLZXJuZWxSYWRpdXM7XHJcblxyXG4gICAgZk9jY2x1c2lvbiArPSBnZXRPY2NsdXNpb24odmN0UG9zaXRpb24sIHZjdE5vcm1hbCwgdl92Y3RUZXh0dXJlICsgdmN0SzEpO1xyXG4gICAgZk9jY2x1c2lvbiArPSBnZXRPY2NsdXNpb24odmN0UG9zaXRpb24sIHZjdE5vcm1hbCwgdl92Y3RUZXh0dXJlICsgdmN0SzIgKiAwLjc1KTtcclxuICAgIGZPY2NsdXNpb24gKz0gZ2V0T2NjbHVzaW9uKHZjdFBvc2l0aW9uLCB2Y3ROb3JtYWwsIHZfdmN0VGV4dHVyZSArIHZjdEsxICogMC41KTtcclxuICAgIGZPY2NsdXNpb24gKz0gZ2V0T2NjbHVzaW9uKHZjdFBvc2l0aW9uLCB2Y3ROb3JtYWwsIHZfdmN0VGV4dHVyZSArIHZjdEsyICogMC4yNSk7XHJcbiAgfVxyXG5cclxuICBmT2NjbHVzaW9uID0gY2xhbXAoZk9jY2x1c2lvbiAvIDE2LjAsIDAuMCwgMS4wKTtcclxuXHJcbiAgaWYgKHVfYkZvZ0FjdGl2ZSAmJiBmT2NjbHVzaW9uID4gMC4wKSAvLyBjb3JyZWN0IG9jY2x1c2lvbiBieSBmb2cgZmFjdG9yXHJcbiAgICBmT2NjbHVzaW9uID0gbWl4KGZPY2NsdXNpb24sIDAuMCwgZ2V0Rm9nKHZjdFBvc2l0aW9uKSk7XHJcbiAgXHJcbiAgdmN0RnJhZy5yZ2IgPSB2ZWMzKGZPY2NsdXNpb24pO1xyXG4gIHZjdEZyYWcuYSA9IDEuMDtcclxufWA7XG4gIHNoYWRlclNvdXJjZXNbXCJTaGFkZXJCbG9vbS5mcmFnXCJdID0gLypnbHNsKi8gYCN2ZXJzaW9uIDMwMCBlc1xyXG4vKipcclxuICogRXh0cmFjdHMgY29sb3JzLCBkb3duc2FtcGxlcyBhbmQgdXBzYW1wbGVzIGEgdGV4dHVyZVxyXG4gKiBBZGFwdGlvbiBvZiB0aGUgXCJkdWFsIGZpbHRlcmluZyBrYXdhc2VcIiBtZXRob2QgZGVzY3JpYmVkIGluIFNJR0dSQVBIIDIwMTUgYnkgTWFyaXVzIEJqw7hyZ2VcclxuICogaHR0cHM6Ly9jb21tdW5pdHkuYXJtLmNvbS9jZnMtZmlsZS9fX2tleS9jb21tdW5pdHlzZXJ2ZXItYmxvZ3MtY29tcG9uZW50cy13ZWJsb2dmaWxlcy8wMC0wMC0wMC0yMC02Ni9zaWdncmFwaDIwMTVfMkQwMF9tbWdfMkQwMF9tYXJpdXNfMkQwMF9ub3Rlcy5wZGZcclxuICogQGF1dGhvcnMgUm9sYW5kIEhlZXIsIEhGVSwgMjAyMyB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIzIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXHJcbiAqL1xyXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxucHJlY2lzaW9uIGhpZ2hwIGludDtcclxuXHJcbnVuaWZvcm0gaW50IHVfaU1vZGU7IC8vIDA6IGV4dHJhY3QsIDE6IGRvd25zYW1wbGUsIDI6IHVwc2FtcGxlLCAzOiBhcHBseVxyXG51bmlmb3JtIGZsb2F0IHVfZlRocmVzaG9sZDtcclxudW5pZm9ybSBmbG9hdCB1X2ZJbnRlbnNpdHk7XHJcbnVuaWZvcm0gZmxvYXQgdV9mSGlnaGxpZ2h0RGVzYXR1cmF0aW9uO1xyXG51bmlmb3JtIHZlYzIgdV92Y3RUZXhlbDtcclxuXHJcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4U291cmNlO1xyXG5cclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG4vLyBvbGQgZ2F1c3NpYW4gYmx1clxyXG4vLyBmbGF0IGluIHZlYzJbOV0gdl92Y3RPZmZzZXRzO1xyXG4vLyBjb25zdCBmbG9hdCBnYXVzc2lhbktlcm5lbFs5XSA9IGZsb2F0W10oMC4wNDUsIDAuMTIyLCAwLjA0NSwgMC4xMjIsIDAuMzMyLCAwLjEyMiwgMC4wNDUsIDAuMTIyLCAwLjA0NSk7XHJcbi8vIHZlYzQgZG93bnNhbXBsZSh2ZWMyIF92Y3RUZXh0dXJlKSB7XHJcbi8vICAgdmVjNCB2Y3RDb2xvciA9IHZlYzQoMC4wKTtcclxuLy8gICBmb3IgKGludCBpID0gMDsgaSA8IDk7IGkrKykgXHJcbi8vICAgICB2Y3RDb2xvciArPSB0ZXh0dXJlKHVfdGV4U291cmNlLCB2X3ZjdFRleHR1cmUgKyB2X3ZjdE9mZnNldHNbaV0pICogZ2F1c3NpYW5LZXJuZWxbaV07XHJcbi8vICAgcmV0dXJuIHZjdENvbG9yO1xyXG4vLyB9XHJcbi8vIHZlYzQgdXBzYW1wbGUodmVjMiBfdmN0VGV4dHVyZSkge1xyXG4vLyAgIHZlYzQgdmN0Q29sb3IgPSB2ZWM0KDAuMCk7XHJcbi8vICAgZm9yIChpbnQgaSA9IDA7IGkgPCA5OyBpKyspIFxyXG4vLyAgICAgdmN0Q29sb3IgKz0gdGV4dHVyZSh1X3RleFNvdXJjZSwgX3ZjdFRleHR1cmUgKyB2X3ZjdE9mZnNldHNbaV0pICogZ2F1c3NpYW5LZXJuZWxbaV07XHJcbi8vICAgcmV0dXJuIHZjdENvbG9yO1xyXG4vLyB9XHJcblxyXG4vLyB2ZWMzIGV4dHJhY3QodmVjMiBfdmN0VGV4dHVyZSkge1xyXG4vLyAgIHZlYzMgdmN0Q29sb3IgPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSkucmdiO1xyXG4vLyAgIGlmKGFueShncmVhdGVyVGhhbih2Y3RDb2xvciwgdmVjMyh1X2ZUaHJlc2hvbGQpKSkpXHJcbi8vICAgICByZXR1cm4gdmN0Q29sb3I7XHJcbi8vICAgZGlzY2FyZDtcclxuLy8gfVxyXG5cclxuLy8gdmVjMyBleHRyYWN0KHZlYzIgX3ZjdFRleHR1cmUpIHtcclxuLy8gICB2ZWMzIHZjdENvbG9yID0gdGV4dHVyZSh1X3RleFNvdXJjZSwgX3ZjdFRleHR1cmUpLnJnYjtcclxuLy8gICBmbG9hdCBsdW1pbmFuY2UgPSBkb3QodmN0Q29sb3IsIHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCkpO1xyXG4vLyAgIGlmKGx1bWluYW5jZSA+IHVfZlRocmVzaG9sZClcclxuLy8gICAgIHJldHVybiB2Y3RDb2xvcjtcclxuLy8gICBkaXNjYXJkO1xyXG4vLyB9XHJcblxyXG4vLyBvbGQgZXh0cmFjdGlvbiB3aXRoIGF2ZXJhZ2UgYnJpZ2h0bmVzc1xyXG52ZWMzIGV4dHJhY3QodmVjMiBfdmN0VGV4dHVyZSkge1xyXG4gIHZlYzMgdmN0Q29sb3IgPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSkucmdiO1xyXG4gIGZsb2F0IGZUaHJlc2hvbGQgPSB1X2ZUaHJlc2hvbGQ7XHJcbiAgaWYoZlRocmVzaG9sZCA+PSAxLjApXHJcbiAgICBmVGhyZXNob2xkID0gMC45OTk5OTk7XHJcblxyXG4gIHZjdENvbG9yID0gdmN0Q29sb3IgLSBmVGhyZXNob2xkO1xyXG4gIHZjdENvbG9yID0gdmN0Q29sb3IgLyAoMS4wIC0gZlRocmVzaG9sZCk7IC8vIG5lZ2F0aXZlIHZhbHVlcyBtaWdodCByZWNlaXZlIHZhbHVlcyBhYm92ZSAxLjAuLi5cclxuICBcclxuICBmbG9hdCBhdmVyYWdlQnJpZ2h0bmVzcyA9ICgoKHZjdENvbG9yLnIgKyB2Y3RDb2xvci5nICsgdmN0Q29sb3IuYikgLyAzLjApICogMC4yKSArIDAuODsgLy90aGUgZWZmZWN0IGlzIHJlZHVjZWQgYnkgZmlyc3Qgc2V0dGluZyBpdCB0byBhIDAuMC0wLjIgcmFuZ2UgYW5kIHRoZW4gYWRkaW5nIDAuOFxyXG4gIHZjdENvbG9yID0gY2xhbXAodmN0Q29sb3IsIDAuMCwgMS4wKSAqIGNsYW1wKGF2ZXJhZ2VCcmlnaHRuZXNzLCAwLjAsIDEuMCk7XHJcbiAgcmV0dXJuIHZjdENvbG9yO1xyXG59XHJcblxyXG52ZWM0IGRvd25zYW1wbGUodmVjMiBfdmN0VGV4dHVyZSkge1xyXG4gIHZlYzQgc3VtID0gdGV4dHVyZSh1X3RleFNvdXJjZSwgX3ZjdFRleHR1cmUpICogNC4wO1xyXG4gIHN1bSArPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSAtIHVfdmN0VGV4ZWwueHkpO1xyXG4gIHN1bSArPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSArIHVfdmN0VGV4ZWwueHkpO1xyXG4gIHN1bSArPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSArIHZlYzIodV92Y3RUZXhlbC54LCAtdV92Y3RUZXhlbC55KSk7XHJcbiAgc3VtICs9IHRleHR1cmUodV90ZXhTb3VyY2UsIF92Y3RUZXh0dXJlIC0gdmVjMih1X3ZjdFRleGVsLngsIC11X3ZjdFRleGVsLnkpKTtcclxuXHJcbiAgcmV0dXJuIHN1bSAvIDguMDtcclxufVxyXG5cclxudmVjNCB1cHNhbXBsZSh2ZWMyIF92Y3RUZXh0dXJlKSB7XHJcbiAgdmVjNCBzdW0gPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSArIHZlYzIoLXVfdmN0VGV4ZWwueCAqIDIuMCwgMC4wKSk7XHJcbiAgc3VtICs9IHRleHR1cmUodV90ZXhTb3VyY2UsIF92Y3RUZXh0dXJlICsgdmVjMigtdV92Y3RUZXhlbC54LCB1X3ZjdFRleGVsLnkpKSAqIDIuMDtcclxuICBzdW0gKz0gdGV4dHVyZSh1X3RleFNvdXJjZSwgX3ZjdFRleHR1cmUgKyB2ZWMyKDAuMCwgdV92Y3RUZXhlbC55ICogMi4wKSk7XHJcbiAgc3VtICs9IHRleHR1cmUodV90ZXhTb3VyY2UsIF92Y3RUZXh0dXJlICsgdmVjMih1X3ZjdFRleGVsLngsIHVfdmN0VGV4ZWwueSkpICogMi4wO1xyXG4gIHN1bSArPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSArIHZlYzIodV92Y3RUZXhlbC54ICogMi4wLCAwLjApKTtcclxuICBzdW0gKz0gdGV4dHVyZSh1X3RleFNvdXJjZSwgX3ZjdFRleHR1cmUgKyB2ZWMyKHVfdmN0VGV4ZWwueCwgLXVfdmN0VGV4ZWwueSkpICogMi4wO1xyXG4gIHN1bSArPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSArIHZlYzIoMC4wLCAtdV92Y3RUZXhlbC55ICogMi4wKSk7XHJcbiAgc3VtICs9IHRleHR1cmUodV90ZXhTb3VyY2UsIF92Y3RUZXh0dXJlICsgdmVjMigtdV92Y3RUZXhlbC54LCAtdV92Y3RUZXhlbC55KSkgKiAyLjA7XHJcbiAgcmV0dXJuIHN1bSAvIDEyLjA7XHJcbn1cclxuXHJcbnZlYzMgYXBwbHkodmVjMiBfdmN0VGV4dHVyZSkge1xyXG4gIHZlYzMgdmN0Qmxvb20gPSB0ZXh0dXJlKHVfdGV4U291cmNlLCBfdmN0VGV4dHVyZSkucmdiO1xyXG4gIGlmICh2Y3RCbG9vbS5yID49IDEuMCB8fCB2Y3RCbG9vbS5nID49IDEuMCB8fCB2Y3RCbG9vbS5iID49IDEuMCkgLy8gbWF5YmUgdXNlIHRocmVzaG9sZCBpbnN0ZWFkIG9mIDEuMD9cclxuICAgIHZjdEJsb29tID0gbWl4KHZjdEJsb29tLCB2ZWMzKDEuMCksIHVfZkhpZ2hsaWdodERlc2F0dXJhdGlvbik7XHJcbiAgdmN0Qmxvb20gPSBjbGFtcCh2Y3RCbG9vbSAqIHVfZkludGVuc2l0eSwgMC4wLCAxLjApO1xyXG4gIHJldHVybiB2Y3RCbG9vbTtcclxufVxyXG5cclxudm9pZCBtYWluKCkge1xyXG4gIHN3aXRjaCh1X2lNb2RlKSB7XHJcbiAgICBjYXNlIDA6XHJcbiAgICAgIHZjdEZyYWcucmdiID0gZXh0cmFjdCh2X3ZjdFRleHR1cmUpO1xyXG4gICAgICB2Y3RGcmFnLmEgPSAxLjA7XHJcbiAgICAgIHJldHVybjtcclxuICAgIGNhc2UgMTpcclxuICAgICAgdmN0RnJhZyA9IGRvd25zYW1wbGUodl92Y3RUZXh0dXJlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAyOlxyXG4gICAgICB2Y3RGcmFnID0gdXBzYW1wbGUodl92Y3RUZXh0dXJlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY2FzZSAzOlxyXG4gICAgICB2Y3RGcmFnLnJnYiA9IGFwcGx5KHZfdmN0VGV4dHVyZSk7XHJcbiAgICAgIHZjdEZyYWcuYSA9IDEuMDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdmN0RnJhZyA9IHRleHR1cmUodV90ZXhTb3VyY2UsIHZfdmN0VGV4dHVyZSk7XHJcbiAgICAgIHJldHVybjtcclxuICB9XHJcbn1gO1xuICBzaGFkZXJTb3VyY2VzW1wiU2hhZGVyR2l6bW8uZnJhZ1wiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogLi4uXHJcbiogQGF1dGhvcnMgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXHJcbiovXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5wcmVjaXNpb24gaGlnaHAgaW50O1xyXG5cclxudW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XHJcblxyXG5vdXQgdmVjNCB2Y3RGcmFnO1xyXG5cclxuLy8gdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhEZXB0aFN0ZW5jaWw7XHJcbiNpZiBkZWZpbmVkKFRFWFRVUkUpXHJcblxyXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4Q29sb3I7XHJcbiAgaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbiAgXHJcbiNlbmRpZlxyXG5cclxuLy8gLy8gNHg0IEJheWVyIG1hdHJpeCBmb3IgZGl0aGVyaW5nXHJcbi8vIGNvbnN0IGZsb2F0IG10eERpdGhlclsxNl0gPSBmbG9hdFtdKFxyXG4vLyAgIDEuMCAvIDE3LjAsICA5LjAgLyAxNy4wLCAgMy4wIC8gMTcuMCwgMTEuMCAvIDE3LjAsXHJcbi8vICAgMTMuMCAvIDE3LjAsICA1LjAgLyAxNy4wLCAxNS4wIC8gMTcuMCwgIDcuMCAvIDE3LjAsXHJcbi8vICAgNC4wIC8gMTcuMCwgMTIuMCAvIDE3LjAsICAyLjAgLyAxNy4wLCAxMC4wIC8gMTcuMCxcclxuLy8gICAxNi4wIC8gMTcuMCwgIDguMCAvIDE3LjAsIDE0LjAgLyAxNy4wLCAgNi4wIC8gMTcuMFxyXG4vLyApO1xyXG5cclxudm9pZCBtYWluKCkge1xyXG4gIHZjdEZyYWcgPSB1X3ZjdENvbG9yO1xyXG5cclxuICAjaWYgZGVmaW5lZChURVhUVVJFKVxyXG5cclxuICAgICAgdmN0RnJhZyAqPSB0ZXh0dXJlKHVfdGV4Q29sb3IsIHZfdmN0VGV4dHVyZSk7XHJcblxyXG4gICNlbmRpZlxyXG5cclxuICAvLyBpbnQgeCA9IGludChnbF9GcmFnQ29vcmQueCkgJSA0O1xyXG4gIC8vIGludCB5ID0gaW50KGdsX0ZyYWdDb29yZC55KSAlIDQ7XHJcbiAgLy8gaW50IGluZGV4ID0geSAqIDQgKyB4O1xyXG4gIC8vIC8vIERpc2NhcmQgdGhlIGZyYWdtZW50IGlmIGl0cyBhbHBoYSBpcyBsZXNzIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgaW4gdGhlIGRpdGhlcmluZyBtYXRyaXhcclxuICAvLyBpZiAodmN0RnJhZy5hIDwgbXR4RGl0aGVyW2luZGV4XSkgXHJcbiAgLy8gICBkaXNjYXJkO1xyXG5cclxuICAvLyAvLyBEaXNjYXJkIHRoZSBmcmFnbWVudCBpZiBpdHMgYWxwaGEgaXMgMFxyXG4gIC8vIGlmICh2Y3RGcmFnLmEgPT0gMC4wKVxyXG4gIC8vICAgZGlzY2FyZDtcclxuXHJcbiAgLy8gLy8gQ3JlYXRlIGEgY2hlY2tlcmJvYXJkIHBhdHRlcm4gZm9yIGFscGhhIHZhbHVlcyBsZXNzIHRoYW4gMC41XHJcbiAgLy8gZWxzZSBpZiAodmN0RnJhZy5hIDwgMC41ICYmICgoeCArIHkpICUgMiA9PSAwKSlcclxuICAvLyAgIGRpc2NhcmQ7XHJcblxyXG4gIC8vIHZjdEZyYWcuYSA9IDEuMDtcclxuXHJcbiAgaWYgKHZjdEZyYWcuYSA8IDAuMDEpXHJcbiAgICBkaXNjYXJkO1xyXG59YDtcbiAgc2hhZGVyU291cmNlc1tcIlNoYWRlckdpem1vLnZlcnRcIl0gPSAvKmdsc2wqLyBgI3ZlcnNpb24gMzAwIGVzXHJcbi8qKlxyXG4qIC4uLlxyXG4qIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xyXG4qL1xyXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxucHJlY2lzaW9uIGhpZ2hwIGludDtcclxuXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkOyAvLyB1X210eE1vZGVsXHJcblxyXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENhbWVyYSB7XHJcbiAgbWF0NCB1X210eFdvcmxkVG9DYW1lcmE7IC8vIHVfbXR4Vmlld1xyXG4gIG1hdDQgdV9tdHhQcm9qZWN0aW9uOyBcclxuICBtYXQ0IHVfbXR4V29ybGRUb1ZpZXc7IC8vIHVfbXR4Vmlld1Byb2plY3Rpb25cclxuICB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG59O1xyXG5cclxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjMyBhX3ZjdFBvc2l0aW9uO1xyXG5cclxuI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuXHJcbiAgbGF5b3V0KGxvY2F0aW9uID0gMikgaW4gdmVjMiBhX3ZjdFRleHR1cmU7XHJcbiAgb3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG5cclxuI2VuZGlmXHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgZ2xfUG9zaXRpb24gPSB1X210eFdvcmxkVG9WaWV3ICogdV9tdHhNZXNoVG9Xb3JsZCAqIHZlYzQoYV92Y3RQb3NpdGlvbiwgMS4wKTtcclxuXHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuXHJcbiAgICB2X3ZjdFRleHR1cmUgPSBhX3ZjdFRleHR1cmU7XHJcblxyXG4gICNlbmRpZlxyXG59YDtcbiAgc2hhZGVyU291cmNlc1tcIlNoYWRlck91dGxpbmUuZnJhZ1wiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiAqIEBhdXRob3JzIEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyNVxyXG4gKi9cclxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbnByZWNpc2lvbiBoaWdocCBpbnQ7XHJcblxyXG51bmlmb3JtIHZlYzIgdV92Y3RUZXhlbDtcclxudW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XHJcbnVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yT2NjbHVkZWQ7XHJcblxyXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleERlcHRoT3V0bGluZTtcclxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhEZXB0aFNjZW5lO1xyXG5cclxuaW4gdmVjMiB2X3ZjdFRleHR1cmU7XHJcbm91dCB2ZWM0IHZjdEZyYWc7XHJcblxyXG5mbG9hdCBnZXREZXB0aCh2ZWMyIF92Y3RUZXh0dXJlKSB7XHJcbiAgcmV0dXJuIHRleHR1cmUodV90ZXhEZXB0aE91dGxpbmUsIF92Y3RUZXh0dXJlKS5yO1xyXG59XHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgZmxvYXQgZkRlcHRoID0gZ2V0RGVwdGgodl92Y3RUZXh0dXJlKTtcclxuXHJcbiAgaWYgKGZEZXB0aCAhPSAxLjApXHJcbiAgICBkaXNjYXJkO1xyXG5cclxuICBmbG9hdCBmRGVwdGhUb3AgPSBnZXREZXB0aCh2X3ZjdFRleHR1cmUgKyB2ZWMyKDAsIHVfdmN0VGV4ZWwueSkpO1xyXG4gIGZsb2F0IGZEZXB0aFJpZ2h0ID0gZ2V0RGVwdGgodl92Y3RUZXh0dXJlICsgdmVjMih1X3ZjdFRleGVsLngsIDApKTtcclxuICBmbG9hdCBmRGVwdGhCb3R0b20gPSBnZXREZXB0aCh2X3ZjdFRleHR1cmUgKyB2ZWMyKDAsIC11X3ZjdFRleGVsLnkpKTtcclxuICBmbG9hdCBmRGVwdGhMZWZ0ID0gZ2V0RGVwdGgodl92Y3RUZXh0dXJlICsgdmVjMigtdV92Y3RUZXhlbC54LCAwKSk7XHJcblxyXG4gIGZsb2F0IGZEZXB0aE1pbiA9IG1pbihtaW4oZkRlcHRoVG9wLCBmRGVwdGhSaWdodCksIG1pbihmRGVwdGhCb3R0b20sIGZEZXB0aExlZnQpKTtcclxuICBmbG9hdCBmRGVwdGhEZWx0YSA9IGFicyhmRGVwdGggLSBmRGVwdGhNaW4pO1xyXG5cclxuICBpZiAoZkRlcHRoRGVsdGEgPT0gMC4wKVxyXG4gICAgZGlzY2FyZDtcclxuXHJcbiAgZmxvYXQgZkRlcHRoU2NlbmUgPSB0ZXh0dXJlKHVfdGV4RGVwdGhTY2VuZSwgdl92Y3RUZXh0dXJlKS5yO1xyXG4gIGlmIChmRGVwdGhNaW4gPCBmRGVwdGhTY2VuZSlcclxuICAgIHZjdEZyYWcgPSB1X3ZjdENvbG9yO1xyXG4gIGVsc2VcclxuICAgIHZjdEZyYWcgPSB1X3ZjdENvbG9yT2NjbHVkZWQ7XHJcbn1gO1xuICBzaGFkZXJTb3VyY2VzW1wiU2hhZGVyUGhvbmcuZnJhZ1wiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogUGhvbmcgc2hhZGluZ1xyXG4qIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIyIHwgUm9sYW5kIEhlZXIsIEhGVSwgMjAyMyB8IEpvbmFzIFBsb3R6a3ksIEhGVSwgMjAyM1xyXG4qL1xyXG5cclxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbnByZWNpc2lvbiBoaWdocCBpbnQ7XHJcblxyXG51bmlmb3JtIHZlYzQgdV92Y3RDb2xvcjtcclxudW5pZm9ybSBmbG9hdCB1X2ZEaWZmdXNlO1xyXG51bmlmb3JtIGZsb2F0IHVfZlNwZWN1bGFyO1xyXG51bmlmb3JtIGZsb2F0IHVfZkludGVuc2l0eTtcclxudW5pZm9ybSBmbG9hdCB1X2ZNZXRhbGxpYztcclxudW5pZm9ybSB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG5cclxudW5pZm9ybSBib29sIHVfYkZvZztcclxudW5pZm9ybSB2ZWM0IHVfdmN0Rm9nQ29sb3I7XHJcbnVuaWZvcm0gZmxvYXQgdV9mRm9nTmVhcjtcclxudW5pZm9ybSBmbG9hdCB1X2ZGb2dGYXI7XHJcblxyXG5pbiB2ZWM0IHZfdmN0Q29sb3I7XHJcbmluIHZlYzMgdl92Y3RQb3NpdGlvbjtcclxuXHJcbmxheW91dChsb2NhdGlvbiA9IDApIG91dCB2ZWM0IHZjdEZyYWc7XHJcbmxheW91dChsb2NhdGlvbiA9IDEpIG91dCB2ZWM0IHZjdEZyYWdQb3NpdGlvbjtcclxubGF5b3V0KGxvY2F0aW9uID0gMikgb3V0IHZlYzQgdmN0RnJhZ05vcm1hbDtcclxuXHJcbiNpZmRlZiBQSE9OR1xyXG5cclxuICBpbiB2ZWMzIHZfdmN0Tm9ybWFsO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWZkZWYgRkxBVFxyXG5cclxuICBmbGF0IGluIHZlYzMgdl92Y3RQb3NpdGlvbkZsYXQ7XHJcblxyXG4jZW5kaWZcclxuXHJcbnN0cnVjdCBMaWdodCB7XHJcbiAgdmVjNCB2Y3RDb2xvcjtcclxuICBtYXQ0IG10eFNoYXBlO1xyXG4gIG1hdDQgbXR4U2hhcGVJbnZlcnNlO1xyXG59O1xyXG5cclxuY29uc3QgdWludCBNQVhfTElHSFRTX0RJUkVDVElPTkFMID0gMTV1O1xyXG5jb25zdCB1aW50IE1BWF9MSUdIVFNfUE9JTlQgPSAxMDB1O1xyXG5jb25zdCB1aW50IE1BWF9MSUdIVFNfU1BPVCA9IDEwMHU7XHJcblxyXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIExpZ2h0cyB7XHJcbiAgdWludCB1X25MaWdodHNEaXJlY3Rpb25hbDtcclxuICB1aW50IHVfbkxpZ2h0c1BvaW50O1xyXG4gIHVpbnQgdV9uTGlnaHRzU3BvdDtcclxuICB1aW50IHBhZGRpbmc7IC8vIEFkZCBwYWRkaW5nIHRvIGFsaWduIHRvIDE2IGJ5dGVzXHJcbiAgTGlnaHQgdV9hbWJpZW50O1xyXG4gIExpZ2h0IHVfZGlyZWN0aW9uYWxbTUFYX0xJR0hUU19ESVJFQ1RJT05BTF07XHJcbiAgTGlnaHQgdV9wb2ludFtNQVhfTElHSFRTX1BPSU5UXTtcclxuICBMaWdodCB1X3Nwb3RbTUFYX0xJR0hUU19TUE9UXTtcclxufTtcclxuXHJcbi8vIFRFWFRVUkU6IGlucHV0IFVWcyBhbmQgdGV4dHVyZVxyXG4jaWZkZWYgVEVYVFVSRVxyXG5cclxuICBpbiB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleENvbG9yO1xyXG5cclxuI2VuZGlmXHJcblxyXG4vLyBOT1JNQUxNQVA6IGlucHV0IFVWcyBhbmQgdGV4dHVyZVxyXG4jaWZkZWYgTk9STUFMTUFQXHJcblxyXG4gIGluIHZlYzMgdl92Y3RUYW5nZW50O1xyXG4gIGluIHZlYzMgdl92Y3RCaXRhbmdlbnQ7XHJcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhOb3JtYWw7XHJcblxyXG4jZW5kaWZcclxuXHJcbi8vIFJldHVybnMgYSB2ZWN0b3IgZm9yIHZpc3VhbGl6aW5nIG9uIG1vZGVsLiBHcmVhdCBmb3IgZGVidWdnaW5nXHJcbnZlYzQgc2hvd1ZlY3RvckFzQ29sb3IodmVjMyBfdmVjdG9yLCBib29sIF9jbGFtcCkge1xyXG4gIGlmKF9jbGFtcCkge1xyXG4gICAgX3ZlY3RvciAqPSAwLjU7XHJcbiAgICBfdmVjdG9yICs9IDAuNTtcclxuICB9XHJcbiAgcmV0dXJuIHZlYzQoX3ZlY3Rvci54LCBfdmVjdG9yLnksIF92ZWN0b3IueiwgMSk7XHJcbn1cclxuXHJcbnZvaWQgaWxsdW1pbmF0ZURpcmVjdGVkKHZlYzMgX3ZjdERpcmVjdGlvbiwgdmVjMyBfdmN0VmlldywgdmVjMyBfdmN0Tm9ybWFsLCB2ZWMzIF92Y3RDb2xvciwgaW5vdXQgdmVjMyBfdmN0RGlmZnVzZSwgaW5vdXQgdmVjMyBfdmN0U3BlY3VsYXIpIHtcclxuICB2ZWMzIHZjdERpcmVjdGlvbiA9IG5vcm1hbGl6ZShfdmN0RGlyZWN0aW9uKTtcclxuICBmbG9hdCBmSWxsdW1pbmF0aW9uID0gLWRvdChfdmN0Tm9ybWFsLCB2Y3REaXJlY3Rpb24pO1xyXG4gIGlmKGZJbGx1bWluYXRpb24gPiAwLjApIHtcclxuICAgIF92Y3REaWZmdXNlICs9IHVfZkRpZmZ1c2UgKiBmSWxsdW1pbmF0aW9uICogX3ZjdENvbG9yO1xyXG5cclxuICAgIGlmKHVfZlNwZWN1bGFyIDw9IDAuMClcclxuICAgICAgcmV0dXJuO1xyXG4gICAgICBcclxuICAgIC8vQkxJTk4tUGhvbmcgU2hhZGluZ1xyXG4gICAgdmVjMyBoYWxmd2F5RGlyID0gbm9ybWFsaXplKC12Y3REaXJlY3Rpb24gLSBfdmN0Vmlldyk7XHJcbiAgICBmbG9hdCBmYWN0b3IgPSBtYXgoZG90KC12Y3REaXJlY3Rpb24sIF92Y3ROb3JtYWwpLCAwLjApOyAvL0ZhY3RvciBmb3Igc21vb3RoaW5nIG91dCB0cmFuc2l0aW9uIGZyb20gc3VyZmFjZSBmYWNpbmcgdGhlIGxpZ2h0c291cmNlIHRvIHN1cmZhY2UgZmFjaW5nIGF3YXkgZnJvbSB0aGUgbGlnaHRzb3VyY2VcclxuICAgIGZhY3RvciA9IDEuMCAtIChwb3coZmFjdG9yIC0gMS4wLCA4LjApKTsgICAgICAgICAgICAgICAgIC8vVGhlIGZhY3RvciBpcyBhbHRlcmVkIGluIG9yZGVyIHRvIGNsZWFybHkgc2VlIHRoZSBzcGVjdWxhciBoaWdobGlnaHQgZXZlbiBhdCBzdGVlcCBhbmdsZXMsIHdoaWxlIHN0aWxsIHByZXZlbnRpbmcgYXJ0aWZhY3RzXHJcblxyXG4gICAgX3ZjdFNwZWN1bGFyICs9IHBvdyhtYXgoZG90KF92Y3ROb3JtYWwsIGhhbGZ3YXlEaXIpLCAwLjApLCBleHAyKHVfZlNwZWN1bGFyICogNS4wKSkgKiB1X2ZTcGVjdWxhciAqIHVfZkludGVuc2l0eSAqIGZhY3RvciAqIF92Y3RDb2xvcjtcclxuICB9XHJcbn1cclxuXHJcbmZsb2F0IGdldEZvZyh2ZWMzIF92Y3RQb3NpdGlvbikge1xyXG4gIGZsb2F0IGZEaXN0YW5jZSA9IGxlbmd0aChfdmN0UG9zaXRpb24gLSB1X3ZjdENhbWVyYSk7IC8vIG1heWJlIHVzZSB6LWRlcHRoIGluc3RlYWQgb2YgZXVjbGlkZWFuIGRlcHRoXHJcbiAgZmxvYXQgZkZvZyA9IGNsYW1wKChmRGlzdGFuY2UgLSB1X2ZGb2dOZWFyKSAvICh1X2ZGb2dGYXIgLSB1X2ZGb2dOZWFyKSwgMC4wLCAxLjApO1xyXG4gIGZGb2cgPSAtcG93KGZGb2csIDIuMCkgKyAoMi4wICogZkZvZyk7IC8vIGxldHMgZm9nIGFwcGVhciBxdWlja2VyIGFuZCBmYWxsIG9mZiBzbG93ZXIgcmVzdWx0cyBpbiBhIG1vcmUgZ3JhZHVhbCBmYWxsb2ZmXHJcbiAgcmV0dXJuIGZGb2c7XHJcbn1cclxuXHJcbnZvaWQgbWFpbigpIHtcclxuICAjaWYgZGVmaW5lZChQSE9ORykgJiYgIWRlZmluZWQoRkxBVClcclxuXHJcbiAgICAjaWZkZWYgTk9STUFMTUFQXHJcblxyXG4gICAgICBtYXQzIG10eFRCTiA9IG1hdDMobm9ybWFsaXplKHZfdmN0VGFuZ2VudCksIG5vcm1hbGl6ZSh2X3ZjdEJpdGFuZ2VudCksIG5vcm1hbGl6ZSh2X3ZjdE5vcm1hbCkpO1xyXG4gICAgICB2ZWMzIHZjdE5vcm1hbCA9IHRleHR1cmUodV90ZXhOb3JtYWwsIHZfdmN0VGV4dHVyZSkueHl6ICogMi4wIC0gMS4wO1xyXG4gICAgICB2Y3ROb3JtYWwgPSBub3JtYWxpemUobXR4VEJOICogdmN0Tm9ybWFsKTtcclxuXHJcbiAgICAjZWxzZVxyXG5cclxuICAgICAgdmVjMyB2Y3ROb3JtYWwgPSBub3JtYWxpemUodl92Y3ROb3JtYWwpO1xyXG5cclxuICAgICNlbmRpZlxyXG5cclxuICAgIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZSh2X3ZjdFBvc2l0aW9uIC0gdV92Y3RDYW1lcmEpO1xyXG4gICAgdmVjMyB2Y3RQb3NpdGlvbiA9IHZfdmN0UG9zaXRpb247XHJcblxyXG4gICNlbmRpZlxyXG5cclxuICAjaWZkZWYgRkxBVFxyXG5cclxuICAgIHZlYzMgdmN0RmR4ID0gZEZkeCh2X3ZjdFBvc2l0aW9uKTtcclxuICAgIHZlYzMgdmN0RmR5ID0gZEZkeSh2X3ZjdFBvc2l0aW9uKTtcclxuICAgIHZlYzMgdmN0Tm9ybWFsID0gbm9ybWFsaXplKGNyb3NzKHZjdEZkeCwgdmN0RmR5KSk7XHJcbiAgICB2ZWMzIHZjdFZpZXcgPSBub3JtYWxpemUodl92Y3RQb3NpdGlvbkZsYXQgLSB1X3ZjdENhbWVyYSk7XHJcbiAgICB2ZWMzIHZjdFBvc2l0aW9uID0gdl92Y3RQb3NpdGlvbkZsYXQ7XHJcblxyXG4gICNlbmRpZlxyXG5cclxuICB2ZWMzIHZjdERpZmZ1c2UgPSB1X2ZEaWZmdXNlICogdV9hbWJpZW50LnZjdENvbG9yLnJnYjtcclxuICB2ZWMzIHZjdFNwZWN1bGFyID0gdmVjMygwLCAwLCAwKTtcclxuXHJcbiAgLy8gY2FsY3VsYXRlIGRpcmVjdGlvbmFsIGxpZ2h0IGVmZmVjdFxyXG4gIGZvcih1aW50IGkgPSAwdTsgaSA8IHVfbkxpZ2h0c0RpcmVjdGlvbmFsOyBpKyspIHtcclxuICAgIHZlYzMgdmN0RGlyZWN0aW9uID0gdmVjMyh1X2RpcmVjdGlvbmFsW2ldLm10eFNoYXBlICogdmVjNCgwLjAsIDAuMCwgMS4wLCAxLjApKTtcclxuICAgIGlsbHVtaW5hdGVEaXJlY3RlZCh2Y3REaXJlY3Rpb24sIHZjdFZpZXcsIHZjdE5vcm1hbCwgdV9kaXJlY3Rpb25hbFtpXS52Y3RDb2xvci5yZ2IsIHZjdERpZmZ1c2UsIHZjdFNwZWN1bGFyKTtcclxuICB9XHJcblxyXG4gIC8vIGNhbGN1bGF0ZSBwb2ludCBsaWdodCBlZmZlY3RcclxuICBmb3IodWludCBpID0gMHU7IGkgPCB1X25MaWdodHNQb2ludDsgaSsrKSB7XHJcbiAgICB2ZWMzIHZjdFBvc2l0aW9uTGlnaHQgPSB2ZWMzKHVfcG9pbnRbaV0ubXR4U2hhcGUgKiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCkpO1xyXG4gICAgdmVjMyB2Y3REaXJlY3Rpb24gPSB2Y3RQb3NpdGlvbiAtIHZjdFBvc2l0aW9uTGlnaHQ7XHJcbiAgICBmbG9hdCBmSW50ZW5zaXR5ID0gMS4wIC0gbGVuZ3RoKG1hdDModV9wb2ludFtpXS5tdHhTaGFwZUludmVyc2UpICogdmN0RGlyZWN0aW9uKTtcclxuICAgIGlmKGZJbnRlbnNpdHkgPCAwLjApXHJcbiAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgIGlsbHVtaW5hdGVEaXJlY3RlZCh2Y3REaXJlY3Rpb24sIHZjdFZpZXcsIHZjdE5vcm1hbCwgdV9wb2ludFtpXS52Y3RDb2xvci5yZ2IgKiBmSW50ZW5zaXR5LCB2Y3REaWZmdXNlLCB2Y3RTcGVjdWxhcik7XHJcbiAgfVxyXG5cclxuICAvLyBjYWxjdWxhdGUgc3BvdCBsaWdodCBlZmZlY3RcclxuICBmb3IodWludCBpID0gMHU7IGkgPCB1X25MaWdodHNTcG90OyBpKyspIHtcclxuICAgIHZlYzMgdmN0UG9zaXRpb25MaWdodCA9IHZlYzModV9zcG90W2ldLm10eFNoYXBlICogdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApKTtcclxuICAgIHZlYzMgdmN0RGlyZWN0aW9uID0gdmN0UG9zaXRpb24gLSB2Y3RQb3NpdGlvbkxpZ2h0O1xyXG4gICAgdmVjMyB2Y3REaXJlY3Rpb25JbnZlcnRlZCA9IG1hdDModV9zcG90W2ldLm10eFNoYXBlSW52ZXJzZSkgKiB2Y3REaXJlY3Rpb247XHJcbiAgICBpZih2Y3REaXJlY3Rpb25JbnZlcnRlZC56IDw9IDAuMClcclxuICAgICAgY29udGludWU7XHJcblxyXG4gICAgZmxvYXQgZkludGVuc2l0eSA9IDEuMCAtIG1pbigxLjAsIDIuMCAqIGxlbmd0aCh2Y3REaXJlY3Rpb25JbnZlcnRlZC54eSkgLyB2Y3REaXJlY3Rpb25JbnZlcnRlZC56KTsgICAgLy9Db25lc2hhcGUgdGhhdCBpcyBicmlnaHRlc3QgaW4gdGhlIGNlbnRlci4gUG9zc2libGUgVE9ETzogXCJWYXJpYWJsZSBTcG90bGlnaHRzb2Z0bmVzc1wiXHJcbiAgICBmSW50ZW5zaXR5ICo9IDEuMCAtIHBvdyh2Y3REaXJlY3Rpb25JbnZlcnRlZC56LCAyLjApOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1ByZXZlbnRzIGhhcnNoIGxpZ2h0aW5nIGFydGlmYWN0cyBhdCBib3VuZGFyeSBvZiB0aGUgZ2l2ZW4gc3BvdGxpZ2h0XHJcbiAgICBpZihmSW50ZW5zaXR5IDwgMC4wKVxyXG4gICAgICBjb250aW51ZTtcclxuXHJcbiAgICBpbGx1bWluYXRlRGlyZWN0ZWQodmN0RGlyZWN0aW9uLCB2Y3RWaWV3LCB2Y3ROb3JtYWwsIHVfc3BvdFtpXS52Y3RDb2xvci5yZ2IgKiBmSW50ZW5zaXR5LCB2Y3REaWZmdXNlLCB2Y3RTcGVjdWxhcik7XHJcbiAgfVxyXG5cclxuICB2Y3RGcmFnLnJnYiA9IHZjdERpZmZ1c2UgKyB2Y3RTcGVjdWxhciAqIHVfZk1ldGFsbGljO1xyXG4gIHZjdEZyYWcuYSA9IDEuMDtcclxuXHJcbiAgI2lmZGVmIFRFWFRVUkVcclxuXHJcbiAgICB2ZWM0IHZjdENvbG9yVGV4dHVyZSA9IHRleHR1cmUodV90ZXhDb2xvciwgdl92Y3RUZXh0dXJlKTtcclxuICAgIHZjdEZyYWcgKj0gdmN0Q29sb3JUZXh0dXJlO1xyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgdmN0RnJhZyAqPSB1X3ZjdENvbG9yICogdl92Y3RDb2xvcjtcclxuICB2Y3RGcmFnLnJnYiArPSB2Y3RTcGVjdWxhciAqICgxLjAgLSB1X2ZNZXRhbGxpYyk7XHJcblxyXG4gIHZjdEZyYWdQb3NpdGlvbiA9IHZlYzQodl92Y3RQb3NpdGlvbiwgMS4wKTsgLy8gZG9uJ3QgdXNlIGZsYXQgaGVyZSwgYmVjYXVzZSB3ZSB3YW50IHRvIGludGVycG9sYXRlIHRoZSBwb3NpdGlvblxyXG4gIHZjdEZyYWdOb3JtYWwgPSB2ZWM0KHZjdE5vcm1hbCwgMS4wKTtcclxuXHJcbiAgaWYgKHVfYkZvZykgXHJcbiAgICB2Y3RGcmFnLnJnYiA9IG1peCh2Y3RGcmFnLnJnYiwgdV92Y3RGb2dDb2xvci5yZ2IsIGdldEZvZyh2Y3RQb3NpdGlvbikgKiB1X3ZjdEZvZ0NvbG9yLmEpO1xyXG5cclxuICB2Y3RGcmFnLnJnYiAqPSB2Y3RGcmFnLmE7XHJcblxyXG4gIGlmKHZjdEZyYWcuYSA8IDAuMDEpXHJcbiAgICBkaXNjYXJkO1xyXG59YDtcbiAgc2hhZGVyU291cmNlc1tcIlNoYWRlclBpY2suZnJhZ1wiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogUmVuZGVycyBmb3IgUmF5Y2FzdGluZ1xyXG4qIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiovXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5wcmVjaXNpb24gaGlnaHAgaW50O1xyXG5cclxudW5pZm9ybSBpbnQgdV9pZDtcclxudW5pZm9ybSBpbnQgdV9zaXplO1xyXG51bmlmb3JtIHZlYzQgdV92Y3RDb2xvcjtcclxub3V0IGl2ZWM0IHZjdEZyYWc7XHJcblxyXG4jaWYgZGVmaW5lZChURVhUVVJFKVxyXG5cclxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleENvbG9yO1xyXG4gIGluIHZlYzIgdl92Y3RUZXh0dXJlO1xyXG5cclxuI2VuZGlmXHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgaW50IHBpeGVsID0gaW50KGdsX0ZyYWdDb29yZC54KSArIHVfc2l6ZSAqIGludChnbF9GcmFnQ29vcmQueSk7XHJcblxyXG4gIGlmIChwaXhlbCAhPSB1X2lkKVxyXG4gICAgZGlzY2FyZDtcclxuICBcclxuICB2ZWM0IHZjdENvbG9yID0gdV92Y3RDb2xvcjtcclxuICBcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKVxyXG5cclxuICAgIHZjdENvbG9yICo9IHRleHR1cmUodV90ZXhDb2xvciwgdl92Y3RUZXh0dXJlKTtcclxuXHJcbiAgI2VuZGlmXHJcblxyXG4gIHVpbnQgaWNvbG9yID0gdWludCh2Y3RDb2xvci5yICogMjU1LjApIDw8IDI0IHwgdWludCh2Y3RDb2xvci5nICogMjU1LjApIDw8IDE2IHwgdWludCh2Y3RDb2xvci5iICogMjU1LjApIDw8IDggfCB1aW50KHZjdENvbG9yLmEgKiAyNTUuMCk7XHJcbiAgXHJcbiAgdmN0RnJhZyA9IGl2ZWM0KGZsb2F0Qml0c1RvSW50KGdsX0ZyYWdDb29yZC56KSwgaWNvbG9yLCAwLCAwKTtcclxuXHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuXHJcbiAgICB2Y3RGcmFnLmIgPSBmbG9hdEJpdHNUb0ludCh2X3ZjdFRleHR1cmUueCk7XHJcbiAgICB2Y3RGcmFnLmEgPSBmbG9hdEJpdHNUb0ludCh2X3ZjdFRleHR1cmUueSk7XHJcblxyXG4gICNlbmRpZlxyXG59YDtcbiAgc2hhZGVyU291cmNlc1tcIlNoYWRlclBpY2sudmVydFwiXSA9IC8qZ2xzbCovIGAjdmVyc2lvbiAzMDAgZXNcclxuLyoqXHJcbiogUmVuZGVycyBmb3IgUmF5Y2FzdGluZ1xyXG4qIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiovXHJcbnVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkOyAvLyB1X210eE1vZGVsXHJcblxyXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENhbWVyYSB7XHJcbiAgbWF0NCB1X210eFdvcmxkVG9DYW1lcmE7IC8vIHVfbXR4Vmlld1xyXG4gIG1hdDQgdV9tdHhQcm9qZWN0aW9uOyBcclxuICBtYXQ0IHVfbXR4V29ybGRUb1ZpZXc7IC8vIHVfbXR4Vmlld1Byb2plY3Rpb25cclxuICB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG59O1xyXG5cclxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjMyBhX3ZjdFBvc2l0aW9uO1xyXG5cclxuI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuXHJcbiAgbGF5b3V0KGxvY2F0aW9uID0gMikgaW4gdmVjMiBhX3ZjdFRleHR1cmU7XHJcbiAgb3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG5cclxuI2VuZGlmXHJcblxyXG52b2lkIG1haW4oKSB7XHJcbiAgZ2xfUG9zaXRpb24gPSB1X210eFdvcmxkVG9WaWV3ICogdV9tdHhNZXNoVG9Xb3JsZCAqIHZlYzQoYV92Y3RQb3NpdGlvbiwgMS4wKTtcclxuXHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSlcclxuXHJcbiAgICB2X3ZjdFRleHR1cmUgPSBhX3ZjdFRleHR1cmU7XHJcblxyXG4gICNlbmRpZlxyXG59YDtcbiAgc2hhZGVyU291cmNlc1tcIlNoYWRlclNjcmVlbi52ZXJ0XCJdID0gLypnbHNsKi8gYCN2ZXJzaW9uIDMwMCBlc1xyXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxucHJlY2lzaW9uIGhpZ2hwIGludDtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBmdWxsc2NyZWVuIHRyaWFuZ2xlIHdoaWNoIGNvdGFpbnMgdGhlIHNjcmVlbiBxdWFkIGFuZCBzZXRzIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFjY29yZGluZ2x5LlxyXG4gKiBAYXV0aG9ycyBSb2xhbmQgSGVlciwgSEZVLCAyMDIzIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjMgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjNcclxuICpcclxuICogIDIgIDMgLlxyXG4gKiAgICAgICAuICAuXHJcbiAqICAgICAgIC4gICAgIC4gIFxyXG4gKiAgICAgICAuICAgICAgICAuXHJcbiAqICAxICAxIC4uLi4uLi4uLi4gIC5cclxuICogICAgICAgLiBzY3JlZW4gLiAgICAgLlxyXG4gKiAgICAgICAuICBxdWFkICAuICAgICAgICAuXHJcbiAqICAwIC0xIC4uLi4uLi4uLi4gIC4gIC4gIC4gIC5cclxuICogICAgcCAtMSAgICAgICAgMSAgICAgICAgICAgM1xyXG4gKiAgdCAgICAwICAgICAgICAxICAgICAgICAgICAyXHJcbiAqICBcclxuICogIHAgPT0gcG9zdGlvblxyXG4gKiAgdCA9PSB0ZXh0dXJlIGNvb3JkaW5hdGVcclxuICovXHJcblxyXG4vLyB1bmlmb3JtIHZlYzIgdV92Y3RSZXNvbHV0aW9uO1xyXG5cclxub3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG5cclxuLy8gI2lmZGVmIFNBTVBMRVxyXG5cclxuLy8gICBmbGF0IG91dCB2ZWMyWzldIHZfdmN0T2Zmc2V0cztcclxuXHJcbi8vICNlbmRpZlxyXG5cclxudm9pZCBtYWluKCkge1xyXG4gIGZsb2F0IHggPSBmbG9hdCgoZ2xfVmVydGV4SUQgJSAyKSAqIDQpOyAvLyAwLCA0LCAwXHJcbiAgZmxvYXQgeSA9IGZsb2F0KChnbF9WZXJ0ZXhJRCAvIDIpICogNCk7IC8vIDAsIDAsIDRcclxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoeCAtIDEuMCwgeSAtIDEuMCwgMC4wLCAxLjApOyAvLyAoLTEsIC0xKSwgKDMsIC0xKSwgKC0xLCAzKVxyXG4gIHZfdmN0VGV4dHVyZSA9IHZlYzIoeCAvIDIuMCwgeSAvIDIuMCk7ICAvLyAoMCwgMCksICgyLCAwKSwgKDAsIDIpIC0+IGludGVycG9sYXRpb24gd2lsbCB5aWVsZCAoMCwgMCksICgxLCAwKSwgKDAsIDEpIGFzIHRoZSBwb3NpdGlvbnMgYXJlIGRvdWJsZSB0aGUgc2l6ZSBvZiB0aGUgc2NyZWVuXHJcblxyXG4gIC8vICNpZmRlZiBTQU1QTEVcclxuXHJcbiAgLy8gICB2ZWMyIG9mZnNldCA9IHZlYzIoMS4wIC8gdV92Y3RSZXNvbHV0aW9uLngsIDEuMCAvIHVfdmN0UmVzb2x1dGlvbi55KTtcclxuICAvLyAgIHZfdmN0T2Zmc2V0cyA9IHZlYzJbXShcclxuICAvLyAgICAgdmVjMigtb2Zmc2V0LngsIG9mZnNldC55KSwgIHZlYzIoMC4wLCBvZmZzZXQueSksICB2ZWMyKG9mZnNldC54LCBvZmZzZXQueSksXHJcbiAgLy8gICAgIHZlYzIoLW9mZnNldC54LCAwLjApLCAgICAgICB2ZWMyKDAuMCwgMC4wKSwgICAgICAgdmVjMihvZmZzZXQueCwgMC4wKSxcclxuICAvLyAgICAgdmVjMigtb2Zmc2V0LngsIC1vZmZzZXQueSksIHZlYzIoMC4wLCAtb2Zmc2V0LnkpLCAgdmVjMihvZmZzZXQueCwgLW9mZnNldC55KVxyXG4gIC8vICAgKTtcclxuXHJcbiAgLy8gI2VuZGlmXHJcbn1gO1xuICBzaGFkZXJTb3VyY2VzW1wiU2hhZGVyVW5pdmVyc2FsLmZyYWdcIl0gPSAvKmdsc2wqLyBgI3ZlcnNpb24gMzAwIGVzXHJcbi8qKlxyXG4qIFVuaXZlcnNhbCBTaGFkZXIgYXMgYmFzZSBmb3IgbWFueSBvdGhlcnMuIENvbnRyb2xsZWQgYnkgY29tcGlsZXIgZGlyZWN0aXZlc1xyXG4qIEBhdXRob3JzIEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDIxIHwgSm9uYXMgUGxvdHpreSwgSEZVLCAyMDIzXHJcbiovXHJcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG5wcmVjaXNpb24gaGlnaHAgaW50O1xyXG5cclxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBOb2RlIHtcclxuICB1bmlmb3JtIG1hdDQgdV9tdHhNZXNoVG9Xb3JsZDsgLy8gdV9tdHhNb2RlbFxyXG4gIHVuaWZvcm0gbWF0MyB1X210eFBpdm90OyAvLyB0ZXh0dXJlIHBpdm90IG1hdHJpeFxyXG4gIHVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yUHJpbWFyeTsgLy8gY29tcG9uZW50IG1hdGVyaWFsIGNvbG9yXHJcblxyXG4gIHVuaWZvcm0gdWludCB1X2lCbGVuZE1vZGU7XHJcbiAgdW5pZm9ybSBmbG9hdCB1X2ZQYXJ0aWNsZVN5c3RlbUR1cmF0aW9uO1xyXG4gIHVuaWZvcm0gZmxvYXQgdV9mUGFydGljbGVTeXN0ZW1TaXplO1xyXG4gIHVuaWZvcm0gZmxvYXQgdV9mUGFydGljbGVTeXN0ZW1UaW1lO1xyXG5cclxuICB1bmlmb3JtIGJvb2wgdV9iRmFjZUNhbWVyYUFjdGl2ZTtcclxuICB1bmlmb3JtIGJvb2wgdV9iRmFjZUNhbWVyYVJlc3RyaWN0O1xyXG59O1xyXG5cclxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBDYW1lcmEge1xyXG4gIG1hdDQgdV9tdHhXb3JsZFRvQ2FtZXJhOyAvLyB1X210eFZpZXdcclxuICBtYXQ0IHVfbXR4UHJvamVjdGlvbjsgXHJcbiAgbWF0NCB1X210eFdvcmxkVG9WaWV3OyAvLyB1X210eFZpZXdQcm9qZWN0aW9uXHJcbiAgdmVjMyB1X3ZjdENhbWVyYTtcclxufTtcclxuXHJcbmxheW91dChzdGQxNDApIHVuaWZvcm0gTWF0ZXJpYWwge1xyXG4gIHVuaWZvcm0gdmVjNCB1X3ZjdENvbG9yO1xyXG5cclxuICB1bmlmb3JtIGZsb2F0IHVfZkRpZmZ1c2U7XHJcbiAgdW5pZm9ybSBmbG9hdCB1X2ZTcGVjdWxhcjtcclxuICB1bmlmb3JtIGZsb2F0IHVfZkludGVuc2l0eTtcclxuICB1bmlmb3JtIGZsb2F0IHVfZk1ldGFsbGljO1xyXG5cclxuICB1bmlmb3JtIGZsb2F0IHVfZkFscGhhQ2xpcDtcclxufTtcclxuXHJcbmxheW91dChzdGQxNDApIHVuaWZvcm0gRm9nIHtcclxuICBib29sIHVfYkZvZ0FjdGl2ZTtcclxuICBmbG9hdCB1X2ZGb2dOZWFyO1xyXG4gIGZsb2F0IHVfZkZvZ0ZhcjtcclxuICBmbG9hdCBmb2dQYWRkaW5nOyAvLyBhZGQgcGFkZGluZyB0byBhbGlnbiB0byAxNiBieXRlc1xyXG4gIHZlYzQgdV92Y3RGb2dDb2xvcjtcclxufTtcclxuXHJcbmluIHZlYzMgdl92Y3RQb3NpdGlvbjtcclxuaW4gdmVjNCB2X3ZjdENvbG9yO1xyXG5cclxubGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzQgdmN0RnJhZztcclxubGF5b3V0KGxvY2F0aW9uID0gMSkgb3V0IHZlYzQgdmN0RnJhZ1Bvc2l0aW9uOyAvLyBUT0RPOiBtYWtlIHRoZXNlIG9wdGlvbmFsP1xyXG5sYXlvdXQobG9jYXRpb24gPSAyKSBvdXQgdmVjNCB2Y3RGcmFnTm9ybWFsO1xyXG5cclxuI2lmIGRlZmluZWQoRkxBVCkgfHwgZGVmaW5lZChHT1VSQVVEKSB8fCBkZWZpbmVkKFBIT05HKVxyXG5cclxuICBpbiB2ZWMzIHZfdmN0Tm9ybWFsO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWYgZGVmaW5lZChGTEFUKVxyXG5cclxuICBmbGF0IGluIHZlYzMgdl92Y3RQb3NpdGlvbkZsYXQ7XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZiBkZWZpbmVkKEdPVVJBVUQpXHJcblxyXG4gIGluIHZlYzMgdl92Y3REaWZmdXNlO1xyXG4gIGluIHZlYzMgdl92Y3RTcGVjdWxhcjtcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmIGRlZmluZWQoVE9PTilcclxuXHJcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXhUb29uO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWYgZGVmaW5lZChQSE9ORykgfHwgZGVmaW5lZChGTEFUKVxyXG5cclxuICBzdHJ1Y3QgTGlnaHQge1xyXG4gICAgdmVjNCB2Y3RDb2xvcjtcclxuICAgIG1hdDQgbXR4U2hhcGU7XHJcbiAgICBtYXQ0IG10eFNoYXBlSW52ZXJzZTtcclxuICB9O1xyXG5cclxuICAjZGVmaW5lIE1BWF9MSUdIVFNfRElSRUNUSU9OQUwgMTV1XHJcbiAgI2RlZmluZSBNQVhfTElHSFRTX1BPSU5UIDEwMHVcclxuICAjZGVmaW5lIE1BWF9MSUdIVFNfU1BPVCAxMDB1XHJcblxyXG4gIGxheW91dChzdGQxNDApIHVuaWZvcm0gTGlnaHRzIHsgLy8gVE9ETzogcHV0IGFtYmllbnQgY29sb3IgaW4gaGVhZGVyXHJcbiAgICB1aW50IHVfbkxpZ2h0c0RpcmVjdGlvbmFsO1xyXG4gICAgdWludCB1X25MaWdodHNQb2ludDtcclxuICAgIHVpbnQgdV9uTGlnaHRzU3BvdDtcclxuICAgIHZlYzQgdV92Y3RBbWJpZW50Q29sb3I7IFxyXG5cclxuICAgIExpZ2h0IHVfZGlyZWN0aW9uYWxbTUFYX0xJR0hUU19ESVJFQ1RJT05BTF07XHJcbiAgICBMaWdodCB1X3BvaW50W01BWF9MSUdIVFNfUE9JTlRdO1xyXG4gICAgTGlnaHQgdV9zcG90W01BWF9MSUdIVFNfU1BPVF07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogX3ZjdExpZ2h0OiBkaXJlY3Rpb24gZnJvbSBwb3NpdGlvbiB0byBsaWdodFxyXG4gICAqIF92Y3RWaWV3OiBkaXJlY3Rpb24gZnJvbSBwb3NpdGlvbiB0byBjYW1lcmFcclxuICAgKiBfdmN0Tm9ybWFsOiBzdXJmYWNlIG5vcm1hbCBhdCBwb3NpdGlvblxyXG4gICAqIF92Y3RDb2xvcjogY29sb3Igb2YgdGhlIGxpZ2h0XHJcbiAgICovXHJcbiAgdm9pZCBpbGx1bWluYXRlRGlyZWN0ZWQodmVjMyBfdmN0TGlnaHREaXJlY3Rpb24sIHZlYzMgX3ZjdFZpZXdEaXJlY3Rpb24sIHZlYzMgX3ZjdE5vcm1hbCwgdmVjMyBfdmN0Q29sb3IsIGlub3V0IHZlYzMgX3ZjdERpZmZ1c2UsIGlub3V0IHZlYzMgX3ZjdFNwZWN1bGFyKSB7XHJcbiAgICB2ZWMzIHZjdExpZ2h0RGlyZWN0aW9uID0gbm9ybWFsaXplKF92Y3RMaWdodERpcmVjdGlvbik7XHJcblxyXG4gICAgZmxvYXQgZkRpZmZ1c2UgPSBkb3QoX3ZjdE5vcm1hbCwgdmN0TGlnaHREaXJlY3Rpb24pO1xyXG5cclxuICAgIGlmKGZEaWZmdXNlID4gMC4wKSB7XHJcblxyXG4gICAgICAjaWYgZGVmaW5lZChUT09OKVxyXG4gICAgICBcclxuICAgICAgICBmRGlmZnVzZSA9IHRleHR1cmUodV90ZXhUb29uLCB2ZWMyKGZEaWZmdXNlLCAwKSkucjtcclxuXHJcbiAgICAgICNlbmRpZlxyXG5cclxuICAgICAgX3ZjdERpZmZ1c2UgKz0gdV9mRGlmZnVzZSAqIGZEaWZmdXNlICogX3ZjdENvbG9yO1xyXG5cclxuICAgICAgaWYodV9mU3BlY3VsYXIgPD0gMC4wIHx8IHVfZkludGVuc2l0eSA8PSAwLjApXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBcclxuICAgICAgLy9CTElOTi1QaG9uZyBTaGFkaW5nXHJcbiAgICAgIHZlYzMgaGFsZndheURpciA9IG5vcm1hbGl6ZSh2Y3RMaWdodERpcmVjdGlvbiArIF92Y3RWaWV3RGlyZWN0aW9uKTtcclxuICAgICAgZmxvYXQgZmFjdG9yID0gZkRpZmZ1c2U7ICAgICAgICAgICAgICAgICAgLy8gRmFjdG9yIGZvciBzbW9vdGhpbmcgb3V0IHRyYW5zaXRpb24gZnJvbSBzdXJmYWNlIGZhY2luZyB0aGUgbGlnaHRzb3VyY2UgdG8gc3VyZmFjZSBmYWNpbmcgYXdheSBmcm9tIHRoZSBsaWdodHNvdXJjZVxyXG4gICAgICBmYWN0b3IgPSAxLjAgLSAocG93KGZhY3RvciAtIDEuMCwgOC4wKSk7ICAvLyBUaGUgZmFjdG9yIGlzIGFsdGVyZWQgaW4gb3JkZXIgdG8gY2xlYXJseSBzZWUgdGhlIHNwZWN1bGFyIGhpZ2hsaWdodCBldmVuIGF0IHN0ZWVwIGFuZ2xlcywgd2hpbGUgc3RpbGwgcHJldmVudGluZyBhcnRpZmFjdHNcclxuXHJcbiAgICAgIGZsb2F0IGZTcGVjdWxhciA9IHBvdyhtYXgoZG90KF92Y3ROb3JtYWwsIGhhbGZ3YXlEaXIpLCAwLjApLCBleHAyKHVfZlNwZWN1bGFyICogNS4wKSkgKiBmYWN0b3I7IC8vIFRPRE86IHJlbW92ZSBtYWdpYyBudW1iZXJzP1xyXG5cclxuICAgICAgI2lmIGRlZmluZWQoVE9PTilcclxuICAgICAgICBcclxuICAgICAgICBmU3BlY3VsYXIgPSB0ZXh0dXJlKHVfdGV4VG9vbiwgdmVjMihmU3BlY3VsYXIsIDAuMCkpLmcgKiBmRGlmZnVzZTtcclxuXHJcbiAgICAgICNlbmRpZlxyXG5cclxuICAgICAgX3ZjdFNwZWN1bGFyICs9IGZTcGVjdWxhciAqIHVfZkludGVuc2l0eSAqIF92Y3RDb2xvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZiBkZWZpbmVkKFRFWFRVUkUpIHx8IGRlZmluZWQoTUFUQ0FQKVxyXG5cclxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleENvbG9yO1xyXG4gIGluIHZlYzIgdl92Y3RUZXh0dXJlO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWYgZGVmaW5lZChOT1JNQUxNQVApXHJcblxyXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4Tm9ybWFsO1xyXG4gIGluIHZlYzMgdl92Y3RUYW5nZW50O1xyXG4gIGluIHZlYzMgdl92Y3RCaXRhbmdlbnQ7XHJcblxyXG4jZW5kaWZcclxuXHJcbmZsb2F0IGdldEZvZyh2ZWMzIF92Y3RQb3NpdGlvbikge1xyXG4gIGZsb2F0IGZEaXN0YW5jZSA9IGxlbmd0aChfdmN0UG9zaXRpb24gLSB1X3ZjdENhbWVyYSk7IC8vIG1heWJlIHVzZSB6LWRlcHRoIGluc3RlYWQgb2YgZXVjbGlkZWFuIGRlcHRoXHJcbiAgZmxvYXQgZkZvZyA9IGNsYW1wKChmRGlzdGFuY2UgLSB1X2ZGb2dOZWFyKSAvICh1X2ZGb2dGYXIgLSB1X2ZGb2dOZWFyKSwgMC4wLCAxLjApO1xyXG4gIGZGb2cgPSAtcG93KGZGb2csIDIuMCkgKyAoMi4wICogZkZvZyk7IC8vIGxldHMgZm9nIGFwcGVhciBxdWlja2VyIGFuZCBmYWxsIG9mZiBzbG93ZXIgcmVzdWx0cyBpbiBhIG1vcmUgZ3JhZHVhbCBmYWxsb2ZmXHJcbiAgcmV0dXJuIGZGb2cgKiB1X3ZjdEZvZ0NvbG9yLmE7XHJcbn1cclxuXHJcbnZvaWQgbWFpbigpIHtcclxuXHJcbiAgI2lmIGRlZmluZWQoRkxBVClcclxuXHJcbiAgICB2ZWMzIHZjdEZkeCA9IGRGZHgodl92Y3RQb3NpdGlvbik7XHJcbiAgICB2ZWMzIHZjdEZkeSA9IGRGZHkodl92Y3RQb3NpdGlvbik7XHJcbiAgICB2ZWMzIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShjcm9zcyh2Y3RGZHgsIHZjdEZkeSkpO1xyXG4gICAgdmVjMyB2Y3RWaWV3RGlyZWN0aW9uID0gbm9ybWFsaXplKHVfdmN0Q2FtZXJhIC0gdl92Y3RQb3NpdGlvbkZsYXQpO1xyXG4gICAgdmVjMyB2Y3RQb3NpdGlvbiA9IHZfdmN0UG9zaXRpb25GbGF0O1xyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIChkZWZpbmVkKFBIT05HKSB8fCBkZWZpbmVkKEdPVVJBVUQpKSAmJiAhZGVmaW5lZChOT1JNQUxNQVApXHJcblxyXG4gICAgdmVjMyB2Y3ROb3JtYWwgPSBub3JtYWxpemUodl92Y3ROb3JtYWwpO1xyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoUEhPTkcpXHJcblxyXG4gICAgdmVjMyB2Y3RWaWV3RGlyZWN0aW9uID0gbm9ybWFsaXplKHVfdmN0Q2FtZXJhIC0gdl92Y3RQb3NpdGlvbik7XHJcbiAgICB2ZWMzIHZjdFBvc2l0aW9uID0gdl92Y3RQb3NpdGlvbjtcclxuXHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKE5PUk1BTE1BUClcclxuXHJcbiAgICBtYXQzIG10eFRCTiA9IG1hdDMobm9ybWFsaXplKHZfdmN0VGFuZ2VudCksIG5vcm1hbGl6ZSh2X3ZjdEJpdGFuZ2VudCksIG5vcm1hbGl6ZSh2X3ZjdE5vcm1hbCkpO1xyXG4gICAgdmVjMyB2Y3ROb3JtYWwgPSB0ZXh0dXJlKHVfdGV4Tm9ybWFsLCB2X3ZjdFRleHR1cmUpLnh5eiAqIDIuMCAtIDEuMDtcclxuICAgIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZShtdHhUQk4gKiB2Y3ROb3JtYWwpO1xyXG5cclxuICAjZW5kaWZcclxuICBcclxuICAjaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKFBIT05HKVxyXG5cclxuICAgIHZlYzMgdmN0RGlmZnVzZSA9IHVfZkRpZmZ1c2UgKiB1X3ZjdEFtYmllbnRDb2xvci5yZ2I7XHJcbiAgICB2ZWMzIHZjdFNwZWN1bGFyID0gdmVjMygwLCAwLCAwKTtcclxuXHJcbiAgICAvLyBkaXJlY3Rpb25hbCBsaWdodHNcclxuICAgIGZvcih1aW50IGkgPSAwdTsgaSA8IHVfbkxpZ2h0c0RpcmVjdGlvbmFsOyBpKyspIHtcclxuICAgICAgdmVjMyB2Y3RMaWdodERpcmVjdGlvbiA9IHZlYzModV9kaXJlY3Rpb25hbFtpXS5tdHhTaGFwZSAqIHZlYzQoMC4wLCAwLjAsIC0xLjAsIDEuMCkpO1xyXG4gICAgICBpbGx1bWluYXRlRGlyZWN0ZWQodmN0TGlnaHREaXJlY3Rpb24sIHZjdFZpZXdEaXJlY3Rpb24sIHZjdE5vcm1hbCwgdV9kaXJlY3Rpb25hbFtpXS52Y3RDb2xvci5yZ2IsIHZjdERpZmZ1c2UsIHZjdFNwZWN1bGFyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBwb2ludCBsaWdodHNcclxuICAgIGZvcih1aW50IGkgPSAwdTsgaSA8IHVfbkxpZ2h0c1BvaW50OyBpKyspIHtcclxuICAgICAgdmVjMyB2Y3RMaWdodFBvc2l0aW9uID0gdmVjMyh1X3BvaW50W2ldLm10eFNoYXBlICogdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApKTtcclxuICAgICAgdmVjMyB2Y3RMaWdodERpcmVjdGlvbiA9IHZjdExpZ2h0UG9zaXRpb24gLSB2Y3RQb3NpdGlvbjtcclxuICAgICAgZmxvYXQgZkludGVuc2l0eSA9IDEuMCAtIGxlbmd0aChtYXQzKHVfcG9pbnRbaV0ubXR4U2hhcGVJbnZlcnNlKSAqIHZjdExpZ2h0RGlyZWN0aW9uKTtcclxuICAgICAgaWYoZkludGVuc2l0eSA8IDAuMClcclxuICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgIGlsbHVtaW5hdGVEaXJlY3RlZCh2Y3RMaWdodERpcmVjdGlvbiwgdmN0Vmlld0RpcmVjdGlvbiwgdmN0Tm9ybWFsLCB1X3BvaW50W2ldLnZjdENvbG9yLnJnYiAqIGZJbnRlbnNpdHksIHZjdERpZmZ1c2UsIHZjdFNwZWN1bGFyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzcG90IGxpZ2h0c1xyXG4gICAgZm9yKHVpbnQgaSA9IDB1OyBpIDwgdV9uTGlnaHRzU3BvdDsgaSsrKSB7XHJcbiAgICAgIHZlYzMgdmN0TGlnaHRQb3NpdGlvbiA9IHZlYzModV9zcG90W2ldLm10eFNoYXBlICogdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApKTtcclxuICAgICAgdmVjMyB2Y3RMaWdodERpcmVjdGlvbiA9IHZjdExpZ2h0UG9zaXRpb24gLSB2Y3RQb3NpdGlvbjtcclxuICAgICAgdmVjMyB2Y3RMaWdodERpcmVjdGlvbkludmVydGVkID0gbWF0Myh1X3Nwb3RbaV0ubXR4U2hhcGVJbnZlcnNlKSAqIC12Y3RMaWdodERpcmVjdGlvbjtcclxuICAgICAgaWYodmN0TGlnaHREaXJlY3Rpb25JbnZlcnRlZC56IDw9IDAuMClcclxuICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgIGZsb2F0IGZJbnRlbnNpdHkgPSAxLjAgLSBtaW4oMS4wLCAyLjAgKiBsZW5ndGgodmN0TGlnaHREaXJlY3Rpb25JbnZlcnRlZC54eSkgLyB2Y3RMaWdodERpcmVjdGlvbkludmVydGVkLnopOyAgICAvLyBDb25lc2hhcGUgdGhhdCBpcyBicmlnaHRlc3QgaW4gdGhlIGNlbnRlci4gUG9zc2libGUgVE9ETzogXCJWYXJpYWJsZSBTcG90bGlnaHRzb2Z0bmVzc1wiXHJcbiAgICAgIGZJbnRlbnNpdHkgKj0gMS4wIC0gcG93KHZjdExpZ2h0RGlyZWN0aW9uSW52ZXJ0ZWQueiwgMi4wKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBoYXJzaCBsaWdodGluZyBhcnRpZmFjdHMgYXQgYm91bmRhcnkgb2YgdGhlIGdpdmVuIHNwb3RsaWdodFxyXG4gICAgICBpZihmSW50ZW5zaXR5IDwgMC4wKVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgaWxsdW1pbmF0ZURpcmVjdGVkKHZjdExpZ2h0RGlyZWN0aW9uLCB2Y3RWaWV3RGlyZWN0aW9uLCB2Y3ROb3JtYWwsIHVfc3BvdFtpXS52Y3RDb2xvci5yZ2IgKiBmSW50ZW5zaXR5LCB2Y3REaWZmdXNlLCB2Y3RTcGVjdWxhcik7XHJcbiAgICB9XHJcblxyXG4gICNlbmRpZlxyXG5cclxuICB2ZWM0IHZjdENvbG9yID0gdV92Y3RDb2xvciAqIHVfdmN0Q29sb3JQcmltYXJ5ICogdl92Y3RDb2xvcjtcclxuXHJcbiAgI2lmIGRlZmluZWQoR09VUkFVRClcclxuXHJcbiAgICB2ZWMzIHZjdERpZmZ1c2UgPSB2X3ZjdERpZmZ1c2U7XHJcbiAgICB2ZWMzIHZjdFNwZWN1bGFyID0gdl92Y3RTcGVjdWxhcjtcclxuXHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKEZMQVQpIHx8IGRlZmluZWQoR09VUkFVRCkgfHwgZGVmaW5lZChQSE9ORylcclxuXHJcbiAgICB2Y3RGcmFnLnJnYiA9IHZjdERpZmZ1c2UgKyB2Y3RTcGVjdWxhciAqIHVfZk1ldGFsbGljO1xyXG4gICAgdmN0RnJhZy5hID0gMS4wO1xyXG5cclxuICAjZWxzZVxyXG5cclxuICAgIC8vIE1JTklNQUw6IHNldCB0aGUgYmFzZSBjb2xvclxyXG4gICAgdmN0RnJhZyA9IHZjdENvbG9yO1xyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoVEVYVFVSRSkgfHwgZGVmaW5lZChNQVRDQVApXHJcbiAgICBcclxuICAgIC8vIFRFWFRVUkU6IG11bHRpcGx5IHdpdGggdGV4ZWwgY29sb3JcclxuICAgIHZlYzQgdmN0Q29sb3JUZXh0dXJlID0gdGV4dHVyZSh1X3RleENvbG9yLCB2X3ZjdFRleHR1cmUpOyAvLyBoYXMgcHJlbXVsdGlwbGllZCBhbHBoYSBieSB3ZWJnbCBmb3IgY29ycmVjdCBmaWx0ZXJpbmdcclxuICAgIGlmICh2Y3RDb2xvclRleHR1cmUuYSA+IDAuMCkgLy8gdW5wcmVtdWx0aXBseSBhbHBoYVxyXG4gICAgICB2Y3RDb2xvclRleHR1cmUucmdiIC89IHZjdENvbG9yVGV4dHVyZS5hOyBcclxuICAgIHZjdEZyYWcgKj0gdmN0Q29sb3JUZXh0dXJlO1xyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoRkxBVCkgfHwgZGVmaW5lZChHT1VSQVVEKSB8fCBkZWZpbmVkKFBIT05HKVxyXG5cclxuICAgIHZjdEZyYWcgKj0gdmN0Q29sb3I7XHJcbiAgICB2Y3RGcmFnLnJnYiArPSB2Y3RTcGVjdWxhciAqICgxLjAgLSB1X2ZNZXRhbGxpYyk7XHJcblxyXG4gICAgdmN0RnJhZ1Bvc2l0aW9uID0gdmVjNCh2X3ZjdFBvc2l0aW9uLCAxLjApO1xyXG4gICAgdmN0RnJhZ05vcm1hbCA9IHZlYzQodmN0Tm9ybWFsLCAxLjApO1xyXG4gIFxyXG4gICNlbmRpZlxyXG5cclxuICAjaWYgIWRlZmluZWQoUEhPTkcpICYmICFkZWZpbmVkKEZMQVQpICYmICFkZWZpbmVkKEdPVVJBVUQpIC8vIE1JTklNQUxcclxuXHJcbiAgICB2Y3RGcmFnUG9zaXRpb24gPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7IC8vICgwLCAwLCAwKSB3aWxsIHRyZWF0IG9jY2x1ZGVycyBhcyBub24gZXhpc3RpbmcgaW4gc3Nhb1xyXG4gICAgdmN0RnJhZ05vcm1hbCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMS4wKTsgLy8gKDAsIDAsIDApIG5vcm1hbCB3aWxsIHlpZWxkIG5vdCBvY2NsdXNpb24gaW4gc3Nhb1xyXG4gIFxyXG4gICNlbmRpZlxyXG5cclxuICAvLyBkaXNjYXJkIHBpeGVsIGFsbHRvZ2V0aGVyIHdoZW4gdHJhbnNwYXJlbnQ6IGRvbid0IHNob3cgaW4gWi1CdWZmZXJcclxuICBpZih2Y3RGcmFnLmEgPCB1X2ZBbHBoYUNsaXApXHJcbiAgICBkaXNjYXJkO1xyXG5cclxuICBpZiAodV9iRm9nQWN0aXZlKSB7XHJcbiAgICBmbG9hdCBmRm9nID0gZ2V0Rm9nKHZfdmN0UG9zaXRpb24pO1xyXG4gICAgdmN0RnJhZy5yZ2IgPSBtaXgodmN0RnJhZy5yZ2IsIHVfdmN0Rm9nQ29sb3IucmdiLCBmRm9nKTtcclxuXHJcbiAgICAjaWYgZGVmaW5lZChQQVJUSUNMRSlcclxuXHJcbiAgICAgIGlmICh1X2lCbGVuZE1vZGUgPT0gMnUgfHwgdV9pQmxlbmRNb2RlID09IDN1IHx8IHVfaUJsZW5kTW9kZSA9PSA0dSkgIC8vIGZvciBibGVuZCBhZGRpdGl2ZSwgc3VidHJhY3RpdmUsIG1vZHVsYXRlXHJcbiAgICAgICAgdmN0RnJhZy5hID0gbWl4KHZjdEZyYWcuYSwgMC4wLCBmRm9nKTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhZGUgb3V0IHBhcnRpY2xlIHdoZW4gaW4gZm9nIHRvIG1ha2UgaXQgZGlzYXBwZWFyIGNvbXBsZXRlbHlcclxuXHJcbiAgICAjZW5kaWZcclxuICB9XHJcbn1gO1xuICBzaGFkZXJTb3VyY2VzW1wiU2hhZGVyVW5pdmVyc2FsLnZlcnRcIl0gPSAvKmdsc2wqLyBgI3ZlcnNpb24gMzAwIGVzXHJcbi8qKlxyXG4qIFVuaXZlcnNhbCBTaGFkZXIgYXMgYmFzZSBmb3IgbWFueSBvdGhlcnMuIENvbnRyb2xsZWQgYnkgY29tcGlsZXIgZGlyZWN0aXZlc1xyXG4qIEBhdXRob3JzIDIwMjEsIEx1aXMgS2VjaywgSEZVLCAyMDIxIHwgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMjEgfCBKb25hcyBQbG90emt5LCBIRlUsIDIwMjNcclxuKi9cclxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbnByZWNpc2lvbiBoaWdocCBpbnQ7XHJcblxyXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIE5vZGUge1xyXG4gIHVuaWZvcm0gbWF0NCB1X210eE1lc2hUb1dvcmxkOyAvLyB1X210eE1vZGVsXHJcbiAgdW5pZm9ybSBtYXQzIHVfbXR4UGl2b3Q7IC8vIHRleHR1cmUgcGl2b3QgbWF0cml4XHJcbiAgdW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3JQcmltYXJ5OyAvLyBjb21wb25lbnQgbWF0ZXJpYWwgY29sb3JcclxuXHJcbiAgdW5pZm9ybSB1aW50IHVfaUJsZW5kTW9kZTtcclxuICB1bmlmb3JtIGZsb2F0IHVfZlBhcnRpY2xlU3lzdGVtRHVyYXRpb247XHJcbiAgdW5pZm9ybSBmbG9hdCB1X2ZQYXJ0aWNsZVN5c3RlbVNpemU7XHJcbiAgdW5pZm9ybSBmbG9hdCB1X2ZQYXJ0aWNsZVN5c3RlbVRpbWU7XHJcblxyXG4gIHVuaWZvcm0gYm9vbCB1X2JGYWNlQ2FtZXJhQWN0aXZlO1xyXG4gIHVuaWZvcm0gYm9vbCB1X2JGYWNlQ2FtZXJhUmVzdHJpY3Q7XHJcbn07XHJcblxyXG5sYXlvdXQoc3RkMTQwKSB1bmlmb3JtIENhbWVyYSB7XHJcbiAgbWF0NCB1X210eFdvcmxkVG9DYW1lcmE7IC8vIHVfbXR4Vmlld1xyXG4gIG1hdDQgdV9tdHhQcm9qZWN0aW9uOyBcclxuICBtYXQ0IHVfbXR4V29ybGRUb1ZpZXc7IC8vIHVfbXR4Vmlld1Byb2plY3Rpb25cclxuICB2ZWMzIHVfdmN0Q2FtZXJhO1xyXG59O1xyXG5cclxubGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBNYXRlcmlhbCB7XHJcbiAgdW5pZm9ybSB2ZWM0IHVfdmN0Q29sb3I7XHJcblxyXG4gIHVuaWZvcm0gZmxvYXQgdV9mRGlmZnVzZTtcclxuICB1bmlmb3JtIGZsb2F0IHVfZlNwZWN1bGFyO1xyXG4gIHVuaWZvcm0gZmxvYXQgdV9mSW50ZW5zaXR5O1xyXG4gIHVuaWZvcm0gZmxvYXQgdV9mTWV0YWxsaWM7XHJcblxyXG4gIHVuaWZvcm0gZmxvYXQgdV9mQWxwaGFDbGlwO1xyXG59O1xyXG5cclxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjMyBhX3ZjdFBvc2l0aW9uO1xyXG5sYXlvdXQobG9jYXRpb24gPSAzKSBpbiB2ZWM0IGFfdmN0Q29sb3I7IC8vIFRPRE86IHRoaW5rIGFib3V0IG1ha2luZyB2ZXJ0ZXggY29sb3Igb3B0aW9uYWxcclxuXHJcbm91dCB2ZWMzIHZfdmN0UG9zaXRpb247XHJcbm91dCB2ZWM0IHZfdmN0Q29sb3I7XHJcblxyXG4jaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKEdPVVJBVUQpIHx8IGRlZmluZWQoUEhPTkcpXHJcblxyXG4gIGxheW91dChsb2NhdGlvbiA9IDEpIGluIHZlYzMgYV92Y3ROb3JtYWw7XHJcbiAgb3V0IHZlYzMgdl92Y3ROb3JtYWw7XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZiBkZWZpbmVkKEZMQVQpXHJcblxyXG4gIGZsYXQgb3V0IHZlYzMgdl92Y3RQb3NpdGlvbkZsYXQ7XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZiBkZWZpbmVkKEdPVVJBVUQpXHJcblxyXG4gIG91dCB2ZWMzIHZfdmN0RGlmZnVzZTtcclxuICBvdXQgdmVjMyB2X3ZjdFNwZWN1bGFyO1xyXG5cclxuICBzdHJ1Y3QgTGlnaHQge1xyXG4gICAgdmVjNCB2Y3RDb2xvcjtcclxuICAgIG1hdDQgbXR4U2hhcGU7XHJcbiAgICBtYXQ0IG10eFNoYXBlSW52ZXJzZTtcclxuICB9O1xyXG5cclxuICAjZGVmaW5lIE1BWF9MSUdIVFNfRElSRUNUSU9OQUwgMTV1XHJcbiAgI2RlZmluZSBNQVhfTElHSFRTX1BPSU5UIDEwMHVcclxuICAjZGVmaW5lIE1BWF9MSUdIVFNfU1BPVCAxMDB1XHJcblxyXG4gIGxheW91dChzdGQxNDApIHVuaWZvcm0gTGlnaHRzIHsgLy8gVE9ETzogcHV0IGFtYmllbnQgY29sb3IgaW4gaGVhZGVyXHJcbiAgICB1aW50IHVfbkxpZ2h0c0RpcmVjdGlvbmFsO1xyXG4gICAgdWludCB1X25MaWdodHNQb2ludDtcclxuICAgIHVpbnQgdV9uTGlnaHRzU3BvdDtcclxuICAgIHZlYzQgdV92Y3RBbWJpZW50Q29sb3I7XHJcblxyXG4gICAgTGlnaHQgdV9kaXJlY3Rpb25hbFtNQVhfTElHSFRTX0RJUkVDVElPTkFMXTtcclxuICAgIExpZ2h0IHVfcG9pbnRbTUFYX0xJR0hUU19QT0lOVF07XHJcbiAgICBMaWdodCB1X3Nwb3RbTUFYX0xJR0hUU19TUE9UXTtcclxuICB9O1xyXG5cclxuICB2b2lkIGlsbHVtaW5hdGVEaXJlY3RlZCh2ZWMzIF92Y3REaXJlY3Rpb24sIHZlYzMgX3ZjdFZpZXcsIHZlYzMgX3ZjdE5vcm1hbCwgdmVjMyBfdmN0Q29sb3IsIGlub3V0IHZlYzMgX3ZjdERpZmZ1c2UsIGlub3V0IHZlYzMgX3ZjdFNwZWN1bGFyKSB7XHJcbiAgICB2ZWMzIHZjdERpcmVjdGlvbiA9IG5vcm1hbGl6ZShfdmN0RGlyZWN0aW9uKTtcclxuICAgIGZsb2F0IGZJbGx1bWluYXRpb24gPSAtZG90KF92Y3ROb3JtYWwsIHZjdERpcmVjdGlvbik7XHJcbiAgICBpZihmSWxsdW1pbmF0aW9uID4gMC4wKSB7XHJcbiAgICAgIF92Y3REaWZmdXNlICs9IHVfZkRpZmZ1c2UgKiBmSWxsdW1pbmF0aW9uICogX3ZjdENvbG9yO1xyXG5cclxuICAgICAgaWYodV9mU3BlY3VsYXIgPD0gMC4wKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIC8vQkxJTk5cclxuICAgICAgdmVjMyBoYWxmd2F5RGlyID0gbm9ybWFsaXplKC12Y3REaXJlY3Rpb24gLSBfdmN0Vmlldyk7XHJcbiAgICAgIGZsb2F0IGZhY3RvciA9IG1heChkb3QoLXZjdERpcmVjdGlvbiwgX3ZjdE5vcm1hbCksIDAuMCk7IC8vRmFjdG9yIGZvciBzbW9vdGhpbmcgb3V0IHRyYW5zaXRpb24gZnJvbSBzdXJmYWNlIGZhY2luZyB0aGUgbGlnaHRzb3VyY2UgdG8gc3VyZmFjZSBmYWNpbmcgYXdheSBmcm9tIHRoZSBsaWdodHNvdXJjZVxyXG4gICAgICBmYWN0b3IgPSAxLjAgLSAocG93KGZhY3RvciAtIDEuMCwgOC4wKSk7ICAgICAgICAgICAgICAgICAvL1RoZSBmYWN0b3IgaXMgYWx0ZXJlZCBpbiBvcmRlciB0byBjbGVhcmx5IHNlZSB0aGUgc3BlY3VsYXIgaGlnaGxpZ2h0IGV2ZW4gYXQgc3RlZXAgYW5nbGVzLCB3aGlsZSBzdGlsbCBwcmV2ZW50aW5nIGFydGlmYWN0c1xyXG5cclxuICAgICAgX3ZjdFNwZWN1bGFyICs9IHBvdyhtYXgoZG90KF92Y3ROb3JtYWwsIGhhbGZ3YXlEaXIpLCAwLjApLCBleHAyKHVfZlNwZWN1bGFyICogNS4wKSkgKiB1X2ZTcGVjdWxhciAqIHVfZkludGVuc2l0eSAqIGZhY3RvciAqIF92Y3RDb2xvcjtcclxuXHJcbiAgICAgIC8vUEhPTkcgKG9sZClcclxuICAgICAgLy8gdmVjMyB2Y3RSZWZsZWN0aW9uID0gbm9ybWFsaXplKHJlZmxlY3QoLXZjdERpcmVjdGlvbiwgX3ZjdE5vcm1hbCkpO1xyXG4gICAgICAvLyBmbG9hdCBmSGl0Q2FtZXJhID0gZG90KHZjdFJlZmxlY3Rpb24sIF92Y3RWaWV3KTtcclxuICAgICAgLy8gX3ZjdFNwZWN1bGFyICs9IHBvdyhtYXgoZkhpdENhbWVyYSwgMC4wKSwgdV9mU3BlY3VsYXIgKiAxMC4wKSAqIHVfZlNwZWN1bGFyICogX3ZjdENvbG9yOyAvLyAxMC4wID0gbWFnaWMgbnVtYmVyLCBsb29rcyBnb29kLi4uIFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmIGRlZmluZWQoVEVYVFVSRSkgfHwgZGVmaW5lZChOT1JNQUxNQVApXHJcblxyXG4gIGxheW91dChsb2NhdGlvbiA9IDIpIGluIHZlYzIgYV92Y3RUZXh0dXJlO1xyXG4gIG91dCB2ZWMyIHZfdmN0VGV4dHVyZTtcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmIGRlZmluZWQoTk9STUFMTUFQKVxyXG5cclxuICBsYXlvdXQobG9jYXRpb24gPSA0KSBpbiB2ZWM0IGFfdmN0VGFuZ2VudDtcclxuICBvdXQgdmVjMyB2X3ZjdFRhbmdlbnQ7XHJcbiAgb3V0IHZlYzMgdl92Y3RCaXRhbmdlbnQ7XHJcblxyXG4jZW5kaWZcclxuXHJcbi8vIE1BVENBUDogb2ZmZXIgYnVmZmVycyBmb3IgVVZzIGFuZCBwaXZvdCBtYXRyaXhcclxuI2lmIGRlZmluZWQoTUFUQ0FQKSAvLyBNYXRDYXAtc2hhZGVyIGdlbmVyYXRlcyB0ZXh0dXJlIGNvb3JkaW5hdGVzIGZyb20gc3VyZmFjZSBub3JtYWxzXHJcblxyXG4gIGxheW91dChsb2NhdGlvbiA9IDEpIGluIHZlYzMgYV92Y3ROb3JtYWw7XHJcbiAgb3V0IHZlYzIgdl92Y3RUZXh0dXJlO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWYgZGVmaW5lZChTS0lOKVxyXG5cclxuICAvLyBCb25lcyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2Jsb2IvZGV2L3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubmluZ19wYXJzX3ZlcnRleC5nbHNsLmpzXHJcbiAgbGF5b3V0KGxvY2F0aW9uID0gNSkgaW4gdXZlYzQgYV92Y3RCb25lcztcclxuICBsYXlvdXQobG9jYXRpb24gPSA2KSBpbiB2ZWM0IGFfdmN0V2VpZ2h0cztcclxuXHJcbiAgY29uc3QgdWludCBNQVhfQk9ORVMgPSAyNTZ1OyAvLyBDQVVUSU9OOiB0aGlzIG51bWJlciBtdXN0IGJlIHRoZSBzYW1lIGFzIGluIFJlbmRlckluamVjdG9yU2tlbGV0b25JbnN0YW5jZSB3aGVyZSB0aGUgY29ycmVzcG9uZGluZyBidWZmZXJzIGFyZSBjcmVhdGVkXHJcbiAgbGF5b3V0KHN0ZDE0MCkgdW5pZm9ybSBTa2luIHtcclxuICAgIG1hdDQgdV9tdHhCb25lc1tNQVhfQk9ORVNdO1xyXG4gIH07XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZiBkZWZpbmVkKFBBUlRJQ0xFKVxyXG5cclxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X3BhcnRpY2xlU3lzdGVtUmFuZG9tTnVtYmVycztcclxuXHJcbiAgZmxvYXQgZmV0Y2hSYW5kb21OdW1iZXIoaW50IF9pT2Zmc2V0LCBpbnQgX2lQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNTaXplLCBpbnQgX2lQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNMZW5ndGgpIHtcclxuICAgIF9pT2Zmc2V0ID0gZ2xfSW5zdGFuY2VJRCArIF9pT2Zmc2V0ICUgX2lQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNMZW5ndGg7XHJcbiAgICByZXR1cm4gdGV4ZWxGZXRjaCh1X3BhcnRpY2xlU3lzdGVtUmFuZG9tTnVtYmVycywgaXZlYzIoX2lPZmZzZXQgJSBfaVBhcnRpY2xlU3lzdGVtUmFuZG9tTnVtYmVyc1NpemUsIF9pT2Zmc2V0IC8gX2lQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNTaXplKSwgMCkucjtcclxuICB9XHJcblxyXG4jZW5kaWZcclxuXHJcbm1hdDQgbG9va0F0Q2FtZXJhKG1hdDQgX210eFdvcmxkLCBib29sIF9iUmVzdHJpY3QpIHtcclxuICB2ZWMzIHZjdFVwID0gdmVjMygwLjAsIDEuMCwgMC4wKTtcclxuXHJcbiAgdmVjMyB2Y3RQb3NpdGlvbiA9IF9tdHhXb3JsZFszXS54eXo7XHJcblxyXG4gIC8vIHZlYzMgekF4aXMgPSBub3JtYWxpemUodV92Y3RDYW1lcmEgLSB2Y3RQb3NpdGlvbik7IC8vIGxvb2sgYXQgY2FtZXJhIHBvc2l0aW9uXHJcbiAgdmVjMyB6QXhpcyA9IG5vcm1hbGl6ZSgtdmVjMyh1X210eFdvcmxkVG9DYW1lcmFbMF0ueiwgdV9tdHhXb3JsZFRvQ2FtZXJhWzFdLnosIHVfbXR4V29ybGRUb0NhbWVyYVsyXS56KSk7IC8vIGxvb2sgaW4gY2FtZXJhIGRpcmVjdGlvblxyXG5cclxuICB2ZWMzIHhBeGlzID0gbm9ybWFsaXplKGNyb3NzKHZjdFVwLCB6QXhpcykpO1xyXG4gIHZlYzMgeUF4aXMgPSBfYlJlc3RyaWN0ID8gdmN0VXAgOiBub3JtYWxpemUoY3Jvc3MoekF4aXMsIHhBeGlzKSk7XHJcbiAgekF4aXMgPSBfYlJlc3RyaWN0ID8gbm9ybWFsaXplKGNyb3NzKHhBeGlzLCB2Y3RVcCkpIDogekF4aXM7XHJcblxyXG4gIHZlYzMgdmN0U2NhbGUgPSB2ZWMzKGxlbmd0aChfbXR4V29ybGRbMF0ueHl6KSwgbGVuZ3RoKF9tdHhXb3JsZFsxXS54eXopLCBsZW5ndGgoX210eFdvcmxkWzJdLnh5eikpO1xyXG5cclxuICBtYXQ0IGJpbGxib2FyZE1hdHJpeCA9IG1hdDQoXHJcbiAgICB2ZWM0KHhBeGlzICogdmN0U2NhbGUueCwgMC4wKSxcclxuICAgIHZlYzQoeUF4aXMgKiB2Y3RTY2FsZS55LCAwLjApLFxyXG4gICAgdmVjNCh6QXhpcyAqIHZjdFNjYWxlLnosIDAuMCksXHJcbiAgICB2ZWM0KHZjdFBvc2l0aW9uLCAxLjApXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIGJpbGxib2FyZE1hdHJpeDtcclxufVxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuICB2ZWM0IHZjdFBvc2l0aW9uID0gdmVjNChhX3ZjdFBvc2l0aW9uLCAxLjApO1xyXG4gIG1hdDQgbXR4TWVzaFRvV29ybGQgPSB1X210eE1lc2hUb1dvcmxkO1xyXG5cclxuICAvLyBpZiAodV9iQmlsbGJvYXJkQWN0aXZlKSBcclxuICAvLyAgIG10eE1lc2hUb1dvcmxkID0gbG9va0F0Q2FtZXJhKG10eE1lc2hUb1dvcmxkLCB1X2JCaWxsYm9hcmRSZXN0cmljdCk7XHJcblxyXG4gICNpZiBkZWZpbmVkKFBBUlRJQ0xFKVxyXG4gIFxyXG4gICAgZmxvYXQgZlBhcnRpY2xlSWQgPSBmbG9hdChnbF9JbnN0YW5jZUlEKTtcclxuICAgIGludCBpUGFydGljbGVTeXN0ZW1SYW5kb21OdW1iZXJzU2l6ZSA9IHRleHR1cmVTaXplKHVfcGFydGljbGVTeXN0ZW1SYW5kb21OdW1iZXJzLCAwKS54OyAvLyB0aGUgZGltZW5zaW9uIG9mIHRoZSBxdWFkcmF0aWMgdGV4dHVyZVxyXG4gICAgaW50IGlQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNMZW5ndGggPSBpUGFydGljbGVTeXN0ZW1SYW5kb21OdW1iZXJzU2l6ZSAqIGlQYXJ0aWNsZVN5c3RlbVJhbmRvbU51bWJlcnNTaXplOyAvLyB0aGUgdG90YWwgbnVtYmVyIG9mIHRleGVscyBpbiB0aGUgdGV4dHVyZVxyXG4gICAgLyokdmFyaWFibGVzKi9cclxuICAgIC8qJG10eExvY2FsKi9cclxuICAgIC8qJG10eFdvcmxkKi9cclxuICAgIG10eE1lc2hUb1dvcmxkID0gLyokbXR4V29ybGQqLyBtdHhNZXNoVG9Xb3JsZCAvKiRtdHhMb2NhbCovO1xyXG4gICAgaWYodV9iRmFjZUNhbWVyYUFjdGl2ZSkgXHJcbiAgICAgIG10eE1lc2hUb1dvcmxkID0gbG9va0F0Q2FtZXJhKG10eE1lc2hUb1dvcmxkLCB1X2JGYWNlQ2FtZXJhUmVzdHJpY3QpO1xyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoU0tJTilcclxuXHJcbiAgICBtdHhNZXNoVG9Xb3JsZCA9IGFfdmN0V2VpZ2h0cy54ICogdV9tdHhCb25lc1thX3ZjdEJvbmVzLnhdICtcclxuICAgICAgYV92Y3RXZWlnaHRzLnkgKiB1X210eEJvbmVzW2FfdmN0Qm9uZXMueV0gK1xyXG4gICAgICBhX3ZjdFdlaWdodHMueiAqIHVfbXR4Qm9uZXNbYV92Y3RCb25lcy56XSArXHJcbiAgICAgIGFfdmN0V2VpZ2h0cy53ICogdV9tdHhCb25lc1thX3ZjdEJvbmVzLnddO1xyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgbWF0NCBtdHhNZXNoVG9WaWV3ID0gdV9tdHhXb3JsZFRvVmlldyAqIG10eE1lc2hUb1dvcmxkO1xyXG5cclxuICAjaWYgZGVmaW5lZChGTEFUKSB8fCBkZWZpbmVkKEdPVVJBVUQpIHx8IGRlZmluZWQoUEhPTkcpIHx8IGRlZmluZWQoTUFUQ0FQKSAvLyBvbmx5IHRoZXNlIHdvcmsgd2l0aCBwYXJ0aWNsZSBhbmQgc2tpbm5pbmdcclxuXHJcbiAgICBtYXQ0IG10eE5vcm1hbE1lc2hUb1dvcmxkID0gdHJhbnNwb3NlKGludmVyc2UobXR4TWVzaFRvV29ybGQpKTtcclxuXHJcbiAgI2VuZGlmXHJcblxyXG4gIGdsX1Bvc2l0aW9uID0gbXR4TWVzaFRvVmlldyAqIHZjdFBvc2l0aW9uOyBcclxuICB2Y3RQb3NpdGlvbiA9IG10eE1lc2hUb1dvcmxkICogdmN0UG9zaXRpb247XHJcblxyXG4gIHZfdmN0Q29sb3IgPSBhX3ZjdENvbG9yO1xyXG4gIHZfdmN0UG9zaXRpb24gPSB2Y3RQb3NpdGlvbi54eXo7XHJcblxyXG4gICNpZiBkZWZpbmVkKFBBUlRJQ0xFX0NPTE9SKVxyXG5cclxuICAgIHZfdmN0Q29sb3IgKj0gLyokY29sb3IqLztcclxuXHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKEZMQVQpXHJcblxyXG4gICAgdl92Y3RQb3NpdGlvbkZsYXQgPSB2X3ZjdFBvc2l0aW9uO1xyXG4gICAgXHJcbiAgI2VuZGlmXHJcblxyXG4gICNpZiBkZWZpbmVkKEZMQVQpIHx8IGRlZmluZWQoR09VUkFVRCkgfHwgZGVmaW5lZChQSE9ORylcclxuXHJcbiAgICB2X3ZjdE5vcm1hbCA9IG1hdDMobXR4Tm9ybWFsTWVzaFRvV29ybGQpICogYV92Y3ROb3JtYWw7IC8vIHVubm9ybWFsaXplZCBhcyBpdCBtdXN0IGJlIG5vcm1hbGl6ZWQgaW4gdGhlIGZyYWdtZW50IHNoYWRlciBhbnl3YXlcclxuXHJcbiAgI2VuZGlmIFxyXG5cclxuICAjaWYgZGVmaW5lZChOT1JNQUxNQVApXHJcblxyXG4gICAgdl92Y3RUYW5nZW50ID0gbWF0MyhtdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiBhX3ZjdFRhbmdlbnQueHl6O1xyXG4gICAgdl92Y3RCaXRhbmdlbnQgPSBjcm9zcyh2X3ZjdE5vcm1hbCwgdl92Y3RUYW5nZW50KSAqIGFfdmN0VGFuZ2VudC53O1xyXG5cclxuICAjZW5kaWZcclxuXHJcbiAgI2lmIGRlZmluZWQoR09VUkFVRClcclxuICBcclxuICAgIHZlYzMgdmN0VmlldyA9IG5vcm1hbGl6ZSh2Y3RQb3NpdGlvbi54eXogLSB1X3ZjdENhbWVyYSk7XHJcbiAgICB2ZWMzIHZjdE5vcm1hbCA9IG5vcm1hbGl6ZSh2X3ZjdE5vcm1hbCk7XHJcbiAgICB2X3ZjdERpZmZ1c2UgPSB1X2ZEaWZmdXNlICogdV92Y3RBbWJpZW50Q29sb3IucmdiO1xyXG4gICAgdl92Y3RTcGVjdWxhciA9IHZlYzMoMCwgMCwgMCk7XHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIGRpcmVjdGlvbmFsIGxpZ2h0IGVmZmVjdFxyXG4gICAgZm9yKHVpbnQgaSA9IDB1OyBpIDwgdV9uTGlnaHRzRGlyZWN0aW9uYWw7IGkgKyspIHtcclxuICAgICAgdmVjMyB2Y3REaXJlY3Rpb24gPSB2ZWMzKHVfZGlyZWN0aW9uYWxbaV0ubXR4U2hhcGUgKiB2ZWM0KDAuMCwgMC4wLCAxLjAsIDEuMCkpO1xyXG4gICAgICBpbGx1bWluYXRlRGlyZWN0ZWQodmN0RGlyZWN0aW9uLCB2Y3RWaWV3LCB2Y3ROb3JtYWwsIHVfZGlyZWN0aW9uYWxbaV0udmN0Q29sb3IucmdiLCB2X3ZjdERpZmZ1c2UsIHZfdmN0U3BlY3VsYXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGN1bGF0ZSBwb2ludCBsaWdodCBlZmZlY3RcclxuICAgIGZvcih1aW50IGkgPSAwdTtpIDwgdV9uTGlnaHRzUG9pbnQ7aSArKykge1xyXG4gICAgICB2ZWMzIHZjdFBvc2l0aW9uTGlnaHQgPSB2ZWMzKHVfcG9pbnRbaV0ubXR4U2hhcGUgKiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCkpO1xyXG4gICAgICB2ZWMzIHZjdERpcmVjdGlvbiA9IHZjdFBvc2l0aW9uLnh5eiAtIHZjdFBvc2l0aW9uTGlnaHQ7XHJcbiAgICAgIGZsb2F0IGZJbnRlbnNpdHkgPSAxLjAgLSBsZW5ndGgobWF0Myh1X3BvaW50W2ldLm10eFNoYXBlSW52ZXJzZSkgKiB2Y3REaXJlY3Rpb24pO1xyXG4gICAgICBpZihmSW50ZW5zaXR5IDwgMC4wKSBjb250aW51ZTtcclxuXHJcbiAgICAgIGlsbHVtaW5hdGVEaXJlY3RlZCh2Y3REaXJlY3Rpb24sIHZjdFZpZXcsIHZjdE5vcm1hbCwgdV9wb2ludFtpXS52Y3RDb2xvci5yZ2IgKiBmSW50ZW5zaXR5LCB2X3ZjdERpZmZ1c2UsIHZfdmN0U3BlY3VsYXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGN1bGF0ZSBzcG90IGxpZ2h0IGVmZmVjdFxyXG4gICAgZm9yKHVpbnQgaSA9IDB1O2kgPCB1X25MaWdodHNTcG90O2kgKyspIHtcclxuICAgICAgdmVjMyB2Y3RQb3NpdGlvbkxpZ2h0ID0gdmVjMyh1X3Nwb3RbaV0ubXR4U2hhcGUgKiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCkpO1xyXG4gICAgICB2ZWMzIHZjdERpcmVjdGlvbiA9IHZjdFBvc2l0aW9uLnh5eiAtIHZjdFBvc2l0aW9uTGlnaHQ7XHJcbiAgICAgIHZlYzMgdmN0RGlyZWN0aW9uSW52ZXJ0ZWQgPSBtYXQzKHVfc3BvdFtpXS5tdHhTaGFwZUludmVyc2UpICogdmN0RGlyZWN0aW9uO1xyXG4gICAgICBpZih2Y3REaXJlY3Rpb25JbnZlcnRlZC56IDw9IDAuMCkgY29udGludWU7XHJcblxyXG4gICAgICBmbG9hdCBmSW50ZW5zaXR5ID0gMS4wIC0gbWluKDEuMCwgMi4wICogbGVuZ3RoKHZjdERpcmVjdGlvbkludmVydGVkLnh5KSAvIHZjdERpcmVjdGlvbkludmVydGVkLnopOyAgICAvL0NvbmVzaGFwZSB0aGF0IGlzIGJyaWdodGVzdCBpbiB0aGUgY2VudGVyLiBQb3NzaWJsZSBUT0RPOiBcIlZhcmlhYmxlIFNwb3RsaWdodHNvZnRuZXNzXCJcclxuICAgICAgZkludGVuc2l0eSAqPSAxLjAgLSBwb3codmN0RGlyZWN0aW9uSW52ZXJ0ZWQueiwgMi4wKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9QcmV2ZW50cyBoYXJzaCBsaWdodGluZyBhcnRpZmFjdHMgYXQgYm91bmRhcnkgb2YgdGhlIGdpdmVuIHNwb3RsaWdodFxyXG4gICAgICBpZihmSW50ZW5zaXR5IDwgMC4wKSBjb250aW51ZTtcclxuXHJcbiAgICAgIGlsbHVtaW5hdGVEaXJlY3RlZCh2Y3REaXJlY3Rpb24sIHZjdFZpZXcsIHZjdE5vcm1hbCwgdV9zcG90W2ldLnZjdENvbG9yLnJnYiAqIGZJbnRlbnNpdHksIHZfdmN0RGlmZnVzZSwgdl92Y3RTcGVjdWxhcik7XHJcbiAgICB9XHJcblxyXG4gICNlbmRpZlxyXG5cclxuICAgIC8vIFRFWFRVUkU6IHRyYW5zZm9ybSBVVnNcclxuICAjaWYgZGVmaW5lZChURVhUVVJFKSB8fCBkZWZpbmVkKE5PUk1BTE1BUClcclxuXHJcbiAgICB2X3ZjdFRleHR1cmUgPSB2ZWMyKHVfbXR4UGl2b3QgKiB2ZWMzKGFfdmN0VGV4dHVyZSwgMS4wKSkueHk7XHJcblxyXG4gICNlbmRpZlxyXG5cclxuICAjaWYgZGVmaW5lZChNQVRDQVApXHJcblxyXG4gICAgdmVjNCB2Y3RWZXJ0ZXhJbkNhbWVyYSA9IG5vcm1hbGl6ZSh1X210eFdvcmxkVG9DYW1lcmEgKiB2Y3RQb3NpdGlvbik7XHJcbiAgICB2Y3RWZXJ0ZXhJbkNhbWVyYS54eSAqPSAtIDEuMDtcclxuICAgIG1hdDQgbXR4X1JvdFggPSBtYXQ0KDEsIDAsIDAsIDAsIDAsIHZjdFZlcnRleEluQ2FtZXJhLnosIHZjdFZlcnRleEluQ2FtZXJhLnksIDAsIDAsIC0gdmN0VmVydGV4SW5DYW1lcmEueSwgdmN0VmVydGV4SW5DYW1lcmEueiwgMCwgMCwgMCwgMCwgMSk7XHJcbiAgICBtYXQ0IG10eF9Sb3RZID0gbWF0NCh2Y3RWZXJ0ZXhJbkNhbWVyYS56LCAwLCAtIHZjdFZlcnRleEluQ2FtZXJhLngsIDAsIDAsIDEsIDAsIDAsIHZjdFZlcnRleEluQ2FtZXJhLngsIDAsIHZjdFZlcnRleEluQ2FtZXJhLnosIDAsIDAsIDAsIDAsIDEpO1xyXG5cclxuICAgIHZlYzMgdmN0Tm9ybWFsID0gbWF0MyhtdHhOb3JtYWxNZXNoVG9Xb3JsZCkgKiBhX3ZjdE5vcm1hbDtcclxuXHJcbiAgICAvLyBhZGRzIGNvcnJlY3Rpb24gZm9yIHRoaW5ncyBiZWluZyBmYXIgYW5kIHRvIHRoZSBzaWRlLCBidXQgZGlzdG9ydGlvbiBmb3IgdGhpbmdzIGJlaW5nIGNsb3NlXHJcbiAgICB2Y3ROb3JtYWwgPSBtYXQzKG10eF9Sb3RYICogbXR4X1JvdFkpICogdmN0Tm9ybWFsO1xyXG5cclxuICAgIHZlYzMgdmN0UmVmbGVjdGlvbiA9IG5vcm1hbGl6ZShtYXQzKHVfbXR4V29ybGRUb0NhbWVyYSkgKiBub3JtYWxpemUodmN0Tm9ybWFsKSk7XHJcbiAgICB2Y3RSZWZsZWN0aW9uLnkgPSAtIHZjdFJlZmxlY3Rpb24ueTtcclxuXHJcbiAgICB2X3ZjdFRleHR1cmUgPSAwLjUgKiB2Y3RSZWZsZWN0aW9uLnh5ICsgMC41O1xyXG5cclxuICAjZW5kaWZcclxufWA7XG5cbn0iLCIvLyAvIDxyZWZlcmVuY2UgcGF0aD1cIi4uL0NvYXQvQ29hdC50c1wiLz5cclxubmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVyZmFjZSB0byBhY2Nlc3MgZGF0YSBmcm9tIGEgV2ViR2wgc2hhZGVycHJvZ3JhbS4gXHJcbiAgICogVGhpcyBzaG91bGQgYWx3YXlzIG1pcnJvciB0aGUgKHN0YXRpYykgaW50ZXJmYWNlIG9mIHtAbGluayBTaGFkZXJ9LiBJdCBleHBvc2VzIHRoZSBzdGF0aWMgbWVtYmVycyBvZiBTaGFkZXIgaW4gYW4gaW5zdGFuY2UtYmFzZWQgd2F5LiBlLmcuOlxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiBsZXQgc2hhZGVyOiBTaGFkZXJJbnRlcmZhY2U7XHJcbiAgICogYGBgXHJcbiAgICogY2FuIHRha2UgdmFsdWVzIG9mIHR5cGUgXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIHR5cGVvZiBTaGFkZXIgfCBTaGFkZXJJbnRlZmFjZVxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2hhZGVySW50ZXJmYWNlIHtcclxuICAgIGRlZmluZTogc3RyaW5nW107XHJcbiAgICBwcm9ncmFtOiBXZWJHTFByb2dyYW07XHJcbiAgICB1bmlmb3JtczogeyBbbmFtZTogc3RyaW5nXTogV2ViR0xVbmlmb3JtTG9jYXRpb24gfTtcclxuICAgIC8qKiBSZXR1cm5zIHRoZSB2ZXJ0ZXggc2hhZGVyIHNvdXJjZSBjb2RlIGZvciB0aGUgcmVuZGVyIGVuZ2luZSAqL1xyXG4gICAgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZztcclxuICAgIC8qKiBSZXR1cm5zIHRoZSBmcmFnbWVudCBzaGFkZXIgc291cmNlIGNvZGUgZm9yIHRoZSByZW5kZXIgZW5naW5lICovXHJcbiAgICBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmc7XHJcbiAgICAvKiogQGludGVybmFsIEluamVjdGVkIGJ5IGRlY29yYXRvci4gVXNlZCBieSB0aGUgcmVuZGVyIHN5c3RlbS4gKi9cclxuICAgIGRlbGV0ZVByb2dyYW0odGhpczogU2hhZGVySW50ZXJmYWNlKTogdm9pZDtcclxuICAgIC8qKiBAaW50ZXJuYWwgSW5qZWN0ZWQgYnkgZGVjb3JhdG9yLiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLiAqL1xyXG4gICAgdXNlUHJvZ3JhbSh0aGlzOiBTaGFkZXJJbnRlcmZhY2UpOiB2b2lkO1xyXG4gICAgLyoqIEBpbnRlcm5hbCBJbmplY3RlZCBieSBkZWNvcmF0b3IuIFVzZWQgYnkgdGhlIHJlbmRlciBzeXN0ZW0uICovXHJcbiAgICBjcmVhdGVQcm9ncmFtKHRoaXM6IFNoYWRlckludGVyZmFjZSk6IHZvaWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGF0aWMgc3VwZXJjbGFzcyBmb3IgdGhlIHJlcHJlc2VudGF0aW9uIG9mIFdlYkdsIHNoYWRlcnByb2dyYW1zLiBcclxuICAgKiBAYXV0aG9ycyBKYXNjaGEgS2FyYWfDtmwsIEhGVSwgMjAxOSB8IEppcmthIERlbGwnT3JvLUZyaWVkbCwgSEZVLCAyMDE5XHJcbiAgICovXHJcbiAgLy8gVE9ETzogZGVmaW5lIHVuaWZvcm1zIGFzIGxheW91dCBhbmQgdXNlIHRob3NlIGNvbnNpc3RlbnRseSBpbiBzaGFkZXJzXHJcbiAgQFJlbmRlckluamVjdG9yU2hhZGVyLmRlY29yYXRlXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlciB7XHJcbiAgICAvKiogcmVmZXJzIGJhY2sgdG8gdGhpcyBjbGFzcyBmcm9tIGFueSBzdWJjbGFzcyBlLmcuIGluIG9yZGVyIHRvIGZpbmQgY29tcGF0aWJsZSBvdGhlciByZXNvdXJjZXMqL1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBiYXNlQ2xhc3M6IHR5cGVvZiBTaGFkZXIgPSBTaGFkZXI7XHJcbiAgICAvKiogbGlzdCBvZiBhbGwgdGhlIHN1YmNsYXNzZXMgZGVyaXZlZCBmcm9tIHRoaXMgY2xhc3MsIGlmIHRoZXkgcmVnaXN0ZXJlZCBwcm9wZXJseSovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHN1YmNsYXNzZXM6IHR5cGVvZiBTaGFkZXJbXSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXTtcclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgdmVydGV4U2hhZGVyU291cmNlOiBzdHJpbmc7XHJcbiAgICAvLyBwdWJsaWMgc3RhdGljIGZyYWdtZW50U2hhZGVyU291cmNlOiBzdHJpbmc7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBwcm9ncmFtOiBXZWJHTFByb2dyYW07XHJcbiAgICBwdWJsaWMgc3RhdGljIHVuaWZvcm1zOiB7IFtuYW1lOiBzdHJpbmddOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB9O1xyXG5cclxuICAgIC8qKiBUaGUgdHlwZSBvZiBjb2F0IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB0aGlzIHNoYWRlciB0byBjcmVhdGUgYSBtYXRlcmlhbCAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRDb2xvcmVkOyB9XHJcbiAgICAvKiogUmV0dXJucyB0aGUgdmVydGV4IHNoYWRlciBzb3VyY2UgY29kZSBmb3IgdGhlIHJlbmRlciBlbmdpbmUgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlclVuaXZlcnNhbC52ZXJ0XCJdLCB0aGlzLmRlZmluZSk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0aGUgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZSBjb2RlIGZvciB0aGUgcmVuZGVyIGVuZ2luZSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJVbml2ZXJzYWwuZnJhZ1wiXSwgdGhpcy5kZWZpbmUpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JTaGFkZXJ9LiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWxldGVQcm9ncmFtKHRoaXM6IHR5cGVvZiBTaGFkZXIpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBkZWNvcmF0b3IgKi8gfVxyXG4gICAgLyoqIEBpbnRlcm5hbCBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JTaGFkZXJ9LiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLiAqL1xyXG4gICAgcHVibGljIHN0YXRpYyB1c2VQcm9ncmFtKHRoaXM6IHR5cGVvZiBTaGFkZXIpOiB2b2lkIHsvKiBpbmplY3RlZCBieSBkZWNvcmF0b3IgKi8gfVxyXG4gICAgLyoqIEBpbnRlcm5hbCBJbmplY3RlZCBieSB7QGxpbmsgUmVuZGVySW5qZWN0b3JTaGFkZXJ9LiBVc2VkIGJ5IHRoZSByZW5kZXIgc3lzdGVtLiAqLyAvLyBUT0RPOiBtYXliZSBkb24ndCBmbGFnIHRoaXMgYXMgaW50ZXJuYWwsIHNvIHNoYWRlcnMgY2FuIGJlIHByZWNvbXBpbGVkIGluIGZ1dHVyZSBGVURHRSBhcHBzLiBPciBjcmVhdGUgYW4gQVBJIHRvIHByZWNvbXBpbGUgc2hhZGVycywgbG9hZCB0ZXh0dXJlcyBldGMuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZVByb2dyYW0odGhpczogdHlwZW9mIFNoYWRlcik6IHZvaWQgey8qIGluamVjdGVkIGJ5IGRlY29yYXRvciAqLyB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyByZWdpc3RlclN1YmNsYXNzKF9zdWJjbGFzczogdHlwZW9mIFNoYWRlcik6IG51bWJlciB7IHJldHVybiBTaGFkZXIuc3ViY2xhc3Nlcy5wdXNoKF9zdWJjbGFzcykgLSAxOyB9XHJcblxyXG4gICAgLy8gcmVwbGFjZSB0aGUgbWFuZGF0b3J5IGhlYWRlciBvZiB0aGUgc2hhZGVyIHdpdGggaXRzZWxmIHBsdXMgdGhlIGRlZmluaXRpb25zIGdpdmVuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGluc2VydERlZmluZXMoX3NoYWRlcjogc3RyaW5nLCBfZGVmaW5lczogc3RyaW5nW10pOiBzdHJpbmcge1xyXG4gICAgICBpZiAoIV9kZWZpbmVzKVxyXG4gICAgICAgIHJldHVybiBfc2hhZGVyO1xyXG5cclxuICAgICAgbGV0IGNvZGU6IHN0cmluZyA9IFwiI3ZlcnNpb24gMzAwIGVzXFxuXCI7XHJcbiAgICAgIGZvciAobGV0IGRlZmluZSBvZiBfZGVmaW5lcylcclxuICAgICAgICBjb2RlICs9IGAjZGVmaW5lICR7ZGVmaW5lfVxcbmA7XHJcblxyXG4gICAgICByZXR1cm4gX3NoYWRlci5yZXBsYWNlKFwiI3ZlcnNpb24gMzAwIGVzXCIsIGNvZGUpO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJBbWJpZW50T2NjbHVzaW9uIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlclNjcmVlbi52ZXJ0XCJdLCB0aGlzLmRlZmluZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJBbWJpZW50T2NjbHVzaW9uLmZyYWdcIl0sIHRoaXMuZGVmaW5lKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyQmxvb20gZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0RGVmaW5lcyhzaGFkZXJTb3VyY2VzW1wiU2hhZGVyU2NyZWVuLnZlcnRcIl0sIHRoaXMuZGVmaW5lKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlckJsb29tLmZyYWdcIl0sIHRoaXMuZGVmaW5lKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyRmxhdCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyRmxhdCk7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xyXG4gICAgICBcIkZMQVRcIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZTsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJGbGF0U2tpbiBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyRmxhdFNraW4pO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJGTEFUXCIsXHJcbiAgICAgIFwiU0tJTlwiXHJcbiAgICBdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0UmVtaXNzaXZlOyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckZsYXRUZXh0dXJlZCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyRmxhdFRleHR1cmVkKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiRkxBVFwiLFxyXG4gICAgICBcIlRFWFRVUkVcIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZVRleHR1cmVkOyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckZsYXRUZXh0dXJlZFNraW4gZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckZsYXRUZXh0dXJlZFNraW4pO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJGTEFUXCIsXHJcbiAgICAgIFwiVEVYVFVSRVwiLFxyXG4gICAgICBcIlNLSU5cIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZVRleHR1cmVkOyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckdpem1vIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlckdpem1vLnZlcnRcIl0sIHRoaXMuZGVmaW5lKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlckdpem1vLmZyYWdcIl0sIHRoaXMuZGVmaW5lKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyR2l6bW9UZXh0dXJlZCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXCJURVhUVVJFXCJdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlckdpem1vLnZlcnRcIl0sIHRoaXMuZGVmaW5lKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlckdpem1vLmZyYWdcIl0sIHRoaXMuZGVmaW5lKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyR291cmF1ZCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyR291cmF1ZCk7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xyXG4gICAgICBcIkdPVVJBVURcIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZTsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJHb3VyYXVkU2tpbiBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyR291cmF1ZFNraW4pO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJHT1VSQVVEXCIsXHJcbiAgICAgIFwiU0tJTlwiXHJcbiAgICBdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0UmVtaXNzaXZlOyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckdvdXJhdWRUZXh0dXJlZCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyR291cmF1ZFRleHR1cmVkKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiR09VUkFVRFwiLFxyXG4gICAgICBcIlRFWFRVUkVcIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZVRleHR1cmVkOyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckdvdXJhdWRUZXh0dXJlZFNraW4gZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlckdvdXJhdWRUZXh0dXJlZFNraW4pO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJHT1VSQVVEXCIsXHJcbiAgICAgIFwiVEVYVFVSRVwiLFxyXG4gICAgICBcIlNLSU5cIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZVRleHR1cmVkOyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckxpdCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyTGl0KTtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtdO1xyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJMaXRTa2luIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJMaXRTa2luKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJTS0lOXCJcclxuICAgIF07XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckxpdFRleHR1cmVkIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJMaXRUZXh0dXJlZCk7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xyXG4gICAgICBcIlRFWFRVUkVcIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFRleHR1cmVkOyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlckxpdFRleHR1cmVkU2tpbiBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyTGl0VGV4dHVyZWRTa2luKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiVEVYVFVSRVwiLFxyXG4gICAgICBcIlNLSU5cIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFRleHR1cmVkOyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlck1hdENhcCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyTWF0Q2FwKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiTUFUQ0FQXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRUZXh0dXJlZDsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJPdXRsaW5lIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlclNjcmVlbi52ZXJ0XCJdLCB0aGlzLmRlZmluZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnREZWZpbmVzKHNoYWRlclNvdXJjZXNbXCJTaGFkZXJPdXRsaW5lLmZyYWdcIl0sIHRoaXMuZGVmaW5lKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyUGhvbmcgZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlclBob25nKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiUEhPTkdcIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZTsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJQaG9uZ1NraW4gZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlclBob25nU2tpbik7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xyXG4gICAgICBcIlBIT05HXCIsXHJcbiAgICAgIFwiU0tJTlwiXHJcbiAgICBdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0UmVtaXNzaXZlOyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlclBob25nVGV4dHVyZWQgZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlclBob25nVGV4dHVyZWQpO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJQSE9OR1wiLFxyXG4gICAgICBcIlRFWFRVUkVcIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZVRleHR1cmVkOyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlclBob25nVGV4dHVyZWROb3JtYWxzIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJQaG9uZ1RleHR1cmVkTm9ybWFscyk7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xyXG4gICAgICBcIlBIT05HXCIsXHJcbiAgICAgIFwiVEVYVFVSRVwiLFxyXG4gICAgICBcIk5PUk1BTE1BUFwiXHJcbiAgICBdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0UmVtaXNzaXZlVGV4dHVyZWROb3JtYWxzOyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlclBob25nVGV4dHVyZWROb3JtYWxzU2tpbiBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyUGhvbmdUZXh0dXJlZE5vcm1hbHNTa2luKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiUEhPTkdcIixcclxuICAgICAgXCJURVhUVVJFXCIsXHJcbiAgICAgIFwiTk9STUFMTUFQXCIsXHJcbiAgICAgIFwiU0tJTlwiXHJcbiAgICBdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29hdCgpOiB0eXBlb2YgQ29hdCB7IHJldHVybiBDb2F0UmVtaXNzaXZlVGV4dHVyZWROb3JtYWxzOyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlclBob25nVGV4dHVyZWRTa2luIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJQaG9uZ1RleHR1cmVkU2tpbik7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW1xyXG4gICAgICBcIlBIT05HXCIsXHJcbiAgICAgIFwiVEVYVFVSRVwiLFxyXG4gICAgICBcIlNLSU5cIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFJlbWlzc2l2ZVRleHR1cmVkOyB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlclBpY2sgZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyBkZWZpbmU6IHN0cmluZ1tdID0gW107XHJcbiAgICBcclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlclBpY2sudmVydFwiXSwgdGhpcy5kZWZpbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0RGVmaW5lcyhzaGFkZXJTb3VyY2VzW1wiU2hhZGVyUGljay5mcmFnXCJdLCB0aGlzLmRlZmluZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlclBpY2tUZXh0dXJlZCBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXCJURVhUVVJFXCJdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VmVydGV4U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluc2VydERlZmluZXMoc2hhZGVyU291cmNlc1tcIlNoYWRlclBpY2sudmVydFwiXSwgdGhpcy5kZWZpbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0RGVmaW5lcyhzaGFkZXJTb3VyY2VzW1wiU2hhZGVyUGljay5mcmFnXCJdLCB0aGlzLmRlZmluZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59IiwibmFtZXNwYWNlIEZ1ZGdlQ29yZSB7XHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYWRlclRvb24gZXh0ZW5kcyBTaGFkZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBpU3ViY2xhc3M6IG51bWJlciA9IFNoYWRlci5yZWdpc3RlclN1YmNsYXNzKFNoYWRlclRvb24pO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJQSE9OR1wiLFxyXG4gICAgICBcIlRPT05cIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFRvb247IH1cclxuICB9XHJcblxyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJUb29uU2tpbiBleHRlbmRzIFNoYWRlciB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGlTdWJjbGFzczogbnVtYmVyID0gU2hhZGVyLnJlZ2lzdGVyU3ViY2xhc3MoU2hhZGVyVG9vblNraW4pO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJQSE9OR1wiLFxyXG4gICAgICBcIlRPT05cIixcclxuICAgICAgXCJTS0lOXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRUb29uOyB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyVG9vblRleHR1cmVkIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJUb29uVGV4dHVyZWQpO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVmaW5lOiBzdHJpbmdbXSA9IFtcclxuICAgICAgXCJQSE9OR1wiLFxyXG4gICAgICBcIlRPT05cIixcclxuICAgICAgXCJURVhUVVJFXCJcclxuICAgIF07XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb2F0KCk6IHR5cGVvZiBDb2F0IHsgcmV0dXJuIENvYXRUb29uVGV4dHVyZWQ7IH1cclxuICB9XHJcblxyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJUb29uVGV4dHVyZWRTa2luIGV4dGVuZHMgU2hhZGVyIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgaVN1YmNsYXNzOiBudW1iZXIgPSBTaGFkZXIucmVnaXN0ZXJTdWJjbGFzcyhTaGFkZXJUb29uVGV4dHVyZWRTa2luKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlZmluZTogc3RyaW5nW10gPSBbXHJcbiAgICAgIFwiUEhPTkdcIixcclxuICAgICAgXCJUT09OXCIsXHJcbiAgICAgIFwiVEVYVFVSRVwiLFxyXG4gICAgICBcIlNLSU5cIlxyXG4gICAgXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvYXQoKTogdHlwZW9mIENvYXQgeyByZXR1cm4gQ29hdFRvb25UZXh0dXJlZDsgfVxyXG4gIH1cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIGV4cG9ydCBjbGFzcyBUZXh0dXJlRGVmYXVsdCBleHRlbmRzIFRleHR1cmVCYXNlNjQge1xyXG4gICAgcHVibGljIHN0YXRpYyBjb2xvcjogVGV4dHVyZUJhc2U2NCA9IG5ldyBUZXh0dXJlRGVmYXVsdChcIlRleHR1cmVEZWZhdWx0XCIsIFRleHR1cmVEZWZhdWx0LmdldENvbG9yKCksIE1JUE1BUC5NRURJVU0pO1xyXG4gICAgcHVibGljIHN0YXRpYyBub3JtYWw6IFRleHR1cmVCYXNlNjQgPSBuZXcgVGV4dHVyZURlZmF1bHQoXCJUZXh0dXJlTm9ybWFsRGVmYXVsdFwiLCBUZXh0dXJlRGVmYXVsdC5nZXROb3JtYWwoKSwgTUlQTUFQLk1FRElVTSk7XHJcbiAgICBwdWJsaWMgc3RhdGljIHRvb246IFRleHR1cmVCYXNlNjQgPSBuZXcgVGV4dHVyZURlZmF1bHQoXCJUZXh0dXJlVG9vbkRlZmF1bHRcIiwgVGV4dHVyZURlZmF1bHQuZ2V0VG9vbigpLCBNSVBNQVAuU01PT1RILCBXUkFQLkNMQU1QKTtcclxuXHJcbiAgICAvLyBUT0RPOiBtYXliZSBtYWtlIHRoZXNlIGxhenlcclxuICAgIHB1YmxpYyBzdGF0aWMgaWNvbkxpZ2h0OiBUZXh0dXJlQmFzZTY0ID0gbmV3IFRleHR1cmVEZWZhdWx0KFwiSWNvbkRlZmF1bHRMaWdodFwiLCBUZXh0dXJlRGVmYXVsdC5nZXRJY29uTGlnaHQoKSwgTUlQTUFQLkJMVVJSWSwgV1JBUC5DTEFNUCwgMjU2LCAyNTYpO1xyXG4gICAgcHVibGljIHN0YXRpYyBpY29uQ2FtZXJhOiBUZXh0dXJlQmFzZTY0ID0gbmV3IFRleHR1cmVEZWZhdWx0KFwiSWNvbkRlZmF1bHRDYW1lcmFcIiwgVGV4dHVyZURlZmF1bHQuZ2V0SWNvbkNhbWVyYSgpLCBNSVBNQVAuQkxVUlJZLCBXUkFQLkNMQU1QLCAyNTYsIDI1Nik7XHJcbiAgICBwdWJsaWMgc3RhdGljIGljb25BdWRpbzogVGV4dHVyZUJhc2U2NCA9IG5ldyBUZXh0dXJlRGVmYXVsdChcIkljb25EZWZhdWx0QXVkaW9cIiwgVGV4dHVyZURlZmF1bHQuZ2V0SWNvbkF1ZGlvKCksIE1JUE1BUC5CTFVSUlksIFdSQVAuQ0xBTVAsIDI1NiwgMjU2KTtcclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgaWNvblBhcnRpY2xlczogVGV4dHVyZUJhc2U2NCA9IG5ldyBUZXh0dXJlRGVmYXVsdChcIkljb25EZWZhdWx0UGFydGljbGVcIiwgVGV4dHVyZURlZmF1bHQuZ2V0SWNvblBhcnRpY2xlcygpLCBNSVBNQVAuQkxVUlJZLCAyNTYsIDI1Nik7XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0Q29sb3IoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFaQUFBQUdRQ0FZQUFBQ0F2emJNQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBRFdMU1VSQlZIaGU3ZDBIbkZUbHZmL3hIOXVYWllHbDl5clNSSnBFVWV4WXNKSWJhOFJlNDk4V05jWkViKzQxZXBPSXNXczBOaXl4bTJnMGR1d2Fld083b3FKQ0FHblN0N0gvODMwNEI0ZGxkcGs1WjNiM3pPN256ZXU4NXB3ek04dk1zN1BQYjM1UE82MXFQQlpqclZxMTh2ZmlLZWJGUi9sRlJQbEZRL2xGRS9meXkvRnZBUUJJQ3dFRUFCQUtBUVFBRUFwOUlCSFJoaG9ONVJjTjVSZE5TeWcvL1l6Q3drSnIzYnExTzE2OWVyWGJNb0VBRWhGL3dORlFmdEZRZnRFMDkvTEx6YzIxTGwyNjJFOSs4aE1iUDM2OFZWZFgyK3V2djI3VHAwOTNRU1RxK3llQVJNUWZjRFNVWHpTVVh6VE50Znh5Y25Lc3BLVEVCZzBhWkVjZWVhUWRldWlodG1MRkN2dnNzODlzM3J4NTl2ampqOXZERHo4Y09ST0pIRUNxcXFwczl1elp0bXpaTWx1NWNxVkxsZHExYTJkOSsvWjErMUh4QVl5RzhvdUc4b3VHOG9zbVRQbmw1K2RiOSs3ZGJmZmRkN2RUVHozVjFjWHZ2dnV1dmZ6eXl5NERrVldyVnRtTk45NW9TNVlzY2NkaGhRNGc1ZVhsOXV5eno5cU1HVE5zelpvMS90a2ZLUUlxK3UyOTk5NVdXbHJxbjAwZkg4Qm9LTDlvS0w5b0tMOW8waWsvUGJaTm16YTJ4UlpiMkhISEhXZVRKMCsyaFFzWDJwTlBQbW1MRnkvMkg3WE9mLzd6SDd2MTFsdGRQUjVGcUFDeVlNRUN1K2VlZTFLS1htdlhyclg5OXR2UFJvOGU3WUpLdXZnQVJrUDVSUk9Vbno2NytpS1VsNWRubFpXVnRuejU4bGk4ZGo1LzBUU244bE9UMWI3Nzdtc1hYSENCZGU3YzJWNTc3VFY3ODgwM2s3N0hiNy85MXU2NDR3NnJxS2p3ejRTVGRnQlJ0cUhVSjRob0NoQ2ZmUEtKZmZYVlY2NDlyWDM3OWpaZ3dBQzNCWlF1VFpvMHliYmJianVYWHFXREQyQTBsRjgwUWZsMTdOalJqam5tR092VXFaTjk4ODAzOXNBREQ3Z3ZVazM5K3ZuOFJkT2N5cTlyMTY0MmRlcFUyM3JycmUzUlJ4OTFYM0pFZGJTYXNJcUxpMjNZc0dIdVhLWUNTTm9wZ1hydmcrQ2gvby83N3J2UHZWaTkrSi8vL09kMjlORkgyOUNoUTkwTERHajRtTklsQlptNC84TFFzc3ljT2RNMXhiNzY2cXRKbTJKRjJVZlBuajN0MTcvK3RVMllNTUYyM1hWWE8vYllZMTFRUWZNMWYvNTh1K21tbTF6ZmdmcDQ0MDcxc1Y2elBzdEI4RkE5ckMvOFR6MzFsT3NYeWJTME1wQWZmdmpCcnI3NjZ2VWRNVUVmaUZLbS9mZmYzOHJLeXRhbitNcEdWUGpCWS9YSHFlempyTFBPY3Azc3FlSWJURFNVWC8zKzhJYy91TStyNkV2UVQzLzZVemZzTVNnMzNTcUFxRjM1bVdlZXNXdXZ2ZGFkbDRjZWVzamVlKzg5LzZocDhQbUxwcjd5MDZpbEs2KzgwbFhNMHI5L2Z4czVjcVQ3Z2x4UVVPRE9OYlIweWkvNG9uUEVFVWU0WTQyMGV1ZWRkOXhncHFPT09zcDIzSEZITndwTG1pUUQrZUNERHpib3hYLzc3YmRkeG5IZ2dRZGFuejU5ckczYnRpN2JVSURvMXEyYjYwQVBGQlVWMlhQUFBSZUx0QjlJUm45UUw3MzBVc29kaTdVN0p0RzhxRU42bDExMjhZL012djc2YS92blAvOXBmLzd6biszQkJ4KzBMNy84TWxaMW1acXE1czZkNno3SCtxS2paaXZSKzFEZ0N5WVNabEphQWVTTEw3N3c5OHcrLy94ejk4SVU3ZlROTFZta0hERml4QVlkNTNxODNsVFVubitnSVNqRDFsRDBWQ3VGNE1zVW1pLzFKNmh6V3ArSllGUEdxcVpQVmRTWFhucXB5MHcxMmlrTzlKbFVkckYwNmRMMW4yTk5KbXlvakNubEFLSVg4OTEzMy9sSDVpS2Qyb1BWcnBZWUpCS3BPVXVqQVFMcWdIenJyYmZxYkdzR2dEaFIzVFp1M0xpTjZyaWdjdFlYamxkZWVjVjk0Ny8rK3V2dGpUZmVjSzB6VFNsNGJZMGg1UUNpYjJkQlc2Qm9DSytHNXFwbnZ6N0tUZ0pxMnZyMDAwL0pRQUJrRFRYLzFGY3BCL2VwQTF2OURtcml1dnZ1dSszamp6OXU5bGxxeWdHazlwd1BSVmtOMWQzVXNGd042dzJvajBSRElJTk9Td0NJTzlWaDZVeUdWa0JSRS8rOTk5NXJGMTk4Y1N6N1N6SWw1UUJTT3kxVDc3MEtWdTFyOVVrTU1OcFhsS2J0R0VBMjZkMjdkNTFOOWNrb1dLaGZXRitXUC96d1E5ZGZjdFZWVjdsQkdtck5hUzVTSHNhcjRZb2FnUkM0L1BMTDNXSmMyMjY3cmV2cnFJdFdmbnppaVNmOEk3TXJycmpDRFMzVGtMaFUxTzZjVjJlUVJuekZ4V09QUGVidnhkTmVlKzNsNzhWVFU1V2Z2c3owNnRYTFRid0tNbUxOYWRLb3dqMzMzSFA5T200cVAxVWNtMisrdWQxMjIyMXVHSHRBNCtzMThrV2RyRTJGejE4MHFaYWZScHhxQ0d6VUxDS296M3IwNk9HNkFEUTh2TDQxQTlNWnhsc1hEVXZYY0hYMVFRZkR6ak0xakRmbEFLSXA4WW1GclhhK0YxNTR3VWFOR2xWdlpGYXdlT1NSUi95amRZRkhIVTM2ZzB4RjdRSlVuOG92ZnZFTC93Z0lwME9IRGk1WTZGdGhFRURVNURCOCtIQWJQSGp3QnBtelBvUDZJNXd5WllvYmRSTzQ1WlpiM0VDU1ZEL0xRRzJhM3ZDclgvMnF6anEwMlFTUTJvSGdzc3N1Y3pNZU5hbW12amRaTy9CY2Nza2xibzBXUmQ1VTFQN1phalpMbkYvUzFQUnROYzRTczc4NGFxcnlVMy9jYnJ2dDVyN1FCQUZFNjd0cDNQL1lzV1BYRDN0VStlbVBXeE8wemozM1hKZEJCelJSZHJQTk5uUDNOUlUrZjlHa1duNkxGaTF5UTJNelNhdmthb1NYdnJUVXBka0VFTTA0VjJkUVFETTBsWUVvRU5UM0poVmtOSTFlMVBlaEFLSTNvVzk1cWNoRUFUYWtGSXV2eVZCKzlVdWNpZjczdi8vZHJaUncwRUVIclI5ZHFQSlRQNSthRzFRWlhuUE5OZTY4cUFscnpwdzUvbEhUNFBNWFRhcmxwK1o2MVZ0aHkxdWZJZFYvV3ExanpKZ3h0dVdXVzdvdk1adVNpZkpyeUFDU2NxOVE3WWtvbXRXb1A3eE5GV2ppa04xZ09aUEU1Z0dnS1NYMjM2a3ZRMFBWRXovVCtnUFc4SE5sSmVsMG9xSjUwVVdZMU4rVmpxRHlWeCtIZ29hV1dEL3R0Tk5jczJjcXdTTWJwUHdYVVhzWW0yYVZhOEd1VFJWcTRpSmtXdnBCUDJkVEk3ZUF4cExZZ2FrQW9oRXlpYU1FOVkxUkYrWlI4MVZjWmh1amNlbExoUUpJT3RtQUhqdHc0RUMzekpQNk9EU1lvQ21iT2h0S3lnRWtjVDZINlBqNzc3L2ZZSEpoTW9uckJXa3VpVWErMURkcUMyaE1pU3ZxcWo5RFFTTHhNNjNtckQvOTZVOHUrMGhzd2tYTG9Ua2RtMnBwQ1lLTFZ1WlFzRkRRT095d3c5enk2YzM1QzNQS0FVUnR3b21MY2FtZ3RMUkpmUUZFVFZ4YThpU2c5bUlOd2FVSkMzR2hqc3lBUHRNYXFwazQ1K21QZi95amE0WlZCM3ZVNjBjak8ya3FRckxzSTJqU1ZMMm96dkNUVGpySlRqamhCTGUvcVJVNkdvdGVkenFaVTdwU0RpQXFyTVM1RzVxRnJxbjY5YTFycGRtWFFRZWxhRFZMZFI1cDZCb1FCMXFtSXBGR3hHZytpQmJMMHdTd3A1OStlbjN3VUlkanBrZmlJTjcwSlhuMjdObnJNNUNnUWxZcmloYUwxV0t5WjU5OXRydGdYdUt5VFUxQnIwdGRDNXIwcUMvcXdhYW1zMlJ6bGRTdnJmdjBlSFd3aDVGeUFKRWhRNGI0ZSt1R1Flb0NVWFV0SEtZQzF5SmpBZjBTMUw0OGZ2ejQyRVJuUUovamJiYlp4ajlhOTBWSi9YYi8rTWMvM0ZVSFAvcm9JL2RaMXFKNXQ5OStlMVpjV0FpWm9mNWRqYjVLcEMvUnV0YjRPZWVjNDI1MTNKRGY4Tk9oVEVpWHRMM3p6anZkbktaZ3UrR0dHMnlISFhiWTRIVUdDWUVXZ05Uanp6Ly9mTGZ3YmJydkphMEFvamtmaWYwWG1rU29JYnExVTN2OXdXbUpZdzBWQzJqdWh4NnZTVmMwWVNGT0prNmM2RVphSmN1bVZZa29HOUh3WFYzTFJrTWlBeXpKMDd4cDNUNzE4MnJTcVQ0anYvemxMKzN3d3c5M3JTaHhyTVBVc3FNNlZ2M1RHcTZyUzJkby9wNG1ibXNWRVYxNlBLQmdvU3RycXBWSTEzbFNQODNKSjUrYzlxb0thVjJSVVBTQ0ZKV0RTS1VtS25VK2JyWFZWaTRDcXFOY0x6NXg2WGNkYXd5OUpoOHE1VXZuUmNZbHV0Y2x6ZUpyZEpSZmFuVDFPYTJncW05c0NnejZvcVNNV1g5MHdlVkJkVTd6bDlSTW9NOTNVODhCRVQ1LzBkUlhmcnBQOVprQ1NGTkpwL3hVcnlvcjBrVHI0TXFENmRJOFBXWGJxVW83Z0lqV3ZsZGtUdVhOYVFTREx2MjV4eDU3dUZtL2FtOUxwMUNvQUtPaC9GS25JS0xobWxvOVlkYXNXYTY1U2t2MkpMNUdwZjRxVTUxTGQxNUFRK0R6RjAxekt6OTl1VG40NElQZGFGZjEyYVh6L2pSaVZzMWQ2UWdWUU5Udm9Xd2lTTytTVVdlai9oQzFDSmtXWE5Uak5XczkzU0Z0ZkFDam9melNweVpaWmRZS0VKb0hFbWQ4L3FKcGJ1V254eXNUVVhOVzdUbE5tNkt5U0xjOFFnVVEwYmV6SjU5ODBpMG9welJQelZkNjhmb1dwMGltRkYvWFJUL2trRVBjb25VYXRSVm0vZ2Nmd0dnb3YyZ292MmdvdjJqaVhuNmhBNGpvbTVxQ2hZYno2a3FEU3Y4MUwwU1RzelI4VEIwNjZuVFVTSmRnekhTNitBQkdRL2xGUS9sRlEvbEYwNndEU0VEcHZ0cmJGRHowNDlSTXBWRUtXaVlpYWdId0FZeUc4b3VHOG91Rzhvc203dVdYa1FEU2tQZ0FSa1A1UlVQNVJVUDVSUlAzOGd2WHJnUUFhUEVJSUFDQVVBZ2dBSUJRMU1BVzcwYkFkYThSSVkwZE96YnV2OTlZZSt2dHQvMDloTkVxNW4wTWNSZjMwaU1EQVFDRVFnQUJBSVJDQUFFQWhFSUFBUUNFUWdBQkFJUkNBQUVBaEpLUkFLS3JET3BLWFZ0dnZiVi9CZ0RRM0dVa2dPaHlvQU1IRGd4OVlYWUFRUGFoQ1FzQUVFcEdBa2pjVjdRRUFHUWVHUWdBSUJRQ0NBQWdGQUlJQUNDVWpBYVF1Rjg5Q3dDUU9XUWdBSUJRQ0NBQWdGQXlFa0FZeGdzQUxROFpDQUFnRkFJSUFDQ1VqQVlRUm1FQlFNdEJCZ0lBQ0lVQUFnQUloUUFDQUFnbEl3R0VZYndBMFBLUWdRQUFRaUdBQUFCQ3lXZ0FZUmd2QUxRY1pDQUFnRkFJSUFDQVVBZ2dBSUJRTWhKQUdNWUxBQzBQR1FnQUlCUUNDQUFnbEl3R0VJYnhBa0RMUVFZQ0FBaUZBQUlBQ0lVQUFnQUlKU01CaEdHOEFORHlrSUVBQUVMSlVmWVFkWnMyYlpyN1lVY2RkVlRTKzZOc0FOQlNhV1JybkxlTVpDRDZRUUNBbG9VbUxBQkFLQVFRQUVBb0dRMGc5RmtBUU10QkJnSUFDSVVBQWdBSWhRQUNBQWdsSXdHRVlid0EwUEtRZ1FBQVFpR0FBQUJDeVdnQVlSZ3ZBTFFjWkNBQWdGQUlJQUNBVUFnZ0FJQlFNaEpBR01ZTEFDMFBHUWdBSUJRQ0NBQWdsSXdHRUlieEFrRExRUVlDQUFpRkFBSUFDSVVBQWdBSUpTTUJoR0c4QU5EeWtJRUFBRUloZ0FBQVFzbG9BR0VZTHdDMEhHUWdBSUJRQ0NBQWdGQXlFa0FZaFFVQUxROFpDQUFnRkFJSUFDQVVBZ2dBSUpTTUJoQ0c4UUpBeTBFR0FnQUloUUFDQUFnbEl3R0VZYndBMFBLUWdRQUFRaUdBQUFCQ0lZQUFBRUxKYUFCaEdDOEF0QnpxL1k1YzZ3OGJOc3dPT3VnZysvREREKzMrKysvM3oyYUdGNVIyOW5jUndva25udmljdjRzUWJ2anJEZjRld3FocHhaZktTR0plZkRSaEFRQkN5VWdBQ1pxdUdNNExBQzBIR1FnQUlCUUNDQUFnRkFJSUFDQVVBZ2dBSUJRQ0NBQWdGQUlJQUNDVWpBUVFodkVDUU10REJnSUFDSVVBQWdBSWhRQUNBQWlGQUFJQUNJVUFBZ0FJaFFBQ0FBZ2xJd0dFWWJ3QTBQS1FnUUFBUWlHQUFBQkNJWUFBQUVJaGdBQUFRaUdBQUFCQ0lZQUFBRUxKU0FCaEdDOEF0RHhrSUFDQVVBZ2dBSUJRQ0NBQWdGQUlJQUNBVUFnZ0FJQlFNaEpBR0lVRkFDMFBHUWdBSUJRQ0NBQWdGQUlJQUNBVUFnZ0FJQlFDQ0FBZ0ZBSUlBQ0NVakFRUWh2RUNRTXREQmdJQUNJVUFBZ0FJaFFBQ0FBZ2xSLzBYVWJmSEgzL2MvYkE5OTl3ejZmMVJOZ0JvcWRTdkhPZU5EQVFBRUFvQkJBQVFDZ0VFQUJBS0FRUUFFQW9CQkFBUUNnRUVBQkJLUmdLSWhuTUp3MjRCb09VZ0F3RUFoRUlBQVFDRVFnQUJBSVJDQUFFQWhFSUFBUUNFa3BFQXdpZ3NBR2g1eUVBQUFLRVFRQUFBb1JCQUFBQ2hFRUFBQUtFUVFBQUFvUkJBQUFDaFpDU0FNSXdYQUZvZU1oQUFRQ2dFRUFCQUtBUVFBRUFvQkJBQVFDZ0VFQUJBS0FRUUFFQW9HUWtnRE9NRmdKYUhEQVFBRUVwR0FraHVicTY3cmE2dWRyY0FnT1l2NVFDeVlzVUt1K09PTyt6R0cyKzBlKzY1eDVZdlgrN2ZVNzgzM25qRHBrMmJaamZmZkxOOS9QSEgvbGtBUUxaTE9ZQW95NWc5ZTdiTm5UdlhQdjMwVTd2d3dndnQ4ODgvdDdWcjEvcVAySmd5a21lZmZkYSsrZVliKys2NzcreXFxNjd5N3dFQVpMdVVBMGh4Y2JIMTc5L2ZQekpidlhxMTNYLy8vUzR6Q1FTZDZZRXZ2dmpDeXN2TDNiNkN5Y01QUCt6MkFRRFpMNjAra0ZHalJ2bDdacDA2ZGJMbm5udXUzcWFzbVRObitudG1YMzc1cFMxYnRzdy9BZ0JrdTdRQ3lPREJnOWQzbUl2MlAvdnNNNnVxcXZMUC9Fam5sSUVFUHZyb0l4czNicHgvQkFESWRta0ZrTHk4UEJzeVpJaC90QzZnUFBQTU03WnExU3IvekkvVVB4STBYMVZVVkxoZ01tblNKSGNNQU1oK2FRVVFHVE5takw5bjFxRkRCM3Z0dGRmV0I1REVQcEFQUC96UTN6UFg2VjVRVUdBVEowNzB6d0FBc2wzYUFhUmZ2MzVXV0Zqb0g1bmJuelZybHVza1Y1Q1F5c3BLMTdRVlVERFpmdnZ0clVlUEh2NFpBRUMyU3p1QTVPVGsySlpiYnVrZm1XdlNldkhGRjEyZmg1cTRSTUZEUVVRMFNrdkRlUGZlZTI4ckxTMTE1d0FBMlMvdEFDSmp4NDcxOTh6YXRtMXJNMmJNY1BOQjJyUnA0ODRsTmwrcDg3eXNyTXkyMjI0N054UVlBTkE4cU5NaXJSVVEyN2R2YjZlY2Nvb0xIRUhmeDV0dnZtbTlldld5blhiYXlYYmZmWGU3N3JycjFvL011dUdHRzJ6Ky9QbWhsem1wcWFtNXdOOUZDRjc1LzQrL2l4Qk9QUEVFZnc5aDFOUnNPRGNNNllyM0FyVnBaeUJxa3BvK2Zib05IejdjUDJNMmRPaFFOMHU5VDU4K2JyNUhFRHkrLy81N04zT2ROYklBb1BsSk80QW9PR2haa3NRbFROUjB0V1RKRW12WHJwMGJjUlhRUk1MYXM5TUJBTTFEcUQ0UXpTaC82cW1uM0d6MFFQZnUzZTJERHo2d3I3LysyaDNyMmlEcUd3RUFORStoQW9pYXNUVHlhdENnUWY0WnM4MDMzOXl0dkJzMFg2bEphK25TcFZ4a0NnQ2FxVkFCUk0xWEN4WXNzSVVMRjY1dm9tcmR1clhsNStlN2ZWRTJrcmpzQ1FDZ2VRa1ZRQ1JveHVyWnM2ZC9adDJLdmFJc1JFTjV5VDRBb1BrS0hVQTBoRmZOV0ltejBnT2FTS2psM3V1N1ZnZ0FJTHVGRGlES0x0VFBjZEZGRjduRkVvTmdvZjRSOVlWb3hub3lkWjBIQUdTWHRDY1MxcVoramhFalJyaUFvaUc4YTlhczhlOUpUbzlQWjE2STkzT1pTQmdCRXdtallTSmhORXdraktxWlRTU3NUY0ZBbzYwMEEzMmZmZmJ4ejlhTlNZVUEwRHlrRkVEVXo2SE9jaTFYMHJWcjEvV0xKZ1lVRkVwS1N0eEV3b0NhcXJUY3U1NmpWWGcxU2dzQTBIeWtGRUIwWWFnNWMrYTRHZWhhMXlxWTYxRWY5WWtzWHJ6WVBVZkxtU1M3NkJRQUlIdlJvdzBBQ0NVakFZVDVIZ0RROHBDQkFBQkNJWUFBQUVJaGdBQUFRc2xvQU9IYUh3RFFjcENCQUFCQ0lZQUFBRUxKU0FCaEdDOEF0RHhrSUFDQVVBZ2dBSUJRQ0NBQWdGQXlHa0FZeGdzQUxRY1pDQUFnRkFJSUFDQ1VqQVFRaHZFQ1FNdERCZ0lBQ0lVQUFnQUloUUFDQUFnbG93R0VZYndBMEhLUWdRQUFRaUdBQUFCQ3lVZ0FZUmd2QUxROFpDQUFnRkFJSUFDQVVETGFoTVVvTEFCb09jaEFBQUNoNUNoN2lMcTk4ODQ3N29lTkhqMDY2ZjFSTmdCb3FkU3FFK2VOREFRQUVFcEdBb2dpa1pBeEFFRExRUVlDQUFpRkFBSUFDSVVBQWdBSWhRQUNBQWlGQUFJQUNJVUFBZ0FJSlNNQmhHRzhBTkR5a0lFQUFFSWhnQUFBUWlHQUFBQkNJWUFBQUVJaGdBQUFRaUdBQUFCQ3lVZ0FZUmd2QUxROFpDQUFnRkFJSUFDQVVBZ2dBSUJRQ0NBQWdGQUlJQUNBVURJU1FCaUZCUUF0RHhrSUFDQVVBZ2dBSUJRQ0NBQWdsSXoyZ1FBQVdnNHlFQUJBS0FRUUFFQW9HUTBnRE9NRmdKYUREQVFBRUFvQkJBQVFDZ0VFQUJCS1JnSUl3M2dCb09VaEF3RUFoRUlBQVFDRWt0RUF3akJlQUdnNXlFQUFBS0VRUUFBQW9XUWtnREFLQ3dCYUh0WDhrVHN1T25ic2FLZWVlcW90V3JUSXJyNzZhdjlzWnRUVTFMemc3eUtFdDk5K2UwZC9GeUdNSFR2VzMxdW45cGVsMnYxK1RYMS9iYlVmWDF0RFB4L05HMDFZQUlCUUNDQUFXaHhsVG01YnUzYjlQdEtYa1FCQzRRT0lNOVZSVlpXVnRtRGVkM2Jqbjg2eHZZWVVlRnUrN1RYVXYvVzJzdy9ieVQ1NjkxV3JxQ2kzdFY1Z3dhYVJnUUQxVUI5QTRoWjhXdzIycHI0ZmRWTVFXTEpvZ2IzeTlFTjIwajRqYmQ4dGl1M0lIZnZaUDZaZDV0MjdjZGw5K05iTGR0WWgyOXYrSTByc29LMjcyRDl2djhZV3paOXIxZFZWL2lOUUd3RUVRTE9ob1BIMTV4L2F2WCs5MkFXQm4yL2J3eTQ2NVFENzVvdVAvRWVrWnVXeXBYYjkvNTFoVTNib1l6OGIyOUZ1bnZvYm0vWHhlMTR3cWZZZkFjbG9FNWErSVFGQVkxSS94Z2RlOW5Ebk5SZlp6OGFVMlMrOGJPUFd5ODV6UVNBVHlsZXZ0QWR1dnNST21ieVYrL2wvdS9yMzlzR2JML24zdG14a0lBQ3lSdEIwdDNadHRjMTg4MFdiZHVsNXR0K0lFdnZWWVR0NUZmdi8yaHF2c205STVXdFdlWUhxOS9hcktUdmJ2dDcvZStjMUY5cG5NOTl5bVU5TGJGSlV5aEQ1WFplVmxkbnBwNTl1aXhjdnRxdXV1c28vbXhuZUw0VjVJQkV3RHlTYXVNOEQyWlRhejY5dFV6K3ZvWitmS3YyYzZxb3FtLzNGUnpiOXdkdnR5UWVtMmVxVnkveDdtMTVacDI2MjYrVERiZTlEVDdETzNYdGJUazV1MnIrcmJFUUdBaUNXZ3FBeDUrdlA3ZG9MVHJWamR4OWlwMHdlYXcvZGRtV3Nnb2NzV1RqUEhyanBFanQ2MTBGMitzKzJzVHV2dmNnV2Z6L1AxbFpYWnl5SXhoRUJCRUNzcUtQNmh5VUw3YjRicHRycEI0eTM0L1lZYW8vZWZiMHRtRHZiZjBTOHFiUDl6cXN2c0NOMjZtZm5Iclc3UGYrdmUyemw4aCthWlNBaGdBQ0loVlVybHRrTGo5MW5aeDI2ZzAzWnZyZnJDSi8xOGJ2K3ZRMG5KNmVWNWVYbHV2YjhURkwyTlBPTkYyenEyWWU3ek9TQ1gweTJUOTkvdzhyWHJQWWZrZjFVWnBIREluMGc4VVVmU0RSYmJiV1Z2N2RPN1crUjZmWlpOUFQ5dGRWK2ZHMU4vWHpOc1ZndzV4dTc2OXFMN00wWEhuT1pSME1vTENpd2ZuMTcyRTRUeGxsSlNaRTdwNWRlWEZ4c25UdVZXVjV1cnBWWFZOaXNyNzYxQng2YWJ2TVhMSEtQeVRTVmwvcElkdnV2bzIzUGc0NnhqbDE2YkxJTTQweXZ2UDdmY0FyYXQyOXZaNXh4aGkxWnNzU3V2UEpLLzJ4bWVCOUFBa2dFQkpCb0NDQU44L3pLaW5JMzlQYTZDMCszT2JNL2QzMEZEYVYzejY3MjI3T1BkNEZpVTY5WDFJUTI0OFBQN2ZKcjc3Q1ZLeHN1VzhndktMUytnNGJiS2Y5N3JXMDJiTFRsNXVYNTkyUVBtckFBTkNyMVpSeXoyMkQ3N2RGNzJMZGZmdEtnd1NNL1A4L08rZVV4MXFWemg1U0NoK1I2MmNpb0VZUHQ3Rk9QOU04MERBWFJMejU4eDg0NGNGczdZdWYrOXZGN3IvbjNaQThDQ0lCR05mUFpoMnpOOTNQOG80YlZ5dnRYVlZXMXlVeXFOZ1diRlN0WCtVY05yY2JXTEpwbmoxNzVHLzg0ZXhCQWdIcW80a25jVkxFa2JuRzd2L1pXKy9HMXQyVFBTZHlTUFNkeFMvYWN4QzJaWlF2bldZODJoZGEzcE1DS2MxUExDc0txcUt5MHMzNTdxZDEyMXlQMjNzeFBiZWtQeXplNVVLSmU5OExGUyszTyt4NzF6elFjdmY5K0pmbld5eXNQVmNaMWxWbGM2YmNYK1JYVEJ4SmY5SUZFd3dXbG9qMC9tUWN1T2N0ZXV2K3YvcEhabXFwcVc3aW15bFpWcC8rendpZ3VLclJSV3c2MnpwMDZXTnZTRWlzb3lIZm5TbG9YdTg1ekJacjNQL2pNZjNUREtNbHJaWjBLODZ3d0w5Yy9ZOVpyeUdnNzY5WVhMQ2NuZTc3WGs0RUFhRlJWbFJYKzNqcEZYaVdxYitCOXZXL2lwVjdGMnRCV3J5bTNWOStZWVE4Lzlyejk3ZDVIN1pZN0hySnJiN3pYcGw1NXE5MTI5eU1OR2p6YTV1ZFl2ellGMXJPa2NJUGdJVFZhOVRkRVFHNUtCQkFBamFxNnN0TGYyNUFxMU81ZXhkcmZxMkE3Rkd4WXVXWXpoY1JPaGJrMm9MVEF1clV1c0lMYzVOV3VSbitGeWVpYVVrWUR5S2JTWFNEYjZET2R1T2tQUEhGcjZ2dXpVZTBNcExaOHI0THRXSlJuQTBzTHJZdDNtNjBVQXJzVmUrK2piYUdWRmVaWjNpYWFwckp4MlJNeUVBQ05xcnFxL2dBaUNwYTVPYTJzdlZmeGJ1WlZ3RDFiNTF0K2xudy9MZlplZCsvV2VUYkFlOTF0Qy9Jc3h3LyttMUt6VnNPWkNTQUFVS2RXcmRLcmRsUUJsK1RuV2o4dkkxSC9RWnU4SE5jc0ZDZDZSMlg1T2RhL3RNQjZlNit6T0Q4dnBhQ3hnU3hzd01sSUFNbldWQnBBNDh2TnovZjMwcU1LV2YwSDNiMXNSQlYxcDRKY2E0USs5M29WZURWbzkrSTg3L1VVV3VmV0JaWWZZUVJWdW9FMURyTHZGUU9OS0xHL1Fac3FzY1N0cWUvZjFGYjcrYlczWk05SjNKSTlKM0ZMOXB6RUxabmN2SEFCSktDZnEvNkVzcUk4bDVYMDlnSks2MXp2Ly9QdmIyaXFOTnQ2V1pBNisvdTJLYlRTZ2p6WDNCWlZLKzluMUZWbWNVVUFBZENvb2dhUWdDcGJOVzhWNStkYXo1SUNmL1JXVG9QMWxSUjVGWHhYTDJncCsrbXFQaGt2Rzhwa2hiOHVBeUdBQUVDZGtnV1FiajI2MmVubm5XN0huMzZjamRsNnRCVVVGUGozcE1abEpXNzBWcjZYRlJSWUw2K0NiNU1YUFN0UkUxbDdMeWlwNzZXM3Q3VXR5UFd5amN3R2pvQUxJTmtWUHpJYlFMSXQvUUxRK0pMMWdSeHcrTSs4SU5MVkJtdyt3TnMvd002ZmVwNXR2K3YyL3IycGMxbUpWOEczOXJLUzdxMEwzTnlMTGtXNVZwVG1raW1hOEtjZ3BNRFIyUXRLNm52UnoyN0lPcTZWQWhNWkNOQjhCSlZHc0cycUQ2Q3g3ODlHeVRLUTdqMjcrM3ZyeWp6ZkN6S1RmcnFuL2Z6WVEvMno2ZFBQVWJiUXZqRGZldnROWEpyUXA0N3ZaTnA1UWFOYlVaNXQ1ay80VXhCU01OTFBpYXB6dDg2MjUrUTlYWUNzU3liK244WkdBQUhRcUpJRmtFVUxONzZBa3lyVUxVWnZZV1BIYjdnZVdSZ3VLSGxaUkFjdm0raFhXbVFEdlNEUm96amZ1bm1iT3VFVk5McDZRYU50WVY3RzE2S2FmTWhrTytPOE0yekgzWGF3WTA4OXhyMm5aRnJsNUdaZEVNbElTV1hyTnlFQWpTOVpBUGxrNWlmKzNvWlVvVTdjYTFmL0tIT1VtYlFweUhWOUd1cUViNGdGRFBQeTh1eVlVNDYybjB3WTUvMzhkWUZCLzg5QlJ4N283cXZOWFZDcUpRWVFBRWhWc2dEeXpPUFB1cldna21sWDFzN2FsTGJ4ajdKRFVYR1JuZmsvdjdSQlF3ZHRsRldvZWE1bjM1NytVYUoxelpUWmhBQUMxS04ybjRQK3dCTzN1TjFmZTZ2OStOcGJzdWNrYnNtZWs3Z2xlMDdpbGt4T2tnQlN2cWJjM256bHJhVFAwZi9UdG4xYi95ZzdISGI4WVZiV29jdy8ycERlNC9JZmx2dEgyWTBBQXFCUkZSUzE5dmMyOU05Ny8ybXpaODNlS0lqb2VGV2pYUjB3T21WTEF3ZlYzVm0rY3ZsS1c3eHdzWCtVM1RMYUI2SnZDZ0JRbjZLU1VuOXZZMys5L0FhYi91aDBXN2xpNWZwNlpmYVgzOWpTeFV2ZGZqWVlzc1ZnTjZzOEdWME44WkVIL3VVZlpUOHlFQUNOcXFpay91YW9aeDkvemk3NjlmL1pmNS8rTy92ZEwvL0gvbnJaajFjdmpEMHZib3o2eVNqL1lHUFBQZkc4elhoN2huK1UvUWdnUUQwUzIvdTE2VnR4NHRiVTkyZWowbGFyclgxQmxiZFgvN1hKMWFsZVdaSDg0bE54bFp1VHU4R2Nsb0IrVjdPL25PMnlxNDJ0dFRLdlBJYTNML2VQc3djQkJFQ2pxbHc2MTZzc0syMTR1d29yek1tK2EyRFVwM3B0dGMzNWRxNS90QzV3cU5ucXFVZWV0dXN2cloxSjFWaHBYcldOOUFMSE1LODhjbHRsWHprUVFBQTBxdkpsNnlZTnRpK3NzVEVkSzJ4QVNZWGx1bXlrR1FRUzd5MW9NTUN5SDVhNXdMRncva0tiZHUydDl2eVR6L3NQa0JvcjhnTG4wTGJsTnFLc3d0cWt0K3hYckJCQUFEU3F0UW1YdEZWZmMvZVN0YlpWcDNMcjA3clNXaldEUUxKb3dTSzc1SGVYMk1YL1BkVXV1K2h5KytLVEwveDdhaXkvMVZvYlZGcGhvenRVV0ljaU5WSDZkL215clZreUoyaExqYkxObVRQSC9iQWVQWG9rdlQvS0JqU2w0RE9ZK0ZsVVgwUncyOVQzQjdTZjdGalBTM3h1N2VOQVF6MC9tYlhWRzEvU05zLzdLdHU3VGJWdDFiSGN1aFZWZVlGazQvOGptMVJWVmR1eXBjdThBdE5SalpkaDFkaUFOaFUyMW50L1hZclhXcktKN3pWZXh1SS9ZYjJnSE9PNlpTUUQwUThDbWlOOXRsVmh4dlUyRzYydHFydGp2Q0RYYkdEYkt1OGIraHBybDZlTzl1d09KRG5lNisvdFpWWmpPNjZ4Ymw3Z3lLMm54bDFiV2U0SGtleEJFeFpRajFRcThhYThEVFlkSjU2THkzRXlOUWxOV0hVcHpqTWJYbFpwbzh2V1dFbHU5blcwZXlWZ1hRdlhCWTdlSmRXVzd3VkdyMWpxVmJQV2U1OTFsRmxjRVVDQWVnU1ZZVnh2czlIYTZ0U0c1bnB2MFZybm00M3NVR0Zqdkl4RUhjOTUrWG5XcVVzbjY5Q3BnLytvT05Idm84YmE1MWZaT0M5d0tKTlNScVgza1lxYW11ektQaVNqQVNSYlA5QkFYZXFydk9OeUcrekg4VGlaK3Bxd2t0R1BVVWFpRVZ0bi91bzRPL04zdjdTei8vY3NPL2EwWTlPK2NtSERxYkUyZWRXMmRhYzFia2h1S2hsSGJXcSs4a3JQUDhvT1pDQkFQWUpLTWE2MzJXaHQxYWFic0pKcFhkYkJ5bnIyY2U5ZDIyYURCOXF2THpySGlsb1grWTlvQ212ZFhJNnhYb1kwc2tPbEd3emd2YlJ3YW1qQ0FwcVZWQ3J4cHJ3Tk5oMG5ub3ZMY1RLcE5tSFZWcmxxcFp0YmthaDFTV3M3NG9URC9hUEdGRXdDckxBdE8xUlkwY2FYOTBoYnRuV2dDd0VFcUVkUUdjYjFOaHVsMjRRVnFLb290emt6M3ZLUGZ0UzVZNmtOYlJkMHRqZTBHbXViWDJWYnRsL2pBa2ViZ3N6OURsd0F5YkxmS1FFRXFFY3FsWGhUM3diN2NUeE9waVprQmlJekhyblhsczMvY2FrUVpTVHZQWFNYZFNpc2NaM3R3N3hBMHJxQkFvbUdGWTlvWDI1YnRLKzAwZ2JwZXNtK0x3UXBCWkExYTliWXlwVXIvYVB3RmkxYVZPZFZ4NEE0Q2lyRnVONW1vNXk4OExXdnZxWC9lOXJWTnYvemo2eGl6V3A3Ky81YmJlbTNYN243dkNLeE1pK1FqTm9na0VRdEl6VlZyY3M0Tkt5NHJaZHg2UDlwQ0xvbWVvUDk4QWFTVWdCNTl0bG43WW9ycnJCWFhubGxvemJJVkt4YXRjb2VldWdodSthYWEreVRUNUpmK3hpSW8xUXE4YWE4RFRZZEo1Nkx5M0V5T2ZuUk9yMnJ5dGZZbTNmZGFFOWQvRnViLzhsTS8reVB2UDkrZlNCUnh0Qm0vWVRFVklQSnVzZTJkWUZENjFVcDQ5QjdXM2R2UThuSnpYZGxsMDFTQ2lBREJ3NjBxcW9xbXo1OXVnc2tMNy84c3ExWXNjSy9kOTIzTktuOWdWSEc4Y1FUVDdqbnZQLysrKzV4L2Z2MzkrOEY0aStvRE9ONm00MXlDeHBuMUpSWFJDNWoyTklMQUNQTHlxMTlmclcvUkVwZDVlYVZxN2RwSHNjbzcvRmJORkxnQ0xUS1ZVOThkZ1dRVnQ2SGNKT2ZRbVVkbDF4eWlXdktrdUREMjZsVEordmJ0NjhWRlJXNTdLU3dzTkRHang5dml4Y3Z0cSsrK3NxV0wxOXVPVGs1N3ZtNjNXeXp6ZXpRUXc5MVB5TU5ML2kzQ09IdHQ5L2UwZDlGQ0dQSGp0Mm8wbzdicldoZjRucWM2TTJyVHJDdm5yclpQMm84ZWlscnFzM21yYzYxNzlma1dXV05YcU0yTFhKWVk1MkxxcXhiY2JVVk5WRkxVcnYrSTIyM0s5NzBNaEh2QmZpQ2NveXJsRElRVmY1YmJybWw1ZnB2TFBoUUxGeTQwTjU5OTExNzlkVlgzYkVDeklzdnZtZ3paODUwd1VPQ0ppLzFmWXdjT2RMdEE5bENmOEQ2dk1mMU5odEZiY0lLeXlzeU55R3hmMm0xamVsWWJzUGFsVnZYb2twM3ErTitiYXJkL1hwY1U4ajF5cVZWc2xVV1l5emxWenRxMUtpa0hlQUtFRUdRMElkYSs4aysyTXBPQmc4ZTdCOEIyYUcreWpzT3Q4R200OFJ6Y1RsT3ByQnRSMyt2NldqQ24vcEpObXRiNVc0alRRRE1GTy8vVjlsbGs1UURTUGZ1M2ExangvUi84Zm9RS1hOSnpHQ0FiQkZVaG5HOXpVWWROaC9uN3lGUjY4NTkvTDNza1ZhK05IcjBhUGZCVFljZVQvTVZzbFVxbFhoVDN3YjdjVHhPcHR1WTNhM1g5Z2Y2UjltaGJiZWUxbnYwMXRaM3ErMHN0d0hXMzJvL1lMU05PKzFHL3loN3BCVkFsRVhvdzVFT1BiNWR1M2JXczJkUC93eVFQWUpLTWE2MzJTZ25OOC9HbjNPM2JYSDRSVjRCcDFVRk5icWkwblkyN3VmSDI0VGp6N1NSK3gxaUkvWSt3SGI2ZjcvMTc4Mk1udHY5ekhiOTg4dVczN3JVUDVNOTB2cnRsWmFXdW1HNCt2Q21TaDN3WVRJWElBNVNxY1NiOGpiWWRKeDRMaTdIZGRGamhoMzhHOXZwRDg5WWJuRm1LODc4NGhKcmxZSG1jbVVkTzUzeUcrczZhSmlyeHdLRnJVc3lGdmlHVDduQXR2MzEzWTAydERuVDBpNEZCWU9nMHp3VitoQXBjd0d5VVZBWnh2VTIyM1Vac1lQdGZkTm4xbVhVUlA5TU5Oc2MvZ3ZiNDV5TGJOSnZwOXI0bzA2eGpnTTI5KzlKajVxcGZuTFlDWlpYVU9pZitWSDVxcFZleFpiK2hPcEV1VVVsdHZQRkw5andRODVmTndNOVM2VWRRSVlPSFpyV0d2eTlldld5c3JJeS93aklMcWxVNGsxOUcrekg4VGdWUmUyNjJJNi9mOXpHblBKWC8wdzRIZm9Nc0U1K3dGREcwTEh2UU50bXlrbGVGdkZiS3loSkw4dnBQWHE4RmRieG5NcnkxZjVlT0YxR1RyUjliLzNHT2crZjRKL0pYbWtIa0x5OFBCcytmTGo3QmVtRHNpbktXSUJzRlZTS2NiMXRMalQvWWJNOWo3UDk3cGhyZWNWdC9iUHA2VGx5NDlGZEtxYzJIVHZiMWxOT1RQbWJ2aDQzZU9jOTNYT1RLUzV0NSsrbGI5d1p0OWlPRno1dUJXM2ErMmV5VzZpR1BNMEpVVE5XWFFVY1VKQVpObXlZZndSa24xUXE4YWE4RFRZZEo1Nkx5M0c2aXNxNjJ1UzdGOWpRZzgvemp0THJONjF2ZEZUYnJqMXMyRzc3K1VmMUsrM2FQV25UMVkvUzc4OHQ3VFhFOXIxamp2V2ZlS1FMbHMxRnFIZlNwMDhmTjdLcVB2b1FEUmt5eEMxekFtU3JvREtNNjIxemxKT1hiMXRNdWNBbTNmaXBGWFZJZmZUbTNKbnYrbnNiVTNsMTdMOVpTcFYzYWVmdTd2SEpWSmF2c1ZkdXZ0dy8yclJXdWZtdW8zeVBhOTYzb3ZaZC9iUE5SNmdBb3NMVnZJNjZDbG4wNFdidUI3SmRmWlYzWEc2RC9UZ2VoNlhudHVrMndQYStaWllObUhTaWY3WitTNzc3MnRiV2M3bUlWSmRMWDdGb3Zuc1BpYlNNL1BkZmZXNVBYL0xmdG1MaEF2OXMvVXA3RDdWSmYvM0Vobm5aVkU1ZVhxVHlpS3ZRdVpTQ1ErMUNUcVRNUTRzbkF0a3NxQlRqZXR1YzZUM21ldG5JMkpPdnRZbFh2R0d0dTlXL2tuZmxxaFgyOW4zVDZpeVh2TUpDeTBtaEgrU0hPZC9ZZHpQZXN1cXFTdmV6bHN6NTFwNjU4dmYyK3UxLzhRS1Vsb2F2bjdLT1FmdWY3bVVkNzNsQnNKOTdIODFWU3F2eDF1WEdHMiswdVhOL3ZEcFlRRXVXakJzM3p2YllZdy8vVENTc3hoc0JxL0ZHRS9mVmVBTTZsdUJjWEk0enFXWnR0YjEzOHpuMitiK3VNYTkyOTg5dXJQdXdVVFo4ejhsdUVtQ2lsWXNYMmd2WFhXeHJxellkQkVUTHErY1hGbG1GRjVoUzFXN0FLTnY2N0R1c25aZDlCR1VSUlNaK1JrT0sxSnN6WnN3WWYyOURXcnFFdVI5b0R2UUhyTW93cnJjdGlacWdSaDMzWjV0NDZXdld0dDhXL3RtTi9lZWo5Mno2RmIrM0wxNSsxcW9yMTEwK1YwMWJzLzc5WE1yQlEycThJSlZxOE5BS3d5T08vcFB0ZnVWYjFyN1BNUGY3YVFraVpTRGw1ZVUyZGVyVWpTWVdkdWpRd1U0OTlWVC9LREl5a0FqSVFLTGhlaUNaT2M0ME5TVjk5dEFWTnVPMjg3eUR1b05DYmtHaHRlM2V5OHFYLzJDcnZBeWtJWFFjdHAxdGZlWnQxbVlUVFd4aEJPVVlWNUV5RUMzUnJvbUZpVzlTKzNWbEprQzIwZWRabFdCY2Ixc3FyYWMxK0wvT3NrazNmR3hsbTQzMXoyNnN1cUxjbHN5ZTFTREJROWQyMythY3UyeVhpNTl2a09DUkRTSUZFS205d0tMMlI0d1k0UjhCMlMxWnBSMm4yMkRUY2VLNXVCdzNKUDAvcGQwRzJLNlgvdHUyT2ZjZTEzbmRXSHB0ZjVEdCs3ZTUxbWVIZzczWEVia2F6VnFSMzdsR1dpWE85Umd3WUlDMWJSdHVKaWtRTjBGbEdOZGJyTXRHK2t3NDBQYS9hNEgxMmVrdzcwekROZnZrRlpmYXhDdmZzdkZlNWxIWWhpV2FJZ2NRelRiWHpIUjlvTFV4OXdQTlNTcVZlRlBmQnZ0eFBHNU1CU1Z0Ylp1emI3YzkvakxUOGtzNytHY3pRODFWWTA2NXppYmYvYjExR01qcTRvR001RjdCbkJBRkU4MCtCNXFMb0ZLTTZ5MDIxcTdQVU52L3puazIrSUJmdTRvL0VxK2MydzhjYS92ZnZkQUc3bkc4bXlXUEgyVWtnSFRyMXMyNmR1M3ErajdTV2FrWGlMdFVLdkdtdkEwMkhTZWVpOHR4VTlHRXdaRkgvY0gyOHdKSngyRVRYQ0JJbHk0eHU4c2xMOXR1Vjd5Kzdob2pJWDVHY3hkcEdHOGlEZW5WU3IwTmNOMXpodkZHd0REZWFMYmFhcXYxRldOY2IwWDdFcmZqdUpqMzNqUDI5alVuMmNwNVgvcG42cGJYdXExYnYycnpmVS94M2svVGRwQUg1UmxYR1NzZERlbHRnT0FCTkNsVmhQb2pqdk50c0IvSDQ3am9ObXBYbTNUOVIxNWcrTDNsRnJYeHo5Yml2ZDUrRTQrMi9mODJ6d2J2ZDVwMzJMVEJJeHRRUWtBOWdrb3hycmRJbmZvdmhoOXlucnZteUtEOXovRFByclBaM2lmYjVIc1cyVS9PdU1sTlBrUnFNdGFFMVlCb3dvcUFKcXhvV0FzcjJuR2NWYTVlYm5OZS9hZjFtbkNBNWNYMG11UkJlY1lWR1FoUUQvMEJxektNNnkzQ3l5OHV0WDY3VElsdDhNZ0dDbSt4L2hURy9ZOUVmOGh4UnZsRlEvbEZRL2xGRS9meUl3TUJBSVJDQUFHQUZrRFp6SW9WSzl4V240cUtDbHU2ZEtsVnBiRDBQVTFZRVpFQ1IwUDVSVVA1UmRPY3l1L3h4eCszTjk1NHd6cDM3bXdubjN5eWYzYWRqejc2eUo1ODhrbGJ0bXlaTzlZbE4vYlpaeC9yMy8vSFZZUlhyVnBsLy9yWHYreVRUejV4LzYrbVpXaVpxa21USnRVNVJZTU1CQUN5M0gvKzh4OTc4ODAzcmF5c3pHVVFpV2JQbm0wUFBQQ0E5ZTNiMTA0ODhVUTcvUEREM2FUdnUrKysyMzc0NFFmL1VXYjMzWGVmZSt5QkJ4NW9KNTEwa2syWU1FR2pPRzM2OU9uK0l6WVdPWUFvTW5YczJOSDY5T25qTnIwQkFFRGpVTGJ3NktPUDJyQmh3NnhYcjE3KzJSKzkrT0tMMXE1ZE81czhlYkpiZGtvcnB2LzBweisxeXNwS2UrZWRkOXhqdnY3NmF4YzhkdDk5ZDNlTkp5MU50ZE5PTzltZ1FZUHNyYmZlcXJNNUszUUFVZXBYVWxKaVcyeXhoWjF6empsMnp6MzMySjEzM21tbm5IS0tTNC9pbmhvQ1FIUHcvdnZ2MjRJRkMxemxYNXV1RnF2Z01IRGdRTGZZYlVDQlJKZmQrTzY3Nzl6eGwxK3VXK0pGQVNQUjVwdHY3b0tIZm40eW9RS0kwcDhlUFhxNGlIYkREVGU0dEVqUjdJTVBQbkFaeUhISEhlY2lIZ0NnNFdnTlFqVXg3YkRERGttdnc2UU9jd1VSdFJMVnBycDY1Y3FWYmw5OUk4WEZ4ZGE2ZFd0M0hBaGFsT3JxZUU4cmdDaUM2VVhxa3JYbm4zKytYWEhGRmE3RFJtMXB6ejMzbk0yZlA5KzlFTDJwNnVwcS8xa0FnSWFnZWxmckVJNGZQOTQvczZFZ1FPZ3h0ZW1jT3M1Rmo2dnJNYko2OVdwM1cxdktBVVRCUTJuUGxDbFRiTnEwYVhid3dRZmJ1KysrNjVxdEZEZ1M2VVVwaUFBQUdzYjMzMy92T3M3MzNIUFBUUzVrcXl3a21jVG4xZmVsUC9Jb0xHVWVSeDU1cEYxNDRZVXVtTngyMjIzMjczLy8yLzJuNnNSWnMyYU4vOGgxblRycEREOERBS1JIdzNMVjJkMm1UUnMzQ2t1Yk1nWFZ5ZHBYblJ3MFNTWFd6d0dkVXorMnFQbXFyc2RJOExqYVVnNGd1bENVcm4vKzRZY2YycjMzM3J0KytOZWlSWXRjRTViT0F3QWF4N3g1ODF5Z1VEOTBzSDN4eFJldXYwTDdyNzMybWdzZ0d0QzBjT0ZDLzFucjZBdSt6clZ2Mzk0ZEt3aXBIenVZSnhKUS9TNTE5V21uSEVBVWlUUkpaY2FNR2U1WVRWUlBQLzIwL2VVdmY3SGx5NWZidHR0dTY4NERBQnFlNW1xY2R0cHBHMnlEQncrMjB0SlN0Njk1SFBuNStkYXpaMDhYV0JLSDRzNmFOY3QxTldpVWxXaU9pSHo2NmFmdVZoUmtWTjkzNnRUSmpheE5KdVVBb3Npa29icWEwZmp0dDkrNndQSEtLNis0VHBiamp6L2VaU2NBZ01haHJFR2pwQkkzdFJTcGkwSDdHaTByMjIrL3Zlc2tEMXFLWG4vOWRYdnd3UWRkbjdhbVlZZ0NpWTQxb3V2VlYxOTFqOVBFd3JsejU5ckVpUlBkWTVMUlpJMlVPeXVVQ2dXcFR0QkpydUZoRjExMGtYWHYzdDExcW92R0ZxdVBSSStMS3U1OUtjMXBLWVNtUVBsRlEvbEYwOXpLVHdGQWxmNFJSeHpobjFsSFV5eGVldWtsMXlSVlZGVGtBb1lDUStLd1hUVjlQZlhVVXk1YlVkM2RwVXNYRjN5R0RCbmlQMkpqYVFXUVpQU2ZxR05kMFlzQUVqK1VYelNVWHpTVVh6UnhMNytVbTdBQUFFaEVBQUdBWms3TlVwZGZmcm5yZWxCV2M4c3R0MlJrNUN3QkJBQ2FPUTF5VWovMTg4OC83eFpRVkVlN0ZsK01pZ0FDQUMzQVhudnRaZSs5OTU1Yi9tUy8vZmJMU1A4UEFRUUFXZ0FOOGRXbW1lckJFTitvQ0NBQTBBSm9pTzZJRVNOczVNaVI3dXFGbVVBQUFZQm1UdGNFMGV4ekxmdSs4ODQ3dTZrV3VuUnRWQVFRQUdqbXRCanVVVWNkNVpxd3RIckkwVWNmN1M3RkVSVUJCQUNhQWZWdExGbXlaUDAxUGhKcExTdk5PdGN5Vk5xMFhsYXlpMHlKbG9uLzZxdXZiUEhpeGY2WnVxa2JQdEpVUjJhaU01TTFDc292R3Nvdm11WlVmbG9sWGMxU1dnZExpeWttMHFVM05Qb3FXRkJSbWNnKysremora1FDQ2hqMzMzKy9XK1Uzb0V2aEhuamdnVWt2TmlWa0lBQ1E1VFJSVUN2cDZndDk3YUNqQlhDMWN2bzIyMnhqNTU1N3JwMTY2cW51a3VRUFBmVFErbVhlZGNFcExaWmJVVkhoTGxIK205Lzh4bDJ5WE5kS2YrS0pKOXhqa2trN2dHZ0NTckRwS2xXNnJTdUtiK3ArQUVBMGFycFNKVDl1M0RnWFFHcFQ5cUgramwxMjJjVmxFbXJPMm5mZmZWM1FDRnFOUHYvOGM5ZDB0ZnZ1dTd2V0pHVW9HcTJseVlaYTBsMkJKWm1VQTRnQ2dkYUZIelZxMUFhYmxnTk8xcGFtSzFnTkh6N2N2UWlsUVhvK0FDQ3pkT0VvWFlsUW82dHFVNVBWbkRselhCMmMrRVZlUVVRWGs5SUZxV1QyN05udS9uNzkrcm5qd0lBQkExeWdVWEJKSnVWYVhiMzR4eDU3ckV1RkhudnNzZlhiWFhmZFpUdnV1S09MZ2dGTlVoazZkS2pkZnZ2dDlzZ2pqN2lyWTJrcVBVRUVBREpIMTJsNjRZVVgzTkxzV3FhOU5pM1JMc0dWQnhQcG5LNFRJbnFjT3RscjkzVUVWeUlNSGxkYldobUlzb3IzMzMvZnJyLytlcmRkZDkxMTdzSlMxMXh6emZvckZZcFNvRDMyMk1PMXNkMTAwMDMyNG9zdjJwUXBVMXpQUHdBZ00vU0ZYczFXYWcxS0pxajRrM1dDNjJxRnlseEVqMU96VlczQjg0TEgxWlp5QUZHRVVzYng4Y2NmKzJmU296UW91QWdWQUNDYWI3NzV4cTJvTzJuU3BBMmFweElGclQ2Smw3TU5xTE5kUVVUMHVMb2VJOEhqYWtzNWdLZ1RSUjB1RHp6d2dDMVlzTUJtenB6cGpsUGROSVJNMTFVSEFFU25wVW02ZHUxcVAvendneHRwcFUzN3FxdTF2M1RwMHZWWEhFeFc5eXFyVUt1U0ZCY1hKMzFNTUtkRVY2Sk5SbUVycllIYVNuUFUxcFp1TnFFTUpNeThFTWFSUjBQNVJVUDVSVVA1UlZOZitWMTIyV1cyZlBseS8yaGp1KzY2cXh1Nis4Yy8vdEgxU1I5d3dBSCtQZXZxNDZsVHA3ckwxV3E0cmk2Ris4b3JyN2o1STVwSEV0QmxjSjk5OWxrNzg4d3prM1pCcEIxQUdoc2Z3R2dvdjJnb3YyZ292MmpTTGIrLy8vM3ZiaUwzNmFlZjdwOHhONmxia3dOMUx1aG9WNS8xZ3c4K2FJY2Njb2dOSGp6WXpUelhvQ2NGblFrVEpyakhhR0NVK3JpVm5SeDMzSEh1WEcwTWl3S0Faa3p6UDlTc05XM2FOSmRsYUNYZWh4OSsyQTN0M1h6enpkMWpOSHkzZi8vK3JxdEI5Ny84OHN0Mjg4MDN1eVl4RFlpcUN4bElSSHdEaklieWk0YnlpNmE1bGQrcnI3N3E1bXpvZ2xHSjFPR3VDWVdMRmkxeVdZZ0N4N2JiYnVzbWV3ZlV4YUFtSzYzYXEzMk43dHB1dSszY2xRenJRZ0NKaUQvZ2FDaS9hQ2kvYUNpL2FHakNBZ0NFUWdBQkFJUmc5djhCNGhNT3BJK1hsdHNBQUFBQVNVVk9SSzVDWUlJPVwiO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldE5vcm1hbCgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUJDQUlBQUFDUWQxUGVBQUFGRG1sVVdIUllUVXc2WTI5dExtRmtiMkpsTG5odGNBQUFBQUFBUEQ5NGNHRmphMlYwSUdKbFoybHVQU0x2dTc4aUlHbGtQU0pYTlUwd1RYQkRaV2hwU0hweVpWTjZUbFJqZW10ak9XUWlQejRLUEhnNmVHMXdiV1YwWVNCNGJXeHVjenA0UFNKaFpHOWlaVHB1Y3pwdFpYUmhMeUlnZURwNGJYQjBhejBpV0UxUUlFTnZjbVVnTlM0MUxqQWlQZ29nUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0S0lDQThjbVJtT2tSbGMyTnlhWEIwYVc5dUlISmtaanBoWW05MWREMGlJZ29nSUNBZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJZ29nSUNBZ2VHMXNibk02Y0dodmRHOXphRzl3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzQm9iM1J2YzJodmNDOHhMakF2SWdvZ0lDQWdlRzFzYm5NNlpYaHBaajBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5bGVHbG1MekV1TUM4aUNpQWdJQ0I0Yld4dWN6cDBhV1ptUFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzUnBabVl2TVM0d0x5SUtJQ0FnSUhodGJHNXpPbmh0Y0UxTlBTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZiVzB2SWdvZ0lDQWdlRzFzYm5NNmMzUkZkblE5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVVYyWlc1MEl5SUtJQ0FnZUcxd09rTnlaV0YwWlVSaGRHVTlJakl3TWpNdE1EVXRNRFpVTWpJNk1qZzZNRFlyTURJd01DSUtJQ0FnZUcxd09rMXZaR2xtZVVSaGRHVTlJakl3TWpNdE1EVXRNRFpVTWpJNk16QTZNakVyTURJNk1EQWlDaUFnSUhodGNEcE5aWFJoWkdGMFlVUmhkR1U5SWpJd01qTXRNRFV0TURaVU1qSTZNekE2TWpFck1ESTZNREFpQ2lBZ0lIQm9iM1J2YzJodmNEcEVZWFJsUTNKbFlYUmxaRDBpTWpBeU15MHdOUzB3TmxReU1qb3lPRG93Tmlzd01qQXdJZ29nSUNCd2FHOTBiM05vYjNBNlEyOXNiM0pOYjJSbFBTSXpJZ29nSUNCd2FHOTBiM05vYjNBNlNVTkRVSEp2Wm1sc1pUMGljMUpIUWlCSlJVTTJNVGsyTmkweUxqRWlDaUFnSUdWNGFXWTZVR2w0Wld4WVJHbHRaVzV6YVc5dVBTSXhJZ29nSUNCbGVHbG1PbEJwZUdWc1dVUnBiV1Z1YzJsdmJqMGlNU0lLSUNBZ1pYaHBaanBEYjJ4dmNsTndZV05sUFNJeElnb2dJQ0IwYVdabU9rbHRZV2RsVjJsa2RHZzlJakVpQ2lBZ0lIUnBabVk2U1cxaFoyVk1aVzVuZEdnOUlqRWlDaUFnSUhScFptWTZVbVZ6YjJ4MWRHbHZibFZ1YVhROUlqSWlDaUFnSUhScFptWTZXRkpsYzI5c2RYUnBiMjQ5SWpjeUx6RWlDaUFnSUhScFptWTZXVkpsYzI5c2RYUnBiMjQ5SWpjeUx6RWlQZ29nSUNBOGVHMXdUVTA2U0dsemRHOXllVDRLSUNBZ0lEeHlaR1k2VTJWeFBnb2dJQ0FnSUR4eVpHWTZiR2tLSUNBZ0lDQWdjM1JGZG5RNllXTjBhVzl1UFNKd2NtOWtkV05sWkNJS0lDQWdJQ0FnYzNSRmRuUTZjMjltZEhkaGNtVkJaMlZ1ZEQwaVFXWm1hVzVwZEhrZ1VHaHZkRzhnTWlBeUxqQXVOQ0lLSUNBZ0lDQWdjM1JGZG5RNmQyaGxiajBpTWpBeU15MHdOUzB3TmxReU1qb3pNRG95TVNzd01qb3dNQ0l2UGdvZ0lDQWdQQzl5WkdZNlUyVnhQZ29nSUNBOEwzaHRjRTFOT2tocGMzUnZjbmsrQ2lBZ1BDOXlaR1k2UkdWelkzSnBjSFJwYjI0K0NpQThMM0prWmpwU1JFWStDand2ZURwNGJYQnRaWFJoUGdvOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4KzBJZ1Z4QUFBQVlCcFEwTlFjMUpIUWlCSlJVTTJNVGsyTmkweUxqRUFBQ2lSZFpIUEswUlJGTWMvTTM3bVI2TllLQll2RGF1aFFZbU54Y2l2d21LTU10ak12UG1sNW8zWGUyL1NaS3RzRlNVMmZpMzRDOWdxYTZXSWxHeFpFeHYwbk9lcGtjeTVuWHMrOTN2dk9kMTdMbmdqV1ZVenk0T2c1U3dqUEJwU1pxTnpTdFVqRlZUU1JBdSttR3JxazlNakVVcmEydzBlSjE1MU9yVktuL3ZYYWhOSlV3VlB0ZkNncWh1VzhKand4TEtsTzd3cDNLUm1ZZ25oWStHQUlSY1V2bmIwdU10UERxZGQvbkRZaUlTSHdOc2dyS1IvY2Z3WHF4bERFNWFYNDlleWVmWG5QczVMNnBLNW1XbUpiZUt0bUlRWkpZVENPTU1NMFVjM0F6TDMwVWtQWGJLaVJIN3dPMytLSmNsVlpkWXBZTEJJbWd3V0FWSHpVajBwTVNWNlVrYVdndFAvdjMwMVU3MDlidlc2RUZRODJQWkxPMVJ0d09lNmJiL3YyL2JuQVpUZHcxbXVtTCswQi8ydm9xOFhOZjh1K0ZiaDVMeW94YmZnZEEyYTcvU1lFZnVXeXNTOXFSUThIMEY5RkJvdm9XYmU3ZG5QUG9lM0VGbVJyN3FBN1Izb2tQTytoUzgyNFdmUWd4R0NjZ0FBQUFsd1NGbHpBQUFMRXdBQUN4TUJBSnFjR0FBQUFBeEpSRUZVQ0psamFHajREd0FEZ3dJQVZialdQd0FBQUFCSlJVNUVya0pnZ2c9PVwiO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldFRvb24oKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFQOEFBQUFCQ0FZQUFBQVJrSGlqQUFBQmhHbERRMUJKUTBNZ2NISnZabWxzWlFBQUtKRjlrVDFJdzBBY3hWL1RTb3RVQk8wZzRwQ2hPdGxGUlJ4TEZZdGdvYlFWV25Vd3VmUUxtalFrS1M2T2dtdkJ3WS9GcW9PTHM2NE9yb0lnK0FIaTdPQ2s2Q0lsL2k4cHRJang0TGdmNys0OTd0NEJRcXZHVkRNUUIxVE5NakxKaEpndnJJckJWd1FSUUJnaERFbk0xRlBaeFJ3OHg5YzlmSHk5aS9FczczTi9qZ0dsYURMQUp4TEhtVzVZeEJ2RXM1dVd6bm1mT01JcWtrSjhUanhwMEFXSkg3a3V1L3pHdWV5d3dETWpSaTR6VHh3aEZzczlMUGN3cXhncThReHhWRkUxeWhmeUxpdWN0emlydFFicjNKTy9NRnpVVnJKY3B6bUdKSmFRUWhvaVpEUlFSUTBXWXJScXBKakkwSDdDd3ovcStOUGtrc2xWQlNQSEF1cFFJVGwrOEQvNDNhMVptcDV5azhJSm9PL0Z0ai9HZ2VBdTBHN2E5dmV4YmJkUEFQOHpjS1YxL2ZVV01QZEplck9yUlkrQXdXM2c0cnFyeVh2QTVRNHc4cVJMaHVSSWZwcENxUVM4bjlFM0ZZRGhXNkIvemUydHM0L1RCeUJIWFMzZkFBZUh3RVNac3RjOTNoM3E3ZTNmTTUzK2ZnQTRPWEtQdC83Sy9nQUFBQVppUzBkRUFQOEFBQUFBTXlkODh3QUFBQWx3U0ZsekFBQXVJd0FBTGlNQmVLVS9kZ0FBQUFkMFNVMUZCK2dIQkF3ZEoxajlXQnNBQUFBWmRFVllkRU52YlcxbGJuUUFRM0psWVhSbFpDQjNhWFJvSUVkSlRWQlhnUTRYQUFBQVZVbEVRVlFvejJOa1lHRDR6ekFLaGg1Z1pXQmc0R0JnWU9CRW8yRnNLSitYazRGQmlwT0JRWm9EUWt0eE1qQ0lzREV3U0hGQU1SZUU1c1ZtRGhjV08xZ1lHQmdZR01sSU52ajBNSTd3WkVpcy82a2JoZ0MwNFFqL3c3L0haZ0FBQUFCSlJVNUVya0pnZ2c9PVwiO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldEljb25MaWdodCgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sIHZlcnNpb249JzEuMCcgZW5jb2Rpbmc9J1VURi04JyBzdGFuZGFsb25lPSdubyclM0YlM0UlM0Nzdmcgdmlld0JveD0nMCAwIDE2IDE2JyB2ZXJzaW9uPScxLjEnIHdpZHRoPScxNicgaGVpZ2h0PScxNicgaWQ9J0xpZ2h0JyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnJTNFJTNDc3R5bGUlM0UgLnMlN0JmaWxsOiUyM2ZmZjtzdHJva2U6JTIzMDAwO3N0cm9rZS13aWR0aDouMXB4OyU3RCAlM0Mvc3R5bGUlM0UlM0NyZWN0IGNsYXNzPSdzJyB4PScwLjE3MDM5MjkzJyB5PScxMC4wMDI0NDgnIHdpZHRoPSczLjkwMDA1NjgnIGhlaWdodD0nMC45MDAwOTkzNCcgaWQ9J05ORScgdHJhbnNmb3JtPSdyb3RhdGUoLTY3LjUpJyAvJTNFJTNDcmVjdCB4PSc4LjgyOTUwNzgnIHk9JzEwLjAwMjQ0Nycgd2lkdGg9JzMuOTAwMDU2OCcgaGVpZ2h0PScwLjkwMDA5OTM0JyBpZD0nRU5FJyB0cmFuc2Zvcm09J3JvdGF0ZSgtMjIuNSknIGNsYXNzPSdzJyAvJTNFJTNDcmVjdCB4PScxNC45NTI0NjknIHk9JzMuODc5NTcxNycgd2lkdGg9JzMuOTAwMDEzOScgaGVpZ2h0PScwLjkwMDA5OTg3JyBpZD0nRVNFJyB0cmFuc2Zvcm09J3JvdGF0ZSgyMi41KScgY2xhc3M9J3MnIC8lM0UlM0NyZWN0IHg9JzE0Ljk1MjQ3JyB5PSctNC43Nzk1NDI5JyB3aWR0aD0nMy45MDAwMTM5JyBoZWlnaHQ9JzAuOTAwMDk5ODcnIGlkPSdTU0UnIHRyYW5zZm9ybT0ncm90YXRlKDY3LjUpJyBjbGFzcz0ncycgLyUzRSUzQ3JlY3QgeD0nLTEyLjcyOTU2NScgeT0nMTAuMDAyNDQ3JyB3aWR0aD0nMy45MDAwMTM5JyBoZWlnaHQ9JzAuOTAwMDk5ODcnIGlkPSdTU1cnIHRyYW5zZm9ybT0ncm90YXRlKC02Ny41KScgY2xhc3M9J3MnIC8lM0UlM0NyZWN0IHg9Jy00LjA3MDQ0OTgnIHk9JzEwLjAwMjQ0Nycgd2lkdGg9JzMuOTAwMDEzOScgaGVpZ2h0PScwLjkwMDA5OTg3JyBpZD0nV1NXJyB0cmFuc2Zvcm09J3JvdGF0ZSgtMjIuNSknIGNsYXNzPSdzJyAvJTNFJTNDcmVjdCB4PScyLjA1MjQ2ODUnIHk9JzMuODc5NTcxNycgd2lkdGg9JzMuOTAwMDEzOScgaGVpZ2h0PScwLjkwMDA5OTg3JyBpZD0nV05XJyB0cmFuc2Zvcm09J3JvdGF0ZSgyMi41KScgY2xhc3M9J3MnIC8lM0UlM0NyZWN0IHg9JzIuMDUyNDY4NScgeT0nLTQuNzc5NTQyOScgd2lkdGg9JzMuOTAwMDEzOScgaGVpZ2h0PScwLjkwMDA5OTg3JyBpZD0nTk5XJyB0cmFuc2Zvcm09J3JvdGF0ZSg2Ny41KScgY2xhc3M9J3MnIC8lM0UlM0NlbGxpcHNlIGlkPSdDRU5URVInIGN4PSc4LjAwMDA4MicgY3k9JzguMDAwMjU3NScgcng9JzMuNDUwMDgyMycgcnk9JzMuNDUwMjU3MycgY2xhc3M9J3MnIC8lM0UlM0Mvc3ZnJTNFXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0SWNvbkNhbWVyYSgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sIHZlcnNpb249JzEuMCcgZW5jb2Rpbmc9J1VURi04JyBzdGFuZGFsb25lPSdubyclM0YlM0UlM0NzdmcgaWQ9J0NhbWVyYScgdmlld0JveD0nMCAwIDE2IDE2JyB2ZXJzaW9uPScxLjEnIHdpZHRoPScxNicgaGVpZ2h0PScxNicgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyUzRSUzQ3N0eWxlIGlkPSdzdHlsZTEnJTNFLnMlN0JmaWxsOiUyM2ZmZjtzdHJva2U6JTIzMDAwO3N0cm9rZS13aWR0aDouMXB4OyU3RCAlM0Mvc3R5bGUlM0UlM0NwYXRoIGNsYXNzPSdzJyBkPSdNIDEzLjg1NzMyMiw4Ljg3NTUyOTcgSCAxMi40MTM0MjQgTCAxMi40MTMsNi43ODcgaCAtMS40MjUzMTEgYyAwLjIyNzAyNiwtMC40NDk0NjkzIDAuMzYzMjQzLC0wLjk0NTM5MTkgMC4zNjMyNDMsLTEuNDg4NTAwOCAwLC0xLjc5Nzg3NzUgLTEuNDA3NTcyNywtMy4yNDkyODkzIC0zLjE1MTE0NjYsLTMuMjQ5Mjg5MyAtMS43NDM1NzQ2LDAgLTMuMTUxMTQ3OSwxLjQ1MTQxMTggLTMuMTUxMTQ3OSwzLjI0OTI4OTMgdiAwLjAyODA5MyBDIDQuNTc2NDE5NCw1LjAzNjMxMTggNC4wMzE1NTI0LDQuODU4Mzk2OCAzLjQ1MDM2MDYsNC44NTgzOTY4IDEuNzA2Nzg2Myw0Ljg2Nzc1NjcgMC4yOTkyMTI5OCw2LjMxOTE3MjMgMC4yOTkyMTI5OCw4LjEwNzY4NiBjIDAsMS43ODg1MTM1IDEuNjY1Mzg1ODIsMy4zMTE3ODkgMy40MjQ1ODUxMiwzLjI0OTI4OSBMIDMuNzMyLDEzLjk3NiBoIDguNjgxIHYgLTIuMTEzMzY4IGggMS40NDQzMjIgeicgaWQ9J3BhdGgxJyAvJTNFJTNDcmVjdCBjbGFzcz0ncycgeD0nMTIuODAzOTEnIHk9JzguMzk3OTY4Mycgd2lkdGg9JzIuODk2ODc2NicgaGVpZ2h0PSczLjg4NjAzNzYnIHJ4PScwJyByeT0nMCcgaWQ9J3JlY3QxJyAvJTNFJTNDL3N2ZyUzRSUwQVwiO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGdldEljb25BdWRpbygpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sIHZlcnNpb249JzEuMCcgZW5jb2Rpbmc9J1VURi04JyBzdGFuZGFsb25lPSdubyclM0YlM0UlM0NzdmcgaWQ9J0F1ZGlvJyB2aWV3Qm94PScwIDAgMTYgMTYnIHZlcnNpb249JzEuMScgd2lkdGg9JzE2JyBoZWlnaHQ9JzE2JyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnJTNFJTNDc3R5bGUlM0UucyU3QmZpbGw6JTIzZmZmO3N0cm9rZTolMjMwMDA7c3Ryb2tlLXdpZHRoOi4xcHg7JTdEICUzQy9zdHlsZSUzRSUzQ3BhdGggY2xhc3M9J3MnIGQ9J00gOS4xNTYzNTg4LDEuMDgwNDAwNiAzLjY3MjkzNDEsNC42NDIwMTcgSCAwLjU0MzY0OTcxIHYgNi43ODQwMzEgSCAzLjc1OTA2MTIgbCA1LjM5NzI5NzYsMy40OTM3NzYgeicgaWQ9J3BhdGgxJyAvJTNFJTNDcGF0aCBjbGFzcz0ncycgZD0nbSAxMy4zNDc1MTgsMTMuNjc2NjQ1IC0wLjc2NTE1NywtMC41NjM1NjYgYyA0LjIyNzQ4NSwtNS41NjA1MjQxIDAuMjEwNDE4LC05Ljg4MTIwMiAwLjAzODI1LC0xMC4wNTk2NjQ4IGwgMC42OTgyMDQsLTAuNjQ4MTAxOSBjIDAuMDQ3ODIsMC4wNDY5NjQgNC43NTM1Myw1LjA2MjcwNzYgMC4wMzgyNSwxMS4yNzEzMzI3IHonIGlkPSdwYXRoMicgLyUzRSUzQ3BhdGggY2xhc3M9J3MnIGQ9J20gMTEuMzIxODY4LDExLjc5ODA5IC0wLjgyMjU0MSwtMC40NzkwMzIgYyAyLjE0MjQzNCwtMy41Nzg2NDc0IDAuMTE0NzczLC02LjM1ODkxIDAuMDI4NjksLTYuNDcxNjIzMiBsIDAuNzY1MTU2LC0wLjU2MzU2NjYgYyAwLjEwNTIwOCwwLjE0MDg5MTUgMi41MDU4ODMsMy4zODE0MDAxIDAuMDI4NjksNy41MDQ4Mjk4IHonIGlkPSdwYXRoMycgLyUzRSUzQy9zdmclM0UlMEFcIjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBwcml2YXRlIHN0YXRpYyBnZXRJY29uUGFydGljbGVzKCk6IHN0cmluZyB7XHJcbiAgICAvLyAgIHJldHVybiBcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0MlM0Z4bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnJTNGJTNFJTNDc3ZnIGlkPSdQYXJ0aWtlbF9WMicgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB2aWV3Qm94PScwIDAgMTYuMjggMTYuNTInJTNFJTNDZGVmcyUzRSUzQ3N0eWxlJTNFLmNscy0xJTdCZmlsbDolMjNmZmY7c3Ryb2tlOiUyMzAwMDtzdHJva2UtbWl0ZXJsaW1pdDoxNS4xMjtzdHJva2Utd2lkdGg6LjI1cHg7JTdEJTNDL3N0eWxlJTNFJTNDL2RlZnMlM0UlM0NjaXJjbGUgY2xhc3M9J2Nscy0xJyBjeD0nNC43MicgY3k9JzUuNDcnIHI9JzIuNTInLyUzRSUzQ2NpcmNsZSBjbGFzcz0nY2xzLTEnIGN4PScxMS4yNicgY3k9JzguMjgnIHI9JzEuNzUnLyUzRSUzQ2NpcmNsZSBjbGFzcz0nY2xzLTEnIGN4PSc1Ljk1JyBjeT0nMTIuMDUnIHI9JzEuMjknLyUzRSUzQy9zdmclM0VcIjtcclxuICAgIC8vIH1cclxuICB9XHJcbn0iLCIvLyAvPHJlZmVyZW5jZSBwYXRoPVwiLi4vRXZlbnQvRXZlbnQudHNcIi8+XHJcbi8vIC88cmVmZXJlbmNlIHBhdGg9XCIuLi9UaW1lL1RpbWUudHNcIi8+XHJcbm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgdGhlIG1vZGUgYSBsb29wIHJ1bnMgaW5cclxuICAgKi9cclxuICBleHBvcnQgZW51bSBMT09QX01PREUge1xyXG4gICAgLyoqIExvb3AgY3ljbGVzIGNvbnRyb2xsZWQgYnkgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAqL1xyXG4gICAgRlJBTUVfUkVRVUVTVCA9IFwiZnJhbWVSZXF1ZXN0XCIsXHJcbiAgICAvKiogTG9vcCBjeWNsZXMgY29udHJvbGxlZCBieSB4clNlc3Npb24ucmVxdWVzdEFuaW1hdGlvbkZyYW1lICovXHJcbiAgICBGUkFNRV9SRVFVRVNUX1hSID0gXCJmcmFtZVJlcXVlc3RYUlwiLFxyXG4gICAgLyoqIExvb3AgY3ljbGVzIHdpdGggdGhlIGdpdmVuIGZyYW1lcmF0ZSBpbiB7QGxpbmsgVGltZS5nYW1lfSAqL1xyXG4gICAgVElNRV9HQU1FID0gXCJ0aW1lR2FtZVwiLFxyXG4gICAgLyoqIExvb3AgY3ljbGVzIHdpdGggdGhlIGdpdmVuIGZyYW1lcmF0ZSBpbiByZWFsdGltZSwgaW5kZXBlbmRlbnQgb2Yge0BsaW5rIFRpbWUuZ2FtZX0gKi9cclxuICAgIFRJTUVfUkVBTCA9IFwidGltZVJlYWxcIlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29yZSBsb29wIG9mIGEgRlVER0UgYXBwbGljYXRpb24uIEluaXRpYWxpemVzIGF1dG9tYXRpY2FsbHkgYW5kIG11c3QgYmUgc3RhcnRlZCBleHBsaWNpdGx5LlxyXG4gICAqIEl0IHRoZW4gZmlyZXMge0BsaW5rIEVWRU5ULkxPT1BfRlJBTUV9IHRvIGFsbCBhZGRlZCBsaXN0ZW5lcnMgYXQgZWFjaCBmcmFtZVxyXG4gICAqIFxyXG4gICAqIEBhdXRob3IgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgTG9vcCBleHRlbmRzIEV2ZW50VGFyZ2V0U3RhdGljIHtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZVN0YXJ0R2FtZTogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZVN0YXJ0UmVhbDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZUZyYW1lR2FtZTogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZUZyYW1lUmVhbDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSVGltZUZyYW1lU3RhcnRHYW1lOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJUaW1lRnJhbWVTdGFydFJlYWw6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyDGklRpbWVMYXN0RnJhbWVHYW1lQXZnOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgxpJUaW1lTGFzdEZyYW1lUmVhbEF2ZzogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIMaSRnJhbWVzOiBudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcnVubmluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbW9kZTogTE9PUF9NT0RFID0gTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1Q7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBpZEludGVydmFsbDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIGlkUmVxdWVzdDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgc3RhdGljIGZwc0Rlc2lyZWQ6IG51bWJlciA9IDMwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZnJhbWVzVG9BdmVyYWdlOiBudW1iZXIgPSAzMDtcclxuICAgIHByaXZhdGUgc3RhdGljIHN5bmNXaXRoQW5pbWF0aW9uRnJhbWU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKiogVGhlIGdhbWV0aW1lIHRoZSBsb29wIHdhcyBzdGFydGVkLCBvdmVyd3JpdHRlbiBhdCBlYWNoIHN0YXJ0ICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCB0aW1lU3RhcnRHYW1lKCk6IG51bWJlciB7IHJldHVybiBMb29wLsaSVGltZVN0YXJ0R2FtZTsgfVxyXG4gICAgLyoqIFRoZSByZWFsdGltZSB0aGUgbG9vcCB3YXMgc3RhcnRlZCwgb3ZlcndyaXR0ZW4gYXQgZWFjaCBzdGFydCAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgdGltZVN0YXJ0UmVhbCgpOiBudW1iZXIgeyByZXR1cm4gTG9vcC7GklRpbWVTdGFydFJlYWw7IH1cclxuICAgIC8qKiBUaGUgZ2FtZXRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBsb29wIGN5Y2xlICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCB0aW1lRnJhbWVHYW1lKCk6IG51bWJlciB7IHJldHVybiBMb29wLsaSVGltZUZyYW1lR2FtZTsgfVxyXG4gICAgLyoqIFRoZSByZWFsdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IGxvb3AgY3ljbGUgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IHRpbWVGcmFtZVJlYWwoKTogbnVtYmVyIHsgcmV0dXJuIExvb3AuxpJUaW1lRnJhbWVSZWFsOyB9XHJcbiAgICAvKiogVGhlIGdhbWV0aW1lIHRoZSBsYXN0IGxvb3AgY3ljbGUgc3RhcnRlZCovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCB0aW1lRnJhbWVTdGFydEdhbWUoKTogbnVtYmVyIHsgcmV0dXJuIExvb3AuxpJUaW1lRnJhbWVTdGFydEdhbWU7IH1cclxuICAgIC8qKiBUaGUgcmVhbHRpbWUgdGhlIGxhc3QgbG9vcCBjeWNsZSBzdGFydGVkKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IHRpbWVGcmFtZVN0YXJ0UmVhbCgpOiBudW1iZXIgeyByZXR1cm4gTG9vcC7GklRpbWVGcmFtZVN0YXJ0UmVhbDsgfVxyXG4gICAgLyoqIFRoZSBhdmVyYWdlIG51bWJlciBvZiBmcmFtZXMgcGVyIHNlY29uZCBpbiBnYW1ldGltZSAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgZnBzR2FtZUF2ZXJhZ2UoKTogbnVtYmVyIHsgcmV0dXJuIDEwMDAgLyBMb29wLsaSVGltZUxhc3RGcmFtZUdhbWVBdmc7IH1cclxuICAgIC8qKiBUaGUgYXZlcmFnZSBudW1iZXIgb2YgZnJhbWVzIHBlciBzZWNvbmQgaW4gcmVhbHRpbWUgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0IGZwc1JlYWxBdmVyYWdlKCk6IG51bWJlciB7IHJldHVybiAxMDAwIC8gTG9vcC7GklRpbWVMYXN0RnJhbWVSZWFsQXZnOyB9XHJcbiAgICAvKiogVGhlIG51bWJlciBvZiBmcmFtZXMgdHJpZ2dlcmVkIHNvIGZhciAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgZnJhbWVzKCk6IG51bWJlciB7IHJldHVybiBMb29wLsaSRnJhbWVzOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIGxvb3Agd2l0aCB0aGUgZ2l2ZW4gbW9kZSBhbmQgZnBzLiAgXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBmb3IgX21vZGUgaXMgRlJBTUVfUkVRVUVTVCwgc2VlIHtAbGluayBMT09QX01PREV9LCBob29raW5nIHRoZSBsb29wIHRvIHRoZSBicm93c2VyJ3MgYW5pbWF0aW9uIGZyYW1lLlxyXG4gICAgICogSXMgb25seSBhcHBsaWNhYmxlIGluIFRJTUUtbW9kZXMuXHJcbiAgICAgKiBfc3luY1dpdGhBbmltYXRpb25GcmFtZSBpcyBleHBlcmltZW50YWwgYW5kIG9ubHkgYXBwbGljYWJsZSBpbiBUSU1FLW1vZGVzLCBkZWZlcnJpbmcgdGhlIGxvb3AtY3ljbGUgdW50aWwgdGhlIG5leHQgcG9zc2libGUgYW5pbWF0aW9uIGZyYW1lLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHN0YXJ0KF9tb2RlOiBMT09QX01PREUgPSBMT09QX01PREUuRlJBTUVfUkVRVUVTVCwgX2ZwczogbnVtYmVyID0gNjAsIF9zeW5jV2l0aEFuaW1hdGlvbkZyYW1lOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgTG9vcC5zdG9wKCk7XHJcblxyXG4gICAgICBMb29wLsaSVGltZVN0YXJ0R2FtZSA9IFRpbWUuZ2FtZS5nZXQoKTtcclxuICAgICAgTG9vcC7GklRpbWVTdGFydFJlYWwgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgTG9vcC7GklRpbWVGcmFtZVN0YXJ0R2FtZSA9IExvb3AuxpJUaW1lU3RhcnRHYW1lO1xyXG4gICAgICBMb29wLsaSVGltZUZyYW1lU3RhcnRSZWFsID0gTG9vcC7GklRpbWVTdGFydFJlYWw7XHJcbiAgICAgIExvb3AuZnBzRGVzaXJlZCA9IChfbW9kZSA9PSBMT09QX01PREUuRlJBTUVfUkVRVUVTVCkgPyA2MCA6IF9mcHM7XHJcbiAgICAgIExvb3AuZnJhbWVzVG9BdmVyYWdlID0gTG9vcC5mcHNEZXNpcmVkO1xyXG4gICAgICBMb29wLsaSVGltZUxhc3RGcmFtZUdhbWVBdmcgPSBMb29wLsaSVGltZUxhc3RGcmFtZVJlYWxBdmcgPSAxMDAwIC8gTG9vcC5mcHNEZXNpcmVkO1xyXG4gICAgICBMb29wLm1vZGUgPSBfbW9kZTtcclxuICAgICAgTG9vcC5zeW5jV2l0aEFuaW1hdGlvbkZyYW1lID0gX3N5bmNXaXRoQW5pbWF0aW9uRnJhbWU7XHJcblxyXG4gICAgICBsZXQgbG9nOiBzdHJpbmcgPSBgTG9vcCBzdGFydGluZyBpbiBtb2RlICR7TG9vcC5tb2RlfWA7XHJcbiAgICAgIGlmIChMb29wLm1vZGUgIT0gTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1QpXHJcbiAgICAgICAgbG9nICs9IGAgd2l0aCBhdHRlbXB0ZWQgJHtfZnBzfSBmcHNgO1xyXG4gICAgICBEZWJ1Zy5mdWRnZShsb2cpO1xyXG5cclxuICAgICAgc3dpdGNoIChfbW9kZSkge1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1Q6XHJcbiAgICAgICAgICBMb29wLmxvb3BGcmFtZSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBMT09QX01PREUuRlJBTUVfUkVRVUVTVF9YUjpcclxuICAgICAgICAgIExvb3AubG9vcEZyYW1lWFIoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLlRJTUVfUkVBTDpcclxuICAgICAgICAgIExvb3AuaWRJbnRlcnZhbGwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoTG9vcC5sb29wVGltZSwgMTAwMCAvIExvb3AuZnBzRGVzaXJlZCk7XHJcbiAgICAgICAgICBMb29wLmxvb3BUaW1lKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIExPT1BfTU9ERS5USU1FX0dBTUU6XHJcbiAgICAgICAgICBMb29wLmlkSW50ZXJ2YWxsID0gVGltZS5nYW1lLnNldFRpbWVyKDEwMDAgLyBMb29wLmZwc0Rlc2lyZWQsIDAsIExvb3AubG9vcFRpbWUpO1xyXG4gICAgICAgICAgTG9vcC5sb29wVGltZSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBMb29wLnJ1bm5pbmcgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgdGhlIGxvb3BcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBzdG9wKCk6IHZvaWQge1xyXG4gICAgICBpZiAoIUxvb3AucnVubmluZylcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBzd2l0Y2ggKExvb3AubW9kZSkge1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLkZSQU1FX1JFUVVFU1Q6XHJcbiAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoTG9vcC5pZFJlcXVlc3QpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBMT09QX01PREUuRlJBTUVfUkVRVUVTVF9YUjpcclxuICAgICAgICAgIFhSVmlld3BvcnQuZGVmYXVsdC5zZXNzaW9uLmNhbmNlbEFuaW1hdGlvbkZyYW1lKExvb3AuaWRSZXF1ZXN0KTtcclxuICAgICAgICAgIFhSVmlld3BvcnQuZGVmYXVsdC5zZXNzaW9uID0gbnVsbDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLlRJTUVfUkVBTDpcclxuICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKExvb3AuaWRJbnRlcnZhbGwpO1xyXG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKExvb3AuaWRSZXF1ZXN0KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTE9PUF9NT0RFLlRJTUVfR0FNRTpcclxuICAgICAgICAgIFRpbWUuZ2FtZS5kZWxldGVUaW1lcihMb29wLmlkSW50ZXJ2YWxsKTtcclxuICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShMb29wLmlkUmVxdWVzdCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIExvb3AucnVubmluZyA9IGZhbHNlO1xyXG4gICAgICBEZWJ1Zy5mdWRnZShcIkxvb3Agc3RvcHBlZCFcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb250aW51ZSBydW5uaW5nIHRoZSBsb29wXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgY29udGludWUoKTogdm9pZCB7XHJcbiAgICAgIGlmIChMb29wLnJ1bm5pbmcpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgTG9vcC5zdGFydChMb29wLm1vZGUsIExvb3AuZnBzRGVzaXJlZCwgTG9vcC5zeW5jV2l0aEFuaW1hdGlvbkZyYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBsb29wKCk6IHZvaWQge1xyXG4gICAgICBsZXQgdGltZTogbnVtYmVyO1xyXG4gICAgICB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgIExvb3AuxpJUaW1lRnJhbWVSZWFsID0gdGltZSAtIExvb3AuxpJUaW1lRnJhbWVTdGFydFJlYWw7XHJcbiAgICAgIExvb3AuxpJUaW1lRnJhbWVTdGFydFJlYWwgPSB0aW1lO1xyXG5cclxuICAgICAgdGltZSA9IFRpbWUuZ2FtZS5nZXQoKTtcclxuICAgICAgTG9vcC7GklRpbWVGcmFtZUdhbWUgPSB0aW1lIC0gTG9vcC7GklRpbWVGcmFtZVN0YXJ0R2FtZTtcclxuICAgICAgTG9vcC7GklRpbWVGcmFtZVN0YXJ0R2FtZSA9IHRpbWU7XHJcblxyXG4gICAgICBMb29wLsaSVGltZUxhc3RGcmFtZUdhbWVBdmcgPSAoKExvb3AuZnJhbWVzVG9BdmVyYWdlIC0gMSkgKiBMb29wLsaSVGltZUxhc3RGcmFtZUdhbWVBdmcgKyBMb29wLsaSVGltZUZyYW1lR2FtZSkgLyBMb29wLmZyYW1lc1RvQXZlcmFnZTtcclxuICAgICAgTG9vcC7GklRpbWVMYXN0RnJhbWVSZWFsQXZnID0gKChMb29wLmZyYW1lc1RvQXZlcmFnZSAtIDEpICogTG9vcC7GklRpbWVMYXN0RnJhbWVSZWFsQXZnICsgTG9vcC7GklRpbWVGcmFtZVJlYWwpIC8gTG9vcC5mcmFtZXNUb0F2ZXJhZ2U7XHJcblxyXG4gICAgICAvLyBUT0RPOiBjb25zaWRlciBMb29wRXZlbnQgd2hpY2ggY29udmV5cyBpbmZvcm1hdGlvbiBzdWNoIGFzIHRpbWVFbGFwc2VkIGV0Yy4uLlxyXG4gICAgICBMb29wLsaSRnJhbWVzKys7XHJcbiAgICAgIGNvbnN0IGV2ZW50OiBSZWN5Y2xhYmxlRXZlbnQgPSBSZWN5Y2xhYmxlRXZlbnQuZ2V0KEVWRU5ULkxPT1BfRlJBTUUpO1xyXG4gICAgICBMb29wLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICBSZWN5Y2xhYmxlRXZlbnQuc3RvcmUoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGxvb3BGcmFtZSgpOiB2b2lkIHtcclxuICAgICAgTG9vcC5sb29wKCk7XHJcbiAgICAgIExvb3AuaWRSZXF1ZXN0ID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShMb29wLmxvb3BGcmFtZSk7XHJcbiAgICB9XHJcbiAgICBwcml2YXRlIHN0YXRpYyBsb29wRnJhbWVYUihfdGltZTogbnVtYmVyID0gbnVsbCwgX3hyRnJhbWU6IFhSRnJhbWUgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgIExvb3AubG9vcCgpO1xyXG4gICAgICBYUlZpZXdwb3J0LmRlZmF1bHQuZHJhdyh0cnVlLCBfeHJGcmFtZSk7XHJcbiAgICAgIExvb3AuaWRSZXF1ZXN0ID0gWFJWaWV3cG9ydC5kZWZhdWx0LnNlc3Npb24ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKExvb3AubG9vcEZyYW1lWFIpO1xyXG4gICAgfVxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgbG9vcFRpbWUoKTogdm9pZCB7XHJcbiAgICAgIGlmIChMb29wLnN5bmNXaXRoQW5pbWF0aW9uRnJhbWUpXHJcbiAgICAgICAgTG9vcC5pZFJlcXVlc3QgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKExvb3AubG9vcCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBMb29wLmxvb3AoKTtcclxuICAgIH1cclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgRnVkZ2VDb3JlIHtcclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBUaW1lVW5pdHMge1xyXG4gICAgaG91cnM/OiBudW1iZXI7XHJcbiAgICBtaW51dGVzPzogbnVtYmVyO1xyXG4gICAgc2Vjb25kcz86IG51bWJlcjtcclxuICAgIHRlbnRocz86IG51bWJlcjtcclxuICAgIGh1bmRyZWRzPzogbnVtYmVyO1xyXG4gICAgdGhvdXNhbmRzPzogbnVtYmVyO1xyXG4gICAgZnJhY3Rpb24/OiBudW1iZXI7XHJcbiAgICBhc0hvdXJzPzogbnVtYmVyO1xyXG4gICAgYXNNaW51dGVzPzogbnVtYmVyO1xyXG4gICAgYXNTZWNvbmRzPzogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBUaW1lcnMgZXh0ZW5kcyBPYmplY3Qge1xyXG4gICAgW2lkOiBudW1iZXJdOiBUaW1lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGdlbmVyYXRlIGEgdGltZXN0YW1wIHRoYXQgY29ycmVsYXRlcyB3aXRoIHRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtIGJ1dCBhbGxvd3MgZm9yIHJlc2V0dGluZyBhbmQgc2NhbGluZy4gIFxyXG4gICAqIFN1cHBvcnRzIHtAbGluayBUaW1lcn1zIHNpbWlsYXIgdG8gd2luZG93LnNldEludGVydmFsIGJ1dCB3aXRoIHJlc3BlY3QgdG8gdGhlIHNjYWxlZCB0aW1lLlxyXG4gICAqIEFsbCB0aW1lIHZhbHVlcyBhcmUgZ2l2ZW4gaW4gbWlsbGlzZWNvbmRzXHJcbiAgICogXHJcbiAgICogQGF1dGhvcnMgSmlya2EgRGVsbCdPcm8tRnJpZWRsLCBIRlUsIDIwMTlcclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgVGltZSBleHRlbmRzIEV2ZW50VGFyZ2V0VW5pZmllZCB7XHJcbiAgICAvKiogU3RhbmRhcmQgZ2FtZSB0aW1lIHN0YXJ0aW5nIGF1dG9tYXRpY2FsbHkgd2l0aCB0aGUgYXBwbGljYXRpb24gKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgZ2FtZTogVGltZSA9IG5ldyBUaW1lKCk7XHJcbiAgICBwcml2YXRlIHN0YXJ0OiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHNjYWxlOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIG9mZnNldDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBsYXN0Q2FsbFRvRWxhcHNlZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSB0aW1lcnM6IFRpbWVycyA9IHt9O1xyXG4gICAgcHJpdmF0ZSBpZFRpbWVyQWRkZWRMYXN0OiBudW1iZXIgPSAwO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICB0aGlzLnNjYWxlID0gMS4wO1xyXG4gICAgICB0aGlzLm9mZnNldCA9IDAuMDtcclxuICAgICAgdGhpcy5sYXN0Q2FsbFRvRWxhcHNlZCA9IDAuMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgcmVwcmVzZW50aW9ucyBvZiB0aGUgdGltZSBnaXZlbiBpbiBtaWxsaXNlY29uZHMgaW4gdmFyaW91cyBmb3JtYXRzIGRlZmluZWQgaW4ge0BsaW5rIFRpbWVVbml0c31cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRVbml0cyhfbWlsbGlzZWNvbmRzOiBudW1iZXIpOiBUaW1lVW5pdHMge1xyXG4gICAgICBsZXQgdW5pdHM6IFRpbWVVbml0cyA9IHt9O1xyXG5cclxuICAgICAgdW5pdHMuYXNTZWNvbmRzID0gX21pbGxpc2Vjb25kcyAvIDEwMDA7XHJcbiAgICAgIHVuaXRzLmFzTWludXRlcyA9IHVuaXRzLmFzU2Vjb25kcyAvIDYwO1xyXG4gICAgICB1bml0cy5hc0hvdXJzID0gdW5pdHMuYXNNaW51dGVzIC8gNjA7XHJcblxyXG4gICAgICB1bml0cy5ob3VycyA9IE1hdGguZmxvb3IodW5pdHMuYXNIb3Vycyk7XHJcbiAgICAgIHVuaXRzLm1pbnV0ZXMgPSBNYXRoLmZsb29yKHVuaXRzLmFzTWludXRlcykgJSA2MDtcclxuICAgICAgdW5pdHMuc2Vjb25kcyA9IE1hdGguZmxvb3IodW5pdHMuYXNTZWNvbmRzKSAlIDYwO1xyXG5cclxuICAgICAgdW5pdHMuZnJhY3Rpb24gPSBfbWlsbGlzZWNvbmRzICUgMTAwMDtcclxuICAgICAgdW5pdHMudGhvdXNhbmRzID0gX21pbGxpc2Vjb25kcyAlIDEwO1xyXG4gICAgICB1bml0cy5odW5kcmVkcyA9IF9taWxsaXNlY29uZHMgJSAxMDAgLSB1bml0cy50aG91c2FuZHM7XHJcbiAgICAgIHVuaXRzLnRlbnRocyA9IHVuaXRzLmZyYWN0aW9uIC0gdW5pdHMuaHVuZHJlZHMgLSB1bml0cy50aG91c2FuZHM7XHJcblxyXG4gICAgICByZXR1cm4gdW5pdHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jcmVnaW9uIEdldC9TZXQgdGltZSBhbmQgc2NhbGluZ1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgc2NhbGVkIHRpbWVzdGFtcCBvZiB0aGlzIGluc3RhbmNlIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0KCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldCArIHRoaXMuc2NhbGUgKiAocGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnN0YXJ0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlbWFpbmluZyB0aW1lIHRvIHRoZSBnaXZlbiBwb2ludCBvZiB0aW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRSZW1haW5kZXIoX3RvOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gX3RvIC0gdGhpcy5nZXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIChSZS0pIFNldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGlzIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgVGhlIHRpbWVzdGFtcCB0byByZXByZXNlbnQgdGhlIGN1cnJlbnQgdGltZSAoZGVmYXVsdCAwLjApXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQoX3RpbWU6IG51bWJlciA9IDApOiB2b2lkIHtcclxuICAgICAgdGhpcy5vZmZzZXQgPSBfdGltZTtcclxuICAgICAgdGhpcy5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICB0aGlzLmdldEVsYXBzZWRTaW5jZVByZXZpb3VzQ2FsbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc2NhbGluZyBvZiB0aGlzIHRpbWUsIGFsbG93aW5nIGZvciBzbG93bW90aW9uICg8MSkgb3IgZmFzdGZvcndhcmQgKD4xKSBcclxuICAgICAqIEBwYXJhbSBfc2NhbGUgVGhlIGRlc2lyZWQgc2NhbGluZyAoZGVmYXVsdCAxLjApXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRTY2FsZShfc2NhbGU6IG51bWJlciA9IDEuMCk6IHZvaWQge1xyXG4gICAgICB0aGlzLnNldCh0aGlzLmdldCgpKTtcclxuICAgICAgdGhpcy5zY2FsZSA9IF9zY2FsZTtcclxuICAgICAgLy9UT0RPOiBjYXRjaCBzY2FsZT0wXHJcbiAgICAgIHRoaXMucmVzY2FsZUFsbFRpbWVycygpO1xyXG4gICAgICB0aGlzLmdldEVsYXBzZWRTaW5jZVByZXZpb3VzQ2FsbCgpO1xyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWRU5ULlRJTUVfU0NBTEVEKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgc2NhbGluZyBvZiB0aGlzIHRpbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFNjYWxlKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBvZmZzZXQgb2YgdGhpcyB0aW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRPZmZzZXQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBzY2FsZWQgdGltZSBpbiBtaWxsaXNlY29uZHMgcGFzc2VkIHNpbmNlIHRoZSBsYXN0IGNhbGwgdG8gdGhpcyBtZXRob2RcclxuICAgICAqIEF1dG9tYXRpY2FsbHkgcmVzZXQgYXQgZXZlcnkgY2FsbCB0byBzZXQoLi4uKSBhbmQgc2V0U2NhbGUoLi4uKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0RWxhcHNlZFNpbmNlUHJldmlvdXNDYWxsKCk6IG51bWJlciB7XHJcbiAgICAgIGxldCBjdXJyZW50OiBudW1iZXIgPSB0aGlzLmdldCgpO1xyXG4gICAgICBsZXQgZWxhcHNlZDogbnVtYmVyID0gY3VycmVudCAtIHRoaXMubGFzdENhbGxUb0VsYXBzZWQ7XHJcbiAgICAgIHRoaXMubGFzdENhbGxUb0VsYXBzZWQgPSBjdXJyZW50O1xyXG4gICAgICByZXR1cm4gZWxhcHNlZDtcclxuICAgIH1cclxuICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuXHJcbiAgICAvLyNyZWdpb24gVGltZXJzXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBQcm9taXNlPHZvaWQ+IHRvIGJlIHJlc29sdmVkIGFmdGVyIHRoZSB0aW1lIGdpdmVuLiBUbyBiZSB1c2VkIHdpdGggYXN5bmMvYXdhaXRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGRlbGF5KF9sYXBzZTogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShfcmVzb2x2ZSA9PiB0aGlzLnNldFRpbWVyKF9sYXBzZSwgMSwgKCkgPT4gX3Jlc29sdmUoKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IGV4YW1pbmUgaWYgd2ViLXdvcmtlcnMgd291bGQgZW5oYW5jZSBwZXJmb3JtYW5jZSBoZXJlIVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBhbmQgZGVsZXRlcyBhbGwge0BsaW5rIFRpbWVyfXMgYXR0YWNoZWQuIFNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIHRoaXMgVGltZS1vYmplY3QgbGVhdmVzIHNjb3BlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbGVhckFsbFRpbWVycygpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy50aW1lcnMpIHtcclxuICAgICAgICB0aGlzLmRlbGV0ZVRpbWVyKE51bWJlcihpZCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHtAbGluayBUaW1lcn0gZm91bmQgdXNpbmcgdGhlIGludGVybmFsIGlkIG9mIHRoZSBjb25uZWN0ZWQgaW50ZXJ2YWwtb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gX2lkIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVsZXRlVGltZXJCeUl0c0ludGVybmFsSWQoX2lkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy50aW1lcnMpIHtcclxuICAgICAgICBsZXQgdGltZXI6IFRpbWVyID0gdGhpcy50aW1lcnNbaWRdO1xyXG4gICAgICAgIGlmICh0aW1lci5pZCA9PSBfaWQpIHtcclxuICAgICAgICAgIHRpbWVyLmNsZWFyKCk7XHJcbiAgICAgICAgICBkZWxldGUgdGhpcy50aW1lcnNbaWRdO1xyXG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgaWYgYW4gZWFybHkgb3V0IGlzIE9LIGhlcmUuLi4gc2hvdWxkIGJlIVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFsbHMgYSB0aW1lciBhdCB0aGlzIHRpbWUgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gX2xhcHNlIFRoZSBvYmplY3QtdGltZSB0byBlbGFwc2UgYmV0d2VlbiB0aGUgY2FsbHMgdG8gX2NhbGxiYWNrXHJcbiAgICAgKiBAcGFyYW0gX2NvdW50IFRoZSBudW1iZXIgb2YgY2FsbHMgZGVzaXJlZCwgMCA9IEluZmluaXRlXHJcbiAgICAgKiBAcGFyYW0gX2hhbmRsZXIgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZWFjaCB0aGUgZ2l2ZW4gbGFwc2UgaGFzIGVsYXBzZWRcclxuICAgICAqIEBwYXJhbSBfYXJndW1lbnRzIEFkZGl0aW9uYWwgcGFyYW1ldGVycyB0byBwYXNzIHRvIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRUaW1lcihfbGFwc2U6IG51bWJlciwgX2NvdW50OiBudW1iZXIsIF9oYW5kbGVyOiBUaW1lckhhbmRsZXIsIC4uLl9hcmd1bWVudHM6IE9iamVjdFtdKTogbnVtYmVyIHtcclxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby11bnVzZWQtZXhwcmVzc2lvblxyXG4gICAgICBuZXcgVGltZXIodGhpcywgX2xhcHNlLCBfY291bnQsIF9oYW5kbGVyLCAuLi5fYXJndW1lbnRzKTsgLy8gVE9ETzogcmV1c2UgdGltZSBpbnN0YW5jZXMgdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uXHJcbiAgICAgIC8vdGhpcy5hZGRUaW1lcih0aW1lcik7XHJcbiAgICAgIHJldHVybiB0aGlzLmlkVGltZXJBZGRlZExhc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgaW50ZXJuYWxseSBieSB7QGxpbmsgVGltZX0gYW5kIHtAbGluayBUaW1lcn0gYW5kIG11c3Qgbm90IGJlIGNhbGxlZCBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZFRpbWVyKF90aW1lcjogVGltZXIpOiBudW1iZXIge1xyXG4gICAgICB0aGlzLnRpbWVyc1srK3RoaXMuaWRUaW1lckFkZGVkTGFzdF0gPSBfdGltZXI7XHJcbiAgICAgIHJldHVybiB0aGlzLmlkVGltZXJBZGRlZExhc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSB0aW1lciB3aXRoIHRoZSBpZCBnaXZlbiBieSB0aGlzIHRpbWUgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkZWxldGVUaW1lcihfaWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBsZXQgdGltZXI6IFRpbWVyID0gdGhpcy50aW1lcnNbX2lkXTtcclxuICAgICAgaWYgKCF0aW1lcilcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIHRpbWVyLmNsZWFyKCk7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLnRpbWVyc1tfaWRdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgdGltZXIgd2l0aCB0aGUgZ2l2ZW4gaWQgb3IgbnVsbCBpZiBub3QgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUaW1lcihfaWQ6IG51bWJlcik6IFRpbWVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMudGltZXJzW19pZF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCBvZiB0aW1lcnMgY3VycmVudGx5IGluc3RhbGxlZCBvbiB0aGlzIHRpbWUgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUaW1lcnMoKTogVGltZXJzIHtcclxuICAgICAgbGV0IHJlc3VsdDogVGltZXJzID0ge307XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlc3VsdCwgdGhpcy50aW1lcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSB7QGxpbmsgVGltZXJzfSBpbnN0YWxsZWQgdG8gdGhpc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaGFzVGltZXJzKCk6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gKE9iamVjdC5rZXlzKHRoaXMudGltZXJzKS5sZW5ndGggPiAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3JlYXRlcyB7QGxpbmsgVGltZXJ9cyB3aGVuIHNjYWxpbmcgY2hhbmdlc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlc2NhbGVBbGxUaW1lcnMoKTogdm9pZCB7XHJcbiAgICAgIGZvciAobGV0IGlkIGluIHRoaXMudGltZXJzKSB7XHJcbiAgICAgICAgbGV0IHRpbWVyOiBUaW1lciA9IHRoaXMudGltZXJzW2lkXTtcclxuICAgICAgICB0aW1lci5jbGVhcigpO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRpbWVyc1tpZF07XHJcbiAgICAgICAgaWYgKCF0aGlzLnNjYWxlKVxyXG4gICAgICAgICAgLy8gVGltZSBoYXMgc3RvcHBlZCwgbm8gbmVlZCB0byByZXBsYWNlIGNsZWFyZWQgdGltZXJzXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgLyogdGhpcy50aW1lcnNbaWRdID0gICovXHJcbiAgICAgICAgdGltZXIgPSB0aW1lci5pbnN0YWxsQ29weSgpOyAvLyB0aGUgdGltZXIgaXMgYXV0b21hdGljYWxseSBhZGRlZCB0byB0aGlzIHRpbWUgaW5zdGFuY2VcclxuICAgICAgICBkZWxldGUgdGhpcy50aW1lcnNbdGhpcy5pZFRpbWVyQWRkZWRMYXN0XTsgLy8gcmVtb3ZlIHRoZSBjb3B5IGFnYWluIC4uLlxyXG4gICAgICAgIHRoaXMudGltZXJzW2lkXSA9IHRpbWVyOyAvLyAuLi4gYW5kIHBsYWNlIGl0IGF0IHRoZSBpZCBvZiB0aGUgb3JpZ2luYWxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvLyNlbmRyZWdpb25cclxufSIsIm5hbWVzcGFjZSBGdWRnZUNvcmUge1xyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgdGhlIHNpZ25hdHVyZSBvZiBoYW5kbGVyIGZ1bmN0aW9ucyBmb3Ige0BsaW5rIEV2ZW50VGltZXJ9cywgdmVyeSBzaW1pbGFyIHRvIHVzdWFsIGV2ZW50IGhhbmRsZXJcclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBUaW1lckhhbmRsZXIgPSAoX2V2ZW50OiBFdmVudFRpbWVyKSA9PiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiBBIHtAbGluayBUaW1lcn0taW5zdGFuY2UgaW50ZXJuYWxseSB1c2VzIHdpbmRvdy5zZXRJbnRlcnZhbCB0byBjYWxsIGEgZ2l2ZW4gaGFuZGxlciB3aXRoIGEgZ2l2ZW4gZnJlcXVlbmN5IGEgZ2l2ZW4gbnVtYmVyIG9mIHRpbWVzLFxyXG4gICAqIHBhc3NpbmcgYW4ge0BsaW5rIEV2ZW50VGltZXJ9LWluc3RhbmNlIHdpdGggYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhbmQgZ2l2ZW4gYXJndW1lbnRzLiBcclxuICAgKiBUaGUgZnJlcXVlbmN5IHNjYWxlcyB3aXRoIHRoZSB7QGxpbmsgVGltZX0taW5zdGFuY2UgdGhlIHtAbGluayBUaW1lcn0taW5zdGFuY2UgaXMgYXR0YWNoZWQgdG8uXHJcbiAgICogXHJcbiAgICogQGF1dGhvciBKaXJrYSBEZWxsJ09yby1GcmllZGwsIEhGVSwgMjAxOVxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBUaW1lciB7XHJcbiAgICBwdWJsaWMgYWN0aXZlOiBib29sZWFuO1xyXG4gICAgcHVibGljIGNvdW50OiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGhhbmRsZXI6IFRpbWVySGFuZGxlcjtcclxuICAgIHByaXZhdGUgdGltZTogVGltZTtcclxuICAgIHByaXZhdGUgZWxhcHNlOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGV2ZW50OiBFdmVudFRpbWVyO1xyXG4gICAgcHJpdmF0ZSB0aW1lb3V0UmVhbDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBpZFdpbmRvdzogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHtAbGluayBUaW1lcn0gaW5zdGFuY2UuXHJcbiAgICAgKiBAcGFyYW0gX3RpbWUgVGhlIHtAbGluayBUaW1lfSBpbnN0YW5jZSwgdGhlIHRpbWVyIGF0dGFjaGVzIHRvXHJcbiAgICAgKiBAcGFyYW0gX2VsYXBzZSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gZWxhcHNlLCB0byB0aGUgbmV4dCBjYWxsIG9mIF9oYW5kbGVyLCBtZWFzdXJlZCBpbiBfdGltZVxyXG4gICAgICogQHBhcmFtIF9jb3VudCBUaGUgZGVzaXJlZCBudW1iZXIgb2YgY2FsbHMgdG8gX2hhbmRsZXIsIFRpbWVyIGRlaW5zdGFsbHMgYXV0b21hdGljYWxseSBhZnRlciBsYXN0IGNhbGwuIFBhc3NpbmcgMCBpbnZva2VzIGluZmluaXRlIGNhbGxzXHJcbiAgICAgKiBAcGFyYW0gX2hhbmRsZXIgVGhlIHtAbGluayBUaW1lckhhbmRsZXJ9IGluc3RhbmNlIHRvIGNhbGxcclxuICAgICAqIEBwYXJhbSBfYXJndW1lbnRzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gX2hhbmRsZXJcclxuICAgICAqIFxyXG4gICAgICogVE9ETzogZm9yIHByb3BlciBoYW5kbGluZyBhbmQgZGVsZXRpb24sIHVzZSBUaW1lLnNldFRpbWVyIGluc3RlYWQgb2YgaW5zdGFudGlhdGluZyB0aW1lcnMgeW91cnNlbGYuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihfdGltZTogVGltZSwgX2VsYXBzZTogbnVtYmVyLCBfY291bnQ6IG51bWJlciwgX2hhbmRsZXI6IFRpbWVySGFuZGxlciwgLi4uX2FyZ3VtZW50czogT2JqZWN0W10pIHtcclxuICAgICAgdGhpcy50aW1lID0gX3RpbWU7XHJcbiAgICAgIHRoaXMuZWxhcHNlID0gX2VsYXBzZTtcclxuICAgICAgdGhpcy5ldmVudCA9IG5ldyBFdmVudFRpbWVyKHRoaXMsIC4uLl9hcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLmhhbmRsZXIgPSBfaGFuZGxlcjtcclxuICAgICAgdGhpcy5jb3VudCA9IF9jb3VudDtcclxuXHJcbiAgICAgIGxldCBzY2FsZTogbnVtYmVyID0gTWF0aC5hYnMoX3RpbWUuZ2V0U2NhbGUoKSk7XHJcblxyXG4gICAgICBpZiAoIXNjYWxlKSB7XHJcbiAgICAgICAgLy8gVGltZSBpcyBzdG9wcGVkLCB0aW1lciB3b24ndCBiZSBhY3RpdmVcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy50aW1lb3V0UmVhbCA9IHRoaXMuZWxhcHNlIC8gc2NhbGU7XHJcblxyXG4gICAgICBsZXQgY2FsbGJhY2s6IEZ1bmN0aW9uID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXHJcbiAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnQuY291bnQgPSB0aGlzLmNvdW50O1xyXG4gICAgICAgIHRoaXMuZXZlbnQubGFzdENhbGwgPSAodGhpcy5jb3VudCA9PSAxKTtcclxuICAgICAgICBfaGFuZGxlcih0aGlzLmV2ZW50KTtcclxuICAgICAgICB0aGlzLmV2ZW50LmZpcnN0Q2FsbCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5jb3VudCA+IDApXHJcbiAgICAgICAgICBpZiAoLS10aGlzLmNvdW50ID09IDApXHJcbiAgICAgICAgICAgIF90aW1lLmRlbGV0ZVRpbWVyQnlJdHNJbnRlcm5hbElkKHRoaXMuaWRXaW5kb3cpO1xyXG5cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuaWRXaW5kb3cgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIHRoaXMudGltZW91dFJlYWwsIC4uLl9hcmd1bWVudHMpO1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgIF90aW1lLmFkZFRpbWVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgd2luZG93LWlkIG9mIHRoZSB0aW1lciwgd2hpY2ggd2FzIHJldHVybmVkIGJ5IHNldEludGVydmFsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgaWQoKTogbnVtYmVyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaWRXaW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0aW1lLWludGVydmFsbCBmb3IgY2FsbHMgdG8gdGhlIGhhbmRsZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBsYXBzZSgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5lbGFwc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2hlcyBhIGNvcHkgb2YgdGhpcyBhdCBpdHMgY3VycmVudCBzdGF0ZSB0byB0aGUgc2FtZSB7QGxpbmsgVGltZX0taW5zdGFuY2UuIFVzZWQgaW50ZXJuYWxseSB3aGVuIHJlc2NhbGluZyB7QGxpbmsgVGltZX1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGluc3RhbGxDb3B5KCk6IFRpbWVyIHtcclxuICAgICAgcmV0dXJuIG5ldyBUaW1lcih0aGlzLnRpbWUsIHRoaXMuZWxhcHNlLCB0aGlzLmNvdW50LCB0aGlzLmhhbmRsZXIsIHRoaXMuZXZlbnQuYXJndW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgdGltZXIsIHJlbW92aW5nIGl0IGZyb20gdGhlIGludGVydmFsLXRpbWVycyBoYW5kbGVkIGJ5IHdpbmRvd1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgIC8vIGlmICh0aGlzLnR5cGUgPT0gVElNRVJfVFlQRS5USU1FT1VUKSB7XHJcbiAgICAgIC8vICAgICBpZiAodGhpcy5hY3RpdmUpXHJcbiAgICAgIC8vICAgICAgICAgLy8gc2F2ZSByZW1haW5pbmcgdGltZSB0byB0aW1lb3V0IGFzIG5ldyB0aW1lb3V0IGZvciByZXN0YXJ0XHJcbiAgICAgIC8vICAgICAgICAgdGhpcy50aW1lb3V0ID0gdGhpcy50aW1lb3V0ICogKDEgLSAocGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnN0YXJ0VGltZVJlYWwpIC8gdGhpcy50aW1lb3V0UmVhbCk7XHJcbiAgICAgIC8vICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuaWQpO1xyXG4gICAgICAvLyB9XHJcbiAgICAgIC8vIGVsc2VcclxuICAgICAgLy8gVE9ETzogcmV1c2luZyB0aW1lciBzdGFydHMgaW50ZXJ2YWwgYW5ldy4gU2hvdWxkIGJlIHJlbWFpbmluZyBpbnRlcnZhbCBhcyB0aW1lb3V0LCB0aGVuIHN0YXJ0aW5nIGludGVydmFsIGFuZXcgXHJcbiAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuaWRXaW5kb3cpO1xyXG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxufSJdfQ==